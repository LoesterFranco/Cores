Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 1
noc_boot.a

                                        ; ============================================================================
                                        ;        __
                                        ;   \\__/ o\    (C) 2017  Robert Finch, Waterloo
                                        ;    \  __ /    All rights reserved.
                                        ;     \/_//     robfinch<remove>@finitron.ca
                                        ;       ||
                                        ;  
                                        ;
                                        ; This source file is free software: you can redistribute it and/or modify 
                                        ; it under the terms of the GNU Lesser General Public License as published 
                                        ; by the Free Software Foundation, either version 3 of the License, or     
                                        ; (at your option) any later version.                                      
                                        ;                                                                          
                                        ; This source file is distributed in the hope that it will be useful,      
                                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                                        ; GNU General Public License for more details.                             
                                        ;                                                                          
                                        ; You should have received a copy of the GNU General Public License        
                                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                                        ;                                    
                                        ;                                      
                                        ; This boot rom for an ordinary node.
                                        ; ============================================================================
                                        ;
     26 = 0D                            CR	= 13
     27 = 0A                            LF	= 10
     28 = 09                            CTRLH	equ		9
     29 = 20                            txBuf	equ		32
     30 = 30                            rxBuf	equ		48
                                        
     32 = 01                            MT_RST		equ		1
     33 = 02                            MT_RST_ACK	equ		2
     34 = 03                            MT_STOP		equ		3
     35 = 04                            MT_KEYSTROKE			equ	4
     36 = 05                            MT_SET_INPUT_FOCUS		equ	5
     37 = 06                            MT_BUTTON_STATUS		equ	6
     38 = 07                            MT_REQ_INP_FOCUS		equ	7
     39 = 08                            MT_GRNT_INP_FOCUS		equ 8
     40 = 09                            MT_PING					equ	9
     41 = 0A                            MT_START_BASIC_LOAD		equ	10
     42 = 0B                            MT_LOAD_BASIC_CHAR		equ	11
     43 = 0C                            MT_RUN_BASIC_PROG		equ	12
     44 = 0D                            MT_BASIC_EXIT			equ	13
     45 = 0F                            MT_REQ_OUT_FOCUS		equ	15
     46 = 10                            MT_GRNT_OUT_FOCUS		equ	16
     47 = 11                            MT_OUT_CHAR				equ	17
     48 = 12                            MT_PING_ACK				equ	18
     49 = 13                            MT_ETH_PACKET			equ	19
                                        
                                        
     52 = 000000000000B000                              ROUTER		equ	$B000
     53 = 10                            RTR_RXSTAT	equ	$10
     54 = 12                            RTR_TXSTAT	equ	$12
                                        
     56 = 00                            ROUTER_TRB	equ	0
                                        
     58 = 0F                            MSG_DST		equ	15
     59 = 0E                            MSG_SRC		equ	14
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 2
noc_boot.a
     60 = 09                            MSG_TTL		equ	9
     61 = 08                            MSG_TYPE	equ	8
                                        
                                        		.code
                                        		cpu		Butterfly16
                                        		org		0xE000
                                        ; ============================================================================
                                        ;        __
                                        ;   \\__/ o\    (C) 2017  Robert Finch, Waterloo
                                        ;    \  __ /    All rights reserved.
                                        ;     \/_//     robfinch<remove>@finitron.ca
                                        ;       ||
                                        ;  
                                        ;
                                        ; This source file is free software: you can redistribute it and/or modify 
                                        ; it under the terms of the GNU Lesser General Public License as published 
                                        ; by the Free Software Foundation, either version 3 of the License, or     
                                        ; (at your option) any later version.                                      
                                        ;                                                                          
                                        ; This source file is distributed in the hope that it will be useful,      
                                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                                        ; GNU General Public License for more details.                             
                                        ;                                                                          
                                        ; You should have received a copy of the GNU General Public License        
                                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                                        ;                                    
                                        ;                                      
                                        ; Networking software components
                                        ; ============================================================================
                                        ;
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Zero out the transmit buffer.
                                        ; Used before building transmit buffer.
                                        ; Automatically inserts a time-to-live of 63, and the source id.
                                        ;
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	<none>
                                        ;----------------------------------------------------------------------------
                                        
    106 0000E000                        zeroTxBuf:
    107 0000E000 FE 6E                   		add		sp,sp,#-2
    108 0000E002 E0 D2                   		sw		r2,[sp]
    109 0000E004 00 40 0F 12             		lw		r2,#15
    110 0000E008                        zeroTxBuf1:
    111 0000E008 02 40 20 C0             		sb		r0,txBuf[r2]
    112 0000E00C FF 62                   		sub		r2,r2,#1
    113 0000E00E FC BB                   		bpl		zeroTxBuf1
    114 0000E010 03 40 0F 12             		lw		r2,#63
    115 0000E014 02 40 09 C2             		sb		r2,txBuf+MSG_TTL
    116 0000E018 E4 32                   		tsr		r2,ID
    117 0000E01A 02 40 0E C2             		sb		r2,txBuf+MSG_SRC
    118 0000E01E E0 F2                   		lw		r2,[sp]
    119 0000E020 02 6E                   		add		sp,sp,#2
    120 0000E022 F0 80                   		ret
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 3
noc_boot.a
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Transmit on the network.
                                        ; Blocks until the transmit buffer is open.
                                        ;
                                        ; Prerequisites:
                                        ;	The transmit buffer txBuf must have already been loaded.
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	<none>
                                        ;----------------------------------------------------------------------------
                                        
    136 0000E024 FC 6E                  Xmit:	
    137 0000E026 E0 D1                   		sw		r1,[sp]
    138 0000E028 E2 D2                   		sw		r2,2[sp]
                                        		; wait for transmit buffer to empty
    140 0000E02A                        Xmit2:
    141 0000E02A 01 4B 02 E1             		lb		r1,ROUTER+RTR_TXSTAT
    142 0000E02E FD B9                   		bne		Xmit2
    143 0000E030 00 40 0F 12             		lw		r2,#15
    144 0000E034                        Xmit1:
    145 0000E034 02 40 20 E1             		lb		r1,txBuf[r2]
    146 0000E038 00 4B 20 C1             		sb		r1,ROUTER[r2]
    147 0000E03C FF 62                   		add		r2,r2,#-1
    148 0000E03E FA BB                   		bpl		Xmit1
                                        		; trigger a transmit
    150 0000E040 01 11                   		lw		r1,#1
    151 0000E042 01 4B 02 C2             		sb		r2,ROUTER+RTR_TXSTAT
    152 0000E046 E2 F2                   		lw		r2,2[sp]
    153 0000E048 E0 F1                   		lw		r1,[sp]
    154 0000E04A 04 6E                   		add		sp,sp,#4
    155 0000E04C F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Receive from network.
                                        ; Receive status must have already indicated a message present.
                                        ; Copies recieve buffer from router to rxBuf.
                                        ; The router fifo is configured with first word fall-through. This means
                                        ; the data word appears on the fifo output before the fifo is popped.
                                        ; A fifo pop signal has to be sent after reading the data.
                                        ;
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	<none>
                                        ;----------------------------------------------------------------------------
                                        
    173 0000E04E                        Recv:
    174 0000E04E FC 6E                   		add		sp,sp,#-4
    175 0000E050 E0 D1                   		sw		r1,[sp]
    176 0000E052 E2 D2                   		sw		r2,2[sp]
    177 0000E054 00 40 0F 12             		lw		r2,#15
    178 0000E058                        Recv1:
    179 0000E058 00 4B 20 E1             		lb		r1,ROUTER[r2]			; copy message to local buffer
    180 0000E05C 03 40 20 C1             		sb		r1,rxBuf[r2]
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 4
noc_boot.a
    181 0000E060 FF 62                   		add		r2,r2,#-1
    182 0000E062 FA BB                   		bpl		Recv1
    183 0000E064 01 4B 00 E1             		lb		r1,ROUTER+RTR_RXSTAT
    184 0000E068 04 40 60 31             		or		r1,#$40
    185 0000E06C 01 4B 00 C1             		sb		r1,ROUTER+RTR_RXSTAT	; pop the rx fifo
    186 0000E070 E0 F1                   		lw		r1,[sp]
    187 0000E072 E2 F2                   		lw		r2,2[sp]
    188 0000E074 04 6E                   		add		sp,sp,#4
    189 0000E076 F0 80                   		ret
                                        
                                        ;****************************************************************;
                                        ;                                                                ;
                                        ;		Tiny BASIC Worker for the Finitron Butterfly             ;
                                        ;                                                                ;
                                        ; Supports worker threads.                                       ;
                                        ; There is no user interface to worker threads so the commands   ;
                                        ; LOAD and SAVE are removed.                                     ;
                                        ;                                                                ;
                                        ; Derived from a 68000 derivative of Palo Alto Tiny BASIC as     ;
                                        ; published in the May 1976 issue of Dr. Dobb's Journal.         ;
                                        ; Adapted to the 68000 by:                                       ;
                                        ;	Gordon brndly						                         ;
                                        ;	12147 - 51 Street					                         ;
                                        ;	Edmonton AB  T5W 3G8					                     ;
                                        ;	Canada							                             ;
                                        ;	(updated mailing address for 1996)			                 ;
                                        ;                                                                ;
                                        ; Adapted to the Butterfly by:                                    ;
                                        ;    Robert Finch                                                ;
                                        ;    Ontario, Canada                                             ;
                                        ;	 rob<remove>@finitron.ca                                     ;  
                                        ;****************************************************************;
                                        ;   Copyright (C) 2005-2017 by Robert Finch. This program may be ;
                                        ;    freely distributed for personal use only. All commercial	 ;
                                        ;		       rights are reserved.			                     ;
                                        ;****************************************************************;
                                        ;
                                        ; Register Usage
                                        ; r8 = text pointer (global usage)
                                        ; r3,r4 = inputs parameters to subroutines
                                        ; r2 = return value
                                        ;
                                        ;* Vers. 1.0  1984/7/17	- Original version by Gordon brndly
                                        ;*	1.1  1984/12/9	- Addition of '0x' print term by Marvin Lipford
                                        ;*	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                                        
                                        ;	OPT	FRS,BRS 	forward ref.'s & brnches default to short
                                        
                                        ;XMIT_FULL		equ	0x40		; the transmit buffer is full
                                        ;DATA_PRESENT	equ	0x08		; there is data preset at the serial port bc_uart3
    230 = 01                            DATA_PRESENT	equ	0x01		; there is data preset at the serial port bc_uart3
    231 = 20                            XMIT_NOT_FULL	equ	0x20
                                        
    233 = 00000000FFFFDC40                              TS_TIMER	equ		0xFFFFDC40		; system time slice timer
    234 = 00000000FFFFDC50                              KBD			equ		0xFFFFDC50
                                        
    236 = 00000000FFFFDCA0                              RAND		equ		0xFFFFDCA0
    237 = 00000000FFFFD800                              VIC			equ		0xFFFFD800
                                        
    239 = 2000                          VIDEORAM	equ		0x00002000
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 5
noc_boot.a
                                        
                                        ; BOOT ROM routines
                                        
    243 = 0000000FFFFFF804                              getSerial	equ		0xFFFFFF804	; get a serial port character
    244 = 0000000FFFFFF808                              peekSerial	equ		0xFFFFFF808	; get a serial port character
    245 = 0000000FFFFFF80C                              putSerial	equ		0xFFFFFF80C	; put a character to serial port
    246 = 0000000FFFFFF82C                              clearScreen	equ		0xFFFFFF82C	; clear the screen
    247 = 0000000FFFFFF840                              getKbdCharWait	equ	0xFFFFFF840
    248 = 0000000FFFFFF844                              getKbdChar		equ	0xFFFFFF844
                                        
    250 = 20                            warmStart   equ     0x20
    251 = 24                            usrJmp      equ     0x24
                                        
    253 = 0D                            CR		equ	0x0D		; ASCII equates
    254 = 0A                            LF		equ	0x0A
    255 = 09                            TAB		equ	0x09
    256 = 03                            CTRLC	equ	0x03
    257 = 08                            CTRLH	equ	0x08
    258 = 13                            CTRLS	equ	0x13
    259 = 18                            CTRLX	equ	0x18
                                        
    261 = 50                            BUFLEN	equ	80	;	length of keyboard input buffer
                                        
                                        	code
                                        ;	org	0xC000	;
                                        ;
                                        ; Standard jump table. You can change these addresses if you are
                                        ; customizing this interpreter for a different environment.
                                        ;
    270 0000E078 FF BE                  START	jmp	CSTART	;	Cold Start entry point
    271 0000E07A 26 AE                  GOWARM	jmp	WSTART	;	Warm Start entry point
    272 0000E07C 75 40 02 AE            GOOUT	jmp	OUTC	;	Jump to character-out routine
    273 0000E080 75 40 01 AE            GOIN	jmp	INC		;Jump to character-in routine
    274 0000E084 78 40 02 AE            GOAUXO	jmp	AUXOUT	;	Jump to auxiliary-out routine
    275 0000E088 79 40 0F AE            GOAUXI	jmp	AUXIN	;	Jump to auxiliary-in routine
    276 0000E08C 7D 40 01 AE            GOBYE	jmp	BYEBYE	;	Jump to monitor, DOS, etc.
                                        ;
                                        ; Modifiable system constants:
                                        ;
    280 0000E090 00 02                  TXTBGN	dw	0x0200		;beginning of program memory
    281 0000E092 00 1E                  ENDMEM	dw	0x1E00	;	end of available memory
                                        ;
    283 0000E094                        INITTBW:
                                        	; First save off the link register and OS sp value
    285 0000E094 FE 6E                   	sub		sp,sp,#2
    286 0000E096 E0 DF                   	sw		lr,[sp]
    287 0000E098 09 4E 00 F1             	lw		r1,TXTBGN	;	init. end-of-program pointer
    288 0000E09C 09 40 06 D1             	sw		r1,TXTUNF
    289 0000E0A0 09 4E 02 F1             	lw		r1,ENDMEM	;	get address of end of memory
    290 0000E0A4 E0 4F 10 11             	sub		r1,r1,#512	; 	reserve 512 bytes for the stack
    291 0000E0A8 0A 40 00 D1             	sw		r1,STKBOT
    292 0000E0AC E0 4F 10 11             	sub     r1,r1,#512 ;   128 vars
    293 0000E0B0 09 40 08 D1             	sw      r1,VARBGN
    294 0000E0B4 EB AF                   	call    clearVars   ; clear the variable area
    295 0000E0B6 08 40 0C D0             	sw		r0,LOPVAR   ; initialize internal variables
    296 0000E0BA 08 40 08 D0             	sw		r0,STKGOS
    297 0000E0BE 08 40 06 D0             	sw		r0,CURRNT	;	current line number pointer = 0
    298 0000E0C2 E0 FF                   	lw		lr,[sp]
    299 0000E0C4 02 6E                   	add		sp,sp,#2
    300 0000E0C6 F0 80                   	ret
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 6
noc_boot.a
                                        ;
                                        ; The main interpreter starts here:
                                        ;
                                        ; Usage
                                        ; r1 = temp
                                        ; r8 = text buffer pointer
                                        ; r12 = end of text in text buffer
                                        ;
                                        	; At the end of the running program it'll go back to
                                        	; the warm start location. Use this to return.
    311 0000E0C8                        WSTART
    312 0000E0C8 08 40 0C D0             	sw		r0,LOPVAR   ; initialize internal variables
    313 0000E0CC 08 40 08 D0             	sw		r0,STKGOS
    314 0000E0D0 08 40 06 D0             	sw		r0,CURRNT	;	current line number pointer = 0
    315 0000E0D4 08 40 04 FE             	lw		sp,OSSP
    316 0000E0D8 E0 FF                   	lw		lr,[sp]
    317 0000E0DA 02 6E                   	add		sp,sp,#2
    318 0000E0DC F0 80                   	ret
                                        
                                        	; Entry point which is called by the reciever dispatcher.
    321 0000E0DE                        ST3:
    322 0000E0DE FE 6E                   	add		sp,sp,#-2
    323 0000E0E0 E0 DF                   	sw		lr,[sp]
    324 0000E0E2 08 40 04 DE             	sw		sp,OSSP
    325 0000E0E6 09 4E 02 FE             	lw		sp,ENDMEM	;	init S.P.
    326 0000E0EA 6C 40 03 AF             	call	TOUPBUF 	; convert to upper case
    327 0000E0EE 80 1C                   	lw		r12,r8		; save pointer to end of line
    328 0000E0F0 0A 40 0E 18             	lea		r8,BUFFER	; point to the beginning of line
    329 0000E0F4 6F AE                   	br		DIRECT
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** Tables *** DIRECT *** EXEC ***
                                        ;
                                        ; This section of the code tests a string against a table. When
                                        ; a match is found, control is transferred to the section of
                                        ; code according to the table.
                                        ;
                                        ; At 'EXEC', r8 should point to the string, r9 should point to
                                        ; the character table, and r10 should point to the execution
                                        ; table. At 'DIRECT', r8 should point to the string, r9 and
                                        ; r10 will be set up to point to TAB1 and TAB1_1, which are
                                        ; the tables of all direct and statement commands.
                                        ;
                                        ; A '.' in the string will terminate the test and the partial
                                        ; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                                        ; 'PRIN.', or 'PRINT' will all match 'PRINT'.
                                        ;
                                        ; There are two tables: the character table and the execution
                                        ; table. The character table consists of any number of text items.
                                        ; Each item is a string of characters with the last character's
                                        ; high bit set to one. The execution table holds a 32-bit
                                        ; execution addresses that correspond to each entry in the
                                        ; character table.
                                        ;
                                        ; The end of the character table is a 0 byte which corresponds
                                        ; to the default routine in the execution table, which is
                                        ; executed if none of the other table items are matched.
                                        ;
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 7
noc_boot.a
                                        ; Character-matching tables:
    362 0000E0F6                        TAB1
    363 0000E0F6 4C 49 53 D4             	db	"LIS",('T'+0x80)        ; Direct commands
    364 0000E0FA 4E 45 D7                	db	"NE",('W'+0x80)
    365 0000E0FD 52 55 CE                	db	"RU",('N'+0x80)
    366 0000E100                        TAB2
    367 0000E100 4E 45 58 D4             	db	"NEX",('T'+0x80)         ; Direct / statement
    368 0000E104 4C 45 D4                	db	"LE",('T'+0x80)
    369 0000E107 49 C6                   	db	"I",('F'+0x80)
    370 0000E109 47 4F 54 CF             	db	"GOT",('O'+0x80)
    371 0000E10D 47 4F 53 55 C2          	db	"GOSU",('B'+0x80)
    372 0000E112 52 45 54 55 52 CE       	db	"RETUR",('N'+0x80)
    373 0000E118 52 45 CD                	db	"RE",('M'+0x80)
    374 0000E11B 46 4F D2                	db	"FO",('R'+0x80)
    375 0000E11E 49 4E 50 55 D4          	db	"INPU",('T'+0x80)
    376 0000E123 50 52 49 4E D4          	db	"PRIN",('T'+0x80)
    377 0000E128 50 4F 4B 45 D7          	db	"POKE",('W'+0x80)
    378 0000E12D 50 4F 4B C5             	db	"POK",('E'+0x80)
    379 0000E131 53 54 4F D0             	db	"STO",('P'+0x80)
    380 0000E135 42 59 C5                	db	"BY",('E'+0x80)
    381 0000E138 53 59 D3                	db	"SY",('S'+0x80)
    382 0000E13B 43 4C D2                    db  "CL",('R'+0x80)
    383 0000E13E 45 58 49 D4             	db	"EXI",('T'+0x80)
    384 0000E142 00                      	db	0
    385 0000E143                        TAB4
    386 0000E143 4E 4F 44 45 4E 55 CD    	db	"NODENU",('M'+0x80)
                                      
    387 0000E14A 50 45 45 4B D7          	db	"PEEK",('W'+0x80)        ;Functions
    388 0000E14F 50 45 45 CB             	db	"PEE",('K'+0x80)         ;Functions
    389 0000E153 52 4E C4                	db	"RN",('D'+0x80)
    390 0000E156 41 42 D3                	db	"AB",('S'+0x80)
    391 0000E159 53 49 5A C5             	db	"SIZ",('E'+0x80)
    392 0000E15D 55 53 D2                	db  "US",('R'+0x80)
    393 0000E160 00                      	db	0
    394 0000E161                        TAB5
    395 0000E161 54 CF                   	db	"T",('O'+0x80)           ;"TO" in "FOR"
    396 0000E163 00                      	db	0
    397 0000E164                        TAB6
    398 0000E164 53 54 45 D0             	db	"STE",('P'+0x80)         ;"STEP" in "FOR"
    399 0000E168 00                      	db	0
    400 0000E169                        TAB8
    401 0000E169 3E BD                   	db	'>',('='+0x80)           ;Relational operators
    402 0000E16B 3C BE                   	db	'<',('>'+0x80)
    403 0000E16D BE                      	db	('>'+0x80)
    404 0000E16E BD                      	db	('='+0x80)
    405 0000E16F 3C BD                   	db	'<',('='+0x80)
    406 0000E171 BC                      	db	('<'+0x80)
    407 0000E172 00                      	db	0
    408 0000E173                        TAB9
    409 0000E173 41 4E C4                    db  "AN",('D'+0x80)
    410 0000E176 00                          db  0
    411 0000E177                        TAB10
    412 0000E177 4F D2                       db  "O",('R'+0x80)
    413 0000E179 00                          db  0
                                        
    415 0000E17A FF FF                   	.align	4
                                        
                                        ;* Execution address tables:
    418 0000E17C                        TAB1_1
    419 0000E17C AA E2                   	dw	LISTX			;Direct commands
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 8
noc_boot.a
    420 0000E17E 28 E2                   	dw	NEW
    421 0000E180 3C E2                   	dw	RUN
    422 0000E182                        TAB2_1
    423 0000E182 FC E3                   	dw	NEXT		;	Direct / statement
    424 0000E184 F6 E4                   	dw	LET
    425 0000E186 56 E4                   	dw	IF
    426 0000E188 6E E2                   	dw	GOTO
    427 0000E18A 42 E3                   	dw	GOSUB
    428 0000E18C 72 E3                   	dw	RETURN
    429 0000E18E 5C E4                   	dw	IF2			; REM
    430 0000E190 9C E3                   	dw	FOR
    431 0000E192 7A E4                   	dw	INPUT
    432 0000E194 DE E2                   	dw	PRINT
    433 0000E196 E0 E5                   	dw	POKEW
    434 0000E198 C0 E5                   	dw	POKE
    435 0000E19A 36 E2                   	dw	STOP
    436 0000E19C 8C E0                   	dw	GOBYE
    437 0000E19E F8 E5                   	dw	SYSX
    438 0000E1A0 88 E2                   	dw  _clr
    439 0000E1A2 4C F0                   	dw	EXIT
    440 0000E1A4 EE E4                   	dw	DEFLT
    441 0000E1A6                        TAB4_1
    442 0000E1A6 26 EA                   	dw	NODENUM
    443 0000E1A8 76 E9                   	dw  PEEKW
    444 0000E1AA 6A E9                   	dw	PEEK			;Functions
    445 0000E1AC 96 E9                   	dw	RND
    446 0000E1AE F0 E9                   	dw	ABS
    447 0000E1B0 16 EA                   	dw	SIZEX
    448 0000E1B2 82 E9                   	dw  USRX
    449 0000E1B4 A0 E7                   	dw	XP40
    450 0000E1B6                        TAB5_1
    451 0000E1B6 B2 E3                   	dw	FR1			;"TO" in "FOR"
    452 0000E1B8 A6 EA                   	dw	QWHAT
    453 0000E1BA                        TAB6_1
    454 0000E1BA C4 E3                   	dw	FR2			;"STEP" in "FOR"
    455 0000E1BC CA E3                   	dw	FR3
    456 0000E1BE                        TAB8_1
    457 0000E1BE C2 E6                   	dw	XP11	;>=		Relational operators
    458 0000E1C0 CC E6                   	dw	XP12	;<>
    459 0000E1C2 D6 E6                   	dw	XP13	;>
    460 0000E1C4 EA E6                   	dw	XP15	;=
    461 0000E1C6 E0 E6                   	dw	XP14	;<=
    462 0000E1C8 F4 E6                   	dw	XP16	;<
    463 0000E1CA 0E E7                   	dw	XP17
    464 0000E1CC                        TAB9_1
    465 0000E1CC 4E E6                       dw  XP_AND
    466 0000E1CE 56 E6                       dw  XP_ANDX
    467 0000E1D0                        TAB10_1
    468 0000E1D0 2A E6                       dw  XP_OR
    469 0000E1D2 32 E6                       dw  XP_ORX
                                        
                                        ;*
                                        ; r3 = match flag (trashed)
                                        ; r9 = text table
                                        ; r10 = exec table
                                        ; r11 = trashed
    476 0000E1D4                        DIRECT
    477 0000E1D4 0F 4E 06 19             	lea		r9,TAB1
    478 0000E1D8 17 4E 0C 1A             	lea		r10,TAB1_1
    479 0000E1DC                        EXEC
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 9
noc_boot.a
    480 0000E1DC F0 1B                   	lw		r11,lr		; save link reg
    481 0000E1DE 63 40 0B AF             	call	IGNBLK		; ignore leading blanks
    482 0000E1E2 B0 1F                   	lw		lr,r11		; restore link reg
    483 0000E1E4 80 1B                   	lw		r11,r8		; save the pointer
    484 0000E1E6 00 13                   	lw		r3,#0		; clear match flag
    485 0000E1E8                        EXLP
    486 0000E1E8 80 E1                   	lb		r1,[r8]		; get the program character
    487 0000E1EA 01 68                   	add		r8,r8,#1
    488 0000E1EC 90 E2                   	lb		r2,[r9]		; get the table character
    489 0000E1EE 02 A9                   	bne		EXNGO		; If end of table,
    490 0000E1F0 B0 18                   	lw		r8,r11		;	restore the text pointer and...
    491 0000E1F2 12 AE                   	br		EXGO		;   execute the default.
    492 0000E1F4                        EXNGO
    493 0000E1F4 3D 21                   	cmp		r1,r3		; Else check for period...
    494 0000E1F6 10 A8                   	beq		EXGO		; if so, execute
    495 0000E1F8 07 40 5F 32             	and		r2,#0x7f	; ignore the table's high bit
    496 0000E1FC 1D 22                   	cmp		r2,r1		;		is there a match?
    497 0000E1FE 07 A8                   	beq		EXMAT
    498 0000E200 04 6A                   	add		r10,r10,#4	;if not, try the next entry
    499 0000E202 B0 18                   	lw		r8,r11		; reset the program pointer
    500 0000E204 00 13                   	lw		r3,#0		; sorry, no match
    501 0000E206                        EX1
    502 0000E206 01 69                   	add		r9,r9,#1
    503 0000E208 9F E1                   	lb		r1,-1[r9]	; get to the end of the entry
    504 0000E20A FD BB                   	bpl		EX1
    505 0000E20C ED BE                   	br		EXLP		; back for more matching
    506 0000E20E                        EXMAT
    507 0000E20E 02 40 0E 13             	lw		r3,#'.'		; we've got a match so far
    508 0000E212 01 69                   	add		r9,r9,#1
    509 0000E214 9F E1                   	lb		r1,-1[r9]	; end of table entry?
    510 0000E216 E8 BB                   	bpl		EXLP		; if not, go back for more
    511 0000E218                        EXGO
    512 0000E218 01 4B 00 E1             	lb		r1,ROUTER+RTR_RXSTAT
    513 0000E21C 03 A8                   	beq		EXGO1
    514 0000E21E 17 BF                   	call	Recv
    515 0000E220 84 40 00 AF             	call	RecvDispatch
    516 0000E224                        EXGO1
    517 0000E224 A0 FB                   	lw		r11,[r10]	; execute the appropriate routine
    518 0000E226 B0 80                   	jmp		[r11]
                                        
                                        
                                        ;    lb      r1,[r8]     ; get token from text space
                                        ;    bpl
                                        ;    and     r1,#0x7f
                                        ;    shl     r1,#2       ; * 4 - word offset
                                        ;    add     r1,r1,#TAB1_1
                                        ;    lw      r1,[r1]
                                        ;    jmp     [r1]
                                        
                                            
                                        ;
                                        ; What follows is the code to execute direct and statement
                                        ; commands. Control is transferred to these points via the command
                                        ; table lookup code of 'DIRECT' and 'EXEC' in the last section.
                                        ; After the command is executed, control is transferred to other
                                        ; sections as follows:
                                        ;
                                        ; For 'LISTX', 'NEW', and 'STOP': go back to the warm start point.
                                        ; For 'RUN': go execute the first stored line if any; else go
                                        ; back to the warm start point.
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 10
noc_boot.a
                                        ; For 'GOTO' and 'GOSUB': go execute the target line.
                                        ; For 'RETURN' and 'NEXT'; go back to saved return line.
                                        ; For all others: if 'CURRNT' is 0, go to warm start; else go
                                        ; execute next command. (This is done in 'FINISH'.)
                                        ;
                                        ;******************************************************************
                                        ;
                                        ; *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                                        ;
                                        ; 'NEW<CR>' sets TXTUNF to point to TXTBGN
                                        ;
                                        ; 'STOP<CR>' goes back to WSTART
                                        ;
                                        ; 'RUN<CR>' finds the first stored line, stores its address
                                        ; in CURRNT, and starts executing it. Note that only those
                                        ; commands in TAB2 are legal for a stored program.
                                        ;
                                        ; RUN ON <node number> sends a run command to the specified node
                                        ;
                                        ; There are 3 more entries in 'RUN':
                                        ; 'RUNNXL' finds next line, stores it's address and executes it.
                                        ; 'RUNTSL' stores the address of this line and executes it.
                                        ; 'RUNSML' continues the execution on same line.
                                        ;
                                        ; 'GOTO expr<CR>' evaluates the expression, finds the target
                                        ; line, and jumps to 'RUNTSL' to do it.
                                        ;
    567 0000E228                        NEW
    568 0000E228 42 40 09 AF             	call	ENDCHK
    569 0000E22C 09 4E 00 F1             	lw		r1,TXTBGN
    570 0000E230 09 40 06 D1             	sw		r1,TXTUNF	;	set the end pointer
    571 0000E234 2B AF                   	call    clearVars
                                        
    573 0000E236                        STOP
    574 0000E236 42 40 02 AF             	call	ENDCHK
    575 0000E23A 46 BE                   	br		WSTART		; WSTART will reset the stack
                                        
    577 0000E23C                        RUN
    578 0000E23C 41 40 0F AF             	call	ENDCHK
    579 0000E240 09 4E 00 F8             	lw		r8,TXTBGN	;	set pointer to beginning
    580 0000E244 08 40 06 D8             	sw		r8,CURRNT
    581 0000E248 21 AF                   	call    clearVars
                                        
    583 0000E24A                        RUNNXL					; RUN <next line>
    584 0000E24A 08 40 06 F1             	lw		r1,CURRNT	; executing a program?
    585 0000E24E 3C B8                   	beq		WSTART		; if not, we've finished a direct stat.
    586 0000E250 00 11                   	lw		r1,#0	    ; else find the next line number
    587 0000E252 80 19                   	lw		r9,r8
    588 0000E254 49 40 0F AF             	call	FNDLNP		; search for the next line
    589 0000E258 37 B7                   	bgtu	WSTART		; if we've fallen off the end, stop
                                        
    591 0000E25A                        RUNTSL					; RUN <this line>
    592 0000E25A 08 40 06 D9             	sw		r9,CURRNT	; set CURRNT to point to the line no.
    593 0000E25E 92 18                   	lea		r8,2[r9]	; set the text pointer to
                                        
    595 0000E260                        RUNSML                  ; RUN <same line>
    596 0000E260 63 40 00 AF             	call	CHKIO		; see if a control-C was pressed
    597 0000E264 10 4E 00 19             	lea		r9,TAB2		; find command in TAB2
    598 0000E268 18 4E 02 1A             	lea		r10,TAB2_1
    599 0000E26C B7 BE                   	br		EXEC		; and execute it
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 11
noc_boot.a
                                        
    601 0000E26E                        GOTO
    602 0000E26E 1D 40 02 AF             	call	OREXPR		;evaluate the following expression
    603 0000E272 10 15                   	lw      r5,r1
    604 0000E274 40 40 03 AF             	call	ENDCHK		;must find end of line
    605 0000E278 50 11                   	lw      r1,r5
    606 0000E27A 48 40 04 AF             	call	FNDLN		; find the target line
    607 0000E27E ED B8                   	beq		RUNTSL		; go do it
    608 0000E280 21 4F 0F 11             	lea		r1,msgBadGotoGosub
    609 0000E284 41 40 01 AE             	br		ERROR		; no such line no.
                                        
                                        
    612 0000E288                        _clr
    613 0000E288 01 AF                       call    clearVars
    614 0000E28A 57 AE                       br      FINISH
                                        
                                        ; Clear the variable area of memory
    617 0000E28C                        clearVars
    618 0000E28C FC 6E                       sub     sp,sp,#4
    619 0000E28E E0 DF                       sw      lr,[sp]
    620 0000E290 E2 D6                       sw      r6,2[sp]
    621 0000E292 80 40 00 16                 lw      r6,#2048    ; number of words to clear
    622 0000E296 09 40 08 F1                 lw      r1,VARBGN
    623 0000E29A                        cv1
    624 0000E29A 10 D0                       sw      r0,[r1]
    625 0000E29C 04 61                       add     r1,r1,#4
    626 0000E29E FF 66                       sub		r6,r6,#1
    627 0000E2A0 FC B9                       bne     cv1
    628 0000E2A2 E0 FF                       lw      lr,[sp]
    629 0000E2A4 E2 F6                       lw      r6,2[sp]
    630 0000E2A6 04 6E                       add     sp,sp,#4
    631 0000E2A8 F0 80                       ret    
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; LIST
                                        ;
                                        ; LISTX has two forms:
                                        ; 'LIST<CR>' lists all saved lines
                                        ; 'LIST #<CR>' starts listing at the line #
                                        ; Control-S pauses the listing, control-C stops it.
                                        ;
                                        
    644 0000E2AA                        LISTX
    645 0000E2AA 5B 40 04 AF             	call	TSTNUM		; see if there's a line no.
    646 0000E2AE 10 15                   	lw      r5,r1
    647 0000E2B0 3E 40 05 AF             	call	ENDCHK		; if not, we get a zero
    648 0000E2B4 50 11                   	lw      r1,r5
    649 0000E2B6 46 40 06 AF             	call	FNDLN		; find this or next line
    650 0000E2BA                        LS1
    651 0000E2BA 06 B7                   	bgtu	WSTART		; warm start if we passed the end
                                        
    653 0000E2BC 90 11                   	lw		r1,r9
    654 0000E2BE 57 40 0A AF             	call	PRTLN		; print the line
    655 0000E2C2 10 19                   	lw		r9,r1		; set pointer for next
    656 0000E2C4 5F 40 0E AF             	call	CHKIO		; check for listing halt request
    657 0000E2C8 06 A8                   	beq		LS3
    658 0000E2CA FE 4F 1D 10             	cmp		r1,#CTRLS	; pause the listing?
    659 0000E2CE 03 A9                   	bne		LS3
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 12
noc_boot.a
    660 0000E2D0                        LS2
    661 0000E2D0 5F 40 08 AF             	call	CHKIO		; if so, wait for another keypress
    662 0000E2D4 FD B8                   	beq		LS2
    663 0000E2D6                        LS3
    664 0000E2D6 00 11                   	lw		r1,#0
    665 0000E2D8 45 40 0D AF             	call	FNDLNP		; find the next line
    666 0000E2DC EE BE                   	br		LS1
                                        
                                        
                                        ;******************************************************************
                                        ; PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                                        ; where '....' is a list of expressions, formats, back-arrows,
                                        ; and strings.	These items a separated by commas.
                                        ;
                                        ; A format is a pound sign followed by a number.  It controls
                                        ; the number of spaces the value of an expression is going to
                                        ; be printed in.  It stays effective for the rest of the print
                                        ; command unless changed by another format.  If no format is
                                        ; specified, 11 positions will be used.
                                        ;
                                        ; A string is quoted in a pair of single- or double-quotes.
                                        ;
                                        ; An underline (back-arrow) means generate a <CR> without a <LF>
                                        ;
                                        ; A <CR LF> is generated after the entire list has been printed
                                        ; or if the list is empty.  If the list ends with a semicolon,
                                        ; however, no <CR LF> is generated.
                                        ;
                                        
    689 0000E2DE                        PRINT
    690 0000E2DE 0B 15                   	lw		r5,#11		; D4 = number of print spaces
    691 0000E2E0 58 40 07 AF             	call	TSTC		; if null list and ":"
    692 0000E2E4 3A 08                   	db	':',PR2-*+1
    693 0000E2E6 5F 40 0D AF             	call	CRLF		; give CR-LF and continue
    694 0000E2EA BA BE                   	br		RUNSML		;		execution on the same line
    695 0000E2EC                        PR2
    696 0000E2EC 58 40 01 AF             	call	TSTC		;if null list and <CR>
    697 0000E2F0 0D 08                   	db	CR,PR0-*+1
    698 0000E2F2 5F 40 07 AF             	call	CRLF		;also give CR-LF and
    699 0000E2F6 A9 BE                   	br		RUNNXL		;execute the next line
    700 0000E2F8                        PR0
    701 0000E2F8 57 40 0B AF             	call	TSTC		;else is it a format?
    702 0000E2FC 23 0A                   	db	'#',PR1-*+1
    703 0000E2FE 18 40 0A AF             	call	OREXPR		; yes, evaluate expression
    704 0000E302 10 15                   	lw		r5,r1		; and save it as print width
    705 0000E304 0B AE                   	br		PR3		; look for more to print
    706 0000E306                        PR1
    707 0000E306 57 40 04 AF             	call	TSTC	;	is character expression? (MRL)
    708 0000E30A 24 0C                   	db	'$',PR4-*+1
    709 0000E30C 18 40 03 AF             	call	OREXPR	;	yep. Evaluate expression (MRL)
    710 0000E310 EB 4F 04 AF             	call	GOOUT	;	print low byte (MRL)
    711 0000E314 03 AE                   	br		PR3		;look for more. (MRL)
    712 0000E316                        PR4
    713 0000E316 4B 40 02 AF             	call	QTSTG	;	is it a string?
                                        	; the following branch must occupy only two bytes!
    715 0000E31A 09 AE                   	br		PR8		;	if not, must be an expression
    716 0000E31C                        PR3
    717 0000E31C 56 40 09 AF             	call	TSTC	;	if ",", go find next
    718 0000E320 2C 08                   	db	',',PR6-*+1
    719 0000E322 39 40 0A AF             	call	FIN		;in the list.
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 13
noc_boot.a
    720 0000E326 E8 BE                   	br		PR0
    721 0000E328                        PR6
    722 0000E328 5D 40 0C AF             	call	CRLF		;list ends here
    723 0000E32C 06 AE                   	br		FINISH
    724 0000E32E                        PR8
    725 0000E32E 17 40 02 AF             	call	OREXPR		; evaluate the expression
    726 0000E332 50 12                   	lw		r2,r5		; set the width
    727 0000E334 4C 40 0F AF             	call	PRTNUM		; print its value
    728 0000E338 F1 BE                   	br		PR3			; more to print?
                                        
    730 0000E33A                        FINISH
    731 0000E33A 38 40 0E AF             	call	FIN		; Check end of command
    732 0000E33E 3B 40 02 AE             	jmp		QWHAT	; print "What?" if wrong
                                        
                                        
                                        ;*******************************************************************
                                        ;
                                        ; *** GOSUB *** & RETURN ***
                                        ;
                                        ; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                                        ; except that the current text pointer, stack pointer, etc. are
                                        ; saved so that execution can be continued after the subroutine
                                        ; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                                        ; recursive), the save area must be stacked.  The stack pointer
                                        ; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                                        ; If we are in the main routine, 'STKGOS' is zero (this was done
                                        ; in the initialization section of the interpreter), but we still
                                        ; save it as a flag for no further 'RETURN's.
                                        ;
    749 0000E342                        GOSUB
    750 0000E342 46 40 06 AF             	call	PUSHA		; save the current 'FOR' parameters
    751 0000E346 16 40 06 AF             	call	OREXPR		; get line number
    752 0000E34A 41 40 0C AF             	call	FNDLN		; find the target line
    753 0000E34E 04 A8                   	beq		gosub1
    754 0000E350 21 4F 0F 11             	lea		r1,msgBadGotoGosub
    755 0000E354 3A 40 09 AE             	br		ERROR		; if not there, say "How?"
    756 0000E358                        gosub1
    757 0000E358 FA 6E                   	sub		sp,sp,#6
    758 0000E35A E0 D8                   	sw		r8,[sp]		; save text pointer
    759 0000E35C 08 40 06 F1             	lw		r1,CURRNT
    760 0000E360 E2 D1                   	sw		r1,2[sp]	; found it, save old 'CURRNT'...
    761 0000E362 08 40 08 F1             	lw		r1,STKGOS
    762 0000E366 E4 D1                   	sw		r1,4[sp]	; and 'STKGOS'
    763 0000E368 08 40 0C D0             	sw		r0,LOPVAR	; load new values
    764 0000E36C 08 40 08 DE             	sw		sp,STKGOS
    765 0000E370 74 BE                   	br		RUNTSL
                                        
                                        
                                        ; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                                        ; returns the execution to the command after the most recent
                                        ; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                                        ; a 'GOSUB' and is thus an error.
                                        ;
    773 0000E372                        RETURN
    774 0000E372 38 40 04 AF             	call	ENDCHK		; there should be just a <CR>
    775 0000E376 08 40 08 F1             	lw		r1,STKGOS	; get old stack pointer
    776 0000E37A 04 A9                   	bne		return1
    777 0000E37C 23 4F 0C 11             	lea		r1,msgRetWoGosub
    778 0000E380 39 40 03 AE             	br		ERROR		; if zero, it doesn't exist
    779 0000E384                        return1
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 14
noc_boot.a
    780 0000E384 10 1E                   	lw		sp,r1		; else restore it
    781 0000E386 E4 F1                   	lw		r1,4[sp]
    782 0000E388 08 40 08 D1             	sw		r1,STKGOS	; and the old 'STKGOS'
    783 0000E38C E2 F1                   	lw		r1,2[sp]
    784 0000E38E 08 40 06 D1             	sw		r1,CURRNT	; and the old 'CURRNT'
    785 0000E392 E0 F8                   	lw		r8,[sp]		; and the old text pointer
    786 0000E394 06 6E                   	add		sp,sp,#6
    787 0000E396 42 40 08 AF             	call	POPA		;and the old 'FOR' parameters
    788 0000E39A CF BE                   	br		FINISH		;and we are back home
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** FOR *** & NEXT ***
                                        ;
                                        ; 'FOR' has two forms:
                                        ; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                                        ; The second form means the same thing as the first form with a
                                        ; STEP of positive 1.  The interpreter will find the variable 'var'
                                        ; and set its value to the current value of 'exp1'.  It also
                                        ; evaluates 'exp2' and 'exp1' and saves all these together with
                                        ; the text pointer, etc. in the 'FOR' save area, which consisits of
                                        ; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                                        ; already something in the save area (indicated by a non-zero
                                        ; 'LOPVAR'), then the old save area is saved on the stack before
                                        ; the new values are stored.  The interpreter will then dig in the
                                        ; stack and find out if this same variable was used in another
                                        ; currently active 'FOR' loop.  If that is the case, then the old
                                        ; 'FOR' loop is deactivated. (i.e. purged from the stack)
                                        ;
    810 0000E39C                        FOR
    811 0000E39C 43 40 09 AF             	call	PUSHA		; save the old 'FOR' save area
    812 0000E3A0 34 40 05 AF             	call	SETVAL		; set the control variable
    813 0000E3A4 08 40 0C D1             	sw		r1,LOPVAR	; save its address
    814 0000E3A8 16 4E 01 19             	lea		r9,TAB5		; use 'EXEC' to test for 'TO'
    815 0000E3AC 1B 4E 06 1A             	lea		r10,TAB5_1
    816 0000E3B0 15 BE                   	jmp		EXEC
    817 0000E3B2                        FR1
    818 0000E3B2 13 40 00 AF             	call	OREXPR		; evaluate the limit
    819 0000E3B6 09 40 00 D1             	sw		r1,LOPLMT	; save that
    820 0000E3BA 16 4E 04 19             	lea		r9,TAB6		; use 'EXEC' to look for the
    821 0000E3BE 1B 4E 0A 1A             	lea		r10,TAB6_1	; word 'STEP'
    822 0000E3C2 0C BE                   	jmp		EXEC
    823 0000E3C4                        FR2
    824 0000E3C4 12 40 07 AF             	call	OREXPR		; found it, get the step value
    825 0000E3C8 01 AE                   	br		FR4
    826 0000E3CA                        FR3
    827 0000E3CA 01 11                   	lw		r1,#1		; not found, step defaults to 1
    828 0000E3CC                        FR4
    829 0000E3CC 08 40 0E D1             	sw		r1,LOPINC	; save that too
                                        
    831 0000E3D0                        FR5
    832 0000E3D0 08 40 06 F2             	lw		r2,CURRNT
    833 0000E3D4 09 40 02 D2             	sw		r2,LOPLN	; save address of current line number
    834 0000E3D8 09 40 04 D8             	sw		r8,LOPPT	; and text pointer
                                        
                                        
    837 0000E3DC E0 13                   	lw		r3,sp		; dig into the stack to find 'LOPVAR'
    838 0000E3DE 08 40 0C F6             	lw		r6,LOPVAR
    839 0000E3E2 01 AE                   	br		FR7
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 15
noc_boot.a
    840 0000E3E4                        FR6
    841 0000E3E4 3A 13                   	lea		r3,10[r3]	; look at next stack frame
    842 0000E3E6                        FR7
    843 0000E3E6 30 F2                   	lw		r2,[r3]		; is it zero?
    844 0000E3E8 08 A8                   	beq		FR8			; if so, we're done
    845 0000E3EA 6D 22                   	cmp		r2,r6		; same as current LOPVAR?
    846 0000E3EC FB B9                   	bne		FR6			; nope, look some more
                                        
    848 0000E3EE 30 11                       lw      r1,r3       ; Else remove 5 words from...
    849 0000E3F0 3A 12                   	lea		r2,10[r3]   ; inside the stack.
    850 0000E3F2 E0 13                   	lw		r3,sp		
    851 0000E3F4 3F 40 06 AF             	call	MVDOWN
    852 0000E3F8 0A 6E                   	add		sp,sp,#10	; set the SP 5 words up
    853 0000E3FA                        FR8
    854 0000E3FA 9F BE                       br	    FINISH		; and continue execution
                                        
                                        
                                        ; 'NEXT var' serves as the logical (not necessarily physical) end
                                        ; of the 'FOR' loop.  The control variable 'var' is checked with
                                        ; the 'LOPVAR'.  If they are not the same, the interpreter digs in
                                        ; the stack to find the right one and purges all those that didn't
                                        ; match.  Either way, it then adds the 'STEP' to that variable and
                                        ; checks the result with against the limit value.  If it is within
                                        ; the limit, control loops back to the command following the
                                        ; 'FOR'.  If it's outside the limit, the save area is purged and
                                        ; execution continues.
                                        ;
    867 0000E3FC                        NEXT
    868 0000E3FC 00 11                   	lw		r1,#0		; don't allocate it
    869 0000E3FE 1E 40 0E AF             	call	TSTV		; get address of variable
    870 0000E402 04 A9                   	bne		NX4
    871 0000E404 1F 4F 0B 11             	lea		r1,msgNextVar
    872 0000E408 34 40 0F AE             	br		ERROR		; if no variable, say "What?"
    873 0000E40C                        NX4
    874 0000E40C 10 19                   	lw		r9,r1		; save variable's address
    875 0000E40E                        NX0
    876 0000E40E 08 40 0C F1             	lw		r1,LOPVAR	; If 'LOPVAR' is zero, we never...
    877 0000E412 04 A9                   	bne		NX5         ; had a FOR loop
    878 0000E414 1E 4F 08 11             	lea		r1,msgNextFor
    879 0000E418 34 40 07 AE             	br		ERROR		
    880 0000E41C                        NX5
    881 0000E41C 9D 21                   	cmp		r1,r9		; else we check them
    882 0000E41E 03 A8                   	beq		NX2			; OK, they agree
    883 0000E420 3E 40 03 AF             	call	POPA		; nope, let's see the next frame
    884 0000E424 F4 BE                   	br		NX0
    885 0000E426                        NX2
    886 0000E426 90 F1                   	lw		r1,[r9]		; get control variable's value
    887 0000E428 08 40 0E F2             	lw		r2,LOPINC
    888 0000E42C 20 21                   	add		r1,r2		; add in loop increment
                                        ;	BVS.L	QHOW		say "How?" for 32-bit overflow
    890 0000E42E 90 D1                   	sw		r1,[r9]		; save control variable's new value
    891 0000E430 09 40 00 F3             	lw		r3,LOPLMT	; get loop's limit value
    892 0000E434 26 22                   	or		r2,r2       ; check loop increment
    893 0000E436 03 AB                   	bpl		NX1			; branch if loop increment is positive
    894 0000E438 3D 21                   	cmp		r1,r3		; test against limit
    895 0000E43A 0A A0                   	blt		NXPurge
    896 0000E43C 02 AE                   	br      NX3
    897 0000E43E                        NX1
    898 0000E43E 3D 21                   	cmp		r1,r3
    899 0000E440 07 A3                   	bgt		NXPurge
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 16
noc_boot.a
    900 0000E442                        NX3	
    901 0000E442 09 40 02 F8             	lw		r8,LOPLN	; Within limit, go back to the...
    902 0000E446 08 40 06 D8             	sw		r8,CURRNT
    903 0000E44A 09 40 04 F8             	lw		r8,LOPPT	; saved 'CURRNT' and text pointer.
    904 0000E44E 75 BE                   	br		FINISH
                                        
    906 0000E450                        NXPurge
    907 0000E450 3C 40 0B AF                 call    POPA        ; purge this loop
    908 0000E454 72 BE                       br      FINISH
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                                        ;
                                        ; 'REM' can be followed by anything and is ignored by the
                                        ; interpreter.
                                        ;
                                        ;REM
                                        ;    br	    IF2		    ; skip the rest of the line
                                        
                                        ; 'IF' is followed by an expression, as a condition and one or
                                        ; more commands (including other 'IF's) separated by colons.
                                        ; Note that the word 'THEN' is not used.  The interpreter evaluates
                                        ; the expression.  If it is non-zero, execution continues.  If it
                                        ; is zero, the commands that follow are ignored and execution
                                        ; continues on the next line.
                                        ;
    928 0000E456                        IF
    929 0000E456 DF AF                       call	OREXPR		; evaluate the expression
    930 0000E458                        IF1
    931 0000E458 16 21                       or      r1,r1       ; is it zero?
    932 0000E45A 02 B9                       bne	    RUNSML		; if not, continue
    933 0000E45C                        IF2
    934 0000E45C 80 19                       lw		r9,r8		; set lookup pointer
    935 0000E45E 00 11                   	lw		r1,#0		; find line #0 (impossible)
    936 0000E460 3A 40 0F AF             	call	FNDSKP		; if so, skip the rest of the line
    937 0000E464 E3 4F 00 A7             	bgtu	WSTART		; if no next line, do a warm start
    938 0000E468                        IF3
    939 0000E468 EF 4F 07 AE             	br		RUNTSL		; run the next line
                                        
                                        
                                        ; INPUT is called first and establishes a stack frame
    943 0000E46C                        INPERR
    944 0000E46C 08 40 0A FE             	lw		sp,STKINP	; restore the old stack pointer
    945 0000E470 E4 F8                   	lw		r8,4[sp]
    946 0000E472 08 40 06 D8             	sw		r8,CURRNT	; and old 'CURRNT'
    947 0000E476 E2 F8                   	lw		r8,2[sp]	; and old text pointer
    948 0000E478 0A 6E                   	add		sp,sp,#10	; fall through will subtract 10
                                        
                                        ; 'INPUT' is like the 'PRINT' command, and is followed by a list
                                        ; of items.  If the item is a string in single or double quotes,
                                        ; or is an underline (back arrow), it has the same effect as in
                                        ; 'PRINT'.  If an item is a variable, this variable name is
                                        ; printed out followed by a colon, then the interpreter waits for
                                        ; an expression to be typed in.  The variable is then set to the
                                        ; value of this expression.  If the variable is preceeded by a
                                        ; string (again in single or double quotes), the string will be
                                        ; displayed followed by a colon.  The interpreter the waits for an
                                        ; expression to be entered and sets the variable equal to the
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 17
noc_boot.a
                                        ; expression's value.  If the input expression is invalid, the
                                        ; interpreter will print "What?", "How?", or "Sorry" and reprint
                                        ; the prompt and redo the input.  The execution will not terminate
                                        ; unless you press control-C.  This is handled in 'INPERR'.
                                        ;
    965 0000E47A                        INPUT
    966 0000E47A F6 6E                   	sub		sp,sp,#10	; allocate stack frame
    967 0000E47C E8 D5                   	sw      r5,8[sp]
    968 0000E47E                        IP6
    969 0000E47E E0 D8                   	sw		r8,[sp]		; save in case of error
    970 0000E480 3F 40 0D AF             	call	QTSTG		; is next item a string?
    971 0000E484 06 AE                   	br		IP2			; nope - this branch must take only two bytes
    972 0000E486 01 11                   	lw		r1,#1		; allocate var
    973 0000E488 1A 40 09 AF             	call	TSTV		; yes, but is it followed by a variable?
    974 0000E48C 29 A8                   	beq     IP4		    ; if not, brnch
    975 0000E48E 10 1A                   	lw		r10,r1		; put away the variable's address
    976 0000E490 10 AE                   	br		IP3			; if so, input to variable
    977 0000E492                        IP2
    978 0000E492 E2 D8                   	sw		r8,2[sp]	; save for 'PRTSTG'
    979 0000E494 01 11                   	lw		r1,#1
    980 0000E496 1A 40 02 AF             	call	TSTV		; must be a variable now
    981 0000E49A 04 A9                   	bne		IP7
    982 0000E49C 1C 4F 0B 11             	lea		r1,msgInputVar
    983 0000E4A0 30 40 03 AE             	br		ERROR		; "What?" it isn't?
    984 0000E4A4                        IP7
    985 0000E4A4 10 1A                   	lw		r10,r1		; put away the variable's address
    986 0000E4A6 80 E5                   	lb		r5,[r8]		; get ready for 'PRTSTG' by null terminating
    987 0000E4A8 80 C0                   	sb		r0,[r8]
    988 0000E4AA E2 F1                   	lw		r1,2[sp]	; get back text pointer
    989 0000E4AC 3C 40 0B AF             	call	PRTSTG		; print string as prompt
    990 0000E4B0 80 C5                   	sb		r5,[r8]		; un-null terminate
    991 0000E4B2                        IP3
    992 0000E4B2 E2 D8                   	sw		r8,2[sp]	; save in case of error
    993 0000E4B4 08 40 06 F1             	lw		r1,CURRNT
    994 0000E4B8 E4 D1                   	sw		r1,4[sp]	; also save 'CURRNT'
    995 0000E4BA 0F 11                   	lw		r1,#-1
    996 0000E4BC 08 40 06 D1             	sw		r1,CURRNT	; flag that we are in INPUT
    997 0000E4C0 08 40 0A DE             	sw		sp,STKINP	; save the stack pointer too
    998 0000E4C4 E6 DA                   	sw		r10,6[sp]	; save the variable address
    999 0000E4C6 03 40 0A 11             	lw		r1,#':'		; print a colon first
   1000 0000E4CA 30 40 08 AF             	call	GETLN		; then get an input line
   1001 0000E4CE 0A 40 0E 18             	lea		r8,BUFFER	; point to the buffer
   1002 0000E4D2 A1 AF                   	call	OREXPR		; evaluate the input
   1003 0000E4D4 E6 FA                   	lw		r10,6[sp]	; restore the variable address
   1004 0000E4D6 A0 D1                   	sw		r1,[r10]	; save value in variable
   1005 0000E4D8 E4 F1                   	lw		r1,4[sp]	; restore old 'CURRNT'
   1006 0000E4DA 08 40 06 D1             	sw		r1,CURRNT
   1007 0000E4DE E2 F8                   	lw		r8,2[sp]	; and the old text pointer
   1008 0000E4E0                        IP4
   1009 0000E4E0 48 40 07 AF             	call	TSTC		; is the next thing a comma?
   1010 0000E4E4 2C 04                   	db	',',IP5-*+1
   1011 0000E4E6 CB BE                   	br		IP6			; yes, more items
   1012 0000E4E8                        IP5
   1013 0000E4E8 E8 F5                       lw      r5,8[sp]
   1014 0000E4EA 0A 6E                   	add		sp,sp,#10	; clean up the stack
   1015 0000E4EC 26 BE                   	jmp		FINISH
                                        
                                        
   1018 0000E4EE                        DEFLT
   1019 0000E4EE 80 E1                       lb      r1,[r8]
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 18
noc_boot.a
   1020 0000E4F0 FF 4F 13 10                 cmp     r1,#CR      ; empty line is OK
   1021 0000E4F4 22 B8                   	beq	    FINISH	    ; else it is 'LET'
                                        
                                        
                                        ; 'LET' is followed by a list of items separated by commas.
                                        ; Each item consists of a variable, an equals sign, and an
                                        ; expression.  The interpreter evaluates the expression and sets
                                        ; the variable to that value.  The interpreter will also handle
                                        ; 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                                        ;
   1030 0000E4F6                        LET
   1031 0000E4F6 29 40 0A AF                 call	SETVAL		; do the assignment
   1032 0000E4FA 47 40 0A AF             	call	TSTC		; check for more 'LET' items
   1033 0000E4FE 2C 04                   	db	',',LT1-*+1
   1034 0000E500 FA BE                   	br	    LET
   1035 0000E502                        LT1
   1036 0000E502 1B BE                       br	    FINISH		; until we are finished.
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** LOAD *** & SAVE ***
                                        ;
                                        ; These two commands transfer a program to/from an auxiliary
                                        ; device such as a cassette, another computer, etc.  The program
                                        ; is converted to an easily-stored format: each line starts with
                                        ; a colon, the line no. as 4 hex digits, and the rest of the line.
                                        ; At the end, a line starting with an '@' sign is sent.  This
                                        ; format can be read back with a minimum of processing time by
                                        ; the Butterfly.
                                        ;
   1051 0000E504                        LOAD
   1052 0000E504 09 4E 00 F8             	lw		r8,TXTBGN	; set pointer to start of prog. area
   1053 0000E508 00 40 0D 11             	lw		r1,#CR		; For a CP/M host, tell it we're ready...
   1054 0000E50C DB 4F 0A AF             	call	GOAUXO		; by sending a CR to finish PIP command.
   1055 0000E510                        LOD1
   1056 0000E510 DB 4F 0A AF             	call	GOAUXI		; look for start of line
   1057 0000E514 FD BA                   	bmi		LOD1
   1058 0000E516 FC 4F 10 10             	cmp		r1,#'@'		; end of program?
   1059 0000E51A 1B A8                   	beq		LODEND
   1060 0000E51C FE 4F 16 10             	cmp     r1,#0x1A    ; or EOF marker
   1061 0000E520 18 A8                   	beq     LODEND
   1062 0000E522 FC 4F 16 10             	cmp		r1,#':'		; if not, is it start of line?
   1063 0000E526 F4 B9                   	bne		LOD1		; if not, wait for it
   1064 0000E528 18 AF                   	call	GCHAR		; get line number
   1065 0000E52A 80 C1                   	sb		r1,[r8]		; store it
   1066 0000E52C A1 31                   	shr		r1,#1
   1067 0000E52E A1 31                   	shr		r1,#1
   1068 0000E530 A1 31                   	shr		r1,#1
   1069 0000E532 A1 31                   	shr		r1,#1
   1070 0000E534 A1 31                   	shr		r1,#1
   1071 0000E536 A1 31                   	shr		r1,#1
   1072 0000E538 A1 31                   	shr		r1,#1
   1073 0000E53A A1 31                   	shr		r1,#1
   1074 0000E53C 81 C1                   	sb		r1,1[r8]
   1075 0000E53E 02 68                   	add		r8,r8,#2
   1076 0000E540                        LOD2
   1077 0000E540 DA 4F 02 AF             	call	GOAUXI		; get another text char.
   1078 0000E544 FD BA                   	bmi		LOD2
   1079 0000E546 80 C1                   	sb		r1,[r8]
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 19
noc_boot.a
   1080 0000E548 01 68                   	add		r8,r8,#1	; store it
   1081 0000E54A FF 4F 13 10             	cmp		r1,#CR		; is it the end of the line?
   1082 0000E54E F8 B9                   	bne		LOD2		; if not, go back for more
   1083 0000E550 DF BE                   	br		LOD1		; if so, start a new line
   1084 0000E552                        LODEND
   1085 0000E552 09 40 06 D8             	sw		r8,TXTUNF	; set end-of program pointer
   1086 0000E556 DB 4F 07 AE             	br		WSTART		; back to direct mode
                                        
                                        ; get character from input (16 bit value)
   1089 0000E55A                        GCHAR
   1090 0000E55A FA 6E                   	sub		sp,sp,#6
   1091 0000E55C E0 DF                   	sw		lr,[sp]
   1092 0000E55E E2 D5                   	sw		r5,2[sp]
   1093 0000E560 E4 D6                   	sw		r6,4[sp]
   1094 0000E562 04 16                   	lw      r6,#4       ; repeat four times
   1095 0000E564 00 15                   	lw		r5,#0
   1096 0000E566                        GCHAR1
   1097 0000E566 D8 4F 0F AF             	call	GOAUXI		; get a char
   1098 0000E56A FD BA                   	bmi		GCHAR1
   1099 0000E56C 0D AF                   	call	asciiToHex
   1100 0000E56E 81 35                   	shl		r5,#1
   1101 0000E570 81 35                   	shl		r5,#1
   1102 0000E572 81 35                   	shl		r5,#1
   1103 0000E574 81 35                   	shl		r5,#1
   1104 0000E576 16 25                   	or		r5,r1
   1105 0000E578 FF 66                   	sub		r6,r6,#1
   1106 0000E57A F5 B9                   	bne     GCHAR1
   1107 0000E57C 50 11                   	lw		r1,r5
   1108 0000E57E E0 FF                   	lw		lr,[sp]
   1109 0000E580 E2 F5                   	lw		r5,2[sp]
   1110 0000E582 E4 F6                   	lw		r6,4[sp]
   1111 0000E584 06 6E                   	add     sp,sp,#6
   1112 0000E586 F0 80                   	ret
                                        
                                        ; convert an ascii char to hex code
                                        ; input
                                        ;	r2 = char to convert
                                        
   1118 0000E588                        asciiToHex
   1119 0000E588 FC 4F 17 10             	cmp		r1,#'9'
   1120 0000E58C 01 A2                   	ble		a2h1		; less than '9'
   1121 0000E58E F9 61                   	sub		r1,r1,#7	; shift 'A' to '9'+1
   1122 0000E590                        a2h1
   1123 0000E590 D0 61                   	sub		r1,r1,#'0'	;
   1124 0000E592 00 40 5F 31             	and		r1,#15		; make sure a nybble
   1125 0000E596 F0 80                   	ret
                                        
                                        ; output a CR LF sequence to auxillary output
                                        ; Registers Affected
                                        ;   r3 = LF
   1130 0000E598                        AUXOCRLF
   1131 0000E598 FE 6E                       sub     sp,sp,#2
   1132 0000E59A E0 DF                       sw      lr,[sp]
   1133 0000E59C 00 40 0D 11                 lw      r1,#CR
   1134 0000E5A0 D7 4F 00 AF                 call    GOAUXO
   1135 0000E5A4 0A 11                       lw      r1,#LF
   1136 0000E5A6 D6 4F 0D AF                 call    GOAUXO
   1137 0000E5AA E0 FF                       lw      lr,[sp]
   1138 0000E5AC 02 6E                   	add		sp,sp,#2
   1139 0000E5AE F0 80                       ret
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 20
noc_boot.a
                                        
                                        
                                        ; convert nybble in r2 to ascii hex char2
                                        ; r2 = character to convert
                                        
   1145 0000E5B0                        toAsciiHex
   1146 0000E5B0 00 40 5F 31             	and		r1,#15		; make sure it's a nybble
   1147 0000E5B4 FF 4F 16 10             	cmp		r1,#10		; > 10 ?
   1148 0000E5B8 01 A0                   	blt		tah1
   1149 0000E5BA 07 61                   	add		r1,r1,#7	; bump it up to the letter 'A'
   1150 0000E5BC                        tah1
   1151 0000E5BC 30 61                   	add		r1,r1,#'0'	; bump up to ascii '0'
   1152 0000E5BE F0 80                   	ret
                                        
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** POKE *** & SYSX ***
                                        ;
                                        ; 'POKE expr1,expr2' stores the byte from 'expr2' into the memory
                                        ; address specified by 'expr1'.
                                        ;
                                        ; 'SYSX expr' jumps to the machine language subroutine whose
                                        ; starting address is specified by 'expr'.  The subroutine can use
                                        ; all registers but must leave the stack the way it found it.
                                        ; The subroutine returns to the interpreter by executing an RET.
                                        ;
   1168 0000E5C0                        POKE
   1169 0000E5C0 FE 6E                   	sub		sp,sp,#2
   1170 0000E5C2 29 AF                   	call	OREXPR		; get the memory address
   1171 0000E5C4 41 40 05 AF             	call	TSTC		; it must be followed by a comma
   1172 0000E5C8 2C 10                   	db	',',PKER-*+1
   1173 0000E5CA E0 D1                   	sw		r1,[sp]	    ; save the address
   1174 0000E5CC 24 AF                   	call	OREXPR		; get the byte to be POKE'd
   1175 0000E5CE E0 F2                   	lw		r2,[sp]	    ; get the address back
   1176 0000E5D0 20 C1                   	sb		r1,[r2]		; store the byte in memory
   1177 0000E5D2 02 6E                   	add		sp,sp,#2
   1178 0000E5D4 EB 4F 01 AE             	br		FINISH
   1179 0000E5D8                        PKER
   1180 0000E5D8 16 4F 04 11             	lea		r1,msgComma
   1181 0000E5DC 26 40 05 AE             	br		ERROR		; if no comma, say "What?"
                                        
                                        
   1184 0000E5E0                        POKEW
   1185 0000E5E0 FE 6E                   	sub		sp,sp,#2
   1186 0000E5E2 19 AF                   	call	OREXPR		; get the memory address
   1187 0000E5E4 40 40 05 AF             	call	TSTC		; it must be followed by a comma
   1188 0000E5E8 2C F0                   	db	',',PKER-*+1
   1189 0000E5EA E0 D1                   	sw		r1,[sp]	    ; save the address
   1190 0000E5EC 14 AF                   	call	OREXPR		; get the byte to be POKE'd
   1191 0000E5EE E0 F2                   	lw		r2,[sp]	    ; get the address back
   1192 0000E5F0 20 D1                   	sw		r1,[r2]		; store the word in memory
   1193 0000E5F2 02 6E                   	add		sp,sp,#2
   1194 0000E5F4 EA 4F 01 AE             	jmp		FINISH
                                        
                                        
   1197 0000E5F8                        SYSX
   1198 0000E5F8 FE 6E                   	sub		sp,sp,#2
   1199 0000E5FA 0D AF                   	call	OREXPR		; get the subroutine's address
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 21
noc_boot.a
   1200 0000E5FC 16 20                   	or		r0,r1		; make sure we got a valid address
   1201 0000E5FE 04 A9                   	bne		sysx1
   1202 0000E600 1B 4F 09 11             	lea		r1,msgSYSBad
   1203 0000E604 25 40 01 AE             	br		ERROR
   1204 0000E608                        sysx1
   1205 0000E608 E0 D8                   	sw		r8,[sp]	    ; save the text pointer
   1206 0000E60A CF 48 09 AF             	call	[r1]		; jump to the subroutine
   1207 0000E60E E0 F8                   	lw		r8,[sp]	    ; restore the text pointer
   1208 0000E610 02 6E                   	add		sp,sp,#2
   1209 0000E612 E9 4F 02 AE             	br		FINISH
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** EXPR ***
                                        ;
                                        ; 'EXPR' evaluates arithmetical or logical expressions.
                                        ; <OREXPR>::= <ANDEXPR> OR <ANDEXPR> ...
                                        ; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                                        ; <EXPR>::=<EXPR2>
                                        ;	   <EXPR2><rel.op.><EXPR2>
                                        ; where <rel.op.> is one of the operators in TAB8 and the result
                                        ; of these operations is 1 if true and 0 if false.
                                        ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                                        ; where () are optional and (... are optional repeats.
                                        ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                                        ; <EXPR4>::=<variable>
                                        ;	    <function>
                                        ;	    (<EXPR>)
                                        ; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                                        ; as an index, functions can have an <EXPR> as arguments, and
                                        ; <EXPR4> can be an <EXPR> in parenthesis.
                                        ;
                                        
                                        
                                        ; <OREXPR>::=<ANDEXPR> OR <ANDEXPR> ...
                                        ;
   1237 0000E616                        OREXPR
   1238 0000E616 FC 6E                   	sub		sp,sp,#4
   1239 0000E618 E0 DF                   	sw		lr,[sp]
   1240 0000E61A 0F AF                   	call	ANDEXPR		; get first <ANDEXPR>
   1241 0000E61C                        XP_OR1
   1242 0000E61C E2 D1                   	sw		r1,2[sp]	; save <ANDEXPR> value
   1243 0000E61E 17 4E 07 19             	lea		r9,TAB10		; look up a logical operator
   1244 0000E622 1D 4E 00 1A             	lea		r10,TAB10_1
   1245 0000E626 DD 4F 09 AE             	jmp		EXEC		; go do it
                                        
   1247 0000E62A                        XP_OR
   1248 0000E62A 07 AF                       call    ANDEXPR
   1249 0000E62C E2 F2                       lw      r2,2[sp]
   1250 0000E62E 26 21                       or      r1,r2
   1251 0000E630 F5 BE                       br      XP_OR1
                                        
   1253 0000E632                        XP_ORX
   1254 0000E632 E2 F1                   	lw		r1,2[sp]
   1255 0000E634 E0 FF                       lw      lr,[sp]
   1256 0000E636 04 6E                       add     sp,sp,#4
   1257 0000E638 F0 80                       ret
                                        
                                        
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 22
noc_boot.a
                                        ; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                                        ;
   1262 0000E63A                        ANDEXPR
   1263 0000E63A FC 6E                   	sub		sp,sp,#4
   1264 0000E63C E0 DF                   	sw		lr,[sp]
   1265 0000E63E 37 AF                   	call	EXPR		; get first <EXPR>
   1266 0000E640                        XP_AND1
   1267 0000E640 E2 D1                   	sw		r1,2[sp]	; save <EXPR> value
   1268 0000E642 17 4E 03 19             	lea		r9,TAB9		; look up a logical operator
   1269 0000E646 1C 4E 0C 1A             	lea		r10,TAB9_1
   1270 0000E64A DC 4F 07 AE             	jmp		EXEC		; go do it
                                        
   1272 0000E64E                        XP_AND
   1273 0000E64E 2F AF                       call    EXPR
   1274 0000E650 E2 F2                       lw      r2,2[sp]
   1275 0000E652 25 21                       and     r1,r2
   1276 0000E654 F5 BE                       br      XP_AND1
                                        
   1278 0000E656                        XP_ANDX
   1279 0000E656 E2 F1                   	lw		r1,2[sp]
   1280 0000E658 E0 FF                       lw      lr,[sp]
   1281 0000E65A 04 6E                       add     sp,sp,#4
   1282 0000E65C F0 80                       ret
                                        
                                        
                                        ; Determine if the character is a digit
                                        ;   Parameters
                                        ;       r2 = char to test
                                        ;   Returns
                                        ;       r1 = 1 if digit, otherwise 0
                                        ;
   1291 0000E65E                        isDigit
   1292 0000E65E FD 4F 10 10                 cmp     r1,#'0'
   1293 0000E662 05 A0                       blt     isDigitFalse
   1294 0000E664 FC 4F 17 10                 cmp     r1,#'9'
   1295 0000E668 02 A3                       bgt     isDigitFalse
   1296 0000E66A 01 11                       lw      r1,#1
   1297 0000E66C F0 80                       ret
   1298 0000E66E                        isDigitFalse
   1299 0000E66E 00 11                       lw      r1,#0
   1300 0000E670 F0 80                       ret
                                        
                                        
                                        ; Determine if the character is a alphabetic
                                        ;   Parameters
                                        ;       r2 = char to test
                                        ;   Returns
                                        ;       r1 = 1 if alpha, otherwise 0
                                        ;
   1309 0000E672                        isAlpha
   1310 0000E672 FB 4F 1F 10                 cmp     r1,#'A'
   1311 0000E676 0B A0                       blt     isAlphaFalse
   1312 0000E678 FA 4F 16 10                 cmp     r1,#'Z'
   1313 0000E67C 06 A2                       ble     isAlphaTrue
   1314 0000E67E F9 4F 1F 10                 cmp     r1,#'a'
   1315 0000E682 05 A0                       blt     isAlphaFalse
   1316 0000E684 F8 4F 16 10                 cmp     r1,#'z'
   1317 0000E688 02 A3                       bgt     isAlphaFalse
   1318 0000E68A                        isAlphaTrue
   1319 0000E68A 01 11                       lw      r1,#1
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 23
noc_boot.a
   1320 0000E68C F0 80                       ret
   1321 0000E68E                        isAlphaFalse
   1322 0000E68E 00 11                       lw      r1,#0
   1323 0000E690 F0 80                       ret
                                        
                                        
                                        ; Determine if the character is a alphanumeric
                                        ;   Parameters
                                        ;       r1 = char to test
                                        ;   Returns
                                        ;       r1 = 1 if alpha, otherwise 0
                                        ;
   1332 0000E692                        isAlnum
   1333 0000E692 FE 6E                       sub     sp,sp,#2
   1334 0000E694 E0 DF                       sw      lr,[sp]
   1335 0000E696 10 12                       lw      r2,r1		; save test char
   1336 0000E698 E2 BF                       call    isDigit
   1337 0000E69A 06 A9                       bne		isDigitx	; if it is a digit
   1338 0000E69C 20 11                       lw      r1,r2		; get back test char
   1339 0000E69E E9 BF                       call    isAlpha
   1340 0000E6A0 E0 FF                       lw      lr,[sp]
   1341 0000E6A2 02 6E                       add		sp,sp,#2
   1342 0000E6A4 16 21                       or      r1,r1
   1343 0000E6A6 F0 80                       ret
   1344 0000E6A8                        isDigitx
   1345 0000E6A8 E0 FF                       lw      lr,[sp]
   1346 0000E6AA 02 6E                       add     sp,sp,#2	; return Z=0
   1347 0000E6AC F0 80                       ret
                                        
                                        
   1350 0000E6AE                        EXPR
   1351 0000E6AE FC 6E                   	sub		sp,sp,#4
   1352 0000E6B0 E0 DF                   	sw		lr,[sp]
   1353 0000E6B2 39 AF                   	call	EXPR2
   1354 0000E6B4 E2 D1                   	sw		r1,2[sp]	; save <EXPR2> value
   1355 0000E6B6 16 4E 09 19             	lea		r9,TAB8		; look up a relational operator
   1356 0000E6BA 1B 4E 0E 1A             	lea		r10,TAB8_1
   1357 0000E6BE D8 4F 0D AE             	jmp		EXEC		; go do it
                                        
   1359 0000E6C2                        XP11
   1360 0000E6C2 E2 F1                   	lw		r1,2[sp]
   1361 0000E6C4 28 AF                   	call	XP18	; is it ">="?
   1362 0000E6C6 1D 22                   	cmp		r2,r1
   1363 0000E6C8 1E A1                   	bge		XPRT1	; no, return r2=1
   1364 0000E6CA 19 AE                   	br		XPRT0	; else return r2=0
                                        
   1366 0000E6CC                        XP12
   1367 0000E6CC E2 F1                   	lw		r1,2[sp]
   1368 0000E6CE 23 AF                   	call	XP18	; is it "<>"?
   1369 0000E6D0 1D 22                   	cmp		r2,r1
   1370 0000E6D2 19 A9                   	bne		XPRT1	; no, return r2=1
   1371 0000E6D4 14 AE                   	br		XPRT0	; else return r2=0
                                        
   1373 0000E6D6                        XP13
   1374 0000E6D6 E2 F1                   	lw		r1,2[sp]
   1375 0000E6D8 1E AF                   	call	XP18	; is it ">"?
   1376 0000E6DA 1D 22                   	cmp		r2,r1
   1377 0000E6DC 14 A3                   	bgt		XPRT1	; no, return r2=1
   1378 0000E6DE 0F AE                   	br		XPRT0	; else return r2=0
                                        
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 24
noc_boot.a
   1380 0000E6E0                        XP14
   1381 0000E6E0 E2 F1                   	lw		r1,2[sp]
   1382 0000E6E2 19 AF                   	call	XP18	; is it "<="?
   1383 0000E6E4 1D 22                   	cmp		r2,r1
   1384 0000E6E6 0F A2                   	ble		XPRT1	; no, return r2=1
   1385 0000E6E8 0A AE                   	br		XPRT0	; else return r2=0
                                        
   1387 0000E6EA                        XP15
   1388 0000E6EA E2 F1                   	lw		r1,2[sp]
   1389 0000E6EC 14 AF                   	call	XP18	; is it "="?
   1390 0000E6EE 1D 22                   	cmp		r2,r1
   1391 0000E6F0 0A A8                   	beq		XPRT1	; if not, return r2=1
   1392 0000E6F2 05 AE                   	br		XPRT0	; else return r2=0
                                        
                                        
   1395 0000E6F4                        XP16
   1396 0000E6F4 E2 F1                   	lw		r1,2[sp]
   1397 0000E6F6 0F AF                   	call	XP18	; is it "<"?
   1398 0000E6F8 1D 22                   	cmp		r2,r1
   1399 0000E6FA 05 A0                   	blt		XPRT1	; if not, return r2=1
   1400 0000E6FC 00 AE                   	br		XPRT0	; else return r2=0
                                        
   1402 0000E6FE                        XPRT0
   1403 0000E6FE E0 FF                   	lw		lr,[sp]
   1404 0000E700 04 6E                   	add		sp,sp,#4
   1405 0000E702 00 11                   	lw		r1,#0   ; return r1=0 (false)
   1406 0000E704 F0 80                   	ret
                                        
   1408 0000E706                        XPRT1
   1409 0000E706 E0 FF                   	lw		lr,[sp]
   1410 0000E708 04 6E                   	add		sp,sp,#4
   1411 0000E70A 01 11                   	lw		r1,#1	; return r1=1 (true)
   1412 0000E70C F0 80                   	ret
                                        
   1414 0000E70E                        XP17				; it's not a rel. operator
   1415 0000E70E E2 F1                   	lw		r1,2[sp]	; return r2=<EXPR2>
   1416 0000E710 E0 FF                   	lw		lr,[sp]
   1417 0000E712 04 6E                   	add		sp,sp,#4
   1418 0000E714 F0 80                   	ret
                                        
   1420 0000E716                        XP18
   1421 0000E716 FC 6E                   	sub		sp,sp,#4
   1422 0000E718 E0 DF                   	sw		lr,[sp]
   1423 0000E71A E2 D1                   	sw		r1,2[sp]
   1424 0000E71C 04 AF                   	call	EXPR2		; do a second <EXPR2>
   1425 0000E71E E2 F2                   	lw		r2,2[sp]
   1426 0000E720 E0 FF                   	lw		lr,[sp]
   1427 0000E722 04 6E                   	add		sp,sp,#4
   1428 0000E724 F0 80                   	ret
                                        
                                        ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                                        
   1432 0000E726                        EXPR2
   1433 0000E726 FC 6E                   	sub		sp,sp,#4
   1434 0000E728 E0 DF                   	sw		lr,[sp]
   1435 0000E72A 36 40 02 AF             	call	TSTC		; negative sign?
   1436 0000E72E 2D 08                   	db	'-',XP21-*+1
   1437 0000E730 00 11                   	lw		r1,#0		; yes, fake '0-'
   1438 0000E732 E2 D1                   	sw		r1,2[sp]
   1439 0000E734 0F AE                   	br		XP26
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 25
noc_boot.a
   1440 0000E736                        XP21
   1441 0000E736 35 40 0C AF             	call	TSTC		; positive sign? ignore it
   1442 0000E73A 2B 02                   	db	'+',XP22-*+1
   1443 0000E73C                        XP22
   1444 0000E73C 12 AF                   	call	EXPR3		; first <EXPR3>
   1445 0000E73E                        XP23
   1446 0000E73E E2 D1                   	sw		r1,2[sp]	; yes, save the value
   1447 0000E740 35 40 07 AF             	call	TSTC		; add?
   1448 0000E744 2B 0A                   	db	'+',XP25-*+1
   1449 0000E746 0D AF                   	call	EXPR3		; get the second <EXPR3>
   1450 0000E748                        XP24
   1451 0000E748 E2 F2                   	lw		r2,2[sp]
   1452 0000E74A 20 21                   	add		r1,r2		; add it to the first <EXPR3>
                                        ;	BVS.L	QHOW		brnch if there's an overflow
   1454 0000E74C F8 BE                   	br		XP23		; else go back for more operations
   1455 0000E74E                        XP25
   1456 0000E74E 35 40 00 AF             	call	TSTC		; subtract?
   1457 0000E752 2D 08                   	db	'-',XP45-*+1
   1458 0000E754                        XP26
   1459 0000E754 06 AF                   	call	EXPR3		; get second <EXPR3>
   1460 0000E756 20 31                   	neg		r1			; change its sign
   1461 0000E758 F7 BE                   	br		XP24		; and do an addition
                                        
   1463 0000E75A                        XP45
   1464 0000E75A E2 F1                   	lw		r1,2[sp]
   1465 0000E75C E0 FF                   	lw		lr,[sp]
   1466 0000E75E 04 6E                   	add		sp,sp,#4
   1467 0000E760 F0 80                   	ret
                                        
                                        
                                        ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                                        
   1472 0000E762                        EXPR3
   1473 0000E762 FC 6E                   	sub		sp,sp,#4
   1474 0000E764 E0 DF                   	sw		lr,[sp]
   1475 0000E766 14 AF                   	call	EXPR4		; get first <EXPR4>
   1476 0000E768                        XP31
   1477 0000E768 E2 D1                   	sw		r1,2[sp]	; yes, save that first result
   1478 0000E76A 34 40 02 AF             	call	TSTC		; multiply?
   1479 0000E76E 2A 0A                   	db	'*',XP34-*+1
   1480 0000E770 0F AF                   	call	EXPR4		; get second <EXPR4>
   1481 0000E772 E2 F2                   	lw		r2,2[sp]
   1482 0000E774 B8 AF                   	call	MULT32		; multiply the two
   1483 0000E776 F8 BE                   	br		XP31		 ; then look for more terms
   1484 0000E778                        XP34
   1485 0000E778 33 40 0B AF             	call	TSTC		; divide?
   1486 0000E77C 2F 0C                   	db	'/',XP47-*+1
   1487 0000E77E 08 AF                   	call	EXPR4		; get second <EXPR4>
   1488 0000E780 10 12                   	lw      r2,r1
   1489 0000E782 E2 F1                   	lw		r1,2[sp]
   1490 0000E784 CD AF                   	call	DIV32		; do the division
   1491 0000E786 F0 BE                   	br		XP31		; go back for any more terms
                                        
   1493 0000E788                        XP47
   1494 0000E788 E2 F1                   	lw		r1,2[sp]
   1495 0000E78A E0 FF                   	lw		lr,[sp]
   1496 0000E78C 04 6E                   	add		sp,sp,#4
   1497 0000E78E F0 80                   	ret
                                        
                                        
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 26
noc_boot.a
                                        ; Functions are called through EXPR4
                                        ; <EXPR4>::=<variable>
                                        ;	    <function>
                                        ;	    (<EXPR>)
                                        
   1505 0000E790                        EXPR4
   1506 0000E790 FA 6E                       sub     sp,sp,#6
   1507 0000E792 E0 DF                       sw      lr,[sp]
   1508 0000E794 14 4E 03 19             	lea		r9,TAB4		; find possible function
   1509 0000E798 1A 4E 06 1A             	lea		r10,TAB4_1
   1510 0000E79C D1 4F 0E AE             	jmp		EXEC        ; branch to function which does subsequent
                                        	                    ; ret for EXPR4
                                        
   1513 0000E7A0                        XP40                    ; we get here if it wasn't a function
   1514 0000E7A0 00 11                   	lw		r1,#0
   1515 0000E7A2 1D AF                   	call	TSTV		
   1516 0000E7A4 04 A8                   	beq     XP41        ; nor a variable
   1517 0000E7A6 10 F1                   	lw		r1,[r1]		; if a variable, return its value in r1
   1518 0000E7A8 E0 FF                   	lw      lr,[sp]
   1519 0000E7AA 06 6E                   	add     sp,sp,#6
   1520 0000E7AC F0 80                   	ret
   1521 0000E7AE                        XP41
   1522 0000E7AE 33 40 02 AF             	call	TSTNUM		; or is it a number?
   1523 0000E7B2 26 22                   	or		r2,r2		; (if not, # of digits will be zero)
   1524 0000E7B4 01 A9                   	bne		XP46		; if so, return it in r1
   1525 0000E7B6 03 AF                   	call    PARN        ; check for (EXPR)
   1526 0000E7B8                        XP46
   1527 0000E7B8 E0 FF                   	lw      lr,[sp]
   1528 0000E7BA 06 6E                   	add     sp,sp,#6
   1529 0000E7BC F0 80                   	ret
                                        
                                        
                                        ; Check for a parenthesized expression
   1533 0000E7BE                        PARN
   1534 0000E7BE FE 6E                   	sub		sp,sp,#2
   1535 0000E7C0 E0 DF                   	sw		lr,[sp]
   1536 0000E7C2 31 40 06 AF             	call	TSTC		; else look for ( OREXPR )
   1537 0000E7C6 28 10                   	db	'(',XP43-*+1
   1538 0000E7C8 26 BF                   	call	OREXPR
   1539 0000E7CA 31 40 02 AF             	call	TSTC
   1540 0000E7CE 29 08                   	db	')',XP43-*+1
   1541 0000E7D0                        XP42
   1542 0000E7D0 E0 FF                   	lw		lr,[sp]
   1543 0000E7D2 02 6E                   	add		sp,sp,#2
   1544 0000E7D4 F0 80                   	ret
   1545 0000E7D6                        XP43
   1546 0000E7D6 0E 4F 01 11             	lea		r1,msgWhat
   1547 0000E7DA 16 40 06 AE             	br		ERROR
                                        
                                        
                                        ; ===== Test for a valid variable name.  Returns Z=1 if not
                                        ;	found, else returns Z=0 and the address of the
                                        ;	variable in r1.
                                        ; Parameters
                                        ;	r1 = 1 = allocate if not found
                                        ; Returns
                                        ;	r1 = address of variable, zero if not found
                                        
   1558 0000E7DE                        TSTV
   1559 0000E7DE FA 6E                   	sub		sp,sp,#6
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 27
noc_boot.a
   1560 0000E7E0 E0 DF                   	sw		lr,[sp]
   1561 0000E7E2 E2 D5                   	sw		r5,2[sp]
   1562 0000E7E4 10 15                   	lw		r5,r1		; allocate flag
   1563 0000E7E6 33 40 07 AF             	call	IGNBLK
   1564 0000E7EA 80 E1                   	lb		r1,[r8]		; look at the program text
   1565 0000E7EC FC 4F 10 10             	cmp     r1,#'@'
   1566 0000E7F0 1C A0                   	blt     tstv_notfound   ; C=1: not a variable
   1567 0000E7F2 12 A9                   	bne		TV1			; brnch if not "@" array
   1568 0000E7F4 01 68                   	add		r8,r8,#1	; If it is, it should be
   1569 0000E7F6 E3 BF                   	call	PARN		; followed by (EXPR) as its index.
   1570 0000E7F8 81 31                   	shl     r1,#1
   1571 0000E7FA 81 31                   	shl     r1,#1
                                        ;	BCS.L	QHOW		say "How?" if index is too big
   1573 0000E7FC E4 D1                       sw      r1,4[sp]    ; save the index
   1574 0000E7FE F4 6E                       sub		sp,sp,#12
   1575 0000E800 E0 DF                       sw		lr,[sp]
   1576 0000E802 10 40 08 AF             	call	SIZEX		; get amount of free memory
   1577 0000E806 E4 F2                   	lw      r2,4[sp]    ; get back the index
   1578 0000E808 1D 22                   	cmp     r2,r1       ; see if there's enough memory
   1579 0000E80A 02 A4                   	bltu	TV2
   1580 0000E80C 14 40 08 AE             	jmp    	QSORRY		; if not, say "Sorry"
   1581 0000E810                        TV2
   1582 0000E810 09 40 08 F1             	lw      r1,VARBGN   ; put address of array element...
   1583 0000E814 22 21                   	sub     r1,r2       ; into r1 (neg. offset is used)
   1584 0000E816 05 AE                   	br      TSTVRT
   1585 0000E818                        TV1	
   1586 0000E818 0D AF                       call    getVarName      ; get variable name
   1587 0000E81A 07 A8                       beq     tstv_notfound   ; if not, set Z=1 and return
   1588 0000E81C 50 12                       lw		r2,r5
   1589 0000E81E 45 AF                       call    findVar     ; find or allocate
   1590 0000E820 04 A8                       beq		tstv_notfound
   1591 0000E822                        TSTVRT
   1592 0000E822 E2 F5                   	lw		r5,2[sp]
   1593 0000E824 E0 FF                   	lw		lr,[sp]
   1594 0000E826 06 6E                   	add		sp,sp,#6    ; Z=0 (found)
   1595 0000E828 F0 80                   	ret
   1596 0000E82A                        tstv_notfound
   1597 0000E82A E2 F5                   	lw		r5,2[sp]
   1598 0000E82C E0 FF                       lw      lr,[sp]
   1599 0000E82E 06 6E                       add     sp,sp,#6
   1600 0000E830 00 11                       lw      r1,#0       ; Z=1 if not found
   1601 0000E832 F0 80                       ret
                                        
                                        
                                        ; Returns
                                        ;   r1 = 3 character variable name + type
                                        ;
   1607 0000E834                        getVarName
   1608 0000E834 FA 6E                       sub     sp,sp,#6
   1609 0000E836 E0 DF                       sw      lr,[sp]
   1610 0000E838 E4 D5                       sw		r5,4[sp]
                                        
   1612 0000E83A 80 E1                       lb      r1,[r8]     ; get first character
   1613 0000E83C E2 D1                       sw		r1,2[sp]	; save off current name
   1614 0000E83E 19 BF                       call    isAlpha
   1615 0000E840 2F A8                       beq     gvn1
   1616 0000E842 02 15                       lw      r5,#2       ; loop twice more
                                        
                                        	; check for second/third character
   1619 0000E844                        gvn4
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 28
noc_boot.a
   1620 0000E844 01 68                   	add     r8,r8,#1
   1621 0000E846 80 E1                   	lb      r1,[r8]     ; do we have another char ?
   1622 0000E848 24 BF                   	call    isAlnum
   1623 0000E84A 12 A8                   	beq     gvn2        ; nope
   1624 0000E84C E2 F1                   	lw      r1,2[sp]    ; get varname
   1625 0000E84E 81 31                   	shl     r1,#1       ; shift left by eight
   1626 0000E850 81 31                   	shl     r1,#1       ; shift left by eight
   1627 0000E852 81 31                   	shl     r1,#1       ; shift left by eight
   1628 0000E854 81 31                   	shl     r1,#1       ; shift left by eight
   1629 0000E856 81 31                   	shl     r1,#1       ; shift left by eight
   1630 0000E858 81 31                   	shl     r1,#1       ; shift left by eight
   1631 0000E85A 81 31                   	shl     r1,#1       ; shift left by eight
   1632 0000E85C 81 31                   	shl     r1,#1       ; shift left by eight
   1633 0000E85E 80 E2                   	lb      r2,[r8]
   1634 0000E860 26 21                   	or      r1,r2       ; add in new char
   1635 0000E862 E2 D1                       sw      r1,2[sp]   ; save off name again
   1636 0000E864 FF 65                       sub		r5,r5,#1
   1637 0000E866 EE B9                       bne     gvn4
                                        
                                            ; now ignore extra variable name characters
   1640 0000E868                        gvn6
   1641 0000E868 01 68                       add     r8,r8,#1
   1642 0000E86A 80 E1                       lb      r1,[r8]
   1643 0000E86C 12 BF                       call    isAlnum
   1644 0000E86E FC B9                       bne     gvn6        ; keep looping as long as we have identifier chars
                                            
   1646 0000E870                        gvn2
   1647 0000E870 80 E1                   	lb		r1,[r8]
   1648 0000E872 FD 4F 1B 10                 cmp     r1,#'%'
   1649 0000E876 05 A8                       beq     gvn3
   1650 0000E878 FD 4F 1C 10                 cmp     r1,#'$'
   1651 0000E87C 02 A8                       beq     gvn3
   1652 0000E87E 00 11                       lw      r1,#0
   1653 0000E880 FF 68                       sub     r8,r8,#1
                                        
                                            ; insert variable type indicator and return
   1656 0000E882                        gvn3
   1657 0000E882 01 68                       add     r8,r8,#1
   1658 0000E884 E2 F2                       lw      r2,2[sp]
   1659 0000E886 81 32                       shl     r2,#1
   1660 0000E888 81 32                       shl     r2,#1
   1661 0000E88A 81 32                       shl     r2,#1
   1662 0000E88C 81 32                       shl     r2,#1
   1663 0000E88E 81 32                       shl     r2,#1
   1664 0000E890 81 32                       shl     r2,#1
   1665 0000E892 81 32                       shl     r2,#1
   1666 0000E894 81 32                       shl     r2,#1
   1667 0000E896 26 21                       or      r1,r2       ; add in variable type
   1668 0000E898 E0 FF                       lw      lr,[sp]
   1669 0000E89A E4 F5                       lw		r5,4[sp]
   1670 0000E89C 06 6E                       add     sp,sp,#6   ; return Z = 0, r1 = varname
   1671 0000E89E F0 80                       ret
                                        
                                            ; not a variable name
   1674 0000E8A0                        gvn1
   1675 0000E8A0 E0 FF                       lw      lr,[sp]
   1676 0000E8A2 E4 F5                       lw		r5,4[sp]
   1677 0000E8A4 06 6E                       add     sp,sp,#6
   1678 0000E8A6 00 11                       lw      r1,#0       ; return Z = 1 if not a varname
   1679 0000E8A8 F0 80                       ret
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 29
noc_boot.a
                                        
                                        
                                        ; Find variable
                                        ;   r1 = varname
                                        ;	r2 = allocate flag
                                        ; Returns
                                        ;   r1 = variable address, Z =0 if found / allocated, Z=1 if not found
                                        
   1688 0000E8AA                        findVar
   1689 0000E8AA FC 6E                       sub     sp,sp,#4
   1690 0000E8AC E0 DF                       sw      lr,[sp]
   1691 0000E8AE E2 D7                       sw      r7,2[sp]
   1692 0000E8B0 09 40 08 F3                 lw      r3,VARBGN
   1693 0000E8B4                        fv4
   1694 0000E8B4 30 F7                       lw      r7,[r3]     ; get varname / type
   1695 0000E8B6 0A A8                       beq     fv3         ; no more vars ?
   1696 0000E8B8 7D 21                       cmp     r1,r7       ; match ?
   1697 0000E8BA 0B A8                       beq     fv1
   1698 0000E8BC 08 63                       add     r3,r3,#8    ; move to next var
   1699 0000E8BE 0A 40 00 F7                 lw      r7,STKBOT
   1700 0000E8C2 7D 23                       cmp     r3,r7
   1701 0000E8C4 F7 B0                       blt     fv4         ; loop back to look at next var
                                        
                                            ; variable not found
                                            ; no more memory
   1705 0000E8C6 13 4F 04 11                 lea     r1,msgVarSpace
   1706 0000E8CA EF AE                       br      ERROR
                                        ;    lw      lr,[sp]
                                        ;    lw      r7,2[sp]
                                        ;    add     sp,sp,#4
                                        ;    lw      r1,#0
                                        ;    ret
                                        
                                            ; variable not found
                                            ; allocate new ?
   1715 0000E8CC                        fv3
   1716 0000E8CC 26 22                   	or		r2,r2
   1717 0000E8CE 06 A8                   	beq		fv2
   1718 0000E8D0 30 D1                       sw      r1,[r3]     ; save varname / type
                                            ; found variable
                                            ; return address
   1721 0000E8D2                        fv1
   1722 0000E8D2 34 11                       add     r1,r3,#4
   1723 0000E8D4 E0 FF                       lw      lr,[sp]
   1724 0000E8D6 E2 F7                       lw      r7,2[sp]
   1725 0000E8D8 04 6E                       add     sp,sp,#4    ; Z = 0, r1 = address
   1726 0000E8DA F0 80                       ret
                                        
                                            ; didn't find var and not allocating
   1729 0000E8DC                        fv2
   1730 0000E8DC E0 FF                       lw      lr,[sp]
   1731 0000E8DE E2 F7                       lw      r7,2[sp]
   1732 0000E8E0 04 6E                       add     sp,sp,#4    ; Z = 0, r1 = address
   1733 0000E8E2 00 11                   	lw		r1,#0		; Z = 1, r1 = 0
   1734 0000E8E4 F0 80                       ret
                                        
                                        
                                        ; ===== Multiplies the 32 bit values in r1 and r2, returning
                                        ;	the 32 bit result in r1.
                                        ;
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 30
noc_boot.a
                                        
   1741 0000E8E6                        MULT32
   1742 0000E8E6 FA 6E                   	sub		sp,sp,#6
   1743 0000E8E8 E0 D5                   	sw		r5,[sp]		; w
   1744 0000E8EA E2 D6                   	sw		r6,2[sp]	; s
   1745 0000E8EC E4 D7                   	sw		r7,4[sp]
                                        
   1747 0000E8EE 00 15                   	lw		r5,#0		; w = 0;
   1748 0000E8F0 10 16                   	lw		r6,r1
   1749 0000E8F2 24 26                   	xor		r6,r2		; s = a ^ b
   1750 0000E8F4 16 21                   	or		r1,r1
   1751 0000E8F6 01 AB                   	bpl		mult1
   1752 0000E8F8 20 31                   	neg		r1
   1753 0000E8FA                        mult1
   1754 0000E8FA 26 22                   	or		r2,r2
   1755 0000E8FC 01 AB                   	bpl		mult2
   1756 0000E8FE 20 32                   	neg		r2
   1757 0000E900                        mult2
   1758 0000E900 10 17                   	lw		r7,r1
   1759 0000E902 51 37                   	and		r7,#1
   1760 0000E904 01 A8                   	beq		mult3
   1761 0000E906 20 25                   	add		r5,r2		; w += b
   1762 0000E908                        mult3
   1763 0000E908 81 32                   	shl		r2,#1		; b <<= 1
   1764 0000E90A A1 31                   	shr		r1,#1		; a >>= 1
   1765 0000E90C F9 B9                   	bne		mult2       ; a = 0 ?
   1766 0000E90E                        mult4
   1767 0000E90E 66 26                       or      r6,r6
   1768 0000E910 01 AB                   	bpl		mult5
   1769 0000E912 20 35                   	neg		r5
   1770 0000E914                        mult5
   1771 0000E914 50 11                   	lw		r1,r5
   1772 0000E916 E4 F7                   	lw		r7,4[sp]
   1773 0000E918 E2 F6                   	lw		r6,2[sp]
   1774 0000E91A E0 F5                   	lw		r5,[sp]
   1775 0000E91C 06 6E                   	add		sp,sp,#6
   1776 0000E91E F0 80                   	ret
                                        
                                        
                                        ; ===== Divide the 32 bit value in r2 by the 32 bit value in r3.
                                        ;	Returns the 32 bit quotient in r1, remainder in r2
                                        ;
                                        ; r2 = a
                                        ; r3 = b
                                        ; r6 = remainder
                                        ; r7 = iteration count
                                        ; r8 = sign
                                        ;
                                        
                                        ; q = a / b
                                        ; a = r1
                                        ; b = r2
                                        ; q = r2
                                        
   1794 0000E920                        DIV32
   1795 0000E920 26 22                       or      r2,r2       ; check for divide-by-zero
   1796 0000E922 03 A9                       bne		div6
   1797 0000E924 12 4F 01 11                 lea		r1,msgDivZero
   1798 0000E928 C0 AE                       br		ERROR		; divide by zero error
   1799 0000E92A                        div6
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 31
noc_boot.a
   1800 0000E92A FA 6E                   	sub		sp,sp,#6
   1801 0000E92C E0 D6                   	sw		r6,[sp]
   1802 0000E92E E2 D7                   	sw		r7,2[sp]
   1803 0000E930 E4 D8                   	sw		r8,4[sp]
                                        
   1805 0000E932 02 40 00 18                 lw      r8,#32      ; iteration count for 32 bits
   1806 0000E936 00 16                   	lw		r6,#0		; r = 0
   1807 0000E938 20 17                       lw      r7,r2       ; r7 = sign of result
   1808 0000E93A 14 27                       xor     r7,r1
   1809 0000E93C 16 21                   	or	    r1,r1	    ; take absolute value of r1 (a)
   1810 0000E93E 01 AB                   	bpl     div1
   1811 0000E940 20 31                   	neg     r1
   1812 0000E942                        div1
   1813 0000E942 26 22                       or      r2,r2	    ; take absolute value of r2 (b)
   1814 0000E944 01 AB                   	bpl	    div2
   1815 0000E946 20 32                   	neg     r2
   1816 0000E948                        div2
   1817 0000E948 81 31                   	shl		r1,#1		; a <<= 1
   1818 0000E94A 61 26                   	adc		r6,r6		; r <<= 1
   1819 0000E94C 6D 22                   	cmp		r2,r6		; b < r ?
   1820 0000E94E 02 A7                   	bgtu	div4
   1821 0000E950 22 26                   	sub		r6,r2		; r -= b
   1822 0000E952 61 31                   	or      r1,#1       ; a |= 1
   1823 0000E954                        div4
   1824 0000E954 FF 68                   	sub		r8,r8,#1
   1825 0000E956 F8 B9                       bne     div2        ; n--
   1826 0000E958 76 27                   	or      r7,r7
   1827 0000E95A 01 AB                   	bpl     div5
   1828 0000E95C 20 31                   	neg     r1
   1829 0000E95E                        div5
   1830 0000E95E 60 12                   	lw		r2,r6		; r2 = r
   1831 0000E960 E2 F7                   	lw		r7,2[sp]
   1832 0000E962 E4 F8                   	lw		r8,4[sp]
   1833 0000E964 E0 F6                   	lw		r6,[sp]
   1834 0000E966 06 6E                   	add		sp,sp,#6
   1835 0000E968 F0 80                   	ret
                                        
                                        ; ===== The PEEK function returns the byte stored at the address
                                        ;	contained in the following expression.
                                        ;
   1840 0000E96A                        PEEK
   1841 0000E96A 29 BF                   	call	PARN		; get the memory address
   1842 0000E96C 10 E1                   	lb		r1,[r1]		; get the addressed byte
   1843 0000E96E 0E 21                   	zxb		r1			; upper 3 bytes will be zero
   1844 0000E970 E0 FF                   	lw		lr,[sp]	; and return it
   1845 0000E972 06 6E                   	add		sp,sp,#6
   1846 0000E974 F0 80                   	ret
                                        
                                        
                                        ; ===== The PEEK function returns the byte stored at the address
                                        ;	contained in the following expression.
                                        ;
   1852 0000E976                        PEEKW
   1853 0000E976 23 BF                   	call	PARN		; get the memory address
   1854 0000E978 5E 31                   	and		r1,#-2		; align to word address
   1855 0000E97A 10 F1                   	lw		r1,[r1]		; get the addressed word
   1856 0000E97C E0 FF                   	lw		lr,[sp]	; and return it
   1857 0000E97E 06 6E                   	add		sp,sp,#6
   1858 0000E980 F0 80                   	ret
                                        
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 32
noc_boot.a
                                        
                                        ; user function call
                                        ; call the user function with argument in r1
   1863 0000E982                        USRX
   1864 0000E982 1D BF                   	call	PARN		; get expression value
   1865 0000E984 E2 D8                   	sw		r8,2[sp]	; save the text pointer
   1866 0000E986 02 40 04 F2             	lw      r2,usrJmp   ; get usr vector
   1867 0000E98A B3 48 09 AF             	call	[r2]		; jump to the subroutine
   1868 0000E98E E2 F8                   	lw		r8,2[sp]	; restore the text pointer
   1869 0000E990 E0 FF                   	lw		lr,[sp]
   1870 0000E992 06 6E                   	add		sp,sp,#6
   1871 0000E994 F0 80                   	ret
                                        
                                        
                                        ; ===== The RND function returns a random number from 1 to
                                        ;	the value of the following expression in D0.
                                        ;
   1877 0000E996                        RND
   1878 0000E996 13 BF                   	call	PARN		; get the upper limit
   1879 0000E998 16 21                   	or		r1,r1		; it must be positive and non-zero
   1880 0000E99A 0E A8                   	beq		rnd2
   1881 0000E99C 0A AA                   	bmi		rnd1
   1882 0000E99E 10 12                   	lw		r2,r1
   1883 0000E9A0 CA 4D 04 D0             	sh		r0,RAND+4	; read command
   1884 0000E9A4 CA 4D 00 F1             	lw		r1,RAND		; get a number
   1885 0000E9A8 0E AF                   	call	modu4		; RND(n)=MOD(number,n)+1
   1886 0000E9AA 01 61                   	add		r1,r1,#1
   1887 0000E9AC E0 FF                   	lw		lr,[sp]
   1888 0000E9AE 06 6E                   	add		sp,sp,#6
   1889 0000E9B0 F0 80                   	ret
   1890 0000E9B2                        rnd1
   1891 0000E9B2 1A 4F 05 11             	lea		r1,msgRNDBad
   1892 0000E9B6 79 AE                   	br		ERROR
   1893 0000E9B8                        rnd2
   1894 0000E9B8 CA 4D 04 D0             	sh		r0,RAND+4
   1895 0000E9BC CA 4D 00 F1             	lw		r1,RAND
   1896 0000E9C0 E0 FF                   	lw		lr,[sp]
   1897 0000E9C2 06 6E                   	add		sp,sp,#6
   1898 0000E9C4 F0 80                   	ret
                                        
                                        
                                        ; r = a mod b
                                        ; a = r2
                                        ; b = r3
                                        ; r = r1
   1905 0000E9C6                        modu4
   1906 0000E9C6 FA 6E                   	sub		sp,sp,#6
   1907 0000E9C8 E0 D5                   	sw		r5,[sp]
   1908 0000E9CA E2 D6                   	sw		r6,2[sp]
   1909 0000E9CC E4 D7                   	sw		r7,4[sp]
   1910 0000E9CE 02 40 00 17             	lw      r7,#32		; n = 32
   1911 0000E9D2 00 15                   	lw		r5,#0		; w = 0
   1912 0000E9D4 00 16                   	lw		r6,#0		; r = 0
   1913 0000E9D6                        mod2
   1914 0000E9D6 81 31                   	shl		r1,#1		; a <<= 1
   1915 0000E9D8 61 26                   	adc		r6,r6		; r <<= 1
   1916 0000E9DA 6D 22                   	cmp		r2,r6		; b < r ?
   1917 0000E9DC 01 A7                   	bgtu	mod1
   1918 0000E9DE 22 26                   	sub		r6,r2		; r -= b
   1919 0000E9E0                        mod1
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 33
noc_boot.a
   1920 0000E9E0 FF 67                   	sub		r7,r7,#1
   1921 0000E9E2 F9 B9                       bne     mod2        ; n--
   1922 0000E9E4 60 11                   	lw		r1,r6
   1923 0000E9E6 E0 F5                   	lw		r5,[sp]
   1924 0000E9E8 E2 F6                   	lw		r6,2[sp]
   1925 0000E9EA E4 F7                   	lw		r7,4[sp]
   1926 0000E9EC 06 6E                   	add		sp,sp,#6
   1927 0000E9EE F0 80                   	ret
                                        
                                        
                                        
                                        ; ===== The ABS function returns an absolute value in r2.
                                        ;
   1933 0000E9F0                        ABS
   1934 0000E9F0 EE 4F 05 AF             	call	PARN		; get the following expr.'s value
   1935 0000E9F4 16 21                   	or		r1,r1
   1936 0000E9F6 01 AB                   	bpl		abs1
   1937 0000E9F8 20 31                   	neg		r1			; if negative, complement it
                                        ;	bmi		QHOW		; if still negative, it was too big
   1939 0000E9FA                        abs1
   1940 0000E9FA E0 FF                   	lw		lr,[sp]
   1941 0000E9FC 06 6E                   	add		sp,sp,#6
   1942 0000E9FE F0 80                   	ret
                                        
                                        
                                        ; ===== The SGN function returns the sign in r1. +1,0, or -1
                                        ;
   1947 0000EA00                        SGN
   1948 0000EA00 ED 4F 0D AF             	call	PARN		; get the following expr.'s value
   1949 0000EA04 16 21                   	or		r1,r1
   1950 0000EA06 04 A8                   	beq		sgn1
   1951 0000EA08 02 AB                   	bpl		sgn2
   1952 0000EA0A 0F 11                   	lw		r1,#-1
   1953 0000EA0C 01 AE                   	br		sgn1
   1954 0000EA0E                        sgn2
   1955 0000EA0E 01 11                   	lw		r1,#1
   1956 0000EA10                        sgn1
   1957 0000EA10 E0 FF                   	lw		lr,[sp]
   1958 0000EA12 06 6E                   	add		sp,sp,#6
   1959 0000EA14 F0 80                   	ret
                                        
                                        
                                        ; ===== The SIZE function returns the size of free memory in r1.
                                        ;
   1964 0000EA16                        SIZEX
   1965 0000EA16 09 40 08 F1             	lw		r1,VARBGN	; get the number of free bytes...
   1966 0000EA1A 09 40 06 F2             	lw		r2,TXTUNF	; between 'TXTUNF' and 'VARBGN'
   1967 0000EA1E 22 21                   	sub		r1,r2
   1968 0000EA20 E0 FF                   	lw		lr,[sp]
   1969 0000EA22 06 6E                   	add		sp,sp,#6
   1970 0000EA24 F0 80                   	ret					; return the number in r2
                                        
                                        ; ==== Return the node number that the code is running on
                                        ;
   1974 0000EA26                        NODENUM
   1975 0000EA26 E4 31                   	tsr		r1,ID
   1976 0000EA28 E0 FF                   	lw		lr,[sp]
   1977 0000EA2A 06 6E                   	add		sp,sp,#6
   1978 0000EA2C F0 80                   	ret
                                        
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 34
noc_boot.a
                                        ;******************************************************************
                                        ;
                                        ; *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                                        ;
                                        ; 'SETVAL' expects a variable, followed by an equal sign and then
                                        ; an expression.  It evaluates the expression and sets the variable
                                        ; to that value.
                                        ;
                                        ; 'FIN' checks the end of a command.  If it ended with ":",
                                        ; execution continues.	If it ended with a CR, it finds the
                                        ; the next line and continues from there.
                                        ;
                                        ; 'ENDCHK' checks if a command is ended with a CR. This is
                                        ; required in certain commands, such as GOTO, RETURN, STOP, etc.
                                        ;
                                        ; 'ERROR' prints the string pointed to by A0. It then prints the
                                        ; line pointed to by CURRNT with a "?" inserted at where the
                                        ; old text pointer (should be on top of the stack) points to.
                                        ; Execution of Tiny BASIC is stopped and a warm start is done.
                                        ; If CURRNT is zero (indicating a direct command), the direct
                                        ; command is not printed. If CURRNT is -1 (indicating
                                        ; 'INPUT' command in progress), the input line is not printed
                                        ; and execution is not terminated but continues at 'INPERR'.
                                        ;
                                        ; Related to 'ERROR' are the following:
                                        ; 'QWHAT' saves text pointer on stack and gets "What?" message.
                                        ; 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                                        ; 'QSORRY' and 'ASORRY' do the same kind of thing.
                                        ; 'QHOW' and 'AHOW' also do this for "How?".
                                        ;
                                        
                                        ; returns
                                        ; r2 = variable's address
                                        ;
   2014 0000EA2E                        SETVAL
   2015 0000EA2E FC 6E                       sub     sp,sp,#4
   2016 0000EA30 E0 DF                       sw      lr,[sp]
   2017 0000EA32 01 11                       lw		r1,#1		; allocate var
   2018 0000EA34 ED 4F 03 AF                 call	TSTV		; variable name?
   2019 0000EA38 03 A9                       bne		sv2
   2020 0000EA3A 18 4F 0E 11                	lea		r1,msgVar
   2021 0000EA3E 35 AE                      	br		ERROR 
   2022 0000EA40                        sv2
   2023 0000EA40 E2 D1                   	sw      r1,2[sp]    ; save the variable's address
   2024 0000EA42 1D 40 06 AF             	call	TSTC		; get past the "=" sign
   2025 0000EA46 3D 12                   	db	'=',SV1-*+1
   2026 0000EA48 DE 4F 05 AF             	call	OREXPR		; evaluate the expression
   2027 0000EA4C E2 F2                   	lw      r2,2[sp]    ; get back the variable's address
   2028 0000EA4E 20 D1                   	sw      r1,[r2]     ; and save value in the variable
   2029 0000EA50 20 11                   	lw		r1,r2		; return r1 = variable address
   2030 0000EA52 E0 FF                   	lw      lr,[sp]
   2031 0000EA54 04 6E                   	add     sp,sp,#4
   2032 0000EA56 F0 80                   	ret
   2033 0000EA58                        SV1
   2034 0000EA58 26 AE                       br	    QWHAT		; if no "=" sign
                                        
                                        
   2037 0000EA5A                        FIN
   2038 0000EA5A FE 6E                   	sub		sp,sp,#2
   2039 0000EA5C E0 DF                   	sw		lr,[sp]
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 35
noc_boot.a
   2040 0000EA5E 1C 40 08 AF             	call	TSTC		; *** FIN ***
   2041 0000EA62 3A 08                   	db	':',FI1-*+1
   2042 0000EA64 02 6E                   	add		sp,sp,#2	; if ":", discard return address
   2043 0000EA66 BF 4F 0B AE             	br		RUNSML		; continue on the same line
   2044 0000EA6A                        FI1
   2045 0000EA6A 1C 40 02 AF             	call	TSTC		; not ":", is it a CR?
   2046 0000EA6E 0D 0A                   	db	CR,FI2-*+1
   2047 0000EA70 E0 FF                   	lw		lr,[sp]	; else return to the caller
   2048 0000EA72 02 6E                   	add		sp,sp,#2	; yes, purge return address
   2049 0000EA74 BE 4F 09 AE             	br		RUNNXL		; execute the next line
   2050 0000EA78                        FI2
   2051 0000EA78 E0 FF                   	lw		lr,[sp]	; else return to the caller
   2052 0000EA7A 02 6E                   	add		sp,sp,#2
   2053 0000EA7C F0 80                   	ret
                                        
                                        
                                        ; Check that there is nothing else on the line
                                        ; Registers Affected
                                        ;   r1
                                        ;
   2060 0000EA7E                        ENDCHK
   2061 0000EA7E FE 6E                   	sub		sp,sp,#2
   2062 0000EA80 E0 DF                   	sw		lr,[sp]
   2063 0000EA82 1E 40 09 AF             	call	IGNBLK
   2064 0000EA86 80 E1                   	lb		r1,[r8]
   2065 0000EA88 FF 4F 13 10             	cmp		r1,#CR		; does it end with a CR?
   2066 0000EA8C 03 A8                   	beq		ec1
   2067 0000EA8E 26 4F 08 11             	lea		r1,msgExtraChars
   2068 0000EA92 0B AE                   	jmp		ERROR
   2069 0000EA94                        ec1
   2070 0000EA94 E0 FF                   	lw		lr,[sp]
   2071 0000EA96 02 6E                   	add		sp,sp,#2
   2072 0000EA98 F0 80                   	ret
                                        
                                        
   2075 0000EA9A                        TOOBIG
   2076 0000EA9A 25 4F 03 11             	lea		r1,msgTooBig
   2077 0000EA9E 05 AE                   	br		ERROR
   2078 0000EAA0                        QSORRY
   2079 0000EAA0 0E 4F 09 11                 lea     r1,SRYMSG
   2080 0000EAA4 02 AE                   	br	    ERROR
   2081 0000EAA6                        QWHAT
   2082 0000EAA6 0E 4F 01 11             	lea		r1,msgWhat
   2083 0000EAAA                        ERROR
   2084 0000EAAA 21 40 0D AF             	call	PRMESG		; display the error message
   2085 0000EAAE 08 40 06 F1             	lw		r1,CURRNT	; get the current line number
   2086 0000EAB2 B0 4F 09 A8             	beq		WSTART		; if zero, do a warm start
   2087 0000EAB6 11 10                   	cmp		r1,#-1		; is the line no. pointer = -1?
   2088 0000EAB8 CD 4F 08 A8             	beq		INPERR		; if so, redo input
   2089 0000EABC 80 E5                   	lb		r5,[r8]		; save the char. pointed to
   2090 0000EABE 80 C0                   	sb		r0,[r8]		; put a zero where the error is
   2091 0000EAC0 08 40 06 F1             	lw		r1,CURRNT	; point to start of current line
   2092 0000EAC4 17 40 07 AF             	call	PRTLN		; display the line in error up to the 0
   2093 0000EAC8 10 16                   	lw      r6,r1       ; save off end pointer
   2094 0000EACA 80 C5                   	sb		r5,[r8]		; restore the character
   2095 0000EACC 03 40 0F 11             	lw		r1,#'?'		; display a "?"
   2096 0000EAD0 AD 4F 04 AF             	call	GOOUT
   2097 0000EAD4 00 12                   	lw      r2,#0       ; stop char = 0
   2098 0000EAD6 6F 11                   	sub		r1,r6,#1	; point back to the error char.
   2099 0000EAD8 B6 AF                   	call	PRTSTG		; display the rest of the line
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 36
noc_boot.a
   2100 0000EADA AF 4F 05 AE             	jmp	    WSTART		; and do a warm start
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** GETLN *** FNDLN (& friends) ***
                                        ;
                                        ; 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                                        ; the character in r3 (given by the caller), then it fills the
                                        ; buffer and echos. It ignores LF's but still echos
                                        ; them back. Control-H is used to delete the last character
                                        ; entered (if there is one), and control-X is used to delete the
                                        ; whole line and start over again. CR signals the end of a line,
                                        ; and causes 'GETLN' to return.
                                        ;
                                        ;
   2116 0000EADE                        GETLN
   2117 0000EADE FC 6E                   	sub		sp,sp,#4
   2118 0000EAE0 E0 DF                   	sw		lr,[sp]
   2119 0000EAE2 E2 D5                   	sw		r5,2[sp]
   2120 0000EAE4 AC 4F 0A AF             	call	GOOUT		; display the prompt
   2121 0000EAE8 01 11                   	lw		r1,#1		; turn on cursor flash
   2122 0000EAEA 03 40 0C C1             	sb		r1,cursFlash
   2123 0000EAEE 02 40 00 11             	lw		r1,#' '		; and a space
   2124 0000EAF2 AC 4F 03 AF             	call	GOOUT
   2125 0000EAF6 0A 40 0E 18             	lea		r8,BUFFER	; r8 is the buffer pointer
   2126 0000EAFA                        GL1
   2127 0000EAFA 1E 40 03 AF             	call	CHKIO		; check keyboard
   2128 0000EAFE FD B8                   	beq		GL1			; wait for a char. to come in
   2129 0000EB00 FF 4F 18 10             	cmp		r1,#CTRLH	; delete last character?
   2130 0000EB04 14 A8                   	beq		GL3			; if so
   2131 0000EB06 FE 4F 18 10             	cmp		r1,#CTRLX	; delete the whole line?
   2132 0000EB0A 20 A8                   	beq		GL4			; if so
   2133 0000EB0C FF 4F 13 10             	cmp		r1,#CR		; accept a CR
   2134 0000EB10 03 A8                   	beq		GL2
   2135 0000EB12 FE 4F 10 10             	cmp		r1,#' '		; if other control char., discard it
   2136 0000EB16 F1 B4                   	bltu	GL1
   2137 0000EB18                        GL2
   2138 0000EB18 80 C1                   	sb		r1,[r8]		; save the char.
   2139 0000EB1A 01 68                   	add		r8,r8,#1
   2140 0000EB1C AA 4F 0E AF             	call	GOOUT		; echo the char back out
   2141 0000EB20 8F E1                   	lb      r1,-1[r8]   ; get char back (GOOUT destroys r1)
   2142 0000EB22 FF 4F 13 10             	cmp		r1,#CR		; if it's a CR, end the line
   2143 0000EB26 25 A8                   	beq		GL7
   2144 0000EB28 F0 4F 83 10             	cmp		r8,#(BUFFER+BUFLEN-1)	; any more room?
   2145 0000EB2C E6 B4                   	bltu	GL1			; yes: get some more, else delete last char.
                                        
   2147 0000EB2E                        GL3
   2148 0000EB2E 08 11                   	lw		r1,#CTRLH	; delete a char. if possible
   2149 0000EB30 AA 4F 04 AF             	call	GOOUT
   2150 0000EB34 02 40 00 11             	lw		r1,#' '
   2151 0000EB38 AA 4F 00 AF             	call	GOOUT
   2152 0000EB3C F5 4F 82 10             	cmp		r8,#BUFFER	; any char.'s left?
   2153 0000EB40 DC B6                   	bleu	GL1			; if not
   2154 0000EB42 08 11                   	lw		r1,#CTRLH	; if so, finish the BS-space-BS sequence
   2155 0000EB44 A9 4F 0A AF             	call	GOOUT
   2156 0000EB48 FF 68                   	sub		r8,r8,#1	; decrement the text pointer
   2157 0000EB4A D7 BE                   	br		GL1			; back for more
                                        
   2159 0000EB4C                        GL4
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 37
noc_boot.a
   2160 0000EB4C 80 11                   	lw		r1,r8		; delete the whole line
   2161 0000EB4E F5 4F 12 15             	sub		r5,r1,#BUFFER   ; figure out how many backspaces we need
   2162 0000EB52 0C A8                   	beq		GL6			; if none needed, brnch
   2163 0000EB54                        GL5	
   2164 0000EB54 08 11                   	lw		r1,#CTRLH	; and display BS-space-BS sequences
   2165 0000EB56 A9 4F 01 AF             	call	GOOUT
   2166 0000EB5A 02 40 00 11             	lw		r1,#' '
   2167 0000EB5E A8 4F 0D AF             	call	GOOUT
   2168 0000EB62 08 11                   	lw		r1,#CTRLH
   2169 0000EB64 A8 4F 0A AF             	call	GOOUT
   2170 0000EB68 FF 65                   	sub		r5,r5,#1
   2171 0000EB6A F4 B9                   	bne     GL5
   2172 0000EB6C                        GL6
   2173 0000EB6C 0A 40 0E 18             	lea		r8,BUFFER	; reinitialize the text pointer
   2174 0000EB70 C4 BE                   	br		GL1			; and go back for more
   2175 0000EB72                        GL7
   2176 0000EB72 00 11                   	lw		r1,#0		; turn off cursor flash
   2177 0000EB74 03 40 0C C1             	sb		r1,cursFlash
   2178 0000EB78 0A 11                   	lw		r1,#LF		; echo a LF for the CR
   2179 0000EB7A A7 4F 0F AF             	call	GOOUT
   2180 0000EB7E E0 FF                   	lw		lr,[sp]
   2181 0000EB80 E2 F5                   	lw		r5,2[sp]
   2182 0000EB82 04 6E                   	add		sp,sp,#4
   2183 0000EB84 F0 80                   	ret
                                        
                                        
                                        ; 'FNDLN' finds a line with a given line no. (in r1) in the
                                        ; text save area.  r9 is used as the text pointer. If the line
                                        ; is found, r9 will point to the beginning of that line
                                        ; (i.e. the high byte of the line no.), and flags are Z.
                                        ; If that line is not there and a line with a higher line no.
                                        ; is found, r9 points there and flags are NC & NZ. If we reached
                                        ; the end of the text save area and cannot find the line, flags
                                        ; are C & NZ.
                                        ; Z=1 if line found
                                        ; N=1 if end of text save area
                                        ; Z=0 & N=0 if higher line found
                                        ;
                                        ; 'FNDLN' will initialize r9 to the beginning of the text save
                                        ; area to start the search. Some other entries of this routine
                                        ; will not initialize r9 and do the search.
                                        ; 'FNDLNP' will start with r9 and search for the line no.
                                        ; 'FNDNXT' will bump r9 by 2, find a CR and then start search.
                                        ; 'FNDSKP' uses r9 to find a CR, and then starts the search.
                                        ; return Z=1 if line is found, r9 = pointer to line
                                        ;
                                        ; Parameters
                                        ;	r1 = line number to find
                                        ;
   2209 0000EB86                        FNDLN
   2210 0000EB86 00 40 11 10             	cmp		r1,#0xFFFF	; line no. must be < 65535
   2211 0000EB8A 03 A6                   	bleu	fl1
   2212 0000EB8C 17 4F 08 11             	lea		r1,msgLineRange
   2213 0000EB90 8C BE                   	br		ERROR
   2214 0000EB92                        fl1
   2215 0000EB92 09 4E 00 F9             	lw		r9,TXTBGN	; init. the text save pointer
                                        
   2217 0000EB96                        FNDLNP
   2218 0000EB96 09 40 06 FA             	lw		r10,TXTUNF	; check if we passed the end
   2219 0000EB9A FF 6A                   	sub		r10,r10,#1
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 38
noc_boot.a
   2220 0000EB9C AD 29                   	cmp		r9,r10
   2221 0000EB9E 0F A7                   	bgtu	FNDRET		; if so, return with Z=0 & C=1
   2222 0000EBA0 90 E3                   	lb		r3,[r9]		; get low order byte of line number
   2223 0000EBA2 0E 23                   	zxb		r3
   2224 0000EBA4 91 E2                   	lb		r2,1[r9]	; get high order byte
   2225 0000EBA6 0E 22                   	zxb		r2
   2226 0000EBA8 81 32                   	shl		r2,#1
   2227 0000EBAA 81 32                   	shl		r2,#1
   2228 0000EBAC 81 32                   	shl		r2,#1
   2229 0000EBAE 81 32                   	shl		r2,#1
   2230 0000EBB0 81 32                   	shl		r2,#1
   2231 0000EBB2 81 32                   	shl		r2,#1
   2232 0000EBB4 81 32                   	shl		r2,#1
   2233 0000EBB6 81 32                   	shl		r2,#1
   2234 0000EBB8 36 22                   	or		r2,r3		; build whole line number
   2235 0000EBBA 2D 21                   	cmp		r1,r2		; is this the line we want?
   2236 0000EBBC 01 A7                   	bgtu	FNDNXT		; no, not there yet
   2237 0000EBBE                        FNDRET
   2238 0000EBBE F0 80                   	ret			; return the cond. codes
                                        
   2240 0000EBC0                        FNDNXT
   2241 0000EBC0 02 69                   	add		r9,r9,#2	; find the next line
                                        
   2243 0000EBC2                        FNDSKP
   2244 0000EBC2 90 E2                   	lb		r2,[r9]
   2245 0000EBC4 01 69                   	add		r9,r9,#1
   2246 0000EBC6 FF 4F 23 10             	cmp		r2,#CR		; try to find a CR
   2247 0000EBCA FB B9                   	bne		FNDSKP		; keep looking
   2248 0000EBCC E4 BE                   	br		FNDLNP		; check if end of text
                                        
                                        
                                        ;******************************************************************
                                        ; 'MVUP' moves a block up from where r1 points to where r2 points
                                        ; until r1=r3
                                        ;
   2255 0000EBCE                        MVUP1
   2256 0000EBCE 10 E4                   	lb		r4,[r1]
   2257 0000EBD0 20 C4                   	sb		r4,[r2]
   2258 0000EBD2 01 61                   	add		r1,r1,#1
   2259 0000EBD4 01 62                   	add		r2,r2,#1
   2260 0000EBD6                        MVUP
   2261 0000EBD6 3D 21                   	cmp		r1,r3
   2262 0000EBD8 FA B9                   	bne		MVUP1
   2263 0000EBDA                        MVRET
   2264 0000EBDA F0 80                   	ret
                                        
                                        
                                        ; 'MVDOWN' moves a block down from where r1 points to where r2
                                        ; points until r1=r3
                                        ;
   2270 0000EBDC                        MVDOWN1
   2271 0000EBDC FF 61                   	sub		r1,r1,#1
   2272 0000EBDE FF 62                   	sub		r2,r2,#1
   2273 0000EBE0 10 E4                   	lb		r4,[r1]
   2274 0000EBE2 20 C4                   	sb		r4,[r2]
   2275 0000EBE4                        MVDOWN
   2276 0000EBE4 3D 21                   	cmp		r1,r3
   2277 0000EBE6 FA B9                   	bne		MVDOWN1
   2278 0000EBE8 F0 80                   	ret
                                        
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 39
noc_boot.a
                                        
                                        ; 'POPA' restores the 'FOR' loop variable save area from the stack
                                        ;
                                        ; 'PUSHA' stacks for 'FOR' loop variable save area onto the stack
                                        ;
                                        ; Note: a single zero word is stored on the stack in the
                                        ; case that no FOR loops need to be saved. This needs to be
                                        ; done because PUSHA / POPA is called all the time.
                                        
   2289 0000EBEA                        POPA
   2290 0000EBEA E0 F1                   	lw		r1,[sp]		; restore LOPVAR, but zero means no more
   2291 0000EBEC 08 40 0C D1             	sw		r1,LOPVAR
   2292 0000EBF0 0E A8                   	beq		PP1
   2293 0000EBF2 E8 F1                   	lw		r1,8[sp]	; if not zero, restore the rest
   2294 0000EBF4 09 40 04 D1             	sw		r1,LOPPT
   2295 0000EBF8 E6 F1                   	lw		r1,6[sp]
   2296 0000EBFA 09 40 02 D1             	sw		r1,LOPLN
   2297 0000EBFE E4 F1                   	lw		r1,4[sp]
   2298 0000EC00 09 40 00 D1             	sw		r1,LOPLMT
   2299 0000EC04 E2 F1                   	lw		r1,2[sp]
   2300 0000EC06 08 40 0E D1             	sw		r1,LOPINC
   2301 0000EC0A 0A 6E                   	add		sp,sp,#10
   2302 0000EC0C F0 80                   	ret
   2303 0000EC0E                        PP1
   2304 0000EC0E 02 6E                   	add		sp,sp,#2
   2305 0000EC10 F0 80                   	ret
                                        
                                        
   2308 0000EC12                        PUSHA
   2309 0000EC12 0A 40 00 F1             	lw		r1,STKBOT	; Are we running out of stack room?
   2310 0000EC16 0A 61                   	add		r1,r1,#10	; we might need this many bytes
   2311 0000EC18 1D 2E                   	cmp		sp,r1
   2312 0000EC1A 42 B4                   	bltu	QSORRY		; out of stack space
   2313 0000EC1C 08 40 0C F1             	lw		r1,LOPVAR	; save loop variables
   2314 0000EC20 0F A8                   	beq		PU1			; if LOPVAR is zero, that's all
   2315 0000EC22 F6 6E                   	sub		sp,sp,#10
   2316 0000EC24 E0 D1                   	sw		r1,[sp]
   2317 0000EC26 09 40 04 F1             	lw		r1,LOPPT
   2318 0000EC2A E8 D1                   	sw		r1,8[sp]	; else save all the others
   2319 0000EC2C 09 40 02 F1             	lw		r1,LOPLN
   2320 0000EC30 E6 D1                   	sw		r1,6[sp]
   2321 0000EC32 09 40 00 F1             	lw		r1,LOPLMT
   2322 0000EC36 E4 D1                   	sw		r1,4[sp]
   2323 0000EC38 08 40 0E F1             	lw		r1,LOPINC
   2324 0000EC3C E2 D1                   	sw		r1,2[sp]
   2325 0000EC3E F0 80                   	ret
   2326 0000EC40                        PU1
   2327 0000EC40 FE 6E                   	sub		sp,sp,#2
   2328 0000EC42 E0 D1                   	sw		r1,[sp]
   2329 0000EC44 F0 80                   	ret
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** PRTSTG *** QTSTG *** PRTNUM *** PRTLN ***
                                        ;
                                        ; 'PRTSTG' prints a string pointed to by r3. It stops printing
                                        ; and returns to the caller when either a CR is printed or when
                                        ; the next byte is the same as what was passed in r4 by the
                                        ; caller.
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 40
noc_boot.a
                                        ;
                                        ; 'QTSTG' looks for an underline (back-arrow on some systems),
                                        ; single-quote, or double-quote.  If none of these are found, returns
                                        ; to the caller.  If underline, outputs a CR without a LF.  If single
                                        ; or double quote, prints the quoted string and demands a matching
                                        ; end quote.  After the printing, the next 2 bytes of the caller are
                                        ; skipped over (usually a short brnch instruction).
                                        ;
                                        ; 'PRTNUM' prints the 32 bit number in r3, leading blanks are added if
                                        ; needed to pad the number of spaces to the number in r4.
                                        ; However, if the number of digits is larger than the no. in
                                        ; r4, all digits are printed anyway. Negative sign is also
                                        ; printed and counted in, positive sign is not.
                                        ;
                                        ; 'PRTLN' prints the saved text line pointed to by r3
                                        ; with line no. and all.
                                        ;
                                        
                                        ; r1 = pointer to string
                                        ; r2 = stop character
                                        ; return r1 = pointer to end of line + 1
                                        
   2362 0000EC46                        PRTSTG
   2363 0000EC46 F8 6E                       sub     sp,sp,#8
   2364 0000EC48 E0 DF                       sw      lr,[sp]
   2365 0000EC4A E2 D5                       sw      r5,2[sp]
   2366 0000EC4C E4 D6                       sw      r6,4[sp]
   2367 0000EC4E E6 D7                       sw      r7,6[sp]
   2368 0000EC50 10 15                       lw      r5,r1       ; r5 = pointer
   2369 0000EC52 20 16                       lw      r6,r2       ; r6 = stop char
   2370 0000EC54                        PS1
   2371 0000EC54 50 E7                       lb      r7,[r5]     ; get a text character
   2372 0000EC56 01 65                       add     r5,r5,#1
   2373 0000EC58 6D 27                   	cmp     r7,r6		; same as stop character?
   2374 0000EC5A 09 A8                   	beq	    PRTRET		; if so, return
   2375 0000EC5C 70 11                   	lw      r1,r7
   2376 0000EC5E A0 4F 0D AF             	call	GOOUT		; display the char.
   2377 0000EC62 FF 4F 73 10             	cmp     r7,#CR      ; is it a C.R.?
   2378 0000EC66 F6 B9                   	bne	    PS1		    ; no, go back for more
   2379 0000EC68 0A 11                   	lw      r1,#LF      ; yes, add a L.F.
   2380 0000EC6A A0 4F 07 AF             	call	GOOUT
   2381 0000EC6E                        PRTRET
   2382 0000EC6E 70 12                       lw      r2,r7       ; return r2 = stop char
   2383 0000EC70 50 11                   	lw		r1,r5		; return r1 = line pointer
   2384 0000EC72 E2 F5                       lw      r5,2[sp]
   2385 0000EC74 E4 F6                       lw      r6,4[sp]
   2386 0000EC76 E6 F7                       lw      r7,6[sp]
   2387 0000EC78 E0 FF                       lw      lr,[sp]
   2388 0000EC7A 08 6E                       add     sp,sp,#8
   2389 0000EC7C F0 80                       ret			        ; then return
                                        
                                        
   2392 0000EC7E                        QTSTG
   2393 0000EC7E FE 6E                   	sub		sp,sp,#2
   2394 0000EC80 E0 DF                   	sw		lr,[sp]
   2395 0000EC82 B7 AF                   	call	TSTC		; *** QTSTG ***
   2396 0000EC84 22 18                   	db	'"',QT3-*+1
   2397 0000EC86 02 40 02 12             	lw		r2,#'"'		; it is a "
   2398 0000EC8A                        QT1
   2399 0000EC8A 80 11                   	lw		r1,r8
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 41
noc_boot.a
   2400 0000EC8C DC BF                   	call	PRTSTG		; print until another
   2401 0000EC8E 10 18                   	lw		r8,r1
   2402 0000EC90 FF 4F 26 10             	cmp		r2,#LF		; was last one a CR?
   2403 0000EC94 0E A9                   	bne		QT2
   2404 0000EC96 02 6E                   	add		sp,sp,#2
   2405 0000EC98 AD 4F 07 AE             	br		RUNNXL		; if so, run next line
   2406 0000EC9C                        QT3
   2407 0000EC9C AA AF                   	call	TSTC		; is it a single quote?
   2408 0000EC9E 27 08                   	db	"'",QT4-*+1
   2409 0000ECA0 02 40 07 12             	lw		r2,#''''	; if so, do same as above
   2410 0000ECA4 F2 BE                   	br		QT1
   2411 0000ECA6                        QT4
   2412 0000ECA6 A5 AF                   	call	TSTC		; is it an underline?
   2413 0000ECA8 5F 10                   	db	'_',QT5-*+1
   2414 0000ECAA 00 40 0D 11             	lw		r1,#CR		; if so, output a CR without LF
   2415 0000ECAE 9E 4F 05 AF             	call	GOOUT
   2416 0000ECB2                        QT2
   2417 0000ECB2 E0 FF                   	lw		lr,[sp]
   2418 0000ECB4 02 6E                   	add		sp,sp,#2
   2419 0000ECB6 F2 80                   	jmp		2[lr]		; skip over 2 bytes when returning
   2420 0000ECB8                        QT5						; not " ' or _
   2421 0000ECB8 E0 FF                   	lw		lr,[sp]
   2422 0000ECBA 02 6E                   	add		sp,sp,#2
   2423 0000ECBC F0 80                   	ret
                                        
                                        
                                        ; Output a CR LF sequence
                                        ;
   2428 0000ECBE                        prCRLF
   2429 0000ECBE FE 6E                   	sub		sp,sp,#2
   2430 0000ECC0 E0 DF                   	sw		lr,[sp]
   2431 0000ECC2 00 40 0D 11             	lw		r1,#CR
   2432 0000ECC6 9D 4F 09 AF             	call	GOOUT
   2433 0000ECCA 0A 11                   	lw		r1,#LF
   2434 0000ECCC 9D 4F 06 AF             	call	GOOUT
   2435 0000ECD0 E0 FF                   	lw		lr,[sp]
   2436 0000ECD2 02 6E                   	add		sp,sp,#2
   2437 0000ECD4 F0 80                   	ret
                                        
                                        
                                        ; r1 = number to print
                                        ; r2 = number of digits
                                        ; Register Usage
                                        ;	r5 = number of padding spaces
   2444 0000ECD6                        PRTNUM
   2445 0000ECD6 F8 6E                   	sub		sp,sp,#8
   2446 0000ECD8 E0 DF                   	sw		lr,[sp]
   2447 0000ECDA E2 D5                   	sw		r5,2[sp]
   2448 0000ECDC E4 D6                   	sw		r6,4[sp]
   2449 0000ECDE E6 D7                   	sw		r7,6[sp]
                                        
   2451 0000ECE0 0A 40 02 17             	lea		r7,NUMWKA	; r7 = pointer to numeric work area
   2452 0000ECE4 10 16                   	lw		r6,r1		; save number for later
   2453 0000ECE6 20 15                   	lw		r5,r2		; r5 = min number of chars
   2454 0000ECE8 16 21                   	
   2455 0000ECEA 02 AB                   	bpl		PN1			; if not
   2456 0000ECEC 20 31                   	neg		r1			; else make it positive
   2457 0000ECEE FF 65                   	sub		r5,r5,#1	; one less for width count
   2458 0000ECF0                        PN1
   2459 0000ECF0 0A 12                   	lw		r2,#10		; divide by 10
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 42
noc_boot.a
   2460 0000ECF2 E1 4F 05 AF             	call	DIV32
   2461 0000ECF6 30 62                   	add		r2,r2,#'0'	; convert remainder to ascii
   2462 0000ECF8 70 C2                   	sb		r2,[r7]		; and store in buffer
   2463 0000ECFA 01 67                   	add		r7,r7,#1
   2464 0000ECFC FF 65                   	sub		r5,r5,#1	; decrement width
   2465 0000ECFE 10 10                   	cmp		r1,#0
   2466 0000ED00 F7 B9                   	bne		PN1
   2467 0000ED02                        PN6
   2468 0000ED02 56 25                   	or		r5,r5		; test pad count
   2469 0000ED04 06 A2                   	ble		PN4			; skip padding if not needed
   2470 0000ED06                        PN3
   2471 0000ED06 02 40 00 11             	lw		r1,#' '		; display the required leading spaces
   2472 0000ED0A 9B 4F 07 AF             	call	GOOUT
   2473 0000ED0E FF 65                   	sub		r5,r5,#1
   2474 0000ED10 FA B9                   	bne		PN3
   2475 0000ED12                        PN4
   2476 0000ED12 66 26                   	or		r6,r6		; is number negative?
   2477 0000ED14 04 AB                   	bpl		PN5
   2478 0000ED16 02 40 0D 11             	lw		r1,#'-'		; if so, display the sign
   2479 0000ED1A 9A 4F 0F AF             	call	GOOUT
   2480 0000ED1E                        PN5
   2481 0000ED1E FF 67                   	sub		r7,r7,#1
   2482 0000ED20 70 E1                   	lb		r1,[r7]		; now unstack the digits and display
   2483 0000ED22 9A 4F 0B AF             	call	GOOUT
   2484 0000ED26 F5 4F 7E 10             	cmp		r7,#NUMWKA
   2485 0000ED2A F9 B7                   	bgtu	PN5
   2486 0000ED2C                        PNRET
   2487 0000ED2C E0 FF                   	lw		lr,[sp]
   2488 0000ED2E E2 F5                   	lw		r5,2[sp]
   2489 0000ED30 E4 F6                   	lw		r6,4[sp]
   2490 0000ED32 E6 F7                   	lw		r7,6[sp]
   2491 0000ED34 08 6E                   	add		sp,sp,#8
   2492 0000ED36 F0 80                   	ret
                                        
                                        
                                        ; r1 = number to print
                                        ; r2 = number of digits
   2497 0000ED38                        PRTHEXNUM
   2498 0000ED38 F6 6E                   	sub		sp,sp,#10
   2499 0000ED3A E0 DF                   	sw		lr,[sp]
   2500 0000ED3C E2 D5                   	sw		r5,2[sp]
   2501 0000ED3E E4 D6                   	sw		r6,4[sp]
   2502 0000ED40 E6 D7                   	sw		r7,6[sp]
   2503 0000ED42 E8 D8                   	sw		r8,8[sp]
                                        
   2505 0000ED44 0A 40 02 17             	lea		r7,NUMWKA	; r7 = pointer to numeric work area
   2506 0000ED48 10 16                   	lw		r6,r1		; save number for later
   2507 0000ED4A 0A 15                   	lw		r5,#10		; r5 = min number of chars
   2508 0000ED4C 10 14                   	lw		r4,r1
   2509 0000ED4E 46 24                   	
   2510 0000ED50 03 AB                   	bpl		PHN1		; if not
   2511 0000ED52 20 34                   	neg		r4			; else make it positive
   2512 0000ED54 FF 65                   	sub		r5,r5,#1	; one less for width count
   2513 0000ED56 0A 18                   	lw		r8,#10		; maximum of 10 digits
   2514 0000ED58                        PHN1
   2515 0000ED58 40 11                   	lw		r1,r4
   2516 0000ED5A 00 40 5F 31             	and		r1,#15
   2517 0000ED5E FF 4F 16 10             	cmp		r1,#10
   2518 0000ED62 02 A0                   	blt		PHN7
   2519 0000ED64 37 61                   	add		r1,r1,#'A'-10
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 43
noc_boot.a
   2520 0000ED66 01 AE                   	br		PHN8
   2521 0000ED68                        PHN7
   2522 0000ED68 30 61                   	add		r1,r1,#'0'		; convert remainder to ascii
   2523 0000ED6A                        PHN8
   2524 0000ED6A 70 C1                   	sb		r1,[r7]		; and store in buffer
   2525 0000ED6C 01 67                   	add		r7,r7,#1
   2526 0000ED6E FF 65                   	sub		r5,r5,#1	; decrement width
   2527 0000ED70 A1 34                   	shr		r4,#1
   2528 0000ED72 A1 34                   	shr		r4,#1
   2529 0000ED74 A1 34                   	shr		r4,#1
   2530 0000ED76 A1 34                   	shr		r4,#1
   2531 0000ED78 02 A8                   	beq		PHN6			; is it zero yet ?
   2532 0000ED7A FF 68                   	sub		r8,r8,#1	; safety
   2533 0000ED7C ED B9                   	bne		PHN1
   2534 0000ED7E                        PHN6
   2535 0000ED7E 56 25                   	or		r5,r5		; test pad count
   2536 0000ED80 06 A2                   	ble		PHN4			; skip padding if not needed
   2537 0000ED82                        PHN3
   2538 0000ED82 02 40 00 11             	lw		r1,#' '		; display the required leading spaces
   2539 0000ED86 97 4F 09 AF             	call	GOOUT
   2540 0000ED8A FF 65                   	sub		r5,r5,#1
   2541 0000ED8C FA B9                   	bne		PHN3
   2542 0000ED8E                        PHN4
   2543 0000ED8E 66 26                   	or		r6,r6		; is number negative?
   2544 0000ED90 04 AB                   	bpl		PHN5
   2545 0000ED92 02 40 0D 11             	lw		r1,#'-'		; if so, display the sign
   2546 0000ED96 97 4F 01 AF             	call	GOOUT
   2547 0000ED9A                        PHN5
   2548 0000ED9A FF 67                   	sub		r7,r7,#1
   2549 0000ED9C 70 E1                   	lb		r1,[r7]		; now unstack the digits and display
   2550 0000ED9E 96 4F 0D AF             	call	GOOUT
   2551 0000EDA2 F5 4F 7E 10             	cmp		r7,#NUMWKA
   2552 0000EDA6 F9 B7                   	bgtu	PHN5
   2553 0000EDA8                        PHNRET
   2554 0000EDA8 E0 FF                   	lw		lr,[sp]
   2555 0000EDAA E2 F5                   	lw		r5,2[sp]
   2556 0000EDAC E4 F6                   	lw		r6,4[sp]
   2557 0000EDAE E6 F7                   	lw		r7,6[sp]
   2558 0000EDB0 E8 F8                   	lw		r8,8[sp]
   2559 0000EDB2 0A 6E                   	add		sp,sp,#10
   2560 0000EDB4 F0 80                   	ret
                                        
                                        
                                        ; r1 = pointer to line
                                        ; returns r1 = pointer to end of line + 1
   2565 0000EDB6                        PRTLN
   2566 0000EDB6 FC 6E                       sub     sp,sp,#4
   2567 0000EDB8 E0 DF                       sw      lr,[sp]
   2568 0000EDBA E2 D5                       sw      r5,2[sp]
   2569 0000EDBC 12 15                       add     r5,r1,#2
   2570 0000EDBE 5E E1                       lb		r1,-2[r5]	; get the binary line number
   2571 0000EDC0 0E 21                       zxb		r1
   2572 0000EDC2 5F E2                       lb		r2,-1[r5]
   2573 0000EDC4 0E 22                       zxb		r2
   2574 0000EDC6 81 32                       shl		r2,#1
   2575 0000EDC8 81 32                       shl		r2,#1
   2576 0000EDCA 81 32                       shl		r2,#1
   2577 0000EDCC 81 32                       shl		r2,#1
   2578 0000EDCE 81 32                       shl		r2,#1
   2579 0000EDD0 81 32                       shl		r2,#1
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 44
noc_boot.a
   2580 0000EDD2 81 32                       shl		r2,#1
   2581 0000EDD4 81 32                       shl		r2,#1
   2582 0000EDD6 26 21                       or		r1,r2
   2583 0000EDD8 00 12                       lw      r2,#0       ; display a 0 or more digit line no.
   2584 0000EDDA 7D BF                   	call	PRTNUM
   2585 0000EDDC 02 40 00 11             	lw      r1,#' '     ; followed by a blank
   2586 0000EDE0 94 4F 0C AF             	call	GOOUT
   2587 0000EDE4 00 12                   	lw      r2,#0       ; stop char. is a zero
   2588 0000EDE6 50 11                   	lw      r1,r5
   2589 0000EDE8 2E BF                   	call    PRTSTG		; display the rest of the line
   2590 0000EDEA E2 F5                   	lw      r5,2[sp]
   2591 0000EDEC E0 FF                   	lw      lr,[sp]
   2592 0000EDEE 04 6E                   	add     sp,sp,#4
   2593 0000EDF0 F0 80                   	ret
                                        
                                        
                                        ; ===== Test text byte following the call to this subroutine. If it
                                        ;	equals the byte pointed to by r8, return to the code following
                                        ;	the call. If they are not equal, brnch to the point
                                        ;	indicated by the offset byte following the text byte.
                                        ;
                                        ; Registers Affected
                                        ;   r3,r8
                                        ; Returns
                                        ;	r8 = updated text pointer
                                        ;
   2606 0000EDF2                        TSTC
   2607 0000EDF2 FC 6E                   	sub		sp,sp,#4
   2608 0000EDF4 E0 DF                   	sw		lr,[sp]
   2609 0000EDF6 E2 D1                   	sw		r1,2[sp]
   2610 0000EDF8 2F AF                   	call	IGNBLK		; ignore leading blanks
   2611 0000EDFA E0 FF                   	lw		lr,[sp]	; get the return address
   2612 0000EDFC F0 E3                   	lb		r3,[lr]	; get the byte to compare
   2613 0000EDFE 80 E1                   	lb		r1,[r8]
   2614 0000EE00 1D 23                   	cmp		r3,r1		; is it = to what r8 points to?
   2615 0000EE02 05 A8                   	beq		TC1			; if so
                                        						; If not, add the second
   2617 0000EE04 F1 E3                   	lb		r3,1[lr]	; byte following the call to
   2618 0000EE06 30 2F                   	add		lr,r3		; the return address.
   2619 0000EE08 E2 F1                   	lw		r1,2[sp]
   2620 0000EE0A 04 6E                   	add		sp,sp,#4
   2621 0000EE0C F0 80                   	ret					; jump to the routine
   2622 0000EE0E                        TC1
   2623 0000EE0E 01 68                   	add		r8,r8,#1	; if equal, bump text pointer
   2624 0000EE10 E2 F1                   	lw		r1,2[sp]
   2625 0000EE12 04 6E                   	add     sp,sp,#4
   2626 0000EE14 F2 80                   	jmp		2[lr]		; Skip the 2 bytes following
                                        						; the call and continue.
                                        
                                        
                                        ; ===== See if the text pointed to by r8 is a number. If so,
                                        ;	return the number in r2 and the number of digits in r3,
                                        ;	else return zero in r2 and r3.
                                        ; Registers Affected
                                        ;   r1,r2,r3,r4
                                        ; Returns
                                        ; 	r1 = number
                                        ;	r2 = number of digits in number
                                        ;	r8 = updated text pointer
                                        ;
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 45
noc_boot.a
   2640 0000EE16                        TSTNUM
   2641 0000EE16 FE 6E                   	sub		sp,sp,#2
   2642 0000EE18 E0 DF                   	sw		lr,[sp]
   2643 0000EE1A 1E AF                   	call	IGNBLK		; skip over blanks
   2644 0000EE1C 00 11                   	lw		r1,#0		; initialize return parameters
   2645 0000EE1E 00 12                   	lw		r2,#0
   2646 0000EE20                        TN1
   2647 0000EE20 80 E3                   	lb		r3,[r8]
   2648 0000EE22 FD 4F 30 10             	cmp		r3,#'0'		; is it less than zero?
   2649 0000EE26 15 A4                   	bltu	TSNMRET 	; if so, that's all
   2650 0000EE28 FC 4F 37 10             	cmp		r3,#'9'		; is it greater than nine?
   2651 0000EE2C 12 A7                   	bgtu	TSNMRET 	; if so, return
   2652 0000EE2E 33 43 14 10             	cmp		r1,#214748364	; see if there's room for new digit
   2653 0000EE32 04 A6                   	bleu	TN2
   2654 0000EE34 10 4F 0D 11             	lea		r1,msgNumTooBig
   2655 0000EE38 E3 4F 07 AE             	br		ERROR		; if not, we've overflowd
   2656 0000EE3C                        TN2
   2657 0000EE3C 10 14                   	lw		r4,r1		; quickly multiply result by 10
   2658 0000EE3E 81 31                   	shl		r1,#1		; * 2
   2659 0000EE40 81 31                   	shl		r1,#1		; * 4
   2660 0000EE42 40 21                   	add		r1,r4		; * 5
   2661 0000EE44 81 31                   	shl		r1,#1		; * 10
   2662 0000EE46 01 68                   	add		r8,r8,#1	; adjust text pointer
   2663 0000EE48 00 40 5F 33             	and		r3,#0xF		; add in the new digit
   2664 0000EE4C 30 21                   	add		r1,r3
   2665 0000EE4E 01 62                   	add		r2,r2,#1	; increment the no. of digits
   2666 0000EE50 E7 BE                   	br		TN1
   2667 0000EE52                        TSNMRET
   2668 0000EE52 E0 FF                   	lw		lr,[sp]
   2669 0000EE54 02 6E                   	add		sp,sp,#2
   2670 0000EE56 F0 80                   	ret
                                        
                                        
                                        ;===== Skip over blanks in the text pointed to by r8.
                                        ;
                                        ; Registers Affected:
                                        ;	r8
                                        ; Returns
                                        ;	r8 = pointer updateded past any spaces or tabs
                                        ;
   2680 0000EE58                        IGNBLK
   2681 0000EE58 FE 6E                   	sub		sp,sp,#2
   2682 0000EE5A E0 D1                   	sw		r1,[sp]
   2683 0000EE5C                        IGB2
   2684 0000EE5C 80 E1                   	lb		r1,[r8]			; get char
   2685 0000EE5E FE 4F 10 10             	cmp		r1,#' '			; see if it's a space
   2686 0000EE62 03 A8                   	beq		IGB1			; if so, swallow it
   2687 0000EE64 FF 4F 17 10             	cmp		r1,#'\t'		; or a tab
   2688 0000EE68 02 A9                   	bne		IGBRET
   2689 0000EE6A                        IGB1
   2690 0000EE6A 01 68                   	add		r8,r8,#1		; increment the text pointer
   2691 0000EE6C F7 BE                   	br		IGB2
   2692 0000EE6E                        IGBRET
   2693 0000EE6E E0 F1                   	lw		r1,[sp]
   2694 0000EE70 02 6E                   	add		sp,sp,#2
   2695 0000EE72 F0 80                   	ret
                                        
                                        
                                        ; ===== Convert the line of text in the input buffer to upper
                                        ;	case (except for stuff between quotes).
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 46
noc_boot.a
                                        ;
                                        ; Registers Affected
                                        ;   r1,r3
                                        ; Returns
                                        ;	r8 = pointing to end of text in buffer
                                        ;
   2706 0000EE74                        TOUPBUF
   2707 0000EE74 FE 6E                   	sub		sp,sp,#2
   2708 0000EE76 E0 DF                   	sw		lr,[sp]
   2709 0000EE78 0A 40 0E 18             	lea		r8,BUFFER	; set up text pointer
   2710 0000EE7C 00 13                   	lw		r3,#0		; clear quote flag
   2711 0000EE7E                        TOUPB1
   2712 0000EE7E 80 E1                   	lb		r1,[r8]		; get the next text char.
   2713 0000EE80 01 68                   	add		r8,r8,#1
   2714 0000EE82 FF 4F 13 10             	cmp		r1,#CR		; is it end of line?
   2715 0000EE86 13 A8                   	beq		TOUPBRT 	; if so, return
   2716 0000EE88 FD 4F 1E 10             	cmp		r1,#'"'		; a double quote?
   2717 0000EE8C 08 A8                   	beq		DOQUO
   2718 0000EE8E FD 4F 19 10             	cmp		r1,#''''	; or a single quote?
   2719 0000EE92 05 A8                   	beq		DOQUO
   2720 0000EE94 30 10                   	cmp		r3,#0		; inside quotes?
   2721 0000EE96 F3 B9                   	bne		TOUPB1		; if so, do the next one
   2722 0000EE98 0D AF                   	call	toUpper 	; convert to upper case
   2723 0000EE9A 8F C1                   	sb		r1,-1[r8]	; store it
   2724 0000EE9C F0 BE                   	br		TOUPB1		; and go back for more
   2725 0000EE9E                        DOQUO
   2726 0000EE9E 30 10                   	cmp		r3,#0		; are we inside quotes?
   2727 0000EEA0 02 A9                   	bne		DOQUO1
   2728 0000EEA2 10 13                   	lw		r3,r1		; if not, toggle inside-quotes flag
   2729 0000EEA4 EC BE                   	br		TOUPB1
   2730 0000EEA6                        DOQUO1
   2731 0000EEA6 1D 23                   	cmp		r3,r1		; make sure we're ending proper quote
   2732 0000EEA8 EA B9                   	bne		TOUPB1		; if not, ignore it
   2733 0000EEAA 00 13                   	lw		r3,#0		; else clear quote flag
   2734 0000EEAC E8 BE                   	br		TOUPB1
   2735 0000EEAE                        TOUPBRT
   2736 0000EEAE E0 FF                   	lw		lr,[sp]
   2737 0000EEB0 02 6E                   	add		sp,sp,#2
   2738 0000EEB2 F0 80                   	ret
                                        
                                        
                                        ; ===== Convert the character in r1 to upper case
                                        ;
   2743 0000EEB4                        toUpper
   2744 0000EEB4 F9 4F 1F 10             	cmp		r1,#'a'		; is it < 'a'?
   2745 0000EEB8 04 A0                   	blt	    TOUPRET
   2746 0000EEBA F8 4F 16 10             	cmp		r1,#'z'		; or > 'z'?
   2747 0000EEBE 01 A3                   	bgt	    TOUPRET
   2748 0000EEC0 E0 61                   	sub		r1,r1,#32	; if not, make it upper case
   2749 0000EEC2                        TOUPRET
   2750 0000EEC2 F0 80                   	ret
                                        
                                        
                                        ; 'CHKIO' checks the input. If there's no input, it will return
                                        ; to the caller with the Z flag set. If there is input, the Z
                                        ; flag is cleared and the input byte is in r2. However, if a
                                        ; control-C is read, 'CHKIO' will warm-start BASIC and will not
                                        ; return to the caller.
                                        ;
   2759 0000EEC4                        CHKIO
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 47
noc_boot.a
   2760 0000EEC4 FE 6E                   	sub		sp,sp,#2	; save link reg
   2761 0000EEC6 E0 DF                   	sw		lr,[sp]
   2762 0000EEC8 8D 4F 0A AF             	call	GOIN		; get input if possible
   2763 0000EECC 07 A8                   	beq		CHKRET2		; if Zero, no input
   2764 0000EECE 1D 10                   	cmp		r1,#CTRLC	; is it control-C?
   2765 0000EED0 02 A9                   	bne		CHKRET		; if not
   2766 0000EED2 8F 4F 09 AE             	jmp		WSTART		; if so, do a warm start
   2767 0000EED6                        CHKRET
   2768 0000EED6 E0 FF                   	lw		lr,[sp]
   2769 0000EED8 02 6E                   	add		sp,sp,#2	; Z=0
   2770 0000EEDA F0 80                   	ret
   2771 0000EEDC                        CHKRET2
   2772 0000EEDC E0 FF                   	lw		lr,[sp]
   2773 0000EEDE 02 6E                   	add		sp,sp,#2
   2774 0000EEE0 00 11                   	lw		r1,#0		; Z=1
   2775 0000EEE2 F0 80                   	ret
                                        
                                        
                                        ; ===== Display a CR-LF sequence
                                        ;
   2780 0000EEE4                        CRLF
   2781 0000EEE4 0E 4F 0F 11             	lea		r1,CLMSG
                                        
                                        
                                        ; ===== Display a zero-ended string pointed to by register r1
                                        ; Registers Affected
                                        ;   r1,r2,r4
                                        ;
   2788 0000EEE8                        PRMESG
   2789 0000EEE8 FC 6E                   	sub		sp,sp,#4
   2790 0000EEEA E0 DF                   	sw		lr,[sp]
   2791 0000EEEC E2 D5                   	sw		r5,2[sp]
   2792 0000EEEE 10 15                   	lw      r5,r1       ; r5 = pointer to message
   2793 0000EEF0                        PRMESG1
   2794 0000EEF0 01 65                   	add		r5,r5,#1
   2795 0000EEF2 5F E1                   	lb		r1,-1[r5]	; 	get the char.
   2796 0000EEF4 03 A8                   	beq		PRMRET
   2797 0000EEF6 8C 4F 01 AF             	call	GOOUT		;else display it trashes r4
   2798 0000EEFA FA BE                   	br		PRMESG1
   2799 0000EEFC                        PRMRET
   2800 0000EEFC 50 11                   	lw		r1,r5
   2801 0000EEFE E2 F5                   	lw		r5,2[sp]
   2802 0000EF00 E0 FF                   	lw		lr,[sp]
   2803 0000EF02 04 6E                   	add		sp,sp,#4
   2804 0000EF04 F0 80                   	ret
                                        
                                        
                                        ; ===== Display a zero-ended string pointed to by register r1
                                        ; Registers Affected
                                        ;   r1,r2,r3
                                        ;
   2811 0000EF06                        PRMESGAUX
   2812 0000EF06 FC 6E                   	sub		sp,sp,#4
   2813 0000EF08 E0 DF                   	sw		lr,[sp]
   2814 0000EF0A E2 D5                   	sw		r5,2[sp]
   2815 0000EF0C 10 15                   	lw      r5,r1       ; r3 = pointer
   2816 0000EF0E                        PRMESGA1
   2817 0000EF0E 01 65                   	add		r5,r5,#1
   2818 0000EF10 5F E1                   	lb		r1,-1[r5]	; 	get the char.
   2819 0000EF12 03 A8                   	beq		PRMRETA
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 48
noc_boot.a
   2820 0000EF14 8B 4F 06 AF             	call	GOAUXO		;else display it
   2821 0000EF18 FA BE                   	br		PRMESGA1
   2822 0000EF1A                        PRMRETA
   2823 0000EF1A 50 11                   	lw		r1,r5
   2824 0000EF1C E2 F5                   	lw		r5,2[sp]
   2825 0000EF1E E0 FF                   	lw		lr,[sp]
   2826 0000EF20 04 6E                   	add		sp,sp,#4
   2827 0000EF22 F0 80                   	ret
                                        
                                        ;*****************************************************
                                        ; The following routines are the only ones that need *
                                        ; to be changed for a different I/O environment.     *
                                        ;*****************************************************
                                        
                                        
                                        ; ===== Output character to the console (Port 1) from register D0
                                        ;	(Preserves all registers.)
                                        ;
   2838 0000EF24                        OUTC
   2839 0000EF24 FF BE                   	jmp		_putChar
                                        
                                        
                                        ; ===== Input a character from the console into register D0 (or
                                        ;	return Zero status if there's no character available).
                                        ;
   2845 0000EF26                        INC
   2846 0000EF26 FE 6E                   	add		sp,sp,#-2
   2847 0000EF28 E0 DF                   	sw		lr,[sp]
   2848 0000EF2A 01 4B 00 E1             	lb		r1,ROUTER+RTR_RXSTAT
   2849 0000EF2E 04 A8                   	beq		INC1
   2850 0000EF30 88 4F 0D AF             	call	Recv
   2851 0000EF34 1B 40 06 AF             	call	RecvDispatch
   2852 0000EF38                        INC1
                                        ; get char from keyboard
                                        ; returns char in r1
   2855 0000EF38                        _getChar
   2856 0000EF38 C5 4D 02 E1             	lb		r1,KBD+2	; get keyboard strobe
   2857 0000EF3C 08 AB                   	bpl		gc1
   2858 0000EF3E C5 4D 00 E1             	lb		r1,KBD		; get character and clear keyboard strobe
   2859 0000EF42 05 AA                   	bmi		gc1			; was it a keyup event ? (ignore)
   2860 0000EF44 07 40 5F 31             	and		r1,#0x7f
   2861 0000EF48 E0 FF                   	lw		lr,[sp]
   2862 0000EF4A 02 6E                   	add		sp,sp,#2
   2863 0000EF4C F0 80                   	ret
   2864 0000EF4E                        gc1
   2865 0000EF4E E0 FF                   	lw		lr,[sp]
   2866 0000EF50 02 6E                   	add		sp,sp,#2
   2867 0000EF52 00 11                   	lw		r1,#0		; return Z=1 (no character)
   2868 0000EF54 F0 80                   	ret
                                        
                                        
                                        ; get char from keyboard
                                        ; returns char in r1
   2873 0000EF56                        _getCharWait
   2874 0000EF56                        gc2
   2875 0000EF56 C5 4D 02 E1             	lb		r1,KBD+2	; get keyboard strobe
   2876 0000EF5A FD BB                   	bpl		gc2
   2877 0000EF5C C5 4D 00 E1             	lb		r1,KBD		; get character and clear keyboard strobe
   2878 0000EF60 FA BA                   	bmi		gc2			; was it a keyup event ? (ignore)
   2879 0000EF62 07 40 5F 31             	and		r1,#0x7f
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 49
noc_boot.a
   2880 0000EF66 F0 80                   	ret
                                        
                                        
                                        ; Trigger a load operation on the target node.
                                        
   2885 0000EF68                        TriggerTgtLoad:
   2886 0000EF68 84 4F 0A AF             	call	zeroTxBuf
   2887 0000EF6C 03 40 06 E2             	lb		r2,tgtNode
   2888 0000EF70 02 40 0F C2             	sb		r2,txBuf+MSG_DST
   2889 0000EF74 01 40 01 12             	lw		r2,#$11
   2890 0000EF78 02 40 0E C2             	sb		r2,txBuf+MSG_SRC
   2891 0000EF7C 0A 12                   	lw		r2,#10				; trigger load on target node
   2892 0000EF7E 02 40 08 C2             	sb		r2,txBuf+MSG_TYPE
   2893 0000EF82 84 4F 0F AF             	call	Xmit
   2894 0000EF86 E2 F2                   	lw		r2,2[sp]
   2895 0000EF88 E0 FF                   	lw		lr,[sp]
   2896 0000EF8A F0 80                   	ret
                                        
                                        ; ===== Output character to the host (Port 2) from register r1
                                        ;	(Preserves all registers.)
                                        ;
   2901 0000EF8C                        AUXOUT
   2902 0000EF8C FC 6E                   	add		sp,sp,#-4
   2903 0000EF8E E0 DF                   	sw		lr,[sp]
   2904 0000EF90 E2 D2                   	sw		r2,2[sp]
   2905 0000EF92 03 40 06 E2             	lb		r2,tgtNode
                                        	cmp		#$11
   2907 0000EF96 05 A9                   	bne		auxout1
   2908 0000EF98 43 48 07 AF             	call	putSerial	; call boot rom routine
   2909 0000EF9C E2 F2                   	lw		r2,2[sp]
   2910 0000EF9E E0 FF                   	lw		lr,[sp]
   2911 0000EFA0 F0 80                   	ret
   2912 0000EFA2                        auxout1:
   2913 0000EFA2 82 4F 0D AF             	call	zeroTxBuf
   2914 0000EFA6 02 40 00 C1             	sb		r1,txBuf
   2915 0000EFAA 03 40 06 E2             	lb		r2,tgtNode
   2916 0000EFAE 02 40 0F C2             	sb		r2,txBuf+MSG_DST
   2917 0000EFB2 01 40 01 12             	lw		r2,#$11
   2918 0000EFB6 02 40 0E C2             	sb		r2,txBuf+MSG_SRC
   2919 0000EFBA 0B 12                   	lw		r2,#11				; recieve BASIC program char
   2920 0000EFBC 02 40 08 C2             	sb		r2,txBuf+MSG_TYPE
   2921 0000EFC0 83 4F 00 AF             	call	Xmit
   2922 0000EFC4 E2 F2                   	lw		r2,2[sp]
   2923 0000EFC6 E0 FF                   	lw		lr,[sp]
   2924 0000EFC8 F0 80                   	ret
                                        ;
                                        ; ===== Input a character from the host into register D0 (or
                                        ;	return negative status if there's no character available).
                                        ;
   2929 0000EFCA                        AUXIN
                                        ; get character from serial port
                                        ; return  N=1 if no character available
   2932 0000EFCA 41 48 0C AE             	jmp		peekSerial
                                        
                                        
   2935 0000EFCE                        _scrollScreen
   2936 0000EFCE FC 6E                   	sub		sp,sp,#4
   2937 0000EFD0 E0 D5                   	sw		r5,[sp]
   2938 0000EFD2 60 40 00 13             	lw		r3,#1536	; number of chars to move - 1
   2939 0000EFD6 00 42 00 12             	lw		r2,#VIDEORAM
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 50
noc_boot.a
   2940 0000EFDA 03 40 00 E1             	lb		r1,txtWidth
   2941 0000EFDE 81 31                   	shl		r1,#1
   2942 0000EFE0 81 31                   	shl		r1,#1
   2943 0000EFE2                        ss1:
   2944 0000EFE2 20 15                   	lw		r5,r2
   2945 0000EFE4 10 25                   	add		r5,r1
   2946 0000EFE6 50 F4                   	lw		r4,[r5]		; char at next line
   2947 0000EFE8 20 D4                   	sw		r4,[r2]		; goes to this line
   2948 0000EFEA 04 62                   	add		r2,r2,#4
   2949 0000EFEC FF 63                   	sub		r3,r3,#1
   2950 0000EFEE F9 B9                   	bne     ss1
                                        	; blank out last line
   2952 0000EFF0 02 40 00 13             	lw		r3,#' '
   2953 0000EFF4 03 40 08 D3             	sh		r3,charToPrint
   2954 0000EFF8 03 40 00 E3             	lb		r3,txtWidth
   2955 0000EFFC 03 40 08 F4             	lw		r4,charToPrint	; and colors
   2956 0000F000                        ss2
   2957 0000F000 20 D4                   	sw		r4,[r2]
   2958 0000F002 04 62                   	add		r2,r2,#4
   2959 0000F004 FF 63                   	sub		r3,r3,#1
   2960 0000F006 FC B9                   	bne     ss2
   2961 0000F008 E0 F5                   	lw		r5,[sp]
   2962 0000F00A 04 6E                   	add		sp,sp,#4
   2963 0000F00C F0 80                   	ret
                                        
                                        
                                        ; flash the character at the screen position
                                        ;   r1: 1 = flash, 0 = no flash
   2968 0000F00E                        _flashCursor
   2969 0000F00E 00 42 00 12             	lw		r2,#VIDEORAM
   2970 0000F012 03 40 04 F3             	lh		r3,pos
   2971 0000F016 81 33                   	shl		r3,#1
   2972 0000F018 81 33                   	shl		r3,#1
   2973 0000F01A 20 23                   	add		r3,r2		; r3 = scr[pos]
                                        
   2975 0000F01C 16 21                   	or		r1,r1
   2976 0000F01E 04 A8                   	beq		fc1
   2977 0000F020 33 E2                   	lb		r2,3[r3]	; get background color
   2978 0000F022 08 40 60 32             	or		r2,#0x80	; set flash indicator
   2979 0000F026 03 AE                   	br		fcx
   2980 0000F028                        fc1
   2981 0000F028 33 E2                   	lb		r2,3[r3]	; get background color
   2982 0000F02A 07 40 5F 32             	and		r2,#0x7f	; clear flash indicator
   2983 0000F02E                        fcx:
   2984 0000F02E 33 C2                   	sb		r2,3[r3]
   2985 0000F030 F0 80                   	ret
                                        
                                        
                                        ; ===== Return to the resident monitor, operating system, etc.
                                        ;
   2990 0000F032                        BYEBYE
   2991 0000F032 08 40 04 FE             	lw		sp,OSSP
   2992 0000F036 E0 FF                       lw      lr,[sp]
   2993 0000F038 02 6E                       add		sp,sp,#2
   2994 0000F03A F0 80                   	ret
                                        
                                        ; Set the message address fields
                                        
   2998 0000F03C                        SetMsgAddr:
   2999 0000F03C E4 31                   	tsr		r1,ID
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 51
noc_boot.a
   3000 0000F03E 02 40 0E C1             	sb		r1,txBuf+MSG_SRC
   3001 0000F042 01 40 01 11             	lw		r1,#$11
   3002 0000F046 02 40 0F C1             	sb		r1,txBuf+MSG_DST
   3003 0000F04A F0 80                   	ret
                                        
   3005 0000F04C                        EXIT
   3006 0000F04C AE 4F 03 AF             	call	OREXPR
   3007 0000F050 7D 4F 06 AF             	call	zeroTxBuf
   3008 0000F054 02 40 00 D1             	sw		r1,txBuf
   3009 0000F058 F1 BF                   	call	SetMsgAddr
   3010 0000F05A 00 40 0D 11             	lw		r1,#MT_BASIC_EXIT
   3011 0000F05E 02 40 08 C1             	sb		r1,txBuf+MSG_TYPE
   3012 0000F062 7D 4F 0F AF             	call	Xmit
   3013 0000F066 82 4F 0F AE             	jmp		WSTART
                                        
   3015 0000F06A                        RequestOutputFocus:
   3016 0000F06A FE 6E                   	add		sp,sp,#-2
   3017 0000F06C E0 DF                   	sw		lr,[sp]
   3018 0000F06E 7C 4F 07 AF             	call	zeroTxBuf
   3019 0000F072 E4 BF                   	call	SetMsgAddr
   3020 0000F074 00 40 0F 11             	lw		r1,#MT_REQ_OUT_FOCUS
   3021 0000F078 02 40 08 C1             	sb		r1,txBuf+MSG_TYPE
   3022 0000F07C 7D 4F 02 AF             	call	Xmit
   3023 0000F080                        ROF1:
   3024 0000F080 01 4B 00 E1             	lb		r1,ROUTER+RTR_RXSTAT
   3025 0000F084 FD B8                   	beq		ROF1
   3026 0000F086 7E 4F 02 AF             	call	Recv
   3027 0000F08A 10 40 0B AF             	call	RecvDispatch
   3028 0000F08E 03 40 08 E1             	lb		r1,rxBuf+MSG_TYPE
   3029 0000F092 FF 4F 10 10             	cmp		r1,#MT_GRNT_OUT_FOCUS
   3030 0000F096 F4 B9                   	bne		ROF1
   3031 0000F098 E0 FF                   	lw		lr,[sp]
   3032 0000F09A 02 6E                   	add		sp,sp,#2
   3033 0000F09C F0 80                   	ret
                                        
                                        ;	MOVE.B	#228,D7 	return to Tutor
                                        ;	TRAP	#14
                                        
   3038 0000F09E 0D 0A 42 75 74 74      msgInit db	CR,LF,"Butterfly Tiny BASIC v1.1",CR,LF,"(C) 2005-2017  Robert Finch",CR,LF,LF,0
   3038 0000F0A4 65 72 66 6C 79 20 54  
   3038 0000F0AB 69 6E 79 20 42 41 53  
   3038 0000F0B2 49 43 20 76 31 2E 31  
   3038 0000F0B9 0D 0A 28 43 29 20 32  
   3038 0000F0C0 30 30 35 2D 32 30 31  
   3038 0000F0C7 37 20 20 52 6F 62 65  
   3038 0000F0CE 72 74 20 46 69 6E 63  
   3038 0000F0D5 68 0D 0A 0A 00        
   3039 0000F0DA 0D 0A 4F 4B 0D 0A      OKMSG	db	CR,LF,"OK",CR,LF,0
   3039 0000F0E0 00                    
   3040 0000F0E1 57 68 61 74 3F 0D      msgWhat	db	"What?",CR,LF,0
   3040 0000F0E7 0A 00                 
   3041 0000F0E9 53 6F 72 72 79 2E      SRYMSG	db	"Sorry."
                                      
   3042 0000F0EF 0D 0A 00               CLMSG	db	CR,LF,0
   3043 0000F0F2 43 6F 6D 70 61 63      msgReadError	db	"Compact FLASH read error",CR,LF,0
   3043 0000F0F8 74 20 46 4C 41 53 48  
   3043 0000F0FF 20 72 65 61 64 20 65  
   3043 0000F106 72 72 6F 72 0D 0A 00  
                                      
   3044 0000F10D 4E 75 6D 62 65 72      msgNumTooBig	db	"Number is too big",CR,LF,0
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 52
noc_boot.a
   3044 0000F113 20 69 73 20 74 6F 6F  
   3044 0000F11A 20 62 69 67 0D 0A 00  
                                      
   3045 0000F121 44 69 76 69 73 69      msgDivZero		db	"Division by zero",CR,LF,0
   3045 0000F127 6F 6E 20 62 79 20 7A  
   3045 0000F12E 65 72 6F 0D 0A 00     
   3046 0000F134 4F 75 74 20 6F 66      msgVarSpace     db  "Out of variable space",CR,LF,0
   3046 0000F13A 20 76 61 72 69 61 62  
   3046 0000F141 6C 65 20 73 70 61 63  
   3046 0000F148 65 0D 0A 00           
   3047 0000F14C 20 62 79 74 65 73      msgBytesFree	db	" bytes free",CR,LF,0
   3047 0000F152 20 66 72 65 65 0D 0A  
   3047 0000F159 00                    
   3048 0000F15A 0D 0A 52 65 61 64      msgReady		db	CR,LF,"Ready",CR,LF,0
   3048 0000F160 79 0D 0A 00           
   3049 0000F164 45 78 70 65 63 74      msgComma		db	"Expecting a comma",CR,LF,0
   3049 0000F16A 69 6E 67 20 61 20 63  
   3049 0000F171 6F 6D 6D 61 0D 0A 00  
                                      
   3050 0000F178 4C 69 6E 65 20 6E      msgLineRange	db	"Line number too big",CR,LF,0
   3050 0000F17E 75 6D 62 65 72 20 74  
   3050 0000F185 6F 6F 20 62 69 67 0D  
   3050 0000F18C 0A 00                 
   3051 0000F18E 45 78 70 65 63 74      msgVar			db	"Expecting a variable",CR,LF,0
   3051 0000F194 69 6E 67 20 61 20 76  
   3051 0000F19B 61 72 69 61 62 6C 65  
   3051 0000F1A2 0D 0A 00              
   3052 0000F1A5 52 4E 44 20 62 61      msgRNDBad		db	"RND bad parameter",CR,LF,0
   3052 0000F1AB 64 20 70 61 72 61 6D  
   3052 0000F1B2 65 74 65 72 0D 0A 00  
                                      
   3053 0000F1B9 53 59 53 20 62 61      msgSYSBad		db	"SYS bad address",CR,LF,0
   3053 0000F1BF 64 20 61 64 64 72 65  
   3053 0000F1C6 73 73 0D 0A 00        
   3054 0000F1CB 49 4E 50 55 54 20      msgInputVar		db	"INPUT expecting a variable",CR,LF,0
   3054 0000F1D1 65 78 70 65 63 74 69  
   3054 0000F1D8 6E 67 20 61 20 76 61  
   3054 0000F1DF 72 69 61 62 6C 65 0D  
   3054 0000F1E6 0A 00                 
   3055 0000F1E8 4E 45 58 54 20 77      msgNextFor		db	"NEXT without FOR",CR,LF,0
   3055 0000F1EE 69 74 68 6F 75 74 20  
   3055 0000F1F5 46 4F 52 0D 0A 00     
   3056 0000F1FB 4E 45 58 54 20 65      msgNextVar		db	"NEXT expecting a defined variable",CR,LF,0
   3056 0000F201 78 70 65 63 74 69 6E  
   3056 0000F208 67 20 61 20 64 65 66  
   3056 0000F20F 69 6E 65 64 20 76 61  
   3056 0000F216 72 69 61 62 6C 65 0D  
   3056 0000F21D 0A 00                 
   3057 0000F21F 47 4F 54 4F 2F 47      msgBadGotoGosub	db	"GOTO/GOSUB bad line number",CR,LF,0
   3057 0000F225 4F 53 55 42 20 62 61  
   3057 0000F22C 64 20 6C 69 6E 65 20  
   3057 0000F233 6E 75 6D 62 65 72 0D  
   3057 0000F23A 0A 00                 
   3058 0000F23C 52 45 54 55 52 4E      msgRetWoGosub   db	"RETURN without GOSUB",CR,LF,0
   3058 0000F242 20 77 69 74 68 6F 75  
   3058 0000F249 74 20 47 4F 53 55 42  
   3058 0000F250 0D 0A 00              
   3059 0000F253 50 72 6F 67 72 61      msgTooBig		db	"Program is too big",CR,LF,0
   3059 0000F259 6D 20 69 73 20 74 6F  
   3059 0000F260 6F 20 62 69 67 0D 0A  
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 53
noc_boot.a
   3059 0000F267 00                    
   3060 0000F268 45 78 74 72 61 20      msgExtraChars	db	"Extra characters on line ignored",CR,LF,0
   3060 0000F26E 63 68 61 72 61 63 74  
   3060 0000F275 65 72 73 20 6F 6E 20  
   3060 0000F27C 6C 69 6E 65 20 69 67  
   3060 0000F283 6E 6F 72 65 64 0D 0A  
   3060 0000F28A 00                    
                                        
   3062 0000F28B FF                      	.align	4
   3129 = 0000F28C                      LSTROM	equ	*		; end of possible ROM area
                                        ;
                                        ; Internal variables follow:
                                        ;
                                        		bss
                                        		org		0x0030
   3069 00000030                        txtWidth	db	0		; BIOS var =60
   3070 00000031                        txtHeight	db	0		; BIOS var =27
   3071 00000032                        cursx	db		0		; cursor x position
   3072 00000033                        cursy	db		0		; cursor y position
   3073 00000034                        pos		dw		0		; text screen position
   3074 00000036                        tgtNode	db		0
   3075 00000037                        srcNode	db		0
                                        		org		0x0038
   3077 00000038                        charToPrint		dw		0
   3078 0000003A                        fgColor			db		0
   3079 0000003B                        bkColor			db		0
   3080 0000003C                        cursFlash		db		0	; flash the cursor ?
   3081 0000003D                         				db		0
   3082 0000003E                        NormAttr		dw		0
                                        
   3084 00000040                        lineLinkTbl		fill.b	25,0	; screen line link table
   3085 00000059                         	align 4
                                        
                                        		org		0x0080
   3088 00000080                        typef   db      0   ; variable / expression type
   3089 00000081                                 align   4
   3090 00000084                        OSSP	dw	1	; OS value of sp
   3091 00000086                        CURRNT	dw	1	;	Current line pointer
   3092 00000088                        STKGOS	dw	1	;	Saves stack pointer in 'GOSUB'
   3093 0000008A                        STKINP	dw	1	;	Saves stack pointer during 'INPUT'
   3094 0000008C                        LOPVAR	dw	1	;	'FOR' loop save area
   3095 0000008E                        LOPINC	dw	1	;	increment
   3096 00000090                        LOPLMT	dw	1	;	limit
   3097 00000092                        LOPLN	dw	1	;	line number
   3098 00000094                        LOPPT	dw	1	;	text pointer
   3099 00000096                        TXTUNF	dw	1	;	points to unfilled text area
   3100 00000098                        VARBGN	dw	1	;	points to variable area
   3101 0000009A                        IVARBGN dw  1   ;   points to integer variable area
   3102 0000009C                        SVARBGN dw  1   ;   points to string variable area
   3103 0000009E                        FVARBGN dw  1   ;   points to float variable area
   3104 000000A0                        STKBOT	dw	1	;	holds lower limit for stack growth
   3105 000000A2                        NUMWKA	fill.b	12,0			; numeric work area
   3106 000000AE                        BUFFER	fill.b	BUFLEN,0x00		;		Keyboard input buffer
                                        
                                                bss
                                                org     0x2000
   3110 00002000                        textScr1
                                                org     0x2000
                                        ;	END
                                        
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 54
noc_boot.a
                                        ; Operation of an ordinary (worker) node is pretty simple. It just waits in
                                        ; loop polling for recieved messages which are then dispatched.
                                        
                                        		.code
   3118 0000F28C                        start:
   3119 0000F28C FF 41 0E 1E             		lw		sp,#$1FFE
   3120 0000F290                        noMsg1:
   3121 0000F290 01 4B 00 E1             		lb		r1,ROUTER+RTR_RXSTAT
   3122 0000F294 03 40 5F 31             		and		r1,#63
   3123 0000F298 FB B8                   		beq		noMsg1
   3124 0000F29A 6D 4F 08 AF             		call	Recv
   3125 0000F29E 02 AF                   		call	RecvDispatch
   3126 0000F2A0 F5 BE                   		bra		start
   3127 0000F2A2                        lockup:
   3128 0000F2A2 FF BE                   		bra		lockup
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Receiver dispatch
                                        ;
                                        ; Executes different message handlers based on the message type.
                                        ;----------------------------------------------------------------------------
                                        
   3136 0000F2A4                        RecvDispatch:
   3137 0000F2A4 FC 6E                   		add		sp,sp,#-4
   3138 0000F2A6 E0 DF                   		sw		lr,[sp]
   3139 0000F2A8 E2 D1                   		sw		r1,2[sp]
   3140 0000F2AA 03 40 08 E1             		lb		r1,rxBuf+MSG_TYPE
   3141 0000F2AE 1F 10                   		cmp		r1,#MT_RST			; reset message ?
   3142 0000F2B0 0C A9                   		bne		RecvDispatch2
                                        		; Send back a reset ACK message to indicate node is good to go.
   3144 0000F2B2 6A 4F 05 AF             		call	zeroTxBuf
   3145 0000F2B6 01 40 01 11             		lw		r1,#$11
   3146 0000F2BA 02 40 0F C1             		sb		r1,txBuf+MSG_DST
   3147 0000F2BE 02 11                   		lw		r1,#MT_RST_ACK
   3148 0000F2C0 02 40 08 C1             		sb		r1,txBuf+MSG_TYPE
   3149 0000F2C4 6A 4F 0E AF             		call	Xmit
   3150 0000F2C8 44 AE                   		br		RecvDispatch5
   3151 0000F2CA                        RecvDispatch2:
   3152 0000F2CA FF 4F 17 10             		cmp		r1,#MT_PING
   3153 0000F2CE 0D A9                   		bne		RecvDispatch9
   3154 0000F2D0 69 4F 06 AF             		call	zeroTxBuf
   3155 0000F2D4 03 40 0E E1             		lb		r1,rxBuf+MSG_SRC
   3156 0000F2D8 02 40 0F C1             		sb		r1,txBuf+MSG_DST
   3157 0000F2DC 01 40 02 11             		lw		r1,#MT_PING_ACK
   3158 0000F2E0 02 40 08 C1             		sb		r1,txBuf+MSG_TYPE
   3159 0000F2E4 69 4F 0E AF             		call	Xmit
   3160 0000F2E8 34 AE                   		br		RecvDispatchXit
   3161 0000F2EA                        RecvDispatch9:
   3162 0000F2EA FF 4F 16 10             		cmp		r1,#MT_START_BASIC_LOAD	; start BASIC load
   3163 0000F2EE 07 A9                   		bne		RecvDispatch3
   3164 0000F2F0 03 40 0E E1             		lb		r1,rxBuf+MSG_SRC
   3165 0000F2F4 6C 4F 0E AF             		call	INITTBW
   3166 0000F2F8 09 4E 00 F8             		lw		r8,TXTBGN			; r8 = text begin
   3167 0000F2FC 2A AE                   		br		RecvDispatch5
   3168 0000F2FE                        RecvDispatch3:
   3169 0000F2FE FF 4F 15 10             		cmp		r1,#MT_LOAD_BASIC_CHAR	; load BASIC program char
   3170 0000F302 0D A9                   		bne		RecvDispatch4
   3171 0000F304 03 40 00 F1             		lw		r1,rxBuf
   3172 0000F308 80 D1                   		sw		r1,[r8]
   3173 0000F30A 03 40 02 F1             		lw		r1,rxBuf+2
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 55
noc_boot.a
   3174 0000F30E 82 D1                   		sw		r1,2[r8]
   3175 0000F310 03 40 04 F1             		lw		r1,rxBuf+4
   3176 0000F314 84 D1                   		sw		r1,4[r8]
   3177 0000F316 06 68                   		add		r8,r8,#6
   3178 0000F318 09 40 06 D8             		sw		r8,TXTUNF
   3179 0000F31C 1A AE                   		br		RecvDispatch5
   3180 0000F31E                        RecvDispatch4:
                                        		; Run a BASIC program by stuffing a 'RUN' command into the BASIC
                                        		; buffer.
   3183 0000F31E FF 4F 14 10             		cmp		r1,#MT_RUN_BASIC_PROG
   3184 0000F322 17 A9                   		bne		RecvDispatch5
   3185 0000F324 05 40 02 11             		lw		r1,#'R'
   3186 0000F328 0A 40 0E C1             		sb		r1,BUFFER
   3187 0000F32C 05 40 05 11             		lw		r1,#'U'
   3188 0000F330 0A 40 0F C1             		sb		r1,BUFFER+1
   3189 0000F334 04 40 0E 11             		lw		r1,#'N'
   3190 0000F338 0B 40 00 C1             		sb		r1,BUFFER+2
   3191 0000F33C 00 40 0D 11             		lw		r1,#13
   3192 0000F340 0B 40 01 C1             		sb		r1,BUFFER+3
   3193 0000F344 0B 40 02 C0             		sb		r0,BUFFER+4
   3194 0000F348 0B 40 02 18             		lw		r8,#BUFFER+4
   3195 0000F34C 6C 4F 07 AF             		call	ST3
   3196 0000F350 00 AE                   		br		RecvDispatch5
   3197 0000F352                        RecvDispatch5:
   3198 0000F352                        RecvDispatchXit:
   3199 0000F352 E0 FF                   		lw		lr,[sp]
   3200 0000F354 E2 F1                   		lw		r1,2[sp]
   3201 0000F356 04 6E                   		add		sp,sp,#4
   3202 0000F358 F0 80                   		ret
                                        
   3204 0000F35A FF FF FF FF FF FF FF    		org		0xFFFE
   3204 0000F361 FF FF FF FF FF FF FF  
   3204 0000F368 FF FF FF FF FF FF FF  
   3204 0000F36F FF FF FF FF FF FF FF  
   3204 0000F376 FF FF FF FF FF FF FF  
   3204 0000F37D FF FF FF FF FF FF FF  
   3204 0000F384 FF FF FF FF FF FF FF  
   3204 0000F38B FF FF FF FF FF FF FF  
   3204 0000F392 FF FF FF FF FF FF FF  
   3204 0000F399 FF FF FF FF FF FF FF  
   3204 0000F3A0 FF FF FF FF FF FF FF  
   3204 0000F3A7 FF FF FF FF FF FF FF  
   3204 0000F3AE FF FF FF FF FF FF FF  
   3204 0000F3B5 FF FF FF FF FF FF FF  
   3204 0000F3BC FF FF FF FF FF FF FF  
   3204 0000F3C3 FF FF FF FF FF FF FF  
   3204 0000F3CA FF FF FF FF FF FF FF  
   3204 0000F3D1 FF FF FF FF FF FF FF  
   3204 0000F3D8 FF FF FF FF FF FF FF  
   3204 0000F3DF FF FF FF FF FF FF FF  
   3204 0000F3E6 FF FF FF FF FF FF FF  
   3204 0000F3ED FF FF FF FF FF FF FF  
   3204 0000F3F4 FF FF FF FF FF FF FF  
   3204 0000F3FB FF FF FF FF FF FF FF  
   3204 0000F402 FF FF FF FF FF FF FF  
   3204 0000F409 FF FF FF FF FF FF FF  
   3204 0000F410 FF FF FF FF FF FF FF  
   3204 0000F417 FF FF FF FF FF FF FF  
   3204 0000F41E FF FF FF FF FF FF FF  
   3204 0000F425 FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 56
noc_boot.a
   3204 0000F42C FF FF FF FF FF FF FF  
   3204 0000F433 FF FF FF FF FF FF FF  
   3204 0000F43A FF FF FF FF FF FF FF  
   3204 0000F441 FF FF FF FF FF FF FF  
   3204 0000F448 FF FF FF FF FF FF FF  
   3204 0000F44F FF FF FF FF FF FF FF  
   3204 0000F456 FF FF FF FF FF FF FF  
   3204 0000F45D FF FF FF FF FF FF FF  
   3204 0000F464 FF FF FF FF FF FF FF  
   3204 0000F46B FF FF FF FF FF FF FF  
   3204 0000F472 FF FF FF FF FF FF FF  
   3204 0000F479 FF FF FF FF FF FF FF  
   3204 0000F480 FF FF FF FF FF FF FF  
   3204 0000F487 FF FF FF FF FF FF FF  
   3204 0000F48E FF FF FF FF FF FF FF  
   3204 0000F495 FF FF FF FF FF FF FF  
   3204 0000F49C FF FF FF FF FF FF FF  
   3204 0000F4A3 FF FF FF FF FF FF FF  
   3204 0000F4AA FF FF FF FF FF FF FF  
   3204 0000F4B1 FF FF FF FF FF FF FF  
   3204 0000F4B8 FF FF FF FF FF FF FF  
   3204 0000F4BF FF FF FF FF FF FF FF  
   3204 0000F4C6 FF FF FF FF FF FF FF  
   3204 0000F4CD FF FF FF FF FF FF FF  
   3204 0000F4D4 FF FF FF FF FF FF FF  
   3204 0000F4DB FF FF FF FF FF FF FF  
   3204 0000F4E2 FF FF FF FF FF FF FF  
   3204 0000F4E9 FF FF FF FF FF FF FF  
   3204 0000F4F0 FF FF FF FF FF FF FF  
   3204 0000F4F7 FF FF FF FF FF FF FF  
   3204 0000F4FE FF FF FF FF FF FF FF  
   3204 0000F505 FF FF FF FF FF FF FF  
   3204 0000F50C FF FF FF FF FF FF FF  
   3204 0000F513 FF FF FF FF FF FF FF  
   3204 0000F51A FF FF FF FF FF FF FF  
   3204 0000F521 FF FF FF FF FF FF FF  
   3204 0000F528 FF FF FF FF FF FF FF  
   3204 0000F52F FF FF FF FF FF FF FF  
   3204 0000F536 FF FF FF FF FF FF FF  
   3204 0000F53D FF FF FF FF FF FF FF  
   3204 0000F544 FF FF FF FF FF FF FF  
   3204 0000F54B FF FF FF FF FF FF FF  
   3204 0000F552 FF FF FF FF FF FF FF  
   3204 0000F559 FF FF FF FF FF FF FF  
   3204 0000F560 FF FF FF FF FF FF FF  
   3204 0000F567 FF FF FF FF FF FF FF  
   3204 0000F56E FF FF FF FF FF FF FF  
   3204 0000F575 FF FF FF FF FF FF FF  
   3204 0000F57C FF FF FF FF FF FF FF  
   3204 0000F583 FF FF FF FF FF FF FF  
   3204 0000F58A FF FF FF FF FF FF FF  
   3204 0000F591 FF FF FF FF FF FF FF  
   3204 0000F598 FF FF FF FF FF FF FF  
   3204 0000F59F FF FF FF FF FF FF FF  
   3204 0000F5A6 FF FF FF FF FF FF FF  
   3204 0000F5AD FF FF FF FF FF FF FF  
   3204 0000F5B4 FF FF FF FF FF FF FF  
   3204 0000F5BB FF FF FF FF FF FF FF  
   3204 0000F5C2 FF FF FF FF FF FF FF  
   3204 0000F5C9 FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 57
noc_boot.a
   3204 0000F5D0 FF FF FF FF FF FF FF  
   3204 0000F5D7 FF FF FF FF FF FF FF  
   3204 0000F5DE FF FF FF FF FF FF FF  
   3204 0000F5E5 FF FF FF FF FF FF FF  
   3204 0000F5EC FF FF FF FF FF FF FF  
   3204 0000F5F3 FF FF FF FF FF FF FF  
   3204 0000F5FA FF FF FF FF FF FF FF  
   3204 0000F601 FF FF FF FF FF FF FF  
   3204 0000F608 FF FF FF FF FF FF FF  
   3204 0000F60F FF FF FF FF FF FF FF  
   3204 0000F616 FF FF FF FF FF FF FF  
   3204 0000F61D FF FF FF FF FF FF FF  
   3204 0000F624 FF FF FF FF FF FF FF  
   3204 0000F62B FF FF FF FF FF FF FF  
   3204 0000F632 FF FF FF FF FF FF FF  
   3204 0000F639 FF FF FF FF FF FF FF  
   3204 0000F640 FF FF FF FF FF FF FF  
   3204 0000F647 FF FF FF FF FF FF FF  
   3204 0000F64E FF FF FF FF FF FF FF  
   3204 0000F655 FF FF FF FF FF FF FF  
   3204 0000F65C FF FF FF FF FF FF FF  
   3204 0000F663 FF FF FF FF FF FF FF  
   3204 0000F66A FF FF FF FF FF FF FF  
   3204 0000F671 FF FF FF FF FF FF FF  
   3204 0000F678 FF FF FF FF FF FF FF  
   3204 0000F67F FF FF FF FF FF FF FF  
   3204 0000F686 FF FF FF FF FF FF FF  
   3204 0000F68D FF FF FF FF FF FF FF  
   3204 0000F694 FF FF FF FF FF FF FF  
   3204 0000F69B FF FF FF FF FF FF FF  
   3204 0000F6A2 FF FF FF FF FF FF FF  
   3204 0000F6A9 FF FF FF FF FF FF FF  
   3204 0000F6B0 FF FF FF FF FF FF FF  
   3204 0000F6B7 FF FF FF FF FF FF FF  
   3204 0000F6BE FF FF FF FF FF FF FF  
   3204 0000F6C5 FF FF FF FF FF FF FF  
   3204 0000F6CC FF FF FF FF FF FF FF  
   3204 0000F6D3 FF FF FF FF FF FF FF  
   3204 0000F6DA FF FF FF FF FF FF FF  
   3204 0000F6E1 FF FF FF FF FF FF FF  
   3204 0000F6E8 FF FF FF FF FF FF FF  
   3204 0000F6EF FF FF FF FF FF FF FF  
   3204 0000F6F6 FF FF FF FF FF FF FF  
   3204 0000F6FD FF FF FF FF FF FF FF  
   3204 0000F704 FF FF FF FF FF FF FF  
   3204 0000F70B FF FF FF FF FF FF FF  
   3204 0000F712 FF FF FF FF FF FF FF  
   3204 0000F719 FF FF FF FF FF FF FF  
   3204 0000F720 FF FF FF FF FF FF FF  
   3204 0000F727 FF FF FF FF FF FF FF  
   3204 0000F72E FF FF FF FF FF FF FF  
   3204 0000F735 FF FF FF FF FF FF FF  
   3204 0000F73C FF FF FF FF FF FF FF  
   3204 0000F743 FF FF FF FF FF FF FF  
   3204 0000F74A FF FF FF FF FF FF FF  
   3204 0000F751 FF FF FF FF FF FF FF  
   3204 0000F758 FF FF FF FF FF FF FF  
   3204 0000F75F FF FF FF FF FF FF FF  
   3204 0000F766 FF FF FF FF FF FF FF  
   3204 0000F76D FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 58
noc_boot.a
   3204 0000F774 FF FF FF FF FF FF FF  
   3204 0000F77B FF FF FF FF FF FF FF  
   3204 0000F782 FF FF FF FF FF FF FF  
   3204 0000F789 FF FF FF FF FF FF FF  
   3204 0000F790 FF FF FF FF FF FF FF  
   3204 0000F797 FF FF FF FF FF FF FF  
   3204 0000F79E FF FF FF FF FF FF FF  
   3204 0000F7A5 FF FF FF FF FF FF FF  
   3204 0000F7AC FF FF FF FF FF FF FF  
   3204 0000F7B3 FF FF FF FF FF FF FF  
   3204 0000F7BA FF FF FF FF FF FF FF  
   3204 0000F7C1 FF FF FF FF FF FF FF  
   3204 0000F7C8 FF FF FF FF FF FF FF  
   3204 0000F7CF FF FF FF FF FF FF FF  
   3204 0000F7D6 FF FF FF FF FF FF FF  
   3204 0000F7DD FF FF FF FF FF FF FF  
   3204 0000F7E4 FF FF FF FF FF FF FF  
   3204 0000F7EB FF FF FF FF FF FF FF  
   3204 0000F7F2 FF FF FF FF FF FF FF  
   3204 0000F7F9 FF FF FF FF FF FF FF  
   3204 0000F800 FF FF FF FF FF FF FF  
   3204 0000F807 FF FF FF FF FF FF FF  
   3204 0000F80E FF FF FF FF FF FF FF  
   3204 0000F815 FF FF FF FF FF FF FF  
   3204 0000F81C FF FF FF FF FF FF FF  
   3204 0000F823 FF FF FF FF FF FF FF  
   3204 0000F82A FF FF FF FF FF FF FF  
   3204 0000F831 FF FF FF FF FF FF FF  
   3204 0000F838 FF FF FF FF FF FF FF  
   3204 0000F83F FF FF FF FF FF FF FF  
   3204 0000F846 FF FF FF FF FF FF FF  
   3204 0000F84D FF FF FF FF FF FF FF  
   3204 0000F854 FF FF FF FF FF FF FF  
   3204 0000F85B FF FF FF FF FF FF FF  
   3204 0000F862 FF FF FF FF FF FF FF  
   3204 0000F869 FF FF FF FF FF FF FF  
   3204 0000F870 FF FF FF FF FF FF FF  
   3204 0000F877 FF FF FF FF FF FF FF  
   3204 0000F87E FF FF FF FF FF FF FF  
   3204 0000F885 FF FF FF FF FF FF FF  
   3204 0000F88C FF FF FF FF FF FF FF  
   3204 0000F893 FF FF FF FF FF FF FF  
   3204 0000F89A FF FF FF FF FF FF FF  
   3204 0000F8A1 FF FF FF FF FF FF FF  
   3204 0000F8A8 FF FF FF FF FF FF FF  
   3204 0000F8AF FF FF FF FF FF FF FF  
   3204 0000F8B6 FF FF FF FF FF FF FF  
   3204 0000F8BD FF FF FF FF FF FF FF  
   3204 0000F8C4 FF FF FF FF FF FF FF  
   3204 0000F8CB FF FF FF FF FF FF FF  
   3204 0000F8D2 FF FF FF FF FF FF FF  
   3204 0000F8D9 FF FF FF FF FF FF FF  
   3204 0000F8E0 FF FF FF FF FF FF FF  
   3204 0000F8E7 FF FF FF FF FF FF FF  
   3204 0000F8EE FF FF FF FF FF FF FF  
   3204 0000F8F5 FF FF FF FF FF FF FF  
   3204 0000F8FC FF FF FF FF FF FF FF  
   3204 0000F903 FF FF FF FF FF FF FF  
   3204 0000F90A FF FF FF FF FF FF FF  
   3204 0000F911 FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 59
noc_boot.a
   3204 0000F918 FF FF FF FF FF FF FF  
   3204 0000F91F FF FF FF FF FF FF FF  
   3204 0000F926 FF FF FF FF FF FF FF  
   3204 0000F92D FF FF FF FF FF FF FF  
   3204 0000F934 FF FF FF FF FF FF FF  
   3204 0000F93B FF FF FF FF FF FF FF  
   3204 0000F942 FF FF FF FF FF FF FF  
   3204 0000F949 FF FF FF FF FF FF FF  
   3204 0000F950 FF FF FF FF FF FF FF  
   3204 0000F957 FF FF FF FF FF FF FF  
   3204 0000F95E FF FF FF FF FF FF FF  
   3204 0000F965 FF FF FF FF FF FF FF  
   3204 0000F96C FF FF FF FF FF FF FF  
   3204 0000F973 FF FF FF FF FF FF FF  
   3204 0000F97A FF FF FF FF FF FF FF  
   3204 0000F981 FF FF FF FF FF FF FF  
   3204 0000F988 FF FF FF FF FF FF FF  
   3204 0000F98F FF FF FF FF FF FF FF  
   3204 0000F996 FF FF FF FF FF FF FF  
   3204 0000F99D FF FF FF FF FF FF FF  
   3204 0000F9A4 FF FF FF FF FF FF FF  
   3204 0000F9AB FF FF FF FF FF FF FF  
   3204 0000F9B2 FF FF FF FF FF FF FF  
   3204 0000F9B9 FF FF FF FF FF FF FF  
   3204 0000F9C0 FF FF FF FF FF FF FF  
   3204 0000F9C7 FF FF FF FF FF FF FF  
   3204 0000F9CE FF FF FF FF FF FF FF  
   3204 0000F9D5 FF FF FF FF FF FF FF  
   3204 0000F9DC FF FF FF FF FF FF FF  
   3204 0000F9E3 FF FF FF FF FF FF FF  
   3204 0000F9EA FF FF FF FF FF FF FF  
   3204 0000F9F1 FF FF FF FF FF FF FF  
   3204 0000F9F8 FF FF FF FF FF FF FF  
   3204 0000F9FF FF FF FF FF FF FF FF  
   3204 0000FA06 FF FF FF FF FF FF FF  
   3204 0000FA0D FF FF FF FF FF FF FF  
   3204 0000FA14 FF FF FF FF FF FF FF  
   3204 0000FA1B FF FF FF FF FF FF FF  
   3204 0000FA22 FF FF FF FF FF FF FF  
   3204 0000FA29 FF FF FF FF FF FF FF  
   3204 0000FA30 FF FF FF FF FF FF FF  
   3204 0000FA37 FF FF FF FF FF FF FF  
   3204 0000FA3E FF FF FF FF FF FF FF  
   3204 0000FA45 FF FF FF FF FF FF FF  
   3204 0000FA4C FF FF FF FF FF FF FF  
   3204 0000FA53 FF FF FF FF FF FF FF  
   3204 0000FA5A FF FF FF FF FF FF FF  
   3204 0000FA61 FF FF FF FF FF FF FF  
   3204 0000FA68 FF FF FF FF FF FF FF  
   3204 0000FA6F FF FF FF FF FF FF FF  
   3204 0000FA76 FF FF FF FF FF FF FF  
   3204 0000FA7D FF FF FF FF FF FF FF  
   3204 0000FA84 FF FF FF FF FF FF FF  
   3204 0000FA8B FF FF FF FF FF FF FF  
   3204 0000FA92 FF FF FF FF FF FF FF  
   3204 0000FA99 FF FF FF FF FF FF FF  
   3204 0000FAA0 FF FF FF FF FF FF FF  
   3204 0000FAA7 FF FF FF FF FF FF FF  
   3204 0000FAAE FF FF FF FF FF FF FF  
   3204 0000FAB5 FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 60
noc_boot.a
   3204 0000FABC FF FF FF FF FF FF FF  
   3204 0000FAC3 FF FF FF FF FF FF FF  
   3204 0000FACA FF FF FF FF FF FF FF  
   3204 0000FAD1 FF FF FF FF FF FF FF  
   3204 0000FAD8 FF FF FF FF FF FF FF  
   3204 0000FADF FF FF FF FF FF FF FF  
   3204 0000FAE6 FF FF FF FF FF FF FF  
   3204 0000FAED FF FF FF FF FF FF FF  
   3204 0000FAF4 FF FF FF FF FF FF FF  
   3204 0000FAFB FF FF FF FF FF FF FF  
   3204 0000FB02 FF FF FF FF FF FF FF  
   3204 0000FB09 FF FF FF FF FF FF FF  
   3204 0000FB10 FF FF FF FF FF FF FF  
   3204 0000FB17 FF FF FF FF FF FF FF  
   3204 0000FB1E FF FF FF FF FF FF FF  
   3204 0000FB25 FF FF FF FF FF FF FF  
   3204 0000FB2C FF FF FF FF FF FF FF  
   3204 0000FB33 FF FF FF FF FF FF FF  
   3204 0000FB3A FF FF FF FF FF FF FF  
   3204 0000FB41 FF FF FF FF FF FF FF  
   3204 0000FB48 FF FF FF FF FF FF FF  
   3204 0000FB4F FF FF FF FF FF FF FF  
   3204 0000FB56 FF FF FF FF FF FF FF  
   3204 0000FB5D FF FF FF FF FF FF FF  
   3204 0000FB64 FF FF FF FF FF FF FF  
   3204 0000FB6B FF FF FF FF FF FF FF  
   3204 0000FB72 FF FF FF FF FF FF FF  
   3204 0000FB79 FF FF FF FF FF FF FF  
   3204 0000FB80 FF FF FF FF FF FF FF  
   3204 0000FB87 FF FF FF FF FF FF FF  
   3204 0000FB8E FF FF FF FF FF FF FF  
   3204 0000FB95 FF FF FF FF FF FF FF  
   3204 0000FB9C FF FF FF FF FF FF FF  
   3204 0000FBA3 FF FF FF FF FF FF FF  
   3204 0000FBAA FF FF FF FF FF FF FF  
   3204 0000FBB1 FF FF FF FF FF FF FF  
   3204 0000FBB8 FF FF FF FF FF FF FF  
   3204 0000FBBF FF FF FF FF FF FF FF  
   3204 0000FBC6 FF FF FF FF FF FF FF  
   3204 0000FBCD FF FF FF FF FF FF FF  
   3204 0000FBD4 FF FF FF FF FF FF FF  
   3204 0000FBDB FF FF FF FF FF FF FF  
   3204 0000FBE2 FF FF FF FF FF FF FF  
   3204 0000FBE9 FF FF FF FF FF FF FF  
   3204 0000FBF0 FF FF FF FF FF FF FF  
   3204 0000FBF7 FF FF FF FF FF FF FF  
   3204 0000FBFE FF FF FF FF FF FF FF  
   3204 0000FC05 FF FF FF FF FF FF FF  
   3204 0000FC0C FF FF FF FF FF FF FF  
   3204 0000FC13 FF FF FF FF FF FF FF  
   3204 0000FC1A FF FF FF FF FF FF FF  
   3204 0000FC21 FF FF FF FF FF FF FF  
   3204 0000FC28 FF FF FF FF FF FF FF  
   3204 0000FC2F FF FF FF FF FF FF FF  
   3204 0000FC36 FF FF FF FF FF FF FF  
   3204 0000FC3D FF FF FF FF FF FF FF  
   3204 0000FC44 FF FF FF FF FF FF FF  
   3204 0000FC4B FF FF FF FF FF FF FF  
   3204 0000FC52 FF FF FF FF FF FF FF  
   3204 0000FC59 FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 61
noc_boot.a
   3204 0000FC60 FF FF FF FF FF FF FF  
   3204 0000FC67 FF FF FF FF FF FF FF  
   3204 0000FC6E FF FF FF FF FF FF FF  
   3204 0000FC75 FF FF FF FF FF FF FF  
   3204 0000FC7C FF FF FF FF FF FF FF  
   3204 0000FC83 FF FF FF FF FF FF FF  
   3204 0000FC8A FF FF FF FF FF FF FF  
   3204 0000FC91 FF FF FF FF FF FF FF  
   3204 0000FC98 FF FF FF FF FF FF FF  
   3204 0000FC9F FF FF FF FF FF FF FF  
   3204 0000FCA6 FF FF FF FF FF FF FF  
   3204 0000FCAD FF FF FF FF FF FF FF  
   3204 0000FCB4 FF FF FF FF FF FF FF  
   3204 0000FCBB FF FF FF FF FF FF FF  
   3204 0000FCC2 FF FF FF FF FF FF FF  
   3204 0000FCC9 FF FF FF FF FF FF FF  
   3204 0000FCD0 FF FF FF FF FF FF FF  
   3204 0000FCD7 FF FF FF FF FF FF FF  
   3204 0000FCDE FF FF FF FF FF FF FF  
   3204 0000FCE5 FF FF FF FF FF FF FF  
   3204 0000FCEC FF FF FF FF FF FF FF  
   3204 0000FCF3 FF FF FF FF FF FF FF  
   3204 0000FCFA FF FF FF FF FF FF FF  
   3204 0000FD01 FF FF FF FF FF FF FF  
   3204 0000FD08 FF FF FF FF FF FF FF  
   3204 0000FD0F FF FF FF FF FF FF FF  
   3204 0000FD16 FF FF FF FF FF FF FF  
   3204 0000FD1D FF FF FF FF FF FF FF  
   3204 0000FD24 FF FF FF FF FF FF FF  
   3204 0000FD2B FF FF FF FF FF FF FF  
   3204 0000FD32 FF FF FF FF FF FF FF  
   3204 0000FD39 FF FF FF FF FF FF FF  
   3204 0000FD40 FF FF FF FF FF FF FF  
   3204 0000FD47 FF FF FF FF FF FF FF  
   3204 0000FD4E FF FF FF FF FF FF FF  
   3204 0000FD55 FF FF FF FF FF FF FF  
   3204 0000FD5C FF FF FF FF FF FF FF  
   3204 0000FD63 FF FF FF FF FF FF FF  
   3204 0000FD6A FF FF FF FF FF FF FF  
   3204 0000FD71 FF FF FF FF FF FF FF  
   3204 0000FD78 FF FF FF FF FF FF FF  
   3204 0000FD7F FF FF FF FF FF FF FF  
   3204 0000FD86 FF FF FF FF FF FF FF  
   3204 0000FD8D FF FF FF FF FF FF FF  
   3204 0000FD94 FF FF FF FF FF FF FF  
   3204 0000FD9B FF FF FF FF FF FF FF  
   3204 0000FDA2 FF FF FF FF FF FF FF  
   3204 0000FDA9 FF FF FF FF FF FF FF  
   3204 0000FDB0 FF FF FF FF FF FF FF  
   3204 0000FDB7 FF FF FF FF FF FF FF  
   3204 0000FDBE FF FF FF FF FF FF FF  
   3204 0000FDC5 FF FF FF FF FF FF FF  
   3204 0000FDCC FF FF FF FF FF FF FF  
   3204 0000FDD3 FF FF FF FF FF FF FF  
   3204 0000FDDA FF FF FF FF FF FF FF  
   3204 0000FDE1 FF FF FF FF FF FF FF  
   3204 0000FDE8 FF FF FF FF FF FF FF  
   3204 0000FDEF FF FF FF FF FF FF FF  
   3204 0000FDF6 FF FF FF FF FF FF FF  
   3204 0000FDFD FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 62
noc_boot.a
   3204 0000FE04 FF FF FF FF FF FF FF  
   3204 0000FE0B FF FF FF FF FF FF FF  
   3204 0000FE12 FF FF FF FF FF FF FF  
   3204 0000FE19 FF FF FF FF FF FF FF  
   3204 0000FE20 FF FF FF FF FF FF FF  
   3204 0000FE27 FF FF FF FF FF FF FF  
   3204 0000FE2E FF FF FF FF FF FF FF  
   3204 0000FE35 FF FF FF FF FF FF FF  
   3204 0000FE3C FF FF FF FF FF FF FF  
   3204 0000FE43 FF FF FF FF FF FF FF  
   3204 0000FE4A FF FF FF FF FF FF FF  
   3204 0000FE51 FF FF FF FF FF FF FF  
   3204 0000FE58 FF FF FF FF FF FF FF  
   3204 0000FE5F FF FF FF FF FF FF FF  
   3204 0000FE66 FF FF FF FF FF FF FF  
   3204 0000FE6D FF FF FF FF FF FF FF  
   3204 0000FE74 FF FF FF FF FF FF FF  
   3204 0000FE7B FF FF FF FF FF FF FF  
   3204 0000FE82 FF FF FF FF FF FF FF  
   3204 0000FE89 FF FF FF FF FF FF FF  
   3204 0000FE90 FF FF FF FF FF FF FF  
   3204 0000FE97 FF FF FF FF FF FF FF  
   3204 0000FE9E FF FF FF FF FF FF FF  
   3204 0000FEA5 FF FF FF FF FF FF FF  
   3204 0000FEAC FF FF FF FF FF FF FF  
   3204 0000FEB3 FF FF FF FF FF FF FF  
   3204 0000FEBA FF FF FF FF FF FF FF  
   3204 0000FEC1 FF FF FF FF FF FF FF  
   3204 0000FEC8 FF FF FF FF FF FF FF  
   3204 0000FECF FF FF FF FF FF FF FF  
   3204 0000FED6 FF FF FF FF FF FF FF  
   3204 0000FEDD FF FF FF FF FF FF FF  
   3204 0000FEE4 FF FF FF FF FF FF FF  
   3204 0000FEEB FF FF FF FF FF FF FF  
   3204 0000FEF2 FF FF FF FF FF FF FF  
   3204 0000FEF9 FF FF FF FF FF FF FF  
   3204 0000FF00 FF FF FF FF FF FF FF  
   3204 0000FF07 FF FF FF FF FF FF FF  
   3204 0000FF0E FF FF FF FF FF FF FF  
   3204 0000FF15 FF FF FF FF FF FF FF  
   3204 0000FF1C FF FF FF FF FF FF FF  
   3204 0000FF23 FF FF FF FF FF FF FF  
   3204 0000FF2A FF FF FF FF FF FF FF  
   3204 0000FF31 FF FF FF FF FF FF FF  
   3204 0000FF38 FF FF FF FF FF FF FF  
   3204 0000FF3F FF FF FF FF FF FF FF  
   3204 0000FF46 FF FF FF FF FF FF FF  
   3204 0000FF4D FF FF FF FF FF FF FF  
   3204 0000FF54 FF FF FF FF FF FF FF  
   3204 0000FF5B FF FF FF FF FF FF FF  
   3204 0000FF62 FF FF FF FF FF FF FF  
   3204 0000FF69 FF FF FF FF FF FF FF  
   3204 0000FF70 FF FF FF FF FF FF FF  
   3204 0000FF77 FF FF FF FF FF FF FF  
   3204 0000FF7E FF FF FF FF FF FF FF  
   3204 0000FF85 FF FF FF FF FF FF FF  
   3204 0000FF8C FF FF FF FF FF FF FF  
   3204 0000FF93 FF FF FF FF FF FF FF  
   3204 0000FF9A FF FF FF FF FF FF FF  
   3204 0000FFA1 FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Sun Jun 18 22:01:56 2017     Page 63
noc_boot.a
   3204 0000FFA8 FF FF FF FF FF FF FF  
   3204 0000FFAF FF FF FF FF FF FF FF  
   3204 0000FFB6 FF FF FF FF FF FF FF  
   3204 0000FFBD FF FF FF FF FF FF FF  
   3204 0000FFC4 FF FF FF FF FF FF FF  
   3204 0000FFCB FF FF FF FF FF FF FF  
   3204 0000FFD2 FF FF FF FF FF FF FF  
   3204 0000FFD9 FF FF FF FF FF FF FF  
   3204 0000FFE0 FF FF FF FF FF FF FF  
   3204 0000FFE7 FF FF FF FF FF FF FF  
   3204 0000FFEE FF FF FF FF FF FF FF  
   3204 0000FFF5 FF FF FF FF FF FF FF  
   3204 0000FFFC FF FF                 
   3205 0000FFFE 8C F2                   		dw		start
