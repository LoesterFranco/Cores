Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 1
noc_boot.a

                                        ; ============================================================================
                                        ;        __
                                        ;   \\__/ o\    (C) 2017  Robert Finch, Waterloo
                                        ;    \  __ /    All rights reserved.
                                        ;     \/_//     robfinch<remove>@finitron.ca
                                        ;       ||
                                        ;  
                                        ;
                                        ; This source file is free software: you can redistribute it and/or modify 
                                        ; it under the terms of the GNU Lesser General Public License as published 
                                        ; by the Free Software Foundation, either version 3 of the License, or     
                                        ; (at your option) any later version.                                      
                                        ;                                                                          
                                        ; This source file is distributed in the hope that it will be useful,      
                                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                                        ; GNU General Public License for more details.                             
                                        ;                                                                          
                                        ; You should have received a copy of the GNU General Public License        
                                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                                        ;                                    
                                        ;                                      
                                        ; This boot rom for an ordinary node.
                                        ; ============================================================================
                                        ;
     26 = 0D                            CR	= 13
     27 = 0A                            LF	= 10
     28 = 09                            CTRLH	equ		9
     29 = 20                            txBuf	equ		32
     30 = 30                            rxBuf	equ		48
                                        
     32 = 01                            MT_RST		equ		1
     33 = 02                            MT_RST_ACK	equ		2
     34 = 03                            MT_STOP		equ		3
     35 = 04                            MT_KEYSTROKE			equ	4
     36 = 05                            MT_SET_INPUT_FOCUS		equ	5
     37 = 06                            MT_BUTTON_STATUS		equ	6
     38 = 07                            MT_REQ_INP_FOCUS		equ	7
     39 = 08                            MT_GRNT_INP_FOCUS		equ 8
     40 = 09                            MT_PING					equ	9
     41 = 0A                            MT_START_BASIC_LOAD		equ	10
     42 = 0B                            MT_LOAD_BASIC_CHAR		equ	11
     43 = 0C                            MT_RUN_BASIC_PROG		equ	12
     44 = 0D                            MT_BASIC_EXIT			equ	13
     45 = 0F                            MT_REQ_OUT_FOCUS		equ	15
     46 = 10                            MT_GRNT_OUT_FOCUS		equ	16
     47 = 11                            MT_OUT_CHAR				equ	17
     48 = 12                            MT_PING_ACK				equ	18
                                        
     50 = 000000000000B000                              ROUTER		equ	$B000
     51 = 10                            RTR_RXSTAT	equ	$10
     52 = 12                            RTR_TXSTAT	equ	$12
                                        
     54 = 00                            ROUTER_TRB	equ	0
                                        
     56 = 0F                            MSG_DST		equ	15
     57 = 0E                            MSG_SRC		equ	14
     58 = 07                            MSG_TYPE	equ	7
                                        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 2
noc_boot.a
                                        		.code
                                        		cpu		Butterfly16
                                        		org		0xE000
                                        ; ============================================================================
                                        ;        __
                                        ;   \\__/ o\    (C) 2017  Robert Finch, Waterloo
                                        ;    \  __ /    All rights reserved.
                                        ;     \/_//     robfinch<remove>@finitron.ca
                                        ;       ||
                                        ;  
                                        ;
                                        ; This source file is free software: you can redistribute it and/or modify 
                                        ; it under the terms of the GNU Lesser General Public License as published 
                                        ; by the Free Software Foundation, either version 3 of the License, or     
                                        ; (at your option) any later version.                                      
                                        ;                                                                          
                                        ; This source file is distributed in the hope that it will be useful,      
                                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                                        ; GNU General Public License for more details.                             
                                        ;                                                                          
                                        ; You should have received a copy of the GNU General Public License        
                                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                                        ;                                    
                                        ;                                      
                                        ; Networking software components
                                        ; ============================================================================
                                        ;
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Zero out the transmit buffer.
                                        ; Used before building transmit buffer.
                                        ;
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	<none>
                                        ;----------------------------------------------------------------------------
                                        
    102 0000E000                        zeroTxBuf:
    103 0000E000 FE 6E                   		add		sp,sp,#-2
    104 0000E002 E0 D2                   		sw		r2,[sp]
    105 0000E004 00 40 0F 12             		lw		r2,#15
    106 0000E008                        zeroTxBuf1:
    107 0000E008 02 40 20 C0             		sb		r0,txBuf[r2]
    108 0000E00C FF 62                   		sub		r2,r2,#1
    109 0000E00E FC BB                   		bpl		zeroTxBuf1
    110 0000E010 E0 F2                   		lw		r2,[sp]
    111 0000E012 02 6E                   		add		sp,sp,#2
    112 0000E014 F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Transmit on the network.
                                        ; Blocks until the transmit buffer is open.
                                        ;
                                        ; Prerequisites:
                                        ;	The transmit buffer txBuf must have already been loaded.
                                        ; Parameters:
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 3
noc_boot.a
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	<none>
                                        ;----------------------------------------------------------------------------
                                        
    128 0000E016 FC 6E                  Xmit:	
    129 0000E018 E0 D1                   		sw		r1,[sp]
    130 0000E01A E2 D2                   		sw		r2,2[sp]
                                        		; wait for transmit buffer to empty
    132 0000E01C                        Xmit2:
    133 0000E01C 01 4B 02 E1             		lb		r1,ROUTER+RTR_TXSTAT
    134 0000E020 FD B9                   		bne		Xmit2
    135 0000E022 00 40 0F 12             		lw		r2,#15
    136 0000E026                        Xmit1:
    137 0000E026 02 40 20 E1             		lb		r1,txBuf[r2]
    138 0000E02A 00 4B 20 C1             		sb		r1,ROUTER[r2]
    139 0000E02E FF 62                   		add		r2,r2,#-1
    140 0000E030 FA BB                   		bpl		Xmit1
                                        		; trigger a transmit
    142 0000E032 01 11                   		lw		r1,#1
    143 0000E034 01 4B 02 C2             		sb		r2,ROUTER+RTR_TXSTAT
    144 0000E038 E2 F2                   		lw		r2,2[sp]
    145 0000E03A E0 F1                   		lw		r1,[sp]
    146 0000E03C 04 6E                   		add		sp,sp,#4
    147 0000E03E F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Receive from network.
                                        ; Receive status must have already indicated a message present.
                                        ; Copies recieve buffer from router to rxBuf.
                                        ;
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	<none>
                                        ;----------------------------------------------------------------------------
                                        
    162 0000E040                        Recv:
    163 0000E040 FC 6E                   		add		sp,sp,#-4
    164 0000E042 E0 D1                   		sw		r1,[sp]
    165 0000E044 E2 D2                   		sw		r2,2[sp]
    166 0000E046 00 40 0F 12             		lw		r2,#15
    167 0000E04A 01 4B 00 E1             		lb		r1,ROUTER+RTR_RXSTAT
    168 0000E04E 04 40 60 31             		or		r1,#$40
    169 0000E052 01 4B 00 C1             		sb		r1,ROUTER+RTR_RXSTAT	; pop the rx fifo
    170 0000E056 20 00                   		nop								; wait a couple of clock cycles
    171 0000E058 20 00                   		nop								; before reading
    172 0000E05A                        Recv1:
    173 0000E05A 00 4B 20 E1             		lb		r1,ROUTER[r2]			; copy message to local buffer
    174 0000E05E 03 40 20 C1             		sb		r1,rxBuf[r2]
    175 0000E062 FF 62                   		add		r2,r2,#-1
    176 0000E064 FA BB                   		bpl		Recv1
    177 0000E066 E0 F1                   		lw		r1,[sp]
    178 0000E068 E2 F2                   		lw		r2,2[sp]
    179 0000E06A 04 6E                   		add		sp,sp,#4
    180 0000E06C F0 80                   		ret
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 4
noc_boot.a
                                        
                                        ;****************************************************************;
                                        ;                                                                ;
                                        ;		Tiny BASIC Worker for the Finitron Butterfly             ;
                                        ;                                                                ;
                                        ; Supports worker threads.                                       ;
                                        ; There is no user interface to worker threads so the commands   ;
                                        ; LOAD and SAVE are removed.                                     ;
                                        ;                                                                ;
                                        ; Derived from a 68000 derivative of Palo Alto Tiny BASIC as     ;
                                        ; published in the May 1976 issue of Dr. Dobb's Journal.         ;
                                        ; Adapted to the 68000 by:                                       ;
                                        ;	Gordon brndly						                         ;
                                        ;	12147 - 51 Street					                         ;
                                        ;	Edmonton AB  T5W 3G8					                     ;
                                        ;	Canada							                             ;
                                        ;	(updated mailing address for 1996)			                 ;
                                        ;                                                                ;
                                        ; Adapted to the Butterfly by:                                    ;
                                        ;    Robert Finch                                                ;
                                        ;    Ontario, Canada                                             ;
                                        ;	 rob<remove>@finitron.ca                                     ;  
                                        ;****************************************************************;
                                        ;   Copyright (C) 2005-2017 by Robert Finch. This program may be ;
                                        ;    freely distributed for personal use only. All commercial	 ;
                                        ;		       rights are reserved.			                     ;
                                        ;****************************************************************;
                                        ;
                                        ; Register Usage
                                        ; r8 = text pointer (global usage)
                                        ; r3,r4 = inputs parameters to subroutines
                                        ; r2 = return value
                                        ;
                                        ;* Vers. 1.0  1984/7/17	- Original version by Gordon brndly
                                        ;*	1.1  1984/12/9	- Addition of '0x' print term by Marvin Lipford
                                        ;*	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                                        
                                        ;	OPT	FRS,BRS 	forward ref.'s & brnches default to short
                                        
                                        ;XMIT_FULL		equ	0x40		; the transmit buffer is full
                                        ;DATA_PRESENT	equ	0x08		; there is data preset at the serial port bc_uart3
    221 = 01                            DATA_PRESENT	equ	0x01		; there is data preset at the serial port bc_uart3
    222 = 20                            XMIT_NOT_FULL	equ	0x20
                                        
    224 = 00000000FFFFDC40                              TS_TIMER	equ		0xFFFFDC40		; system time slice timer
    225 = 00000000FFFFDC50                              KBD			equ		0xFFFFDC50
                                        
    227 = 00000000FFFFDCA0                              RAND		equ		0xFFFFDCA0
    228 = 00000000FFFFD800                              VIC			equ		0xFFFFD800
                                        
    230 = 2000                          VIDEORAM	equ		0x00002000
                                        
                                        ; BOOT ROM routines
                                        
    234 = 0000000FFFFFF804                              getSerial	equ		0xFFFFFF804	; get a serial port character
    235 = 0000000FFFFFF808                              peekSerial	equ		0xFFFFFF808	; get a serial port character
    236 = 0000000FFFFFF80C                              putSerial	equ		0xFFFFFF80C	; put a character to serial port
    237 = 0000000FFFFFF82C                              clearScreen	equ		0xFFFFFF82C	; clear the screen
    238 = 0000000FFFFFF840                              getKbdCharWait	equ	0xFFFFFF840
    239 = 0000000FFFFFF844                              getKbdChar		equ	0xFFFFFF844
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 5
noc_boot.a
                                        
    241 = 20                            warmStart   equ     0x20
    242 = 24                            usrJmp      equ     0x24
                                        
    244 = 0D                            CR		equ	0x0D		; ASCII equates
    245 = 0A                            LF		equ	0x0A
    246 = 09                            TAB		equ	0x09
    247 = 03                            CTRLC	equ	0x03
    248 = 08                            CTRLH	equ	0x08
    249 = 13                            CTRLS	equ	0x13
    250 = 18                            CTRLX	equ	0x18
                                        
    252 = 50                            BUFLEN	equ	80	;	length of keyboard input buffer
                                        
                                        	code
                                        ;	org	0xC000	;
                                        ;
                                        ; Standard jump table. You can change these addresses if you are
                                        ; customizing this interpreter for a different environment.
                                        ;
    261 0000E06E FF BE                  START	jmp	CSTART	;	Cold Start entry point
    262 0000E070 26 AE                  GOWARM	jmp	WSTART	;	Warm Start entry point
    263 0000E072 75 40 01 AE            GOOUT	jmp	OUTC	;	Jump to character-out routine
    264 0000E076 75 40 00 AE            GOIN	jmp	INC		;Jump to character-in routine
    265 0000E07A 78 40 01 AE            GOAUXO	jmp	AUXOUT	;	Jump to auxiliary-out routine
    266 0000E07E 79 40 0E AE            GOAUXI	jmp	AUXIN	;	Jump to auxiliary-in routine
    267 0000E082 7D 40 00 AE            GOBYE	jmp	BYEBYE	;	Jump to monitor, DOS, etc.
                                        ;
                                        ; Modifiable system constants:
                                        ;
    271 0000E086 00 02                  TXTBGN	dw	0x0200		;beginning of program memory
    272 0000E088 00 1E                  ENDMEM	dw	0x1E00	;	end of available memory
                                        ;
    274 0000E08A                        INITTBW:
                                        	; First save off the link register and OS sp value
    276 0000E08A FE 6E                   	sub		sp,sp,#2
    277 0000E08C E0 DF                   	sw		lr,[sp]
    278 0000E08E 08 4E 06 F1             	lw		r1,TXTBGN	;	init. end-of-program pointer
    279 0000E092 09 40 06 D1             	sw		r1,TXTUNF
    280 0000E096 08 4E 08 F1             	lw		r1,ENDMEM	;	get address of end of memory
    281 0000E09A E0 4F 10 11             	sub		r1,r1,#512	; 	reserve 512 bytes for the stack
    282 0000E09E 0A 40 00 D1             	sw		r1,STKBOT
    283 0000E0A2 E0 4F 10 11             	sub     r1,r1,#512 ;   128 vars
    284 0000E0A6 09 40 08 D1             	sw      r1,VARBGN
    285 0000E0AA EA AF                   	call    clearVars   ; clear the variable area
    286 0000E0AC 08 40 0C D0             	sw		r0,LOPVAR   ; initialize internal variables
    287 0000E0B0 08 40 08 D0             	sw		r0,STKGOS
    288 0000E0B4 08 40 06 D0             	sw		r0,CURRNT	;	current line number pointer = 0
    289 0000E0B8 E0 FF                   	lw		lr,[sp]
    290 0000E0BA 02 6E                   	add		sp,sp,#2
    291 0000E0BC F0 80                   	ret
                                        ;
                                        ; The main interpreter starts here:
                                        ;
                                        ; Usage
                                        ; r1 = temp
                                        ; r8 = text buffer pointer
                                        ; r12 = end of text in text buffer
                                        ;
                                        	; At the end of the running program it'll go back to
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 6
noc_boot.a
                                        	; the warm start location. Use this to return.
    302 0000E0BE                        WSTART
    303 0000E0BE 08 40 0C D0             	sw		r0,LOPVAR   ; initialize internal variables
    304 0000E0C2 08 40 08 D0             	sw		r0,STKGOS
    305 0000E0C6 08 40 06 D0             	sw		r0,CURRNT	;	current line number pointer = 0
    306 0000E0CA 08 40 04 FE             	lw		sp,OSSP
    307 0000E0CE E0 FF                   	lw		lr,[sp]
    308 0000E0D0 02 6E                   	add		sp,sp,#2
    309 0000E0D2 F0 80                   	ret
                                        
                                        	; Entry point which is called by the reciever dispatcher.
    312 0000E0D4                        ST3:
    313 0000E0D4 FE 6E                   	add		sp,sp,#-2
    314 0000E0D6 E0 DF                   	sw		lr,[sp]
    315 0000E0D8 08 40 04 DE             	sw		sp,OSSP
    316 0000E0DC 08 4E 08 FE             	lw		sp,ENDMEM	;	init S.P.
    317 0000E0E0 6C 40 02 AF             	call	TOUPBUF 	; convert to upper case
    318 0000E0E4 80 1C                   	lw		r12,r8		; save pointer to end of line
    319 0000E0E6 0A 40 0E 18             	lea		r8,BUFFER	; point to the beginning of line
    320 0000E0EA 6E AE                   	br		DIRECT
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** Tables *** DIRECT *** EXEC ***
                                        ;
                                        ; This section of the code tests a string against a table. When
                                        ; a match is found, control is transferred to the section of
                                        ; code according to the table.
                                        ;
                                        ; At 'EXEC', r8 should point to the string, r9 should point to
                                        ; the character table, and r10 should point to the execution
                                        ; table. At 'DIRECT', r8 should point to the string, r9 and
                                        ; r10 will be set up to point to TAB1 and TAB1_1, which are
                                        ; the tables of all direct and statement commands.
                                        ;
                                        ; A '.' in the string will terminate the test and the partial
                                        ; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                                        ; 'PRIN.', or 'PRINT' will all match 'PRINT'.
                                        ;
                                        ; There are two tables: the character table and the execution
                                        ; table. The character table consists of any number of text items.
                                        ; Each item is a string of characters with the last character's
                                        ; high bit set to one. The execution table holds a 32-bit
                                        ; execution addresses that correspond to each entry in the
                                        ; character table.
                                        ;
                                        ; The end of the character table is a 0 byte which corresponds
                                        ; to the default routine in the execution table, which is
                                        ; executed if none of the other table items are matched.
                                        ;
                                        ; Character-matching tables:
    353 0000E0EC                        TAB1
    354 0000E0EC 4C 49 53 D4             	db	"LIS",('T'+0x80)        ; Direct commands
    355 0000E0F0 4E 45 D7                	db	"NE",('W'+0x80)
    356 0000E0F3 52 55 CE                	db	"RU",('N'+0x80)
    357 0000E0F6                        TAB2
    358 0000E0F6 4E 45 58 D4             	db	"NEX",('T'+0x80)         ; Direct / statement
    359 0000E0FA 4C 45 D4                	db	"LE",('T'+0x80)
    360 0000E0FD 49 C6                   	db	"I",('F'+0x80)
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 7
noc_boot.a
    361 0000E0FF 47 4F 54 CF             	db	"GOT",('O'+0x80)
    362 0000E103 47 4F 53 55 C2          	db	"GOSU",('B'+0x80)
    363 0000E108 52 45 54 55 52 CE       	db	"RETUR",('N'+0x80)
    364 0000E10E 52 45 CD                	db	"RE",('M'+0x80)
    365 0000E111 46 4F D2                	db	"FO",('R'+0x80)
    366 0000E114 49 4E 50 55 D4          	db	"INPU",('T'+0x80)
    367 0000E119 50 52 49 4E D4          	db	"PRIN",('T'+0x80)
    368 0000E11E 50 4F 4B 45 D7          	db	"POKE",('W'+0x80)
    369 0000E123 50 4F 4B C5             	db	"POK",('E'+0x80)
    370 0000E127 53 54 4F D0             	db	"STO",('P'+0x80)
    371 0000E12B 42 59 C5                	db	"BY",('E'+0x80)
    372 0000E12E 53 59 D3                	db	"SY",('S'+0x80)
    373 0000E131 43 4C D2                    db  "CL",('R'+0x80)
    374 0000E134 45 58 49 D4             	db	"EXI",('T'+0x80)
    375 0000E138 00                      	db	0
    376 0000E139                        TAB4
    377 0000E139 4E 4F 44 45 4E 55 CD    	db	"NODENU",('M'+0x80)
                                      
    378 0000E140 50 45 45 4B D7          	db	"PEEK",('W'+0x80)        ;Functions
    379 0000E145 50 45 45 CB             	db	"PEE",('K'+0x80)         ;Functions
    380 0000E149 52 4E C4                	db	"RN",('D'+0x80)
    381 0000E14C 41 42 D3                	db	"AB",('S'+0x80)
    382 0000E14F 53 49 5A C5             	db	"SIZ",('E'+0x80)
    383 0000E153 55 53 D2                	db  "US",('R'+0x80)
    384 0000E156 00                      	db	0
    385 0000E157                        TAB5
    386 0000E157 54 CF                   	db	"T",('O'+0x80)           ;"TO" in "FOR"
    387 0000E159 00                      	db	0
    388 0000E15A                        TAB6
    389 0000E15A 53 54 45 D0             	db	"STE",('P'+0x80)         ;"STEP" in "FOR"
    390 0000E15E 00                      	db	0
    391 0000E15F                        TAB8
    392 0000E15F 3E BD                   	db	'>',('='+0x80)           ;Relational operators
    393 0000E161 3C BE                   	db	'<',('>'+0x80)
    394 0000E163 BE                      	db	('>'+0x80)
    395 0000E164 BD                      	db	('='+0x80)
    396 0000E165 3C BD                   	db	'<',('='+0x80)
    397 0000E167 BC                      	db	('<'+0x80)
    398 0000E168 00                      	db	0
    399 0000E169                        TAB9
    400 0000E169 41 4E C4                    db  "AN",('D'+0x80)
    401 0000E16C 00                          db  0
    402 0000E16D                        TAB10
    403 0000E16D 4F D2                       db  "O",('R'+0x80)
    404 0000E16F 00                          db  0
                                        
                                        	.align	4
                                        
                                        ;* Execution address tables:
    409 0000E170                        TAB1_1
    410 0000E170 9E E2                   	dw	LISTX			;Direct commands
    411 0000E172 1C E2                   	dw	NEW
    412 0000E174 30 E2                   	dw	RUN
    413 0000E176                        TAB2_1
    414 0000E176 F0 E3                   	dw	NEXT		;	Direct / statement
    415 0000E178 EA E4                   	dw	LET
    416 0000E17A 4A E4                   	dw	IF
    417 0000E17C 62 E2                   	dw	GOTO
    418 0000E17E 36 E3                   	dw	GOSUB
    419 0000E180 66 E3                   	dw	RETURN
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 8
noc_boot.a
    420 0000E182 50 E4                   	dw	IF2			; REM
    421 0000E184 90 E3                   	dw	FOR
    422 0000E186 6E E4                   	dw	INPUT
    423 0000E188 D2 E2                   	dw	PRINT
    424 0000E18A D4 E5                   	dw	POKEW
    425 0000E18C B4 E5                   	dw	POKE
    426 0000E18E 2A E2                   	dw	STOP
    427 0000E190 82 E0                   	dw	GOBYE
    428 0000E192 EC E5                   	dw	SYSX
    429 0000E194 7C E2                   	dw  _clr
    430 0000E196 40 F0                   	dw	EXIT
    431 0000E198 E2 E4                   	dw	DEFLT
    432 0000E19A                        TAB4_1
    433 0000E19A 1A EA                   	dw	NODENUM
    434 0000E19C 6A E9                   	dw  PEEKW
    435 0000E19E 5E E9                   	dw	PEEK			;Functions
    436 0000E1A0 8A E9                   	dw	RND
    437 0000E1A2 E4 E9                   	dw	ABS
    438 0000E1A4 0A EA                   	dw	SIZEX
    439 0000E1A6 76 E9                   	dw  USRX
    440 0000E1A8 94 E7                   	dw	XP40
    441 0000E1AA                        TAB5_1
    442 0000E1AA A6 E3                   	dw	FR1			;"TO" in "FOR"
    443 0000E1AC 9A EA                   	dw	QWHAT
    444 0000E1AE                        TAB6_1
    445 0000E1AE B8 E3                   	dw	FR2			;"STEP" in "FOR"
    446 0000E1B0 BE E3                   	dw	FR3
    447 0000E1B2                        TAB8_1
    448 0000E1B2 B6 E6                   	dw	XP11	;>=		Relational operators
    449 0000E1B4 C0 E6                   	dw	XP12	;<>
    450 0000E1B6 CA E6                   	dw	XP13	;>
    451 0000E1B8 DE E6                   	dw	XP15	;=
    452 0000E1BA D4 E6                   	dw	XP14	;<=
    453 0000E1BC E8 E6                   	dw	XP16	;<
    454 0000E1BE 02 E7                   	dw	XP17
    455 0000E1C0                        TAB9_1
    456 0000E1C0 42 E6                       dw  XP_AND
    457 0000E1C2 4A E6                       dw  XP_ANDX
    458 0000E1C4                        TAB10_1
    459 0000E1C4 1E E6                       dw  XP_OR
    460 0000E1C6 26 E6                       dw  XP_ORX
                                        
                                        ;*
                                        ; r3 = match flag (trashed)
                                        ; r9 = text table
                                        ; r10 = exec table
                                        ; r11 = trashed
    467 0000E1C8                        DIRECT
    468 0000E1C8 0E 4E 0C 19             	lea		r9,TAB1
    469 0000E1CC 17 4E 00 1A             	lea		r10,TAB1_1
    470 0000E1D0                        EXEC
    471 0000E1D0 F0 1B                   	lw		r11,lr		; save link reg
    472 0000E1D2 63 40 0B AF             	call	IGNBLK		; ignore leading blanks
    473 0000E1D6 B0 1F                   	lw		lr,r11		; restore link reg
    474 0000E1D8 80 1B                   	lw		r11,r8		; save the pointer
    475 0000E1DA 00 13                   	lw		r3,#0		; clear match flag
    476 0000E1DC                        EXLP
    477 0000E1DC 80 E1                   	lb		r1,[r8]		; get the program character
    478 0000E1DE 01 68                   	add		r8,r8,#1
    479 0000E1E0 90 E2                   	lb		r2,[r9]		; get the table character
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 9
noc_boot.a
    480 0000E1E2 02 A9                   	bne		EXNGO		; If end of table,
    481 0000E1E4 B0 18                   	lw		r8,r11		;	restore the text pointer and...
    482 0000E1E6 12 AE                   	br		EXGO		;   execute the default.
    483 0000E1E8                        EXNGO
    484 0000E1E8 3D 21                   	cmp		r1,r3		; Else check for period...
    485 0000E1EA 10 A8                   	beq		EXGO		; if so, execute
    486 0000E1EC 07 40 5F 32             	and		r2,#0x7f	; ignore the table's high bit
    487 0000E1F0 1D 22                   	cmp		r2,r1		;		is there a match?
    488 0000E1F2 07 A8                   	beq		EXMAT
    489 0000E1F4 04 6A                   	add		r10,r10,#4	;if not, try the next entry
    490 0000E1F6 B0 18                   	lw		r8,r11		; reset the program pointer
    491 0000E1F8 00 13                   	lw		r3,#0		; sorry, no match
    492 0000E1FA                        EX1
    493 0000E1FA 01 69                   	add		r9,r9,#1
    494 0000E1FC 9F E1                   	lb		r1,-1[r9]	; get to the end of the entry
    495 0000E1FE FD BB                   	bpl		EX1
    496 0000E200 ED BE                   	br		EXLP		; back for more matching
    497 0000E202                        EXMAT
    498 0000E202 02 40 0E 13             	lw		r3,#'.'		; we've got a match so far
    499 0000E206 01 69                   	add		r9,r9,#1
    500 0000E208 9F E1                   	lb		r1,-1[r9]	; end of table entry?
    501 0000E20A E8 BB                   	bpl		EXLP		; if not, go back for more
    502 0000E20C                        EXGO
    503 0000E20C 01 4B 00 E1             	lb		r1,ROUTER+RTR_RXSTAT
    504 0000E210 03 A8                   	beq		EXGO1
    505 0000E212 16 BF                   	call	Recv
    506 0000E214 84 40 00 AF             	call	RecvDispatch
    507 0000E218                        EXGO1
    508 0000E218 A0 FB                   	lw		r11,[r10]	; execute the appropriate routine
    509 0000E21A B0 80                   	jmp		[r11]
                                        
                                        
                                        ;    lb      r1,[r8]     ; get token from text space
                                        ;    bpl
                                        ;    and     r1,#0x7f
                                        ;    shl     r1,#2       ; * 4 - word offset
                                        ;    add     r1,r1,#TAB1_1
                                        ;    lw      r1,[r1]
                                        ;    jmp     [r1]
                                        
                                            
                                        ;
                                        ; What follows is the code to execute direct and statement
                                        ; commands. Control is transferred to these points via the command
                                        ; table lookup code of 'DIRECT' and 'EXEC' in the last section.
                                        ; After the command is executed, control is transferred to other
                                        ; sections as follows:
                                        ;
                                        ; For 'LISTX', 'NEW', and 'STOP': go back to the warm start point.
                                        ; For 'RUN': go execute the first stored line if any; else go
                                        ; back to the warm start point.
                                        ; For 'GOTO' and 'GOSUB': go execute the target line.
                                        ; For 'RETURN' and 'NEXT'; go back to saved return line.
                                        ; For all others: if 'CURRNT' is 0, go to warm start; else go
                                        ; execute next command. (This is done in 'FINISH'.)
                                        ;
                                        ;******************************************************************
                                        ;
                                        ; *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                                        ;
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 10
noc_boot.a
                                        ; 'NEW<CR>' sets TXTUNF to point to TXTBGN
                                        ;
                                        ; 'STOP<CR>' goes back to WSTART
                                        ;
                                        ; 'RUN<CR>' finds the first stored line, stores its address
                                        ; in CURRNT, and starts executing it. Note that only those
                                        ; commands in TAB2 are legal for a stored program.
                                        ;
                                        ; RUN ON <node number> sends a run command to the specified node
                                        ;
                                        ; There are 3 more entries in 'RUN':
                                        ; 'RUNNXL' finds next line, stores it's address and executes it.
                                        ; 'RUNTSL' stores the address of this line and executes it.
                                        ; 'RUNSML' continues the execution on same line.
                                        ;
                                        ; 'GOTO expr<CR>' evaluates the expression, finds the target
                                        ; line, and jumps to 'RUNTSL' to do it.
                                        ;
    558 0000E21C                        NEW
    559 0000E21C 42 40 09 AF             	call	ENDCHK
    560 0000E220 08 4E 06 F1             	lw		r1,TXTBGN
    561 0000E224 09 40 06 D1             	sw		r1,TXTUNF	;	set the end pointer
    562 0000E228 2B AF                   	call    clearVars
                                        
    564 0000E22A                        STOP
    565 0000E22A 42 40 02 AF             	call	ENDCHK
    566 0000E22E 47 BE                   	br		WSTART		; WSTART will reset the stack
                                        
    568 0000E230                        RUN
    569 0000E230 41 40 0F AF             	call	ENDCHK
    570 0000E234 08 4E 06 F8             	lw		r8,TXTBGN	;	set pointer to beginning
    571 0000E238 08 40 06 D8             	sw		r8,CURRNT
    572 0000E23C 21 AF                   	call    clearVars
                                        
    574 0000E23E                        RUNNXL					; RUN <next line>
    575 0000E23E 08 40 06 F1             	lw		r1,CURRNT	; executing a program?
    576 0000E242 3D B8                   	beq		WSTART		; if not, we've finished a direct stat.
    577 0000E244 00 11                   	lw		r1,#0	    ; else find the next line number
    578 0000E246 80 19                   	lw		r9,r8
    579 0000E248 49 40 0F AF             	call	FNDLNP		; search for the next line
    580 0000E24C 38 B7                   	bgtu	WSTART		; if we've fallen off the end, stop
                                        
    582 0000E24E                        RUNTSL					; RUN <this line>
    583 0000E24E 08 40 06 D9             	sw		r9,CURRNT	; set CURRNT to point to the line no.
    584 0000E252 92 18                   	lea		r8,2[r9]	; set the text pointer to
                                        
    586 0000E254                        RUNSML                  ; RUN <same line>
    587 0000E254 63 40 00 AF             	call	CHKIO		; see if a control-C was pressed
    588 0000E258 0F 4E 06 19             	lea		r9,TAB2		; find command in TAB2
    589 0000E25C 17 4E 06 1A             	lea		r10,TAB2_1
    590 0000E260 B7 BE                   	br		EXEC		; and execute it
                                        
    592 0000E262                        GOTO
    593 0000E262 1D 40 02 AF             	call	OREXPR		;evaluate the following expression
    594 0000E266 10 15                   	lw      r5,r1
    595 0000E268 40 40 03 AF             	call	ENDCHK		;must find end of line
    596 0000E26C 50 11                   	lw      r1,r5
    597 0000E26E 48 40 04 AF             	call	FNDLN		; find the target line
    598 0000E272 ED B8                   	beq		RUNTSL		; go do it
    599 0000E274 21 4F 03 11             	lea		r1,msgBadGotoGosub
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 11
noc_boot.a
    600 0000E278 41 40 01 AE             	br		ERROR		; no such line no.
                                        
                                        
    603 0000E27C                        _clr
    604 0000E27C 01 AF                       call    clearVars
    605 0000E27E 57 AE                       br      FINISH
                                        
                                        ; Clear the variable area of memory
    608 0000E280                        clearVars
    609 0000E280 FC 6E                       sub     sp,sp,#4
    610 0000E282 E0 DF                       sw      lr,[sp]
    611 0000E284 E2 D6                       sw      r6,2[sp]
    612 0000E286 80 40 00 16                 lw      r6,#2048    ; number of words to clear
    613 0000E28A 09 40 08 F1                 lw      r1,VARBGN
    614 0000E28E                        cv1
    615 0000E28E 10 D0                       sw      r0,[r1]
    616 0000E290 04 61                       add     r1,r1,#4
    617 0000E292 FF 66                       sub		r6,r6,#1
    618 0000E294 FC B9                       bne     cv1
    619 0000E296 E0 FF                       lw      lr,[sp]
    620 0000E298 E2 F6                       lw      r6,2[sp]
    621 0000E29A 04 6E                       add     sp,sp,#4
    622 0000E29C F0 80                       ret    
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; LIST
                                        ;
                                        ; LISTX has two forms:
                                        ; 'LIST<CR>' lists all saved lines
                                        ; 'LIST #<CR>' starts listing at the line #
                                        ; Control-S pauses the listing, control-C stops it.
                                        ;
                                        
    635 0000E29E                        LISTX
    636 0000E29E 5B 40 04 AF             	call	TSTNUM		; see if there's a line no.
    637 0000E2A2 10 15                   	lw      r5,r1
    638 0000E2A4 3E 40 05 AF             	call	ENDCHK		; if not, we get a zero
    639 0000E2A8 50 11                   	lw      r1,r5
    640 0000E2AA 46 40 06 AF             	call	FNDLN		; find this or next line
    641 0000E2AE                        LS1
    642 0000E2AE 07 B7                   	bgtu	WSTART		; warm start if we passed the end
                                        
    644 0000E2B0 90 11                   	lw		r1,r9
    645 0000E2B2 57 40 0A AF             	call	PRTLN		; print the line
    646 0000E2B6 10 19                   	lw		r9,r1		; set pointer for next
    647 0000E2B8 5F 40 0E AF             	call	CHKIO		; check for listing halt request
    648 0000E2BC 06 A8                   	beq		LS3
    649 0000E2BE FE 4F 1D 10             	cmp		r1,#CTRLS	; pause the listing?
    650 0000E2C2 03 A9                   	bne		LS3
    651 0000E2C4                        LS2
    652 0000E2C4 5F 40 08 AF             	call	CHKIO		; if so, wait for another keypress
    653 0000E2C8 FD B8                   	beq		LS2
    654 0000E2CA                        LS3
    655 0000E2CA 00 11                   	lw		r1,#0
    656 0000E2CC 45 40 0D AF             	call	FNDLNP		; find the next line
    657 0000E2D0 EE BE                   	br		LS1
                                        
                                        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 12
noc_boot.a
                                        ;******************************************************************
                                        ; PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                                        ; where '....' is a list of expressions, formats, back-arrows,
                                        ; and strings.	These items a separated by commas.
                                        ;
                                        ; A format is a pound sign followed by a number.  It controls
                                        ; the number of spaces the value of an expression is going to
                                        ; be printed in.  It stays effective for the rest of the print
                                        ; command unless changed by another format.  If no format is
                                        ; specified, 11 positions will be used.
                                        ;
                                        ; A string is quoted in a pair of single- or double-quotes.
                                        ;
                                        ; An underline (back-arrow) means generate a <CR> without a <LF>
                                        ;
                                        ; A <CR LF> is generated after the entire list has been printed
                                        ; or if the list is empty.  If the list ends with a semicolon,
                                        ; however, no <CR LF> is generated.
                                        ;
                                        
    680 0000E2D2                        PRINT
    681 0000E2D2 0B 15                   	lw		r5,#11		; D4 = number of print spaces
    682 0000E2D4 58 40 07 AF             	call	TSTC		; if null list and ":"
    683 0000E2D8 3A 08                   	db	':',PR2-*+1
    684 0000E2DA 5F 40 0D AF             	call	CRLF		; give CR-LF and continue
    685 0000E2DE BA BE                   	br		RUNSML		;		execution on the same line
    686 0000E2E0                        PR2
    687 0000E2E0 58 40 01 AF             	call	TSTC		;if null list and <CR>
    688 0000E2E4 0D 08                   	db	CR,PR0-*+1
    689 0000E2E6 5F 40 07 AF             	call	CRLF		;also give CR-LF and
    690 0000E2EA A9 BE                   	br		RUNNXL		;execute the next line
    691 0000E2EC                        PR0
    692 0000E2EC 57 40 0B AF             	call	TSTC		;else is it a format?
    693 0000E2F0 23 0A                   	db	'#',PR1-*+1
    694 0000E2F2 18 40 0A AF             	call	OREXPR		; yes, evaluate expression
    695 0000E2F6 10 15                   	lw		r5,r1		; and save it as print width
    696 0000E2F8 0B AE                   	br		PR3		; look for more to print
    697 0000E2FA                        PR1
    698 0000E2FA 57 40 04 AF             	call	TSTC	;	is character expression? (MRL)
    699 0000E2FE 24 0C                   	db	'$',PR4-*+1
    700 0000E300 18 40 03 AF             	call	OREXPR	;	yep. Evaluate expression (MRL)
    701 0000E304 EB 4F 05 AF             	call	GOOUT	;	print low byte (MRL)
    702 0000E308 03 AE                   	br		PR3		;look for more. (MRL)
    703 0000E30A                        PR4
    704 0000E30A 4B 40 02 AF             	call	QTSTG	;	is it a string?
                                        	; the following branch must occupy only two bytes!
    706 0000E30E 09 AE                   	br		PR8		;	if not, must be an expression
    707 0000E310                        PR3
    708 0000E310 56 40 09 AF             	call	TSTC	;	if ",", go find next
    709 0000E314 2C 08                   	db	',',PR6-*+1
    710 0000E316 39 40 0A AF             	call	FIN		;in the list.
    711 0000E31A E8 BE                   	br		PR0
    712 0000E31C                        PR6
    713 0000E31C 5D 40 0C AF             	call	CRLF		;list ends here
    714 0000E320 06 AE                   	br		FINISH
    715 0000E322                        PR8
    716 0000E322 17 40 02 AF             	call	OREXPR		; evaluate the expression
    717 0000E326 50 12                   	lw		r2,r5		; set the width
    718 0000E328 4C 40 0F AF             	call	PRTNUM		; print its value
    719 0000E32C F1 BE                   	br		PR3			; more to print?
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 13
noc_boot.a
                                        
    721 0000E32E                        FINISH
    722 0000E32E 38 40 0E AF             	call	FIN		; Check end of command
    723 0000E332 3B 40 02 AE             	jmp		QWHAT	; print "What?" if wrong
                                        
                                        
                                        ;*******************************************************************
                                        ;
                                        ; *** GOSUB *** & RETURN ***
                                        ;
                                        ; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                                        ; except that the current text pointer, stack pointer, etc. are
                                        ; saved so that execution can be continued after the subroutine
                                        ; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                                        ; recursive), the save area must be stacked.  The stack pointer
                                        ; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                                        ; If we are in the main routine, 'STKGOS' is zero (this was done
                                        ; in the initialization section of the interpreter), but we still
                                        ; save it as a flag for no further 'RETURN's.
                                        ;
    740 0000E336                        GOSUB
    741 0000E336 46 40 06 AF             	call	PUSHA		; save the current 'FOR' parameters
    742 0000E33A 16 40 06 AF             	call	OREXPR		; get line number
    743 0000E33E 41 40 0C AF             	call	FNDLN		; find the target line
    744 0000E342 04 A8                   	beq		gosub1
    745 0000E344 21 4F 03 11             	lea		r1,msgBadGotoGosub
    746 0000E348 3A 40 09 AE             	br		ERROR		; if not there, say "How?"
    747 0000E34C                        gosub1
    748 0000E34C FA 6E                   	sub		sp,sp,#6
    749 0000E34E E0 D8                   	sw		r8,[sp]		; save text pointer
    750 0000E350 08 40 06 F1             	lw		r1,CURRNT
    751 0000E354 E2 D1                   	sw		r1,2[sp]	; found it, save old 'CURRNT'...
    752 0000E356 08 40 08 F1             	lw		r1,STKGOS
    753 0000E35A E4 D1                   	sw		r1,4[sp]	; and 'STKGOS'
    754 0000E35C 08 40 0C D0             	sw		r0,LOPVAR	; load new values
    755 0000E360 08 40 08 DE             	sw		sp,STKGOS
    756 0000E364 74 BE                   	br		RUNTSL
                                        
                                        
                                        ; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                                        ; returns the execution to the command after the most recent
                                        ; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                                        ; a 'GOSUB' and is thus an error.
                                        ;
    764 0000E366                        RETURN
    765 0000E366 38 40 04 AF             	call	ENDCHK		; there should be just a <CR>
    766 0000E36A 08 40 08 F1             	lw		r1,STKGOS	; get old stack pointer
    767 0000E36E 04 A9                   	bne		return1
    768 0000E370 23 4F 00 11             	lea		r1,msgRetWoGosub
    769 0000E374 39 40 03 AE             	br		ERROR		; if zero, it doesn't exist
    770 0000E378                        return1
    771 0000E378 10 1E                   	lw		sp,r1		; else restore it
    772 0000E37A E4 F1                   	lw		r1,4[sp]
    773 0000E37C 08 40 08 D1             	sw		r1,STKGOS	; and the old 'STKGOS'
    774 0000E380 E2 F1                   	lw		r1,2[sp]
    775 0000E382 08 40 06 D1             	sw		r1,CURRNT	; and the old 'CURRNT'
    776 0000E386 E0 F8                   	lw		r8,[sp]		; and the old text pointer
    777 0000E388 06 6E                   	add		sp,sp,#6
    778 0000E38A 42 40 08 AF             	call	POPA		;and the old 'FOR' parameters
    779 0000E38E CF BE                   	br		FINISH		;and we are back home
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 14
noc_boot.a
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** FOR *** & NEXT ***
                                        ;
                                        ; 'FOR' has two forms:
                                        ; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                                        ; The second form means the same thing as the first form with a
                                        ; STEP of positive 1.  The interpreter will find the variable 'var'
                                        ; and set its value to the current value of 'exp1'.  It also
                                        ; evaluates 'exp2' and 'exp1' and saves all these together with
                                        ; the text pointer, etc. in the 'FOR' save area, which consisits of
                                        ; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                                        ; already something in the save area (indicated by a non-zero
                                        ; 'LOPVAR'), then the old save area is saved on the stack before
                                        ; the new values are stored.  The interpreter will then dig in the
                                        ; stack and find out if this same variable was used in another
                                        ; currently active 'FOR' loop.  If that is the case, then the old
                                        ; 'FOR' loop is deactivated. (i.e. purged from the stack)
                                        ;
    801 0000E390                        FOR
    802 0000E390 43 40 09 AF             	call	PUSHA		; save the old 'FOR' save area
    803 0000E394 34 40 05 AF             	call	SETVAL		; set the control variable
    804 0000E398 08 40 0C D1             	sw		r1,LOPVAR	; save its address
    805 0000E39C 15 4E 07 19             	lea		r9,TAB5		; use 'EXEC' to test for 'TO'
    806 0000E3A0 1A 4E 0A 1A             	lea		r10,TAB5_1
    807 0000E3A4 15 BE                   	jmp		EXEC
    808 0000E3A6                        FR1
    809 0000E3A6 13 40 00 AF             	call	OREXPR		; evaluate the limit
    810 0000E3AA 09 40 00 D1             	sw		r1,LOPLMT	; save that
    811 0000E3AE 15 4E 0A 19             	lea		r9,TAB6		; use 'EXEC' to look for the
    812 0000E3B2 1A 4E 0E 1A             	lea		r10,TAB6_1	; word 'STEP'
    813 0000E3B6 0C BE                   	jmp		EXEC
    814 0000E3B8                        FR2
    815 0000E3B8 12 40 07 AF             	call	OREXPR		; found it, get the step value
    816 0000E3BC 01 AE                   	br		FR4
    817 0000E3BE                        FR3
    818 0000E3BE 01 11                   	lw		r1,#1		; not found, step defaults to 1
    819 0000E3C0                        FR4
    820 0000E3C0 08 40 0E D1             	sw		r1,LOPINC	; save that too
                                        
    822 0000E3C4                        FR5
    823 0000E3C4 08 40 06 F2             	lw		r2,CURRNT
    824 0000E3C8 09 40 02 D2             	sw		r2,LOPLN	; save address of current line number
    825 0000E3CC 09 40 04 D8             	sw		r8,LOPPT	; and text pointer
                                        
                                        
    828 0000E3D0 E0 13                   	lw		r3,sp		; dig into the stack to find 'LOPVAR'
    829 0000E3D2 08 40 0C F6             	lw		r6,LOPVAR
    830 0000E3D6 01 AE                   	br		FR7
    831 0000E3D8                        FR6
    832 0000E3D8 3A 13                   	lea		r3,10[r3]	; look at next stack frame
    833 0000E3DA                        FR7
    834 0000E3DA 30 F2                   	lw		r2,[r3]		; is it zero?
    835 0000E3DC 08 A8                   	beq		FR8			; if so, we're done
    836 0000E3DE 6D 22                   	cmp		r2,r6		; same as current LOPVAR?
    837 0000E3E0 FB B9                   	bne		FR6			; nope, look some more
                                        
    839 0000E3E2 30 11                       lw      r1,r3       ; Else remove 5 words from...
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 15
noc_boot.a
    840 0000E3E4 3A 12                   	lea		r2,10[r3]   ; inside the stack.
    841 0000E3E6 E0 13                   	lw		r3,sp		
    842 0000E3E8 3F 40 06 AF             	call	MVDOWN
    843 0000E3EC 0A 6E                   	add		sp,sp,#10	; set the SP 5 words up
    844 0000E3EE                        FR8
    845 0000E3EE 9F BE                       br	    FINISH		; and continue execution
                                        
                                        
                                        ; 'NEXT var' serves as the logical (not necessarily physical) end
                                        ; of the 'FOR' loop.  The control variable 'var' is checked with
                                        ; the 'LOPVAR'.  If they are not the same, the interpreter digs in
                                        ; the stack to find the right one and purges all those that didn't
                                        ; match.  Either way, it then adds the 'STEP' to that variable and
                                        ; checks the result with against the limit value.  If it is within
                                        ; the limit, control loops back to the command following the
                                        ; 'FOR'.  If it's outside the limit, the save area is purged and
                                        ; execution continues.
                                        ;
    858 0000E3F0                        NEXT
    859 0000E3F0 00 11                   	lw		r1,#0		; don't allocate it
    860 0000E3F2 1E 40 0E AF             	call	TSTV		; get address of variable
    861 0000E3F6 04 A9                   	bne		NX4
    862 0000E3F8 1E 4F 0F 11             	lea		r1,msgNextVar
    863 0000E3FC 34 40 0F AE             	br		ERROR		; if no variable, say "What?"
    864 0000E400                        NX4
    865 0000E400 10 19                   	lw		r9,r1		; save variable's address
    866 0000E402                        NX0
    867 0000E402 08 40 0C F1             	lw		r1,LOPVAR	; If 'LOPVAR' is zero, we never...
    868 0000E406 04 A9                   	bne		NX5         ; had a FOR loop
    869 0000E408 1D 4F 0C 11             	lea		r1,msgNextFor
    870 0000E40C 34 40 07 AE             	br		ERROR		
    871 0000E410                        NX5
    872 0000E410 9D 21                   	cmp		r1,r9		; else we check them
    873 0000E412 03 A8                   	beq		NX2			; OK, they agree
    874 0000E414 3E 40 03 AF             	call	POPA		; nope, let's see the next frame
    875 0000E418 F4 BE                   	br		NX0
    876 0000E41A                        NX2
    877 0000E41A 90 F1                   	lw		r1,[r9]		; get control variable's value
    878 0000E41C 08 40 0E F2             	lw		r2,LOPINC
    879 0000E420 20 21                   	add		r1,r2		; add in loop increment
                                        ;	BVS.L	QHOW		say "How?" for 32-bit overflow
    881 0000E422 90 D1                   	sw		r1,[r9]		; save control variable's new value
    882 0000E424 09 40 00 F3             	lw		r3,LOPLMT	; get loop's limit value
    883 0000E428 26 22                   	or		r2,r2       ; check loop increment
    884 0000E42A 03 AB                   	bpl		NX1			; branch if loop increment is positive
    885 0000E42C 3D 21                   	cmp		r1,r3		; test against limit
    886 0000E42E 0A A0                   	blt		NXPurge
    887 0000E430 02 AE                   	br      NX3
    888 0000E432                        NX1
    889 0000E432 3D 21                   	cmp		r1,r3
    890 0000E434 07 A3                   	bgt		NXPurge
    891 0000E436                        NX3	
    892 0000E436 09 40 02 F8             	lw		r8,LOPLN	; Within limit, go back to the...
    893 0000E43A 08 40 06 D8             	sw		r8,CURRNT
    894 0000E43E 09 40 04 F8             	lw		r8,LOPPT	; saved 'CURRNT' and text pointer.
    895 0000E442 75 BE                   	br		FINISH
                                        
    897 0000E444                        NXPurge
    898 0000E444 3C 40 0B AF                 call    POPA        ; purge this loop
    899 0000E448 72 BE                       br      FINISH
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 16
noc_boot.a
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                                        ;
                                        ; 'REM' can be followed by anything and is ignored by the
                                        ; interpreter.
                                        ;
                                        ;REM
                                        ;    br	    IF2		    ; skip the rest of the line
                                        
                                        ; 'IF' is followed by an expression, as a condition and one or
                                        ; more commands (including other 'IF's) separated by colons.
                                        ; Note that the word 'THEN' is not used.  The interpreter evaluates
                                        ; the expression.  If it is non-zero, execution continues.  If it
                                        ; is zero, the commands that follow are ignored and execution
                                        ; continues on the next line.
                                        ;
    919 0000E44A                        IF
    920 0000E44A DF AF                       call	OREXPR		; evaluate the expression
    921 0000E44C                        IF1
    922 0000E44C 16 21                       or      r1,r1       ; is it zero?
    923 0000E44E 02 B9                       bne	    RUNSML		; if not, continue
    924 0000E450                        IF2
    925 0000E450 80 19                       lw		r9,r8		; set lookup pointer
    926 0000E452 00 11                   	lw		r1,#0		; find line #0 (impossible)
    927 0000E454 3A 40 0F AF             	call	FNDSKP		; if so, skip the rest of the line
    928 0000E458 E3 4F 01 A7             	bgtu	WSTART		; if no next line, do a warm start
    929 0000E45C                        IF3
    930 0000E45C EF 4F 07 AE             	br		RUNTSL		; run the next line
                                        
                                        
                                        ; INPUT is called first and establishes a stack frame
    934 0000E460                        INPERR
    935 0000E460 08 40 0A FE             	lw		sp,STKINP	; restore the old stack pointer
    936 0000E464 E4 F8                   	lw		r8,4[sp]
    937 0000E466 08 40 06 D8             	sw		r8,CURRNT	; and old 'CURRNT'
    938 0000E46A E2 F8                   	lw		r8,2[sp]	; and old text pointer
    939 0000E46C 0A 6E                   	add		sp,sp,#10	; fall through will subtract 10
                                        
                                        ; 'INPUT' is like the 'PRINT' command, and is followed by a list
                                        ; of items.  If the item is a string in single or double quotes,
                                        ; or is an underline (back arrow), it has the same effect as in
                                        ; 'PRINT'.  If an item is a variable, this variable name is
                                        ; printed out followed by a colon, then the interpreter waits for
                                        ; an expression to be typed in.  The variable is then set to the
                                        ; value of this expression.  If the variable is preceeded by a
                                        ; string (again in single or double quotes), the string will be
                                        ; displayed followed by a colon.  The interpreter the waits for an
                                        ; expression to be entered and sets the variable equal to the
                                        ; expression's value.  If the input expression is invalid, the
                                        ; interpreter will print "What?", "How?", or "Sorry" and reprint
                                        ; the prompt and redo the input.  The execution will not terminate
                                        ; unless you press control-C.  This is handled in 'INPERR'.
                                        ;
    956 0000E46E                        INPUT
    957 0000E46E F6 6E                   	sub		sp,sp,#10	; allocate stack frame
    958 0000E470 E8 D5                   	sw      r5,8[sp]
    959 0000E472                        IP6
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 17
noc_boot.a
    960 0000E472 E0 D8                   	sw		r8,[sp]		; save in case of error
    961 0000E474 3F 40 0D AF             	call	QTSTG		; is next item a string?
    962 0000E478 06 AE                   	br		IP2			; nope - this branch must take only two bytes
    963 0000E47A 01 11                   	lw		r1,#1		; allocate var
    964 0000E47C 1A 40 09 AF             	call	TSTV		; yes, but is it followed by a variable?
    965 0000E480 29 A8                   	beq     IP4		    ; if not, brnch
    966 0000E482 10 1A                   	lw		r10,r1		; put away the variable's address
    967 0000E484 10 AE                   	br		IP3			; if so, input to variable
    968 0000E486                        IP2
    969 0000E486 E2 D8                   	sw		r8,2[sp]	; save for 'PRTSTG'
    970 0000E488 01 11                   	lw		r1,#1
    971 0000E48A 1A 40 02 AF             	call	TSTV		; must be a variable now
    972 0000E48E 04 A9                   	bne		IP7
    973 0000E490 1B 4F 0F 11             	lea		r1,msgInputVar
    974 0000E494 30 40 03 AE             	br		ERROR		; "What?" it isn't?
    975 0000E498                        IP7
    976 0000E498 10 1A                   	lw		r10,r1		; put away the variable's address
    977 0000E49A 80 E5                   	lb		r5,[r8]		; get ready for 'PRTSTG' by null terminating
    978 0000E49C 80 C0                   	sb		r0,[r8]
    979 0000E49E E2 F1                   	lw		r1,2[sp]	; get back text pointer
    980 0000E4A0 3C 40 0B AF             	call	PRTSTG		; print string as prompt
    981 0000E4A4 80 C5                   	sb		r5,[r8]		; un-null terminate
    982 0000E4A6                        IP3
    983 0000E4A6 E2 D8                   	sw		r8,2[sp]	; save in case of error
    984 0000E4A8 08 40 06 F1             	lw		r1,CURRNT
    985 0000E4AC E4 D1                   	sw		r1,4[sp]	; also save 'CURRNT'
    986 0000E4AE 0F 11                   	lw		r1,#-1
    987 0000E4B0 08 40 06 D1             	sw		r1,CURRNT	; flag that we are in INPUT
    988 0000E4B4 08 40 0A DE             	sw		sp,STKINP	; save the stack pointer too
    989 0000E4B8 E6 DA                   	sw		r10,6[sp]	; save the variable address
    990 0000E4BA 03 40 0A 11             	lw		r1,#':'		; print a colon first
    991 0000E4BE 30 40 08 AF             	call	GETLN		; then get an input line
    992 0000E4C2 0A 40 0E 18             	lea		r8,BUFFER	; point to the buffer
    993 0000E4C6 A1 AF                   	call	OREXPR		; evaluate the input
    994 0000E4C8 E6 FA                   	lw		r10,6[sp]	; restore the variable address
    995 0000E4CA A0 D1                   	sw		r1,[r10]	; save value in variable
    996 0000E4CC E4 F1                   	lw		r1,4[sp]	; restore old 'CURRNT'
    997 0000E4CE 08 40 06 D1             	sw		r1,CURRNT
    998 0000E4D2 E2 F8                   	lw		r8,2[sp]	; and the old text pointer
    999 0000E4D4                        IP4
   1000 0000E4D4 48 40 07 AF             	call	TSTC		; is the next thing a comma?
   1001 0000E4D8 2C 04                   	db	',',IP5-*+1
   1002 0000E4DA CB BE                   	br		IP6			; yes, more items
   1003 0000E4DC                        IP5
   1004 0000E4DC E8 F5                       lw      r5,8[sp]
   1005 0000E4DE 0A 6E                   	add		sp,sp,#10	; clean up the stack
   1006 0000E4E0 26 BE                   	jmp		FINISH
                                        
                                        
   1009 0000E4E2                        DEFLT
   1010 0000E4E2 80 E1                       lb      r1,[r8]
   1011 0000E4E4 FF 4F 13 10                 cmp     r1,#CR      ; empty line is OK
   1012 0000E4E8 22 B8                   	beq	    FINISH	    ; else it is 'LET'
                                        
                                        
                                        ; 'LET' is followed by a list of items separated by commas.
                                        ; Each item consists of a variable, an equals sign, and an
                                        ; expression.  The interpreter evaluates the expression and sets
                                        ; the variable to that value.  The interpreter will also handle
                                        ; 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 18
noc_boot.a
                                        ;
   1021 0000E4EA                        LET
   1022 0000E4EA 29 40 0A AF                 call	SETVAL		; do the assignment
   1023 0000E4EE 47 40 0A AF             	call	TSTC		; check for more 'LET' items
   1024 0000E4F2 2C 04                   	db	',',LT1-*+1
   1025 0000E4F4 FA BE                   	br	    LET
   1026 0000E4F6                        LT1
   1027 0000E4F6 1B BE                       br	    FINISH		; until we are finished.
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** LOAD *** & SAVE ***
                                        ;
                                        ; These two commands transfer a program to/from an auxiliary
                                        ; device such as a cassette, another computer, etc.  The program
                                        ; is converted to an easily-stored format: each line starts with
                                        ; a colon, the line no. as 4 hex digits, and the rest of the line.
                                        ; At the end, a line starting with an '@' sign is sent.  This
                                        ; format can be read back with a minimum of processing time by
                                        ; the Butterfly.
                                        ;
   1042 0000E4F8                        LOAD
   1043 0000E4F8 08 4E 06 F8             	lw		r8,TXTBGN	; set pointer to start of prog. area
   1044 0000E4FC 00 40 0D 11             	lw		r1,#CR		; For a CP/M host, tell it we're ready...
   1045 0000E500 DB 4F 0B AF             	call	GOAUXO		; by sending a CR to finish PIP command.
   1046 0000E504                        LOD1
   1047 0000E504 DB 4F 0B AF             	call	GOAUXI		; look for start of line
   1048 0000E508 FD BA                   	bmi		LOD1
   1049 0000E50A FC 4F 10 10             	cmp		r1,#'@'		; end of program?
   1050 0000E50E 1B A8                   	beq		LODEND
   1051 0000E510 FE 4F 16 10             	cmp     r1,#0x1A    ; or EOF marker
   1052 0000E514 18 A8                   	beq     LODEND
   1053 0000E516 FC 4F 16 10             	cmp		r1,#':'		; if not, is it start of line?
   1054 0000E51A F4 B9                   	bne		LOD1		; if not, wait for it
   1055 0000E51C 18 AF                   	call	GCHAR		; get line number
   1056 0000E51E 80 C1                   	sb		r1,[r8]		; store it
   1057 0000E520 A1 31                   	shr		r1,#1
   1058 0000E522 A1 31                   	shr		r1,#1
   1059 0000E524 A1 31                   	shr		r1,#1
   1060 0000E526 A1 31                   	shr		r1,#1
   1061 0000E528 A1 31                   	shr		r1,#1
   1062 0000E52A A1 31                   	shr		r1,#1
   1063 0000E52C A1 31                   	shr		r1,#1
   1064 0000E52E A1 31                   	shr		r1,#1
   1065 0000E530 81 C1                   	sb		r1,1[r8]
   1066 0000E532 02 68                   	add		r8,r8,#2
   1067 0000E534                        LOD2
   1068 0000E534 DA 4F 03 AF             	call	GOAUXI		; get another text char.
   1069 0000E538 FD BA                   	bmi		LOD2
   1070 0000E53A 80 C1                   	sb		r1,[r8]
   1071 0000E53C 01 68                   	add		r8,r8,#1	; store it
   1072 0000E53E FF 4F 13 10             	cmp		r1,#CR		; is it the end of the line?
   1073 0000E542 F8 B9                   	bne		LOD2		; if not, go back for more
   1074 0000E544 DF BE                   	br		LOD1		; if so, start a new line
   1075 0000E546                        LODEND
   1076 0000E546 09 40 06 D8             	sw		r8,TXTUNF	; set end-of program pointer
   1077 0000E54A DB 4F 08 AE             	br		WSTART		; back to direct mode
                                        
                                        ; get character from input (16 bit value)
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 19
noc_boot.a
   1080 0000E54E                        GCHAR
   1081 0000E54E FA 6E                   	sub		sp,sp,#6
   1082 0000E550 E0 DF                   	sw		lr,[sp]
   1083 0000E552 E2 D5                   	sw		r5,2[sp]
   1084 0000E554 E4 D6                   	sw		r6,4[sp]
   1085 0000E556 04 16                   	lw      r6,#4       ; repeat four times
   1086 0000E558 00 15                   	lw		r5,#0
   1087 0000E55A                        GCHAR1
   1088 0000E55A D9 4F 00 AF             	call	GOAUXI		; get a char
   1089 0000E55E FD BA                   	bmi		GCHAR1
   1090 0000E560 0D AF                   	call	asciiToHex
   1091 0000E562 81 35                   	shl		r5,#1
   1092 0000E564 81 35                   	shl		r5,#1
   1093 0000E566 81 35                   	shl		r5,#1
   1094 0000E568 81 35                   	shl		r5,#1
   1095 0000E56A 16 25                   	or		r5,r1
   1096 0000E56C FF 66                   	sub		r6,r6,#1
   1097 0000E56E F5 B9                   	bne     GCHAR1
   1098 0000E570 50 11                   	lw		r1,r5
   1099 0000E572 E0 FF                   	lw		lr,[sp]
   1100 0000E574 E2 F5                   	lw		r5,2[sp]
   1101 0000E576 E4 F6                   	lw		r6,4[sp]
   1102 0000E578 06 6E                   	add     sp,sp,#6
   1103 0000E57A F0 80                   	ret
                                        
                                        ; convert an ascii char to hex code
                                        ; input
                                        ;	r2 = char to convert
                                        
   1109 0000E57C                        asciiToHex
   1110 0000E57C FC 4F 17 10             	cmp		r1,#'9'
   1111 0000E580 01 A2                   	ble		a2h1		; less than '9'
   1112 0000E582 F9 61                   	sub		r1,r1,#7	; shift 'A' to '9'+1
   1113 0000E584                        a2h1
   1114 0000E584 D0 61                   	sub		r1,r1,#'0'	;
   1115 0000E586 00 40 5F 31             	and		r1,#15		; make sure a nybble
   1116 0000E58A F0 80                   	ret
                                        
                                        ; output a CR LF sequence to auxillary output
                                        ; Registers Affected
                                        ;   r3 = LF
   1121 0000E58C                        AUXOCRLF
   1122 0000E58C FE 6E                       sub     sp,sp,#2
   1123 0000E58E E0 DF                       sw      lr,[sp]
   1124 0000E590 00 40 0D 11                 lw      r1,#CR
   1125 0000E594 D7 4F 01 AF                 call    GOAUXO
   1126 0000E598 0A 11                       lw      r1,#LF
   1127 0000E59A D6 4F 0E AF                 call    GOAUXO
   1128 0000E59E E0 FF                       lw      lr,[sp]
   1129 0000E5A0 02 6E                   	add		sp,sp,#2
   1130 0000E5A2 F0 80                       ret
                                        
                                        
                                        ; convert nybble in r2 to ascii hex char2
                                        ; r2 = character to convert
                                        
   1136 0000E5A4                        toAsciiHex
   1137 0000E5A4 00 40 5F 31             	and		r1,#15		; make sure it's a nybble
   1138 0000E5A8 FF 4F 16 10             	cmp		r1,#10		; > 10 ?
   1139 0000E5AC 01 A0                   	blt		tah1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 20
noc_boot.a
   1140 0000E5AE 07 61                   	add		r1,r1,#7	; bump it up to the letter 'A'
   1141 0000E5B0                        tah1
   1142 0000E5B0 30 61                   	add		r1,r1,#'0'	; bump up to ascii '0'
   1143 0000E5B2 F0 80                   	ret
                                        
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** POKE *** & SYSX ***
                                        ;
                                        ; 'POKE expr1,expr2' stores the byte from 'expr2' into the memory
                                        ; address specified by 'expr1'.
                                        ;
                                        ; 'SYSX expr' jumps to the machine language subroutine whose
                                        ; starting address is specified by 'expr'.  The subroutine can use
                                        ; all registers but must leave the stack the way it found it.
                                        ; The subroutine returns to the interpreter by executing an RET.
                                        ;
   1159 0000E5B4                        POKE
   1160 0000E5B4 FE 6E                   	sub		sp,sp,#2
   1161 0000E5B6 29 AF                   	call	OREXPR		; get the memory address
   1162 0000E5B8 41 40 05 AF             	call	TSTC		; it must be followed by a comma
   1163 0000E5BC 2C 10                   	db	',',PKER-*+1
   1164 0000E5BE E0 D1                   	sw		r1,[sp]	    ; save the address
   1165 0000E5C0 24 AF                   	call	OREXPR		; get the byte to be POKE'd
   1166 0000E5C2 E0 F2                   	lw		r2,[sp]	    ; get the address back
   1167 0000E5C4 20 C1                   	sb		r1,[r2]		; store the byte in memory
   1168 0000E5C6 02 6E                   	add		sp,sp,#2
   1169 0000E5C8 EB 4F 01 AE             	br		FINISH
   1170 0000E5CC                        PKER
   1171 0000E5CC 15 4F 08 11             	lea		r1,msgComma
   1172 0000E5D0 26 40 05 AE             	br		ERROR		; if no comma, say "What?"
                                        
                                        
   1175 0000E5D4                        POKEW
   1176 0000E5D4 FE 6E                   	sub		sp,sp,#2
   1177 0000E5D6 19 AF                   	call	OREXPR		; get the memory address
   1178 0000E5D8 40 40 05 AF             	call	TSTC		; it must be followed by a comma
   1179 0000E5DC 2C F0                   	db	',',PKER-*+1
   1180 0000E5DE E0 D1                   	sw		r1,[sp]	    ; save the address
   1181 0000E5E0 14 AF                   	call	OREXPR		; get the byte to be POKE'd
   1182 0000E5E2 E0 F2                   	lw		r2,[sp]	    ; get the address back
   1183 0000E5E4 20 D1                   	sw		r1,[r2]		; store the word in memory
   1184 0000E5E6 02 6E                   	add		sp,sp,#2
   1185 0000E5E8 EA 4F 01 AE             	jmp		FINISH
                                        
                                        
   1188 0000E5EC                        SYSX
   1189 0000E5EC FE 6E                   	sub		sp,sp,#2
   1190 0000E5EE 0D AF                   	call	OREXPR		; get the subroutine's address
   1191 0000E5F0 16 20                   	or		r0,r1		; make sure we got a valid address
   1192 0000E5F2 04 A9                   	bne		sysx1
   1193 0000E5F4 1A 4F 0D 11             	lea		r1,msgSYSBad
   1194 0000E5F8 25 40 01 AE             	br		ERROR
   1195 0000E5FC                        sysx1
   1196 0000E5FC E0 D8                   	sw		r8,[sp]	    ; save the text pointer
   1197 0000E5FE CF 48 0F AF             	call	[r1]		; jump to the subroutine
   1198 0000E602 E0 F8                   	lw		r8,[sp]	    ; restore the text pointer
   1199 0000E604 02 6E                   	add		sp,sp,#2
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 21
noc_boot.a
   1200 0000E606 E9 4F 02 AE             	br		FINISH
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** EXPR ***
                                        ;
                                        ; 'EXPR' evaluates arithmetical or logical expressions.
                                        ; <OREXPR>::= <ANDEXPR> OR <ANDEXPR> ...
                                        ; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                                        ; <EXPR>::=<EXPR2>
                                        ;	   <EXPR2><rel.op.><EXPR2>
                                        ; where <rel.op.> is one of the operators in TAB8 and the result
                                        ; of these operations is 1 if true and 0 if false.
                                        ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                                        ; where () are optional and (... are optional repeats.
                                        ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                                        ; <EXPR4>::=<variable>
                                        ;	    <function>
                                        ;	    (<EXPR>)
                                        ; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                                        ; as an index, functions can have an <EXPR> as arguments, and
                                        ; <EXPR4> can be an <EXPR> in parenthesis.
                                        ;
                                        
                                        
                                        ; <OREXPR>::=<ANDEXPR> OR <ANDEXPR> ...
                                        ;
   1228 0000E60A                        OREXPR
   1229 0000E60A FC 6E                   	sub		sp,sp,#4
   1230 0000E60C E0 DF                   	sw		lr,[sp]
   1231 0000E60E 0F AF                   	call	ANDEXPR		; get first <ANDEXPR>
   1232 0000E610                        XP_OR1
   1233 0000E610 E2 D1                   	sw		r1,2[sp]	; save <ANDEXPR> value
   1234 0000E612 16 4E 0D 19             	lea		r9,TAB10		; look up a logical operator
   1235 0000E616 1C 4E 04 1A             	lea		r10,TAB10_1
   1236 0000E61A DD 4F 09 AE             	jmp		EXEC		; go do it
                                        
   1238 0000E61E                        XP_OR
   1239 0000E61E 07 AF                       call    ANDEXPR
   1240 0000E620 E2 F2                       lw      r2,2[sp]
   1241 0000E622 26 21                       or      r1,r2
   1242 0000E624 F5 BE                       br      XP_OR1
                                        
   1244 0000E626                        XP_ORX
   1245 0000E626 E2 F1                   	lw		r1,2[sp]
   1246 0000E628 E0 FF                       lw      lr,[sp]
   1247 0000E62A 04 6E                       add     sp,sp,#4
   1248 0000E62C F0 80                       ret
                                        
                                        
                                        ; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                                        ;
   1253 0000E62E                        ANDEXPR
   1254 0000E62E FC 6E                   	sub		sp,sp,#4
   1255 0000E630 E0 DF                   	sw		lr,[sp]
   1256 0000E632 37 AF                   	call	EXPR		; get first <EXPR>
   1257 0000E634                        XP_AND1
   1258 0000E634 E2 D1                   	sw		r1,2[sp]	; save <EXPR> value
   1259 0000E636 16 4E 09 19             	lea		r9,TAB9		; look up a logical operator
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 22
noc_boot.a
   1260 0000E63A 1C 4E 00 1A             	lea		r10,TAB9_1
   1261 0000E63E DC 4F 07 AE             	jmp		EXEC		; go do it
                                        
   1263 0000E642                        XP_AND
   1264 0000E642 2F AF                       call    EXPR
   1265 0000E644 E2 F2                       lw      r2,2[sp]
   1266 0000E646 25 21                       and     r1,r2
   1267 0000E648 F5 BE                       br      XP_AND1
                                        
   1269 0000E64A                        XP_ANDX
   1270 0000E64A E2 F1                   	lw		r1,2[sp]
   1271 0000E64C E0 FF                       lw      lr,[sp]
   1272 0000E64E 04 6E                       add     sp,sp,#4
   1273 0000E650 F0 80                       ret
                                        
                                        
                                        ; Determine if the character is a digit
                                        ;   Parameters
                                        ;       r2 = char to test
                                        ;   Returns
                                        ;       r1 = 1 if digit, otherwise 0
                                        ;
   1282 0000E652                        isDigit
   1283 0000E652 FD 4F 10 10                 cmp     r1,#'0'
   1284 0000E656 05 A0                       blt     isDigitFalse
   1285 0000E658 FC 4F 17 10                 cmp     r1,#'9'
   1286 0000E65C 02 A3                       bgt     isDigitFalse
   1287 0000E65E 01 11                       lw      r1,#1
   1288 0000E660 F0 80                       ret
   1289 0000E662                        isDigitFalse
   1290 0000E662 00 11                       lw      r1,#0
   1291 0000E664 F0 80                       ret
                                        
                                        
                                        ; Determine if the character is a alphabetic
                                        ;   Parameters
                                        ;       r2 = char to test
                                        ;   Returns
                                        ;       r1 = 1 if alpha, otherwise 0
                                        ;
   1300 0000E666                        isAlpha
   1301 0000E666 FB 4F 1F 10                 cmp     r1,#'A'
   1302 0000E66A 0B A0                       blt     isAlphaFalse
   1303 0000E66C FA 4F 16 10                 cmp     r1,#'Z'
   1304 0000E670 06 A2                       ble     isAlphaTrue
   1305 0000E672 F9 4F 1F 10                 cmp     r1,#'a'
   1306 0000E676 05 A0                       blt     isAlphaFalse
   1307 0000E678 F8 4F 16 10                 cmp     r1,#'z'
   1308 0000E67C 02 A3                       bgt     isAlphaFalse
   1309 0000E67E                        isAlphaTrue
   1310 0000E67E 01 11                       lw      r1,#1
   1311 0000E680 F0 80                       ret
   1312 0000E682                        isAlphaFalse
   1313 0000E682 00 11                       lw      r1,#0
   1314 0000E684 F0 80                       ret
                                        
                                        
                                        ; Determine if the character is a alphanumeric
                                        ;   Parameters
                                        ;       r1 = char to test
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 23
noc_boot.a
                                        ;   Returns
                                        ;       r1 = 1 if alpha, otherwise 0
                                        ;
   1323 0000E686                        isAlnum
   1324 0000E686 FE 6E                       sub     sp,sp,#2
   1325 0000E688 E0 DF                       sw      lr,[sp]
   1326 0000E68A 10 12                       lw      r2,r1		; save test char
   1327 0000E68C E2 BF                       call    isDigit
   1328 0000E68E 06 A9                       bne		isDigitx	; if it is a digit
   1329 0000E690 20 11                       lw      r1,r2		; get back test char
   1330 0000E692 E9 BF                       call    isAlpha
   1331 0000E694 E0 FF                       lw      lr,[sp]
   1332 0000E696 02 6E                       add		sp,sp,#2
   1333 0000E698 16 21                       or      r1,r1
   1334 0000E69A F0 80                       ret
   1335 0000E69C                        isDigitx
   1336 0000E69C E0 FF                       lw      lr,[sp]
   1337 0000E69E 02 6E                       add     sp,sp,#2	; return Z=0
   1338 0000E6A0 F0 80                       ret
                                        
                                        
   1341 0000E6A2                        EXPR
   1342 0000E6A2 FC 6E                   	sub		sp,sp,#4
   1343 0000E6A4 E0 DF                   	sw		lr,[sp]
   1344 0000E6A6 39 AF                   	call	EXPR2
   1345 0000E6A8 E2 D1                   	sw		r1,2[sp]	; save <EXPR2> value
   1346 0000E6AA 15 4E 0F 19             	lea		r9,TAB8		; look up a relational operator
   1347 0000E6AE 1B 4E 02 1A             	lea		r10,TAB8_1
   1348 0000E6B2 D8 4F 0D AE             	jmp		EXEC		; go do it
                                        
   1350 0000E6B6                        XP11
   1351 0000E6B6 E2 F1                   	lw		r1,2[sp]
   1352 0000E6B8 28 AF                   	call	XP18	; is it ">="?
   1353 0000E6BA 1D 22                   	cmp		r2,r1
   1354 0000E6BC 1E A1                   	bge		XPRT1	; no, return r2=1
   1355 0000E6BE 19 AE                   	br		XPRT0	; else return r2=0
                                        
   1357 0000E6C0                        XP12
   1358 0000E6C0 E2 F1                   	lw		r1,2[sp]
   1359 0000E6C2 23 AF                   	call	XP18	; is it "<>"?
   1360 0000E6C4 1D 22                   	cmp		r2,r1
   1361 0000E6C6 19 A9                   	bne		XPRT1	; no, return r2=1
   1362 0000E6C8 14 AE                   	br		XPRT0	; else return r2=0
                                        
   1364 0000E6CA                        XP13
   1365 0000E6CA E2 F1                   	lw		r1,2[sp]
   1366 0000E6CC 1E AF                   	call	XP18	; is it ">"?
   1367 0000E6CE 1D 22                   	cmp		r2,r1
   1368 0000E6D0 14 A3                   	bgt		XPRT1	; no, return r2=1
   1369 0000E6D2 0F AE                   	br		XPRT0	; else return r2=0
                                        
   1371 0000E6D4                        XP14
   1372 0000E6D4 E2 F1                   	lw		r1,2[sp]
   1373 0000E6D6 19 AF                   	call	XP18	; is it "<="?
   1374 0000E6D8 1D 22                   	cmp		r2,r1
   1375 0000E6DA 0F A2                   	ble		XPRT1	; no, return r2=1
   1376 0000E6DC 0A AE                   	br		XPRT0	; else return r2=0
                                        
   1378 0000E6DE                        XP15
   1379 0000E6DE E2 F1                   	lw		r1,2[sp]
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 24
noc_boot.a
   1380 0000E6E0 14 AF                   	call	XP18	; is it "="?
   1381 0000E6E2 1D 22                   	cmp		r2,r1
   1382 0000E6E4 0A A8                   	beq		XPRT1	; if not, return r2=1
   1383 0000E6E6 05 AE                   	br		XPRT0	; else return r2=0
                                        
                                        
   1386 0000E6E8                        XP16
   1387 0000E6E8 E2 F1                   	lw		r1,2[sp]
   1388 0000E6EA 0F AF                   	call	XP18	; is it "<"?
   1389 0000E6EC 1D 22                   	cmp		r2,r1
   1390 0000E6EE 05 A0                   	blt		XPRT1	; if not, return r2=1
   1391 0000E6F0 00 AE                   	br		XPRT0	; else return r2=0
                                        
   1393 0000E6F2                        XPRT0
   1394 0000E6F2 E0 FF                   	lw		lr,[sp]
   1395 0000E6F4 04 6E                   	add		sp,sp,#4
   1396 0000E6F6 00 11                   	lw		r1,#0   ; return r1=0 (false)
   1397 0000E6F8 F0 80                   	ret
                                        
   1399 0000E6FA                        XPRT1
   1400 0000E6FA E0 FF                   	lw		lr,[sp]
   1401 0000E6FC 04 6E                   	add		sp,sp,#4
   1402 0000E6FE 01 11                   	lw		r1,#1	; return r1=1 (true)
   1403 0000E700 F0 80                   	ret
                                        
   1405 0000E702                        XP17				; it's not a rel. operator
   1406 0000E702 E2 F1                   	lw		r1,2[sp]	; return r2=<EXPR2>
   1407 0000E704 E0 FF                   	lw		lr,[sp]
   1408 0000E706 04 6E                   	add		sp,sp,#4
   1409 0000E708 F0 80                   	ret
                                        
   1411 0000E70A                        XP18
   1412 0000E70A FC 6E                   	sub		sp,sp,#4
   1413 0000E70C E0 DF                   	sw		lr,[sp]
   1414 0000E70E E2 D1                   	sw		r1,2[sp]
   1415 0000E710 04 AF                   	call	EXPR2		; do a second <EXPR2>
   1416 0000E712 E2 F2                   	lw		r2,2[sp]
   1417 0000E714 E0 FF                   	lw		lr,[sp]
   1418 0000E716 04 6E                   	add		sp,sp,#4
   1419 0000E718 F0 80                   	ret
                                        
                                        ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                                        
   1423 0000E71A                        EXPR2
   1424 0000E71A FC 6E                   	sub		sp,sp,#4
   1425 0000E71C E0 DF                   	sw		lr,[sp]
   1426 0000E71E 36 40 02 AF             	call	TSTC		; negative sign?
   1427 0000E722 2D 08                   	db	'-',XP21-*+1
   1428 0000E724 00 11                   	lw		r1,#0		; yes, fake '0-'
   1429 0000E726 E2 D1                   	sw		r1,2[sp]
   1430 0000E728 0F AE                   	br		XP26
   1431 0000E72A                        XP21
   1432 0000E72A 35 40 0C AF             	call	TSTC		; positive sign? ignore it
   1433 0000E72E 2B 02                   	db	'+',XP22-*+1
   1434 0000E730                        XP22
   1435 0000E730 12 AF                   	call	EXPR3		; first <EXPR3>
   1436 0000E732                        XP23
   1437 0000E732 E2 D1                   	sw		r1,2[sp]	; yes, save the value
   1438 0000E734 35 40 07 AF             	call	TSTC		; add?
   1439 0000E738 2B 0A                   	db	'+',XP25-*+1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 25
noc_boot.a
   1440 0000E73A 0D AF                   	call	EXPR3		; get the second <EXPR3>
   1441 0000E73C                        XP24
   1442 0000E73C E2 F2                   	lw		r2,2[sp]
   1443 0000E73E 20 21                   	add		r1,r2		; add it to the first <EXPR3>
                                        ;	BVS.L	QHOW		brnch if there's an overflow
   1445 0000E740 F8 BE                   	br		XP23		; else go back for more operations
   1446 0000E742                        XP25
   1447 0000E742 35 40 00 AF             	call	TSTC		; subtract?
   1448 0000E746 2D 08                   	db	'-',XP45-*+1
   1449 0000E748                        XP26
   1450 0000E748 06 AF                   	call	EXPR3		; get second <EXPR3>
   1451 0000E74A 20 31                   	neg		r1			; change its sign
   1452 0000E74C F7 BE                   	br		XP24		; and do an addition
                                        
   1454 0000E74E                        XP45
   1455 0000E74E E2 F1                   	lw		r1,2[sp]
   1456 0000E750 E0 FF                   	lw		lr,[sp]
   1457 0000E752 04 6E                   	add		sp,sp,#4
   1458 0000E754 F0 80                   	ret
                                        
                                        
                                        ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                                        
   1463 0000E756                        EXPR3
   1464 0000E756 FC 6E                   	sub		sp,sp,#4
   1465 0000E758 E0 DF                   	sw		lr,[sp]
   1466 0000E75A 14 AF                   	call	EXPR4		; get first <EXPR4>
   1467 0000E75C                        XP31
   1468 0000E75C E2 D1                   	sw		r1,2[sp]	; yes, save that first result
   1469 0000E75E 34 40 02 AF             	call	TSTC		; multiply?
   1470 0000E762 2A 0A                   	db	'*',XP34-*+1
   1471 0000E764 0F AF                   	call	EXPR4		; get second <EXPR4>
   1472 0000E766 E2 F2                   	lw		r2,2[sp]
   1473 0000E768 B8 AF                   	call	MULT32		; multiply the two
   1474 0000E76A F8 BE                   	br		XP31		 ; then look for more terms
   1475 0000E76C                        XP34
   1476 0000E76C 33 40 0B AF             	call	TSTC		; divide?
   1477 0000E770 2F 0C                   	db	'/',XP47-*+1
   1478 0000E772 08 AF                   	call	EXPR4		; get second <EXPR4>
   1479 0000E774 10 12                   	lw      r2,r1
   1480 0000E776 E2 F1                   	lw		r1,2[sp]
   1481 0000E778 CD AF                   	call	DIV32		; do the division
   1482 0000E77A F0 BE                   	br		XP31		; go back for any more terms
                                        
   1484 0000E77C                        XP47
   1485 0000E77C E2 F1                   	lw		r1,2[sp]
   1486 0000E77E E0 FF                   	lw		lr,[sp]
   1487 0000E780 04 6E                   	add		sp,sp,#4
   1488 0000E782 F0 80                   	ret
                                        
                                        
                                        ; Functions are called through EXPR4
                                        ; <EXPR4>::=<variable>
                                        ;	    <function>
                                        ;	    (<EXPR>)
                                        
   1496 0000E784                        EXPR4
   1497 0000E784 FA 6E                       sub     sp,sp,#6
   1498 0000E786 E0 DF                       sw      lr,[sp]
   1499 0000E788 13 4E 09 19             	lea		r9,TAB4		; find possible function
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 26
noc_boot.a
   1500 0000E78C 19 4E 0A 1A             	lea		r10,TAB4_1
   1501 0000E790 D1 4F 0E AE             	jmp		EXEC        ; branch to function which does subsequent
                                        	                    ; ret for EXPR4
                                        
   1504 0000E794                        XP40                    ; we get here if it wasn't a function
   1505 0000E794 00 11                   	lw		r1,#0
   1506 0000E796 1D AF                   	call	TSTV		
   1507 0000E798 04 A8                   	beq     XP41        ; nor a variable
   1508 0000E79A 10 F1                   	lw		r1,[r1]		; if a variable, return its value in r1
   1509 0000E79C E0 FF                   	lw      lr,[sp]
   1510 0000E79E 06 6E                   	add     sp,sp,#6
   1511 0000E7A0 F0 80                   	ret
   1512 0000E7A2                        XP41
   1513 0000E7A2 33 40 02 AF             	call	TSTNUM		; or is it a number?
   1514 0000E7A6 26 22                   	or		r2,r2		; (if not, # of digits will be zero)
   1515 0000E7A8 01 A9                   	bne		XP46		; if so, return it in r1
   1516 0000E7AA 03 AF                   	call    PARN        ; check for (EXPR)
   1517 0000E7AC                        XP46
   1518 0000E7AC E0 FF                   	lw      lr,[sp]
   1519 0000E7AE 06 6E                   	add     sp,sp,#6
   1520 0000E7B0 F0 80                   	ret
                                        
                                        
                                        ; Check for a parenthesized expression
   1524 0000E7B2                        PARN
   1525 0000E7B2 FE 6E                   	sub		sp,sp,#2
   1526 0000E7B4 E0 DF                   	sw		lr,[sp]
   1527 0000E7B6 31 40 06 AF             	call	TSTC		; else look for ( OREXPR )
   1528 0000E7BA 28 10                   	db	'(',XP43-*+1
   1529 0000E7BC 26 BF                   	call	OREXPR
   1530 0000E7BE 31 40 02 AF             	call	TSTC
   1531 0000E7C2 29 08                   	db	')',XP43-*+1
   1532 0000E7C4                        XP42
   1533 0000E7C4 E0 FF                   	lw		lr,[sp]
   1534 0000E7C6 02 6E                   	add		sp,sp,#2
   1535 0000E7C8 F0 80                   	ret
   1536 0000E7CA                        XP43
   1537 0000E7CA 0D 4F 05 11             	lea		r1,msgWhat
   1538 0000E7CE 16 40 06 AE             	br		ERROR
                                        
                                        
                                        ; ===== Test for a valid variable name.  Returns Z=1 if not
                                        ;	found, else returns Z=0 and the address of the
                                        ;	variable in r1.
                                        ; Parameters
                                        ;	r1 = 1 = allocate if not found
                                        ; Returns
                                        ;	r1 = address of variable, zero if not found
                                        
   1549 0000E7D2                        TSTV
   1550 0000E7D2 FA 6E                   	sub		sp,sp,#6
   1551 0000E7D4 E0 DF                   	sw		lr,[sp]
   1552 0000E7D6 E2 D5                   	sw		r5,2[sp]
   1553 0000E7D8 10 15                   	lw		r5,r1		; allocate flag
   1554 0000E7DA 33 40 07 AF             	call	IGNBLK
   1555 0000E7DE 80 E1                   	lb		r1,[r8]		; look at the program text
   1556 0000E7E0 FC 4F 10 10             	cmp     r1,#'@'
   1557 0000E7E4 1C A0                   	blt     tstv_notfound   ; C=1: not a variable
   1558 0000E7E6 12 A9                   	bne		TV1			; brnch if not "@" array
   1559 0000E7E8 01 68                   	add		r8,r8,#1	; If it is, it should be
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 27
noc_boot.a
   1560 0000E7EA E3 BF                   	call	PARN		; followed by (EXPR) as its index.
   1561 0000E7EC 81 31                   	shl     r1,#1
   1562 0000E7EE 81 31                   	shl     r1,#1
                                        ;	BCS.L	QHOW		say "How?" if index is too big
   1564 0000E7F0 E4 D1                       sw      r1,4[sp]    ; save the index
   1565 0000E7F2 F4 6E                       sub		sp,sp,#12
   1566 0000E7F4 E0 DF                       sw		lr,[sp]
   1567 0000E7F6 10 40 08 AF             	call	SIZEX		; get amount of free memory
   1568 0000E7FA E4 F2                   	lw      r2,4[sp]    ; get back the index
   1569 0000E7FC 1D 22                   	cmp     r2,r1       ; see if there's enough memory
   1570 0000E7FE 02 A4                   	bltu	TV2
   1571 0000E800 14 40 08 AE             	jmp    	QSORRY		; if not, say "Sorry"
   1572 0000E804                        TV2
   1573 0000E804 09 40 08 F1             	lw      r1,VARBGN   ; put address of array element...
   1574 0000E808 22 21                   	sub     r1,r2       ; into r1 (neg. offset is used)
   1575 0000E80A 05 AE                   	br      TSTVRT
   1576 0000E80C                        TV1	
   1577 0000E80C 0D AF                       call    getVarName      ; get variable name
   1578 0000E80E 07 A8                       beq     tstv_notfound   ; if not, set Z=1 and return
   1579 0000E810 50 12                       lw		r2,r5
   1580 0000E812 45 AF                       call    findVar     ; find or allocate
   1581 0000E814 04 A8                       beq		tstv_notfound
   1582 0000E816                        TSTVRT
   1583 0000E816 E2 F5                   	lw		r5,2[sp]
   1584 0000E818 E0 FF                   	lw		lr,[sp]
   1585 0000E81A 06 6E                   	add		sp,sp,#6    ; Z=0 (found)
   1586 0000E81C F0 80                   	ret
   1587 0000E81E                        tstv_notfound
   1588 0000E81E E2 F5                   	lw		r5,2[sp]
   1589 0000E820 E0 FF                       lw      lr,[sp]
   1590 0000E822 06 6E                       add     sp,sp,#6
   1591 0000E824 00 11                       lw      r1,#0       ; Z=1 if not found
   1592 0000E826 F0 80                       ret
                                        
                                        
                                        ; Returns
                                        ;   r1 = 3 character variable name + type
                                        ;
   1598 0000E828                        getVarName
   1599 0000E828 FA 6E                       sub     sp,sp,#6
   1600 0000E82A E0 DF                       sw      lr,[sp]
   1601 0000E82C E4 D5                       sw		r5,4[sp]
                                        
   1603 0000E82E 80 E1                       lb      r1,[r8]     ; get first character
   1604 0000E830 E2 D1                       sw		r1,2[sp]	; save off current name
   1605 0000E832 19 BF                       call    isAlpha
   1606 0000E834 2F A8                       beq     gvn1
   1607 0000E836 02 15                       lw      r5,#2       ; loop twice more
                                        
                                        	; check for second/third character
   1610 0000E838                        gvn4
   1611 0000E838 01 68                   	add     r8,r8,#1
   1612 0000E83A 80 E1                   	lb      r1,[r8]     ; do we have another char ?
   1613 0000E83C 24 BF                   	call    isAlnum
   1614 0000E83E 12 A8                   	beq     gvn2        ; nope
   1615 0000E840 E2 F1                   	lw      r1,2[sp]    ; get varname
   1616 0000E842 81 31                   	shl     r1,#1       ; shift left by eight
   1617 0000E844 81 31                   	shl     r1,#1       ; shift left by eight
   1618 0000E846 81 31                   	shl     r1,#1       ; shift left by eight
   1619 0000E848 81 31                   	shl     r1,#1       ; shift left by eight
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 28
noc_boot.a
   1620 0000E84A 81 31                   	shl     r1,#1       ; shift left by eight
   1621 0000E84C 81 31                   	shl     r1,#1       ; shift left by eight
   1622 0000E84E 81 31                   	shl     r1,#1       ; shift left by eight
   1623 0000E850 81 31                   	shl     r1,#1       ; shift left by eight
   1624 0000E852 80 E2                   	lb      r2,[r8]
   1625 0000E854 26 21                   	or      r1,r2       ; add in new char
   1626 0000E856 E2 D1                       sw      r1,2[sp]   ; save off name again
   1627 0000E858 FF 65                       sub		r5,r5,#1
   1628 0000E85A EE B9                       bne     gvn4
                                        
                                            ; now ignore extra variable name characters
   1631 0000E85C                        gvn6
   1632 0000E85C 01 68                       add     r8,r8,#1
   1633 0000E85E 80 E1                       lb      r1,[r8]
   1634 0000E860 12 BF                       call    isAlnum
   1635 0000E862 FC B9                       bne     gvn6        ; keep looping as long as we have identifier chars
                                            
   1637 0000E864                        gvn2
   1638 0000E864 80 E1                   	lb		r1,[r8]
   1639 0000E866 FD 4F 1B 10                 cmp     r1,#'%'
   1640 0000E86A 05 A8                       beq     gvn3
   1641 0000E86C FD 4F 1C 10                 cmp     r1,#'$'
   1642 0000E870 02 A8                       beq     gvn3
   1643 0000E872 00 11                       lw      r1,#0
   1644 0000E874 FF 68                       sub     r8,r8,#1
                                        
                                            ; insert variable type indicator and return
   1647 0000E876                        gvn3
   1648 0000E876 01 68                       add     r8,r8,#1
   1649 0000E878 E2 F2                       lw      r2,2[sp]
   1650 0000E87A 81 32                       shl     r2,#1
   1651 0000E87C 81 32                       shl     r2,#1
   1652 0000E87E 81 32                       shl     r2,#1
   1653 0000E880 81 32                       shl     r2,#1
   1654 0000E882 81 32                       shl     r2,#1
   1655 0000E884 81 32                       shl     r2,#1
   1656 0000E886 81 32                       shl     r2,#1
   1657 0000E888 81 32                       shl     r2,#1
   1658 0000E88A 26 21                       or      r1,r2       ; add in variable type
   1659 0000E88C E0 FF                       lw      lr,[sp]
   1660 0000E88E E4 F5                       lw		r5,4[sp]
   1661 0000E890 06 6E                       add     sp,sp,#6   ; return Z = 0, r1 = varname
   1662 0000E892 F0 80                       ret
                                        
                                            ; not a variable name
   1665 0000E894                        gvn1
   1666 0000E894 E0 FF                       lw      lr,[sp]
   1667 0000E896 E4 F5                       lw		r5,4[sp]
   1668 0000E898 06 6E                       add     sp,sp,#6
   1669 0000E89A 00 11                       lw      r1,#0       ; return Z = 1 if not a varname
   1670 0000E89C F0 80                       ret
                                        
                                        
                                        ; Find variable
                                        ;   r1 = varname
                                        ;	r2 = allocate flag
                                        ; Returns
                                        ;   r1 = variable address, Z =0 if found / allocated, Z=1 if not found
                                        
   1679 0000E89E                        findVar
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 29
noc_boot.a
   1680 0000E89E FC 6E                       sub     sp,sp,#4
   1681 0000E8A0 E0 DF                       sw      lr,[sp]
   1682 0000E8A2 E2 D7                       sw      r7,2[sp]
   1683 0000E8A4 09 40 08 F3                 lw      r3,VARBGN
   1684 0000E8A8                        fv4
   1685 0000E8A8 30 F7                       lw      r7,[r3]     ; get varname / type
   1686 0000E8AA 0A A8                       beq     fv3         ; no more vars ?
   1687 0000E8AC 7D 21                       cmp     r1,r7       ; match ?
   1688 0000E8AE 0B A8                       beq     fv1
   1689 0000E8B0 08 63                       add     r3,r3,#8    ; move to next var
   1690 0000E8B2 0A 40 00 F7                 lw      r7,STKBOT
   1691 0000E8B6 7D 23                       cmp     r3,r7
   1692 0000E8B8 F7 B0                       blt     fv4         ; loop back to look at next var
                                        
                                            ; variable not found
                                            ; no more memory
   1696 0000E8BA 12 4F 08 11                 lea     r1,msgVarSpace
   1697 0000E8BE EF AE                       br      ERROR
                                        ;    lw      lr,[sp]
                                        ;    lw      r7,2[sp]
                                        ;    add     sp,sp,#4
                                        ;    lw      r1,#0
                                        ;    ret
                                        
                                            ; variable not found
                                            ; allocate new ?
   1706 0000E8C0                        fv3
   1707 0000E8C0 26 22                   	or		r2,r2
   1708 0000E8C2 06 A8                   	beq		fv2
   1709 0000E8C4 30 D1                       sw      r1,[r3]     ; save varname / type
                                            ; found variable
                                            ; return address
   1712 0000E8C6                        fv1
   1713 0000E8C6 34 11                       add     r1,r3,#4
   1714 0000E8C8 E0 FF                       lw      lr,[sp]
   1715 0000E8CA E2 F7                       lw      r7,2[sp]
   1716 0000E8CC 04 6E                       add     sp,sp,#4    ; Z = 0, r1 = address
   1717 0000E8CE F0 80                       ret
                                        
                                            ; didn't find var and not allocating
   1720 0000E8D0                        fv2
   1721 0000E8D0 E0 FF                       lw      lr,[sp]
   1722 0000E8D2 E2 F7                       lw      r7,2[sp]
   1723 0000E8D4 04 6E                       add     sp,sp,#4    ; Z = 0, r1 = address
   1724 0000E8D6 00 11                   	lw		r1,#0		; Z = 1, r1 = 0
   1725 0000E8D8 F0 80                       ret
                                        
                                        
                                        ; ===== Multiplies the 32 bit values in r1 and r2, returning
                                        ;	the 32 bit result in r1.
                                        ;
                                        
   1732 0000E8DA                        MULT32
   1733 0000E8DA FA 6E                   	sub		sp,sp,#6
   1734 0000E8DC E0 D5                   	sw		r5,[sp]		; w
   1735 0000E8DE E2 D6                   	sw		r6,2[sp]	; s
   1736 0000E8E0 E4 D7                   	sw		r7,4[sp]
                                        
   1738 0000E8E2 00 15                   	lw		r5,#0		; w = 0;
   1739 0000E8E4 10 16                   	lw		r6,r1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 30
noc_boot.a
   1740 0000E8E6 24 26                   	xor		r6,r2		; s = a ^ b
   1741 0000E8E8 16 21                   	or		r1,r1
   1742 0000E8EA 01 AB                   	bpl		mult1
   1743 0000E8EC 20 31                   	neg		r1
   1744 0000E8EE                        mult1
   1745 0000E8EE 26 22                   	or		r2,r2
   1746 0000E8F0 01 AB                   	bpl		mult2
   1747 0000E8F2 20 32                   	neg		r2
   1748 0000E8F4                        mult2
   1749 0000E8F4 10 17                   	lw		r7,r1
   1750 0000E8F6 51 37                   	and		r7,#1
   1751 0000E8F8 01 A8                   	beq		mult3
   1752 0000E8FA 20 25                   	add		r5,r2		; w += b
   1753 0000E8FC                        mult3
   1754 0000E8FC 81 32                   	shl		r2,#1		; b <<= 1
   1755 0000E8FE A1 31                   	shr		r1,#1		; a >>= 1
   1756 0000E900 F9 B9                   	bne		mult2       ; a = 0 ?
   1757 0000E902                        mult4
   1758 0000E902 66 26                       or      r6,r6
   1759 0000E904 01 AB                   	bpl		mult5
   1760 0000E906 20 35                   	neg		r5
   1761 0000E908                        mult5
   1762 0000E908 50 11                   	lw		r1,r5
   1763 0000E90A E4 F7                   	lw		r7,4[sp]
   1764 0000E90C E2 F6                   	lw		r6,2[sp]
   1765 0000E90E E0 F5                   	lw		r5,[sp]
   1766 0000E910 06 6E                   	add		sp,sp,#6
   1767 0000E912 F0 80                   	ret
                                        
                                        
                                        ; ===== Divide the 32 bit value in r2 by the 32 bit value in r3.
                                        ;	Returns the 32 bit quotient in r1, remainder in r2
                                        ;
                                        ; r2 = a
                                        ; r3 = b
                                        ; r6 = remainder
                                        ; r7 = iteration count
                                        ; r8 = sign
                                        ;
                                        
                                        ; q = a / b
                                        ; a = r1
                                        ; b = r2
                                        ; q = r2
                                        
   1785 0000E914                        DIV32
   1786 0000E914 26 22                       or      r2,r2       ; check for divide-by-zero
   1787 0000E916 03 A9                       bne		div6
   1788 0000E918 11 4F 05 11                 lea		r1,msgDivZero
   1789 0000E91C C0 AE                       br		ERROR		; divide by zero error
   1790 0000E91E                        div6
   1791 0000E91E FA 6E                   	sub		sp,sp,#6
   1792 0000E920 E0 D6                   	sw		r6,[sp]
   1793 0000E922 E2 D7                   	sw		r7,2[sp]
   1794 0000E924 E4 D8                   	sw		r8,4[sp]
                                        
   1796 0000E926 02 40 00 18                 lw      r8,#32      ; iteration count for 32 bits
   1797 0000E92A 00 16                   	lw		r6,#0		; r = 0
   1798 0000E92C 20 17                       lw      r7,r2       ; r7 = sign of result
   1799 0000E92E 14 27                       xor     r7,r1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 31
noc_boot.a
   1800 0000E930 16 21                   	or	    r1,r1	    ; take absolute value of r1 (a)
   1801 0000E932 01 AB                   	bpl     div1
   1802 0000E934 20 31                   	neg     r1
   1803 0000E936                        div1
   1804 0000E936 26 22                       or      r2,r2	    ; take absolute value of r2 (b)
   1805 0000E938 01 AB                   	bpl	    div2
   1806 0000E93A 20 32                   	neg     r2
   1807 0000E93C                        div2
   1808 0000E93C 81 31                   	shl		r1,#1		; a <<= 1
   1809 0000E93E 61 26                   	adc		r6,r6		; r <<= 1
   1810 0000E940 6D 22                   	cmp		r2,r6		; b < r ?
   1811 0000E942 02 A7                   	bgtu	div4
   1812 0000E944 22 26                   	sub		r6,r2		; r -= b
   1813 0000E946 61 31                   	or      r1,#1       ; a |= 1
   1814 0000E948                        div4
   1815 0000E948 FF 68                   	sub		r8,r8,#1
   1816 0000E94A F8 B9                       bne     div2        ; n--
   1817 0000E94C 76 27                   	or      r7,r7
   1818 0000E94E 01 AB                   	bpl     div5
   1819 0000E950 20 31                   	neg     r1
   1820 0000E952                        div5
   1821 0000E952 60 12                   	lw		r2,r6		; r2 = r
   1822 0000E954 E2 F7                   	lw		r7,2[sp]
   1823 0000E956 E4 F8                   	lw		r8,4[sp]
   1824 0000E958 E0 F6                   	lw		r6,[sp]
   1825 0000E95A 06 6E                   	add		sp,sp,#6
   1826 0000E95C F0 80                   	ret
                                        
                                        ; ===== The PEEK function returns the byte stored at the address
                                        ;	contained in the following expression.
                                        ;
   1831 0000E95E                        PEEK
   1832 0000E95E 29 BF                   	call	PARN		; get the memory address
   1833 0000E960 10 E1                   	lb		r1,[r1]		; get the addressed byte
   1834 0000E962 0E 21                   	zxb		r1			; upper 3 bytes will be zero
   1835 0000E964 E0 FF                   	lw		lr,[sp]	; and return it
   1836 0000E966 06 6E                   	add		sp,sp,#6
   1837 0000E968 F0 80                   	ret
                                        
                                        
                                        ; ===== The PEEK function returns the byte stored at the address
                                        ;	contained in the following expression.
                                        ;
   1843 0000E96A                        PEEKW
   1844 0000E96A 23 BF                   	call	PARN		; get the memory address
   1845 0000E96C 5E 31                   	and		r1,#-2		; align to word address
   1846 0000E96E 10 F1                   	lw		r1,[r1]		; get the addressed word
   1847 0000E970 E0 FF                   	lw		lr,[sp]	; and return it
   1848 0000E972 06 6E                   	add		sp,sp,#6
   1849 0000E974 F0 80                   	ret
                                        
                                        
                                        ; user function call
                                        ; call the user function with argument in r1
   1854 0000E976                        USRX
   1855 0000E976 1D BF                   	call	PARN		; get expression value
   1856 0000E978 E2 D8                   	sw		r8,2[sp]	; save the text pointer
   1857 0000E97A 02 40 04 F2             	lw      r2,usrJmp   ; get usr vector
   1858 0000E97E B3 48 0F AF             	call	[r2]		; jump to the subroutine
   1859 0000E982 E2 F8                   	lw		r8,2[sp]	; restore the text pointer
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 32
noc_boot.a
   1860 0000E984 E0 FF                   	lw		lr,[sp]
   1861 0000E986 06 6E                   	add		sp,sp,#6
   1862 0000E988 F0 80                   	ret
                                        
                                        
                                        ; ===== The RND function returns a random number from 1 to
                                        ;	the value of the following expression in D0.
                                        ;
   1868 0000E98A                        RND
   1869 0000E98A 13 BF                   	call	PARN		; get the upper limit
   1870 0000E98C 16 21                   	or		r1,r1		; it must be positive and non-zero
   1871 0000E98E 0E A8                   	beq		rnd2
   1872 0000E990 0A AA                   	bmi		rnd1
   1873 0000E992 10 12                   	lw		r2,r1
   1874 0000E994 CA 4D 04 D0             	sh		r0,RAND+4	; read command
   1875 0000E998 CA 4D 00 F1             	lw		r1,RAND		; get a number
   1876 0000E99C 0E AF                   	call	modu4		; RND(n)=MOD(number,n)+1
   1877 0000E99E 01 61                   	add		r1,r1,#1
   1878 0000E9A0 E0 FF                   	lw		lr,[sp]
   1879 0000E9A2 06 6E                   	add		sp,sp,#6
   1880 0000E9A4 F0 80                   	ret
   1881 0000E9A6                        rnd1
   1882 0000E9A6 19 4F 09 11             	lea		r1,msgRNDBad
   1883 0000E9AA 79 AE                   	br		ERROR
   1884 0000E9AC                        rnd2
   1885 0000E9AC CA 4D 04 D0             	sh		r0,RAND+4
   1886 0000E9B0 CA 4D 00 F1             	lw		r1,RAND
   1887 0000E9B4 E0 FF                   	lw		lr,[sp]
   1888 0000E9B6 06 6E                   	add		sp,sp,#6
   1889 0000E9B8 F0 80                   	ret
                                        
                                        
                                        ; r = a mod b
                                        ; a = r2
                                        ; b = r3
                                        ; r = r1
   1896 0000E9BA                        modu4
   1897 0000E9BA FA 6E                   	sub		sp,sp,#6
   1898 0000E9BC E0 D5                   	sw		r5,[sp]
   1899 0000E9BE E2 D6                   	sw		r6,2[sp]
   1900 0000E9C0 E4 D7                   	sw		r7,4[sp]
   1901 0000E9C2 02 40 00 17             	lw      r7,#32		; n = 32
   1902 0000E9C6 00 15                   	lw		r5,#0		; w = 0
   1903 0000E9C8 00 16                   	lw		r6,#0		; r = 0
   1904 0000E9CA                        mod2
   1905 0000E9CA 81 31                   	shl		r1,#1		; a <<= 1
   1906 0000E9CC 61 26                   	adc		r6,r6		; r <<= 1
   1907 0000E9CE 6D 22                   	cmp		r2,r6		; b < r ?
   1908 0000E9D0 01 A7                   	bgtu	mod1
   1909 0000E9D2 22 26                   	sub		r6,r2		; r -= b
   1910 0000E9D4                        mod1
   1911 0000E9D4 FF 67                   	sub		r7,r7,#1
   1912 0000E9D6 F9 B9                       bne     mod2        ; n--
   1913 0000E9D8 60 11                   	lw		r1,r6
   1914 0000E9DA E0 F5                   	lw		r5,[sp]
   1915 0000E9DC E2 F6                   	lw		r6,2[sp]
   1916 0000E9DE E4 F7                   	lw		r7,4[sp]
   1917 0000E9E0 06 6E                   	add		sp,sp,#6
   1918 0000E9E2 F0 80                   	ret
                                        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 33
noc_boot.a
                                        
                                        
                                        ; ===== The ABS function returns an absolute value in r2.
                                        ;
   1924 0000E9E4                        ABS
   1925 0000E9E4 EE 4F 05 AF             	call	PARN		; get the following expr.'s value
   1926 0000E9E8 16 21                   	or		r1,r1
   1927 0000E9EA 01 AB                   	bpl		abs1
   1928 0000E9EC 20 31                   	neg		r1			; if negative, complement it
                                        ;	bmi		QHOW		; if still negative, it was too big
   1930 0000E9EE                        abs1
   1931 0000E9EE E0 FF                   	lw		lr,[sp]
   1932 0000E9F0 06 6E                   	add		sp,sp,#6
   1933 0000E9F2 F0 80                   	ret
                                        
                                        
                                        ; ===== The SGN function returns the sign in r1. +1,0, or -1
                                        ;
   1938 0000E9F4                        SGN
   1939 0000E9F4 ED 4F 0D AF             	call	PARN		; get the following expr.'s value
   1940 0000E9F8 16 21                   	or		r1,r1
   1941 0000E9FA 04 A8                   	beq		sgn1
   1942 0000E9FC 02 AB                   	bpl		sgn2
   1943 0000E9FE 0F 11                   	lw		r1,#-1
   1944 0000EA00 01 AE                   	br		sgn1
   1945 0000EA02                        sgn2
   1946 0000EA02 01 11                   	lw		r1,#1
   1947 0000EA04                        sgn1
   1948 0000EA04 E0 FF                   	lw		lr,[sp]
   1949 0000EA06 06 6E                   	add		sp,sp,#6
   1950 0000EA08 F0 80                   	ret
                                        
                                        
                                        ; ===== The SIZE function returns the size of free memory in r1.
                                        ;
   1955 0000EA0A                        SIZEX
   1956 0000EA0A 09 40 08 F1             	lw		r1,VARBGN	; get the number of free bytes...
   1957 0000EA0E 09 40 06 F2             	lw		r2,TXTUNF	; between 'TXTUNF' and 'VARBGN'
   1958 0000EA12 22 21                   	sub		r1,r2
   1959 0000EA14 E0 FF                   	lw		lr,[sp]
   1960 0000EA16 06 6E                   	add		sp,sp,#6
   1961 0000EA18 F0 80                   	ret					; return the number in r2
                                        
                                        ; ==== Return the node number that the code is running on
                                        ;
   1965 0000EA1A                        NODENUM
   1966 0000EA1A E4 31                   	tsr		r1,ID
   1967 0000EA1C E0 FF                   	lw		lr,[sp]
   1968 0000EA1E 06 6E                   	add		sp,sp,#6
   1969 0000EA20 F0 80                   	ret
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                                        ;
                                        ; 'SETVAL' expects a variable, followed by an equal sign and then
                                        ; an expression.  It evaluates the expression and sets the variable
                                        ; to that value.
                                        ;
                                        ; 'FIN' checks the end of a command.  If it ended with ":",
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 34
noc_boot.a
                                        ; execution continues.	If it ended with a CR, it finds the
                                        ; the next line and continues from there.
                                        ;
                                        ; 'ENDCHK' checks if a command is ended with a CR. This is
                                        ; required in certain commands, such as GOTO, RETURN, STOP, etc.
                                        ;
                                        ; 'ERROR' prints the string pointed to by A0. It then prints the
                                        ; line pointed to by CURRNT with a "?" inserted at where the
                                        ; old text pointer (should be on top of the stack) points to.
                                        ; Execution of Tiny BASIC is stopped and a warm start is done.
                                        ; If CURRNT is zero (indicating a direct command), the direct
                                        ; command is not printed. If CURRNT is -1 (indicating
                                        ; 'INPUT' command in progress), the input line is not printed
                                        ; and execution is not terminated but continues at 'INPERR'.
                                        ;
                                        ; Related to 'ERROR' are the following:
                                        ; 'QWHAT' saves text pointer on stack and gets "What?" message.
                                        ; 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                                        ; 'QSORRY' and 'ASORRY' do the same kind of thing.
                                        ; 'QHOW' and 'AHOW' also do this for "How?".
                                        ;
                                        
                                        ; returns
                                        ; r2 = variable's address
                                        ;
   2005 0000EA22                        SETVAL
   2006 0000EA22 FC 6E                       sub     sp,sp,#4
   2007 0000EA24 E0 DF                       sw      lr,[sp]
   2008 0000EA26 01 11                       lw		r1,#1		; allocate var
   2009 0000EA28 ED 4F 03 AF                 call	TSTV		; variable name?
   2010 0000EA2C 03 A9                       bne		sv2
   2011 0000EA2E 18 4F 02 11                	lea		r1,msgVar
   2012 0000EA32 35 AE                      	br		ERROR 
   2013 0000EA34                        sv2
   2014 0000EA34 E2 D1                   	sw      r1,2[sp]    ; save the variable's address
   2015 0000EA36 1D 40 06 AF             	call	TSTC		; get past the "=" sign
   2016 0000EA3A 3D 12                   	db	'=',SV1-*+1
   2017 0000EA3C DE 4F 05 AF             	call	OREXPR		; evaluate the expression
   2018 0000EA40 E2 F2                   	lw      r2,2[sp]    ; get back the variable's address
   2019 0000EA42 20 D1                   	sw      r1,[r2]     ; and save value in the variable
   2020 0000EA44 20 11                   	lw		r1,r2		; return r1 = variable address
   2021 0000EA46 E0 FF                   	lw      lr,[sp]
   2022 0000EA48 04 6E                   	add     sp,sp,#4
   2023 0000EA4A F0 80                   	ret
   2024 0000EA4C                        SV1
   2025 0000EA4C 26 AE                       br	    QWHAT		; if no "=" sign
                                        
                                        
   2028 0000EA4E                        FIN
   2029 0000EA4E FE 6E                   	sub		sp,sp,#2
   2030 0000EA50 E0 DF                   	sw		lr,[sp]
   2031 0000EA52 1C 40 08 AF             	call	TSTC		; *** FIN ***
   2032 0000EA56 3A 08                   	db	':',FI1-*+1
   2033 0000EA58 02 6E                   	add		sp,sp,#2	; if ":", discard return address
   2034 0000EA5A BF 4F 0B AE             	br		RUNSML		; continue on the same line
   2035 0000EA5E                        FI1
   2036 0000EA5E 1C 40 02 AF             	call	TSTC		; not ":", is it a CR?
   2037 0000EA62 0D 0A                   	db	CR,FI2-*+1
   2038 0000EA64 E0 FF                   	lw		lr,[sp]	; else return to the caller
   2039 0000EA66 02 6E                   	add		sp,sp,#2	; yes, purge return address
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 35
noc_boot.a
   2040 0000EA68 BE 4F 09 AE             	br		RUNNXL		; execute the next line
   2041 0000EA6C                        FI2
   2042 0000EA6C E0 FF                   	lw		lr,[sp]	; else return to the caller
   2043 0000EA6E 02 6E                   	add		sp,sp,#2
   2044 0000EA70 F0 80                   	ret
                                        
                                        
                                        ; Check that there is nothing else on the line
                                        ; Registers Affected
                                        ;   r1
                                        ;
   2051 0000EA72                        ENDCHK
   2052 0000EA72 FE 6E                   	sub		sp,sp,#2
   2053 0000EA74 E0 DF                   	sw		lr,[sp]
   2054 0000EA76 1E 40 09 AF             	call	IGNBLK
   2055 0000EA7A 80 E1                   	lb		r1,[r8]
   2056 0000EA7C FF 4F 13 10             	cmp		r1,#CR		; does it end with a CR?
   2057 0000EA80 03 A8                   	beq		ec1
   2058 0000EA82 25 4F 0C 11             	lea		r1,msgExtraChars
   2059 0000EA86 0B AE                   	jmp		ERROR
   2060 0000EA88                        ec1
   2061 0000EA88 E0 FF                   	lw		lr,[sp]
   2062 0000EA8A 02 6E                   	add		sp,sp,#2
   2063 0000EA8C F0 80                   	ret
                                        
                                        
   2066 0000EA8E                        TOOBIG
   2067 0000EA8E 24 4F 07 11             	lea		r1,msgTooBig
   2068 0000EA92 05 AE                   	br		ERROR
   2069 0000EA94                        QSORRY
   2070 0000EA94 0D 4F 0D 11                 lea     r1,SRYMSG
   2071 0000EA98 02 AE                   	br	    ERROR
   2072 0000EA9A                        QWHAT
   2073 0000EA9A 0D 4F 05 11             	lea		r1,msgWhat
   2074 0000EA9E                        ERROR
   2075 0000EA9E 21 40 0D AF             	call	PRMESG		; display the error message
   2076 0000EAA2 08 40 06 F1             	lw		r1,CURRNT	; get the current line number
   2077 0000EAA6 B0 4F 0A A8             	beq		WSTART		; if zero, do a warm start
   2078 0000EAAA 11 10                   	cmp		r1,#-1		; is the line no. pointer = -1?
   2079 0000EAAC CD 4F 08 A8             	beq		INPERR		; if so, redo input
   2080 0000EAB0 80 E5                   	lb		r5,[r8]		; save the char. pointed to
   2081 0000EAB2 80 C0                   	sb		r0,[r8]		; put a zero where the error is
   2082 0000EAB4 08 40 06 F1             	lw		r1,CURRNT	; point to start of current line
   2083 0000EAB8 17 40 07 AF             	call	PRTLN		; display the line in error up to the 0
   2084 0000EABC 10 16                   	lw      r6,r1       ; save off end pointer
   2085 0000EABE 80 C5                   	sb		r5,[r8]		; restore the character
   2086 0000EAC0 03 40 0F 11             	lw		r1,#'?'		; display a "?"
   2087 0000EAC4 AD 4F 05 AF             	call	GOOUT
   2088 0000EAC8 00 12                   	lw      r2,#0       ; stop char = 0
   2089 0000EACA 6F 11                   	sub		r1,r6,#1	; point back to the error char.
   2090 0000EACC B6 AF                   	call	PRTSTG		; display the rest of the line
   2091 0000EACE AF 4F 06 AE             	jmp	    WSTART		; and do a warm start
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** GETLN *** FNDLN (& friends) ***
                                        ;
                                        ; 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                                        ; the character in r3 (given by the caller), then it fills the
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 36
noc_boot.a
                                        ; buffer and echos. It ignores LF's but still echos
                                        ; them back. Control-H is used to delete the last character
                                        ; entered (if there is one), and control-X is used to delete the
                                        ; whole line and start over again. CR signals the end of a line,
                                        ; and causes 'GETLN' to return.
                                        ;
                                        ;
   2107 0000EAD2                        GETLN
   2108 0000EAD2 FC 6E                   	sub		sp,sp,#4
   2109 0000EAD4 E0 DF                   	sw		lr,[sp]
   2110 0000EAD6 E2 D5                   	sw		r5,2[sp]
   2111 0000EAD8 AC 4F 0B AF             	call	GOOUT		; display the prompt
   2112 0000EADC 01 11                   	lw		r1,#1		; turn on cursor flash
   2113 0000EADE 03 40 0C C1             	sb		r1,cursFlash
   2114 0000EAE2 02 40 00 11             	lw		r1,#' '		; and a space
   2115 0000EAE6 AC 4F 04 AF             	call	GOOUT
   2116 0000EAEA 0A 40 0E 18             	lea		r8,BUFFER	; r8 is the buffer pointer
   2117 0000EAEE                        GL1
   2118 0000EAEE 1E 40 03 AF             	call	CHKIO		; check keyboard
   2119 0000EAF2 FD B8                   	beq		GL1			; wait for a char. to come in
   2120 0000EAF4 FF 4F 18 10             	cmp		r1,#CTRLH	; delete last character?
   2121 0000EAF8 14 A8                   	beq		GL3			; if so
   2122 0000EAFA FE 4F 18 10             	cmp		r1,#CTRLX	; delete the whole line?
   2123 0000EAFE 20 A8                   	beq		GL4			; if so
   2124 0000EB00 FF 4F 13 10             	cmp		r1,#CR		; accept a CR
   2125 0000EB04 03 A8                   	beq		GL2
   2126 0000EB06 FE 4F 10 10             	cmp		r1,#' '		; if other control char., discard it
   2127 0000EB0A F1 B4                   	bltu	GL1
   2128 0000EB0C                        GL2
   2129 0000EB0C 80 C1                   	sb		r1,[r8]		; save the char.
   2130 0000EB0E 01 68                   	add		r8,r8,#1
   2131 0000EB10 AA 4F 0F AF             	call	GOOUT		; echo the char back out
   2132 0000EB14 8F E1                   	lb      r1,-1[r8]   ; get char back (GOOUT destroys r1)
   2133 0000EB16 FF 4F 13 10             	cmp		r1,#CR		; if it's a CR, end the line
   2134 0000EB1A 25 A8                   	beq		GL7
   2135 0000EB1C F0 4F 83 10             	cmp		r8,#(BUFFER+BUFLEN-1)	; any more room?
   2136 0000EB20 E6 B4                   	bltu	GL1			; yes: get some more, else delete last char.
                                        
   2138 0000EB22                        GL3
   2139 0000EB22 08 11                   	lw		r1,#CTRLH	; delete a char. if possible
   2140 0000EB24 AA 4F 05 AF             	call	GOOUT
   2141 0000EB28 02 40 00 11             	lw		r1,#' '
   2142 0000EB2C AA 4F 01 AF             	call	GOOUT
   2143 0000EB30 F5 4F 82 10             	cmp		r8,#BUFFER	; any char.'s left?
   2144 0000EB34 DC B6                   	bleu	GL1			; if not
   2145 0000EB36 08 11                   	lw		r1,#CTRLH	; if so, finish the BS-space-BS sequence
   2146 0000EB38 A9 4F 0B AF             	call	GOOUT
   2147 0000EB3C FF 68                   	sub		r8,r8,#1	; decrement the text pointer
   2148 0000EB3E D7 BE                   	br		GL1			; back for more
                                        
   2150 0000EB40                        GL4
   2151 0000EB40 80 11                   	lw		r1,r8		; delete the whole line
   2152 0000EB42 F5 4F 12 15             	sub		r5,r1,#BUFFER   ; figure out how many backspaces we need
   2153 0000EB46 0C A8                   	beq		GL6			; if none needed, brnch
   2154 0000EB48                        GL5	
   2155 0000EB48 08 11                   	lw		r1,#CTRLH	; and display BS-space-BS sequences
   2156 0000EB4A A9 4F 02 AF             	call	GOOUT
   2157 0000EB4E 02 40 00 11             	lw		r1,#' '
   2158 0000EB52 A8 4F 0E AF             	call	GOOUT
   2159 0000EB56 08 11                   	lw		r1,#CTRLH
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 37
noc_boot.a
   2160 0000EB58 A8 4F 0B AF             	call	GOOUT
   2161 0000EB5C FF 65                   	sub		r5,r5,#1
   2162 0000EB5E F4 B9                   	bne     GL5
   2163 0000EB60                        GL6
   2164 0000EB60 0A 40 0E 18             	lea		r8,BUFFER	; reinitialize the text pointer
   2165 0000EB64 C4 BE                   	br		GL1			; and go back for more
   2166 0000EB66                        GL7
   2167 0000EB66 00 11                   	lw		r1,#0		; turn off cursor flash
   2168 0000EB68 03 40 0C C1             	sb		r1,cursFlash
   2169 0000EB6C 0A 11                   	lw		r1,#LF		; echo a LF for the CR
   2170 0000EB6E A8 4F 00 AF             	call	GOOUT
   2171 0000EB72 E0 FF                   	lw		lr,[sp]
   2172 0000EB74 E2 F5                   	lw		r5,2[sp]
   2173 0000EB76 04 6E                   	add		sp,sp,#4
   2174 0000EB78 F0 80                   	ret
                                        
                                        
                                        ; 'FNDLN' finds a line with a given line no. (in r1) in the
                                        ; text save area.  r9 is used as the text pointer. If the line
                                        ; is found, r9 will point to the beginning of that line
                                        ; (i.e. the high byte of the line no.), and flags are Z.
                                        ; If that line is not there and a line with a higher line no.
                                        ; is found, r9 points there and flags are NC & NZ. If we reached
                                        ; the end of the text save area and cannot find the line, flags
                                        ; are C & NZ.
                                        ; Z=1 if line found
                                        ; N=1 if end of text save area
                                        ; Z=0 & N=0 if higher line found
                                        ;
                                        ; 'FNDLN' will initialize r9 to the beginning of the text save
                                        ; area to start the search. Some other entries of this routine
                                        ; will not initialize r9 and do the search.
                                        ; 'FNDLNP' will start with r9 and search for the line no.
                                        ; 'FNDNXT' will bump r9 by 2, find a CR and then start search.
                                        ; 'FNDSKP' uses r9 to find a CR, and then starts the search.
                                        ; return Z=1 if line is found, r9 = pointer to line
                                        ;
                                        ; Parameters
                                        ;	r1 = line number to find
                                        ;
   2200 0000EB7A                        FNDLN
   2201 0000EB7A 00 40 11 10             	cmp		r1,#0xFFFF	; line no. must be < 65535
   2202 0000EB7E 03 A6                   	bleu	fl1
   2203 0000EB80 16 4F 0C 11             	lea		r1,msgLineRange
   2204 0000EB84 8C BE                   	br		ERROR
   2205 0000EB86                        fl1
   2206 0000EB86 08 4E 06 F9             	lw		r9,TXTBGN	; init. the text save pointer
                                        
   2208 0000EB8A                        FNDLNP
   2209 0000EB8A 09 40 06 FA             	lw		r10,TXTUNF	; check if we passed the end
   2210 0000EB8E FF 6A                   	sub		r10,r10,#1
   2211 0000EB90 AD 29                   	cmp		r9,r10
   2212 0000EB92 0F A7                   	bgtu	FNDRET		; if so, return with Z=0 & C=1
   2213 0000EB94 90 E3                   	lb		r3,[r9]		; get low order byte of line number
   2214 0000EB96 0E 23                   	zxb		r3
   2215 0000EB98 91 E2                   	lb		r2,1[r9]	; get high order byte
   2216 0000EB9A 0E 22                   	zxb		r2
   2217 0000EB9C 81 32                   	shl		r2,#1
   2218 0000EB9E 81 32                   	shl		r2,#1
   2219 0000EBA0 81 32                   	shl		r2,#1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 38
noc_boot.a
   2220 0000EBA2 81 32                   	shl		r2,#1
   2221 0000EBA4 81 32                   	shl		r2,#1
   2222 0000EBA6 81 32                   	shl		r2,#1
   2223 0000EBA8 81 32                   	shl		r2,#1
   2224 0000EBAA 81 32                   	shl		r2,#1
   2225 0000EBAC 36 22                   	or		r2,r3		; build whole line number
   2226 0000EBAE 2D 21                   	cmp		r1,r2		; is this the line we want?
   2227 0000EBB0 01 A7                   	bgtu	FNDNXT		; no, not there yet
   2228 0000EBB2                        FNDRET
   2229 0000EBB2 F0 80                   	ret			; return the cond. codes
                                        
   2231 0000EBB4                        FNDNXT
   2232 0000EBB4 02 69                   	add		r9,r9,#2	; find the next line
                                        
   2234 0000EBB6                        FNDSKP
   2235 0000EBB6 90 E2                   	lb		r2,[r9]
   2236 0000EBB8 01 69                   	add		r9,r9,#1
   2237 0000EBBA FF 4F 23 10             	cmp		r2,#CR		; try to find a CR
   2238 0000EBBE FB B9                   	bne		FNDSKP		; keep looking
   2239 0000EBC0 E4 BE                   	br		FNDLNP		; check if end of text
                                        
                                        
                                        ;******************************************************************
                                        ; 'MVUP' moves a block up from where r1 points to where r2 points
                                        ; until r1=r3
                                        ;
   2246 0000EBC2                        MVUP1
   2247 0000EBC2 10 E4                   	lb		r4,[r1]
   2248 0000EBC4 20 C4                   	sb		r4,[r2]
   2249 0000EBC6 01 61                   	add		r1,r1,#1
   2250 0000EBC8 01 62                   	add		r2,r2,#1
   2251 0000EBCA                        MVUP
   2252 0000EBCA 3D 21                   	cmp		r1,r3
   2253 0000EBCC FA B9                   	bne		MVUP1
   2254 0000EBCE                        MVRET
   2255 0000EBCE F0 80                   	ret
                                        
                                        
                                        ; 'MVDOWN' moves a block down from where r1 points to where r2
                                        ; points until r1=r3
                                        ;
   2261 0000EBD0                        MVDOWN1
   2262 0000EBD0 FF 61                   	sub		r1,r1,#1
   2263 0000EBD2 FF 62                   	sub		r2,r2,#1
   2264 0000EBD4 10 E4                   	lb		r4,[r1]
   2265 0000EBD6 20 C4                   	sb		r4,[r2]
   2266 0000EBD8                        MVDOWN
   2267 0000EBD8 3D 21                   	cmp		r1,r3
   2268 0000EBDA FA B9                   	bne		MVDOWN1
   2269 0000EBDC F0 80                   	ret
                                        
                                        
                                        ; 'POPA' restores the 'FOR' loop variable save area from the stack
                                        ;
                                        ; 'PUSHA' stacks for 'FOR' loop variable save area onto the stack
                                        ;
                                        ; Note: a single zero word is stored on the stack in the
                                        ; case that no FOR loops need to be saved. This needs to be
                                        ; done because PUSHA / POPA is called all the time.
                                        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 39
noc_boot.a
   2280 0000EBDE                        POPA
   2281 0000EBDE E0 F1                   	lw		r1,[sp]		; restore LOPVAR, but zero means no more
   2282 0000EBE0 08 40 0C D1             	sw		r1,LOPVAR
   2283 0000EBE4 0E A8                   	beq		PP1
   2284 0000EBE6 E8 F1                   	lw		r1,8[sp]	; if not zero, restore the rest
   2285 0000EBE8 09 40 04 D1             	sw		r1,LOPPT
   2286 0000EBEC E6 F1                   	lw		r1,6[sp]
   2287 0000EBEE 09 40 02 D1             	sw		r1,LOPLN
   2288 0000EBF2 E4 F1                   	lw		r1,4[sp]
   2289 0000EBF4 09 40 00 D1             	sw		r1,LOPLMT
   2290 0000EBF8 E2 F1                   	lw		r1,2[sp]
   2291 0000EBFA 08 40 0E D1             	sw		r1,LOPINC
   2292 0000EBFE 0A 6E                   	add		sp,sp,#10
   2293 0000EC00 F0 80                   	ret
   2294 0000EC02                        PP1
   2295 0000EC02 02 6E                   	add		sp,sp,#2
   2296 0000EC04 F0 80                   	ret
                                        
                                        
   2299 0000EC06                        PUSHA
   2300 0000EC06 0A 40 00 F1             	lw		r1,STKBOT	; Are we running out of stack room?
   2301 0000EC0A 0A 61                   	add		r1,r1,#10	; we might need this many bytes
   2302 0000EC0C 1D 2E                   	cmp		sp,r1
   2303 0000EC0E 42 B4                   	bltu	QSORRY		; out of stack space
   2304 0000EC10 08 40 0C F1             	lw		r1,LOPVAR	; save loop variables
   2305 0000EC14 0F A8                   	beq		PU1			; if LOPVAR is zero, that's all
   2306 0000EC16 F6 6E                   	sub		sp,sp,#10
   2307 0000EC18 E0 D1                   	sw		r1,[sp]
   2308 0000EC1A 09 40 04 F1             	lw		r1,LOPPT
   2309 0000EC1E E8 D1                   	sw		r1,8[sp]	; else save all the others
   2310 0000EC20 09 40 02 F1             	lw		r1,LOPLN
   2311 0000EC24 E6 D1                   	sw		r1,6[sp]
   2312 0000EC26 09 40 00 F1             	lw		r1,LOPLMT
   2313 0000EC2A E4 D1                   	sw		r1,4[sp]
   2314 0000EC2C 08 40 0E F1             	lw		r1,LOPINC
   2315 0000EC30 E2 D1                   	sw		r1,2[sp]
   2316 0000EC32 F0 80                   	ret
   2317 0000EC34                        PU1
   2318 0000EC34 FE 6E                   	sub		sp,sp,#2
   2319 0000EC36 E0 D1                   	sw		r1,[sp]
   2320 0000EC38 F0 80                   	ret
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** PRTSTG *** QTSTG *** PRTNUM *** PRTLN ***
                                        ;
                                        ; 'PRTSTG' prints a string pointed to by r3. It stops printing
                                        ; and returns to the caller when either a CR is printed or when
                                        ; the next byte is the same as what was passed in r4 by the
                                        ; caller.
                                        ;
                                        ; 'QTSTG' looks for an underline (back-arrow on some systems),
                                        ; single-quote, or double-quote.  If none of these are found, returns
                                        ; to the caller.  If underline, outputs a CR without a LF.  If single
                                        ; or double quote, prints the quoted string and demands a matching
                                        ; end quote.  After the printing, the next 2 bytes of the caller are
                                        ; skipped over (usually a short brnch instruction).
                                        ;
                                        ; 'PRTNUM' prints the 32 bit number in r3, leading blanks are added if
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 40
noc_boot.a
                                        ; needed to pad the number of spaces to the number in r4.
                                        ; However, if the number of digits is larger than the no. in
                                        ; r4, all digits are printed anyway. Negative sign is also
                                        ; printed and counted in, positive sign is not.
                                        ;
                                        ; 'PRTLN' prints the saved text line pointed to by r3
                                        ; with line no. and all.
                                        ;
                                        
                                        ; r1 = pointer to string
                                        ; r2 = stop character
                                        ; return r1 = pointer to end of line + 1
                                        
   2353 0000EC3A                        PRTSTG
   2354 0000EC3A F8 6E                       sub     sp,sp,#8
   2355 0000EC3C E0 DF                       sw      lr,[sp]
   2356 0000EC3E E2 D5                       sw      r5,2[sp]
   2357 0000EC40 E4 D6                       sw      r6,4[sp]
   2358 0000EC42 E6 D7                       sw      r7,6[sp]
   2359 0000EC44 10 15                       lw      r5,r1       ; r5 = pointer
   2360 0000EC46 20 16                       lw      r6,r2       ; r6 = stop char
   2361 0000EC48                        PS1
   2362 0000EC48 50 E7                       lb      r7,[r5]     ; get a text character
   2363 0000EC4A 01 65                       add     r5,r5,#1
   2364 0000EC4C 6D 27                   	cmp     r7,r6		; same as stop character?
   2365 0000EC4E 09 A8                   	beq	    PRTRET		; if so, return
   2366 0000EC50 70 11                   	lw      r1,r7
   2367 0000EC52 A0 4F 0E AF             	call	GOOUT		; display the char.
   2368 0000EC56 FF 4F 73 10             	cmp     r7,#CR      ; is it a C.R.?
   2369 0000EC5A F6 B9                   	bne	    PS1		    ; no, go back for more
   2370 0000EC5C 0A 11                   	lw      r1,#LF      ; yes, add a L.F.
   2371 0000EC5E A0 4F 08 AF             	call	GOOUT
   2372 0000EC62                        PRTRET
   2373 0000EC62 70 12                       lw      r2,r7       ; return r2 = stop char
   2374 0000EC64 50 11                   	lw		r1,r5		; return r1 = line pointer
   2375 0000EC66 E2 F5                       lw      r5,2[sp]
   2376 0000EC68 E4 F6                       lw      r6,4[sp]
   2377 0000EC6A E6 F7                       lw      r7,6[sp]
   2378 0000EC6C E0 FF                       lw      lr,[sp]
   2379 0000EC6E 08 6E                       add     sp,sp,#8
   2380 0000EC70 F0 80                       ret			        ; then return
                                        
                                        
   2383 0000EC72                        QTSTG
   2384 0000EC72 FE 6E                   	sub		sp,sp,#2
   2385 0000EC74 E0 DF                   	sw		lr,[sp]
   2386 0000EC76 B7 AF                   	call	TSTC		; *** QTSTG ***
   2387 0000EC78 22 18                   	db	'"',QT3-*+1
   2388 0000EC7A 02 40 02 12             	lw		r2,#'"'		; it is a "
   2389 0000EC7E                        QT1
   2390 0000EC7E 80 11                   	lw		r1,r8
   2391 0000EC80 DC BF                   	call	PRTSTG		; print until another
   2392 0000EC82 10 18                   	lw		r8,r1
   2393 0000EC84 FF 4F 26 10             	cmp		r2,#LF		; was last one a CR?
   2394 0000EC88 0E A9                   	bne		QT2
   2395 0000EC8A 02 6E                   	add		sp,sp,#2
   2396 0000EC8C AD 4F 07 AE             	br		RUNNXL		; if so, run next line
   2397 0000EC90                        QT3
   2398 0000EC90 AA AF                   	call	TSTC		; is it a single quote?
   2399 0000EC92 27 08                   	db	"'",QT4-*+1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 41
noc_boot.a
   2400 0000EC94 02 40 07 12             	lw		r2,#''''	; if so, do same as above
   2401 0000EC98 F2 BE                   	br		QT1
   2402 0000EC9A                        QT4
   2403 0000EC9A A5 AF                   	call	TSTC		; is it an underline?
   2404 0000EC9C 5F 10                   	db	'_',QT5-*+1
   2405 0000EC9E 00 40 0D 11             	lw		r1,#CR		; if so, output a CR without LF
   2406 0000ECA2 9E 4F 06 AF             	call	GOOUT
   2407 0000ECA6                        QT2
   2408 0000ECA6 E0 FF                   	lw		lr,[sp]
   2409 0000ECA8 02 6E                   	add		sp,sp,#2
   2410 0000ECAA F2 80                   	jmp		2[lr]		; skip over 2 bytes when returning
   2411 0000ECAC                        QT5						; not " ' or _
   2412 0000ECAC E0 FF                   	lw		lr,[sp]
   2413 0000ECAE 02 6E                   	add		sp,sp,#2
   2414 0000ECB0 F0 80                   	ret
                                        
                                        
                                        ; Output a CR LF sequence
                                        ;
   2419 0000ECB2                        prCRLF
   2420 0000ECB2 FE 6E                   	sub		sp,sp,#2
   2421 0000ECB4 E0 DF                   	sw		lr,[sp]
   2422 0000ECB6 00 40 0D 11             	lw		r1,#CR
   2423 0000ECBA 9D 4F 0A AF             	call	GOOUT
   2424 0000ECBE 0A 11                   	lw		r1,#LF
   2425 0000ECC0 9D 4F 07 AF             	call	GOOUT
   2426 0000ECC4 E0 FF                   	lw		lr,[sp]
   2427 0000ECC6 02 6E                   	add		sp,sp,#2
   2428 0000ECC8 F0 80                   	ret
                                        
                                        
                                        ; r1 = number to print
                                        ; r2 = number of digits
                                        ; Register Usage
                                        ;	r5 = number of padding spaces
   2435 0000ECCA                        PRTNUM
   2436 0000ECCA F8 6E                   	sub		sp,sp,#8
   2437 0000ECCC E0 DF                   	sw		lr,[sp]
   2438 0000ECCE E2 D5                   	sw		r5,2[sp]
   2439 0000ECD0 E4 D6                   	sw		r6,4[sp]
   2440 0000ECD2 E6 D7                   	sw		r7,6[sp]
                                        
   2442 0000ECD4 0A 40 02 17             	lea		r7,NUMWKA	; r7 = pointer to numeric work area
   2443 0000ECD8 10 16                   	lw		r6,r1		; save number for later
   2444 0000ECDA 20 15                   	lw		r5,r2		; r5 = min number of chars
   2445 0000ECDC 16 21                   	
   2446 0000ECDE 02 AB                   	bpl		PN1			; if not
   2447 0000ECE0 20 31                   	neg		r1			; else make it positive
   2448 0000ECE2 FF 65                   	sub		r5,r5,#1	; one less for width count
   2449 0000ECE4                        PN1
   2450 0000ECE4 0A 12                   	lw		r2,#10		; divide by 10
   2451 0000ECE6 E1 4F 05 AF             	call	DIV32
   2452 0000ECEA 30 62                   	add		r2,r2,#'0'	; convert remainder to ascii
   2453 0000ECEC 70 C2                   	sb		r2,[r7]		; and store in buffer
   2454 0000ECEE 01 67                   	add		r7,r7,#1
   2455 0000ECF0 FF 65                   	sub		r5,r5,#1	; decrement width
   2456 0000ECF2 10 10                   	cmp		r1,#0
   2457 0000ECF4 F7 B9                   	bne		PN1
   2458 0000ECF6                        PN6
   2459 0000ECF6 56 25                   	or		r5,r5		; test pad count
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 42
noc_boot.a
   2460 0000ECF8 06 A2                   	ble		PN4			; skip padding if not needed
   2461 0000ECFA                        PN3
   2462 0000ECFA 02 40 00 11             	lw		r1,#' '		; display the required leading spaces
   2463 0000ECFE 9B 4F 08 AF             	call	GOOUT
   2464 0000ED02 FF 65                   	sub		r5,r5,#1
   2465 0000ED04 FA B9                   	bne		PN3
   2466 0000ED06                        PN4
   2467 0000ED06 66 26                   	or		r6,r6		; is number negative?
   2468 0000ED08 04 AB                   	bpl		PN5
   2469 0000ED0A 02 40 0D 11             	lw		r1,#'-'		; if so, display the sign
   2470 0000ED0E 9B 4F 00 AF             	call	GOOUT
   2471 0000ED12                        PN5
   2472 0000ED12 FF 67                   	sub		r7,r7,#1
   2473 0000ED14 70 E1                   	lb		r1,[r7]		; now unstack the digits and display
   2474 0000ED16 9A 4F 0C AF             	call	GOOUT
   2475 0000ED1A F5 4F 7E 10             	cmp		r7,#NUMWKA
   2476 0000ED1E F9 B7                   	bgtu	PN5
   2477 0000ED20                        PNRET
   2478 0000ED20 E0 FF                   	lw		lr,[sp]
   2479 0000ED22 E2 F5                   	lw		r5,2[sp]
   2480 0000ED24 E4 F6                   	lw		r6,4[sp]
   2481 0000ED26 E6 F7                   	lw		r7,6[sp]
   2482 0000ED28 08 6E                   	add		sp,sp,#8
   2483 0000ED2A F0 80                   	ret
                                        
                                        
                                        ; r1 = number to print
                                        ; r2 = number of digits
   2488 0000ED2C                        PRTHEXNUM
   2489 0000ED2C F6 6E                   	sub		sp,sp,#10
   2490 0000ED2E E0 DF                   	sw		lr,[sp]
   2491 0000ED30 E2 D5                   	sw		r5,2[sp]
   2492 0000ED32 E4 D6                   	sw		r6,4[sp]
   2493 0000ED34 E6 D7                   	sw		r7,6[sp]
   2494 0000ED36 E8 D8                   	sw		r8,8[sp]
                                        
   2496 0000ED38 0A 40 02 17             	lea		r7,NUMWKA	; r7 = pointer to numeric work area
   2497 0000ED3C 10 16                   	lw		r6,r1		; save number for later
   2498 0000ED3E 0A 15                   	lw		r5,#10		; r5 = min number of chars
   2499 0000ED40 10 14                   	lw		r4,r1
   2500 0000ED42 46 24                   	
   2501 0000ED44 03 AB                   	bpl		PHN1		; if not
   2502 0000ED46 20 34                   	neg		r4			; else make it positive
   2503 0000ED48 FF 65                   	sub		r5,r5,#1	; one less for width count
   2504 0000ED4A 0A 18                   	lw		r8,#10		; maximum of 10 digits
   2505 0000ED4C                        PHN1
   2506 0000ED4C 40 11                   	lw		r1,r4
   2507 0000ED4E 00 40 5F 31             	and		r1,#15
   2508 0000ED52 FF 4F 16 10             	cmp		r1,#10
   2509 0000ED56 02 A0                   	blt		PHN7
   2510 0000ED58 37 61                   	add		r1,r1,#'A'-10
   2511 0000ED5A 01 AE                   	br		PHN8
   2512 0000ED5C                        PHN7
   2513 0000ED5C 30 61                   	add		r1,r1,#'0'		; convert remainder to ascii
   2514 0000ED5E                        PHN8
   2515 0000ED5E 70 C1                   	sb		r1,[r7]		; and store in buffer
   2516 0000ED60 01 67                   	add		r7,r7,#1
   2517 0000ED62 FF 65                   	sub		r5,r5,#1	; decrement width
   2518 0000ED64 A1 34                   	shr		r4,#1
   2519 0000ED66 A1 34                   	shr		r4,#1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 43
noc_boot.a
   2520 0000ED68 A1 34                   	shr		r4,#1
   2521 0000ED6A A1 34                   	shr		r4,#1
   2522 0000ED6C 02 A8                   	beq		PHN6			; is it zero yet ?
   2523 0000ED6E FF 68                   	sub		r8,r8,#1	; safety
   2524 0000ED70 ED B9                   	bne		PHN1
   2525 0000ED72                        PHN6
   2526 0000ED72 56 25                   	or		r5,r5		; test pad count
   2527 0000ED74 06 A2                   	ble		PHN4			; skip padding if not needed
   2528 0000ED76                        PHN3
   2529 0000ED76 02 40 00 11             	lw		r1,#' '		; display the required leading spaces
   2530 0000ED7A 97 4F 0A AF             	call	GOOUT
   2531 0000ED7E FF 65                   	sub		r5,r5,#1
   2532 0000ED80 FA B9                   	bne		PHN3
   2533 0000ED82                        PHN4
   2534 0000ED82 66 26                   	or		r6,r6		; is number negative?
   2535 0000ED84 04 AB                   	bpl		PHN5
   2536 0000ED86 02 40 0D 11             	lw		r1,#'-'		; if so, display the sign
   2537 0000ED8A 97 4F 02 AF             	call	GOOUT
   2538 0000ED8E                        PHN5
   2539 0000ED8E FF 67                   	sub		r7,r7,#1
   2540 0000ED90 70 E1                   	lb		r1,[r7]		; now unstack the digits and display
   2541 0000ED92 96 4F 0E AF             	call	GOOUT
   2542 0000ED96 F5 4F 7E 10             	cmp		r7,#NUMWKA
   2543 0000ED9A F9 B7                   	bgtu	PHN5
   2544 0000ED9C                        PHNRET
   2545 0000ED9C E0 FF                   	lw		lr,[sp]
   2546 0000ED9E E2 F5                   	lw		r5,2[sp]
   2547 0000EDA0 E4 F6                   	lw		r6,4[sp]
   2548 0000EDA2 E6 F7                   	lw		r7,6[sp]
   2549 0000EDA4 E8 F8                   	lw		r8,8[sp]
   2550 0000EDA6 0A 6E                   	add		sp,sp,#10
   2551 0000EDA8 F0 80                   	ret
                                        
                                        
                                        ; r1 = pointer to line
                                        ; returns r1 = pointer to end of line + 1
   2556 0000EDAA                        PRTLN
   2557 0000EDAA FC 6E                       sub     sp,sp,#4
   2558 0000EDAC E0 DF                       sw      lr,[sp]
   2559 0000EDAE E2 D5                       sw      r5,2[sp]
   2560 0000EDB0 12 15                       add     r5,r1,#2
   2561 0000EDB2 5E E1                       lb		r1,-2[r5]	; get the binary line number
   2562 0000EDB4 0E 21                       zxb		r1
   2563 0000EDB6 5F E2                       lb		r2,-1[r5]
   2564 0000EDB8 0E 22                       zxb		r2
   2565 0000EDBA 81 32                       shl		r2,#1
   2566 0000EDBC 81 32                       shl		r2,#1
   2567 0000EDBE 81 32                       shl		r2,#1
   2568 0000EDC0 81 32                       shl		r2,#1
   2569 0000EDC2 81 32                       shl		r2,#1
   2570 0000EDC4 81 32                       shl		r2,#1
   2571 0000EDC6 81 32                       shl		r2,#1
   2572 0000EDC8 81 32                       shl		r2,#1
   2573 0000EDCA 26 21                       or		r1,r2
   2574 0000EDCC 00 12                       lw      r2,#0       ; display a 0 or more digit line no.
   2575 0000EDCE 7D BF                   	call	PRTNUM
   2576 0000EDD0 02 40 00 11             	lw      r1,#' '     ; followed by a blank
   2577 0000EDD4 94 4F 0D AF             	call	GOOUT
   2578 0000EDD8 00 12                   	lw      r2,#0       ; stop char. is a zero
   2579 0000EDDA 50 11                   	lw      r1,r5
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 44
noc_boot.a
   2580 0000EDDC 2E BF                   	call    PRTSTG		; display the rest of the line
   2581 0000EDDE E2 F5                   	lw      r5,2[sp]
   2582 0000EDE0 E0 FF                   	lw      lr,[sp]
   2583 0000EDE2 04 6E                   	add     sp,sp,#4
   2584 0000EDE4 F0 80                   	ret
                                        
                                        
                                        ; ===== Test text byte following the call to this subroutine. If it
                                        ;	equals the byte pointed to by r8, return to the code following
                                        ;	the call. If they are not equal, brnch to the point
                                        ;	indicated by the offset byte following the text byte.
                                        ;
                                        ; Registers Affected
                                        ;   r3,r8
                                        ; Returns
                                        ;	r8 = updated text pointer
                                        ;
   2597 0000EDE6                        TSTC
   2598 0000EDE6 FC 6E                   	sub		sp,sp,#4
   2599 0000EDE8 E0 DF                   	sw		lr,[sp]
   2600 0000EDEA E2 D1                   	sw		r1,2[sp]
   2601 0000EDEC 2F AF                   	call	IGNBLK		; ignore leading blanks
   2602 0000EDEE E0 FF                   	lw		lr,[sp]	; get the return address
   2603 0000EDF0 F0 E3                   	lb		r3,[lr]	; get the byte to compare
   2604 0000EDF2 80 E1                   	lb		r1,[r8]
   2605 0000EDF4 1D 23                   	cmp		r3,r1		; is it = to what r8 points to?
   2606 0000EDF6 05 A8                   	beq		TC1			; if so
                                        						; If not, add the second
   2608 0000EDF8 F1 E3                   	lb		r3,1[lr]	; byte following the call to
   2609 0000EDFA 30 2F                   	add		lr,r3		; the return address.
   2610 0000EDFC E2 F1                   	lw		r1,2[sp]
   2611 0000EDFE 04 6E                   	add		sp,sp,#4
   2612 0000EE00 F0 80                   	ret					; jump to the routine
   2613 0000EE02                        TC1
   2614 0000EE02 01 68                   	add		r8,r8,#1	; if equal, bump text pointer
   2615 0000EE04 E2 F1                   	lw		r1,2[sp]
   2616 0000EE06 04 6E                   	add     sp,sp,#4
   2617 0000EE08 F2 80                   	jmp		2[lr]		; Skip the 2 bytes following
                                        						; the call and continue.
                                        
                                        
                                        ; ===== See if the text pointed to by r8 is a number. If so,
                                        ;	return the number in r2 and the number of digits in r3,
                                        ;	else return zero in r2 and r3.
                                        ; Registers Affected
                                        ;   r1,r2,r3,r4
                                        ; Returns
                                        ; 	r1 = number
                                        ;	r2 = number of digits in number
                                        ;	r8 = updated text pointer
                                        ;
   2631 0000EE0A                        TSTNUM
   2632 0000EE0A FE 6E                   	sub		sp,sp,#2
   2633 0000EE0C E0 DF                   	sw		lr,[sp]
   2634 0000EE0E 1E AF                   	call	IGNBLK		; skip over blanks
   2635 0000EE10 00 11                   	lw		r1,#0		; initialize return parameters
   2636 0000EE12 00 12                   	lw		r2,#0
   2637 0000EE14                        TN1
   2638 0000EE14 80 E3                   	lb		r3,[r8]
   2639 0000EE16 FD 4F 30 10             	cmp		r3,#'0'		; is it less than zero?
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 45
noc_boot.a
   2640 0000EE1A 15 A4                   	bltu	TSNMRET 	; if so, that's all
   2641 0000EE1C FC 4F 37 10             	cmp		r3,#'9'		; is it greater than nine?
   2642 0000EE20 12 A7                   	bgtu	TSNMRET 	; if so, return
   2643 0000EE22 33 43 14 10             	cmp		r1,#214748364	; see if there's room for new digit
   2644 0000EE26 04 A6                   	bleu	TN2
   2645 0000EE28 10 4F 01 11             	lea		r1,msgNumTooBig
   2646 0000EE2C E3 4F 07 AE             	br		ERROR		; if not, we've overflowd
   2647 0000EE30                        TN2
   2648 0000EE30 10 14                   	lw		r4,r1		; quickly multiply result by 10
   2649 0000EE32 81 31                   	shl		r1,#1		; * 2
   2650 0000EE34 81 31                   	shl		r1,#1		; * 4
   2651 0000EE36 40 21                   	add		r1,r4		; * 5
   2652 0000EE38 81 31                   	shl		r1,#1		; * 10
   2653 0000EE3A 01 68                   	add		r8,r8,#1	; adjust text pointer
   2654 0000EE3C 00 40 5F 33             	and		r3,#0xF		; add in the new digit
   2655 0000EE40 30 21                   	add		r1,r3
   2656 0000EE42 01 62                   	add		r2,r2,#1	; increment the no. of digits
   2657 0000EE44 E7 BE                   	br		TN1
   2658 0000EE46                        TSNMRET
   2659 0000EE46 E0 FF                   	lw		lr,[sp]
   2660 0000EE48 02 6E                   	add		sp,sp,#2
   2661 0000EE4A F0 80                   	ret
                                        
                                        
                                        ;===== Skip over blanks in the text pointed to by r8.
                                        ;
                                        ; Registers Affected:
                                        ;	r8
                                        ; Returns
                                        ;	r8 = pointer updateded past any spaces or tabs
                                        ;
   2671 0000EE4C                        IGNBLK
   2672 0000EE4C FE 6E                   	sub		sp,sp,#2
   2673 0000EE4E E0 D1                   	sw		r1,[sp]
   2674 0000EE50                        IGB2
   2675 0000EE50 80 E1                   	lb		r1,[r8]			; get char
   2676 0000EE52 FE 4F 10 10             	cmp		r1,#' '			; see if it's a space
   2677 0000EE56 03 A8                   	beq		IGB1			; if so, swallow it
   2678 0000EE58 FF 4F 17 10             	cmp		r1,#'\t'		; or a tab
   2679 0000EE5C 02 A9                   	bne		IGBRET
   2680 0000EE5E                        IGB1
   2681 0000EE5E 01 68                   	add		r8,r8,#1		; increment the text pointer
   2682 0000EE60 F7 BE                   	br		IGB2
   2683 0000EE62                        IGBRET
   2684 0000EE62 E0 F1                   	lw		r1,[sp]
   2685 0000EE64 02 6E                   	add		sp,sp,#2
   2686 0000EE66 F0 80                   	ret
                                        
                                        
                                        ; ===== Convert the line of text in the input buffer to upper
                                        ;	case (except for stuff between quotes).
                                        ;
                                        ; Registers Affected
                                        ;   r1,r3
                                        ; Returns
                                        ;	r8 = pointing to end of text in buffer
                                        ;
   2697 0000EE68                        TOUPBUF
   2698 0000EE68 FE 6E                   	sub		sp,sp,#2
   2699 0000EE6A E0 DF                   	sw		lr,[sp]
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 46
noc_boot.a
   2700 0000EE6C 0A 40 0E 18             	lea		r8,BUFFER	; set up text pointer
   2701 0000EE70 00 13                   	lw		r3,#0		; clear quote flag
   2702 0000EE72                        TOUPB1
   2703 0000EE72 80 E1                   	lb		r1,[r8]		; get the next text char.
   2704 0000EE74 01 68                   	add		r8,r8,#1
   2705 0000EE76 FF 4F 13 10             	cmp		r1,#CR		; is it end of line?
   2706 0000EE7A 13 A8                   	beq		TOUPBRT 	; if so, return
   2707 0000EE7C FD 4F 1E 10             	cmp		r1,#'"'		; a double quote?
   2708 0000EE80 08 A8                   	beq		DOQUO
   2709 0000EE82 FD 4F 19 10             	cmp		r1,#''''	; or a single quote?
   2710 0000EE86 05 A8                   	beq		DOQUO
   2711 0000EE88 30 10                   	cmp		r3,#0		; inside quotes?
   2712 0000EE8A F3 B9                   	bne		TOUPB1		; if so, do the next one
   2713 0000EE8C 0D AF                   	call	toUpper 	; convert to upper case
   2714 0000EE8E 8F C1                   	sb		r1,-1[r8]	; store it
   2715 0000EE90 F0 BE                   	br		TOUPB1		; and go back for more
   2716 0000EE92                        DOQUO
   2717 0000EE92 30 10                   	cmp		r3,#0		; are we inside quotes?
   2718 0000EE94 02 A9                   	bne		DOQUO1
   2719 0000EE96 10 13                   	lw		r3,r1		; if not, toggle inside-quotes flag
   2720 0000EE98 EC BE                   	br		TOUPB1
   2721 0000EE9A                        DOQUO1
   2722 0000EE9A 1D 23                   	cmp		r3,r1		; make sure we're ending proper quote
   2723 0000EE9C EA B9                   	bne		TOUPB1		; if not, ignore it
   2724 0000EE9E 00 13                   	lw		r3,#0		; else clear quote flag
   2725 0000EEA0 E8 BE                   	br		TOUPB1
   2726 0000EEA2                        TOUPBRT
   2727 0000EEA2 E0 FF                   	lw		lr,[sp]
   2728 0000EEA4 02 6E                   	add		sp,sp,#2
   2729 0000EEA6 F0 80                   	ret
                                        
                                        
                                        ; ===== Convert the character in r1 to upper case
                                        ;
   2734 0000EEA8                        toUpper
   2735 0000EEA8 F9 4F 1F 10             	cmp		r1,#'a'		; is it < 'a'?
   2736 0000EEAC 04 A0                   	blt	    TOUPRET
   2737 0000EEAE F8 4F 16 10             	cmp		r1,#'z'		; or > 'z'?
   2738 0000EEB2 01 A3                   	bgt	    TOUPRET
   2739 0000EEB4 E0 61                   	sub		r1,r1,#32	; if not, make it upper case
   2740 0000EEB6                        TOUPRET
   2741 0000EEB6 F0 80                   	ret
                                        
                                        
                                        ; 'CHKIO' checks the input. If there's no input, it will return
                                        ; to the caller with the Z flag set. If there is input, the Z
                                        ; flag is cleared and the input byte is in r2. However, if a
                                        ; control-C is read, 'CHKIO' will warm-start BASIC and will not
                                        ; return to the caller.
                                        ;
   2750 0000EEB8                        CHKIO
   2751 0000EEB8 FE 6E                   	sub		sp,sp,#2	; save link reg
   2752 0000EEBA E0 DF                   	sw		lr,[sp]
   2753 0000EEBC 8D 4F 0B AF             	call	GOIN		; get input if possible
   2754 0000EEC0 07 A8                   	beq		CHKRET2		; if Zero, no input
   2755 0000EEC2 1D 10                   	cmp		r1,#CTRLC	; is it control-C?
   2756 0000EEC4 02 A9                   	bne		CHKRET		; if not
   2757 0000EEC6 8F 4F 0A AE             	jmp		WSTART		; if so, do a warm start
   2758 0000EECA                        CHKRET
   2759 0000EECA E0 FF                   	lw		lr,[sp]
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 47
noc_boot.a
   2760 0000EECC 02 6E                   	add		sp,sp,#2	; Z=0
   2761 0000EECE F0 80                   	ret
   2762 0000EED0                        CHKRET2
   2763 0000EED0 E0 FF                   	lw		lr,[sp]
   2764 0000EED2 02 6E                   	add		sp,sp,#2
   2765 0000EED4 00 11                   	lw		r1,#0		; Z=1
   2766 0000EED6 F0 80                   	ret
                                        
                                        
                                        ; ===== Display a CR-LF sequence
                                        ;
   2771 0000EED8                        CRLF
   2772 0000EED8 0E 4F 03 11             	lea		r1,CLMSG
                                        
                                        
                                        ; ===== Display a zero-ended string pointed to by register r1
                                        ; Registers Affected
                                        ;   r1,r2,r4
                                        ;
   2779 0000EEDC                        PRMESG
   2780 0000EEDC FC 6E                   	sub		sp,sp,#4
   2781 0000EEDE E0 DF                   	sw		lr,[sp]
   2782 0000EEE0 E2 D5                   	sw		r5,2[sp]
   2783 0000EEE2 10 15                   	lw      r5,r1       ; r5 = pointer to message
   2784 0000EEE4                        PRMESG1
   2785 0000EEE4 01 65                   	add		r5,r5,#1
   2786 0000EEE6 5F E1                   	lb		r1,-1[r5]	; 	get the char.
   2787 0000EEE8 03 A8                   	beq		PRMRET
   2788 0000EEEA 8C 4F 02 AF             	call	GOOUT		;else display it trashes r4
   2789 0000EEEE FA BE                   	br		PRMESG1
   2790 0000EEF0                        PRMRET
   2791 0000EEF0 50 11                   	lw		r1,r5
   2792 0000EEF2 E2 F5                   	lw		r5,2[sp]
   2793 0000EEF4 E0 FF                   	lw		lr,[sp]
   2794 0000EEF6 04 6E                   	add		sp,sp,#4
   2795 0000EEF8 F0 80                   	ret
                                        
                                        
                                        ; ===== Display a zero-ended string pointed to by register r1
                                        ; Registers Affected
                                        ;   r1,r2,r3
                                        ;
   2802 0000EEFA                        PRMESGAUX
   2803 0000EEFA FC 6E                   	sub		sp,sp,#4
   2804 0000EEFC E0 DF                   	sw		lr,[sp]
   2805 0000EEFE E2 D5                   	sw		r5,2[sp]
   2806 0000EF00 10 15                   	lw      r5,r1       ; r3 = pointer
   2807 0000EF02                        PRMESGA1
   2808 0000EF02 01 65                   	add		r5,r5,#1
   2809 0000EF04 5F E1                   	lb		r1,-1[r5]	; 	get the char.
   2810 0000EF06 03 A8                   	beq		PRMRETA
   2811 0000EF08 8B 4F 07 AF             	call	GOAUXO		;else display it
   2812 0000EF0C FA BE                   	br		PRMESGA1
   2813 0000EF0E                        PRMRETA
   2814 0000EF0E 50 11                   	lw		r1,r5
   2815 0000EF10 E2 F5                   	lw		r5,2[sp]
   2816 0000EF12 E0 FF                   	lw		lr,[sp]
   2817 0000EF14 04 6E                   	add		sp,sp,#4
   2818 0000EF16 F0 80                   	ret
                                        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 48
noc_boot.a
                                        ;*****************************************************
                                        ; The following routines are the only ones that need *
                                        ; to be changed for a different I/O environment.     *
                                        ;*****************************************************
                                        
                                        
                                        ; ===== Output character to the console (Port 1) from register D0
                                        ;	(Preserves all registers.)
                                        ;
   2829 0000EF18                        OUTC
   2830 0000EF18 FF BE                   	jmp		_putChar
                                        
                                        
                                        ; ===== Input a character from the console into register D0 (or
                                        ;	return Zero status if there's no character available).
                                        ;
   2836 0000EF1A                        INC
   2837 0000EF1A FE 6E                   	add		sp,sp,#-2
   2838 0000EF1C E0 DF                   	sw		lr,[sp]
   2839 0000EF1E 01 4B 00 E1             	lb		r1,ROUTER+RTR_RXSTAT
   2840 0000EF22 04 A8                   	beq		INC1
   2841 0000EF24 88 4F 0C AF             	call	Recv
   2842 0000EF28 1B 40 06 AF             	call	RecvDispatch
   2843 0000EF2C                        INC1
                                        ; get char from keyboard
                                        ; returns char in r1
   2846 0000EF2C                        _getChar
   2847 0000EF2C C5 4D 02 E1             	lb		r1,KBD+2	; get keyboard strobe
   2848 0000EF30 08 AB                   	bpl		gc1
   2849 0000EF32 C5 4D 00 E1             	lb		r1,KBD		; get character and clear keyboard strobe
   2850 0000EF36 05 AA                   	bmi		gc1			; was it a keyup event ? (ignore)
   2851 0000EF38 07 40 5F 31             	and		r1,#0x7f
   2852 0000EF3C E0 FF                   	lw		lr,[sp]
   2853 0000EF3E 02 6E                   	add		sp,sp,#2
   2854 0000EF40 F0 80                   	ret
   2855 0000EF42                        gc1
   2856 0000EF42 E0 FF                   	lw		lr,[sp]
   2857 0000EF44 02 6E                   	add		sp,sp,#2
   2858 0000EF46 00 11                   	lw		r1,#0		; return Z=1 (no character)
   2859 0000EF48 F0 80                   	ret
                                        
                                        
                                        ; get char from keyboard
                                        ; returns char in r1
   2864 0000EF4A                        _getCharWait
   2865 0000EF4A                        gc2
   2866 0000EF4A C5 4D 02 E1             	lb		r1,KBD+2	; get keyboard strobe
   2867 0000EF4E FD BB                   	bpl		gc2
   2868 0000EF50 C5 4D 00 E1             	lb		r1,KBD		; get character and clear keyboard strobe
   2869 0000EF54 FA BA                   	bmi		gc2			; was it a keyup event ? (ignore)
   2870 0000EF56 07 40 5F 31             	and		r1,#0x7f
   2871 0000EF5A F0 80                   	ret
                                        
                                        
                                        ; Trigger a load operation on the target node.
                                        
   2876 0000EF5C                        TriggerTgtLoad:
   2877 0000EF5C 85 4F 00 AF             	call	zeroTxBuf
   2878 0000EF60 03 40 06 E2             	lb		r2,tgtNode
   2879 0000EF64 02 40 0F C2             	sb		r2,txBuf+MSG_DST
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 49
noc_boot.a
   2880 0000EF68 01 40 01 12             	lw		r2,#$11
   2881 0000EF6C 02 40 0E C2             	sb		r2,txBuf+MSG_SRC
   2882 0000EF70 0A 12                   	lw		r2,#10				; trigger load on target node
   2883 0000EF72 02 40 07 C2             	sb		r2,txBuf+MSG_TYPE
   2884 0000EF76 84 4F 0E AF             	call	Xmit
   2885 0000EF7A E2 F2                   	lw		r2,2[sp]
   2886 0000EF7C E0 FF                   	lw		lr,[sp]
   2887 0000EF7E F0 80                   	ret
                                        
                                        ; ===== Output character to the host (Port 2) from register r1
                                        ;	(Preserves all registers.)
                                        ;
   2892 0000EF80                        AUXOUT
   2893 0000EF80 FC 6E                   	add		sp,sp,#-4
   2894 0000EF82 E0 DF                   	sw		lr,[sp]
   2895 0000EF84 E2 D2                   	sw		r2,2[sp]
   2896 0000EF86 03 40 06 E2             	lb		r2,tgtNode
                                        	cmp		#$11
   2898 0000EF8A 05 A9                   	bne		auxout1
   2899 0000EF8C 43 48 0D AF             	call	putSerial	; call boot rom routine
   2900 0000EF90 E2 F2                   	lw		r2,2[sp]
   2901 0000EF92 E0 FF                   	lw		lr,[sp]
   2902 0000EF94 F0 80                   	ret
   2903 0000EF96                        auxout1:
   2904 0000EF96 83 4F 03 AF             	call	zeroTxBuf
   2905 0000EF9A 02 40 00 C1             	sb		r1,txBuf
   2906 0000EF9E 03 40 06 E2             	lb		r2,tgtNode
   2907 0000EFA2 02 40 0F C2             	sb		r2,txBuf+MSG_DST
   2908 0000EFA6 01 40 01 12             	lw		r2,#$11
   2909 0000EFAA 02 40 0E C2             	sb		r2,txBuf+MSG_SRC
   2910 0000EFAE 0B 12                   	lw		r2,#11				; recieve BASIC program char
   2911 0000EFB0 02 40 07 C2             	sb		r2,txBuf+MSG_TYPE
   2912 0000EFB4 82 4F 0F AF             	call	Xmit
   2913 0000EFB8 E2 F2                   	lw		r2,2[sp]
   2914 0000EFBA E0 FF                   	lw		lr,[sp]
   2915 0000EFBC F0 80                   	ret
                                        ;
                                        ; ===== Input a character from the host into register D0 (or
                                        ;	return negative status if there's no character available).
                                        ;
   2920 0000EFBE                        AUXIN
                                        ; get character from serial port
                                        ; return  N=1 if no character available
   2923 0000EFBE 42 48 02 AE             	jmp		peekSerial
                                        
                                        
   2926 0000EFC2                        _scrollScreen
   2927 0000EFC2 FC 6E                   	sub		sp,sp,#4
   2928 0000EFC4 E0 D5                   	sw		r5,[sp]
   2929 0000EFC6 60 40 00 13             	lw		r3,#1536	; number of chars to move - 1
   2930 0000EFCA 00 42 00 12             	lw		r2,#VIDEORAM
   2931 0000EFCE 03 40 00 E1             	lb		r1,txtWidth
   2932 0000EFD2 81 31                   	shl		r1,#1
   2933 0000EFD4 81 31                   	shl		r1,#1
   2934 0000EFD6                        ss1:
   2935 0000EFD6 20 15                   	lw		r5,r2
   2936 0000EFD8 10 25                   	add		r5,r1
   2937 0000EFDA 50 F4                   	lw		r4,[r5]		; char at next line
   2938 0000EFDC 20 D4                   	sw		r4,[r2]		; goes to this line
   2939 0000EFDE 04 62                   	add		r2,r2,#4
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 50
noc_boot.a
   2940 0000EFE0 FF 63                   	sub		r3,r3,#1
   2941 0000EFE2 F9 B9                   	bne     ss1
                                        	; blank out last line
   2943 0000EFE4 02 40 00 13             	lw		r3,#' '
   2944 0000EFE8 03 40 08 D3             	sh		r3,charToPrint
   2945 0000EFEC 03 40 00 E3             	lb		r3,txtWidth
   2946 0000EFF0 03 40 08 F4             	lw		r4,charToPrint	; and colors
   2947 0000EFF4                        ss2
   2948 0000EFF4 20 D4                   	sw		r4,[r2]
   2949 0000EFF6 04 62                   	add		r2,r2,#4
   2950 0000EFF8 FF 63                   	sub		r3,r3,#1
   2951 0000EFFA FC B9                   	bne     ss2
   2952 0000EFFC E0 F5                   	lw		r5,[sp]
   2953 0000EFFE 04 6E                   	add		sp,sp,#4
   2954 0000F000 F0 80                   	ret
                                        
                                        
                                        ; flash the character at the screen position
                                        ;   r1: 1 = flash, 0 = no flash
   2959 0000F002                        _flashCursor
   2960 0000F002 00 42 00 12             	lw		r2,#VIDEORAM
   2961 0000F006 03 40 04 F3             	lh		r3,pos
   2962 0000F00A 81 33                   	shl		r3,#1
   2963 0000F00C 81 33                   	shl		r3,#1
   2964 0000F00E 20 23                   	add		r3,r2		; r3 = scr[pos]
                                        
   2966 0000F010 16 21                   	or		r1,r1
   2967 0000F012 04 A8                   	beq		fc1
   2968 0000F014 33 E2                   	lb		r2,3[r3]	; get background color
   2969 0000F016 08 40 60 32             	or		r2,#0x80	; set flash indicator
   2970 0000F01A 03 AE                   	br		fcx
   2971 0000F01C                        fc1
   2972 0000F01C 33 E2                   	lb		r2,3[r3]	; get background color
   2973 0000F01E 07 40 5F 32             	and		r2,#0x7f	; clear flash indicator
   2974 0000F022                        fcx:
   2975 0000F022 33 C2                   	sb		r2,3[r3]
   2976 0000F024 F0 80                   	ret
                                        
                                        
                                        ; ===== Return to the resident monitor, operating system, etc.
                                        ;
   2981 0000F026                        BYEBYE
   2982 0000F026 08 40 04 FE             	lw		sp,OSSP
   2983 0000F02A E0 FF                       lw      lr,[sp]
   2984 0000F02C 02 6E                       add		sp,sp,#2
   2985 0000F02E F0 80                   	ret
                                        
                                        ; Set the message address fields
                                        
   2989 0000F030                        SetMsgAddr:
   2990 0000F030 E4 31                   	tsr		r1,ID
   2991 0000F032 02 40 0E C1             	sb		r1,txBuf+MSG_SRC
   2992 0000F036 01 40 01 11             	lw		r1,#$11
   2993 0000F03A 02 40 0F C1             	sb		r1,txBuf+MSG_DST
   2994 0000F03E F0 80                   	ret
                                        
   2996 0000F040                        EXIT
   2997 0000F040 AE 4F 03 AF             	call	OREXPR
   2998 0000F044 7D 4F 0C AF             	call	zeroTxBuf
   2999 0000F048 02 40 00 D1             	sw		r1,txBuf
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 51
noc_boot.a
   3000 0000F04C F1 BF                   	call	SetMsgAddr
   3001 0000F04E 00 40 0D 11             	lw		r1,#MT_BASIC_EXIT
   3002 0000F052 02 40 07 C1             	sb		r1,txBuf+MSG_TYPE
   3003 0000F056 7D 4F 0E AF             	call	Xmit
   3004 0000F05A 83 4F 00 AE             	jmp		WSTART
                                        
   3006 0000F05E                        RequestOutputFocus:
   3007 0000F05E FE 6E                   	add		sp,sp,#-2
   3008 0000F060 E0 DF                   	sw		lr,[sp]
   3009 0000F062 7C 4F 0D AF             	call	zeroTxBuf
   3010 0000F066 E4 BF                   	call	SetMsgAddr
   3011 0000F068 00 40 0F 11             	lw		r1,#MT_REQ_OUT_FOCUS
   3012 0000F06C 02 40 07 C1             	sb		r1,txBuf+MSG_TYPE
   3013 0000F070 7D 4F 01 AF             	call	Xmit
   3014 0000F074                        ROF1:
   3015 0000F074 01 4B 00 E1             	lb		r1,ROUTER+RTR_RXSTAT
   3016 0000F078 FD B8                   	beq		ROF1
   3017 0000F07A 7E 4F 01 AF             	call	Recv
   3018 0000F07E 10 40 0B AF             	call	RecvDispatch
   3019 0000F082 03 40 07 E1             	lb		r1,rxBuf+MSG_TYPE
   3020 0000F086 FF 4F 10 10             	cmp		r1,#MT_GRNT_OUT_FOCUS
   3021 0000F08A F4 B9                   	bne		ROF1
   3022 0000F08C E0 FF                   	lw		lr,[sp]
   3023 0000F08E 02 6E                   	add		sp,sp,#2
   3024 0000F090 F0 80                   	ret
                                        
                                        ;	MOVE.B	#228,D7 	return to Tutor
                                        ;	TRAP	#14
                                        
   3029 0000F092 0D 0A 42 75 74 74      msgInit db	CR,LF,"Butterfly Tiny BASIC v1.1",CR,LF,"(C) 2005-2017  Robert Finch",CR,LF,LF,0
   3029 0000F098 65 72 66 6C 79 20 54  
   3029 0000F09F 69 6E 79 20 42 41 53  
   3029 0000F0A6 49 43 20 76 31 2E 31  
   3029 0000F0AD 0D 0A 28 43 29 20 32  
   3029 0000F0B4 30 30 35 2D 32 30 31  
   3029 0000F0BB 37 20 20 52 6F 62 65  
   3029 0000F0C2 72 74 20 46 69 6E 63  
   3029 0000F0C9 68 0D 0A 0A 00        
   3030 0000F0CE 0D 0A 4F 4B 0D 0A      OKMSG	db	CR,LF,"OK",CR,LF,0
   3030 0000F0D4 00                    
   3031 0000F0D5 57 68 61 74 3F 0D      msgWhat	db	"What?",CR,LF,0
   3031 0000F0DB 0A 00                 
   3032 0000F0DD 53 6F 72 72 79 2E      SRYMSG	db	"Sorry."
                                      
   3033 0000F0E3 0D 0A 00               CLMSG	db	CR,LF,0
   3034 0000F0E6 43 6F 6D 70 61 63      msgReadError	db	"Compact FLASH read error",CR,LF,0
   3034 0000F0EC 74 20 46 4C 41 53 48  
   3034 0000F0F3 20 72 65 61 64 20 65  
   3034 0000F0FA 72 72 6F 72 0D 0A 00  
                                      
   3035 0000F101 4E 75 6D 62 65 72      msgNumTooBig	db	"Number is too big",CR,LF,0
   3035 0000F107 20 69 73 20 74 6F 6F  
   3035 0000F10E 20 62 69 67 0D 0A 00  
                                      
   3036 0000F115 44 69 76 69 73 69      msgDivZero		db	"Division by zero",CR,LF,0
   3036 0000F11B 6F 6E 20 62 79 20 7A  
   3036 0000F122 65 72 6F 0D 0A 00     
   3037 0000F128 4F 75 74 20 6F 66      msgVarSpace     db  "Out of variable space",CR,LF,0
   3037 0000F12E 20 76 61 72 69 61 62  
   3037 0000F135 6C 65 20 73 70 61 63  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 52
noc_boot.a
   3037 0000F13C 65 0D 0A 00           
   3038 0000F140 20 62 79 74 65 73      msgBytesFree	db	" bytes free",CR,LF,0
   3038 0000F146 20 66 72 65 65 0D 0A  
   3038 0000F14D 00                    
   3039 0000F14E 0D 0A 52 65 61 64      msgReady		db	CR,LF,"Ready",CR,LF,0
   3039 0000F154 79 0D 0A 00           
   3040 0000F158 45 78 70 65 63 74      msgComma		db	"Expecting a comma",CR,LF,0
   3040 0000F15E 69 6E 67 20 61 20 63  
   3040 0000F165 6F 6D 6D 61 0D 0A 00  
                                      
   3041 0000F16C 4C 69 6E 65 20 6E      msgLineRange	db	"Line number too big",CR,LF,0
   3041 0000F172 75 6D 62 65 72 20 74  
   3041 0000F179 6F 6F 20 62 69 67 0D  
   3041 0000F180 0A 00                 
   3042 0000F182 45 78 70 65 63 74      msgVar			db	"Expecting a variable",CR,LF,0
   3042 0000F188 69 6E 67 20 61 20 76  
   3042 0000F18F 61 72 69 61 62 6C 65  
   3042 0000F196 0D 0A 00              
   3043 0000F199 52 4E 44 20 62 61      msgRNDBad		db	"RND bad parameter",CR,LF,0
   3043 0000F19F 64 20 70 61 72 61 6D  
   3043 0000F1A6 65 74 65 72 0D 0A 00  
                                      
   3044 0000F1AD 53 59 53 20 62 61      msgSYSBad		db	"SYS bad address",CR,LF,0
   3044 0000F1B3 64 20 61 64 64 72 65  
   3044 0000F1BA 73 73 0D 0A 00        
   3045 0000F1BF 49 4E 50 55 54 20      msgInputVar		db	"INPUT expecting a variable",CR,LF,0
   3045 0000F1C5 65 78 70 65 63 74 69  
   3045 0000F1CC 6E 67 20 61 20 76 61  
   3045 0000F1D3 72 69 61 62 6C 65 0D  
   3045 0000F1DA 0A 00                 
   3046 0000F1DC 4E 45 58 54 20 77      msgNextFor		db	"NEXT without FOR",CR,LF,0
   3046 0000F1E2 69 74 68 6F 75 74 20  
   3046 0000F1E9 46 4F 52 0D 0A 00     
   3047 0000F1EF 4E 45 58 54 20 65      msgNextVar		db	"NEXT expecting a defined variable",CR,LF,0
   3047 0000F1F5 78 70 65 63 74 69 6E  
   3047 0000F1FC 67 20 61 20 64 65 66  
   3047 0000F203 69 6E 65 64 20 76 61  
   3047 0000F20A 72 69 61 62 6C 65 0D  
   3047 0000F211 0A 00                 
   3048 0000F213 47 4F 54 4F 2F 47      msgBadGotoGosub	db	"GOTO/GOSUB bad line number",CR,LF,0
   3048 0000F219 4F 53 55 42 20 62 61  
   3048 0000F220 64 20 6C 69 6E 65 20  
   3048 0000F227 6E 75 6D 62 65 72 0D  
   3048 0000F22E 0A 00                 
   3049 0000F230 52 45 54 55 52 4E      msgRetWoGosub   db	"RETURN without GOSUB",CR,LF,0
   3049 0000F236 20 77 69 74 68 6F 75  
   3049 0000F23D 74 20 47 4F 53 55 42  
   3049 0000F244 0D 0A 00              
   3050 0000F247 50 72 6F 67 72 61      msgTooBig		db	"Program is too big",CR,LF,0
   3050 0000F24D 6D 20 69 73 20 74 6F  
   3050 0000F254 6F 20 62 69 67 0D 0A  
   3050 0000F25B 00                    
   3051 0000F25C 45 78 74 72 61 20      msgExtraChars	db	"Extra characters on line ignored",CR,LF,0
   3051 0000F262 63 68 61 72 61 63 74  
   3051 0000F269 65 72 73 20 6F 6E 20  
   3051 0000F270 6C 69 6E 65 20 69 67  
   3051 0000F277 6E 6F 72 65 64 0D 0A  
   3051 0000F27E 00                    
                                        
   3053 0000F27F FF                      	.align	4
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 53
noc_boot.a
   3120 = 0000F280                      LSTROM	equ	*		; end of possible ROM area
                                        ;
                                        ; Internal variables follow:
                                        ;
                                        		bss
                                        		org		0x0030
   3060 00000030                        txtWidth	db	0		; BIOS var =60
   3061 00000031                        txtHeight	db	0		; BIOS var =27
   3062 00000032                        cursx	db		0		; cursor x position
   3063 00000033                        cursy	db		0		; cursor y position
   3064 00000034                        pos		dw		0		; text screen position
   3065 00000036                        tgtNode	db		0
   3066 00000037                        srcNode	db		0
                                        		org		0x0038
   3068 00000038                        charToPrint		dw		0
   3069 0000003A                        fgColor			db		0
   3070 0000003B                        bkColor			db		0
   3071 0000003C                        cursFlash		db		0	; flash the cursor ?
   3072 0000003D                         				db		0
   3073 0000003E                        NormAttr		dw		0
                                        
   3075 00000040                        lineLinkTbl		fill.b	25,0	; screen line link table
   3076 00000059                         	align 4
                                        
                                        		org		0x0080
   3079 00000080                        typef   db      0   ; variable / expression type
   3080 00000081                                 align   4
   3081 00000084                        OSSP	dw	1	; OS value of sp
   3082 00000086                        CURRNT	dw	1	;	Current line pointer
   3083 00000088                        STKGOS	dw	1	;	Saves stack pointer in 'GOSUB'
   3084 0000008A                        STKINP	dw	1	;	Saves stack pointer during 'INPUT'
   3085 0000008C                        LOPVAR	dw	1	;	'FOR' loop save area
   3086 0000008E                        LOPINC	dw	1	;	increment
   3087 00000090                        LOPLMT	dw	1	;	limit
   3088 00000092                        LOPLN	dw	1	;	line number
   3089 00000094                        LOPPT	dw	1	;	text pointer
   3090 00000096                        TXTUNF	dw	1	;	points to unfilled text area
   3091 00000098                        VARBGN	dw	1	;	points to variable area
   3092 0000009A                        IVARBGN dw  1   ;   points to integer variable area
   3093 0000009C                        SVARBGN dw  1   ;   points to string variable area
   3094 0000009E                        FVARBGN dw  1   ;   points to float variable area
   3095 000000A0                        STKBOT	dw	1	;	holds lower limit for stack growth
   3096 000000A2                        NUMWKA	fill.b	12,0			; numeric work area
   3097 000000AE                        BUFFER	fill.b	BUFLEN,0x00		;		Keyboard input buffer
                                        
                                                bss
                                                org     0x2000
   3101 00002000                        textScr1
                                                org     0x2000
                                        ;	END
                                        
                                        ; Operation of an ordinary (worker) node is pretty simple. It just waits in
                                        ; loop polling for recieved messages which are then dispatched.
                                        
                                        		.code
   3109 0000F280                        start:
   3110 0000F280 FF 41 0E 1E             		lw		sp,#$1FFE
   3111 0000F284                        noMsg1:
   3112 0000F284 01 4B 00 E1             		lb		r1,ROUTER+RTR_RXSTAT
   3113 0000F288 03 40 5F 31             		and		r1,#63
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 54
noc_boot.a
   3114 0000F28C FB B8                   		beq		noMsg1
   3115 0000F28E 6D 4F 07 AF             		call	Recv
   3116 0000F292 02 AF                   		call	RecvDispatch
   3117 0000F294 F5 BE                   		bra		start
   3118 0000F296                        lockup:
   3119 0000F296 FF BE                   		bra		lockup
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Receiver dispatch
                                        ;
                                        ; Executes different message handlers based on the message type.
                                        ;----------------------------------------------------------------------------
                                        
   3127 0000F298                        RecvDispatch:
   3128 0000F298 FC 6E                   		add		sp,sp,#-4
   3129 0000F29A E0 DF                   		sw		lr,[sp]
   3130 0000F29C E2 D1                   		sw		r1,2[sp]
   3131 0000F29E 03 40 07 E1             		lb		r1,rxBuf+MSG_TYPE
   3132 0000F2A2 1F 10                   		cmp		r1,#MT_RST			; reset message ?
   3133 0000F2A4 0F A9                   		bne		RecvDispatch2
                                        		; Send back a reset ACK message to indicate node is good to go.
   3135 0000F2A6 6A 4F 0B AF             		call	zeroTxBuf
   3136 0000F2AA E4 31                   		tsr		r1,ID
   3137 0000F2AC 02 40 0E C1             		sb		r1,txBuf+MSG_SRC
   3138 0000F2B0 01 40 01 11             		lw		r1,#$11
   3139 0000F2B4 02 40 0F C1             		sb		r1,txBuf+MSG_DST
   3140 0000F2B8 02 11                   		lw		r1,#MT_RST_ACK
   3141 0000F2BA 02 40 07 C1             		sb		r1,txBuf+MSG_TYPE
   3142 0000F2BE 6A 4F 0A AF             		call	Xmit
   3143 0000F2C2 53 AE                   		br		RecvDispatch5
   3144 0000F2C4                        RecvDispatch2:
   3145 0000F2C4 FF 4F 17 10             		cmp		r1,#MT_PING
   3146 0000F2C8 10 A9                   		bne		RecvDispatch9
   3147 0000F2CA 69 4F 09 AF             		call	zeroTxBuf
   3148 0000F2CE E4 31                   		tsr		r1,ID
   3149 0000F2D0 02 40 0E C1             		sb		r1,txBuf+MSG_SRC
   3150 0000F2D4 03 40 0E E1             		lb		r1,rxBuf+MSG_SRC
   3151 0000F2D8 02 40 0F C1             		sb		r1,txBuf+MSG_DST
   3152 0000F2DC 01 40 02 11             		lw		r1,#MT_PING_ACK
   3153 0000F2E0 02 40 07 C1             		sb		r1,txBuf+MSG_TYPE
   3154 0000F2E4 69 4F 07 AF             		call	Xmit
   3155 0000F2E8 40 AE                   		br		RecvDispatchXit
   3156 0000F2EA                        RecvDispatch9:
   3157 0000F2EA FF 4F 16 10             		cmp		r1,#MT_START_BASIC_LOAD	; start BASIC load
   3158 0000F2EE 07 A9                   		bne		RecvDispatch3
   3159 0000F2F0 03 40 0E E1             		lb		r1,rxBuf+MSG_SRC
   3160 0000F2F4 6C 4F 09 AF             		call	INITTBW
   3161 0000F2F8 08 4E 06 F8             		lw		r8,TXTBGN			; r8 = text begin
   3162 0000F2FC 36 AE                   		br		RecvDispatch5
   3163 0000F2FE                        RecvDispatch3:
   3164 0000F2FE FF 4F 15 10             		cmp		r1,#MT_LOAD_BASIC_CHAR	; load BASIC program char
   3165 0000F302 19 A9                   		bne		RecvDispatch4
   3166 0000F304 03 40 00 E1             		lb		r1,rxBuf
   3167 0000F308 FC 4F 16 10             		cmp		r1,#':'				; line number ?
   3168 0000F30C 08 A9                   		bne		RecvDispatch6
   3169 0000F30E                        RecvDispatch7:
   3170 0000F30E 03 40 01 E1             		lb		r1,rxBuf+1
   3171 0000F312 80 C1                   		sb		r1,[r8]
   3172 0000F314 03 40 02 E1             		lb		r1,rxBuf+2
   3173 0000F318 81 C1                   		sb		r1,1[r8]
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 55
noc_boot.a
   3174 0000F31A 02 68                   		add		r8,r8,#2
   3175 0000F31C 26 AE                   		br		RecvDispatch5
                                        		; Ordinary BASIC program character (non-line number)
                                        		; Just stuff in BASIC text buffer, increment text pointer
                                        		; and continue.
   3179 0000F31E                        RecvDispatch6:
   3180 0000F31E FC 4F 10 10             		cmp		r1,#'@'				; end of program ?
   3181 0000F322 06 A8                   		beq		RecvDispatch8
   3182 0000F324 FE 4F 16 10             		cmp		r1,#$1A				; CTRL-Z (CPM end of file)
   3183 0000F328 03 A8                   		beq		RecvDispatch8
   3184 0000F32A 80 C1                   		sb		r1,[r8]
   3185 0000F32C 01 68                   		add		r8,r8,#1
   3186 0000F32E 1D AE                   		br		RecvDispatch5
                                        		; End of program load, just set the end of the BASIC
                                        		; program to the current text pointer.
   3189 0000F330                        RecvDispatch8:
   3190 0000F330 09 40 06 D8             		sw		r8,TXTUNF
   3191 0000F334 1A AE                   		br		RecvDispatch5
   3192 0000F336                        RecvDispatch4:
                                        		; Run a BASIC program by stuffing a 'RUN' command into the BASIC
                                        		; buffer.
   3195 0000F336 FF 4F 14 10             		cmp		r1,#MT_RUN_BASIC_PROG
   3196 0000F33A 17 A9                   		bne		RecvDispatch5
   3197 0000F33C 05 40 02 11             		lw		r1,#'R'
   3198 0000F340 0A 40 0E C1             		sb		r1,BUFFER
   3199 0000F344 05 40 05 11             		lw		r1,#'U'
   3200 0000F348 0A 40 0F C1             		sb		r1,BUFFER+1
   3201 0000F34C 04 40 0E 11             		lw		r1,#'N'
   3202 0000F350 0B 40 00 C1             		sb		r1,BUFFER+2
   3203 0000F354 00 40 0D 11             		lw		r1,#13
   3204 0000F358 0B 40 01 C1             		sb		r1,BUFFER+3
   3205 0000F35C 0B 40 02 C0             		sb		r0,BUFFER+4
   3206 0000F360 0B 40 02 18             		lw		r8,#BUFFER+4
   3207 0000F364 6B 4F 06 AF             		call	ST3
   3208 0000F368 00 AE                   		br		RecvDispatch5
   3209 0000F36A                        RecvDispatch5:
   3210 0000F36A                        RecvDispatchXit:
   3211 0000F36A E0 FF                   		lw		lr,[sp]
   3212 0000F36C E2 F1                   		lw		r1,2[sp]
   3213 0000F36E 04 6E                   		add		sp,sp,#4
   3214 0000F370 F0 80                   		ret
                                        
   3216 0000F372 FF FF FF FF FF FF FF    		org		0xFFFE
   3216 0000F379 FF FF FF FF FF FF FF  
   3216 0000F380 FF FF FF FF FF FF FF  
   3216 0000F387 FF FF FF FF FF FF FF  
   3216 0000F38E FF FF FF FF FF FF FF  
   3216 0000F395 FF FF FF FF FF FF FF  
   3216 0000F39C FF FF FF FF FF FF FF  
   3216 0000F3A3 FF FF FF FF FF FF FF  
   3216 0000F3AA FF FF FF FF FF FF FF  
   3216 0000F3B1 FF FF FF FF FF FF FF  
   3216 0000F3B8 FF FF FF FF FF FF FF  
   3216 0000F3BF FF FF FF FF FF FF FF  
   3216 0000F3C6 FF FF FF FF FF FF FF  
   3216 0000F3CD FF FF FF FF FF FF FF  
   3216 0000F3D4 FF FF FF FF FF FF FF  
   3216 0000F3DB FF FF FF FF FF FF FF  
   3216 0000F3E2 FF FF FF FF FF FF FF  
   3216 0000F3E9 FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 56
noc_boot.a
   3216 0000F3F0 FF FF FF FF FF FF FF  
   3216 0000F3F7 FF FF FF FF FF FF FF  
   3216 0000F3FE FF FF FF FF FF FF FF  
   3216 0000F405 FF FF FF FF FF FF FF  
   3216 0000F40C FF FF FF FF FF FF FF  
   3216 0000F413 FF FF FF FF FF FF FF  
   3216 0000F41A FF FF FF FF FF FF FF  
   3216 0000F421 FF FF FF FF FF FF FF  
   3216 0000F428 FF FF FF FF FF FF FF  
   3216 0000F42F FF FF FF FF FF FF FF  
   3216 0000F436 FF FF FF FF FF FF FF  
   3216 0000F43D FF FF FF FF FF FF FF  
   3216 0000F444 FF FF FF FF FF FF FF  
   3216 0000F44B FF FF FF FF FF FF FF  
   3216 0000F452 FF FF FF FF FF FF FF  
   3216 0000F459 FF FF FF FF FF FF FF  
   3216 0000F460 FF FF FF FF FF FF FF  
   3216 0000F467 FF FF FF FF FF FF FF  
   3216 0000F46E FF FF FF FF FF FF FF  
   3216 0000F475 FF FF FF FF FF FF FF  
   3216 0000F47C FF FF FF FF FF FF FF  
   3216 0000F483 FF FF FF FF FF FF FF  
   3216 0000F48A FF FF FF FF FF FF FF  
   3216 0000F491 FF FF FF FF FF FF FF  
   3216 0000F498 FF FF FF FF FF FF FF  
   3216 0000F49F FF FF FF FF FF FF FF  
   3216 0000F4A6 FF FF FF FF FF FF FF  
   3216 0000F4AD FF FF FF FF FF FF FF  
   3216 0000F4B4 FF FF FF FF FF FF FF  
   3216 0000F4BB FF FF FF FF FF FF FF  
   3216 0000F4C2 FF FF FF FF FF FF FF  
   3216 0000F4C9 FF FF FF FF FF FF FF  
   3216 0000F4D0 FF FF FF FF FF FF FF  
   3216 0000F4D7 FF FF FF FF FF FF FF  
   3216 0000F4DE FF FF FF FF FF FF FF  
   3216 0000F4E5 FF FF FF FF FF FF FF  
   3216 0000F4EC FF FF FF FF FF FF FF  
   3216 0000F4F3 FF FF FF FF FF FF FF  
   3216 0000F4FA FF FF FF FF FF FF FF  
   3216 0000F501 FF FF FF FF FF FF FF  
   3216 0000F508 FF FF FF FF FF FF FF  
   3216 0000F50F FF FF FF FF FF FF FF  
   3216 0000F516 FF FF FF FF FF FF FF  
   3216 0000F51D FF FF FF FF FF FF FF  
   3216 0000F524 FF FF FF FF FF FF FF  
   3216 0000F52B FF FF FF FF FF FF FF  
   3216 0000F532 FF FF FF FF FF FF FF  
   3216 0000F539 FF FF FF FF FF FF FF  
   3216 0000F540 FF FF FF FF FF FF FF  
   3216 0000F547 FF FF FF FF FF FF FF  
   3216 0000F54E FF FF FF FF FF FF FF  
   3216 0000F555 FF FF FF FF FF FF FF  
   3216 0000F55C FF FF FF FF FF FF FF  
   3216 0000F563 FF FF FF FF FF FF FF  
   3216 0000F56A FF FF FF FF FF FF FF  
   3216 0000F571 FF FF FF FF FF FF FF  
   3216 0000F578 FF FF FF FF FF FF FF  
   3216 0000F57F FF FF FF FF FF FF FF  
   3216 0000F586 FF FF FF FF FF FF FF  
   3216 0000F58D FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 57
noc_boot.a
   3216 0000F594 FF FF FF FF FF FF FF  
   3216 0000F59B FF FF FF FF FF FF FF  
   3216 0000F5A2 FF FF FF FF FF FF FF  
   3216 0000F5A9 FF FF FF FF FF FF FF  
   3216 0000F5B0 FF FF FF FF FF FF FF  
   3216 0000F5B7 FF FF FF FF FF FF FF  
   3216 0000F5BE FF FF FF FF FF FF FF  
   3216 0000F5C5 FF FF FF FF FF FF FF  
   3216 0000F5CC FF FF FF FF FF FF FF  
   3216 0000F5D3 FF FF FF FF FF FF FF  
   3216 0000F5DA FF FF FF FF FF FF FF  
   3216 0000F5E1 FF FF FF FF FF FF FF  
   3216 0000F5E8 FF FF FF FF FF FF FF  
   3216 0000F5EF FF FF FF FF FF FF FF  
   3216 0000F5F6 FF FF FF FF FF FF FF  
   3216 0000F5FD FF FF FF FF FF FF FF  
   3216 0000F604 FF FF FF FF FF FF FF  
   3216 0000F60B FF FF FF FF FF FF FF  
   3216 0000F612 FF FF FF FF FF FF FF  
   3216 0000F619 FF FF FF FF FF FF FF  
   3216 0000F620 FF FF FF FF FF FF FF  
   3216 0000F627 FF FF FF FF FF FF FF  
   3216 0000F62E FF FF FF FF FF FF FF  
   3216 0000F635 FF FF FF FF FF FF FF  
   3216 0000F63C FF FF FF FF FF FF FF  
   3216 0000F643 FF FF FF FF FF FF FF  
   3216 0000F64A FF FF FF FF FF FF FF  
   3216 0000F651 FF FF FF FF FF FF FF  
   3216 0000F658 FF FF FF FF FF FF FF  
   3216 0000F65F FF FF FF FF FF FF FF  
   3216 0000F666 FF FF FF FF FF FF FF  
   3216 0000F66D FF FF FF FF FF FF FF  
   3216 0000F674 FF FF FF FF FF FF FF  
   3216 0000F67B FF FF FF FF FF FF FF  
   3216 0000F682 FF FF FF FF FF FF FF  
   3216 0000F689 FF FF FF FF FF FF FF  
   3216 0000F690 FF FF FF FF FF FF FF  
   3216 0000F697 FF FF FF FF FF FF FF  
   3216 0000F69E FF FF FF FF FF FF FF  
   3216 0000F6A5 FF FF FF FF FF FF FF  
   3216 0000F6AC FF FF FF FF FF FF FF  
   3216 0000F6B3 FF FF FF FF FF FF FF  
   3216 0000F6BA FF FF FF FF FF FF FF  
   3216 0000F6C1 FF FF FF FF FF FF FF  
   3216 0000F6C8 FF FF FF FF FF FF FF  
   3216 0000F6CF FF FF FF FF FF FF FF  
   3216 0000F6D6 FF FF FF FF FF FF FF  
   3216 0000F6DD FF FF FF FF FF FF FF  
   3216 0000F6E4 FF FF FF FF FF FF FF  
   3216 0000F6EB FF FF FF FF FF FF FF  
   3216 0000F6F2 FF FF FF FF FF FF FF  
   3216 0000F6F9 FF FF FF FF FF FF FF  
   3216 0000F700 FF FF FF FF FF FF FF  
   3216 0000F707 FF FF FF FF FF FF FF  
   3216 0000F70E FF FF FF FF FF FF FF  
   3216 0000F715 FF FF FF FF FF FF FF  
   3216 0000F71C FF FF FF FF FF FF FF  
   3216 0000F723 FF FF FF FF FF FF FF  
   3216 0000F72A FF FF FF FF FF FF FF  
   3216 0000F731 FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 58
noc_boot.a
   3216 0000F738 FF FF FF FF FF FF FF  
   3216 0000F73F FF FF FF FF FF FF FF  
   3216 0000F746 FF FF FF FF FF FF FF  
   3216 0000F74D FF FF FF FF FF FF FF  
   3216 0000F754 FF FF FF FF FF FF FF  
   3216 0000F75B FF FF FF FF FF FF FF  
   3216 0000F762 FF FF FF FF FF FF FF  
   3216 0000F769 FF FF FF FF FF FF FF  
   3216 0000F770 FF FF FF FF FF FF FF  
   3216 0000F777 FF FF FF FF FF FF FF  
   3216 0000F77E FF FF FF FF FF FF FF  
   3216 0000F785 FF FF FF FF FF FF FF  
   3216 0000F78C FF FF FF FF FF FF FF  
   3216 0000F793 FF FF FF FF FF FF FF  
   3216 0000F79A FF FF FF FF FF FF FF  
   3216 0000F7A1 FF FF FF FF FF FF FF  
   3216 0000F7A8 FF FF FF FF FF FF FF  
   3216 0000F7AF FF FF FF FF FF FF FF  
   3216 0000F7B6 FF FF FF FF FF FF FF  
   3216 0000F7BD FF FF FF FF FF FF FF  
   3216 0000F7C4 FF FF FF FF FF FF FF  
   3216 0000F7CB FF FF FF FF FF FF FF  
   3216 0000F7D2 FF FF FF FF FF FF FF  
   3216 0000F7D9 FF FF FF FF FF FF FF  
   3216 0000F7E0 FF FF FF FF FF FF FF  
   3216 0000F7E7 FF FF FF FF FF FF FF  
   3216 0000F7EE FF FF FF FF FF FF FF  
   3216 0000F7F5 FF FF FF FF FF FF FF  
   3216 0000F7FC FF FF FF FF FF FF FF  
   3216 0000F803 FF FF FF FF FF FF FF  
   3216 0000F80A FF FF FF FF FF FF FF  
   3216 0000F811 FF FF FF FF FF FF FF  
   3216 0000F818 FF FF FF FF FF FF FF  
   3216 0000F81F FF FF FF FF FF FF FF  
   3216 0000F826 FF FF FF FF FF FF FF  
   3216 0000F82D FF FF FF FF FF FF FF  
   3216 0000F834 FF FF FF FF FF FF FF  
   3216 0000F83B FF FF FF FF FF FF FF  
   3216 0000F842 FF FF FF FF FF FF FF  
   3216 0000F849 FF FF FF FF FF FF FF  
   3216 0000F850 FF FF FF FF FF FF FF  
   3216 0000F857 FF FF FF FF FF FF FF  
   3216 0000F85E FF FF FF FF FF FF FF  
   3216 0000F865 FF FF FF FF FF FF FF  
   3216 0000F86C FF FF FF FF FF FF FF  
   3216 0000F873 FF FF FF FF FF FF FF  
   3216 0000F87A FF FF FF FF FF FF FF  
   3216 0000F881 FF FF FF FF FF FF FF  
   3216 0000F888 FF FF FF FF FF FF FF  
   3216 0000F88F FF FF FF FF FF FF FF  
   3216 0000F896 FF FF FF FF FF FF FF  
   3216 0000F89D FF FF FF FF FF FF FF  
   3216 0000F8A4 FF FF FF FF FF FF FF  
   3216 0000F8AB FF FF FF FF FF FF FF  
   3216 0000F8B2 FF FF FF FF FF FF FF  
   3216 0000F8B9 FF FF FF FF FF FF FF  
   3216 0000F8C0 FF FF FF FF FF FF FF  
   3216 0000F8C7 FF FF FF FF FF FF FF  
   3216 0000F8CE FF FF FF FF FF FF FF  
   3216 0000F8D5 FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 59
noc_boot.a
   3216 0000F8DC FF FF FF FF FF FF FF  
   3216 0000F8E3 FF FF FF FF FF FF FF  
   3216 0000F8EA FF FF FF FF FF FF FF  
   3216 0000F8F1 FF FF FF FF FF FF FF  
   3216 0000F8F8 FF FF FF FF FF FF FF  
   3216 0000F8FF FF FF FF FF FF FF FF  
   3216 0000F906 FF FF FF FF FF FF FF  
   3216 0000F90D FF FF FF FF FF FF FF  
   3216 0000F914 FF FF FF FF FF FF FF  
   3216 0000F91B FF FF FF FF FF FF FF  
   3216 0000F922 FF FF FF FF FF FF FF  
   3216 0000F929 FF FF FF FF FF FF FF  
   3216 0000F930 FF FF FF FF FF FF FF  
   3216 0000F937 FF FF FF FF FF FF FF  
   3216 0000F93E FF FF FF FF FF FF FF  
   3216 0000F945 FF FF FF FF FF FF FF  
   3216 0000F94C FF FF FF FF FF FF FF  
   3216 0000F953 FF FF FF FF FF FF FF  
   3216 0000F95A FF FF FF FF FF FF FF  
   3216 0000F961 FF FF FF FF FF FF FF  
   3216 0000F968 FF FF FF FF FF FF FF  
   3216 0000F96F FF FF FF FF FF FF FF  
   3216 0000F976 FF FF FF FF FF FF FF  
   3216 0000F97D FF FF FF FF FF FF FF  
   3216 0000F984 FF FF FF FF FF FF FF  
   3216 0000F98B FF FF FF FF FF FF FF  
   3216 0000F992 FF FF FF FF FF FF FF  
   3216 0000F999 FF FF FF FF FF FF FF  
   3216 0000F9A0 FF FF FF FF FF FF FF  
   3216 0000F9A7 FF FF FF FF FF FF FF  
   3216 0000F9AE FF FF FF FF FF FF FF  
   3216 0000F9B5 FF FF FF FF FF FF FF  
   3216 0000F9BC FF FF FF FF FF FF FF  
   3216 0000F9C3 FF FF FF FF FF FF FF  
   3216 0000F9CA FF FF FF FF FF FF FF  
   3216 0000F9D1 FF FF FF FF FF FF FF  
   3216 0000F9D8 FF FF FF FF FF FF FF  
   3216 0000F9DF FF FF FF FF FF FF FF  
   3216 0000F9E6 FF FF FF FF FF FF FF  
   3216 0000F9ED FF FF FF FF FF FF FF  
   3216 0000F9F4 FF FF FF FF FF FF FF  
   3216 0000F9FB FF FF FF FF FF FF FF  
   3216 0000FA02 FF FF FF FF FF FF FF  
   3216 0000FA09 FF FF FF FF FF FF FF  
   3216 0000FA10 FF FF FF FF FF FF FF  
   3216 0000FA17 FF FF FF FF FF FF FF  
   3216 0000FA1E FF FF FF FF FF FF FF  
   3216 0000FA25 FF FF FF FF FF FF FF  
   3216 0000FA2C FF FF FF FF FF FF FF  
   3216 0000FA33 FF FF FF FF FF FF FF  
   3216 0000FA3A FF FF FF FF FF FF FF  
   3216 0000FA41 FF FF FF FF FF FF FF  
   3216 0000FA48 FF FF FF FF FF FF FF  
   3216 0000FA4F FF FF FF FF FF FF FF  
   3216 0000FA56 FF FF FF FF FF FF FF  
   3216 0000FA5D FF FF FF FF FF FF FF  
   3216 0000FA64 FF FF FF FF FF FF FF  
   3216 0000FA6B FF FF FF FF FF FF FF  
   3216 0000FA72 FF FF FF FF FF FF FF  
   3216 0000FA79 FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 60
noc_boot.a
   3216 0000FA80 FF FF FF FF FF FF FF  
   3216 0000FA87 FF FF FF FF FF FF FF  
   3216 0000FA8E FF FF FF FF FF FF FF  
   3216 0000FA95 FF FF FF FF FF FF FF  
   3216 0000FA9C FF FF FF FF FF FF FF  
   3216 0000FAA3 FF FF FF FF FF FF FF  
   3216 0000FAAA FF FF FF FF FF FF FF  
   3216 0000FAB1 FF FF FF FF FF FF FF  
   3216 0000FAB8 FF FF FF FF FF FF FF  
   3216 0000FABF FF FF FF FF FF FF FF  
   3216 0000FAC6 FF FF FF FF FF FF FF  
   3216 0000FACD FF FF FF FF FF FF FF  
   3216 0000FAD4 FF FF FF FF FF FF FF  
   3216 0000FADB FF FF FF FF FF FF FF  
   3216 0000FAE2 FF FF FF FF FF FF FF  
   3216 0000FAE9 FF FF FF FF FF FF FF  
   3216 0000FAF0 FF FF FF FF FF FF FF  
   3216 0000FAF7 FF FF FF FF FF FF FF  
   3216 0000FAFE FF FF FF FF FF FF FF  
   3216 0000FB05 FF FF FF FF FF FF FF  
   3216 0000FB0C FF FF FF FF FF FF FF  
   3216 0000FB13 FF FF FF FF FF FF FF  
   3216 0000FB1A FF FF FF FF FF FF FF  
   3216 0000FB21 FF FF FF FF FF FF FF  
   3216 0000FB28 FF FF FF FF FF FF FF  
   3216 0000FB2F FF FF FF FF FF FF FF  
   3216 0000FB36 FF FF FF FF FF FF FF  
   3216 0000FB3D FF FF FF FF FF FF FF  
   3216 0000FB44 FF FF FF FF FF FF FF  
   3216 0000FB4B FF FF FF FF FF FF FF  
   3216 0000FB52 FF FF FF FF FF FF FF  
   3216 0000FB59 FF FF FF FF FF FF FF  
   3216 0000FB60 FF FF FF FF FF FF FF  
   3216 0000FB67 FF FF FF FF FF FF FF  
   3216 0000FB6E FF FF FF FF FF FF FF  
   3216 0000FB75 FF FF FF FF FF FF FF  
   3216 0000FB7C FF FF FF FF FF FF FF  
   3216 0000FB83 FF FF FF FF FF FF FF  
   3216 0000FB8A FF FF FF FF FF FF FF  
   3216 0000FB91 FF FF FF FF FF FF FF  
   3216 0000FB98 FF FF FF FF FF FF FF  
   3216 0000FB9F FF FF FF FF FF FF FF  
   3216 0000FBA6 FF FF FF FF FF FF FF  
   3216 0000FBAD FF FF FF FF FF FF FF  
   3216 0000FBB4 FF FF FF FF FF FF FF  
   3216 0000FBBB FF FF FF FF FF FF FF  
   3216 0000FBC2 FF FF FF FF FF FF FF  
   3216 0000FBC9 FF FF FF FF FF FF FF  
   3216 0000FBD0 FF FF FF FF FF FF FF  
   3216 0000FBD7 FF FF FF FF FF FF FF  
   3216 0000FBDE FF FF FF FF FF FF FF  
   3216 0000FBE5 FF FF FF FF FF FF FF  
   3216 0000FBEC FF FF FF FF FF FF FF  
   3216 0000FBF3 FF FF FF FF FF FF FF  
   3216 0000FBFA FF FF FF FF FF FF FF  
   3216 0000FC01 FF FF FF FF FF FF FF  
   3216 0000FC08 FF FF FF FF FF FF FF  
   3216 0000FC0F FF FF FF FF FF FF FF  
   3216 0000FC16 FF FF FF FF FF FF FF  
   3216 0000FC1D FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 61
noc_boot.a
   3216 0000FC24 FF FF FF FF FF FF FF  
   3216 0000FC2B FF FF FF FF FF FF FF  
   3216 0000FC32 FF FF FF FF FF FF FF  
   3216 0000FC39 FF FF FF FF FF FF FF  
   3216 0000FC40 FF FF FF FF FF FF FF  
   3216 0000FC47 FF FF FF FF FF FF FF  
   3216 0000FC4E FF FF FF FF FF FF FF  
   3216 0000FC55 FF FF FF FF FF FF FF  
   3216 0000FC5C FF FF FF FF FF FF FF  
   3216 0000FC63 FF FF FF FF FF FF FF  
   3216 0000FC6A FF FF FF FF FF FF FF  
   3216 0000FC71 FF FF FF FF FF FF FF  
   3216 0000FC78 FF FF FF FF FF FF FF  
   3216 0000FC7F FF FF FF FF FF FF FF  
   3216 0000FC86 FF FF FF FF FF FF FF  
   3216 0000FC8D FF FF FF FF FF FF FF  
   3216 0000FC94 FF FF FF FF FF FF FF  
   3216 0000FC9B FF FF FF FF FF FF FF  
   3216 0000FCA2 FF FF FF FF FF FF FF  
   3216 0000FCA9 FF FF FF FF FF FF FF  
   3216 0000FCB0 FF FF FF FF FF FF FF  
   3216 0000FCB7 FF FF FF FF FF FF FF  
   3216 0000FCBE FF FF FF FF FF FF FF  
   3216 0000FCC5 FF FF FF FF FF FF FF  
   3216 0000FCCC FF FF FF FF FF FF FF  
   3216 0000FCD3 FF FF FF FF FF FF FF  
   3216 0000FCDA FF FF FF FF FF FF FF  
   3216 0000FCE1 FF FF FF FF FF FF FF  
   3216 0000FCE8 FF FF FF FF FF FF FF  
   3216 0000FCEF FF FF FF FF FF FF FF  
   3216 0000FCF6 FF FF FF FF FF FF FF  
   3216 0000FCFD FF FF FF FF FF FF FF  
   3216 0000FD04 FF FF FF FF FF FF FF  
   3216 0000FD0B FF FF FF FF FF FF FF  
   3216 0000FD12 FF FF FF FF FF FF FF  
   3216 0000FD19 FF FF FF FF FF FF FF  
   3216 0000FD20 FF FF FF FF FF FF FF  
   3216 0000FD27 FF FF FF FF FF FF FF  
   3216 0000FD2E FF FF FF FF FF FF FF  
   3216 0000FD35 FF FF FF FF FF FF FF  
   3216 0000FD3C FF FF FF FF FF FF FF  
   3216 0000FD43 FF FF FF FF FF FF FF  
   3216 0000FD4A FF FF FF FF FF FF FF  
   3216 0000FD51 FF FF FF FF FF FF FF  
   3216 0000FD58 FF FF FF FF FF FF FF  
   3216 0000FD5F FF FF FF FF FF FF FF  
   3216 0000FD66 FF FF FF FF FF FF FF  
   3216 0000FD6D FF FF FF FF FF FF FF  
   3216 0000FD74 FF FF FF FF FF FF FF  
   3216 0000FD7B FF FF FF FF FF FF FF  
   3216 0000FD82 FF FF FF FF FF FF FF  
   3216 0000FD89 FF FF FF FF FF FF FF  
   3216 0000FD90 FF FF FF FF FF FF FF  
   3216 0000FD97 FF FF FF FF FF FF FF  
   3216 0000FD9E FF FF FF FF FF FF FF  
   3216 0000FDA5 FF FF FF FF FF FF FF  
   3216 0000FDAC FF FF FF FF FF FF FF  
   3216 0000FDB3 FF FF FF FF FF FF FF  
   3216 0000FDBA FF FF FF FF FF FF FF  
   3216 0000FDC1 FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 62
noc_boot.a
   3216 0000FDC8 FF FF FF FF FF FF FF  
   3216 0000FDCF FF FF FF FF FF FF FF  
   3216 0000FDD6 FF FF FF FF FF FF FF  
   3216 0000FDDD FF FF FF FF FF FF FF  
   3216 0000FDE4 FF FF FF FF FF FF FF  
   3216 0000FDEB FF FF FF FF FF FF FF  
   3216 0000FDF2 FF FF FF FF FF FF FF  
   3216 0000FDF9 FF FF FF FF FF FF FF  
   3216 0000FE00 FF FF FF FF FF FF FF  
   3216 0000FE07 FF FF FF FF FF FF FF  
   3216 0000FE0E FF FF FF FF FF FF FF  
   3216 0000FE15 FF FF FF FF FF FF FF  
   3216 0000FE1C FF FF FF FF FF FF FF  
   3216 0000FE23 FF FF FF FF FF FF FF  
   3216 0000FE2A FF FF FF FF FF FF FF  
   3216 0000FE31 FF FF FF FF FF FF FF  
   3216 0000FE38 FF FF FF FF FF FF FF  
   3216 0000FE3F FF FF FF FF FF FF FF  
   3216 0000FE46 FF FF FF FF FF FF FF  
   3216 0000FE4D FF FF FF FF FF FF FF  
   3216 0000FE54 FF FF FF FF FF FF FF  
   3216 0000FE5B FF FF FF FF FF FF FF  
   3216 0000FE62 FF FF FF FF FF FF FF  
   3216 0000FE69 FF FF FF FF FF FF FF  
   3216 0000FE70 FF FF FF FF FF FF FF  
   3216 0000FE77 FF FF FF FF FF FF FF  
   3216 0000FE7E FF FF FF FF FF FF FF  
   3216 0000FE85 FF FF FF FF FF FF FF  
   3216 0000FE8C FF FF FF FF FF FF FF  
   3216 0000FE93 FF FF FF FF FF FF FF  
   3216 0000FE9A FF FF FF FF FF FF FF  
   3216 0000FEA1 FF FF FF FF FF FF FF  
   3216 0000FEA8 FF FF FF FF FF FF FF  
   3216 0000FEAF FF FF FF FF FF FF FF  
   3216 0000FEB6 FF FF FF FF FF FF FF  
   3216 0000FEBD FF FF FF FF FF FF FF  
   3216 0000FEC4 FF FF FF FF FF FF FF  
   3216 0000FECB FF FF FF FF FF FF FF  
   3216 0000FED2 FF FF FF FF FF FF FF  
   3216 0000FED9 FF FF FF FF FF FF FF  
   3216 0000FEE0 FF FF FF FF FF FF FF  
   3216 0000FEE7 FF FF FF FF FF FF FF  
   3216 0000FEEE FF FF FF FF FF FF FF  
   3216 0000FEF5 FF FF FF FF FF FF FF  
   3216 0000FEFC FF FF FF FF FF FF FF  
   3216 0000FF03 FF FF FF FF FF FF FF  
   3216 0000FF0A FF FF FF FF FF FF FF  
   3216 0000FF11 FF FF FF FF FF FF FF  
   3216 0000FF18 FF FF FF FF FF FF FF  
   3216 0000FF1F FF FF FF FF FF FF FF  
   3216 0000FF26 FF FF FF FF FF FF FF  
   3216 0000FF2D FF FF FF FF FF FF FF  
   3216 0000FF34 FF FF FF FF FF FF FF  
   3216 0000FF3B FF FF FF FF FF FF FF  
   3216 0000FF42 FF FF FF FF FF FF FF  
   3216 0000FF49 FF FF FF FF FF FF FF  
   3216 0000FF50 FF FF FF FF FF FF FF  
   3216 0000FF57 FF FF FF FF FF FF FF  
   3216 0000FF5E FF FF FF FF FF FF FF  
   3216 0000FF65 FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:49 2017     Page 63
noc_boot.a
   3216 0000FF6C FF FF FF FF FF FF FF  
   3216 0000FF73 FF FF FF FF FF FF FF  
   3216 0000FF7A FF FF FF FF FF FF FF  
   3216 0000FF81 FF FF FF FF FF FF FF  
   3216 0000FF88 FF FF FF FF FF FF FF  
   3216 0000FF8F FF FF FF FF FF FF FF  
   3216 0000FF96 FF FF FF FF FF FF FF  
   3216 0000FF9D FF FF FF FF FF FF FF  
   3216 0000FFA4 FF FF FF FF FF FF FF  
   3216 0000FFAB FF FF FF FF FF FF FF  
   3216 0000FFB2 FF FF FF FF FF FF FF  
   3216 0000FFB9 FF FF FF FF FF FF FF  
   3216 0000FFC0 FF FF FF FF FF FF FF  
   3216 0000FFC7 FF FF FF FF FF FF FF  
   3216 0000FFCE FF FF FF FF FF FF FF  
   3216 0000FFD5 FF FF FF FF FF FF FF  
   3216 0000FFDC FF FF FF FF FF FF FF  
   3216 0000FFE3 FF FF FF FF FF FF FF  
   3216 0000FFEA FF FF FF FF FF FF FF  
   3216 0000FFF1 FF FF FF FF FF FF FF  
   3216 0000FFF8 FF FF FF FF FF FF     
   3217 0000FFFE 80 F2                   		dw		start
