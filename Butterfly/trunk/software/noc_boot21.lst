Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 1
noc_boot21.asm


Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 1
noc_boot21.asm


Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 1
noc_boot21.asm


Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 1
noc_boot21.asm


Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 1
noc_boot21.asm


Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 1
noc_boot21.asm


Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 1
noc_boot21.asm


Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 1
noc_boot21.asm


Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 1
noc_boot21.asm


Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 1
noc_boot21.asm


Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 1
noc_boot21.asm


Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 1
noc_boot21.asm


Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 1
noc_boot21.asm

                                        ; ============================================================================
                                        ;        __
                                        ;   \\__/ o\    (C) 2017  Robert Finch, Waterloo
                                        ;    \  __ /    All rights reserved.
                                        ;     \/_//     robfinch<remove>@finitron.ca
                                        ;       ||
                                        ;  
                                        ;
                                        ; This source file is free software: you can redistribute it and/or modify 
                                        ; it under the terms of the GNU Lesser General Public License as published 
                                        ; by the Free Software Foundation, either version 3 of the License, or     
                                        ; (at your option) any later version.                                      
                                        ;                                                                          
                                        ; This source file is distributed in the hope that it will be useful,      
                                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                                        ; GNU General Public License for more details.                             
                                        ;                                                                          
                                        ; You should have received a copy of the GNU General Public License        
                                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                                        ;                                    
                                        ;                                      
                                        ; This boot rom for the input node $21.
                                        ; ============================================================================
                                        ;
     26 = 0D                            CR	= 13
     27 = 0A                            LF	= 10
     28 = 09                            CTRLH	equ		9
                                        
     30 = 12                            SC_LSHIFT	EQU		$12
     31 = 59                            SC_RSHIFT	EQU		$59
     32 = 00F0                          SC_KEYUP	EQU		$F0
     33 = 00E0                          SC_EXTEND	EQU		$E0
     34 = 14                            SC_CTRL		EQU		$14
     35 = 11                            SC_ALT		EQU		$11
     36 = 71                            SC_DEL		EQU		$71		; extend
     37 = 58                            SC_LCTRL	EQU		$58
     38 = 77                            SC_NUMLOCK	EQU		$77
     39 = 7E                            SC_SCROLLLOCK	EQU	$7E
     40 = 58                            SC_CAPSLOCK	EQU		$58
                                        
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 1
MessageTypes.asm

                                        
     43 = 01                            MT_RST		equ		1
     44 = 02                            MT_RST_ACK	equ		2
     45 = 03                            MT_STOP		equ		3
     46 = 04                            MT_KEYSTROKE			equ	4
     47 = 05                            MT_SET_INPUT_FOCUS		equ	5
     48 = 06                            MT_BUTTON_STATUS		equ	6
     49 = 0A                            MT_START_BASIC_LOAD		equ	10
     50 = 0B                            MT_LOAD_BASIC_CHAR		equ	11
     51 = 0C                            MT_RUN_BASIC_PROG		equ	12
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 1
noc_boot21.asm


                                      
                                        
     54 = 0F                            HTInputFocus	equ	15
     55 = 10                            KeyState1	equ	16
     56 = 11                            KeyState2	equ	17
     57 = 20                            txBuf	equ		32
     58 = 30                            rxBuf	equ		48
                                        
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 2
noc_boot21.asm
     60 = 000000000000B000                              ROUTER		equ	$B000
     61 = 10                            RTR_RXSTAT	equ	$10
     62 = 12                            RTR_TXSTAT	equ	$12
     63 = 00                            ROUTER_TRB	equ	0
                                        
     65 = 000000000000B200                              BTNS		equ	$B200
     66 = 000000000000B210                              KBD			equ	$B210
     67 = 01                            KBD_STAT	equ	1
                                        
     69 = 0F                            MSG_DST		equ	15
     70 = 0E                            MSG_SRC		equ	14
     71 = 07                            MSG_TYPE	equ	7
                                        
                                        		.code
                                        		cpu		Butterfly16
                                        		org		0xE000
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 1
tb.asm

                                        ;****************************************************************;
                                        ;                                                                ;
                                        ;		Tiny BASIC for the Finitron Butterfly                    ;
                                        ;                                                                ;
                                        ; Derived from a 68000 derivative of Palo Alto Tiny BASIC as     ;
                                        ; published in the May 1976 issue of Dr. Dobb's Journal.         ;
                                        ; Adapted to the 68000 by:                                       ;
                                        ;	Gordon brndly						                         ;
                                        ;	12147 - 51 Street					                         ;
                                        ;	Edmonton AB  T5W 3G8					                     ;
                                        ;	Canada							                             ;
                                        ;	(updated mailing address for 1996)			                 ;
                                        ;                                                                ;
                                        ; Adapted to the Butterfly by:                                    ;
                                        ;    Robert Finch                                                ;
                                        ;    Ontario, Canada                                             ;
                                        ;	 rob<remove>@finitron.ca                                     ;  
                                        ;****************************************************************;
                                        ;    Copyright (C) 2005 by Robert Finch. This program may be	 ;
                                        ;    freely distributed for personal use only. All commercial	 ;
                                        ;		       rights are reserved.			                     ;
                                        ;****************************************************************;
                                        ;
                                        ; Register Usage
                                        ; r8 = text pointer (global usage)
                                        ; r3,r4 = inputs parameters to subroutines
                                        ; r2 = return value
                                        ;
                                        ;* Vers. 1.0  1984/7/17	- Original version by Gordon brndly
                                        ;*	1.1  1984/12/9	- Addition of '0x' print term by Marvin Lipford
                                        ;*	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                                        
                                        ;	OPT	FRS,BRS 	forward ref.'s & brnches default to short
                                        
                                        ;XMIT_FULL		equ	0x40		; the transmit buffer is full
                                        ;DATA_PRESENT	equ	0x08		; there is data preset at the serial port bc_uart3
    112 = 01                            DATA_PRESENT	equ	0x01		; there is data preset at the serial port bc_uart3
    113 = 20                            XMIT_NOT_FULL	equ	0x20
                                        
    115 = 00000000FFFFDC40                              TS_TIMER	equ		0xFFFFDC40		; system time slice timer
    116 = 00000000FFFFDC50                              KBD			equ		0xFFFFDC50
                                        
    118 = 00000000FFFFDCA0                              RAND		equ		0xFFFFDCA0
    119 = 00000000FFFFD800                              VIC			equ		0xFFFFD800
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 2
tb.asm
                                        
    121 = 2000                          VIDEORAM	equ		0x00002000
                                        
                                        ; BOOT ROM routines
                                        
    125 = 0000000FFFFFF804                              getSerial	equ		0xFFFFFF804	; get a serial port character
    126 = 0000000FFFFFF808                              peekSerial	equ		0xFFFFFF808	; get a serial port character
    127 = 0000000FFFFFF80C                              putSerial	equ		0xFFFFFF80C	; put a character to serial port
    128 = 0000000FFFFFF82C                              clearScreen	equ		0xFFFFFF82C	; clear the screen
    129 = 0000000FFFFFF840                              getKbdCharWait	equ	0xFFFFFF840
    130 = 0000000FFFFFF844                              getKbdChar		equ	0xFFFFFF844
                                        
    132 = 20                            warmStart   equ     0x20
    133 = 24                            usrJmp      equ     0x24
                                        
    135 = 0D                            CR		equ	0x0D		; ASCII equates
    136 = 0A                            LF		equ	0x0A
    137 = 09                            TAB		equ	0x09
    138 = 03                            CTRLC	equ	0x03
    139 = 08                            CTRLH	equ	0x08
    140 = 13                            CTRLS	equ	0x13
    141 = 18                            CTRLX	equ	0x18
                                        
    143 = 50                            BUFLEN	equ	80	;	length of keyboard input buffer
                                        
                                        	code
                                        ;	org	0xC000	;
                                        ;
                                        ; Standard jump table. You can change these addresses if you are
                                        ; customizing this interpreter for a different environment.
                                        ;
    153 0000E000 0D AE                  START	jmp	CSTART	;	Cold Start entry point
    154 0000E002 45 AE                  GOWARM	jmp	WSTART	;	Warm Start entry point
    155 0000E004 85 40 0F AE            GOOUT	jmp	OUTC	;	Jump to character-out routine
    156 0000E008 85 40 0E AE            GOIN	jmp	INC		;Jump to character-in routine
    157 0000E00C 88 40 0C AE            GOAUXO	jmp	AUXOUT	;	Jump to auxiliary-out routine
    158 0000E010 8A 40 07 AE            GOAUXI	jmp	AUXIN	;	Jump to auxiliary-in routine
    159 0000E014 8D 40 0D AE            GOBYE	jmp	BYEBYE	;	Jump to monitor, DOS, etc.
                                        ;
                                        ; Modifiable system constants:
                                        ;
    163 0000E018 00 02                  TXTBGN	dw	0x0200		;beginning of program memory
    164 0000E01A 00 1E                  ENDMEM	dw	0x1E00	;	end of available memory
                                        ;
                                        ; The main interpreter starts here:
                                        ;
                                        ; Usage
                                        ; r1 = temp
                                        ; r8 = text buffer pointer
                                        ; r12 = end of text in text buffer
                                        ;
    173 0000E01C                        CSTART
                                        	; First save off the link register and OS sp value
    175 0000E01C FC 6E                   	sub		sp,sp,#4
    176 0000E01E E1 DF                   	sw		lr,[sp]
    177 0000E020 08 40 05 DE             	sw		sp,OSSP
    178 0000E024 01 4E 0B FE             	lw		sp,ENDMEM	; initialize stack pointer
    179 0000E028 E1 DF                   	sw      lr,[sp]    ; save off return address
                                        ;	lw		r1,#TXT_WIDTH
                                        ;	sb		r1,txtWidth
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 3
tb.asm
                                        ;	lw		r1,#TXT_HEIGHT
                                        ;	sb		r1,txtHeight
    184 0000E02A 03 40 02 C0             	sb		r0,cursx	; set screen output
    185 0000E02E 03 40 03 C0             	sb		r0,cursy
    186 0000E032 03 40 0C C0             	sb		r0,cursFlash
    187 0000E036 03 40 05 D0             	sw		r0,pos
    188 0000E03A F2 4B 00 12             	lw		r2,#0xBF20	; black chars, yellow background
    189 0000E03E 03 40 09 D2             	sw		r2,charToPrint
    190 0000E042 BF 48 02 AF             	call	clearScreen
    191 0000E046 1D 4F 0C 11             	lea		r1,msgInit	;	tell who we are
    192 0000E04A 82 40 0D AF             	call	PRMESGAUX
    193 0000E04E 1D 4F 0C 11             	lea		r1,msgInit	;	tell who we are
    194 0000E052 81 40 0A AF             	call	PRMESG
    195 0000E056 01 4E 09 F1             	lw		r1,TXTBGN	;	init. end-of-program pointer
    196 0000E05A 09 40 07 D1             	sw		r1,TXTUNF
    197 0000E05E 01 4E 0B F1             	lw		r1,ENDMEM	;	get address of end of memory
    198 0000E062 80 4F 10 11             	sub		r1,r1,#2048	; 	reserve 2K for the stack
    199 0000E066 0A 40 01 D1             	sw		r1,STKBOT
    200 0000E06A 00 4E 10 11             	sub     r1,r1,#8192 ;   1000 vars
    201 0000E06E 09 40 09 D1             	sw      r1,VARBGN
    202 0000E072 15 40 0E AF             	call    clearVars   ; clear the variable area
    203 0000E076 09 40 09 F1             	lw      r1,VARBGN   ; calculate number of bytes free
    204 0000E07A 09 40 07 F3             	lw		r3,TXTUNF
    205 0000E07E 32 21                   	sub     r1,r3
    206 0000E080 00 12                   	lw		r2,#0
    207 0000E082 6F 40 09 AF             	call	PRTNUM
    208 0000E086 28 4F 0A 11             	lea		r1,msgBytesFree
    209 0000E08A 7F 40 0E AF             	call	PRMESG
    210 0000E08E                        WSTART
    211 0000E08E 08 40 0D D0             	sw		r0,LOPVAR   ; initialize internal variables
    212 0000E092 08 40 09 D0             	sw		r0,STKGOS
    213 0000E096 08 40 07 D0             	sw		r0,CURRNT	;	current line number pointer = 0
    214 0000E09A 01 4E 0B FE             	lw		sp,ENDMEM	;	init S.P. again, just in case
    215 0000E09E 29 4F 08 11             	lea		r1,msgReady	;	display "Ready"
    216 0000E0A2 7F 40 02 AF             	call	PRMESG
    217 0000E0A6                        ST3
    218 0000E0A6 03 40 0E 11             	lw		r1,#'>'		; Prompt with a '>' and
    219 0000E0AA 5E 40 09 AF             	call	GETLN		; read a line.
    220 0000E0AE 7B 40 02 AF             	call	TOUPBUF 	; convert to upper case
    221 0000E0B2 80 1C                   	lw		r12,r8		; save pointer to end of line
    222 0000E0B4 0A 40 0E 18             	lea		r8,BUFFER	; point to the beginning of line
    223 0000E0B8 77 40 0E AF             	call	TSTNUM		; is there a number there?
    224 0000E0BC 79 40 0D AF             	call	IGNBLK		; skip trailing blanks
    225 0000E0C0 16 21                   	or      r1,r1       ; does line no. exist? (or nonzero?)
    226 0000E0C2 C2 A8                   	beq		DIRECT		; if not, it's a direct statement
    227 0000E0C4 00 40 11 10             	cmp		r1,#0xFFFF	; see if line no. is <= 16 bits
    228 0000E0C8 04 A6                   	bleu	ST2
    229 0000E0CA 2B 4F 06 11             	lea		r1,msgLineRange	; if not, we've overflowed
    230 0000E0CE 5B 40 0D AE             	br		ERROR
    231 0000E0D2                        ST2
                                            ; ugliness - store a character at potentially an
                                            ; odd address (unaligned).
    234 0000E0D2 10 12                   	lw		r2,r1       ; r2 = line number
    235 0000E0D4 8E C2                   	sb		r2,-2[r8]
    236 0000E0D6 A1 32                   	shr		r2,#1
    237 0000E0D8 A1 32                   	shr		r2,#1
    238 0000E0DA A1 32                   	shr		r2,#1
    239 0000E0DC A1 32                   	shr		r2,#1
    240 0000E0DE A1 32                   	shr		r2,#1
    241 0000E0E0 A1 32                   	shr		r2,#1
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 4
tb.asm
    242 0000E0E2 A1 32                   	shr		r2,#1
    243 0000E0E4 A1 32                   	shr		r2,#1
    244 0000E0E6 8F C2                   	sb		r2,-1[r8]	; store the binary line no.
    245 0000E0E8 FE 68                   	sub		r8,r8,#2
    246 0000E0EA 61 40 0D AF             	call	FNDLN		; find this line in save area
    247 0000E0EE E0 31                   	tsr		r1,sr
    248 0000E0F0 90 1D                   	lw		r13,r9		; save possible line pointer
    249 0000E0F2 F0 31                   	trs		r1,sr
    250 0000E0F4 11 A9                   	bne		ST4			; if not found, insert
                                        	; here we found the line, so we're replacing the line
                                        	; in the text area
                                        	; first step - delete the line
    254 0000E0F6 00 11                   	lw		r1,#0
    255 0000E0F8 63 40 03 AF             	call	FNDNXT		; find the next line (into r9)
    256 0000E0FC 0A A7                   	bgtu	ST6			; no more lines
    257 0000E0FE 90 11                   	lw		r1,r9		; r1 = pointer to next line
    258 0000E100 D0 12                   	lw		r2,r13		; pointer to line to be deleted
    259 0000E102 09 40 07 F3             	lw		r3,TXTUNF	; points to top of save area
    260 0000E106 63 40 07 AF             	call	MVUP		; move up to delete
    261 0000E10A 09 40 07 D2             	sw		r2,TXTUNF	; update the end pointer
                                        	; we moved the lines of text after the line being
                                        	; deleted down, so the pointer to the next line
                                        	; needs to be reset
    265 0000E10E D0 19                   	lw		r9,r13
    266 0000E110 03 AE                   	br		ST4
                                        	; here there were no more lines, so just move the
                                        	; end of text pointer down
    269 0000E112                        ST6
    270 0000E112 09 40 07 DD             	sw		r13,TXTUNF
    271 0000E116 D0 19                   	lw		r9,r13
    272 0000E118                        ST4
                                        	; here we're inserting because the line wasn't found
                                        	; or it was deleted	from the text area
    275 0000E118 C0 11                   	lw		r1,r12		; calculate the length of new line
    276 0000E11A 82 21                   	sub		r1,r8
    277 0000E11C 1D 10                   	cmp		r1,#3		; is it just a line no. & CR?
    278 0000E11E C3 B2                   	ble		ST3			; if so, it was just a delete
                                        
    280 0000E120 09 40 07 FB             	lw		r11,TXTUNF	; compute new end of text
    281 0000E124 B0 1A                   	lw		r10,r11		; r10 = old TXTUNF
    282 0000E126 10 2B                   	add		r11,r1		; r11 = new top of TXTUNF (r1=line length)
                                        
    284 0000E128 09 40 09 F1             	lw		r1,VARBGN	; see if there's enough room
    285 0000E12C 1D 2B                   	cmp		r11,r1
    286 0000E12E 04 A4                   	bltu	ST5
    287 0000E130 39 4F 01 11             	lea		r1,msgTooBig	; if not, say so
    288 0000E134 58 40 0A AE             	jmp		ERROR
                                        
                                        	; open a space in the text area
    291 0000E138                        ST5
    292 0000E138 09 40 07 DB             	sw		r11,TXTUNF	; if so, store new end position
    293 0000E13C A0 11                   	lw		r1,r10		; points to old end of text
    294 0000E13E B0 12                   	lw		r2,r11		; points to new end of text
    295 0000E140 90 13                   	lw		r3,r9       ; points to start of line after insert line
    296 0000E142 62 40 00 AF             	call	MVDOWN		; move things out of the way
                                        
                                        	; copy line into text space
    299 0000E146 80 11                   	lw		r1,r8		; set up to do the insertion; move from buffer
    300 0000E148 D0 12                   	lw		r2,r13		; to vacated space
    301 0000E14A C0 13                   	lw		r3,r12		; until end of buffer
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 5
tb.asm
    302 0000E14C 61 40 04 AF             	call	MVUP		; do it
    303 0000E150 AA BE                   	br		ST3			; go back and get another line
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** Tables *** DIRECT *** EXEC ***
                                        ;
                                        ; This section of the code tests a string against a table. When
                                        ; a match is found, control is transferred to the section of
                                        ; code according to the table.
                                        ;
                                        ; At 'EXEC', r8 should point to the string, r9 should point to
                                        ; the character table, and r10 should point to the execution
                                        ; table. At 'DIRECT', r8 should point to the string, r9 and
                                        ; r10 will be set up to point to TAB1 and TAB1_1, which are
                                        ; the tables of all direct and statement commands.
                                        ;
                                        ; A '.' in the string will terminate the test and the partial
                                        ; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                                        ; 'PRIN.', or 'PRINT' will all match 'PRINT'.
                                        ;
                                        ; There are two tables: the character table and the execution
                                        ; table. The character table consists of any number of text items.
                                        ; Each item is a string of characters with the last character's
                                        ; high bit set to one. The execution table holds a 32-bit
                                        ; execution addresses that correspond to each entry in the
                                        ; character table.
                                        ;
                                        ; The end of the character table is a 0 byte which corresponds
                                        ; to the default routine in the execution table, which is
                                        ; executed if none of the other table items are matched.
                                        ;
                                        ; Character-matching tables:
    336 0000E152                        TAB1
    337 0000E152 4C 49 53 D4             	db	"LIS",('T'+0x80)        ; Direct commands
    338 0000E156 4C 4F 41 C4             	db	"LOA",('D'+0x80)
    339 0000E15A 4E 45 D7                	db	"NE",('W'+0x80)
    340 0000E15D 52 55 CE                	db	"RU",('N'+0x80)
    341 0000E160 53 41 56 C5             	db	"SAV",('E'+0x80)
    342 0000E164                        TAB2
    343 0000E164 4E 45 58 D4             	db	"NEX",('T'+0x80)         ; Direct / statement
    344 0000E168 4C 45 D4                	db	"LE",('T'+0x80)
    345 0000E16B 49 C6                   	db	"I",('F'+0x80)
    346 0000E16D 47 4F 54 CF             	db	"GOT",('O'+0x80)
    347 0000E171 47 4F 53 55 C2          	db	"GOSU",('B'+0x80)
    348 0000E176 52 45 54 55 52 CE       	db	"RETUR",('N'+0x80)
    349 0000E17C 52 45 CD                	db	"RE",('M'+0x80)
    350 0000E17F 46 4F D2                	db	"FO",('R'+0x80)
    351 0000E182 49 4E 50 55 D4          	db	"INPU",('T'+0x80)
    352 0000E187 50 52 49 4E D4          	db	"PRIN",('T'+0x80)
    353 0000E18C 50 4F 4B 45 D7          	db	"POKE",('W'+0x80)
    354 0000E191 50 4F 4B C5             	db	"POK",('E'+0x80)
    355 0000E195 53 54 4F D0             	db	"STO",('P'+0x80)
    356 0000E199 42 59 C5                	db	"BY",('E'+0x80)
    357 0000E19C 53 59 D3                	db	"SY",('S'+0x80)
    358 0000E19F 43 4C D3                	db	"CL",('S'+0x80)
    359 0000E1A2 43 4C D2                    db  "CL",('R'+0x80)
    360 0000E1A5 52 44 43 C6                 db	"RDC",('F'+0x80)
    361 0000E1A9 00                      	db	0
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 6
tb.asm
    362 0000E1AA                        TAB4
    363 0000E1AA 4E 4F 44 45 4E 55 CD    	db	"NODENU",('M'+0x80)
                                      
    364 0000E1B1 50 45 45 4B C3          	db	"PEEK",('C'+0x80)        ;Functions
    365 0000E1B6 50 45 45 4B D7          	db	"PEEK",('W'+0x80)        ;Functions
    366 0000E1BB 50 45 45 CB             	db	"PEE",('K'+0x80)         ;Functions
    367 0000E1BF 52 4E C4                	db	"RN",('D'+0x80)
    368 0000E1C2 41 42 D3                	db	"AB",('S'+0x80)
    369 0000E1C5 53 49 5A C5             	db	"SIZ",('E'+0x80)
    370 0000E1C9 55 53 D2                	db  "US",('R'+0x80)
    371 0000E1CC 00                      	db	0
    372 0000E1CD                        TAB5
    373 0000E1CD 54 CF                   	db	"T",('O'+0x80)           ;"TO" in "FOR"
    374 0000E1CF 00                      	db	0
    375 0000E1D0                        TAB6
    376 0000E1D0 53 54 45 D0             	db	"STE",('P'+0x80)         ;"STEP" in "FOR"
    377 0000E1D4 00                      	db	0
    378 0000E1D5                        TAB8
    379 0000E1D5 3E BD                   	db	'>',('='+0x80)           ;Relational operators
    380 0000E1D7 3C BE                   	db	'<',('>'+0x80)
    381 0000E1D9 BE                      	db	('>'+0x80)
    382 0000E1DA BD                      	db	('='+0x80)
    383 0000E1DB 3C BD                   	db	'<',('='+0x80)
    384 0000E1DD BC                      	db	('<'+0x80)
    385 0000E1DE 00                      	db	0
    386 0000E1DF                        TAB9
    387 0000E1DF 41 4E C4                    db  "AN",('D'+0x80)
    388 0000E1E2 00                          db  0
    389 0000E1E3                        TAB10
    390 0000E1E3 4F D2                       db  "O",('R'+0x80)
    391 0000E1E5 00                          db  0
                                        
    393 0000E1E6 FF FF                   	.align	4
                                        
                                        ;* Execution address tables:
    396 0000E1E8                        TAB1_1
    397 0000E1E8 50 E3                   	dw	LISTX			;Direct commands
    398 0000E1EA B6 E5                   	dw	LOAD
    399 0000E1EC 9C E2                   	dw	NEW
    400 0000E1EE B2 E2                   	dw	RUN
    401 0000E1F0 4A E6                   	dw	SAVE
    402 0000E1F2                        TAB2_1
    403 0000E1F2 A8 E4                   	dw	NEXT		;	Direct / statement
    404 0000E1F4 A8 E5                   	dw	LET
    405 0000E1F6 02 E5                   	dw	IF
    406 0000E1F8 14 E3                   	dw	GOTO
    407 0000E1FA EA E3                   	dw	GOSUB
    408 0000E1FC 1A E4                   	dw	RETURN
    409 0000E1FE 0C E5                   	dw	IF2			; REM
    410 0000E200 44 E4                   	dw	FOR
    411 0000E202 2A E5                   	dw	INPUT
    412 0000E204 86 E3                   	dw	PRINT
    413 0000E206 74 E7                   	dw	POKEW
    414 0000E208 54 E7                   	dw	POKE
    415 0000E20A AA E2                   	dw	STOP
    416 0000E20C 14 E0                   	dw	GOBYE
    417 0000E20E 8C E7                   	dw	SYSX
    418 0000E210 CA F1                   	dw	_cls
    419 0000E212 2E E3                   	dw  _clr
    420 0000E214 14 E2                   	dw	_rdcf
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 7
tb.asm
    421 0000E216 A0 E5                   	dw	DEFLT
    422 0000E218                        TAB4_1
    423 0000E218 C8 EB                   	dw	NODENUM
    424 0000E21A 0A EB                   	dw  PEEKC
    425 0000E21C 18 EB                   	dw  PEEKW
    426 0000E21E FE EA                   	dw	PEEK			;Functions
    427 0000E220 38 EB                   	dw	RND
    428 0000E222 92 EB                   	dw	ABS
    429 0000E224 B8 EB                   	dw	SIZEX
    430 0000E226 24 EB                   	dw  USRX
    431 0000E228 34 E9                   	dw	XP40
    432 0000E22A                        TAB5_1
    433 0000E22A 5C E4                   	dw	FR1			;"TO" in "FOR"
    434 0000E22C 48 EC                   	dw	QWHAT
    435 0000E22E                        TAB6_1
    436 0000E22E 70 E4                   	dw	FR2			;"STEP" in "FOR"
    437 0000E230 76 E4                   	dw	FR3
    438 0000E232                        TAB8_1
    439 0000E232 56 E8                   	dw	XP11	;>=		Relational operators
    440 0000E234 60 E8                   	dw	XP12	;<>
    441 0000E236 6A E8                   	dw	XP13	;>
    442 0000E238 7E E8                   	dw	XP15	;=
    443 0000E23A 74 E8                   	dw	XP14	;<=
    444 0000E23C 88 E8                   	dw	XP16	;<
    445 0000E23E A2 E8                   	dw	XP17
    446 0000E240                        TAB9_1
    447 0000E240 E2 E7                       dw  XP_AND
    448 0000E242 EA E7                       dw  XP_ANDX
    449 0000E244                        TAB10_1
    450 0000E244 BE E7                       dw  XP_OR
    451 0000E246 C6 E7                       dw  XP_ORX
                                        
                                        ;*
                                        ; r3 = match flag (trashed)
                                        ; r9 = text table
                                        ; r10 = exec table
                                        ; r11 = trashed
    458 0000E248                        DIRECT
    459 0000E248 15 4E 02 19             	lea		r9,TAB1
    460 0000E24C 1E 4E 08 1A             	lea		r10,TAB1_1
    461 0000E250                        EXEC
    462 0000E250 F0 1B                   	lw		r11,lr		; save link reg
    463 0000E252 6D 40 02 AF             	call	IGNBLK		; ignore leading blanks
    464 0000E256 B0 1F                   	lw		lr,r11		; restore link reg
    465 0000E258 80 1B                   	lw		r11,r8		; save the pointer
    466 0000E25A 00 13                   	lw		r3,#0		; clear match flag
    467 0000E25C                        EXLP
    468 0000E25C 80 E1                   	lb		r1,[r8]		; get the program character
    469 0000E25E 01 68                   	add		r8,r8,#1
    470 0000E260 90 E2                   	lb		r2,[r9]		; get the table character
    471 0000E262 02 A9                   	bne		EXNGO		; If end of table,
    472 0000E264 B0 18                   	lw		r8,r11		;	restore the text pointer and...
    473 0000E266 12 AE                   	br		EXGO		;   execute the default.
    474 0000E268                        EXNGO
    475 0000E268 3D 21                   	cmp		r1,r3		; Else check for period...
    476 0000E26A 10 A8                   	beq		EXGO		; if so, execute
    477 0000E26C 07 40 5F 32             	and		r2,#0x7f	; ignore the table's high bit
    478 0000E270 1D 22                   	cmp		r2,r1		;		is there a match?
    479 0000E272 07 A8                   	beq		EXMAT
    480 0000E274 04 6A                   	add		r10,r10,#4	;if not, try the next entry
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 8
tb.asm
    481 0000E276 B0 18                   	lw		r8,r11		; reset the program pointer
    482 0000E278 00 13                   	lw		r3,#0		; sorry, no match
    483 0000E27A                        EX1
    484 0000E27A 01 69                   	add		r9,r9,#1
    485 0000E27C 9F E1                   	lb		r1,-1[r9]	; get to the end of the entry
    486 0000E27E FD BB                   	bpl		EX1
    487 0000E280 ED BE                   	br		EXLP		; back for more matching
    488 0000E282                        EXMAT
    489 0000E282 02 40 0E 13             	lw		r3,#'.'		; we've got a match so far
    490 0000E286 01 69                   	add		r9,r9,#1
    491 0000E288 9F E1                   	lb		r1,-1[r9]	; end of table entry?
    492 0000E28A E8 BB                   	bpl		EXLP		; if not, go back for more
    493 0000E28C                        EXGO
    494 0000E28C 01 4B 00 E1             	lb		r1,ROUTER+RTR_RXSTAT
    495 0000E290 03 A8                   	beq		EXGO1
    496 0000E292 FF BF                   	call	Recv
    497 0000E294 91 40 02 AF             	call	RecvDispatch
    498 0000E298                        EXGO1
    499 0000E298 A1 FB                   	lw		r11,[r10]	; execute the appropriate routine
    500 0000E29A B0 80                   	jmp		[r11]
                                        
                                        
                                        ;    lb      r1,[r8]     ; get token from text space
                                        ;    bpl
                                        ;    and     r1,#0x7f
                                        ;    shl     r1,#2       ; * 4 - word offset
                                        ;    add     r1,r1,#TAB1_1
                                        ;    lw      r1,[r1]
                                        ;    jmp     [r1]
                                        
                                            
                                        ;
                                        ; What follows is the code to execute direct and statement
                                        ; commands. Control is transferred to these points via the command
                                        ; table lookup code of 'DIRECT' and 'EXEC' in the last section.
                                        ; After the command is executed, control is transferred to other
                                        ; sections as follows:
                                        ;
                                        ; For 'LISTX', 'NEW', and 'STOP': go back to the warm start point.
                                        ; For 'RUN': go execute the first stored line if any; else go
                                        ; back to the warm start point.
                                        ; For 'GOTO' and 'GOSUB': go execute the target line.
                                        ; For 'RETURN' and 'NEXT'; go back to saved return line.
                                        ; For all others: if 'CURRNT' is 0, go to warm start; else go
                                        ; execute next command. (This is done in 'FINISH'.)
                                        ;
                                        ;******************************************************************
                                        ;
                                        ; *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                                        ;
                                        ; 'NEW<CR>' sets TXTUNF to point to TXTBGN
                                        ;
                                        ; 'STOP<CR>' goes back to WSTART
                                        ;
                                        ; 'RUN<CR>' finds the first stored line, stores its address
                                        ; in CURRNT, and starts executing it. Note that only those
                                        ; commands in TAB2 are legal for a stored program.
                                        ;
                                        ; RUN ON <node number> sends a run command to the specified node
                                        ;
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 9
tb.asm
                                        ; There are 3 more entries in 'RUN':
                                        ; 'RUNNXL' finds next line, stores it's address and executes it.
                                        ; 'RUNTSL' stores the address of this line and executes it.
                                        ; 'RUNSML' continues the execution on same line.
                                        ;
                                        ; 'GOTO expr<CR>' evaluates the expression, finds the target
                                        ; line, and jumps to 'RUNTSL' to do it.
                                        ;
    549 0000E29C                        NEW
    550 0000E29C 4C 40 00 AF             	call	ENDCHK
    551 0000E2A0 01 4E 09 F1             	lw		r1,TXTBGN
    552 0000E2A4 09 40 07 D1             	sw		r1,TXTUNF	;	set the end pointer
    553 0000E2A8 44 AF                   	call    clearVars
                                        
    555 0000E2AA                        STOP
    556 0000E2AA 4B 40 09 AF             	call	ENDCHK
    557 0000E2AE EE 4F 0E AE             	br		WSTART		; WSTART will reset the stack
                                        
    559 0000E2B2                        RUN
    560 0000E2B2 6A 40 02 AF             	call	IGNBLK
    561 0000E2B6 80 E1                   	lb		r1,[r8]
    562 0000E2B8 FB 4F 11 10             	cmp		r1,#'O'
    563 0000E2BC 10 A9                   	bne		RUN1
    564 0000E2BE 81 E1                   	lb		r1,1[r8]
    565 0000E2C0 FB 4F 12 10             	cmp		r1,#'N'
    566 0000E2C4 0C A9                   	bne		RUN1
    567 0000E2C6 02 68                   	add		r8,r8,#2
    568 0000E2C8 26 40 0F AF             	call	OREXPR
    569 0000E2CC 02 40 0F C1             	sb		r1,txBuf+MSG_DST
                                        	lb		r1,#$11
    571 0000E2D0 02 40 0E C1             	sb		r1,txBuf+MSG_SRC
                                        	lb		r1,#13
    573 0000E2D4 02 40 07 C1             	sb		r1,txBuf+MSG_TYPE
    574 0000E2D8 FF BF                   	call	Xmit
    575 0000E2DA ED 4F 08 AE             	br		WSTART
    576 0000E2DE                        RUN1
    577 0000E2DE 49 40 0F AF             	call	ENDCHK
    578 0000E2E2 01 4E 09 F8             	lw		r8,TXTBGN	;	set pointer to beginning
    579 0000E2E6 08 40 07 D8             	sw		r8,CURRNT
    580 0000E2EA 23 AF                   	call    clearVars
                                        
    582 0000E2EC                        RUNNXL					; RUN <next line>
    583 0000E2EC 08 40 07 F1             	lw		r1,CURRNT	; executing a program?
    584 0000E2F0 EC 4F 0D A8             	beq		WSTART		; if not, we've finished a direct stat.
    585 0000E2F4 00 11                   	lw		r1,#0	    ; else find the next line number
    586 0000E2F6 80 19                   	lw		r9,r8
    587 0000E2F8 51 40 0E AF             	call	FNDLNP		; search for the next line
    588 0000E2FC EC 4F 07 A7             	bgtu	WSTART		; if we've fallen off the end, stop
                                        
    590 0000E300                        RUNTSL					; RUN <this line>
    591 0000E300 08 40 07 D9             	sw		r9,CURRNT	; set CURRNT to point to the line no.
    592 0000E304 92 18                   	lea		r8,2[r9]	; set the text pointer to
                                        
    594 0000E306                        RUNSML                  ; RUN <same line>
    595 0000E306 6A 40 0E AF             	call	CHKIO		; see if a control-C was pressed
    596 0000E30A 16 4E 04 19             	lea		r9,TAB2		; find command in TAB2
    597 0000E30E 1F 4E 02 1A             	lea		r10,TAB2_1
    598 0000E312 9E BE                   	br		EXEC		; and execute it
                                        
    600 0000E314                        GOTO
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 10
tb.asm
    601 0000E314 24 40 09 AF             	call	OREXPR		;evaluate the following expression
    602 0000E318 10 15                   	lw      r5,r1
    603 0000E31A 48 40 01 AF             	call	ENDCHK		;must find end of line
    604 0000E31E 50 11                   	lw      r1,r5
    605 0000E320 50 40 02 AF             	call	FNDLN		; find the target line
    606 0000E324 ED B8                   	beq		RUNTSL		; go do it
    607 0000E326 35 4F 0D 11             	lea		r1,msgBadGotoGosub
    608 0000E32A 48 40 0F AE             	br		ERROR		; no such line no.
                                        
                                        
    611 0000E32E                        _clr
    612 0000E32E 01 AF                       call    clearVars
    613 0000E330 58 AE                       br      FINISH
                                        
                                        ; Clear the variable area of memory
    616 0000E332                        clearVars
    617 0000E332 FC 6E                       sub     sp,sp,#4
    618 0000E334 E1 DF                       sw      lr,[sp]
    619 0000E336 E3 D6                       sw      r6,2[sp]
    620 0000E338 80 40 00 16                 lw      r6,#2048    ; number of words to clear
    621 0000E33C 09 40 09 F1                 lw      r1,VARBGN
    622 0000E340                        cv1
    623 0000E340 11 D0                       sw      r0,[r1]
    624 0000E342 04 61                       add     r1,r1,#4
    625 0000E344 FF 66                       sub		r6,r6,#1
    626 0000E346 FC B9                       bne     cv1
    627 0000E348 E1 FF                       lw      lr,[sp]
    628 0000E34A E3 F6                       lw      r6,2[sp]
    629 0000E34C 04 6E                       add     sp,sp,#4
    630 0000E34E F0 80                       ret    
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; LIST
                                        ;
                                        ; LISTX has two forms:
                                        ; 'LIST<CR>' lists all saved lines
                                        ; 'LIST #<CR>' starts listing at the line #
                                        ; Control-S pauses the listing, control-C stops it.
                                        ;
                                        
    643 0000E350                        LISTX
    644 0000E350 63 40 02 AF             	call	TSTNUM		; see if there's a line no.
    645 0000E354 10 15                   	lw      r5,r1
    646 0000E356 46 40 03 AF             	call	ENDCHK		; if not, we get a zero
    647 0000E35A 50 11                   	lw      r1,r5
    648 0000E35C 4E 40 04 AF             	call	FNDLN		; find this or next line
    649 0000E360                        LS1
    650 0000E360 E9 4F 05 A7             	bgtu	WSTART		; warm start if we passed the end
                                        
    652 0000E364 90 11                   	lw		r1,r9
    653 0000E366 5F 40 07 AF             	call	PRTLN		; print the line
    654 0000E36A 10 19                   	lw		r9,r1		; set pointer for next
    655 0000E36C 67 40 0B AF             	call	CHKIO		; check for listing halt request
    656 0000E370 06 A8                   	beq		LS3
    657 0000E372 FE 4F 1D 10             	cmp		r1,#CTRLS	; pause the listing?
    658 0000E376 03 A9                   	bne		LS3
    659 0000E378                        LS2
    660 0000E378 67 40 05 AF             	call	CHKIO		; if so, wait for another keypress
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 11
tb.asm
    661 0000E37C FD B8                   	beq		LS2
    662 0000E37E                        LS3
    663 0000E37E 00 11                   	lw		r1,#0
    664 0000E380 4D 40 0A AF             	call	FNDLNP		; find the next line
    665 0000E384 ED BE                   	br		LS1
                                        
                                        
                                        ;******************************************************************
                                        ; PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                                        ; where '....' is a list of expressions, formats, back-arrows,
                                        ; and strings.	These items a separated by commas.
                                        ;
                                        ; A format is a pound sign followed by a number.  It controls
                                        ; the number of spaces the value of an expression is going to
                                        ; be printed in.  It stays effective for the rest of the print
                                        ; command unless changed by another format.  If no format is
                                        ; specified, 11 positions will be used.
                                        ;
                                        ; A string is quoted in a pair of single- or double-quotes.
                                        ;
                                        ; An underline (back-arrow) means generate a <CR> without a <LF>
                                        ;
                                        ; A <CR LF> is generated after the entire list has been printed
                                        ; or if the list is empty.  If the list ends with a semicolon,
                                        ; however, no <CR LF> is generated.
                                        ;
                                        
    688 0000E386                        PRINT
    689 0000E386 0B 15                   	lw		r5,#11		; D4 = number of print spaces
    690 0000E388 60 40 04 AF             	call	TSTC		; if null list and ":"
    691 0000E38C 3A 08                   	db	':',PR2-*+1
    692 0000E38E 67 40 0A AF             	call	CRLF		; give CR-LF and continue
    693 0000E392 B9 BE                   	br		RUNSML		;		execution on the same line
    694 0000E394                        PR2
    695 0000E394 5F 40 0E AF             	call	TSTC		;if null list and <CR>
    696 0000E398 0D 08                   	db	CR,PR0-*+1
    697 0000E39A 67 40 04 AF             	call	CRLF		;also give CR-LF and
    698 0000E39E A6 BE                   	br		RUNNXL		;execute the next line
    699 0000E3A0                        PR0
    700 0000E3A0 5F 40 08 AF             	call	TSTC		;else is it a format?
    701 0000E3A4 23 0A                   	db	'#',PR1-*+1
    702 0000E3A6 20 40 00 AF             	call	OREXPR		; yes, evaluate expression
    703 0000E3AA 10 15                   	lw		r5,r1		; and save it as print width
    704 0000E3AC 0B AE                   	br		PR3		; look for more to print
    705 0000E3AE                        PR1
    706 0000E3AE 5F 40 01 AF             	call	TSTC	;	is character expression? (MRL)
    707 0000E3B2 24 0C                   	db	'$',PR4-*+1
    708 0000E3B4 1F 40 09 AF             	call	OREXPR	;	yep. Evaluate expression (MRL)
    709 0000E3B8 E2 4F 04 AF             	call	GOOUT	;	print low byte (MRL)
    710 0000E3BC 03 AE                   	br		PR3		;look for more. (MRL)
    711 0000E3BE                        PR4
    712 0000E3BE 52 40 0F AF             	call	QTSTG	;	is it a string?
                                        	; the following branch must occupy only two bytes!
    714 0000E3C2 09 AE                   	br		PR8		;	if not, must be an expression
    715 0000E3C4                        PR3
    716 0000E3C4 5E 40 06 AF             	call	TSTC	;	if ",", go find next
    717 0000E3C8 2C 08                   	db	',',PR6-*+1
    718 0000E3CA 41 40 07 AF             	call	FIN		;in the list.
    719 0000E3CE E8 BE                   	br		PR0
    720 0000E3D0                        PR6
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 12
tb.asm
    721 0000E3D0 65 40 09 AF             	call	CRLF		;list ends here
    722 0000E3D4 06 AE                   	br		FINISH
    723 0000E3D6                        PR8
    724 0000E3D6 1E 40 08 AF             	call	OREXPR		; evaluate the expression
    725 0000E3DA 50 12                   	lw		r2,r5		; set the width
    726 0000E3DC 54 40 0C AF             	call	PRTNUM		; print its value
    727 0000E3E0 F1 BE                   	br		PR3			; more to print?
                                        
    729 0000E3E2                        FINISH
    730 0000E3E2 40 40 0B AF             	call	FIN		; Check end of command
    731 0000E3E6 42 40 0F AE             	jmp		QWHAT	; print "What?" if wrong
                                        
                                        
                                        ;*******************************************************************
                                        ;
                                        ; *** GOSUB *** & RETURN ***
                                        ;
                                        ; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                                        ; except that the current text pointer, stack pointer, etc. are
                                        ; saved so that execution can be continued after the subroutine
                                        ; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                                        ; recursive), the save area must be stacked.  The stack pointer
                                        ; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                                        ; If we are in the main routine, 'STKGOS' is zero (this was done
                                        ; in the initialization section of the interpreter), but we still
                                        ; save it as a flag for no further 'RETURN's.
                                        ;
    748 0000E3EA                        GOSUB
    749 0000E3EA 4E 40 03 AF             	call	PUSHA		; save the current 'FOR' parameters
    750 0000E3EE 1D 40 0C AF             	call	OREXPR		; get line number
    751 0000E3F2 49 40 09 AF             	call	FNDLN		; find the target line
    752 0000E3F6 04 A8                   	beq		gosub1
    753 0000E3F8 35 4F 0D 11             	lea		r1,msgBadGotoGosub
    754 0000E3FC 42 40 06 AE             	br		ERROR		; if not there, say "How?"
    755 0000E400                        gosub1
    756 0000E400 FA 6E                   	sub		sp,sp,#6
    757 0000E402 E1 D8                   	sw		r8,[sp]		; save text pointer
    758 0000E404 08 40 07 F1             	lw		r1,CURRNT
    759 0000E408 E3 D1                   	sw		r1,2[sp]	; found it, save old 'CURRNT'...
    760 0000E40A 08 40 09 F1             	lw		r1,STKGOS
    761 0000E40E E5 D1                   	sw		r1,4[sp]	; and 'STKGOS'
    762 0000E410 08 40 0D D0             	sw		r0,LOPVAR	; load new values
    763 0000E414 08 40 09 DE             	sw		sp,STKGOS
    764 0000E418 73 BE                   	br		RUNTSL
                                        
                                        
                                        ; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                                        ; returns the execution to the command after the most recent
                                        ; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                                        ; a 'GOSUB' and is thus an error.
                                        ;
    772 0000E41A                        RETURN
    773 0000E41A 40 40 01 AF             	call	ENDCHK		; there should be just a <CR>
    774 0000E41E 08 40 09 F1             	lw		r1,STKGOS	; get old stack pointer
    775 0000E422 04 A9                   	bne		return1
    776 0000E424 37 4F 0A 11             	lea		r1,msgRetWoGosub
    777 0000E428 41 40 00 AE             	br		ERROR		; if zero, it doesn't exist
    778 0000E42C                        return1
    779 0000E42C 10 1E                   	lw		sp,r1		; else restore it
    780 0000E42E E5 F1                   	lw		r1,4[sp]
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 13
tb.asm
    781 0000E430 08 40 09 D1             	sw		r1,STKGOS	; and the old 'STKGOS'
    782 0000E434 E3 F1                   	lw		r1,2[sp]
    783 0000E436 08 40 07 D1             	sw		r1,CURRNT	; and the old 'CURRNT'
    784 0000E43A E1 F8                   	lw		r8,[sp]		; and the old text pointer
    785 0000E43C 06 6E                   	add		sp,sp,#6
    786 0000E43E 4A 40 05 AF             	call	POPA		;and the old 'FOR' parameters
    787 0000E442 CF BE                   	br		FINISH		;and we are back home
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** FOR *** & NEXT ***
                                        ;
                                        ; 'FOR' has two forms:
                                        ; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                                        ; The second form means the same thing as the first form with a
                                        ; STEP of positive 1.  The interpreter will find the variable 'var'
                                        ; and set its value to the current value of 'exp1'.  It also
                                        ; evaluates 'exp2' and 'exp1' and saves all these together with
                                        ; the text pointer, etc. in the 'FOR' save area, which consisits of
                                        ; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                                        ; already something in the save area (indicated by a non-zero
                                        ; 'LOPVAR'), then the old save area is saved on the stack before
                                        ; the new values are stored.  The interpreter will then dig in the
                                        ; stack and find out if this same variable was used in another
                                        ; currently active 'FOR' loop.  If that is the case, then the old
                                        ; 'FOR' loop is deactivated. (i.e. purged from the stack)
                                        ;
    809 0000E444                        FOR
    810 0000E444 4B 40 06 AF             	call	PUSHA		; save the old 'FOR' save area
    811 0000E448 3C 40 02 AF             	call	SETVAL		; set the control variable
    812 0000E44C 08 40 0D D1             	sw		r1,LOPVAR	; save its address
    813 0000E450 1C 4E 0D 19             	lea		r9,TAB5		; use 'EXEC' to test for 'TO'
    814 0000E454 22 4E 0A 1A             	lea		r10,TAB5_1
    815 0000E458 EF 4F 0A AE             	jmp		EXEC
    816 0000E45C                        FR1
    817 0000E45C 1A 40 05 AF             	call	OREXPR		; evaluate the limit
    818 0000E460 09 40 01 D1             	sw		r1,LOPLMT	; save that
    819 0000E464 1D 4E 00 19             	lea		r9,TAB6		; use 'EXEC' to look for the
    820 0000E468 22 4E 0E 1A             	lea		r10,TAB6_1	; word 'STEP'
    821 0000E46C EF 4F 00 AE             	jmp		EXEC
    822 0000E470                        FR2
    823 0000E470 19 40 0B AF             	call	OREXPR		; found it, get the step value
    824 0000E474 01 AE                   	br		FR4
    825 0000E476                        FR3
    826 0000E476 01 11                   	lw		r1,#1		; not found, step defaults to 1
    827 0000E478                        FR4
    828 0000E478 08 40 0F D1             	sw		r1,LOPINC	; save that too
                                        
    830 0000E47C                        FR5
    831 0000E47C 08 40 07 F2             	lw		r2,CURRNT
    832 0000E480 09 40 03 D2             	sw		r2,LOPLN	; save address of current line number
    833 0000E484 09 40 05 D8             	sw		r8,LOPPT	; and text pointer
                                        
                                        
    836 0000E488 E0 13                   	lw		r3,sp		; dig into the stack to find 'LOPVAR'
    837 0000E48A 08 40 0D F6             	lw		r6,LOPVAR
    838 0000E48E 01 AE                   	br		FR7
    839 0000E490                        FR6
    840 0000E490 3A 13                   	lea		r3,10[r3]	; look at next stack frame
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 14
tb.asm
    841 0000E492                        FR7
    842 0000E492 31 F2                   	lw		r2,[r3]		; is it zero?
    843 0000E494 08 A8                   	beq		FR8			; if so, we're done
    844 0000E496 6D 22                   	cmp		r2,r6		; same as current LOPVAR?
    845 0000E498 FB B9                   	bne		FR6			; nope, look some more
                                        
    847 0000E49A 30 11                       lw      r1,r3       ; Else remove 5 words from...
    848 0000E49C 3A 12                   	lea		r2,10[r3]   ; inside the stack.
    849 0000E49E E0 13                   	lw		r3,sp		
    850 0000E4A0 47 40 01 AF             	call	MVDOWN
    851 0000E4A4 0A 6E                   	add		sp,sp,#10	; set the SP 5 words up
    852 0000E4A6                        FR8
    853 0000E4A6 9D BE                       br	    FINISH		; and continue execution
                                        
                                        
                                        ; 'NEXT var' serves as the logical (not necessarily physical) end
                                        ; of the 'FOR' loop.  The control variable 'var' is checked with
                                        ; the 'LOPVAR'.  If they are not the same, the interpreter digs in
                                        ; the stack to find the right one and purges all those that didn't
                                        ; match.  Either way, it then adds the 'STEP' to that variable and
                                        ; checks the result with against the limit value.  If it is within
                                        ; the limit, control loops back to the command following the
                                        ; 'FOR'.  If it's outside the limit, the save area is purged and
                                        ; execution continues.
                                        ;
    866 0000E4A8                        NEXT
    867 0000E4A8 00 11                   	lw		r1,#0		; don't allocate it
    868 0000E4AA 26 40 02 AF             	call	TSTV		; get address of variable
    869 0000E4AE 04 A9                   	bne		NX4
    870 0000E4B0 33 4F 09 11             	lea		r1,msgNextVar
    871 0000E4B4 3C 40 0A AE             	br		ERROR		; if no variable, say "What?"
    872 0000E4B8                        NX4
    873 0000E4B8 10 19                   	lw		r9,r1		; save variable's address
    874 0000E4BA                        NX0
    875 0000E4BA 08 40 0D F1             	lw		r1,LOPVAR	; If 'LOPVAR' is zero, we never...
    876 0000E4BE 04 A9                   	bne		NX5         ; had a FOR loop
    877 0000E4C0 32 4F 06 11             	lea		r1,msgNextFor
    878 0000E4C4 3C 40 02 AE             	br		ERROR		
    879 0000E4C8                        NX5
    880 0000E4C8 9D 21                   	cmp		r1,r9		; else we check them
    881 0000E4CA 03 A8                   	beq		NX2			; OK, they agree
    882 0000E4CC 45 40 0E AF             	call	POPA		; nope, let's see the next frame
    883 0000E4D0 F4 BE                   	br		NX0
    884 0000E4D2                        NX2
    885 0000E4D2 91 F1                   	lw		r1,[r9]		; get control variable's value
    886 0000E4D4 08 40 0F F2             	lw		r2,LOPINC
    887 0000E4D8 20 21                   	add		r1,r2		; add in loop increment
                                        ;	BVS.L	QHOW		say "How?" for 32-bit overflow
    889 0000E4DA 91 D1                   	sw		r1,[r9]		; save control variable's new value
    890 0000E4DC 09 40 01 F3             	lw		r3,LOPLMT	; get loop's limit value
    891 0000E4E0 26 22                   	or		r2,r2       ; check loop increment
    892 0000E4E2 03 AB                   	bpl		NX1			; branch if loop increment is positive
    893 0000E4E4 3D 21                   	cmp		r1,r3		; test against limit
    894 0000E4E6 0A A0                   	blt		NXPurge
    895 0000E4E8 02 AE                   	br      NX3
    896 0000E4EA                        NX1
    897 0000E4EA 3D 21                   	cmp		r1,r3
    898 0000E4EC 07 A3                   	bgt		NXPurge
    899 0000E4EE                        NX3	
    900 0000E4EE 09 40 03 F8             	lw		r8,LOPLN	; Within limit, go back to the...
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 15
tb.asm
    901 0000E4F2 08 40 07 D8             	sw		r8,CURRNT
    902 0000E4F6 09 40 05 F8             	lw		r8,LOPPT	; saved 'CURRNT' and text pointer.
    903 0000E4FA 73 BE                   	br		FINISH
                                        
    905 0000E4FC                        NXPurge
    906 0000E4FC 44 40 06 AF                 call    POPA        ; purge this loop
    907 0000E500 70 BE                       br      FINISH
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                                        ;
                                        ; 'REM' can be followed by anything and is ignored by the
                                        ; interpreter.
                                        ;
                                        ;REM
                                        ;    br	    IF2		    ; skip the rest of the line
                                        
                                        ; 'IF' is followed by an expression, as a condition and one or
                                        ; more commands (including other 'IF's) separated by colons.
                                        ; Note that the word 'THEN' is not used.  The interpreter evaluates
                                        ; the expression.  If it is non-zero, execution continues.  If it
                                        ; is zero, the commands that follow are ignored and execution
                                        ; continues on the next line.
                                        ;
    927 0000E502                        IF
    928 0000E502 15 40 02 AF                 call	OREXPR		; evaluate the expression
    929 0000E506                        IF1
    930 0000E506 16 21                       or      r1,r1       ; is it zero?
    931 0000E508 EF 4F 0D A9                 bne	    RUNSML		; if not, continue
    932 0000E50C                        IF2
    933 0000E50C 80 19                       lw		r9,r8		; set lookup pointer
    934 0000E50E 00 11                   	lw		r1,#0		; find line #0 (impossible)
    935 0000E510 42 40 08 AF             	call	FNDSKP		; if so, skip the rest of the line
    936 0000E514 DB 4F 0B A7             	bgtu	WSTART		; if no next line, do a warm start
    937 0000E518                        IF3
    938 0000E518 EF 4F 02 AE             	br		RUNTSL		; run the next line
                                        
                                        
                                        ; INPUT is called first and establishes a stack frame
    942 0000E51C                        INPERR
    943 0000E51C 08 40 0B FE             	lw		sp,STKINP	; restore the old stack pointer
    944 0000E520 E5 F8                   	lw		r8,4[sp]
    945 0000E522 08 40 07 D8             	sw		r8,CURRNT	; and old 'CURRNT'
    946 0000E526 E3 F8                   	lw		r8,2[sp]	; and old text pointer
    947 0000E528 0A 6E                   	add		sp,sp,#10	; fall through will subtract 10
                                        
                                        ; 'INPUT' is like the 'PRINT' command, and is followed by a list
                                        ; of items.  If the item is a string in single or double quotes,
                                        ; or is an underline (back arrow), it has the same effect as in
                                        ; 'PRINT'.  If an item is a variable, this variable name is
                                        ; printed out followed by a colon, then the interpreter waits for
                                        ; an expression to be typed in.  The variable is then set to the
                                        ; value of this expression.  If the variable is preceeded by a
                                        ; string (again in single or double quotes), the string will be
                                        ; displayed followed by a colon.  The interpreter the waits for an
                                        ; expression to be entered and sets the variable equal to the
                                        ; expression's value.  If the input expression is invalid, the
                                        ; interpreter will print "What?", "How?", or "Sorry" and reprint
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 16
tb.asm
                                        ; the prompt and redo the input.  The execution will not terminate
                                        ; unless you press control-C.  This is handled in 'INPERR'.
                                        ;
    964 0000E52A                        INPUT
    965 0000E52A F6 6E                   	sub		sp,sp,#10	; allocate stack frame
    966 0000E52C E9 D5                   	sw      r5,8[sp]
    967 0000E52E                        IP6
    968 0000E52E E1 D8                   	sw		r8,[sp]		; save in case of error
    969 0000E530 47 40 06 AF             	call	QTSTG		; is next item a string?
    970 0000E534 06 AE                   	br		IP2			; nope - this branch must take only two bytes
    971 0000E536 01 11                   	lw		r1,#1		; allocate var
    972 0000E538 21 40 0B AF             	call	TSTV		; yes, but is it followed by a variable?
    973 0000E53C 2A A8                   	beq     IP4		    ; if not, brnch
    974 0000E53E 10 1A                   	lw		r10,r1		; put away the variable's address
    975 0000E540 10 AE                   	br		IP3			; if so, input to variable
    976 0000E542                        IP2
    977 0000E542 E3 D8                   	sw		r8,2[sp]	; save for 'PRTSTG'
    978 0000E544 01 11                   	lw		r1,#1
    979 0000E546 21 40 04 AF             	call	TSTV		; must be a variable now
    980 0000E54A 04 A9                   	bne		IP7
    981 0000E54C 30 4F 09 11             	lea		r1,msgInputVar
    982 0000E550 37 40 0C AE             	br		ERROR		; "What?" it isn't?
    983 0000E554                        IP7
    984 0000E554 10 1A                   	lw		r10,r1		; put away the variable's address
    985 0000E556 80 E5                   	lb		r5,[r8]		; get ready for 'PRTSTG' by null terminating
    986 0000E558 80 C0                   	sb		r0,[r8]
    987 0000E55A E3 F1                   	lw		r1,2[sp]	; get back text pointer
    988 0000E55C 44 40 04 AF             	call	PRTSTG		; print string as prompt
    989 0000E560 80 C5                   	sb		r5,[r8]		; un-null terminate
    990 0000E562                        IP3
    991 0000E562 E3 D8                   	sw		r8,2[sp]	; save in case of error
    992 0000E564 08 40 07 F1             	lw		r1,CURRNT
    993 0000E568 E5 D1                   	sw		r1,4[sp]	; also save 'CURRNT'
    994 0000E56A 0F 11                   	lw		r1,#-1
    995 0000E56C 08 40 07 D1             	sw		r1,CURRNT	; flag that we are in INPUT
    996 0000E570 08 40 0B DE             	sw		sp,STKINP	; save the stack pointer too
    997 0000E574 E7 DA                   	sw		r10,6[sp]	; save the variable address
    998 0000E576 03 40 0A 11             	lw		r1,#':'		; print a colon first
    999 0000E57A 38 40 01 AF             	call	GETLN		; then get an input line
   1000 0000E57E 0A 40 0E 18             	lea		r8,BUFFER	; point to the buffer
   1001 0000E582 11 40 02 AF             	call	OREXPR		; evaluate the input
   1002 0000E586 E7 FA                   	lw		r10,6[sp]	; restore the variable address
   1003 0000E588 A1 D1                   	sw		r1,[r10]	; save value in variable
   1004 0000E58A E5 F1                   	lw		r1,4[sp]	; restore old 'CURRNT'
   1005 0000E58C 08 40 07 D1             	sw		r1,CURRNT
   1006 0000E590 E3 F8                   	lw		r8,2[sp]	; and the old text pointer
   1007 0000E592                        IP4
   1008 0000E592 4F 40 0F AF             	call	TSTC		; is the next thing a comma?
   1009 0000E596 2C 04                   	db	',',IP5-*+1
   1010 0000E598 CA BE                   	br		IP6			; yes, more items
   1011 0000E59A                        IP5
   1012 0000E59A E9 F5                       lw      r5,8[sp]
   1013 0000E59C 0A 6E                   	add		sp,sp,#10	; clean up the stack
   1014 0000E59E 21 BE                   	jmp		FINISH
                                        
                                        
   1017 0000E5A0                        DEFLT
   1018 0000E5A0 80 E1                       lb      r1,[r8]
   1019 0000E5A2 FF 4F 13 10                 cmp     r1,#CR      ; empty line is OK
   1020 0000E5A6 1D B8                   	beq	    FINISH	    ; else it is 'LET'
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 17
tb.asm
                                        
                                        
                                        ; 'LET' is followed by a list of items separated by commas.
                                        ; Each item consists of a variable, an equals sign, and an
                                        ; expression.  The interpreter evaluates the expression and sets
                                        ; the variable to that value.  The interpreter will also handle
                                        ; 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                                        ;
   1029 0000E5A8                        LET
   1030 0000E5A8 31 40 02 AF                 call	SETVAL		; do the assignment
   1031 0000E5AC 4F 40 02 AF             	call	TSTC		; check for more 'LET' items
   1032 0000E5B0 2C 04                   	db	',',LT1-*+1
   1033 0000E5B2 FA BE                   	br	    LET
   1034 0000E5B4                        LT1
   1035 0000E5B4 16 BE                       br	    FINISH		; until we are finished.
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** LOAD *** & SAVE ***
                                        ;
                                        ; These two commands transfer a program to/from an auxiliary
                                        ; device such as a cassette, another computer, etc.  The program
                                        ; is converted to an easily-stored format: each line starts with
                                        ; a colon, the line no. as 4 hex digits, and the rest of the line.
                                        ; At the end, a line starting with an '@' sign is sent.  This
                                        ; format can be read back with a minimum of processing time by
                                        ; the Butterfly.
                                        ;
   1050 0000E5B6                        LOAD
   1051 0000E5B6 01 4E 09 F8             	lw		r8,TXTBGN	; set pointer to start of prog. area
   1052 0000E5BA 00 40 0D 11             	lw		r1,#CR		; For a CP/M host, tell it we're ready...
   1053 0000E5BE D2 4F 05 AF             	call	GOAUXO		; by sending a CR to finish PIP command.
   1054 0000E5C2                        LOD1
   1055 0000E5C2 D2 4F 05 AF             	call	GOAUXI		; look for start of line
   1056 0000E5C6 FD BA                   	bmi		LOD1
   1057 0000E5C8 FC 4F 10 10             	cmp		r1,#'@'		; end of program?
   1058 0000E5CC 1B A8                   	beq		LODEND
   1059 0000E5CE FE 4F 16 10             	cmp     r1,#0x1A    ; or EOF marker
   1060 0000E5D2 18 A8                   	beq     LODEND
   1061 0000E5D4 FC 4F 16 10             	cmp		r1,#':'		; if not, is it start of line?
   1062 0000E5D8 F4 B9                   	bne		LOD1		; if not, wait for it
   1063 0000E5DA 18 AF                   	call	GCHAR		; get line number
   1064 0000E5DC 80 C1                   	sb		r1,[r8]		; store it
   1065 0000E5DE A1 31                   	shr		r1,#1
   1066 0000E5E0 A1 31                   	shr		r1,#1
   1067 0000E5E2 A1 31                   	shr		r1,#1
   1068 0000E5E4 A1 31                   	shr		r1,#1
   1069 0000E5E6 A1 31                   	shr		r1,#1
   1070 0000E5E8 A1 31                   	shr		r1,#1
   1071 0000E5EA A1 31                   	shr		r1,#1
   1072 0000E5EC A1 31                   	shr		r1,#1
   1073 0000E5EE 81 C1                   	sb		r1,1[r8]
   1074 0000E5F0 02 68                   	add		r8,r8,#2
   1075 0000E5F2                        LOD2
   1076 0000E5F2 D0 4F 0D AF             	call	GOAUXI		; get another text char.
   1077 0000E5F6 FD BA                   	bmi		LOD2
   1078 0000E5F8 80 C1                   	sb		r1,[r8]
   1079 0000E5FA 01 68                   	add		r8,r8,#1	; store it
   1080 0000E5FC FF 4F 13 10             	cmp		r1,#CR		; is it the end of the line?
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 18
tb.asm
   1081 0000E600 F8 B9                   	bne		LOD2		; if not, go back for more
   1082 0000E602 DF BE                   	br		LOD1		; if so, start a new line
   1083 0000E604                        LODEND
   1084 0000E604 09 40 07 D8             	sw		r8,TXTUNF	; set end-of program pointer
   1085 0000E608 D4 4F 01 AE             	br		WSTART		; back to direct mode
                                        
                                        ; get character from input (16 bit value)
   1088 0000E60C                        GCHAR
   1089 0000E60C FA 6E                   	sub		sp,sp,#6
   1090 0000E60E E1 DF                   	sw		lr,[sp]
   1091 0000E610 E3 D5                   	sw		r5,2[sp]
   1092 0000E612 E5 D6                   	sw		r6,4[sp]
   1093 0000E614 04 16                   	lw      r6,#4       ; repeat four times
   1094 0000E616 00 15                   	lw		r5,#0
   1095 0000E618                        GCHAR1
   1096 0000E618 CF 4F 0A AF             	call	GOAUXI		; get a char
   1097 0000E61C FD BA                   	bmi		GCHAR1
   1098 0000E61E 0D AF                   	call	asciiToHex
   1099 0000E620 81 35                   	shl		r5,#1
   1100 0000E622 81 35                   	shl		r5,#1
   1101 0000E624 81 35                   	shl		r5,#1
   1102 0000E626 81 35                   	shl		r5,#1
   1103 0000E628 16 25                   	or		r5,r1
   1104 0000E62A FF 66                   	sub		r6,r6,#1
   1105 0000E62C F5 B9                   	bne     GCHAR1
   1106 0000E62E 50 11                   	lw		r1,r5
   1107 0000E630 E1 FF                   	lw		lr,[sp]
   1108 0000E632 E3 F5                   	lw		r5,2[sp]
   1109 0000E634 E5 F6                   	lw		r6,4[sp]
   1110 0000E636 06 6E                   	add     sp,sp,#6
   1111 0000E638 F0 80                   	ret
                                        
                                        ; convert an ascii char to hex code
                                        ; input
                                        ;	r2 = char to convert
                                        
   1117 0000E63A                        asciiToHex
   1118 0000E63A FC 4F 17 10             	cmp		r1,#'9'
   1119 0000E63E 01 A2                   	ble		a2h1		; less than '9'
   1120 0000E640 F9 61                   	sub		r1,r1,#7	; shift 'A' to '9'+1
   1121 0000E642                        a2h1
   1122 0000E642 D0 61                   	sub		r1,r1,#'0'	;
   1123 0000E644 00 40 5F 31             	and		r1,#15		; make sure a nybble
   1124 0000E648 F0 80                   	ret
                                        
                                        ; SAVE
                                        ; SAVE ON <node number> - copies the code to the specified node
                                        
   1129 0000E64A                        SAVE
   1130 0000E64A 4D 40 06 AF             	call	IGNBLK		; ignore blanks
   1131 0000E64E 80 E1                   	lb		r1,[r8]
   1132 0000E650 FB 4F 11 10             	cmp		r1,#'O'
   1133 0000E654 0A A9                   	bne		SAVE3
   1134 0000E656 81 E1                   	lb		r1,1[r8]
   1135 0000E658 FB 4F 12 10             	cmp		r1,#'N'
   1136 0000E65C 06 A9                   	bne		SAVE3
   1137 0000E65E 02 68                   	add		r8,r8,#2
   1138 0000E660 A4 AF                   	call	OREXPR		; get core #
   1139 0000E662 03 40 06 C1             	sb		r1,tgtNode
   1140 0000E666 54 40 0F AF             	call	TriggerTgtLoad
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 19
tb.asm
   1141 0000E66A                        SAVE3:
   1142 0000E66A 01 4E 09 F8             	lw		r8,TXTBGN	;set pointer to start of prog. area
   1143 0000E66E 09 40 07 F9             	lw		r9,TXTUNF	;set pointer to end of prog. area
   1144 0000E672                        SAVE1
   1145 0000E672 40 AF                   	call    AUXOCRLF    ; send out a CR & LF (CP/M likes this)
   1146 0000E674 9D 28                   	cmp		r8,r9		; are we finished?
   1147 0000E676 33 A5                   	bgeu	SAVEND
   1148 0000E678 03 40 06 E2             	lb		r2,tgtNode
   1149 0000E67C FE 4F 2F 10             	cmp		r2,#$11
   1150 0000E680 13 A8                   	beq		SAVE4
                                        	lb		r1,#':'
   1152 0000E682 02 40 00 C1             	sb		r1,txBuf
   1153 0000E686 80 E1                   	lb		r1,[r8]
   1154 0000E688 02 40 01 C1             	sb		r1,txBuf+1
   1155 0000E68C 81 E1                   	lb		r1,1[r8]
   1156 0000E68E 02 40 02 C1             	sb		r1,txBuf+2
   1157 0000E692 03 40 06 E1             	lb		r1,tgtNode
   1158 0000E696 02 40 0F C1             	sb		r1,txBuf+MSG_DST
                                        	lb		r1,#$11
   1160 0000E69A 02 40 0E C1             	sb		r1,txBuf+MSG_SRC
                                        	lb		r1,#11
   1162 0000E69E 02 40 07 C1             	sb		r1,txBuf+MSG_TYPE
   1163 0000E6A2 FF BF                   	call	Xmit
   1164 0000E6A4 02 68                   	add		r8,r8,#2
   1165 0000E6A6 13 AE                   	br		SAVE2
   1166 0000E6A8                        SAVE4:
   1167 0000E6A8 03 40 0A 11             	lw		r1,#':'		; if not, start a line
   1168 0000E6AC CA 4F 0E AF             	call	GOAUXO
   1169 0000E6B0 80 E1                   	lb		r1,[r8]		; get line number
   1170 0000E6B2 0E 21                   	zxb		r1
   1171 0000E6B4 81 E2                   	lb		r2,1[r8]
   1172 0000E6B6 0E 22                   	zxb		r2
   1173 0000E6B8 81 32                   	shl		r2,#1
   1174 0000E6BA 81 32                   	shl		r2,#1
   1175 0000E6BC 81 32                   	shl		r2,#1
   1176 0000E6BE 81 32                   	shl		r2,#1
   1177 0000E6C0 81 32                   	shl		r2,#1
   1178 0000E6C2 81 32                   	shl		r2,#1
   1179 0000E6C4 81 32                   	shl		r2,#1
   1180 0000E6C6 81 32                   	shl		r2,#1
   1181 0000E6C8 26 21                   	or		r1,r2
   1182 0000E6CA 02 68                   	add		r8,r8,#2
   1183 0000E6CC 1F AF                   	call	PWORD       ; output line number as 4-digit hex
   1184 0000E6CE                        SAVE2
   1185 0000E6CE 80 E1                   	lb		r1,[r8]		; get a text char.
   1186 0000E6D0 01 68                   	add		r8,r8,#1
   1187 0000E6D2 FF 4F 13 10             	cmp		r1,#CR		; is it the end of the line?
   1188 0000E6D6 CD B8                   	beq		SAVE1		; if so, send CR & LF and start new line
   1189 0000E6D8 C9 4F 08 AF             	call	GOAUXO		; send it out
   1190 0000E6DC F8 BE                   	br		SAVE2		; go back for more text
   1191 0000E6DE                        SAVEND
   1192 0000E6DE 04 40 00 11             	lw		r1,#'@'		; send end-of-program indicator
   1193 0000E6E2 C9 4F 03 AF             	call	GOAUXO
   1194 0000E6E6 06 AF                   	call    AUXOCRLF    ; followed by a CR & LF
   1195 0000E6E8 01 40 0A 11             	lw		r1,#0x1A	; and a control-Z to end the CP/M file
   1196 0000E6EC C8 4F 0E AF             	call	GOAUXO
   1197 0000E6F0 CC 4F 0D AE             	br		WSTART		; then go do a warm start
                                        
                                        
                                        ; output a CR LF sequence to auxillary output
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 20
tb.asm
                                        ; Registers Affected
                                        ;   r3 = LF
   1203 0000E6F4                        AUXOCRLF
   1204 0000E6F4 FE 6E                       sub     sp,sp,#2
   1205 0000E6F6 E1 DF                       sw      lr,[sp]
   1206 0000E6F8 00 40 0D 11                 lw      r1,#CR
   1207 0000E6FC C8 4F 06 AF                 call    GOAUXO
   1208 0000E700 0A 11                       lw      r1,#LF
   1209 0000E702 C8 4F 03 AF                 call    GOAUXO
   1210 0000E706 E1 FF                       lw      lr,[sp]
   1211 0000E708 02 6E                   	add		sp,sp,#2
   1212 0000E70A F0 80                       ret
                                        
                                        
                                        ; output a word in hex format
                                        ; tricky because of the need to reverse the order of the chars
   1217 0000E70C                        PWORD
   1218 0000E70C FC 6E                   	sub		sp,sp,#4
   1219 0000E70E E1 DF                   	sw		lr,[sp]
   1220 0000E710 E3 D5                   	sw		r5,2[sp]
   1221 0000E712 0A 40 05 15             	lea     r5,NUMWKA+3
   1222 0000E716 10 14                   	lw		r4,r1		; r4 = value
   1223 0000E718                        pword1
   1224 0000E718 40 11                       lw      r1,r4       ; r1 = value
   1225 0000E71A A1 34                       shr     r4,#1       ; shift over to next nybble
   1226 0000E71C A1 34                       shr     r4,#1
   1227 0000E71E A1 34                       shr     r4,#1
   1228 0000E720 A1 34                       shr     r4,#1
   1229 0000E722 10 AF                       call    toAsciiHex  ; convert LS nybble to ascii hex
   1230 0000E724 50 C1                       sb      r1,[r5]     ; save in work area
   1231 0000E726 FF 65                       sub     r5,r5,#1
   1232 0000E728 F5 4F 5E 10                 cmp     r5,#NUMWKA
   1233 0000E72C F5 B5                       bgeu    pword1
   1234 0000E72E                        pword2
   1235 0000E72E 01 65                       add     r5,r5,#1
   1236 0000E730 50 E1                       lb      r1,[r5]     ; get char to output
   1237 0000E732 C6 4F 0B AF             	call	GOAUXO		; send it
   1238 0000E736 F5 4F 5B 10             	cmp     r5,#NUMWKA+3
   1239 0000E73A F9 B4                   	bltu    pword2
                                        
   1241 0000E73C E3 F5                   	lw		r5,2[sp]
   1242 0000E73E E1 FF                   	lw		lr,[sp]
   1243 0000E740 04 6E                   	add		sp,sp,#4
   1244 0000E742 F0 80                   	ret
                                        
                                        
                                        ; convert nybble in r2 to ascii hex char2
                                        ; r2 = character to convert
                                        
   1250 0000E744                        toAsciiHex
   1251 0000E744 00 40 5F 31             	and		r1,#15		; make sure it's a nybble
   1252 0000E748 FF 4F 16 10             	cmp		r1,#10		; > 10 ?
   1253 0000E74C 01 A0                   	blt		tah1
   1254 0000E74E 07 61                   	add		r1,r1,#7	; bump it up to the letter 'A'
   1255 0000E750                        tah1
   1256 0000E750 30 61                   	add		r1,r1,#'0'	; bump up to ascii '0'
   1257 0000E752 F0 80                   	ret
                                        
                                        
                                        
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 21
tb.asm
                                        ;******************************************************************
                                        ;
                                        ; *** POKE *** & SYSX ***
                                        ;
                                        ; 'POKE expr1,expr2' stores the byte from 'expr2' into the memory
                                        ; address specified by 'expr1'.
                                        ;
                                        ; 'SYSX expr' jumps to the machine language subroutine whose
                                        ; starting address is specified by 'expr'.  The subroutine can use
                                        ; all registers but must leave the stack the way it found it.
                                        ; The subroutine returns to the interpreter by executing an RET.
                                        ;
   1273 0000E754                        POKE
   1274 0000E754 FE 6E                   	sub		sp,sp,#2
   1275 0000E756 29 AF                   	call	OREXPR		; get the memory address
   1276 0000E758 41 40 0C AF             	call	TSTC		; it must be followed by a comma
   1277 0000E75C 2C 10                   	db	',',PKER-*+1
   1278 0000E75E E1 D1                   	sw		r1,[sp]	    ; save the address
   1279 0000E760 24 AF                   	call	OREXPR		; get the byte to be POKE'd
   1280 0000E762 E1 F2                   	lw		r2,[sp]	    ; get the address back
   1281 0000E764 20 C1                   	sb		r1,[r2]		; store the byte in memory
   1282 0000E766 02 6E                   	add		sp,sp,#2
   1283 0000E768 E3 4F 0B AE             	br		FINISH
   1284 0000E76C                        PKER
   1285 0000E76C 2A 4F 02 11             	lea		r1,msgComma
   1286 0000E770 26 40 0C AE             	br		ERROR		; if no comma, say "What?"
                                        
                                        
   1289 0000E774                        POKEW
   1290 0000E774 FE 6E                   	sub		sp,sp,#2
   1291 0000E776 19 AF                   	call	OREXPR		; get the memory address
   1292 0000E778 40 40 0C AF             	call	TSTC		; it must be followed by a comma
   1293 0000E77C 2C F0                   	db	',',PKER-*+1
   1294 0000E77E E1 D1                   	sw		r1,[sp]	    ; save the address
   1295 0000E780 14 AF                   	call	OREXPR		; get the byte to be POKE'd
   1296 0000E782 E1 F2                   	lw		r2,[sp]	    ; get the address back
   1297 0000E784 21 D1                   	sw		r1,[r2]		; store the word in memory
   1298 0000E786 02 6E                   	add		sp,sp,#2
   1299 0000E788 E2 4F 0B AE             	jmp		FINISH
                                        
                                        
   1302 0000E78C                        SYSX
   1303 0000E78C FE 6E                   	sub		sp,sp,#2
   1304 0000E78E 0D AF                   	call	OREXPR		; get the subroutine's address
   1305 0000E790 16 20                   	or		r0,r1		; make sure we got a valid address
   1306 0000E792 04 A9                   	bne		sysx1
   1307 0000E794 2F 4F 07 11             	lea		r1,msgSYSBad
   1308 0000E798 25 40 08 AE             	br		ERROR
   1309 0000E79C                        sysx1
   1310 0000E79C E1 D8                   	sw		r8,[sp]	    ; save the text pointer
   1311 0000E79E C2 48 0F AF             	call	[r1]		; jump to the subroutine
   1312 0000E7A2 E1 F8                   	lw		r8,[sp]	    ; restore the text pointer
   1313 0000E7A4 02 6E                   	add		sp,sp,#2
   1314 0000E7A6 E1 4F 0C AE             	br		FINISH
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** EXPR ***
                                        ;
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 22
tb.asm
                                        ; 'EXPR' evaluates arithmetical or logical expressions.
                                        ; <OREXPR>::= <ANDEXPR> OR <ANDEXPR> ...
                                        ; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                                        ; <EXPR>::=<EXPR2>
                                        ;	   <EXPR2><rel.op.><EXPR2>
                                        ; where <rel.op.> is one of the operators in TAB8 and the result
                                        ; of these operations is 1 if true and 0 if false.
                                        ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                                        ; where () are optional and (... are optional repeats.
                                        ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                                        ; <EXPR4>::=<variable>
                                        ;	    <function>
                                        ;	    (<EXPR>)
                                        ; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                                        ; as an index, functions can have an <EXPR> as arguments, and
                                        ; <EXPR4> can be an <EXPR> in parenthesis.
                                        ;
                                        
                                        
                                        ; <OREXPR>::=<ANDEXPR> OR <ANDEXPR> ...
                                        ;
   1342 0000E7AA                        OREXPR
   1343 0000E7AA FC 6E                   	sub		sp,sp,#4
   1344 0000E7AC E1 DF                   	sw		lr,[sp]
   1345 0000E7AE 0F AF                   	call	ANDEXPR		; get first <ANDEXPR>
   1346 0000E7B0                        XP_OR1
   1347 0000E7B0 E3 D1                   	sw		r1,2[sp]	; save <ANDEXPR> value
   1348 0000E7B2 1E 4E 03 19             	lea		r9,TAB10		; look up a logical operator
   1349 0000E7B6 24 4E 04 1A             	lea		r10,TAB10_1
   1350 0000E7BA D4 4F 09 AE             	jmp		EXEC		; go do it
                                        
   1352 0000E7BE                        XP_OR
   1353 0000E7BE 07 AF                       call    ANDEXPR
   1354 0000E7C0 E3 F2                       lw      r2,2[sp]
   1355 0000E7C2 26 21                       or      r1,r2
   1356 0000E7C4 F5 BE                       br      XP_OR1
                                        
   1358 0000E7C6                        XP_ORX
   1359 0000E7C6 E3 F1                   	lw		r1,2[sp]
   1360 0000E7C8 E1 FF                       lw      lr,[sp]
   1361 0000E7CA 04 6E                       add     sp,sp,#4
   1362 0000E7CC F0 80                       ret
                                        
                                        
                                        ; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                                        ;
   1367 0000E7CE                        ANDEXPR
   1368 0000E7CE FC 6E                   	sub		sp,sp,#4
   1369 0000E7D0 E1 DF                   	sw		lr,[sp]
   1370 0000E7D2 37 AF                   	call	EXPR		; get first <EXPR>
   1371 0000E7D4                        XP_AND1
   1372 0000E7D4 E3 D1                   	sw		r1,2[sp]	; save <EXPR> value
   1373 0000E7D6 1D 4E 0F 19             	lea		r9,TAB9		; look up a logical operator
   1374 0000E7DA 24 4E 00 1A             	lea		r10,TAB9_1
   1375 0000E7DE D3 4F 07 AE             	jmp		EXEC		; go do it
                                        
   1377 0000E7E2                        XP_AND
   1378 0000E7E2 2F AF                       call    EXPR
   1379 0000E7E4 E3 F2                       lw      r2,2[sp]
   1380 0000E7E6 25 21                       and     r1,r2
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 23
tb.asm
   1381 0000E7E8 F5 BE                       br      XP_AND1
                                        
   1383 0000E7EA                        XP_ANDX
   1384 0000E7EA E3 F1                   	lw		r1,2[sp]
   1385 0000E7EC E1 FF                       lw      lr,[sp]
   1386 0000E7EE 04 6E                       add     sp,sp,#4
   1387 0000E7F0 F0 80                       ret
                                        
                                        
                                        ; Determine if the character is a digit
                                        ;   Parameters
                                        ;       r2 = char to test
                                        ;   Returns
                                        ;       r1 = 1 if digit, otherwise 0
                                        ;
   1396 0000E7F2                        isDigit
   1397 0000E7F2 FD 4F 10 10                 cmp     r1,#'0'
   1398 0000E7F6 05 A0                       blt     isDigitFalse
   1399 0000E7F8 FC 4F 17 10                 cmp     r1,#'9'
   1400 0000E7FC 02 A3                       bgt     isDigitFalse
   1401 0000E7FE 01 11                       lw      r1,#1
   1402 0000E800 F0 80                       ret
   1403 0000E802                        isDigitFalse
   1404 0000E802 00 11                       lw      r1,#0
   1405 0000E804 F0 80                       ret
                                        
                                        
                                        ; Determine if the character is a alphabetic
                                        ;   Parameters
                                        ;       r2 = char to test
                                        ;   Returns
                                        ;       r1 = 1 if alpha, otherwise 0
                                        ;
   1414 0000E806                        isAlpha
   1415 0000E806 FB 4F 1F 10                 cmp     r1,#'A'
   1416 0000E80A 0B A0                       blt     isAlphaFalse
   1417 0000E80C FA 4F 16 10                 cmp     r1,#'Z'
   1418 0000E810 06 A2                       ble     isAlphaTrue
   1419 0000E812 F9 4F 1F 10                 cmp     r1,#'a'
   1420 0000E816 05 A0                       blt     isAlphaFalse
   1421 0000E818 F8 4F 16 10                 cmp     r1,#'z'
   1422 0000E81C 02 A3                       bgt     isAlphaFalse
   1423 0000E81E                        isAlphaTrue
   1424 0000E81E 01 11                       lw      r1,#1
   1425 0000E820 F0 80                       ret
   1426 0000E822                        isAlphaFalse
   1427 0000E822 00 11                       lw      r1,#0
   1428 0000E824 F0 80                       ret
                                        
                                        
                                        ; Determine if the character is a alphanumeric
                                        ;   Parameters
                                        ;       r1 = char to test
                                        ;   Returns
                                        ;       r1 = 1 if alpha, otherwise 0
                                        ;
   1437 0000E826                        isAlnum
   1438 0000E826 FE 6E                       sub     sp,sp,#2
   1439 0000E828 E1 DF                       sw      lr,[sp]
   1440 0000E82A 10 12                       lw      r2,r1		; save test char
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 24
tb.asm
   1441 0000E82C E2 BF                       call    isDigit
   1442 0000E82E 06 A9                       bne		isDigitx	; if it is a digit
   1443 0000E830 20 11                       lw      r1,r2		; get back test char
   1444 0000E832 E9 BF                       call    isAlpha
   1445 0000E834 E1 FF                       lw      lr,[sp]
   1446 0000E836 02 6E                       add		sp,sp,#2
   1447 0000E838 16 21                       or      r1,r1
   1448 0000E83A F0 80                       ret
   1449 0000E83C                        isDigitx
   1450 0000E83C E1 FF                       lw      lr,[sp]
   1451 0000E83E 02 6E                       add     sp,sp,#2	; return Z=0
   1452 0000E840 F0 80                       ret
                                        
                                        
   1455 0000E842                        EXPR
   1456 0000E842 FC 6E                   	sub		sp,sp,#4
   1457 0000E844 E1 DF                   	sw		lr,[sp]
   1458 0000E846 39 AF                   	call	EXPR2
   1459 0000E848 E3 D1                   	sw		r1,2[sp]	; save <EXPR2> value
   1460 0000E84A 1D 4E 05 19             	lea		r9,TAB8		; look up a relational operator
   1461 0000E84E 23 4E 02 1A             	lea		r10,TAB8_1
   1462 0000E852 CF 4F 0D AE             	jmp		EXEC		; go do it
                                        
   1464 0000E856                        XP11
   1465 0000E856 E3 F1                   	lw		r1,2[sp]
   1466 0000E858 28 AF                   	call	XP18	; is it ">="?
   1467 0000E85A 1D 22                   	cmp		r2,r1
   1468 0000E85C 1E A1                   	bge		XPRT1	; no, return r2=1
   1469 0000E85E 19 AE                   	br		XPRT0	; else return r2=0
                                        
   1471 0000E860                        XP12
   1472 0000E860 E3 F1                   	lw		r1,2[sp]
   1473 0000E862 23 AF                   	call	XP18	; is it "<>"?
   1474 0000E864 1D 22                   	cmp		r2,r1
   1475 0000E866 19 A9                   	bne		XPRT1	; no, return r2=1
   1476 0000E868 14 AE                   	br		XPRT0	; else return r2=0
                                        
   1478 0000E86A                        XP13
   1479 0000E86A E3 F1                   	lw		r1,2[sp]
   1480 0000E86C 1E AF                   	call	XP18	; is it ">"?
   1481 0000E86E 1D 22                   	cmp		r2,r1
   1482 0000E870 14 A3                   	bgt		XPRT1	; no, return r2=1
   1483 0000E872 0F AE                   	br		XPRT0	; else return r2=0
                                        
   1485 0000E874                        XP14
   1486 0000E874 E3 F1                   	lw		r1,2[sp]
   1487 0000E876 19 AF                   	call	XP18	; is it "<="?
   1488 0000E878 1D 22                   	cmp		r2,r1
   1489 0000E87A 0F A2                   	ble		XPRT1	; no, return r2=1
   1490 0000E87C 0A AE                   	br		XPRT0	; else return r2=0
                                        
   1492 0000E87E                        XP15
   1493 0000E87E E3 F1                   	lw		r1,2[sp]
   1494 0000E880 14 AF                   	call	XP18	; is it "="?
   1495 0000E882 1D 22                   	cmp		r2,r1
   1496 0000E884 0A A8                   	beq		XPRT1	; if not, return r2=1
   1497 0000E886 05 AE                   	br		XPRT0	; else return r2=0
                                        
                                        
   1500 0000E888                        XP16
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 25
tb.asm
   1501 0000E888 E3 F1                   	lw		r1,2[sp]
   1502 0000E88A 0F AF                   	call	XP18	; is it "<"?
   1503 0000E88C 1D 22                   	cmp		r2,r1
   1504 0000E88E 05 A0                   	blt		XPRT1	; if not, return r2=1
   1505 0000E890 00 AE                   	br		XPRT0	; else return r2=0
                                        
   1507 0000E892                        XPRT0
   1508 0000E892 E1 FF                   	lw		lr,[sp]
   1509 0000E894 04 6E                   	add		sp,sp,#4
   1510 0000E896 00 11                   	lw		r1,#0   ; return r1=0 (false)
   1511 0000E898 F0 80                   	ret
                                        
   1513 0000E89A                        XPRT1
   1514 0000E89A E1 FF                   	lw		lr,[sp]
   1515 0000E89C 04 6E                   	add		sp,sp,#4
   1516 0000E89E 01 11                   	lw		r1,#1	; return r1=1 (true)
   1517 0000E8A0 F0 80                   	ret
                                        
   1519 0000E8A2                        XP17				; it's not a rel. operator
   1520 0000E8A2 E3 F1                   	lw		r1,2[sp]	; return r2=<EXPR2>
   1521 0000E8A4 E1 FF                   	lw		lr,[sp]
   1522 0000E8A6 04 6E                   	add		sp,sp,#4
   1523 0000E8A8 F0 80                   	ret
                                        
   1525 0000E8AA                        XP18
   1526 0000E8AA FC 6E                   	sub		sp,sp,#4
   1527 0000E8AC E1 DF                   	sw		lr,[sp]
   1528 0000E8AE E3 D1                   	sw		r1,2[sp]
   1529 0000E8B0 04 AF                   	call	EXPR2		; do a second <EXPR2>
   1530 0000E8B2 E3 F2                   	lw		r2,2[sp]
   1531 0000E8B4 E1 FF                   	lw		lr,[sp]
   1532 0000E8B6 04 6E                   	add		sp,sp,#4
   1533 0000E8B8 F0 80                   	ret
                                        
                                        ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                                        
   1537 0000E8BA                        EXPR2
   1538 0000E8BA FC 6E                   	sub		sp,sp,#4
   1539 0000E8BC E1 DF                   	sw		lr,[sp]
   1540 0000E8BE 36 40 09 AF             	call	TSTC		; negative sign?
   1541 0000E8C2 2D 08                   	db	'-',XP21-*+1
   1542 0000E8C4 00 11                   	lw		r1,#0		; yes, fake '0-'
   1543 0000E8C6 E3 D1                   	sw		r1,2[sp]
   1544 0000E8C8 0F AE                   	br		XP26
   1545 0000E8CA                        XP21
   1546 0000E8CA 36 40 03 AF             	call	TSTC		; positive sign? ignore it
   1547 0000E8CE 2B 02                   	db	'+',XP22-*+1
   1548 0000E8D0                        XP22
   1549 0000E8D0 12 AF                   	call	EXPR3		; first <EXPR3>
   1550 0000E8D2                        XP23
   1551 0000E8D2 E3 D1                   	sw		r1,2[sp]	; yes, save the value
   1552 0000E8D4 35 40 0E AF             	call	TSTC		; add?
   1553 0000E8D8 2B 0A                   	db	'+',XP25-*+1
   1554 0000E8DA 0D AF                   	call	EXPR3		; get the second <EXPR3>
   1555 0000E8DC                        XP24
   1556 0000E8DC E3 F2                   	lw		r2,2[sp]
   1557 0000E8DE 20 21                   	add		r1,r2		; add it to the first <EXPR3>
                                        ;	BVS.L	QHOW		brnch if there's an overflow
   1559 0000E8E0 F8 BE                   	br		XP23		; else go back for more operations
   1560 0000E8E2                        XP25
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 26
tb.asm
   1561 0000E8E2 35 40 07 AF             	call	TSTC		; subtract?
   1562 0000E8E6 2D 08                   	db	'-',XP45-*+1
   1563 0000E8E8                        XP26
   1564 0000E8E8 06 AF                   	call	EXPR3		; get second <EXPR3>
   1565 0000E8EA 20 31                   	neg		r1			; change its sign
   1566 0000E8EC F7 BE                   	br		XP24		; and do an addition
                                        
   1568 0000E8EE                        XP45
   1569 0000E8EE E3 F1                   	lw		r1,2[sp]
   1570 0000E8F0 E1 FF                   	lw		lr,[sp]
   1571 0000E8F2 04 6E                   	add		sp,sp,#4
   1572 0000E8F4 F0 80                   	ret
                                        
                                        
                                        ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                                        
   1577 0000E8F6                        EXPR3
   1578 0000E8F6 FC 6E                   	sub		sp,sp,#4
   1579 0000E8F8 E1 DF                   	sw		lr,[sp]
   1580 0000E8FA 14 AF                   	call	EXPR4		; get first <EXPR4>
   1581 0000E8FC                        XP31
   1582 0000E8FC E3 D1                   	sw		r1,2[sp]	; yes, save that first result
   1583 0000E8FE 34 40 09 AF             	call	TSTC		; multiply?
   1584 0000E902 2A 0A                   	db	'*',XP34-*+1
   1585 0000E904 0F AF                   	call	EXPR4		; get second <EXPR4>
   1586 0000E906 E3 F2                   	lw		r2,2[sp]
   1587 0000E908 B8 AF                   	call	MULT32		; multiply the two
   1588 0000E90A F8 BE                   	br		XP31		 ; then look for more terms
   1589 0000E90C                        XP34
   1590 0000E90C 34 40 02 AF             	call	TSTC		; divide?
   1591 0000E910 2F 0C                   	db	'/',XP47-*+1
   1592 0000E912 08 AF                   	call	EXPR4		; get second <EXPR4>
   1593 0000E914 10 12                   	lw      r2,r1
   1594 0000E916 E3 F1                   	lw		r1,2[sp]
   1595 0000E918 CD AF                   	call	DIV32		; do the division
   1596 0000E91A F0 BE                   	br		XP31		; go back for any more terms
                                        
   1598 0000E91C                        XP47
   1599 0000E91C E3 F1                   	lw		r1,2[sp]
   1600 0000E91E E1 FF                   	lw		lr,[sp]
   1601 0000E920 04 6E                   	add		sp,sp,#4
   1602 0000E922 F0 80                   	ret
                                        
                                        
                                        ; Functions are called through EXPR4
                                        ; <EXPR4>::=<variable>
                                        ;	    <function>
                                        ;	    (<EXPR>)
                                        
   1610 0000E924                        EXPR4
   1611 0000E924 FA 6E                       sub     sp,sp,#6
   1612 0000E926 E1 DF                       sw      lr,[sp]
   1613 0000E928 1A 4E 0A 19             	lea		r9,TAB4		; find possible function
   1614 0000E92C 21 4E 08 1A             	lea		r10,TAB4_1
   1615 0000E930 C8 4F 0E AE             	jmp		EXEC        ; branch to function which does subsequent
                                        	                    ; ret for EXPR4
                                        
   1618 0000E934                        XP40                    ; we get here if it wasn't a function
   1619 0000E934 00 11                   	lw		r1,#0
   1620 0000E936 1D AF                   	call	TSTV		
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 27
tb.asm
   1621 0000E938 04 A8                   	beq     XP41        ; nor a variable
   1622 0000E93A 11 F1                   	lw		r1,[r1]		; if a variable, return its value in r1
   1623 0000E93C E1 FF                   	lw      lr,[sp]
   1624 0000E93E 06 6E                   	add     sp,sp,#6
   1625 0000E940 F0 80                   	ret
   1626 0000E942                        XP41
   1627 0000E942 33 40 09 AF             	call	TSTNUM		; or is it a number?
   1628 0000E946 26 22                   	or		r2,r2		; (if not, # of digits will be zero)
   1629 0000E948 01 A9                   	bne		XP46		; if so, return it in r1
   1630 0000E94A 03 AF                   	call    PARN        ; check for (EXPR)
   1631 0000E94C                        XP46
   1632 0000E94C E1 FF                   	lw      lr,[sp]
   1633 0000E94E 06 6E                   	add     sp,sp,#6
   1634 0000E950 F0 80                   	ret
                                        
                                        
                                        ; Check for a parenthesized expression
   1638 0000E952                        PARN
   1639 0000E952 FE 6E                   	sub		sp,sp,#2
   1640 0000E954 E1 DF                   	sw		lr,[sp]
   1641 0000E956 31 40 0D AF             	call	TSTC		; else look for ( OREXPR )
   1642 0000E95A 28 10                   	db	'(',XP43-*+1
   1643 0000E95C 26 BF                   	call	OREXPR
   1644 0000E95E 31 40 09 AF             	call	TSTC
   1645 0000E962 29 08                   	db	')',XP43-*+1
   1646 0000E964                        XP42
   1647 0000E964 E1 FF                   	lw		lr,[sp]
   1648 0000E966 02 6E                   	add		sp,sp,#2
   1649 0000E968 F0 80                   	ret
   1650 0000E96A                        XP43
   1651 0000E96A 21 4F 0F 11             	lea		r1,msgWhat
   1652 0000E96E 16 40 0D AE             	br		ERROR
                                        
                                        
                                        ; ===== Test for a valid variable name.  Returns Z=1 if not
                                        ;	found, else returns Z=0 and the address of the
                                        ;	variable in r1.
                                        ; Parameters
                                        ;	r1 = 1 = allocate if not found
                                        ; Returns
                                        ;	r1 = address of variable, zero if not found
                                        
   1663 0000E972                        TSTV
   1664 0000E972 FA 6E                   	sub		sp,sp,#6
   1665 0000E974 E1 DF                   	sw		lr,[sp]
   1666 0000E976 E3 D5                   	sw		r5,2[sp]
   1667 0000E978 10 15                   	lw		r5,r1		; allocate flag
   1668 0000E97A 33 40 0E AF             	call	IGNBLK
   1669 0000E97E 80 E1                   	lb		r1,[r8]		; look at the program text
   1670 0000E980 FC 4F 10 10             	cmp     r1,#'@'
   1671 0000E984 1C A0                   	blt     tstv_notfound   ; C=1: not a variable
   1672 0000E986 12 A9                   	bne		TV1			; brnch if not "@" array
   1673 0000E988 01 68                   	add		r8,r8,#1	; If it is, it should be
   1674 0000E98A E3 BF                   	call	PARN		; followed by (EXPR) as its index.
   1675 0000E98C 81 31                   	shl     r1,#1
   1676 0000E98E 81 31                   	shl     r1,#1
                                        ;	BCS.L	QHOW		say "How?" if index is too big
   1678 0000E990 E5 D1                       sw      r1,4[sp]    ; save the index
   1679 0000E992 F4 6E                       sub		sp,sp,#12
   1680 0000E994 E1 DF                       sw		lr,[sp]
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 28
tb.asm
   1681 0000E996 10 40 0F AF             	call	SIZEX		; get amount of free memory
   1682 0000E99A E5 F2                   	lw      r2,4[sp]    ; get back the index
   1683 0000E99C 1D 22                   	cmp     r2,r1       ; see if there's enough memory
   1684 0000E99E 02 A4                   	bltu	TV2
   1685 0000E9A0 14 40 0F AE             	jmp    	QSORRY		; if not, say "Sorry"
   1686 0000E9A4                        TV2
   1687 0000E9A4 09 40 09 F1             	lw      r1,VARBGN   ; put address of array element...
   1688 0000E9A8 22 21                   	sub     r1,r2       ; into r1 (neg. offset is used)
   1689 0000E9AA 05 AE                   	br      TSTVRT
   1690 0000E9AC                        TV1	
   1691 0000E9AC 0D AF                       call    getVarName      ; get variable name
   1692 0000E9AE 07 A8                       beq     tstv_notfound   ; if not, set Z=1 and return
   1693 0000E9B0 50 12                       lw		r2,r5
   1694 0000E9B2 45 AF                       call    findVar     ; find or allocate
   1695 0000E9B4 04 A8                       beq		tstv_notfound
   1696 0000E9B6                        TSTVRT
   1697 0000E9B6 E3 F5                   	lw		r5,2[sp]
   1698 0000E9B8 E1 FF                   	lw		lr,[sp]
   1699 0000E9BA 06 6E                   	add		sp,sp,#6    ; Z=0 (found)
   1700 0000E9BC F0 80                   	ret
   1701 0000E9BE                        tstv_notfound
   1702 0000E9BE E3 F5                   	lw		r5,2[sp]
   1703 0000E9C0 E1 FF                       lw      lr,[sp]
   1704 0000E9C2 06 6E                       add     sp,sp,#6
   1705 0000E9C4 00 11                       lw      r1,#0       ; Z=1 if not found
   1706 0000E9C6 F0 80                       ret
                                        
                                        
                                        ; Returns
                                        ;   r1 = 3 character variable name + type
                                        ;
   1712 0000E9C8                        getVarName
   1713 0000E9C8 FA 6E                       sub     sp,sp,#6
   1714 0000E9CA E1 DF                       sw      lr,[sp]
   1715 0000E9CC E5 D5                       sw		r5,4[sp]
                                        
   1717 0000E9CE 80 E1                       lb      r1,[r8]     ; get first character
   1718 0000E9D0 E3 D1                       sw		r1,2[sp]	; save off current name
   1719 0000E9D2 19 BF                       call    isAlpha
   1720 0000E9D4 2F A8                       beq     gvn1
   1721 0000E9D6 02 15                       lw      r5,#2       ; loop twice more
                                        
                                        	; check for second/third character
   1724 0000E9D8                        gvn4
   1725 0000E9D8 01 68                   	add     r8,r8,#1
   1726 0000E9DA 80 E1                   	lb      r1,[r8]     ; do we have another char ?
   1727 0000E9DC 24 BF                   	call    isAlnum
   1728 0000E9DE 12 A8                   	beq     gvn2        ; nope
   1729 0000E9E0 E3 F1                   	lw      r1,2[sp]    ; get varname
   1730 0000E9E2 81 31                   	shl     r1,#1       ; shift left by eight
   1731 0000E9E4 81 31                   	shl     r1,#1       ; shift left by eight
   1732 0000E9E6 81 31                   	shl     r1,#1       ; shift left by eight
   1733 0000E9E8 81 31                   	shl     r1,#1       ; shift left by eight
   1734 0000E9EA 81 31                   	shl     r1,#1       ; shift left by eight
   1735 0000E9EC 81 31                   	shl     r1,#1       ; shift left by eight
   1736 0000E9EE 81 31                   	shl     r1,#1       ; shift left by eight
   1737 0000E9F0 81 31                   	shl     r1,#1       ; shift left by eight
   1738 0000E9F2 80 E2                   	lb      r2,[r8]
   1739 0000E9F4 26 21                   	or      r1,r2       ; add in new char
   1740 0000E9F6 E3 D1                       sw      r1,2[sp]   ; save off name again
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 29
tb.asm
   1741 0000E9F8 FF 65                       sub		r5,r5,#1
   1742 0000E9FA EE B9                       bne     gvn4
                                        
                                            ; now ignore extra variable name characters
   1745 0000E9FC                        gvn6
   1746 0000E9FC 01 68                       add     r8,r8,#1
   1747 0000E9FE 80 E1                       lb      r1,[r8]
   1748 0000EA00 12 BF                       call    isAlnum
   1749 0000EA02 FC B9                       bne     gvn6        ; keep looping as long as we have identifier chars
                                            
   1751 0000EA04                        gvn2
   1752 0000EA04 80 E1                   	lb		r1,[r8]
   1753 0000EA06 FD 4F 1B 10                 cmp     r1,#'%'
   1754 0000EA0A 05 A8                       beq     gvn3
   1755 0000EA0C FD 4F 1C 10                 cmp     r1,#'$'
   1756 0000EA10 02 A8                       beq     gvn3
   1757 0000EA12 00 11                       lw      r1,#0
   1758 0000EA14 FF 68                       sub     r8,r8,#1
                                        
                                            ; insert variable type indicator and return
   1761 0000EA16                        gvn3
   1762 0000EA16 01 68                       add     r8,r8,#1
   1763 0000EA18 E3 F2                       lw      r2,2[sp]
   1764 0000EA1A 81 32                       shl     r2,#1
   1765 0000EA1C 81 32                       shl     r2,#1
   1766 0000EA1E 81 32                       shl     r2,#1
   1767 0000EA20 81 32                       shl     r2,#1
   1768 0000EA22 81 32                       shl     r2,#1
   1769 0000EA24 81 32                       shl     r2,#1
   1770 0000EA26 81 32                       shl     r2,#1
   1771 0000EA28 81 32                       shl     r2,#1
   1772 0000EA2A 26 21                       or      r1,r2       ; add in variable type
   1773 0000EA2C E1 FF                       lw      lr,[sp]
   1774 0000EA2E E5 F5                       lw		r5,4[sp]
   1775 0000EA30 06 6E                       add     sp,sp,#6   ; return Z = 0, r1 = varname
   1776 0000EA32 F0 80                       ret
                                        
                                            ; not a variable name
   1779 0000EA34                        gvn1
   1780 0000EA34 E1 FF                       lw      lr,[sp]
   1781 0000EA36 E5 F5                       lw		r5,4[sp]
   1782 0000EA38 06 6E                       add     sp,sp,#6
   1783 0000EA3A 00 11                       lw      r1,#0       ; return Z = 1 if not a varname
   1784 0000EA3C F0 80                       ret
                                        
                                        
                                        ; Find variable
                                        ;   r1 = varname
                                        ;	r2 = allocate flag
                                        ; Returns
                                        ;   r1 = variable address, Z =0 if found / allocated, Z=1 if not found
                                        
   1793 0000EA3E                        findVar
   1794 0000EA3E FC 6E                       sub     sp,sp,#4
   1795 0000EA40 E1 DF                       sw      lr,[sp]
   1796 0000EA42 E3 D7                       sw      r7,2[sp]
   1797 0000EA44 09 40 09 F3                 lw      r3,VARBGN
   1798 0000EA48                        fv4
   1799 0000EA48 31 F7                       lw      r7,[r3]     ; get varname / type
   1800 0000EA4A 0A A8                       beq     fv3         ; no more vars ?
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 30
tb.asm
   1801 0000EA4C 7D 21                       cmp     r1,r7       ; match ?
   1802 0000EA4E 0B A8                       beq     fv1
   1803 0000EA50 08 63                       add     r3,r3,#8    ; move to next var
   1804 0000EA52 0A 40 01 F7                 lw      r7,STKBOT
   1805 0000EA56 7D 23                       cmp     r3,r7
   1806 0000EA58 F7 B0                       blt     fv4         ; loop back to look at next var
                                        
                                            ; variable not found
                                            ; no more memory
   1810 0000EA5A 27 4F 02 11                 lea     r1,msgVarSpace
   1811 0000EA5E F6 AE                       br      ERROR
                                        ;    lw      lr,[sp]
                                        ;    lw      r7,2[sp]
                                        ;    add     sp,sp,#4
                                        ;    lw      r1,#0
                                        ;    ret
                                        
                                            ; variable not found
                                            ; allocate new ?
   1820 0000EA60                        fv3
   1821 0000EA60 26 22                   	or		r2,r2
   1822 0000EA62 06 A8                   	beq		fv2
   1823 0000EA64 31 D1                       sw      r1,[r3]     ; save varname / type
                                            ; found variable
                                            ; return address
   1826 0000EA66                        fv1
   1827 0000EA66 34 11                       add     r1,r3,#4
   1828 0000EA68 E1 FF                       lw      lr,[sp]
   1829 0000EA6A E3 F7                       lw      r7,2[sp]
   1830 0000EA6C 04 6E                       add     sp,sp,#4    ; Z = 0, r1 = address
   1831 0000EA6E F0 80                       ret
                                        
                                            ; didn't find var and not allocating
   1834 0000EA70                        fv2
   1835 0000EA70 E1 FF                       lw      lr,[sp]
   1836 0000EA72 E3 F7                       lw      r7,2[sp]
   1837 0000EA74 04 6E                       add     sp,sp,#4    ; Z = 0, r1 = address
   1838 0000EA76 00 11                   	lw		r1,#0		; Z = 1, r1 = 0
   1839 0000EA78 F0 80                       ret
                                        
                                        
                                        ; ===== Multiplies the 32 bit values in r1 and r2, returning
                                        ;	the 32 bit result in r1.
                                        ;
                                        
   1846 0000EA7A                        MULT32
   1847 0000EA7A FA 6E                   	sub		sp,sp,#6
   1848 0000EA7C E1 D5                   	sw		r5,[sp]		; w
   1849 0000EA7E E3 D6                   	sw		r6,2[sp]	; s
   1850 0000EA80 E5 D7                   	sw		r7,4[sp]
                                        
   1852 0000EA82 00 15                   	lw		r5,#0		; w = 0;
   1853 0000EA84 10 16                   	lw		r6,r1
   1854 0000EA86 24 26                   	xor		r6,r2		; s = a ^ b
   1855 0000EA88 16 21                   	or		r1,r1
   1856 0000EA8A 01 AB                   	bpl		mult1
   1857 0000EA8C 20 31                   	neg		r1
   1858 0000EA8E                        mult1
   1859 0000EA8E 26 22                   	or		r2,r2
   1860 0000EA90 01 AB                   	bpl		mult2
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 31
tb.asm
   1861 0000EA92 20 32                   	neg		r2
   1862 0000EA94                        mult2
   1863 0000EA94 10 17                   	lw		r7,r1
   1864 0000EA96 51 37                   	and		r7,#1
   1865 0000EA98 01 A8                   	beq		mult3
   1866 0000EA9A 20 25                   	add		r5,r2		; w += b
   1867 0000EA9C                        mult3
   1868 0000EA9C 81 32                   	shl		r2,#1		; b <<= 1
   1869 0000EA9E A1 31                   	shr		r1,#1		; a >>= 1
   1870 0000EAA0 F9 B9                   	bne		mult2       ; a = 0 ?
   1871 0000EAA2                        mult4
   1872 0000EAA2 66 26                       or      r6,r6
   1873 0000EAA4 01 AB                   	bpl		mult5
   1874 0000EAA6 20 35                   	neg		r5
   1875 0000EAA8                        mult5
   1876 0000EAA8 50 11                   	lw		r1,r5
   1877 0000EAAA E5 F7                   	lw		r7,4[sp]
   1878 0000EAAC E3 F6                   	lw		r6,2[sp]
   1879 0000EAAE E1 F5                   	lw		r5,[sp]
   1880 0000EAB0 06 6E                   	add		sp,sp,#6
   1881 0000EAB2 F0 80                   	ret
                                        
                                        
                                        ; ===== Divide the 32 bit value in r2 by the 32 bit value in r3.
                                        ;	Returns the 32 bit quotient in r1, remainder in r2
                                        ;
                                        ; r2 = a
                                        ; r3 = b
                                        ; r6 = remainder
                                        ; r7 = iteration count
                                        ; r8 = sign
                                        ;
                                        
                                        ; q = a / b
                                        ; a = r1
                                        ; b = r2
                                        ; q = r2
                                        
   1899 0000EAB4                        DIV32
   1900 0000EAB4 26 22                       or      r2,r2       ; check for divide-by-zero
   1901 0000EAB6 03 A9                       bne		div6
   1902 0000EAB8 25 4F 0F 11                 lea		r1,msgDivZero
   1903 0000EABC C7 AE                       br		ERROR		; divide by zero error
   1904 0000EABE                        div6
   1905 0000EABE FA 6E                   	sub		sp,sp,#6
   1906 0000EAC0 E1 D6                   	sw		r6,[sp]
   1907 0000EAC2 E3 D7                   	sw		r7,2[sp]
   1908 0000EAC4 E5 D8                   	sw		r8,4[sp]
                                        
   1910 0000EAC6 02 40 00 18                 lw      r8,#32      ; iteration count for 32 bits
   1911 0000EACA 00 16                   	lw		r6,#0		; r = 0
   1912 0000EACC 20 17                       lw      r7,r2       ; r7 = sign of result
   1913 0000EACE 14 27                       xor     r7,r1
   1914 0000EAD0 16 21                   	or	    r1,r1	    ; take absolute value of r1 (a)
   1915 0000EAD2 01 AB                   	bpl     div1
   1916 0000EAD4 20 31                   	neg     r1
   1917 0000EAD6                        div1
   1918 0000EAD6 26 22                       or      r2,r2	    ; take absolute value of r2 (b)
   1919 0000EAD8 01 AB                   	bpl	    div2
   1920 0000EADA 20 32                   	neg     r2
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 32
tb.asm
   1921 0000EADC                        div2
   1922 0000EADC 81 31                   	shl		r1,#1		; a <<= 1
   1923 0000EADE 61 26                   	adc		r6,r6		; r <<= 1
   1924 0000EAE0 6D 22                   	cmp		r2,r6		; b < r ?
   1925 0000EAE2 02 A7                   	bgtu	div4
   1926 0000EAE4 22 26                   	sub		r6,r2		; r -= b
   1927 0000EAE6 61 31                   	or      r1,#1       ; a |= 1
   1928 0000EAE8                        div4
   1929 0000EAE8 FF 68                   	sub		r8,r8,#1
   1930 0000EAEA F8 B9                       bne     div2        ; n--
   1931 0000EAEC 76 27                   	or      r7,r7
   1932 0000EAEE 01 AB                   	bpl     div5
   1933 0000EAF0 20 31                   	neg     r1
   1934 0000EAF2                        div5
   1935 0000EAF2 60 12                   	lw		r2,r6		; r2 = r
   1936 0000EAF4 E3 F7                   	lw		r7,2[sp]
   1937 0000EAF6 E5 F8                   	lw		r8,4[sp]
   1938 0000EAF8 E1 F6                   	lw		r6,[sp]
   1939 0000EAFA 06 6E                   	add		sp,sp,#6
   1940 0000EAFC F0 80                   	ret
                                        
                                        ; ===== The PEEK function returns the byte stored at the address
                                        ;	contained in the following expression.
                                        ;
   1945 0000EAFE                        PEEK
   1946 0000EAFE 29 BF                   	call	PARN		; get the memory address
   1947 0000EB00 10 E1                   	lb		r1,[r1]		; get the addressed byte
   1948 0000EB02 0E 21                   	zxb		r1			; upper 3 bytes will be zero
   1949 0000EB04 E1 FF                   	lw		lr,[sp]	; and return it
   1950 0000EB06 06 6E                   	add		sp,sp,#6
   1951 0000EB08 F0 80                   	ret
                                        
                                        
                                        ; ===== The PEEK function returns the byte stored at the address
                                        ;	contained in the following expression.
                                        ;
   1957 0000EB0A                        PEEKC
   1958 0000EB0A 23 BF                   	call	PARN		; get the memory address
   1959 0000EB0C 5E 31                   	and		r1,#-2		; align to char address
   1960 0000EB0E 10 F1                   	lh		r1,[r1]		; get the addressed char
   1961 0000EB10 1E 21                   	zxc		r1
   1962 0000EB12 E1 FF                   	lw		lr,[sp]	; and return it
   1963 0000EB14 06 6E                   	add		sp,sp,#6
   1964 0000EB16 F0 80                   	ret
                                        
                                        
                                        ; ===== The PEEK function returns the byte stored at the address
                                        ;	contained in the following expression.
                                        ;
   1970 0000EB18                        PEEKW
   1971 0000EB18 1C BF                   	call	PARN		; get the memory address
   1972 0000EB1A 5C 31                   	and		r1,#-4		; align to word address
   1973 0000EB1C 11 F1                   	lw		r1,[r1]		; get the addressed word
   1974 0000EB1E E1 FF                   	lw		lr,[sp]	; and return it
   1975 0000EB20 06 6E                   	add		sp,sp,#6
   1976 0000EB22 F0 80                   	ret
                                        
                                        
                                        ; user function call
                                        ; call the user function with argument in r1
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 33
tb.asm
   1981 0000EB24                        USRX
   1982 0000EB24 16 BF                   	call	PARN		; get expression value
   1983 0000EB26 E3 D8                   	sw		r8,2[sp]	; save the text pointer
   1984 0000EB28 02 40 05 F2             	lw      r2,usrJmp   ; get usr vector
   1985 0000EB2C A6 48 08 AF             	call	[r2]		; jump to the subroutine
   1986 0000EB30 E3 F8                   	lw		r8,2[sp]	; restore the text pointer
   1987 0000EB32 E1 FF                   	lw		lr,[sp]
   1988 0000EB34 06 6E                   	add		sp,sp,#6
   1989 0000EB36 F0 80                   	ret
                                        
                                        
                                        ; ===== The RND function returns a random number from 1 to
                                        ;	the value of the following expression in D0.
                                        ;
   1995 0000EB38                        RND
   1996 0000EB38 0C BF                   	call	PARN		; get the upper limit
   1997 0000EB3A 16 21                   	or		r1,r1		; it must be positive and non-zero
   1998 0000EB3C 0E A8                   	beq		rnd2
   1999 0000EB3E 0A AA                   	bmi		rnd1
   2000 0000EB40 10 12                   	lw		r2,r1
   2001 0000EB42 CA 4D 04 D0             	sh		r0,RAND+4	; read command
   2002 0000EB46 CA 4D 01 F1             	lw		r1,RAND		; get a number
   2003 0000EB4A 0E AF                   	call	modu4		; RND(n)=MOD(number,n)+1
   2004 0000EB4C 01 61                   	add		r1,r1,#1
   2005 0000EB4E E1 FF                   	lw		lr,[sp]
   2006 0000EB50 06 6E                   	add		sp,sp,#6
   2007 0000EB52 F0 80                   	ret
   2008 0000EB54                        rnd1
   2009 0000EB54 2E 4F 03 11             	lea		r1,msgRNDBad
   2010 0000EB58 79 AE                   	br		ERROR
   2011 0000EB5A                        rnd2
   2012 0000EB5A CA 4D 04 D0             	sh		r0,RAND+4
   2013 0000EB5E CA 4D 01 F1             	lw		r1,RAND
   2014 0000EB62 E1 FF                   	lw		lr,[sp]
   2015 0000EB64 06 6E                   	add		sp,sp,#6
   2016 0000EB66 F0 80                   	ret
                                        
                                        
                                        ; r = a mod b
                                        ; a = r2
                                        ; b = r3
                                        ; r = r1
   2023 0000EB68                        modu4
   2024 0000EB68 FA 6E                   	sub		sp,sp,#6
   2025 0000EB6A E1 D5                   	sw		r5,[sp]
   2026 0000EB6C E3 D6                   	sw		r6,2[sp]
   2027 0000EB6E E5 D7                   	sw		r7,4[sp]
   2028 0000EB70 02 40 00 17             	lw      r7,#32		; n = 32
   2029 0000EB74 00 15                   	lw		r5,#0		; w = 0
   2030 0000EB76 00 16                   	lw		r6,#0		; r = 0
   2031 0000EB78                        mod2
   2032 0000EB78 81 31                   	shl		r1,#1		; a <<= 1
   2033 0000EB7A 61 26                   	adc		r6,r6		; r <<= 1
   2034 0000EB7C 6D 22                   	cmp		r2,r6		; b < r ?
   2035 0000EB7E 01 A7                   	bgtu	mod1
   2036 0000EB80 22 26                   	sub		r6,r2		; r -= b
   2037 0000EB82                        mod1
   2038 0000EB82 FF 67                   	sub		r7,r7,#1
   2039 0000EB84 F9 B9                       bne     mod2        ; n--
   2040 0000EB86 60 11                   	lw		r1,r6
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 34
tb.asm
   2041 0000EB88 E1 F5                   	lw		r5,[sp]
   2042 0000EB8A E3 F6                   	lw		r6,2[sp]
   2043 0000EB8C E5 F7                   	lw		r7,4[sp]
   2044 0000EB8E 06 6E                   	add		sp,sp,#6
   2045 0000EB90 F0 80                   	ret
                                        
                                        
                                        
                                        ; ===== The ABS function returns an absolute value in r2.
                                        ;
   2051 0000EB92                        ABS
   2052 0000EB92 ED 4F 0E AF             	call	PARN		; get the following expr.'s value
   2053 0000EB96 16 21                   	or		r1,r1
   2054 0000EB98 01 AB                   	bpl		abs1
   2055 0000EB9A 20 31                   	neg		r1			; if negative, complement it
                                        ;	bmi		QHOW		; if still negative, it was too big
   2057 0000EB9C                        abs1
   2058 0000EB9C E1 FF                   	lw		lr,[sp]
   2059 0000EB9E 06 6E                   	add		sp,sp,#6
   2060 0000EBA0 F0 80                   	ret
                                        
                                        
                                        ; ===== The SGN function returns the sign in r1. +1,0, or -1
                                        ;
   2065 0000EBA2                        SGN
   2066 0000EBA2 ED 4F 06 AF             	call	PARN		; get the following expr.'s value
   2067 0000EBA6 16 21                   	or		r1,r1
   2068 0000EBA8 04 A8                   	beq		sgn1
   2069 0000EBAA 02 AB                   	bpl		sgn2
   2070 0000EBAC 0F 11                   	lw		r1,#-1
   2071 0000EBAE 01 AE                   	br		sgn1
   2072 0000EBB0                        sgn2
   2073 0000EBB0 01 11                   	lw		r1,#1
   2074 0000EBB2                        sgn1
   2075 0000EBB2 E1 FF                   	lw		lr,[sp]
   2076 0000EBB4 06 6E                   	add		sp,sp,#6
   2077 0000EBB6 F0 80                   	ret
                                        
                                        
                                        ; ===== The SIZE function returns the size of free memory in r1.
                                        ;
   2082 0000EBB8                        SIZEX
   2083 0000EBB8 09 40 09 F1             	lw		r1,VARBGN	; get the number of free bytes...
   2084 0000EBBC 09 40 07 F2             	lw		r2,TXTUNF	; between 'TXTUNF' and 'VARBGN'
   2085 0000EBC0 22 21                   	sub		r1,r2
   2086 0000EBC2 E1 FF                   	lw		lr,[sp]
   2087 0000EBC4 06 6E                   	add		sp,sp,#6
   2088 0000EBC6 F0 80                   	ret					; return the number in r2
                                        
                                        ; ==== Return the node number that the code is running on
                                        ;
   2092 0000EBC8                        NODENUM
   2093 0000EBC8 E4 31                   	tsr		r1,ID
   2094 0000EBCA E1 FF                   	lw		lr,[sp]
   2095 0000EBCC 06 6E                   	add		sp,sp,#6
   2096 0000EBCE F0 80                   	ret
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 35
tb.asm
                                        ;
                                        ; 'SETVAL' expects a variable, followed by an equal sign and then
                                        ; an expression.  It evaluates the expression and sets the variable
                                        ; to that value.
                                        ;
                                        ; 'FIN' checks the end of a command.  If it ended with ":",
                                        ; execution continues.	If it ended with a CR, it finds the
                                        ; the next line and continues from there.
                                        ;
                                        ; 'ENDCHK' checks if a command is ended with a CR. This is
                                        ; required in certain commands, such as GOTO, RETURN, STOP, etc.
                                        ;
                                        ; 'ERROR' prints the string pointed to by A0. It then prints the
                                        ; line pointed to by CURRNT with a "?" inserted at where the
                                        ; old text pointer (should be on top of the stack) points to.
                                        ; Execution of Tiny BASIC is stopped and a warm start is done.
                                        ; If CURRNT is zero (indicating a direct command), the direct
                                        ; command is not printed. If CURRNT is -1 (indicating
                                        ; 'INPUT' command in progress), the input line is not printed
                                        ; and execution is not terminated but continues at 'INPERR'.
                                        ;
                                        ; Related to 'ERROR' are the following:
                                        ; 'QWHAT' saves text pointer on stack and gets "What?" message.
                                        ; 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                                        ; 'QSORRY' and 'ASORRY' do the same kind of thing.
                                        ; 'QHOW' and 'AHOW' also do this for "How?".
                                        ;
                                        
                                        ; returns
                                        ; r2 = variable's address
                                        ;
   2132 0000EBD0                        SETVAL
   2133 0000EBD0 FC 6E                       sub     sp,sp,#4
   2134 0000EBD2 E1 DF                       sw      lr,[sp]
   2135 0000EBD4 01 11                       lw		r1,#1		; allocate var
   2136 0000EBD6 EC 4F 0C AF                 call	TSTV		; variable name?
   2137 0000EBDA 03 A9                       bne		sv2
   2138 0000EBDC 2C 4F 0C 11                	lea		r1,msgVar
   2139 0000EBE0 35 AE                      	br		ERROR 
   2140 0000EBE2                        sv2
   2141 0000EBE2 E3 D1                   	sw      r1,2[sp]    ; save the variable's address
   2142 0000EBE4 1D 40 06 AF             	call	TSTC		; get past the "=" sign
   2143 0000EBE8 3D 12                   	db	'=',SV1-*+1
   2144 0000EBEA DD 4F 0E AF             	call	OREXPR		; evaluate the expression
   2145 0000EBEE E3 F2                   	lw      r2,2[sp]    ; get back the variable's address
   2146 0000EBF0 21 D1                   	sw      r1,[r2]     ; and save value in the variable
   2147 0000EBF2 20 11                   	lw		r1,r2		; return r1 = variable address
   2148 0000EBF4 E1 FF                   	lw      lr,[sp]
   2149 0000EBF6 04 6E                   	add     sp,sp,#4
   2150 0000EBF8 F0 80                   	ret
   2151 0000EBFA                        SV1
   2152 0000EBFA 26 AE                       br	    QWHAT		; if no "=" sign
                                        
                                        
   2155 0000EBFC                        FIN
   2156 0000EBFC FE 6E                   	sub		sp,sp,#2
   2157 0000EBFE E1 DF                   	sw		lr,[sp]
   2158 0000EC00 1C 40 08 AF             	call	TSTC		; *** FIN ***
   2159 0000EC04 3A 08                   	db	':',FI1-*+1
   2160 0000EC06 02 6E                   	add		sp,sp,#2	; if ":", discard return address
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 36
tb.asm
   2161 0000EC08 B7 4F 0D AE             	br		RUNSML		; continue on the same line
   2162 0000EC0C                        FI1
   2163 0000EC0C 1C 40 02 AF             	call	TSTC		; not ":", is it a CR?
   2164 0000EC10 0D 0A                   	db	CR,FI2-*+1
   2165 0000EC12 E1 FF                   	lw		lr,[sp]	; else return to the caller
   2166 0000EC14 02 6E                   	add		sp,sp,#2	; yes, purge return address
   2167 0000EC16 B6 4F 09 AE             	br		RUNNXL		; execute the next line
   2168 0000EC1A                        FI2
   2169 0000EC1A E1 FF                   	lw		lr,[sp]	; else return to the caller
   2170 0000EC1C 02 6E                   	add		sp,sp,#2
   2171 0000EC1E F0 80                   	ret
                                        
                                        
                                        ; Check that there is nothing else on the line
                                        ; Registers Affected
                                        ;   r1
                                        ;
   2178 0000EC20                        ENDCHK
   2179 0000EC20 FE 6E                   	sub		sp,sp,#2
   2180 0000EC22 E1 DF                   	sw		lr,[sp]
   2181 0000EC24 1E 40 09 AF             	call	IGNBLK
   2182 0000EC28 80 E1                   	lb		r1,[r8]
   2183 0000EC2A FF 4F 13 10             	cmp		r1,#CR		; does it end with a CR?
   2184 0000EC2E 03 A8                   	beq		ec1
   2185 0000EC30 3A 4F 06 11             	lea		r1,msgExtraChars
   2186 0000EC34 0B AE                   	jmp		ERROR
   2187 0000EC36                        ec1
   2188 0000EC36 E1 FF                   	lw		lr,[sp]
   2189 0000EC38 02 6E                   	add		sp,sp,#2
   2190 0000EC3A F0 80                   	ret
                                        
                                        
   2193 0000EC3C                        TOOBIG
   2194 0000EC3C 39 4F 01 11             	lea		r1,msgTooBig
   2195 0000EC40 05 AE                   	br		ERROR
   2196 0000EC42                        QSORRY
   2197 0000EC42 22 4F 07 11                 lea     r1,SRYMSG
   2198 0000EC46 02 AE                   	br	    ERROR
   2199 0000EC48                        QWHAT
   2200 0000EC48 21 4F 0F 11             	lea		r1,msgWhat
   2201 0000EC4C                        ERROR
   2202 0000EC4C 21 40 0D AF             	call	PRMESG		; display the error message
   2203 0000EC50 08 40 07 F1             	lw		r1,CURRNT	; get the current line number
   2204 0000EC54 A1 4F 0B A8             	beq		WSTART		; if zero, do a warm start
   2205 0000EC58 11 10                   	cmp		r1,#-1		; is the line no. pointer = -1?
   2206 0000EC5A C5 4F 0F A8             	beq		INPERR		; if so, redo input
   2207 0000EC5E 80 E5                   	lb		r5,[r8]		; save the char. pointed to
   2208 0000EC60 80 C0                   	sb		r0,[r8]		; put a zero where the error is
   2209 0000EC62 08 40 07 F1             	lw		r1,CURRNT	; point to start of current line
   2210 0000EC66 17 40 07 AF             	call	PRTLN		; display the line in error up to the 0
   2211 0000EC6A 10 16                   	lw      r6,r1       ; save off end pointer
   2212 0000EC6C 80 C5                   	sb		r5,[r8]		; restore the character
   2213 0000EC6E 03 40 0F 11             	lw		r1,#'?'		; display a "?"
   2214 0000EC72 9C 4F 07 AF             	call	GOOUT
   2215 0000EC76 00 12                   	lw      r2,#0       ; stop char = 0
   2216 0000EC78 6F 11                   	sub		r1,r6,#1	; point back to the error char.
   2217 0000EC7A B6 AF                   	call	PRTSTG		; display the rest of the line
   2218 0000EC7C A0 4F 07 AE             	jmp	    WSTART		; and do a warm start
                                        
                                        
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 37
tb.asm
                                        ;******************************************************************
                                        ;
                                        ; *** GETLN *** FNDLN (& friends) ***
                                        ;
                                        ; 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                                        ; the character in r3 (given by the caller), then it fills the
                                        ; buffer and echos. It ignores LF's but still echos
                                        ; them back. Control-H is used to delete the last character
                                        ; entered (if there is one), and control-X is used to delete the
                                        ; whole line and start over again. CR signals the end of a line,
                                        ; and causes 'GETLN' to return.
                                        ;
                                        ;
   2234 0000EC80                        GETLN
   2235 0000EC80 FC 6E                   	sub		sp,sp,#4
   2236 0000EC82 E1 DF                   	sw		lr,[sp]
   2237 0000EC84 E3 D5                   	sw		r5,2[sp]
   2238 0000EC86 9B 4F 0D AF             	call	GOOUT		; display the prompt
   2239 0000EC8A 01 11                   	lw		r1,#1		; turn on cursor flash
   2240 0000EC8C 03 40 0C C1             	sb		r1,cursFlash
   2241 0000EC90 02 40 00 11             	lw		r1,#' '		; and a space
   2242 0000EC94 9B 4F 06 AF             	call	GOOUT
   2243 0000EC98 0A 40 0E 18             	lea		r8,BUFFER	; r8 is the buffer pointer
   2244 0000EC9C                        GL1
   2245 0000EC9C 1E 40 03 AF             	call	CHKIO		; check keyboard
   2246 0000ECA0 FD B8                   	beq		GL1			; wait for a char. to come in
   2247 0000ECA2 FF 4F 18 10             	cmp		r1,#CTRLH	; delete last character?
   2248 0000ECA6 14 A8                   	beq		GL3			; if so
   2249 0000ECA8 FE 4F 18 10             	cmp		r1,#CTRLX	; delete the whole line?
   2250 0000ECAC 20 A8                   	beq		GL4			; if so
   2251 0000ECAE FF 4F 13 10             	cmp		r1,#CR		; accept a CR
   2252 0000ECB2 03 A8                   	beq		GL2
   2253 0000ECB4 FE 4F 10 10             	cmp		r1,#' '		; if other control char., discard it
   2254 0000ECB8 F1 B4                   	bltu	GL1
   2255 0000ECBA                        GL2
   2256 0000ECBA 80 C1                   	sb		r1,[r8]		; save the char.
   2257 0000ECBC 01 68                   	add		r8,r8,#1
   2258 0000ECBE 9A 4F 01 AF             	call	GOOUT		; echo the char back out
   2259 0000ECC2 8F E1                   	lb      r1,-1[r8]   ; get char back (GOOUT destroys r1)
   2260 0000ECC4 FF 4F 13 10             	cmp		r1,#CR		; if it's a CR, end the line
   2261 0000ECC8 25 A8                   	beq		GL7
   2262 0000ECCA F0 4F 83 10             	cmp		r8,#(BUFFER+BUFLEN-1)	; any more room?
   2263 0000ECCE E6 B4                   	bltu	GL1			; yes: get some more, else delete last char.
                                        
   2265 0000ECD0                        GL3
   2266 0000ECD0 08 11                   	lw		r1,#CTRLH	; delete a char. if possible
   2267 0000ECD2 99 4F 07 AF             	call	GOOUT
   2268 0000ECD6 02 40 00 11             	lw		r1,#' '
   2269 0000ECDA 99 4F 03 AF             	call	GOOUT
   2270 0000ECDE F5 4F 82 10             	cmp		r8,#BUFFER	; any char.'s left?
   2271 0000ECE2 DC B6                   	bleu	GL1			; if not
   2272 0000ECE4 08 11                   	lw		r1,#CTRLH	; if so, finish the BS-space-BS sequence
   2273 0000ECE6 98 4F 0D AF             	call	GOOUT
   2274 0000ECEA FF 68                   	sub		r8,r8,#1	; decrement the text pointer
   2275 0000ECEC D7 BE                   	br		GL1			; back for more
                                        
   2277 0000ECEE                        GL4
   2278 0000ECEE 80 11                   	lw		r1,r8		; delete the whole line
   2279 0000ECF0 F5 4F 12 15             	sub		r5,r1,#BUFFER   ; figure out how many backspaces we need
   2280 0000ECF4 0C A8                   	beq		GL6			; if none needed, brnch
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 38
tb.asm
   2281 0000ECF6                        GL5	
   2282 0000ECF6 08 11                   	lw		r1,#CTRLH	; and display BS-space-BS sequences
   2283 0000ECF8 98 4F 04 AF             	call	GOOUT
   2284 0000ECFC 02 40 00 11             	lw		r1,#' '
   2285 0000ED00 98 4F 00 AF             	call	GOOUT
   2286 0000ED04 08 11                   	lw		r1,#CTRLH
   2287 0000ED06 97 4F 0D AF             	call	GOOUT
   2288 0000ED0A FF 65                   	sub		r5,r5,#1
   2289 0000ED0C F4 B9                   	bne     GL5
   2290 0000ED0E                        GL6
   2291 0000ED0E 0A 40 0E 18             	lea		r8,BUFFER	; reinitialize the text pointer
   2292 0000ED12 C4 BE                   	br		GL1			; and go back for more
   2293 0000ED14                        GL7
   2294 0000ED14 00 11                   	lw		r1,#0		; turn off cursor flash
   2295 0000ED16 03 40 0C C1             	sb		r1,cursFlash
   2296 0000ED1A 0A 11                   	lw		r1,#LF		; echo a LF for the CR
   2297 0000ED1C 97 4F 02 AF             	call	GOOUT
   2298 0000ED20 E1 FF                   	lw		lr,[sp]
   2299 0000ED22 E3 F5                   	lw		r5,2[sp]
   2300 0000ED24 04 6E                   	add		sp,sp,#4
   2301 0000ED26 F0 80                   	ret
                                        
                                        
                                        ; 'FNDLN' finds a line with a given line no. (in r1) in the
                                        ; text save area.  r9 is used as the text pointer. If the line
                                        ; is found, r9 will point to the beginning of that line
                                        ; (i.e. the high byte of the line no.), and flags are Z.
                                        ; If that line is not there and a line with a higher line no.
                                        ; is found, r9 points there and flags are NC & NZ. If we reached
                                        ; the end of the text save area and cannot find the line, flags
                                        ; are C & NZ.
                                        ; Z=1 if line found
                                        ; N=1 if end of text save area
                                        ; Z=0 & N=0 if higher line found
                                        ;
                                        ; 'FNDLN' will initialize r9 to the beginning of the text save
                                        ; area to start the search. Some other entries of this routine
                                        ; will not initialize r9 and do the search.
                                        ; 'FNDLNP' will start with r9 and search for the line no.
                                        ; 'FNDNXT' will bump r9 by 2, find a CR and then start search.
                                        ; 'FNDSKP' uses r9 to find a CR, and then starts the search.
                                        ; return Z=1 if line is found, r9 = pointer to line
                                        ;
                                        ; Parameters
                                        ;	r1 = line number to find
                                        ;
   2327 0000ED28                        FNDLN
   2328 0000ED28 00 40 11 10             	cmp		r1,#0xFFFF	; line no. must be < 65535
   2329 0000ED2C 03 A6                   	bleu	fl1
   2330 0000ED2E 2B 4F 06 11             	lea		r1,msgLineRange
   2331 0000ED32 8C BE                   	br		ERROR
   2332 0000ED34                        fl1
   2333 0000ED34 01 4E 09 F9             	lw		r9,TXTBGN	; init. the text save pointer
                                        
   2335 0000ED38                        FNDLNP
   2336 0000ED38 09 40 07 FA             	lw		r10,TXTUNF	; check if we passed the end
   2337 0000ED3C FF 6A                   	sub		r10,r10,#1
   2338 0000ED3E AD 29                   	cmp		r9,r10
   2339 0000ED40 0F A7                   	bgtu	FNDRET		; if so, return with Z=0 & C=1
   2340 0000ED42 90 E3                   	lb		r3,[r9]		; get low order byte of line number
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 39
tb.asm
   2341 0000ED44 0E 23                   	zxb		r3
   2342 0000ED46 91 E2                   	lb		r2,1[r9]	; get high order byte
   2343 0000ED48 0E 22                   	zxb		r2
   2344 0000ED4A 81 32                   	shl		r2,#1
   2345 0000ED4C 81 32                   	shl		r2,#1
   2346 0000ED4E 81 32                   	shl		r2,#1
   2347 0000ED50 81 32                   	shl		r2,#1
   2348 0000ED52 81 32                   	shl		r2,#1
   2349 0000ED54 81 32                   	shl		r2,#1
   2350 0000ED56 81 32                   	shl		r2,#1
   2351 0000ED58 81 32                   	shl		r2,#1
   2352 0000ED5A 36 22                   	or		r2,r3		; build whole line number
   2353 0000ED5C 2D 21                   	cmp		r1,r2		; is this the line we want?
   2354 0000ED5E 01 A7                   	bgtu	FNDNXT		; no, not there yet
   2355 0000ED60                        FNDRET
   2356 0000ED60 F0 80                   	ret			; return the cond. codes
                                        
   2358 0000ED62                        FNDNXT
   2359 0000ED62 02 69                   	add		r9,r9,#2	; find the next line
                                        
   2361 0000ED64                        FNDSKP
   2362 0000ED64 90 E2                   	lb		r2,[r9]
   2363 0000ED66 01 69                   	add		r9,r9,#1
   2364 0000ED68 FF 4F 23 10             	cmp		r2,#CR		; try to find a CR
   2365 0000ED6C FB B9                   	bne		FNDSKP		; keep looking
   2366 0000ED6E E4 BE                   	br		FNDLNP		; check if end of text
                                        
                                        
                                        ;******************************************************************
                                        ; 'MVUP' moves a block up from where r1 points to where r2 points
                                        ; until r1=r3
                                        ;
   2373 0000ED70                        MVUP1
   2374 0000ED70 10 E4                   	lb		r4,[r1]
   2375 0000ED72 20 C4                   	sb		r4,[r2]
   2376 0000ED74 01 61                   	add		r1,r1,#1
   2377 0000ED76 01 62                   	add		r2,r2,#1
   2378 0000ED78                        MVUP
   2379 0000ED78 3D 21                   	cmp		r1,r3
   2380 0000ED7A FA B9                   	bne		MVUP1
   2381 0000ED7C                        MVRET
   2382 0000ED7C F0 80                   	ret
                                        
                                        
                                        ; 'MVDOWN' moves a block down from where r1 points to where r2
                                        ; points until r1=r3
                                        ;
   2388 0000ED7E                        MVDOWN1
   2389 0000ED7E FF 61                   	sub		r1,r1,#1
   2390 0000ED80 FF 62                   	sub		r2,r2,#1
   2391 0000ED82 10 E4                   	lb		r4,[r1]
   2392 0000ED84 20 C4                   	sb		r4,[r2]
   2393 0000ED86                        MVDOWN
   2394 0000ED86 3D 21                   	cmp		r1,r3
   2395 0000ED88 FA B9                   	bne		MVDOWN1
   2396 0000ED8A F0 80                   	ret
                                        
                                        
                                        ; 'POPA' restores the 'FOR' loop variable save area from the stack
                                        ;
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 40
tb.asm
                                        ; 'PUSHA' stacks for 'FOR' loop variable save area onto the stack
                                        ;
                                        ; Note: a single zero word is stored on the stack in the
                                        ; case that no FOR loops need to be saved. This needs to be
                                        ; done because PUSHA / POPA is called all the time.
                                        
   2407 0000ED8C                        POPA
   2408 0000ED8C E1 F1                   	lw		r1,[sp]		; restore LOPVAR, but zero means no more
   2409 0000ED8E 08 40 0D D1             	sw		r1,LOPVAR
   2410 0000ED92 0E A8                   	beq		PP1
   2411 0000ED94 E9 F1                   	lw		r1,8[sp]	; if not zero, restore the rest
   2412 0000ED96 09 40 05 D1             	sw		r1,LOPPT
   2413 0000ED9A E7 F1                   	lw		r1,6[sp]
   2414 0000ED9C 09 40 03 D1             	sw		r1,LOPLN
   2415 0000EDA0 E5 F1                   	lw		r1,4[sp]
   2416 0000EDA2 09 40 01 D1             	sw		r1,LOPLMT
   2417 0000EDA6 E3 F1                   	lw		r1,2[sp]
   2418 0000EDA8 08 40 0F D1             	sw		r1,LOPINC
   2419 0000EDAC 0A 6E                   	add		sp,sp,#10
   2420 0000EDAE F0 80                   	ret
   2421 0000EDB0                        PP1
   2422 0000EDB0 02 6E                   	add		sp,sp,#2
   2423 0000EDB2 F0 80                   	ret
                                        
                                        
   2426 0000EDB4                        PUSHA
   2427 0000EDB4 0A 40 01 F1             	lw		r1,STKBOT	; Are we running out of stack room?
   2428 0000EDB8 0A 61                   	add		r1,r1,#10	; we might need this many bytes
   2429 0000EDBA 1D 2E                   	cmp		sp,r1
   2430 0000EDBC 42 B4                   	bltu	QSORRY		; out of stack space
   2431 0000EDBE 08 40 0D F1             	lw		r1,LOPVAR	; save loop variables
   2432 0000EDC2 0F A8                   	beq		PU1			; if LOPVAR is zero, that's all
   2433 0000EDC4 F6 6E                   	sub		sp,sp,#10
   2434 0000EDC6 E1 D1                   	sw		r1,[sp]
   2435 0000EDC8 09 40 05 F1             	lw		r1,LOPPT
   2436 0000EDCC E9 D1                   	sw		r1,8[sp]	; else save all the others
   2437 0000EDCE 09 40 03 F1             	lw		r1,LOPLN
   2438 0000EDD2 E7 D1                   	sw		r1,6[sp]
   2439 0000EDD4 09 40 01 F1             	lw		r1,LOPLMT
   2440 0000EDD8 E5 D1                   	sw		r1,4[sp]
   2441 0000EDDA 08 40 0F F1             	lw		r1,LOPINC
   2442 0000EDDE E3 D1                   	sw		r1,2[sp]
   2443 0000EDE0 F0 80                   	ret
   2444 0000EDE2                        PU1
   2445 0000EDE2 FE 6E                   	sub		sp,sp,#2
   2446 0000EDE4 E1 D1                   	sw		r1,[sp]
   2447 0000EDE6 F0 80                   	ret
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** PRTSTG *** QTSTG *** PRTNUM *** PRTLN ***
                                        ;
                                        ; 'PRTSTG' prints a string pointed to by r3. It stops printing
                                        ; and returns to the caller when either a CR is printed or when
                                        ; the next byte is the same as what was passed in r4 by the
                                        ; caller.
                                        ;
                                        ; 'QTSTG' looks for an underline (back-arrow on some systems),
                                        ; single-quote, or double-quote.  If none of these are found, returns
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 41
tb.asm
                                        ; to the caller.  If underline, outputs a CR without a LF.  If single
                                        ; or double quote, prints the quoted string and demands a matching
                                        ; end quote.  After the printing, the next 2 bytes of the caller are
                                        ; skipped over (usually a short brnch instruction).
                                        ;
                                        ; 'PRTNUM' prints the 32 bit number in r3, leading blanks are added if
                                        ; needed to pad the number of spaces to the number in r4.
                                        ; However, if the number of digits is larger than the no. in
                                        ; r4, all digits are printed anyway. Negative sign is also
                                        ; printed and counted in, positive sign is not.
                                        ;
                                        ; 'PRTLN' prints the saved text line pointed to by r3
                                        ; with line no. and all.
                                        ;
                                        
                                        ; r1 = pointer to string
                                        ; r2 = stop character
                                        ; return r1 = pointer to end of line + 1
                                        
   2480 0000EDE8                        PRTSTG
   2481 0000EDE8 F8 6E                       sub     sp,sp,#8
   2482 0000EDEA E1 DF                       sw      lr,[sp]
   2483 0000EDEC E3 D5                       sw      r5,2[sp]
   2484 0000EDEE E5 D6                       sw      r6,4[sp]
   2485 0000EDF0 E7 D7                       sw      r7,6[sp]
   2486 0000EDF2 10 15                       lw      r5,r1       ; r5 = pointer
   2487 0000EDF4 20 16                       lw      r6,r2       ; r6 = stop char
   2488 0000EDF6                        PS1
   2489 0000EDF6 50 E7                       lb      r7,[r5]     ; get a text character
   2490 0000EDF8 01 65                       add     r5,r5,#1
   2491 0000EDFA 6D 27                   	cmp     r7,r6		; same as stop character?
   2492 0000EDFC 09 A8                   	beq	    PRTRET		; if so, return
   2493 0000EDFE 70 11                   	lw      r1,r7
   2494 0000EE00 90 4F 00 AF             	call	GOOUT		; display the char.
   2495 0000EE04 FF 4F 73 10             	cmp     r7,#CR      ; is it a C.R.?
   2496 0000EE08 F6 B9                   	bne	    PS1		    ; no, go back for more
   2497 0000EE0A 0A 11                   	lw      r1,#LF      ; yes, add a L.F.
   2498 0000EE0C 8F 4F 0A AF             	call	GOOUT
   2499 0000EE10                        PRTRET
   2500 0000EE10 70 12                       lw      r2,r7       ; return r2 = stop char
   2501 0000EE12 50 11                   	lw		r1,r5		; return r1 = line pointer
   2502 0000EE14 E3 F5                       lw      r5,2[sp]
   2503 0000EE16 E5 F6                       lw      r6,4[sp]
   2504 0000EE18 E7 F7                       lw      r7,6[sp]
   2505 0000EE1A E1 FF                       lw      lr,[sp]
   2506 0000EE1C 08 6E                       add     sp,sp,#8
   2507 0000EE1E F0 80                       ret			        ; then return
                                        
                                        
   2510 0000EE20                        QTSTG
   2511 0000EE20 FE 6E                   	sub		sp,sp,#2
   2512 0000EE22 E1 DF                   	sw		lr,[sp]
   2513 0000EE24 B7 AF                   	call	TSTC		; *** QTSTG ***
   2514 0000EE26 22 18                   	db	'"',QT3-*+1
   2515 0000EE28 02 40 02 12             	lw		r2,#'"'		; it is a "
   2516 0000EE2C                        QT1
   2517 0000EE2C 80 11                   	lw		r1,r8
   2518 0000EE2E DC BF                   	call	PRTSTG		; print until another
   2519 0000EE30 10 18                   	lw		r8,r1
   2520 0000EE32 FF 4F 26 10             	cmp		r2,#LF		; was last one a CR?
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 42
tb.asm
   2521 0000EE36 0E A9                   	bne		QT2
   2522 0000EE38 02 6E                   	add		sp,sp,#2
   2523 0000EE3A A5 4F 07 AE             	br		RUNNXL		; if so, run next line
   2524 0000EE3E                        QT3
   2525 0000EE3E AA AF                   	call	TSTC		; is it a single quote?
   2526 0000EE40 27 08                   	db	"'",QT4-*+1
   2527 0000EE42 02 40 07 12             	lw		r2,#''''	; if so, do same as above
   2528 0000EE46 F2 BE                   	br		QT1
   2529 0000EE48                        QT4
   2530 0000EE48 A5 AF                   	call	TSTC		; is it an underline?
   2531 0000EE4A 5F 10                   	db	'_',QT5-*+1
   2532 0000EE4C 00 40 0D 11             	lw		r1,#CR		; if so, output a CR without LF
   2533 0000EE50 8D 4F 08 AF             	call	GOOUT
   2534 0000EE54                        QT2
   2535 0000EE54 E1 FF                   	lw		lr,[sp]
   2536 0000EE56 02 6E                   	add		sp,sp,#2
   2537 0000EE58 F2 80                   	jmp		2[lr]		; skip over 2 bytes when returning
   2538 0000EE5A                        QT5						; not " ' or _
   2539 0000EE5A E1 FF                   	lw		lr,[sp]
   2540 0000EE5C 02 6E                   	add		sp,sp,#2
   2541 0000EE5E F0 80                   	ret
                                        
                                        
                                        ; Output a CR LF sequence
                                        ;
   2546 0000EE60                        prCRLF
   2547 0000EE60 FE 6E                   	sub		sp,sp,#2
   2548 0000EE62 E1 DF                   	sw		lr,[sp]
   2549 0000EE64 00 40 0D 11             	lw		r1,#CR
   2550 0000EE68 8C 4F 0C AF             	call	GOOUT
   2551 0000EE6C 0A 11                   	lw		r1,#LF
   2552 0000EE6E 8C 4F 09 AF             	call	GOOUT
   2553 0000EE72 E1 FF                   	lw		lr,[sp]
   2554 0000EE74 02 6E                   	add		sp,sp,#2
   2555 0000EE76 F0 80                   	ret
                                        
                                        
                                        ; r1 = number to print
                                        ; r2 = number of digits
                                        ; Register Usage
                                        ;	r5 = number of padding spaces
   2562 0000EE78                        PRTNUM
   2563 0000EE78 F8 6E                   	sub		sp,sp,#8
   2564 0000EE7A E1 DF                   	sw		lr,[sp]
   2565 0000EE7C E3 D5                   	sw		r5,2[sp]
   2566 0000EE7E E5 D6                   	sw		r6,4[sp]
   2567 0000EE80 E7 D7                   	sw		r7,6[sp]
                                        
   2569 0000EE82 0A 40 02 17             	lea		r7,NUMWKA	; r7 = pointer to numeric work area
   2570 0000EE86 10 16                   	lw		r6,r1		; save number for later
   2571 0000EE88 20 15                   	lw		r5,r2		; r5 = min number of chars
   2572 0000EE8A 16 21                   	
   2573 0000EE8C 02 AB                   	bpl		PN1			; if not
   2574 0000EE8E 20 31                   	neg		r1			; else make it positive
   2575 0000EE90 FF 65                   	sub		r5,r5,#1	; one less for width count
   2576 0000EE92                        PN1
   2577 0000EE92 0A 12                   	lw		r2,#10		; divide by 10
   2578 0000EE94 E0 4F 0E AF             	call	DIV32
   2579 0000EE98 30 62                   	add		r2,r2,#'0'	; convert remainder to ascii
   2580 0000EE9A 70 C2                   	sb		r2,[r7]		; and store in buffer
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 43
tb.asm
   2581 0000EE9C 01 67                   	add		r7,r7,#1
   2582 0000EE9E FF 65                   	sub		r5,r5,#1	; decrement width
   2583 0000EEA0 10 10                   	cmp		r1,#0
   2584 0000EEA2 F7 B9                   	bne		PN1
   2585 0000EEA4                        PN6
   2586 0000EEA4 56 25                   	or		r5,r5		; test pad count
   2587 0000EEA6 06 A2                   	ble		PN4			; skip padding if not needed
   2588 0000EEA8                        PN3
   2589 0000EEA8 02 40 00 11             	lw		r1,#' '		; display the required leading spaces
   2590 0000EEAC 8A 4F 0A AF             	call	GOOUT
   2591 0000EEB0 FF 65                   	sub		r5,r5,#1
   2592 0000EEB2 FA B9                   	bne		PN3
   2593 0000EEB4                        PN4
   2594 0000EEB4 66 26                   	or		r6,r6		; is number negative?
   2595 0000EEB6 04 AB                   	bpl		PN5
   2596 0000EEB8 02 40 0D 11             	lw		r1,#'-'		; if so, display the sign
   2597 0000EEBC 8A 4F 02 AF             	call	GOOUT
   2598 0000EEC0                        PN5
   2599 0000EEC0 FF 67                   	sub		r7,r7,#1
   2600 0000EEC2 70 E1                   	lb		r1,[r7]		; now unstack the digits and display
   2601 0000EEC4 89 4F 0E AF             	call	GOOUT
   2602 0000EEC8 F5 4F 7E 10             	cmp		r7,#NUMWKA
   2603 0000EECC F9 B7                   	bgtu	PN5
   2604 0000EECE                        PNRET
   2605 0000EECE E1 FF                   	lw		lr,[sp]
   2606 0000EED0 E3 F5                   	lw		r5,2[sp]
   2607 0000EED2 E5 F6                   	lw		r6,4[sp]
   2608 0000EED4 E7 F7                   	lw		r7,6[sp]
   2609 0000EED6 08 6E                   	add		sp,sp,#8
   2610 0000EED8 F0 80                   	ret
                                        
                                        
                                        ; r1 = number to print
                                        ; r2 = number of digits
   2615 0000EEDA                        PRTHEXNUM
   2616 0000EEDA F6 6E                   	sub		sp,sp,#10
   2617 0000EEDC E1 DF                   	sw		lr,[sp]
   2618 0000EEDE E3 D5                   	sw		r5,2[sp]
   2619 0000EEE0 E5 D6                   	sw		r6,4[sp]
   2620 0000EEE2 E7 D7                   	sw		r7,6[sp]
   2621 0000EEE4 E9 D8                   	sw		r8,8[sp]
                                        
   2623 0000EEE6 0A 40 02 17             	lea		r7,NUMWKA	; r7 = pointer to numeric work area
   2624 0000EEEA 10 16                   	lw		r6,r1		; save number for later
   2625 0000EEEC 0A 15                   	lw		r5,#10		; r5 = min number of chars
   2626 0000EEEE 10 14                   	lw		r4,r1
   2627 0000EEF0 46 24                   	
   2628 0000EEF2 03 AB                   	bpl		PHN1		; if not
   2629 0000EEF4 20 34                   	neg		r4			; else make it positive
   2630 0000EEF6 FF 65                   	sub		r5,r5,#1	; one less for width count
   2631 0000EEF8 0A 18                   	lw		r8,#10		; maximum of 10 digits
   2632 0000EEFA                        PHN1
   2633 0000EEFA 40 11                   	lw		r1,r4
   2634 0000EEFC 00 40 5F 31             	and		r1,#15
   2635 0000EF00 FF 4F 16 10             	cmp		r1,#10
   2636 0000EF04 02 A0                   	blt		PHN7
   2637 0000EF06 37 61                   	add		r1,r1,#'A'-10
   2638 0000EF08 01 AE                   	br		PHN8
   2639 0000EF0A                        PHN7
   2640 0000EF0A 30 61                   	add		r1,r1,#'0'		; convert remainder to ascii
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 44
tb.asm
   2641 0000EF0C                        PHN8
   2642 0000EF0C 70 C1                   	sb		r1,[r7]		; and store in buffer
   2643 0000EF0E 01 67                   	add		r7,r7,#1
   2644 0000EF10 FF 65                   	sub		r5,r5,#1	; decrement width
   2645 0000EF12 A1 34                   	shr		r4,#1
   2646 0000EF14 A1 34                   	shr		r4,#1
   2647 0000EF16 A1 34                   	shr		r4,#1
   2648 0000EF18 A1 34                   	shr		r4,#1
   2649 0000EF1A 02 A8                   	beq		PHN6			; is it zero yet ?
   2650 0000EF1C FF 68                   	sub		r8,r8,#1	; safety
   2651 0000EF1E ED B9                   	bne		PHN1
   2652 0000EF20                        PHN6
   2653 0000EF20 56 25                   	or		r5,r5		; test pad count
   2654 0000EF22 06 A2                   	ble		PHN4			; skip padding if not needed
   2655 0000EF24                        PHN3
   2656 0000EF24 02 40 00 11             	lw		r1,#' '		; display the required leading spaces
   2657 0000EF28 86 4F 0C AF             	call	GOOUT
   2658 0000EF2C FF 65                   	sub		r5,r5,#1
   2659 0000EF2E FA B9                   	bne		PHN3
   2660 0000EF30                        PHN4
   2661 0000EF30 66 26                   	or		r6,r6		; is number negative?
   2662 0000EF32 04 AB                   	bpl		PHN5
   2663 0000EF34 02 40 0D 11             	lw		r1,#'-'		; if so, display the sign
   2664 0000EF38 86 4F 04 AF             	call	GOOUT
   2665 0000EF3C                        PHN5
   2666 0000EF3C FF 67                   	sub		r7,r7,#1
   2667 0000EF3E 70 E1                   	lb		r1,[r7]		; now unstack the digits and display
   2668 0000EF40 86 4F 00 AF             	call	GOOUT
   2669 0000EF44 F5 4F 7E 10             	cmp		r7,#NUMWKA
   2670 0000EF48 F9 B7                   	bgtu	PHN5
   2671 0000EF4A                        PHNRET
   2672 0000EF4A E1 FF                   	lw		lr,[sp]
   2673 0000EF4C E3 F5                   	lw		r5,2[sp]
   2674 0000EF4E E5 F6                   	lw		r6,4[sp]
   2675 0000EF50 E7 F7                   	lw		r7,6[sp]
   2676 0000EF52 E9 F8                   	lw		r8,8[sp]
   2677 0000EF54 0A 6E                   	add		sp,sp,#10
   2678 0000EF56 F0 80                   	ret
                                        
                                        
                                        ; r1 = pointer to line
                                        ; returns r1 = pointer to end of line + 1
   2683 0000EF58                        PRTLN
   2684 0000EF58 FC 6E                       sub     sp,sp,#4
   2685 0000EF5A E1 DF                       sw      lr,[sp]
   2686 0000EF5C E3 D5                       sw      r5,2[sp]
   2687 0000EF5E 12 15                       add     r5,r1,#2
   2688 0000EF60 5E E1                       lb		r1,-2[r5]	; get the binary line number
   2689 0000EF62 0E 21                       zxb		r1
   2690 0000EF64 5F E2                       lb		r2,-1[r5]
   2691 0000EF66 0E 22                       zxb		r2
   2692 0000EF68 81 32                       shl		r2,#1
   2693 0000EF6A 81 32                       shl		r2,#1
   2694 0000EF6C 81 32                       shl		r2,#1
   2695 0000EF6E 81 32                       shl		r2,#1
   2696 0000EF70 81 32                       shl		r2,#1
   2697 0000EF72 81 32                       shl		r2,#1
   2698 0000EF74 81 32                       shl		r2,#1
   2699 0000EF76 81 32                       shl		r2,#1
   2700 0000EF78 26 21                       or		r1,r2
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 45
tb.asm
   2701 0000EF7A 00 12                       lw      r2,#0       ; display a 0 or more digit line no.
   2702 0000EF7C 7D BF                   	call	PRTNUM
   2703 0000EF7E 02 40 00 11             	lw      r1,#' '     ; followed by a blank
   2704 0000EF82 83 4F 0F AF             	call	GOOUT
   2705 0000EF86 00 12                   	lw      r2,#0       ; stop char. is a zero
   2706 0000EF88 50 11                   	lw      r1,r5
   2707 0000EF8A 2E BF                   	call    PRTSTG		; display the rest of the line
   2708 0000EF8C E3 F5                   	lw      r5,2[sp]
   2709 0000EF8E E1 FF                   	lw      lr,[sp]
   2710 0000EF90 04 6E                   	add     sp,sp,#4
   2711 0000EF92 F0 80                   	ret
                                        
                                        
                                        ; ===== Test text byte following the call to this subroutine. If it
                                        ;	equals the byte pointed to by r8, return to the code following
                                        ;	the call. If they are not equal, brnch to the point
                                        ;	indicated by the offset byte following the text byte.
                                        ;
                                        ; Registers Affected
                                        ;   r3,r8
                                        ; Returns
                                        ;	r8 = updated text pointer
                                        ;
   2724 0000EF94                        TSTC
   2725 0000EF94 FC 6E                   	sub		sp,sp,#4
   2726 0000EF96 E1 DF                   	sw		lr,[sp]
   2727 0000EF98 E3 D1                   	sw		r1,2[sp]
   2728 0000EF9A 2F AF                   	call	IGNBLK		; ignore leading blanks
   2729 0000EF9C E1 FF                   	lw		lr,[sp]	; get the return address
   2730 0000EF9E F0 E3                   	lb		r3,[lr]	; get the byte to compare
   2731 0000EFA0 80 E1                   	lb		r1,[r8]
   2732 0000EFA2 1D 23                   	cmp		r3,r1		; is it = to what r8 points to?
   2733 0000EFA4 05 A8                   	beq		TC1			; if so
                                        						; If not, add the second
   2735 0000EFA6 F1 E3                   	lb		r3,1[lr]	; byte following the call to
   2736 0000EFA8 30 2F                   	add		lr,r3		; the return address.
   2737 0000EFAA E3 F1                   	lw		r1,2[sp]
   2738 0000EFAC 04 6E                   	add		sp,sp,#4
   2739 0000EFAE F0 80                   	ret					; jump to the routine
   2740 0000EFB0                        TC1
   2741 0000EFB0 01 68                   	add		r8,r8,#1	; if equal, bump text pointer
   2742 0000EFB2 E3 F1                   	lw		r1,2[sp]
   2743 0000EFB4 04 6E                   	add     sp,sp,#4
   2744 0000EFB6 F2 80                   	jmp		2[lr]		; Skip the 2 bytes following
                                        						; the call and continue.
                                        
                                        
                                        ; ===== See if the text pointed to by r8 is a number. If so,
                                        ;	return the number in r2 and the number of digits in r3,
                                        ;	else return zero in r2 and r3.
                                        ; Registers Affected
                                        ;   r1,r2,r3,r4
                                        ; Returns
                                        ; 	r1 = number
                                        ;	r2 = number of digits in number
                                        ;	r8 = updated text pointer
                                        ;
   2758 0000EFB8                        TSTNUM
   2759 0000EFB8 FE 6E                   	sub		sp,sp,#2
   2760 0000EFBA E1 DF                   	sw		lr,[sp]
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 46
tb.asm
   2761 0000EFBC 1E AF                   	call	IGNBLK		; skip over blanks
   2762 0000EFBE 00 11                   	lw		r1,#0		; initialize return parameters
   2763 0000EFC0 00 12                   	lw		r2,#0
   2764 0000EFC2                        TN1
   2765 0000EFC2 80 E3                   	lb		r3,[r8]
   2766 0000EFC4 FD 4F 30 10             	cmp		r3,#'0'		; is it less than zero?
   2767 0000EFC8 15 A4                   	bltu	TSNMRET 	; if so, that's all
   2768 0000EFCA FC 4F 37 10             	cmp		r3,#'9'		; is it greater than nine?
   2769 0000EFCE 12 A7                   	bgtu	TSNMRET 	; if so, return
   2770 0000EFD0 33 43 14 10             	cmp		r1,#214748364	; see if there's room for new digit
   2771 0000EFD4 04 A6                   	bleu	TN2
   2772 0000EFD6 24 4F 0B 11             	lea		r1,msgNumTooBig
   2773 0000EFDA E3 4F 07 AE             	br		ERROR		; if not, we've overflowd
   2774 0000EFDE                        TN2
   2775 0000EFDE 10 14                   	lw		r4,r1		; quickly multiply result by 10
   2776 0000EFE0 81 31                   	shl		r1,#1		; * 2
   2777 0000EFE2 81 31                   	shl		r1,#1		; * 4
   2778 0000EFE4 40 21                   	add		r1,r4		; * 5
   2779 0000EFE6 81 31                   	shl		r1,#1		; * 10
   2780 0000EFE8 01 68                   	add		r8,r8,#1	; adjust text pointer
   2781 0000EFEA 00 40 5F 33             	and		r3,#0xF		; add in the new digit
   2782 0000EFEE 30 21                   	add		r1,r3
   2783 0000EFF0 01 62                   	add		r2,r2,#1	; increment the no. of digits
   2784 0000EFF2 E7 BE                   	br		TN1
   2785 0000EFF4                        TSNMRET
   2786 0000EFF4 E1 FF                   	lw		lr,[sp]
   2787 0000EFF6 02 6E                   	add		sp,sp,#2
   2788 0000EFF8 F0 80                   	ret
                                        
                                        
                                        ;===== Skip over blanks in the text pointed to by r8.
                                        ;
                                        ; Registers Affected:
                                        ;	r8
                                        ; Returns
                                        ;	r8 = pointer updateded past any spaces or tabs
                                        ;
   2798 0000EFFA                        IGNBLK
   2799 0000EFFA FE 6E                   	sub		sp,sp,#2
   2800 0000EFFC E1 D1                   	sw		r1,[sp]
   2801 0000EFFE                        IGB2
   2802 0000EFFE 80 E1                   	lb		r1,[r8]			; get char
   2803 0000F000 FE 4F 10 10             	cmp		r1,#' '			; see if it's a space
   2804 0000F004 03 A8                   	beq		IGB1			; if so, swallow it
   2805 0000F006 FF 4F 17 10             	cmp		r1,#'\t'		; or a tab
   2806 0000F00A 02 A9                   	bne		IGBRET
   2807 0000F00C                        IGB1
   2808 0000F00C 01 68                   	add		r8,r8,#1		; increment the text pointer
   2809 0000F00E F7 BE                   	br		IGB2
   2810 0000F010                        IGBRET
   2811 0000F010 E1 F1                   	lw		r1,[sp]
   2812 0000F012 02 6E                   	add		sp,sp,#2
   2813 0000F014 F0 80                   	ret
                                        
                                        
                                        ; ===== Convert the line of text in the input buffer to upper
                                        ;	case (except for stuff between quotes).
                                        ;
                                        ; Registers Affected
                                        ;   r1,r3
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 47
tb.asm
                                        ; Returns
                                        ;	r8 = pointing to end of text in buffer
                                        ;
   2824 0000F016                        TOUPBUF
   2825 0000F016 FE 6E                   	sub		sp,sp,#2
   2826 0000F018 E1 DF                   	sw		lr,[sp]
   2827 0000F01A 0A 40 0E 18             	lea		r8,BUFFER	; set up text pointer
   2828 0000F01E 00 13                   	lw		r3,#0		; clear quote flag
   2829 0000F020                        TOUPB1
   2830 0000F020 80 E1                   	lb		r1,[r8]		; get the next text char.
   2831 0000F022 01 68                   	add		r8,r8,#1
   2832 0000F024 FF 4F 13 10             	cmp		r1,#CR		; is it end of line?
   2833 0000F028 13 A8                   	beq		TOUPBRT 	; if so, return
   2834 0000F02A FD 4F 1E 10             	cmp		r1,#'"'		; a double quote?
   2835 0000F02E 08 A8                   	beq		DOQUO
   2836 0000F030 FD 4F 19 10             	cmp		r1,#''''	; or a single quote?
   2837 0000F034 05 A8                   	beq		DOQUO
   2838 0000F036 30 10                   	cmp		r3,#0		; inside quotes?
   2839 0000F038 F3 B9                   	bne		TOUPB1		; if so, do the next one
   2840 0000F03A 0D AF                   	call	toUpper 	; convert to upper case
   2841 0000F03C 8F C1                   	sb		r1,-1[r8]	; store it
   2842 0000F03E F0 BE                   	br		TOUPB1		; and go back for more
   2843 0000F040                        DOQUO
   2844 0000F040 30 10                   	cmp		r3,#0		; are we inside quotes?
   2845 0000F042 02 A9                   	bne		DOQUO1
   2846 0000F044 10 13                   	lw		r3,r1		; if not, toggle inside-quotes flag
   2847 0000F046 EC BE                   	br		TOUPB1
   2848 0000F048                        DOQUO1
   2849 0000F048 1D 23                   	cmp		r3,r1		; make sure we're ending proper quote
   2850 0000F04A EA B9                   	bne		TOUPB1		; if not, ignore it
   2851 0000F04C 00 13                   	lw		r3,#0		; else clear quote flag
   2852 0000F04E E8 BE                   	br		TOUPB1
   2853 0000F050                        TOUPBRT
   2854 0000F050 E1 FF                   	lw		lr,[sp]
   2855 0000F052 02 6E                   	add		sp,sp,#2
   2856 0000F054 F0 80                   	ret
                                        
                                        
                                        ; ===== Convert the character in r1 to upper case
                                        ;
   2861 0000F056                        toUpper
   2862 0000F056 F9 4F 1F 10             	cmp		r1,#'a'		; is it < 'a'?
   2863 0000F05A 04 A0                   	blt	    TOUPRET
   2864 0000F05C F8 4F 16 10             	cmp		r1,#'z'		; or > 'z'?
   2865 0000F060 01 A3                   	bgt	    TOUPRET
   2866 0000F062 E0 61                   	sub		r1,r1,#32	; if not, make it upper case
   2867 0000F064                        TOUPRET
   2868 0000F064 F0 80                   	ret
                                        
                                        
                                        ; 'CHKIO' checks the input. If there's no input, it will return
                                        ; to the caller with the Z flag set. If there is input, the Z
                                        ; flag is cleared and the input byte is in r2. However, if a
                                        ; control-C is read, 'CHKIO' will warm-start BASIC and will not
                                        ; return to the caller.
                                        ;
   2877 0000F066                        CHKIO
   2878 0000F066 FE 6E                   	sub		sp,sp,#2	; save link reg
   2879 0000F068 E1 DF                   	sw		lr,[sp]
   2880 0000F06A 7C 4F 0D AF             	call	GOIN		; get input if possible
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 48
tb.asm
   2881 0000F06E 07 A8                   	beq		CHKRET2		; if Zero, no input
   2882 0000F070 1D 10                   	cmp		r1,#CTRLC	; is it control-C?
   2883 0000F072 02 A9                   	bne		CHKRET		; if not
   2884 0000F074 80 4F 0B AE             	jmp		WSTART		; if so, do a warm start
   2885 0000F078                        CHKRET
   2886 0000F078 E1 FF                   	lw		lr,[sp]
   2887 0000F07A 02 6E                   	add		sp,sp,#2	; Z=0
   2888 0000F07C F0 80                   	ret
   2889 0000F07E                        CHKRET2
   2890 0000F07E E1 FF                   	lw		lr,[sp]
   2891 0000F080 02 6E                   	add		sp,sp,#2
   2892 0000F082 00 11                   	lw		r1,#0		; Z=1
   2893 0000F084 F0 80                   	ret
                                        
                                        
                                        ; ===== Display a CR-LF sequence
                                        ;
   2898 0000F086                        CRLF
   2899 0000F086 22 4F 0D 11             	lea		r1,CLMSG
                                        
                                        
                                        ; ===== Display a zero-ended string pointed to by register r1
                                        ; Registers Affected
                                        ;   r1,r2,r4
                                        ;
   2906 0000F08A                        PRMESG
   2907 0000F08A FC 6E                   	sub		sp,sp,#4
   2908 0000F08C E1 DF                   	sw		lr,[sp]
   2909 0000F08E E3 D5                   	sw		r5,2[sp]
   2910 0000F090 10 15                   	lw      r5,r1       ; r5 = pointer to message
   2911 0000F092                        PRMESG1
   2912 0000F092 01 65                   	add		r5,r5,#1
   2913 0000F094 5F E1                   	lb		r1,-1[r5]	; 	get the char.
   2914 0000F096 03 A8                   	beq		PRMRET
   2915 0000F098 7B 4F 04 AF             	call	GOOUT		;else display it trashes r4
   2916 0000F09C FA BE                   	br		PRMESG1
   2917 0000F09E                        PRMRET
   2918 0000F09E 50 11                   	lw		r1,r5
   2919 0000F0A0 E3 F5                   	lw		r5,2[sp]
   2920 0000F0A2 E1 FF                   	lw		lr,[sp]
   2921 0000F0A4 04 6E                   	add		sp,sp,#4
   2922 0000F0A6 F0 80                   	ret
                                        
                                        
                                        ; ===== Display a zero-ended string pointed to by register r1
                                        ; Registers Affected
                                        ;   r1,r2,r3
                                        ;
   2929 0000F0A8                        PRMESGAUX
   2930 0000F0A8 FC 6E                   	sub		sp,sp,#4
   2931 0000F0AA E1 DF                   	sw		lr,[sp]
   2932 0000F0AC E3 D5                   	sw		r5,2[sp]
   2933 0000F0AE 10 15                   	lw      r5,r1       ; r3 = pointer
   2934 0000F0B0                        PRMESGA1
   2935 0000F0B0 01 65                   	add		r5,r5,#1
   2936 0000F0B2 5F E1                   	lb		r1,-1[r5]	; 	get the char.
   2937 0000F0B4 03 A8                   	beq		PRMRETA
   2938 0000F0B6 7A 4F 09 AF             	call	GOAUXO		;else display it
   2939 0000F0BA FA BE                   	br		PRMESGA1
   2940 0000F0BC                        PRMRETA
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 49
tb.asm
   2941 0000F0BC 50 11                   	lw		r1,r5
   2942 0000F0BE E3 F5                   	lw		r5,2[sp]
   2943 0000F0C0 E1 FF                   	lw		lr,[sp]
   2944 0000F0C2 04 6E                   	add		sp,sp,#4
   2945 0000F0C4 F0 80                   	ret
                                        
                                        ;*****************************************************
                                        ; The following routines are the only ones that need *
                                        ; to be changed for a different I/O environment.     *
                                        ;*****************************************************
                                        
                                        
                                        ; ===== Output character to the console (Port 1) from register D0
                                        ;	(Preserves all registers.)
                                        ;
   2956 0000F0C6                        OUTC
   2957 0000F0C6 FF BE                   	jmp		_putChar
                                        
                                        
                                        ; ===== Input a character from the console into register D0 (or
                                        ;	return Zero status if there's no character available).
                                        ;
   2963 0000F0C8                        INC
   2964 0000F0C8 FE 6E                   	add		sp,sp,#-2
   2965 0000F0CA E1 DF                   	sw		lr,[sp]
   2966 0000F0CC 01 4B 00 E1             	lb		r1,ROUTER+RTR_RXSTAT
   2967 0000F0D0 03 A8                   	beq		INC1
   2968 0000F0D2 FF BF                   	call	Recv
   2969 0000F0D4 1F 40 02 AF             	call	RecvDispatch
   2970 0000F0D8                        INC1
                                        ; get char from keyboard
                                        ; returns char in r1
   2973 0000F0D8                        _getChar
   2974 0000F0D8 C5 4D 02 E1             	lb		r1,KBD+2	; get keyboard strobe
   2975 0000F0DC 08 AB                   	bpl		gc1
   2976 0000F0DE C5 4D 00 E1             	lb		r1,KBD		; get character and clear keyboard strobe
   2977 0000F0E2 05 AA                   	bmi		gc1			; was it a keyup event ? (ignore)
   2978 0000F0E4 07 40 5F 31             	and		r1,#0x7f
   2979 0000F0E8 E1 FF                   	lw		lr,[sp]
   2980 0000F0EA 02 6E                   	add		sp,sp,#2
   2981 0000F0EC F0 80                   	ret
   2982 0000F0EE                        gc1
   2983 0000F0EE E1 FF                   	lw		lr,[sp]
   2984 0000F0F0 02 6E                   	add		sp,sp,#2
   2985 0000F0F2 00 11                   	lw		r1,#0		; return Z=1 (no character)
   2986 0000F0F4 F0 80                   	ret
                                        
                                        
                                        ; get char from keyboard
                                        ; returns char in r1
   2991 0000F0F6                        _getCharWait
   2992 0000F0F6                        gc2
   2993 0000F0F6 C5 4D 02 E1             	lb		r1,KBD+2	; get keyboard strobe
   2994 0000F0FA FD BB                   	bpl		gc2
   2995 0000F0FC C5 4D 00 E1             	lb		r1,KBD		; get character and clear keyboard strobe
   2996 0000F100 FA BA                   	bmi		gc2			; was it a keyup event ? (ignore)
   2997 0000F102 07 40 5F 31             	and		r1,#0x7f
   2998 0000F106 F0 80                   	ret
                                        
                                        
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:30 2017     Page 50
tb.asm
                                        ; Trigger a load operation on the target node.
                                        
   3003 0000F108                        TriggerTgtLoad:
   3004 0000F108 FF BF                   	call	zeroTxBuf
   3005 0000F10A 03 40 06 E2             	lb		r2,tgtNode
   3006 0000F10E 02 40 0F C2             	sb		r2,txBuf+MSG_DST
   3007 0000F112 01 40 01 12             	lw		r2,#$11
   3008 0000F116 02 40 0E C2             	sb		r2,txBuf+MSG_SRC
   3009 0000F11A 0A 12                   	lw		r2,#10				; trigger load on target node
   3010 0000F11C 02 40 07 C2             	sb		r2,txBuf+MSG_TYPE
   3011 0000F120 FF BF                   	call	Xmit
   3012 0000F122 E3 F2                   	lw		r2,2[sp]
   3013 0000F124 E1 FF                   	lw		lr,[sp]
   3014 0000F126 F0 80                   	ret
                                        
                                        ; ===== Output character to the host (Port 2) from register r1
                                        ;	(Preserves all registers.)
                                        ;
   3019 0000F128                        AUXOUT
   3020 0000F128 FC 6E                   	add		sp,sp,#-4
   3021 0000F12A E1 DF                   	sw		lr,[sp]
   3022 0000F12C E3 D2                   	sw		r2,2[sp]
   3023 0000F12E 03 40 06 E2             	lb		r2,tgtNode
                                        	cmp		#$11
   3025 0000F132 05 A9                   	bne		auxout1
   3026 0000F134 36 48 09 AF             	call	putSerial	; call boot rom routine
   3027 0000F138 E3 F2                   	lw		r2,2[sp]
   3028 0000F13A E1 FF                   	lw		lr,[sp]
   3029 0000F13C F0 80                   	ret
   3030 0000F13E                        auxout1:
   3031 0000F13E FF BF                   	call	zeroTxBuf
   3032 0000F140 02 40 00 C1             	sb		r1,txBuf
   3033 0000F144 03 40 06 E2             	lb		r2,tgtNode
   3034 0000F148 02 40 0F C2             	sb		r2,txBuf+MSG_DST
   3035 0000F14C 01 40 01 12             	lw		r2,#$11
   3036 0000F150 02 40 0E C2             	sb		r2,txBuf+MSG_SRC
   3037 0000F154 0B 12                   	lw		r2,#11				; recieve BASIC program char
   3038 0000F156 02 40 07 C2             	sb		r2,txBuf+MSG_TYPE
   3039 0000F15A FF BF                   	call	Xmit
   3040 0000F15C E3 F2                   	lw		r2,2[sp]
   3041 0000F15E E1 FF                   	lw		lr,[sp]
   3042 0000F160 F0 80                   	ret
                                        ;
                                        ; ===== Input a character from the host into register D0 (or
                                        ;	return negative status if there's no character available).
                                        ;
   3047 0000F162                        AUXIN
                                        ; get character from serial port
                                        ; return  N=1 if no character available
   3050 0000F162 35 48 00 AE             	jmp		peekSerial
                                        
                                        
   3053 0000F166                        _scrollScreen
   3054 0000F166 FC 6E                   	sub		sp,sp,#4
   3055 0000F168 E1 D5                   	sw		r5,[sp]
   3056 0000F16A 60 40 00 13             	lw		r3,#1536	; number of chars to move - 1
   3057 0000F16E 00 42 00 12             	lw		r2,#VIDEORAM
   3058 0000F172 03 40 00 E1             	lb		r1,txtWidth
   3059 0000F176 81 31                   	shl		r1,#1
   3060 0000F178 81 31                   	shl		r1,#1
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:31 2017     Page 51
tb.asm
   3061 0000F17A                        ss1:
   3062 0000F17A 20 15                   	lw		r5,r2
   3063 0000F17C 10 25                   	add		r5,r1
   3064 0000F17E 51 F4                   	lw		r4,[r5]		; char at next line
   3065 0000F180 21 D4                   	sw		r4,[r2]		; goes to this line
   3066 0000F182 04 62                   	add		r2,r2,#4
   3067 0000F184 FF 63                   	sub		r3,r3,#1
   3068 0000F186 F9 B9                   	bne     ss1
                                        	; blank out last line
   3070 0000F188 02 40 00 13             	lw		r3,#' '
   3071 0000F18C 03 40 08 D3             	sh		r3,charToPrint
   3072 0000F190 03 40 00 E3             	lb		r3,txtWidth
   3073 0000F194 03 40 09 F4             	lw		r4,charToPrint	; and colors
   3074 0000F198                        ss2
   3075 0000F198 21 D4                   	sw		r4,[r2]
   3076 0000F19A 04 62                   	add		r2,r2,#4
   3077 0000F19C FF 63                   	sub		r3,r3,#1
   3078 0000F19E FC B9                   	bne     ss2
   3079 0000F1A0 E1 F5                   	lw		r5,[sp]
   3080 0000F1A2 04 6E                   	add		sp,sp,#4
   3081 0000F1A4 F0 80                   	ret
                                        
                                        
                                        ; flash the character at the screen position
                                        ;   r1: 1 = flash, 0 = no flash
   3086 0000F1A6                        _flashCursor
   3087 0000F1A6 00 42 00 12             	lw		r2,#VIDEORAM
   3088 0000F1AA 03 40 04 F3             	lh		r3,pos
   3089 0000F1AE 81 33                   	shl		r3,#1
   3090 0000F1B0 81 33                   	shl		r3,#1
   3091 0000F1B2 20 23                   	add		r3,r2		; r3 = scr[pos]
                                        
   3093 0000F1B4 16 21                   	or		r1,r1
   3094 0000F1B6 04 A8                   	beq		fc1
   3095 0000F1B8 33 E2                   	lb		r2,3[r3]	; get background color
   3096 0000F1BA 08 40 60 32             	or		r2,#0x80	; set flash indicator
   3097 0000F1BE 03 AE                   	br		fcx
   3098 0000F1C0                        fc1
   3099 0000F1C0 33 E2                   	lb		r2,3[r3]	; get background color
   3100 0000F1C2 07 40 5F 32             	and		r2,#0x7f	; clear flash indicator
   3101 0000F1C6                        fcx:
   3102 0000F1C6 33 C2                   	sb		r2,3[r3]
   3103 0000F1C8 F0 80                   	ret
                                        
                                        
   3106 0000F1CA                        _cls
   3107 0000F1CA 32 48 0E AF             	call	clearScreen
   3108 0000F1CE 90 4F 08 AE             	br		FINISH
                                        
                                        
                                        ; ===== Return to the resident monitor, operating system, etc.
                                        ;
   3113 0000F1D2                        BYEBYE
   3114 0000F1D2 08 40 05 FE             	lw		sp,OSSP
   3115 0000F1D6 E1 FF                       lw      lr,[sp]
   3116 0000F1D8 02 6E                       add		sp,sp,#2
   3117 0000F1DA F0 80                   	ret
                                        
                                        ;	MOVE.B	#228,D7 	return to Tutor
                                        ;	TRAP	#14
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:31 2017     Page 52
tb.asm
                                        
   3122 0000F1DC 0D 0A 42 75 74 74      msgInit db	CR,LF,"Butterfly Tiny BASIC v1.1",CR,LF,"(C) 2005-2017  Robert Finch",CR,LF,LF,0
   3122 0000F1E2 65 72 66 6C 79 20 54  
   3122 0000F1E9 69 6E 79 20 42 41 53  
   3122 0000F1F0 49 43 20 76 31 2E 31  
   3122 0000F1F7 0D 0A 28 43 29 20 32  
   3122 0000F1FE 30 30 35 2D 32 30 31  
   3122 0000F205 37 20 20 52 6F 62 65  
   3122 0000F20C 72 74 20 46 69 6E 63  
   3122 0000F213 68 0D 0A 0A 00        
   3123 0000F218 0D 0A 4F 4B 0D 0A      OKMSG	db	CR,LF,"OK",CR,LF,0
   3123 0000F21E 00                    
   3124 0000F21F 57 68 61 74 3F 0D      msgWhat	db	"What?",CR,LF,0
   3124 0000F225 0A 00                 
   3125 0000F227 53 6F 72 72 79 2E      SRYMSG	db	"Sorry."
                                      
   3126 0000F22D 0D 0A 00               CLMSG	db	CR,LF,0
   3127 0000F230 43 6F 6D 70 61 63      msgReadError	db	"Compact FLASH read error",CR,LF,0
   3127 0000F236 74 20 46 4C 41 53 48  
   3127 0000F23D 20 72 65 61 64 20 65  
   3127 0000F244 72 72 6F 72 0D 0A 00  
                                      
   3128 0000F24B 4E 75 6D 62 65 72      msgNumTooBig	db	"Number is too big",CR,LF,0
   3128 0000F251 20 69 73 20 74 6F 6F  
   3128 0000F258 20 62 69 67 0D 0A 00  
                                      
   3129 0000F25F 44 69 76 69 73 69      msgDivZero		db	"Division by zero",CR,LF,0
   3129 0000F265 6F 6E 20 62 79 20 7A  
   3129 0000F26C 65 72 6F 0D 0A 00     
   3130 0000F272 4F 75 74 20 6F 66      msgVarSpace     db  "Out of variable space",CR,LF,0
   3130 0000F278 20 76 61 72 69 61 62  
   3130 0000F27F 6C 65 20 73 70 61 63  
   3130 0000F286 65 0D 0A 00           
   3131 0000F28A 20 62 79 74 65 73      msgBytesFree	db	" bytes free",CR,LF,0
   3131 0000F290 20 66 72 65 65 0D 0A  
   3131 0000F297 00                    
   3132 0000F298 0D 0A 52 65 61 64      msgReady		db	CR,LF,"Ready",CR,LF,0
   3132 0000F29E 79 0D 0A 00           
   3133 0000F2A2 45 78 70 65 63 74      msgComma		db	"Expecting a comma",CR,LF,0
   3133 0000F2A8 69 6E 67 20 61 20 63  
   3133 0000F2AF 6F 6D 6D 61 0D 0A 00  
                                      
   3134 0000F2B6 4C 69 6E 65 20 6E      msgLineRange	db	"Line number too big",CR,LF,0
   3134 0000F2BC 75 6D 62 65 72 20 74  
   3134 0000F2C3 6F 6F 20 62 69 67 0D  
   3134 0000F2CA 0A 00                 
   3135 0000F2CC 45 78 70 65 63 74      msgVar			db	"Expecting a variable",CR,LF,0
   3135 0000F2D2 69 6E 67 20 61 20 76  
   3135 0000F2D9 61 72 69 61 62 6C 65  
   3135 0000F2E0 0D 0A 00              
   3136 0000F2E3 52 4E 44 20 62 61      msgRNDBad		db	"RND bad parameter",CR,LF,0
   3136 0000F2E9 64 20 70 61 72 61 6D  
   3136 0000F2F0 65 74 65 72 0D 0A 00  
                                      
   3137 0000F2F7 53 59 53 20 62 61      msgSYSBad		db	"SYS bad address",CR,LF,0
   3137 0000F2FD 64 20 61 64 64 72 65  
   3137 0000F304 73 73 0D 0A 00        
   3138 0000F309 49 4E 50 55 54 20      msgInputVar		db	"INPUT expecting a variable",CR,LF,0
   3138 0000F30F 65 78 70 65 63 74 69  
   3138 0000F316 6E 67 20 61 20 76 61  
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:31 2017     Page 53
tb.asm
   3138 0000F31D 72 69 61 62 6C 65 0D  
   3138 0000F324 0A 00                 
   3139 0000F326 4E 45 58 54 20 77      msgNextFor		db	"NEXT without FOR",CR,LF,0
   3139 0000F32C 69 74 68 6F 75 74 20  
   3139 0000F333 46 4F 52 0D 0A 00     
   3140 0000F339 4E 45 58 54 20 65      msgNextVar		db	"NEXT expecting a defined variable",CR,LF,0
   3140 0000F33F 78 70 65 63 74 69 6E  
   3140 0000F346 67 20 61 20 64 65 66  
   3140 0000F34D 69 6E 65 64 20 76 61  
   3140 0000F354 72 69 61 62 6C 65 0D  
   3140 0000F35B 0A 00                 
   3141 0000F35D 47 4F 54 4F 2F 47      msgBadGotoGosub	db	"GOTO/GOSUB bad line number",CR,LF,0
   3141 0000F363 4F 53 55 42 20 62 61  
   3141 0000F36A 64 20 6C 69 6E 65 20  
   3141 0000F371 6E 75 6D 62 65 72 0D  
   3141 0000F378 0A 00                 
   3142 0000F37A 52 45 54 55 52 4E      msgRetWoGosub   db	"RETURN without GOSUB",CR,LF,0
   3142 0000F380 20 77 69 74 68 6F 75  
   3142 0000F387 74 20 47 4F 53 55 42  
   3142 0000F38E 0D 0A 00              
   3143 0000F391 50 72 6F 67 72 61      msgTooBig		db	"Program is too big",CR,LF,0
   3143 0000F397 6D 20 69 73 20 74 6F  
   3143 0000F39E 6F 20 62 69 67 0D 0A  
   3143 0000F3A5 00                    
   3144 0000F3A6 45 78 74 72 61 20      msgExtraChars	db	"Extra characters on line ignored",CR,LF,0
   3144 0000F3AC 63 68 61 72 61 63 74  
   3144 0000F3B3 65 72 73 20 6F 6E 20  
   3144 0000F3BA 6C 69 6E 65 20 69 67  
   3144 0000F3C1 6E 6F 72 65 64 0D 0A  
   3144 0000F3C8 00                    
                                        
   3146 0000F3C9 FF FF FF                	.align	4
   3212 = 0000F3CC                      LSTROM	equ	*		; end of possible ROM area
                                        ;
                                        ; Internal variables follow:
                                        ;
                                        		bss
                                        		org		0x0030
   3153 00000030                        txtWidth	db	0		; BIOS var =60
   3154 00000031                        txtHeight	db	0		; BIOS var =27
   3155 00000032                        cursx	db		0		; cursor x position
   3156 00000033                        cursy	db		0		; cursor y position
   3157 00000034                        pos		dw		0		; text screen position
   3158 00000036                        tgtNode	db		0
   3159 00000037                        srcNode	db		0
                                        		org		0x0038
   3161 00000038                        charToPrint		dw		0
   3162 0000003A                        fgColor			db		0
   3163 0000003B                        bkColor			db		0
   3164 0000003C                        cursFlash		db		0	; flash the cursor ?
   3165 0000003D                         				db		0
   3166 0000003E                        NormAttr		dw		0
                                        
   3168 00000040                        lineLinkTbl		fill.b	25,0	; screen line link table
   3169 00000059                         	align 4
                                        
                                        		org		0x0080
   3172 00000080                        typef   db      0   ; variable / expression type
   3173 00000081                                 align   4
   3174 00000084                        OSSP	dw	1	; OS value of sp
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:31 2017     Page 54
tb.asm
   3175 00000086                        CURRNT	dw	1	;	Current line pointer
   3176 00000088                        STKGOS	dw	1	;	Saves stack pointer in 'GOSUB'
   3177 0000008A                        STKINP	dw	1	;	Saves stack pointer during 'INPUT'
   3178 0000008C                        LOPVAR	dw	1	;	'FOR' loop save area
   3179 0000008E                        LOPINC	dw	1	;	increment
   3180 00000090                        LOPLMT	dw	1	;	limit
   3181 00000092                        LOPLN	dw	1	;	line number
   3182 00000094                        LOPPT	dw	1	;	text pointer
   3183 00000096                        TXTUNF	dw	1	;	points to unfilled text area
   3184 00000098                        VARBGN	dw	1	;	points to variable area
   3185 0000009A                        IVARBGN dw  1   ;   points to integer variable area
   3186 0000009C                        SVARBGN dw  1   ;   points to string variable area
   3187 0000009E                        FVARBGN dw  1   ;   points to float variable area
   3188 000000A0                        STKBOT	dw	1	;	holds lower limit for stack growth
   3189 000000A2                        NUMWKA	fill.b	12,0			; numeric work area
   3190 000000AE                        BUFFER	fill.b	BUFLEN,0x00		;		Keyboard input buffer
                                        
                                                bss
                                                org     0x2000
   3194 00002000                        textScr1
                                                org     0x2000
                                        ;	END
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:31 2017     Page 54
noc_boot21.asm


                                      
                                        
                                        		.code
   3199 0000F3CC                        start:
   3200 0000F3CC FF 41 0E 1E             		lw		sp,#$1FFE
   3201 0000F3D0 00 40 0F C0             		sb		r0,HTInputFocus
   3202 0000F3D4                        start1:
   3203 0000F3D4                        noMsg1:
   3204 0000F3D4 A9 AF                   		call	KeybdGetChar
   3205 0000F3D6 27 A9                   		bne		noKey
   3206 0000F3D8 F9 4F 1D 10             		cmp		r1,#'c'
   3207 0000F3DC 12 A9                   		bne		notC
   3208 0000F3DE 01 40 01 E1             		lb		r1,KeyState2	; test if CTRL down
   3209 0000F3E2 54 31                   		and		r1,#4
   3210 0000F3E4 20 A8                   		beq		noKey
                                        		; CTRL-C
                                        		; If CTRL-C was pressed broadcast a global stop message
   3213 0000F3E6 FF BF                   		call	zeroTxBuf
   3214 0000F3E8 E4 31                   		tsr		r1,ID
   3215 0000F3EA 02 40 0E C1             		sb		r1,txBuf+MSG_SRC
   3216 0000F3EE 0F 40 0F 11             		lw		r1,#$FF
   3217 0000F3F2 02 40 0F C1             		sb		r1,txBuf+MSG_DST
   3218 0000F3F6 3F 4F 06 11             		lw		r1,#MT_STOP
   3219 0000F3FA 02 40 07 C1             		sb		r1,txBuf+MSG_TYPE
   3220 0000F3FE FF BF                   		call	Xmit
   3221 0000F400 12 AE                   		bra		noKey
                                        		; There was a keystroke available so transmit a character
                                        		; message to the thread with the input focus
   3224 0000F402                        notC:
   3225 0000F402 00 40 0F E5             		lb		r5,HTInputFocus		; any thread with input focus ?
   3226 0000F406 0F A8                   		beq		noKey
   3227 0000F408 FF BF                   		call	zeroTxBuf
   3228 0000F40A 02 40 0F C5             		sb		r5,txBuf+MSG_DST	; destination is input focus thread
   3229 0000F40E E4 35                   		tsr		r5,ID				; source is this node
   3230 0000F410 02 40 0E C5             		sb		r5,txBuf+MSG_SRC
   3231 0000F414 02 40 00 C1             		sb		r1,txBuf			; store ascii char
   3232 0000F418 02 40 01 C3             		sb		r3,txBuf+1			; and scan code
   3233 0000F41C 41 4F 0C 11             		lw		r1,#MT_KEYSTROKE	; keyboard message
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:31 2017     Page 55
noc_boot21.asm
   3234 0000F420 02 40 07 C1             		sb		r1,txBuf+MSG_TYPE
   3235 0000F424 FF BF                   		call	Xmit
   3236 0000F426                        noKey:
   3237 0000F426 01 4B 00 E1             		lb		r1,ROUTER+RTR_RXSTAT
   3238 0000F42A D4 B8                   		beq		noMsg1
   3239 0000F42C FF BF                   		call	Recv
   3240 0000F42E 46 AF                   		call	RecvDispatch
   3241 0000F430 D1 BE                   		bra		start1
   3242 0000F432                        lockup:
   3243 0000F432 FF BE                   		bra		lockup
                                        
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:31 2017     Page 1
Network.asm

                                        ; ============================================================================
                                        ;        __
                                        ;   \\__/ o\    (C) 2017  Robert Finch, Waterloo
                                        ;    \  __ /    All rights reserved.
                                        ;     \/_//     robfinch<remove>@finitron.ca
                                        ;       ||
                                        ;  
                                        ;
                                        ; This source file is free software: you can redistribute it and/or modify 
                                        ; it under the terms of the GNU Lesser General Public License as published 
                                        ; by the Free Software Foundation, either version 3 of the License, or     
                                        ; (at your option) any later version.                                      
                                        ;                                                                          
                                        ; This source file is distributed in the hope that it will be useful,      
                                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                                        ; GNU General Public License for more details.                             
                                        ;                                                                          
                                        ; You should have received a copy of the GNU General Public License        
                                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                                        ;                                    
                                        ;                                      
                                        ; Networking software components
                                        ; ============================================================================
                                        ;
                                        ;----------------------------------------------------------------------------
                                        ; Zero out the transmit buffer.
                                        ; Used before building transmit buffer.
                                        ;
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	<none>
                                        ;----------------------------------------------------------------------------
                                        
   3283 0000F434                        zeroTxBuf:
   3284 0000F434 FE 6E                   		add		sp,sp,#-2
   3285 0000F436 E1 D2                   		sw		r2,[sp]
   3286 0000F438 00 40 0F 12             		lw		r2,#15
   3287 0000F43C                        zeroTxBuf1:
   3288 0000F43C 02 40 20 C0             		sb		r0,txBuf[r2]
   3289 0000F440 FF 62                   		sub		r2,r2,#1
   3290 0000F442 FC BB                   		bpl		zeroTxBuf1
   3291 0000F444 E1 F2                   		lw		r2,[sp]
   3292 0000F446 02 6E                   		add		sp,sp,#2
   3293 0000F448 F0 80                   		ret
                                        
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:31 2017     Page 2
Network.asm
                                        ;----------------------------------------------------------------------------
                                        ; Transmit on the network.
                                        ; Blocks until the transmit buffer is open.
                                        ;
                                        ; Prerequisites:
                                        ;	The transmit buffer txBuf must have already been loaded.
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	<none>
                                        ;----------------------------------------------------------------------------
                                        
   3309 0000F44A FC 6E                  Xmit:	
   3310 0000F44C E1 D1                   		sw		r1,[sp]
   3311 0000F44E E3 D2                   		sw		r2,2[sp]
                                        		; wait for transmit buffer to empty
   3313 0000F450                        Xmit2:
   3314 0000F450 01 4B 02 E1             		lb		r1,ROUTER+RTR_TXSTAT
   3315 0000F454 FD B9                   		bne		Xmit2
   3316 0000F456 00 40 0F 12             		lw		r2,#15
   3317 0000F45A                        Xmit1:
   3318 0000F45A 02 40 20 E1             		lb		r1,txBuf[r2]
   3319 0000F45E 00 4B 20 C1             		sb		r1,ROUTER[r2]
   3320 0000F462 FF 62                   		add		r2,r2,#-1
   3321 0000F464 FA BB                   		bpl		Xmit1
                                        		; trigger a transmit
   3323 0000F466 01 11                   		lw		r1,#1
   3324 0000F468 01 4B 02 C2             		sb		r2,ROUTER+RTR_TXSTAT
   3325 0000F46C E3 F2                   		lw		r2,2[sp]
   3326 0000F46E E1 F1                   		lw		r1,[sp]
   3327 0000F470 04 6E                   		add		sp,sp,#4
   3328 0000F472 F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Receive from network.
                                        ; Receive status must have already indicated a message present.
                                        ; Copies recieve buffer from router to rxBuf.
                                        ;
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	<none>
                                        ;----------------------------------------------------------------------------
                                        
   3343 0000F474                        Recv:
   3344 0000F474 FC 6E                   		add		sp,sp,#-4
   3345 0000F476 E1 D1                   		sw		r1,[sp]
   3346 0000F478 E3 D2                   		sw		r2,2[sp]
   3347 0000F47A 01 11                   		lw		r1,#1
   3348 0000F47C 01 4B 00 C1             		sb		r1,ROUTER+RTR_RXSTAT	; pop the rx fifo
   3349 0000F480 00 40 0F 12             		lw		r2,#15
   3350 0000F484                        Recv1:
   3351 0000F484 00 4B 20 E1             		lb		r1,ROUTER[r2]			; copy message to local buffer
   3352 0000F488 03 40 20 C1             		sb		r1,rxBuf[r2]
   3353 0000F48C FF 62                   		add		r2,r2,#-1
   3354 0000F48E FA BB                   		bpl		Recv1
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:31 2017     Page 3
Network.asm
   3355 0000F490 E1 F1                   		lw		r1,[sp]
   3356 0000F492 E3 F2                   		lw		r2,2[sp]
   3357 0000F494 04 6E                   		add		sp,sp,#4
   3358 0000F496 F0 80                   		ret
                                        
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:31 2017     Page 3
noc_boot21.asm


                                      
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Broadcast a reset message on the network.
                                        ;----------------------------------------------------------------------------
                                        
   3365 0000F498                        broadcastReset:
   3366 0000F498 FE 6E                   		add		sp,sp,#-2
   3367 0000F49A E1 DF                   		sw		lr,[sp]
   3368 0000F49C FF BF                   		call	zeroTxBuf
   3369 0000F49E 0F 40 0F 11             		lw		r1,#$FF		; global broadcast address
   3370 0000F4A2 02 40 0F C1             		sb		r1,txBuf+MSG_DST
   3371 0000F4A6 01 40 01 11             		lw		r1,#$11		; source of message
   3372 0000F4AA 02 40 0E C1             		sb		r1,txBuf+MSG_SRC
   3373 0000F4AE 01 11                   		lw		r1,#1
   3374 0000F4B0 02 40 07 C1             		sb		r1,txBuf+MSG_TYPE	; reset message
   3375 0000F4B4 FF BF                   		call	Xmit
   3376 0000F4B6 E1 FF                   		lw		lr,[sp]
   3377 0000F4B8 02 6E                   		add		sp,sp,#2
   3378 0000F4BA F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Received message dispatch.
                                        ;----------------------------------------------------------------------------
                                        
   3384 0000F4BC                        RecvDispatch:
   3385 0000F4BC FE 6E                   		add		sp,sp,#-2
   3386 0000F4BE E1 DF                   		sw		lr,[sp]
   3387 0000F4C0 03 40 07 E1             		lb		r1,rxBuf+MSG_TYPE
                                        		; Reset request ?
   3389 0000F4C4 B3 40 1C 10             		cmp		r1,#MT_RST
   3390 0000F4C8 10 A9                   		bne		RecvDispatch2
   3391 0000F4CA 00 40 0F C0             		sb		r0,HTInputFocus
   3392 0000F4CE FF BF                   		call	zeroTxBuf
   3393 0000F4D0 E4 31                   		tsr		r1,ID
   3394 0000F4D2 02 40 0E C1             		sb		r1,txBuf+MSG_SRC
   3395 0000F4D6 01 40 01 11             		lw		r1,#$11
   3396 0000F4DA 02 40 0F C1             		sb		r1,txBuf+MSG_DST
   3397 0000F4DE 4D 4F 0E 11             		lw		r1,#MT_RST_ACK
   3398 0000F4E2 02 40 07 C1             		sb		r1,txBuf+MSG_TYPE
   3399 0000F4E6 FF BF                   		call	Xmit
   3400 0000F4E8 1C AE                   		bra		RecvDispatchXit
   3401 0000F4EA                        RecvDispatch2:
                                        		; Set input focus ?
                                        		; Check for request to set input focus
   3404 0000F4EA B1 40 16 10             		cmp		r1,#MT_SET_INPUT_FOCUS
   3405 0000F4EE 03 A9                   		bne		RecvDispatch3
   3406 0000F4F0 03 40 00 E1             		lb		r1,rxBuf
                                        		sb		HTInputFocus
   3408 0000F4F4 16 AE                   		bra		RecvDispatchXit
   3409 0000F4F6                        RecvDispatch3:
                                        		; Get button status ?
   3411 0000F4F6 B0 40 1A 10             		cmp		r1,#MT_BUTTON_STATUS
   3412 0000F4FA 12 A9                   		bne		RecvDispatch4
   3413 0000F4FC FF BF                   		call	zeroTxBuf
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:31 2017     Page 4
noc_boot21.asm
   3414 0000F4FE E4 31                   		tsr		r1,ID
   3415 0000F500 02 40 0E C1             		sb		r1,txBuf+MSG_SRC
   3416 0000F504 03 40 0E E1             		lb		r1,rxBuf+MSG_SRC		; where did message come from
   3417 0000F508 02 40 0F C1             		sb		r1,txBuf+MSG_DST		; send back to sender
   3418 0000F50C 50 4F 0C 11             		lw		r1,#MT_BUTTON_STATUS
   3419 0000F510 02 40 07 C1             		sb		r1,txBuf+MSG_TYPE
   3420 0000F514 20 4B 00 E1             		lb		r1,BTNS
   3421 0000F518 02 40 00 C1             		sb		r1,txBuf
   3422 0000F51C FF BF                   		call	Xmit
   3423 0000F51E 01 AE                   		bra		RecvDispatchXit
   3424 0000F520                        RecvDispatch4:
   3425 0000F520 00 AE                   		bra		RecvDispatchXit
   3426 0000F522                        RecvDispatchXit:
   3427 0000F522 E1 FF                   		lw		lr,[sp]
   3428 0000F524 02 6E                   		add		sp,sp,#2
   3429 0000F526 F0 80                   		ret
                                        
                                        ;============================================================================
                                        ; Keyboard Code
                                        ;============================================================================
                                        
                                        ;----------------------------------------------------------------------------
                                        ; KeybdGetChar:
                                        ;
                                        ; Returns:
                                        ; r1 = ascii code
                                        ; r2 = 0 if key available, 1 if no key available, 2 if keyboard busy
                                        ; r3 = scan code
                                        ; .ZF = 1 if a key is available, otherwise .ZF = 0
                                        ;----------------------------------------------------------------------------
                                        
   3445 0000F528                        KeybdGetChar:
   3446 0000F528 FC 6E                   		add		sp,sp,#-4
   3447 0000F52A E3 D4                   		sw		r4,2[sp]
   3448 0000F52C E1 DF                   		sw		lr,[sp]
   3449 0000F52E                        kbd3:
   3450 0000F52E C5 4D 01 E1             		lb		r1,KBD+KBD_STAT	; get keyboard status flag
   3451 0000F532 10 12                   		mov		r2,r1
   3452 0000F534 04 40 50 31             		and		r1,#$40
   3453 0000F538 09 A9                   		bne		kbd1		; is it busy ?
   3454 0000F53A 20 11                   		mov		r1,r2
   3455 0000F53C 08 40 50 31             		and		r1,#$80
   3456 0000F540 0A A9                   		bne		kbd6		; branch if key available
   3457 0000F542 E1 FF                   		lw		lr,[sp]
   3458 0000F544 E3 F4                   		lw		r4,2[sp]
   3459 0000F546 04 6E                   		add		sp,sp,#4
   3460 0000F548 01 12                   		lw		r2,#1		; no key available
   3461 0000F54A F0 80                   		ret
   3462 0000F54C                        kbd1:
   3463 0000F54C E1 FF                   		lw		lr,[sp]
   3464 0000F54E E3 F4                   		lw		r4,2[sp]
   3465 0000F550 04 6E                   		add		sp,sp,#4
   3466 0000F552 02 12                   		lw		r2,#2		; keyboard busy
   3467 0000F554 F0 80                   		ret
   3468 0000F556                        kbd6:
   3469 0000F556 C5 4D 00 E1             		lb		r1,KBD		; get scancode
   3470 0000F55A 10 13                   		mov		r3,r1		; save in r3
   3471 0000F55C C5 4D 02 C0             		sb		r0,KBD+2	; clear read flag
   3472 0000F560 F1 4F 10 10             		cmp		r1,#SC_KEYUP
   3473 0000F564 01 A9                   		bne		notKeyup
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:31 2017     Page 5
noc_boot21.asm
   3474 0000F566 56 AE                   		jmp		doKeyup
   3475 0000F568                        notKeyup:
   3476 0000F568 F2 4F 10 10             		cmp		r1,#SC_EXTEND
   3477 0000F56C 01 A9                   		bne		notExtend
   3478 0000F56E 58 AE                   		jmp		doExtend
   3479 0000F570                        notExtend:
   3480 0000F570 FE 4F 1C 10             		cmp		r1,#$14		; control ?
   3481 0000F574 01 A9                   		bne		notCtrl
   3482 0000F576 5B AE                   		jmp		doCtrl
   3483 0000F578                        notCtrl:
   3484 0000F578 FE 4F 1E 10             		cmp		r1,#$12
   3485 0000F57C 01 A9                   		bne		notShift
   3486 0000F57E 68 AE                   		jmp		doShift
   3487 0000F580                        notShift:
   3488 0000F580 FA 4F 17 10             		cmp		r1,#$59
   3489 0000F584 01 A9                   		bne		notShift2
   3490 0000F586 64 AE                   		jmp		doShift
   3491 0000F588                        notShift2:
   3492 0000F588 F8 4F 19 10             		cmp		r1,#SC_NUMLOCK
   3493 0000F58C 01 A9                   		bne		notNumLock
   3494 0000F58E 71 AE                   		jmp		doNumLock
   3495 0000F590                        notNumLock:
   3496 0000F590 FA 4F 18 10             		cmp		r1,#SC_CAPSLOCK
   3497 0000F594 01 A9                   		bne		notCapsLock
   3498 0000F596 75 AE                   		jmp		doCapsLock
   3499 0000F598                        notCapsLock:
   3500 0000F598 F8 4F 12 10             		cmp		r1,#SC_SCROLLLOCK
   3501 0000F59C 01 A9                   		bne		notScrollLock
   3502 0000F59E 79 AE                   		jmp		doScrollLock
   3503 0000F5A0                        notScrollLock:
   3504 0000F5A0 01 40 00 E2             		lb		r2,KeyState1
   3505 0000F5A4 20 14                   		mov		r4,r2
   3506 0000F5A6 A1 32                   		shr		r2,#1
   3507 0000F5A8 01 40 00 C2             		sb		r2,KeyState1
   3508 0000F5AC 51 34                   		and		r4,#1
   3509 0000F5AE 01 A8                   		beq		kbd11
   3510 0000F5B0 BE BE                   		jmp		kbd3
   3511 0000F5B2                        kbd11:
   3512 0000F5B2 10 12                   		mov		r2,r1
                                        		; Check for extended code
   3514 0000F5B4 08 40 00 11             		lw		r1,#$80
   3515 0000F5B8 01 40 01 E4             		lb		r4,KeyState2
   3516 0000F5BC 45 21                   		and		r1,r4
   3517 0000F5BE 11 A8                   		beq		kbd10
   3518 0000F5C0 07 40 0F 11             		lw		r1,#$7F
   3519 0000F5C4 45 21                   		and		r1,r4
   3520 0000F5C6 01 40 01 C1             		sb		r1,KeyState2
                                        		; clear keyup
   3522 0000F5CA 01 40 00 E4             		lb		r4,KeyState1
   3523 0000F5CE A1 34                   		shr		r4,#1
   3524 0000F5D0 01 40 00 C4             		sb		r4,KeyState1
   3525 0000F5D4 20 11                   		mov		r1,r2
   3526 0000F5D6 07 40 5F 31             		and		r1,#$7F
   3527 0000F5DA 10 12                   		mov		r2,r1
   3528 0000F5DC 92 4F 24 E1             		lb		r1,keybdExtendedCodes[r2]
   3529 0000F5E0 14 AE                   		bra		kbd8
   3530 0000F5E2                        kbd10:
   3531 0000F5E2 01 40 01 E1             		lb		r1,KeyState2
   3532 0000F5E6 54 31                   		and		r1,#4
   3533 0000F5E8 07 A8                   		beq		kbd9
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:31 2017     Page 6
noc_boot21.asm
   3534 0000F5EA 20 11                   		mov		r1,r2
   3535 0000F5EC 07 40 5F 31             		and		r1,#$7F
   3536 0000F5F0 10 12                   		mov		r2,r1
   3537 0000F5F2 8A 4F 24 E1             		lb		r1,keybdControlCodes[r2]
   3538 0000F5F6 09 AE                   		bra		kbd8
   3539 0000F5F8                        kbd9:
   3540 0000F5F8 01 40 01 E1             		lb		r1,KeyState2
   3541 0000F5FC 51 31                   		and		r1,#1			; Is shift down ?
   3542 0000F5FE 03 A8                   		beq		kbd7
   3543 0000F600 7A 4F 24 E1             		lb		r1,shiftedScanCodes[r2]
   3544 0000F604 02 AE                   		bra		kbd8
   3545 0000F606                        kbd7:
   3546 0000F606 6A 4F 24 E1             		lb		r1,unshiftedScanCodes[r2]
   3547 0000F60A                        kbd8:
                                        		; return zero in r2 to indicate key available
   3549 0000F60A E1 FF                   		lw		lr,[sp]
   3550 0000F60C E3 F4                   		lw		r4,2[sp]
   3551 0000F60E 04 6E                   		add		sp,sp,#4
   3552 0000F610 00 12                   		lw		r2,#0
   3553 0000F612 F0 80                   		ret
   3554 0000F614                        doKeyup:
   3555 0000F614 01 40 00 E1             		lb		r1,KeyState1
   3556 0000F618 61 31                   		or		r1,#1
   3557 0000F61A 01 40 00 C1             		sb		r1,KeyState1
   3558 0000F61E 87 BE                   		jmp		kbd3
   3559 0000F620                        doExtend:
   3560 0000F620 01 40 01 E1             		lb		r1,KeyState2
   3561 0000F624 08 40 60 31             		or		r1,#$80
   3562 0000F628 01 40 01 C1             		sb		r1,KeyState2
   3563 0000F62C 80 BE                   		jmp		kbd3
   3564 0000F62E                        doCtrl:
   3565 0000F62E 01 40 00 E1             		lb		r1,KeyState1
   3566 0000F632 C1 31                   		ror		r1,#1
   3567 0000F634 07 AB                   		bpl		kbd4
   3568 0000F636 01 40 01 E1             		lb		r1,KeyState2
   3569 0000F63A FF 4F 5B 31             		and		r1,#$FFFB
   3570 0000F63E 01 40 01 C1             		sb		r1,KeyState2
   3571 0000F642 75 BE                   		jmp		kbd3
   3572 0000F644                        kbd4:
   3573 0000F644 01 40 01 E1             		lb		r1,KeyState2
   3574 0000F648 64 31                   		or		r1,#4
   3575 0000F64A 01 40 01 C1             		sb		r1,KeyState2
   3576 0000F64E 6F BE                   		jmp		kbd3		
   3577 0000F650                        doShift:
   3578 0000F650 01 40 00 E1             		lb		r1,KeyState1
   3579 0000F654 C1 31                   		ror		r1,#1
   3580 0000F656 07 AB                   		bpl		kbd5
   3581 0000F658 01 40 01 E1             		lb		r1,KeyState2
   3582 0000F65C FF 4F 5E 31             		and		r1,#$FFFE
   3583 0000F660 01 40 01 C1             		sb		r1,KeyState2
   3584 0000F664 64 BE                   		jmp		kbd3
   3585 0000F666                        kbd5:
   3586 0000F666 01 40 01 E1             		lb		r1,KeyState2
   3587 0000F66A 61 31                   		or		r1,#1
   3588 0000F66C 01 40 01 C1             		sb		r1,KeyState2
   3589 0000F670 5E BE                   		jmp		kbd3
   3590 0000F672                        doNumLock:
   3591 0000F672 01 40 01 E1             		lb		r1,KeyState2
   3592 0000F676 01 40 40 31             		xor		r1,#16
   3593 0000F67A 01 40 01 C1             		sb		r1,KeyState2
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:31 2017     Page 7
noc_boot21.asm
   3594 0000F67E 11 AF                   		call	KeybdSetLEDStatus
   3595 0000F680 56 BE                   		jmp		kbd3
   3596 0000F682                        doCapsLock:
   3597 0000F682 01 40 01 E1             		lb		r1,KeyState2
   3598 0000F686 02 40 40 31             		xor		r1,#32
   3599 0000F68A 01 40 01 C1             		sb		r1,KeyState2
   3600 0000F68E 09 AF                   		call	KeybdSetLEDStatus
   3601 0000F690 4E BE                   		jmp		kbd3
   3602 0000F692                        doScrollLock:
   3603 0000F692 01 40 01 E1             		lb		r1,KeyState2
   3604 0000F696 04 40 40 31             		xor		r1,#64
   3605 0000F69A 01 40 01 C1             		sb		r1,KeyState2
   3606 0000F69E 01 AF                   		call	KeybdSetLEDStatus
   3607 0000F6A0 46 BE                   		jmp		kbd3
                                        
   3609 0000F6A2                        KeybdSetLEDStatus:
   3610 0000F6A2 F0 80                   		ret
                                        
                                        	;--------------------------------------------------------------------------
                                        	; PS2 scan codes to ascii conversion tables.
                                        	;--------------------------------------------------------------------------
                                        	;
   3616 0000F6A4                        unshiftedScanCodes:
   3617 0000F6A4 2E A9 2E A5 A3 A1 A2    	.byte	$2e,$a9,$2e,$a5,$a3,$a1,$a2,$ac
   3617 0000F6AB AC                    
   3618 0000F6AC 2E AA A8 A6 A4 09 60    	.byte	$2e,$aa,$a8,$a6,$a4,$09,$60,$2e
   3618 0000F6B3 2E                    
   3619 0000F6B4 2E 2E 2E 2E 2E 71 31    	.byte	$2e,$2e,$2e,$2e,$2e,$71,$31,$2e
   3619 0000F6BB 2E                    
   3620 0000F6BC 2E 2E 7A 73 61 77 32    	.byte	$2e,$2e,$7a,$73,$61,$77,$32,$2e
   3620 0000F6C3 2E                    
   3621 0000F6C4 2E 63 78 64 65 34 33    	.byte	$2e,$63,$78,$64,$65,$34,$33,$2e
   3621 0000F6CB 2E                    
   3622 0000F6CC 2E 20 76 66 74 72 35    	.byte	$2e,$20,$76,$66,$74,$72,$35,$2e
   3622 0000F6D3 2E                    
   3623 0000F6D4 2E 6E 62 68 67 79 36    	.byte	$2e,$6e,$62,$68,$67,$79,$36,$2e
   3623 0000F6DB 2E                    
   3624 0000F6DC 2E 2E 6D 6A 75 37 38    	.byte	$2e,$2e,$6d,$6a,$75,$37,$38,$2e
   3624 0000F6E3 2E                    
   3625 0000F6E4 2E 2C 6B 69 6F 30 39    	.byte	$2e,$2c,$6b,$69,$6f,$30,$39,$2e
   3625 0000F6EB 2E                    
   3626 0000F6EC 2E 2E 2F 6C 3B 70 2D    	.byte	$2e,$2e,$2f,$6c,$3b,$70,$2d,$2e
   3626 0000F6F3 2E                    
   3627 0000F6F4 2E 2E 27 2E 5B 3D 2E    	.byte	$2e,$2e,$27,$2e,$5b,$3d,$2e,$2e
   3627 0000F6FB 2E                    
   3628 0000F6FC AD 2E 0D 5D 2E 5C 2E    	.byte	$ad,$2e,$0d,$5d,$2e,$5c,$2e,$2e
   3628 0000F703 2E                    
   3629 0000F704 2E 2E 2E 2E 2E 2E 08    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
   3629 0000F70B 2E                    
   3630 0000F70C 2E 95 2E 93 94 2E 2E    	.byte	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
   3630 0000F713 2E                    
   3631 0000F714 98 7F 92 2E 91 90 1B    	.byte	$98,$7f,$92,$2e,$91,$90,$1b,$af
   3631 0000F71B AF                    
   3632 0000F71C AB 2E 97 2E 2E 96 AE    	.byte	$ab,$2e,$97,$2e,$2e,$96,$ae,$2e
   3632 0000F723 2E                    
                                        
   3634 0000F724 2E 2E 2E A7 2E 2E 2E    	.byte	$2e,$2e,$2e,$a7,$2e,$2e,$2e,$2e
   3634 0000F72B 2E                    
   3635 0000F72C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3635 0000F733 2E                    
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:31 2017     Page 8
noc_boot21.asm
   3636 0000F734 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3636 0000F73B 2E                    
   3637 0000F73C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3637 0000F743 2E                    
   3638 0000F744 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3638 0000F74B 2E                    
   3639 0000F74C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3639 0000F753 2E                    
   3640 0000F754 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3640 0000F75B 2E                    
   3641 0000F75C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3641 0000F763 2E                    
   3642 0000F764 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3642 0000F76B 2E                    
   3643 0000F76C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3643 0000F773 2E                    
   3644 0000F774 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3644 0000F77B 2E                    
   3645 0000F77C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3645 0000F783 2E                    
   3646 0000F784 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3646 0000F78B 2E                    
   3647 0000F78C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3647 0000F793 2E                    
   3648 0000F794 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3648 0000F79B 2E                    
   3649 0000F79C 2E 2E FA 2E 2E 2E 2E    	.byte	$2e,$2e,$fa,$2e,$2e,$2e,$2e,$2e
   3649 0000F7A3 2E                    
                                        
   3651 0000F7A4                        shiftedScanCodes:
   3652 0000F7A4 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3652 0000F7AB 2E                    
   3653 0000F7AC 2E 2E 2E 2E 2E 09 7E    	.byte	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
   3653 0000F7B3 2E                    
   3654 0000F7B4 2E 2E 2E 2E 2E 51 21    	.byte	$2e,$2e,$2e,$2e,$2e,$51,$21,$2e
   3654 0000F7BB 2E                    
   3655 0000F7BC 2E 2E 5A 53 41 57 40    	.byte	$2e,$2e,$5a,$53,$41,$57,$40,$2e
   3655 0000F7C3 2E                    
   3656 0000F7C4 2E 43 58 44 45 24 23    	.byte	$2e,$43,$58,$44,$45,$24,$23,$2e
   3656 0000F7CB 2E                    
   3657 0000F7CC 2E 20 56 46 54 52 25    	.byte	$2e,$20,$56,$46,$54,$52,$25,$2e
   3657 0000F7D3 2E                    
   3658 0000F7D4 2E 4E 42 48 47 59 5E    	.byte	$2e,$4e,$42,$48,$47,$59,$5e,$2e
   3658 0000F7DB 2E                    
   3659 0000F7DC 2E 2E 4D 4A 55 26 2A    	.byte	$2e,$2e,$4d,$4a,$55,$26,$2a,$2e
   3659 0000F7E3 2E                    
   3660 0000F7E4 2E 3C 4B 49 4F 29 28    	.byte	$2e,$3c,$4b,$49,$4f,$29,$28,$2e
   3660 0000F7EB 2E                    
   3661 0000F7EC 2E 3E 3F 4C 3A 50 5F    	.byte	$2e,$3e,$3f,$4c,$3a,$50,$5f,$2e
   3661 0000F7F3 2E                    
   3662 0000F7F4 2E 2E 22 2E 7B 2B 2E    	.byte	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
   3662 0000F7FB 2E                    
   3663 0000F7FC 2E 2E 0D 7D 2E 7C 2E    	.byte	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
   3663 0000F803 2E                    
   3664 0000F804 2E 2E 2E 2E 2E 2E 08    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
   3664 0000F80B 2E                    
   3665 0000F80C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3665 0000F813 2E                    
   3666 0000F814 2E 7F 2E 2E 2E 2E 1B    	.byte	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
   3666 0000F81B 2E                    
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:31 2017     Page 9
noc_boot21.asm
   3667 0000F81C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3667 0000F823 2E                    
                                        
   3669 0000F824 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3669 0000F82B 2E                    
   3670 0000F82C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3670 0000F833 2E                    
   3671 0000F834 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3671 0000F83B 2E                    
   3672 0000F83C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3672 0000F843 2E                    
   3673 0000F844 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3673 0000F84B 2E                    
   3674 0000F84C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3674 0000F853 2E                    
   3675 0000F854 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3675 0000F85B 2E                    
   3676 0000F85C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3676 0000F863 2E                    
   3677 0000F864 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3677 0000F86B 2E                    
   3678 0000F86C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3678 0000F873 2E                    
   3679 0000F874 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3679 0000F87B 2E                    
   3680 0000F87C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3680 0000F883 2E                    
   3681 0000F884 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3681 0000F88B 2E                    
   3682 0000F88C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3682 0000F893 2E                    
   3683 0000F894 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3683 0000F89B 2E                    
   3684 0000F89C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3684 0000F8A3 2E                    
                                        
                                        ; control
   3687 0000F8A4                        keybdControlCodes:
   3688 0000F8A4 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3688 0000F8AB 2E                    
   3689 0000F8AC 2E 2E 2E 2E 2E 09 7E    	.byte	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
   3689 0000F8B3 2E                    
   3690 0000F8B4 2E 2E 2E 2E 2E 11 21    	.byte	$2e,$2e,$2e,$2e,$2e,$11,$21,$2e
   3690 0000F8BB 2E                    
   3691 0000F8BC 2E 2E 1A 13 01 17 40    	.byte	$2e,$2e,$1a,$13,$01,$17,$40,$2e
   3691 0000F8C3 2E                    
   3692 0000F8C4 2E 03 18 04 05 24 23    	.byte	$2e,$03,$18,$04,$05,$24,$23,$2e
   3692 0000F8CB 2E                    
   3693 0000F8CC 2E 20 16 06 14 12 25    	.byte	$2e,$20,$16,$06,$14,$12,$25,$2e
   3693 0000F8D3 2E                    
   3694 0000F8D4 2E 0E 02 08 07 19 5E    	.byte	$2e,$0e,$02,$08,$07,$19,$5e,$2e
   3694 0000F8DB 2E                    
   3695 0000F8DC 2E 2E 0D 0A 15 26 2A    	.byte	$2e,$2e,$0d,$0a,$15,$26,$2a,$2e
   3695 0000F8E3 2E                    
   3696 0000F8E4 2E 3C 0B 09 0F 29 28    	.byte	$2e,$3c,$0b,$09,$0f,$29,$28,$2e
   3696 0000F8EB 2E                    
   3697 0000F8EC 2E 3E 3F 0C 3A 10 5F    	.byte	$2e,$3e,$3f,$0c,$3a,$10,$5f,$2e
   3697 0000F8F3 2E                    
   3698 0000F8F4 2E 2E 22 2E 7B 2B 2E    	.byte	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
   3698 0000F8FB 2E                    
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:31 2017     Page 10
noc_boot21.asm
   3699 0000F8FC 2E 2E 0D 7D 2E 7C 2E    	.byte	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
   3699 0000F903 2E                    
   3700 0000F904 2E 2E 2E 2E 2E 2E 08    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
   3700 0000F90B 2E                    
   3701 0000F90C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3701 0000F913 2E                    
   3702 0000F914 2E 7F 2E 2E 2E 2E 1B    	.byte	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
   3702 0000F91B 2E                    
   3703 0000F91C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3703 0000F923 2E                    
                                        
   3705 0000F924                        keybdExtendedCodes:
   3706 0000F924 2E 2E 2E 2E A3 A1 A2    	.byte	$2e,$2e,$2e,$2e,$a3,$a1,$a2,$2e
   3706 0000F92B 2E                    
   3707 0000F92C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3707 0000F933 2E                    
   3708 0000F934 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3708 0000F93B 2E                    
   3709 0000F93C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3709 0000F943 2E                    
   3710 0000F944 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3710 0000F94B 2E                    
   3711 0000F94C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3711 0000F953 2E                    
   3712 0000F954 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3712 0000F95B 2E                    
   3713 0000F95C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3713 0000F963 2E                    
   3714 0000F964 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3714 0000F96B 2E                    
   3715 0000F96C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3715 0000F973 2E                    
   3716 0000F974 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3716 0000F97B 2E                    
   3717 0000F97C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3717 0000F983 2E                    
   3718 0000F984 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3718 0000F98B 2E                    
   3719 0000F98C 2E 95 2E 93 94 2E 2E    	.byte	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
   3719 0000F993 2E                    
   3720 0000F994 98 99 92 2E 91 90 2E    	.byte	$98,$99,$92,$2e,$91,$90,$2e,$2e
   3720 0000F99B 2E                    
   3721 0000F99C 2E 2E 97 2E 2E 96 2E    	.byte	$2e,$2e,$97,$2e,$2e,$96,$2e,$2e
   3721 0000F9A3 2E                    
                                        
                                        
   3724 0000F9A4 FF FF FF FF FF FF FF    		org		0xFFFE
   3724 0000F9AB FF FF FF FF FF FF FF  
   3724 0000F9B2 FF FF FF FF FF FF FF  
   3724 0000F9B9 FF FF FF FF FF FF FF  
   3724 0000F9C0 FF FF FF FF FF FF FF  
   3724 0000F9C7 FF FF FF FF FF FF FF  
   3724 0000F9CE FF FF FF FF FF FF FF  
   3724 0000F9D5 FF FF FF FF FF FF FF  
   3724 0000F9DC FF FF FF FF FF FF FF  
   3724 0000F9E3 FF FF FF FF FF FF FF  
   3724 0000F9EA FF FF FF FF FF FF FF  
   3724 0000F9F1 FF FF FF FF FF FF FF  
   3724 0000F9F8 FF FF FF FF FF FF FF  
   3724 0000F9FF FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:31 2017     Page 11
noc_boot21.asm
   3724 0000FA06 FF FF FF FF FF FF FF  
   3724 0000FA0D FF FF FF FF FF FF FF  
   3724 0000FA14 FF FF FF FF FF FF FF  
   3724 0000FA1B FF FF FF FF FF FF FF  
   3724 0000FA22 FF FF FF FF FF FF FF  
   3724 0000FA29 FF FF FF FF FF FF FF  
   3724 0000FA30 FF FF FF FF FF FF FF  
   3724 0000FA37 FF FF FF FF FF FF FF  
   3724 0000FA3E FF FF FF FF FF FF FF  
   3724 0000FA45 FF FF FF FF FF FF FF  
   3724 0000FA4C FF FF FF FF FF FF FF  
   3724 0000FA53 FF FF FF FF FF FF FF  
   3724 0000FA5A FF FF FF FF FF FF FF  
   3724 0000FA61 FF FF FF FF FF FF FF  
   3724 0000FA68 FF FF FF FF FF FF FF  
   3724 0000FA6F FF FF FF FF FF FF FF  
   3724 0000FA76 FF FF FF FF FF FF FF  
   3724 0000FA7D FF FF FF FF FF FF FF  
   3724 0000FA84 FF FF FF FF FF FF FF  
   3724 0000FA8B FF FF FF FF FF FF FF  
   3724 0000FA92 FF FF FF FF FF FF FF  
   3724 0000FA99 FF FF FF FF FF FF FF  
   3724 0000FAA0 FF FF FF FF FF FF FF  
   3724 0000FAA7 FF FF FF FF FF FF FF  
   3724 0000FAAE FF FF FF FF FF FF FF  
   3724 0000FAB5 FF FF FF FF FF FF FF  
   3724 0000FABC FF FF FF FF FF FF FF  
   3724 0000FAC3 FF FF FF FF FF FF FF  
   3724 0000FACA FF FF FF FF FF FF FF  
   3724 0000FAD1 FF FF FF FF FF FF FF  
   3724 0000FAD8 FF FF FF FF FF FF FF  
   3724 0000FADF FF FF FF FF FF FF FF  
   3724 0000FAE6 FF FF FF FF FF FF FF  
   3724 0000FAED FF FF FF FF FF FF FF  
   3724 0000FAF4 FF FF FF FF FF FF FF  
   3724 0000FAFB FF FF FF FF FF FF FF  
   3724 0000FB02 FF FF FF FF FF FF FF  
   3724 0000FB09 FF FF FF FF FF FF FF  
   3724 0000FB10 FF FF FF FF FF FF FF  
   3724 0000FB17 FF FF FF FF FF FF FF  
   3724 0000FB1E FF FF FF FF FF FF FF  
   3724 0000FB25 FF FF FF FF FF FF FF  
   3724 0000FB2C FF FF FF FF FF FF FF  
   3724 0000FB33 FF FF FF FF FF FF FF  
   3724 0000FB3A FF FF FF FF FF FF FF  
   3724 0000FB41 FF FF FF FF FF FF FF  
   3724 0000FB48 FF FF FF FF FF FF FF  
   3724 0000FB4F FF FF FF FF FF FF FF  
   3724 0000FB56 FF FF FF FF FF FF FF  
   3724 0000FB5D FF FF FF FF FF FF FF  
   3724 0000FB64 FF FF FF FF FF FF FF  
   3724 0000FB6B FF FF FF FF FF FF FF  
   3724 0000FB72 FF FF FF FF FF FF FF  
   3724 0000FB79 FF FF FF FF FF FF FF  
   3724 0000FB80 FF FF FF FF FF FF FF  
   3724 0000FB87 FF FF FF FF FF FF FF  
   3724 0000FB8E FF FF FF FF FF FF FF  
   3724 0000FB95 FF FF FF FF FF FF FF  
   3724 0000FB9C FF FF FF FF FF FF FF  
   3724 0000FBA3 FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:31 2017     Page 12
noc_boot21.asm
   3724 0000FBAA FF FF FF FF FF FF FF  
   3724 0000FBB1 FF FF FF FF FF FF FF  
   3724 0000FBB8 FF FF FF FF FF FF FF  
   3724 0000FBBF FF FF FF FF FF FF FF  
   3724 0000FBC6 FF FF FF FF FF FF FF  
   3724 0000FBCD FF FF FF FF FF FF FF  
   3724 0000FBD4 FF FF FF FF FF FF FF  
   3724 0000FBDB FF FF FF FF FF FF FF  
   3724 0000FBE2 FF FF FF FF FF FF FF  
   3724 0000FBE9 FF FF FF FF FF FF FF  
   3724 0000FBF0 FF FF FF FF FF FF FF  
   3724 0000FBF7 FF FF FF FF FF FF FF  
   3724 0000FBFE FF FF FF FF FF FF FF  
   3724 0000FC05 FF FF FF FF FF FF FF  
   3724 0000FC0C FF FF FF FF FF FF FF  
   3724 0000FC13 FF FF FF FF FF FF FF  
   3724 0000FC1A FF FF FF FF FF FF FF  
   3724 0000FC21 FF FF FF FF FF FF FF  
   3724 0000FC28 FF FF FF FF FF FF FF  
   3724 0000FC2F FF FF FF FF FF FF FF  
   3724 0000FC36 FF FF FF FF FF FF FF  
   3724 0000FC3D FF FF FF FF FF FF FF  
   3724 0000FC44 FF FF FF FF FF FF FF  
   3724 0000FC4B FF FF FF FF FF FF FF  
   3724 0000FC52 FF FF FF FF FF FF FF  
   3724 0000FC59 FF FF FF FF FF FF FF  
   3724 0000FC60 FF FF FF FF FF FF FF  
   3724 0000FC67 FF FF FF FF FF FF FF  
   3724 0000FC6E FF FF FF FF FF FF FF  
   3724 0000FC75 FF FF FF FF FF FF FF  
   3724 0000FC7C FF FF FF FF FF FF FF  
   3724 0000FC83 FF FF FF FF FF FF FF  
   3724 0000FC8A FF FF FF FF FF FF FF  
   3724 0000FC91 FF FF FF FF FF FF FF  
   3724 0000FC98 FF FF FF FF FF FF FF  
   3724 0000FC9F FF FF FF FF FF FF FF  
   3724 0000FCA6 FF FF FF FF FF FF FF  
   3724 0000FCAD FF FF FF FF FF FF FF  
   3724 0000FCB4 FF FF FF FF FF FF FF  
   3724 0000FCBB FF FF FF FF FF FF FF  
   3724 0000FCC2 FF FF FF FF FF FF FF  
   3724 0000FCC9 FF FF FF FF FF FF FF  
   3724 0000FCD0 FF FF FF FF FF FF FF  
   3724 0000FCD7 FF FF FF FF FF FF FF  
   3724 0000FCDE FF FF FF FF FF FF FF  
   3724 0000FCE5 FF FF FF FF FF FF FF  
   3724 0000FCEC FF FF FF FF FF FF FF  
   3724 0000FCF3 FF FF FF FF FF FF FF  
   3724 0000FCFA FF FF FF FF FF FF FF  
   3724 0000FD01 FF FF FF FF FF FF FF  
   3724 0000FD08 FF FF FF FF FF FF FF  
   3724 0000FD0F FF FF FF FF FF FF FF  
   3724 0000FD16 FF FF FF FF FF FF FF  
   3724 0000FD1D FF FF FF FF FF FF FF  
   3724 0000FD24 FF FF FF FF FF FF FF  
   3724 0000FD2B FF FF FF FF FF FF FF  
   3724 0000FD32 FF FF FF FF FF FF FF  
   3724 0000FD39 FF FF FF FF FF FF FF  
   3724 0000FD40 FF FF FF FF FF FF FF  
   3724 0000FD47 FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:31 2017     Page 13
noc_boot21.asm
   3724 0000FD4E FF FF FF FF FF FF FF  
   3724 0000FD55 FF FF FF FF FF FF FF  
   3724 0000FD5C FF FF FF FF FF FF FF  
   3724 0000FD63 FF FF FF FF FF FF FF  
   3724 0000FD6A FF FF FF FF FF FF FF  
   3724 0000FD71 FF FF FF FF FF FF FF  
   3724 0000FD78 FF FF FF FF FF FF FF  
   3724 0000FD7F FF FF FF FF FF FF FF  
   3724 0000FD86 FF FF FF FF FF FF FF  
   3724 0000FD8D FF FF FF FF FF FF FF  
   3724 0000FD94 FF FF FF FF FF FF FF  
   3724 0000FD9B FF FF FF FF FF FF FF  
   3724 0000FDA2 FF FF FF FF FF FF FF  
   3724 0000FDA9 FF FF FF FF FF FF FF  
   3724 0000FDB0 FF FF FF FF FF FF FF  
   3724 0000FDB7 FF FF FF FF FF FF FF  
   3724 0000FDBE FF FF FF FF FF FF FF  
   3724 0000FDC5 FF FF FF FF FF FF FF  
   3724 0000FDCC FF FF FF FF FF FF FF  
   3724 0000FDD3 FF FF FF FF FF FF FF  
   3724 0000FDDA FF FF FF FF FF FF FF  
   3724 0000FDE1 FF FF FF FF FF FF FF  
   3724 0000FDE8 FF FF FF FF FF FF FF  
   3724 0000FDEF FF FF FF FF FF FF FF  
   3724 0000FDF6 FF FF FF FF FF FF FF  
   3724 0000FDFD FF FF FF FF FF FF FF  
   3724 0000FE04 FF FF FF FF FF FF FF  
   3724 0000FE0B FF FF FF FF FF FF FF  
   3724 0000FE12 FF FF FF FF FF FF FF  
   3724 0000FE19 FF FF FF FF FF FF FF  
   3724 0000FE20 FF FF FF FF FF FF FF  
   3724 0000FE27 FF FF FF FF FF FF FF  
   3724 0000FE2E FF FF FF FF FF FF FF  
   3724 0000FE35 FF FF FF FF FF FF FF  
   3724 0000FE3C FF FF FF FF FF FF FF  
   3724 0000FE43 FF FF FF FF FF FF FF  
   3724 0000FE4A FF FF FF FF FF FF FF  
   3724 0000FE51 FF FF FF FF FF FF FF  
   3724 0000FE58 FF FF FF FF FF FF FF  
   3724 0000FE5F FF FF FF FF FF FF FF  
   3724 0000FE66 FF FF FF FF FF FF FF  
   3724 0000FE6D FF FF FF FF FF FF FF  
   3724 0000FE74 FF FF FF FF FF FF FF  
   3724 0000FE7B FF FF FF FF FF FF FF  
   3724 0000FE82 FF FF FF FF FF FF FF  
   3724 0000FE89 FF FF FF FF FF FF FF  
   3724 0000FE90 FF FF FF FF FF FF FF  
   3724 0000FE97 FF FF FF FF FF FF FF  
   3724 0000FE9E FF FF FF FF FF FF FF  
   3724 0000FEA5 FF FF FF FF FF FF FF  
   3724 0000FEAC FF FF FF FF FF FF FF  
   3724 0000FEB3 FF FF FF FF FF FF FF  
   3724 0000FEBA FF FF FF FF FF FF FF  
   3724 0000FEC1 FF FF FF FF FF FF FF  
   3724 0000FEC8 FF FF FF FF FF FF FF  
   3724 0000FECF FF FF FF FF FF FF FF  
   3724 0000FED6 FF FF FF FF FF FF FF  
   3724 0000FEDD FF FF FF FF FF FF FF  
   3724 0000FEE4 FF FF FF FF FF FF FF  
   3724 0000FEEB FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 14 06:14:31 2017     Page 14
noc_boot21.asm
   3724 0000FEF2 FF FF FF FF FF FF FF  
   3724 0000FEF9 FF FF FF FF FF FF FF  
   3724 0000FF00 FF FF FF FF FF FF FF  
   3724 0000FF07 FF FF FF FF FF FF FF  
   3724 0000FF0E FF FF FF FF FF FF FF  
   3724 0000FF15 FF FF FF FF FF FF FF  
   3724 0000FF1C FF FF FF FF FF FF FF  
   3724 0000FF23 FF FF FF FF FF FF FF  
   3724 0000FF2A FF FF FF FF FF FF FF  
   3724 0000FF31 FF FF FF FF FF FF FF  
   3724 0000FF38 FF FF FF FF FF FF FF  
   3724 0000FF3F FF FF FF FF FF FF FF  
   3724 0000FF46 FF FF FF FF FF FF FF  
   3724 0000FF4D FF FF FF FF FF FF FF  
   3724 0000FF54 FF FF FF FF FF FF FF  
   3724 0000FF5B FF FF FF FF FF FF FF  
   3724 0000FF62 FF FF FF FF FF FF FF  
   3724 0000FF69 FF FF FF FF FF FF FF  
   3724 0000FF70 FF FF FF FF FF FF FF  
   3724 0000FF77 FF FF FF FF FF FF FF  
   3724 0000FF7E FF FF FF FF FF FF FF  
   3724 0000FF85 FF FF FF FF FF FF FF  
   3724 0000FF8C FF FF FF FF FF FF FF  
   3724 0000FF93 FF FF FF FF FF FF FF  
   3724 0000FF9A FF FF FF FF FF FF FF  
   3724 0000FFA1 FF FF FF FF FF FF FF  
   3724 0000FFA8 FF FF FF FF FF FF FF  
   3724 0000FFAF FF FF FF FF FF FF FF  
   3724 0000FFB6 FF FF FF FF FF FF FF  
   3724 0000FFBD FF FF FF FF FF FF FF  
   3724 0000FFC4 FF FF FF FF FF FF FF  
   3724 0000FFCB FF FF FF FF FF FF FF  
   3724 0000FFD2 FF FF FF FF FF FF FF  
   3724 0000FFD9 FF FF FF FF FF FF FF  
   3724 0000FFE0 FF FF FF FF FF FF FF  
   3724 0000FFE7 FF FF FF FF FF FF FF  
   3724 0000FFEE FF FF FF FF FF FF FF  
   3724 0000FFF5 FF FF FF FF FF FF FF  
   3724 0000FFFC FF FF                 
   3725 0000FFFE CC F3                   		dw		start
