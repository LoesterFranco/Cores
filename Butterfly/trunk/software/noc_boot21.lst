Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 1
noc_boot21.a

                                        ; ============================================================================
                                        ;        __
                                        ;   \\__/ o\    (C) 2017  Robert Finch, Waterloo
                                        ;    \  __ /    All rights reserved.
                                        ;     \/_//     robfinch<remove>@finitron.ca
                                        ;       ||
                                        ;  
                                        ;
                                        ; This source file is free software: you can redistribute it and/or modify 
                                        ; it under the terms of the GNU Lesser General Public License as published 
                                        ; by the Free Software Foundation, either version 3 of the License, or     
                                        ; (at your option) any later version.                                      
                                        ;                                                                          
                                        ; This source file is distributed in the hope that it will be useful,      
                                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                                        ; GNU General Public License for more details.                             
                                        ;                                                                          
                                        ; You should have received a copy of the GNU General Public License        
                                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                                        ;                                    
                                        ;                                      
                                        ; This boot rom for the input node $21.
                                        ; ============================================================================
                                        ;
     26 = 0D                            CR	= 13
     27 = 0A                            LF	= 10
     28 = 09                            CTRLH	equ		9
                                        
     30 = 12                            SC_LSHIFT	EQU		$12
     31 = 59                            SC_RSHIFT	EQU		$59
     32 = 00F0                          SC_KEYUP	EQU		$F0
     33 = 00E0                          SC_EXTEND	EQU		$E0
     34 = 14                            SC_CTRL		EQU		$14
     35 = 11                            SC_ALT		EQU		$11
     36 = 71                            SC_DEL		EQU		$71		; extend
     37 = 58                            SC_LCTRL	EQU		$58
     38 = 77                            SC_NUMLOCK	EQU		$77
     39 = 7E                            SC_SCROLLLOCK	EQU	$7E
     40 = 58                            SC_CAPSLOCK	EQU		$58
                                        
     42 = 01                            MT_RST		equ		1
     43 = 02                            MT_RST_ACK	equ		2
     44 = 03                            MT_STOP		equ		3
     45 = 04                            MT_KEYSTROKE			equ	4
     46 = 05                            MT_SET_INPUT_FOCUS		equ	5
     47 = 06                            MT_BUTTON_STATUS		equ	6
     48 = 07                            MT_REQ_INP_FOCUS		equ	7
     49 = 08                            MT_GRNT_INP_FOCUS		equ 8
     50 = 09                            MT_PING					equ	9
     51 = 0A                            MT_START_BASIC_LOAD		equ	10
     52 = 0B                            MT_LOAD_BASIC_CHAR		equ	11
     53 = 0C                            MT_RUN_BASIC_PROG		equ	12
     54 = 0D                            MT_BASIC_EXIT			equ	13
     55 = 0F                            MT_REQ_OUT_FOCUS		equ	15
     56 = 10                            MT_GRNT_OUT_FOCUS		equ	16
     57 = 11                            MT_OUT_CHAR				equ	17
     58 = 12                            MT_PING_ACK				equ	18
                                        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 2
noc_boot21.a
     60 = 0F                            HTInputFocus	equ	15
     61 = 10                            KeyState1	equ	16
     62 = 11                            KeyState2	equ	17
     63 = 20                            txBuf	equ		32
     64 = 30                            rxBuf	equ		48
                                        
     66 = 000000000000B000                              ROUTER		equ	$B000
     67 = 10                            RTR_RXSTAT	equ	$10
     68 = 12                            RTR_TXSTAT	equ	$12
     69 = 00                            ROUTER_TRB	equ	0
                                        
     71 = 000000000000B200                              BTNS		equ	$B200
     72 = 000000000000B210                              KBD			equ	$B210
     73 = 01                            KBD_STAT	equ	1
                                        
     75 = 0F                            MSG_DST		equ	15
     76 = 0E                            MSG_SRC		equ	14
     77 = 07                            MSG_TYPE	equ	7
                                        
                                        		.code
                                        		cpu		Butterfly16
                                        		org		0xE000
                                        ; ============================================================================
                                        ;        __
                                        ;   \\__/ o\    (C) 2017  Robert Finch, Waterloo
                                        ;    \  __ /    All rights reserved.
                                        ;     \/_//     robfinch<remove>@finitron.ca
                                        ;       ||
                                        ;  
                                        ;
                                        ; This source file is free software: you can redistribute it and/or modify 
                                        ; it under the terms of the GNU Lesser General Public License as published 
                                        ; by the Free Software Foundation, either version 3 of the License, or     
                                        ; (at your option) any later version.                                      
                                        ;                                                                          
                                        ; This source file is distributed in the hope that it will be useful,      
                                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                                        ; GNU General Public License for more details.                             
                                        ;                                                                          
                                        ; You should have received a copy of the GNU General Public License        
                                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                                        ;                                    
                                        ;                                      
                                        ; Networking software components
                                        ; ============================================================================
                                        ;
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Zero out the transmit buffer.
                                        ; Used before building transmit buffer.
                                        ;
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	<none>
                                        ;----------------------------------------------------------------------------
                                        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 3
noc_boot21.a
    121 0000E000                        zeroTxBuf:
    122 0000E000 FE 6E                   		add		sp,sp,#-2
    123 0000E002 E0 D2                   		sw		r2,[sp]
    124 0000E004 00 40 0F 12             		lw		r2,#15
    125 0000E008                        zeroTxBuf1:
    126 0000E008 02 40 20 C0             		sb		r0,txBuf[r2]
    127 0000E00C FF 62                   		sub		r2,r2,#1
    128 0000E00E FC BB                   		bpl		zeroTxBuf1
    129 0000E010 E0 F2                   		lw		r2,[sp]
    130 0000E012 02 6E                   		add		sp,sp,#2
    131 0000E014 F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Transmit on the network.
                                        ; Blocks until the transmit buffer is open.
                                        ;
                                        ; Prerequisites:
                                        ;	The transmit buffer txBuf must have already been loaded.
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	<none>
                                        ;----------------------------------------------------------------------------
                                        
    147 0000E016 FC 6E                  Xmit:	
    148 0000E018 E0 D1                   		sw		r1,[sp]
    149 0000E01A E2 D2                   		sw		r2,2[sp]
                                        		; wait for transmit buffer to empty
    151 0000E01C                        Xmit2:
    152 0000E01C 01 4B 02 E1             		lb		r1,ROUTER+RTR_TXSTAT
    153 0000E020 FD B9                   		bne		Xmit2
    154 0000E022 00 40 0F 12             		lw		r2,#15
    155 0000E026                        Xmit1:
    156 0000E026 02 40 20 E1             		lb		r1,txBuf[r2]
    157 0000E02A 00 4B 20 C1             		sb		r1,ROUTER[r2]
    158 0000E02E FF 62                   		add		r2,r2,#-1
    159 0000E030 FA BB                   		bpl		Xmit1
                                        		; trigger a transmit
    161 0000E032 01 11                   		lw		r1,#1
    162 0000E034 01 4B 02 C2             		sb		r2,ROUTER+RTR_TXSTAT
    163 0000E038 E2 F2                   		lw		r2,2[sp]
    164 0000E03A E0 F1                   		lw		r1,[sp]
    165 0000E03C 04 6E                   		add		sp,sp,#4
    166 0000E03E F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Receive from network.
                                        ; Receive status must have already indicated a message present.
                                        ; Copies recieve buffer from router to rxBuf.
                                        ;
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	<none>
                                        ;----------------------------------------------------------------------------
                                        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 4
noc_boot21.a
    181 0000E040                        Recv:
    182 0000E040 FC 6E                   		add		sp,sp,#-4
    183 0000E042 E0 D1                   		sw		r1,[sp]
    184 0000E044 E2 D2                   		sw		r2,2[sp]
    185 0000E046 00 40 0F 12             		lw		r2,#15
    186 0000E04A 01 4B 00 E1             		lb		r1,ROUTER+RTR_RXSTAT
    187 0000E04E 04 40 60 31             		or		r1,#$40
    188 0000E052 01 4B 00 C1             		sb		r1,ROUTER+RTR_RXSTAT	; pop the rx fifo
    189 0000E056 20 00                   		nop								; wait a couple of clock cycles
    190 0000E058 20 00                   		nop								; before reading
    191 0000E05A                        Recv1:
    192 0000E05A 00 4B 20 E1             		lb		r1,ROUTER[r2]			; copy message to local buffer
    193 0000E05E 03 40 20 C1             		sb		r1,rxBuf[r2]
    194 0000E062 FF 62                   		add		r2,r2,#-1
    195 0000E064 FA BB                   		bpl		Recv1
    196 0000E066 E0 F1                   		lw		r1,[sp]
    197 0000E068 E2 F2                   		lw		r2,2[sp]
    198 0000E06A 04 6E                   		add		sp,sp,#4
    199 0000E06C F0 80                   		ret
                                        
                                        ;****************************************************************;
                                        ;                                                                ;
                                        ;		Tiny BASIC for the Finitron Butterfly                    ;
                                        ;                                                                ;
                                        ; Derived from a 68000 derivative of Palo Alto Tiny BASIC as     ;
                                        ; published in the May 1976 issue of Dr. Dobb's Journal.         ;
                                        ; Adapted to the 68000 by:                                       ;
                                        ;	Gordon brndly						                         ;
                                        ;	12147 - 51 Street					                         ;
                                        ;	Edmonton AB  T5W 3G8					                     ;
                                        ;	Canada							                             ;
                                        ;	(updated mailing address for 1996)			                 ;
                                        ;                                                                ;
                                        ; Adapted to the Butterfly by:                                    ;
                                        ;    Robert Finch                                                ;
                                        ;    Ontario, Canada                                             ;
                                        ;	 rob<remove>@finitron.ca                                     ;  
                                        ;****************************************************************;
                                        ;    Copyright (C) 2005 by Robert Finch. This program may be	 ;
                                        ;    freely distributed for personal use only. All commercial	 ;
                                        ;		       rights are reserved.			                     ;
                                        ;****************************************************************;
                                        ;
                                        ; Register Usage
                                        ; r8 = text pointer (global usage)
                                        ; r3,r4 = inputs parameters to subroutines
                                        ; r2 = return value
                                        ;
                                        ;* Vers. 1.0  1984/7/17	- Original version by Gordon brndly
                                        ;*	1.1  1984/12/9	- Addition of '0x' print term by Marvin Lipford
                                        ;*	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                                        
                                        ;	OPT	FRS,BRS 	forward ref.'s & brnches default to short
                                        
                                        ;XMIT_FULL		equ	0x40		; the transmit buffer is full
                                        ;DATA_PRESENT	equ	0x08		; there is data preset at the serial port bc_uart3
    236 = 01                            DATA_PRESENT	equ	0x01		; there is data preset at the serial port bc_uart3
    237 = 20                            XMIT_NOT_FULL	equ	0x20
                                        
    239 = 00000000FFFFDC40                              TS_TIMER	equ		0xFFFFDC40		; system time slice timer
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 5
noc_boot21.a
    240 = 00000000FFFFDC50                              KBD			equ		0xFFFFDC50
                                        
    242 = 00000000FFFFDCA0                              RAND		equ		0xFFFFDCA0
    243 = 00000000FFFFD800                              VIC			equ		0xFFFFD800
                                        
    245 = 2000                          VIDEORAM	equ		0x00002000
                                        
                                        ; BOOT ROM routines
                                        
    249 = 0000000FFFFFF804                              getSerial	equ		0xFFFFFF804	; get a serial port character
    250 = 0000000FFFFFF808                              peekSerial	equ		0xFFFFFF808	; get a serial port character
    251 = 0000000FFFFFF80C                              putSerial	equ		0xFFFFFF80C	; put a character to serial port
    252 = 0000000FFFFFF82C                              clearScreen	equ		0xFFFFFF82C	; clear the screen
    253 = 0000000FFFFFF840                              getKbdCharWait	equ	0xFFFFFF840
    254 = 0000000FFFFFF844                              getKbdChar		equ	0xFFFFFF844
                                        
    256 = 20                            warmStart   equ     0x20
    257 = 24                            usrJmp      equ     0x24
                                        
    259 = 0D                            CR		equ	0x0D		; ASCII equates
    260 = 0A                            LF		equ	0x0A
    261 = 09                            TAB		equ	0x09
    262 = 03                            CTRLC	equ	0x03
    263 = 08                            CTRLH	equ	0x08
    264 = 13                            CTRLS	equ	0x13
    265 = 18                            CTRLX	equ	0x18
                                        
    267 = 50                            BUFLEN	equ	80	;	length of keyboard input buffer
                                        
                                        	code
                                        ;	org	0xC000	;
                                        ;
                                        ; Standard jump table. You can change these addresses if you are
                                        ; customizing this interpreter for a different environment.
                                        ;
    276 0000E06E 0D AE                  START	jmp	CSTART	;	Cold Start entry point
    277 0000E070 45 AE                  GOWARM	jmp	WSTART	;	Warm Start entry point
    278 0000E072 86 40 01 AE            GOOUT	jmp	OUTC	;	Jump to character-out routine
    279 0000E076 86 40 00 AE            GOIN	jmp	INC		;Jump to character-in routine
    280 0000E07A 89 40 01 AE            GOAUXO	jmp	AUXOUT	;	Jump to auxiliary-out routine
    281 0000E07E 8A 40 0E AE            GOAUXI	jmp	AUXIN	;	Jump to auxiliary-in routine
    282 0000E082 8E 40 04 AE            GOBYE	jmp	BYEBYE	;	Jump to monitor, DOS, etc.
                                        ;
                                        ; Modifiable system constants:
                                        ;
    286 0000E086 00 02                  TXTBGN	dw	0x0200		;beginning of program memory
    287 0000E088 00 1E                  ENDMEM	dw	0x1E00	;	end of available memory
                                        ;
                                        ; The main interpreter starts here:
                                        ;
                                        ; Usage
                                        ; r1 = temp
                                        ; r8 = text buffer pointer
                                        ; r12 = end of text in text buffer
                                        ;
    296 0000E08A                        CSTART
                                        	; First save off the link register and OS sp value
    298 0000E08A FC 6E                   	sub		sp,sp,#4
    299 0000E08C E0 DF                   	sw		lr,[sp]
    300 0000E08E 08 40 04 DE             	sw		sp,OSSP
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 6
noc_boot21.a
    301 0000E092 08 4E 08 FE             	lw		sp,ENDMEM	; initialize stack pointer
    302 0000E096 E0 DF                   	sw      lr,[sp]    ; save off return address
                                        ;	lw		r1,#TXT_WIDTH
                                        ;	sb		r1,txtWidth
                                        ;	lw		r1,#TXT_HEIGHT
                                        ;	sb		r1,txtHeight
    307 0000E098 03 40 02 C0             	sb		r0,cursx	; set screen output
    308 0000E09C 03 40 03 C0             	sb		r0,cursy
    309 0000E0A0 03 40 0C C0             	sb		r0,cursFlash
    310 0000E0A4 03 40 04 D0             	sw		r0,pos
    311 0000E0A8 F2 4B 00 12             	lw		r2,#0xBF20	; black chars, yellow background
    312 0000E0AC 03 40 08 D2             	sw		r2,charToPrint
    313 0000E0B0 BB 48 0B AF             	call	clearScreen
    314 0000E0B4 25 4F 08 11             	lea		r1,msgInit	;	tell who we are
    315 0000E0B8 82 40 0F AF             	call	PRMESGAUX
    316 0000E0BC 25 4F 08 11             	lea		r1,msgInit	;	tell who we are
    317 0000E0C0 81 40 0C AF             	call	PRMESG
    318 0000E0C4 08 4E 06 F1             	lw		r1,TXTBGN	;	init. end-of-program pointer
    319 0000E0C8 09 40 06 D1             	sw		r1,TXTUNF
    320 0000E0CC 08 4E 08 F1             	lw		r1,ENDMEM	;	get address of end of memory
    321 0000E0D0 80 4F 10 11             	sub		r1,r1,#2048	; 	reserve 2K for the stack
    322 0000E0D4 0A 40 00 D1             	sw		r1,STKBOT
    323 0000E0D8 E0 4F 10 11             	sub     r1,r1,#512 ;   128 vars
    324 0000E0DC 09 40 08 D1             	sw      r1,VARBGN
    325 0000E0E0 15 40 0F AF             	call    clearVars   ; clear the variable area
    326 0000E0E4 09 40 08 F1             	lw      r1,VARBGN   ; calculate number of bytes free
    327 0000E0E8 09 40 06 F3             	lw		r3,TXTUNF
    328 0000E0EC 32 21                   	sub     r1,r3
    329 0000E0EE 00 12                   	lw		r2,#0
    330 0000E0F0 6F 40 0B AF             	call	PRTNUM
    331 0000E0F4 30 4F 06 11             	lea		r1,msgBytesFree
    332 0000E0F8 80 40 00 AF             	call	PRMESG
    333 0000E0FC                        WSTART
    334 0000E0FC 08 40 0C D0             	sw		r0,LOPVAR   ; initialize internal variables
    335 0000E100 08 40 08 D0             	sw		r0,STKGOS
    336 0000E104 08 40 06 D0             	sw		r0,CURRNT	;	current line number pointer = 0
    337 0000E108 08 4E 08 FE             	lw		sp,ENDMEM	;	init S.P. again, just in case
    338 0000E10C 31 4F 04 11             	lea		r1,msgReady	;	display "Ready"
    339 0000E110 7F 40 04 AF             	call	PRMESG
    340 0000E114                        ST3
    341 0000E114 03 40 0E 11             	lw		r1,#'>'		; Prompt with a '>' and
    342 0000E118 5E 40 0B AF             	call	GETLN		; read a line.
    343 0000E11C 7B 40 04 AF             	call	TOUPBUF 	; convert to upper case
    344 0000E120 80 1C                   	lw		r12,r8		; save pointer to end of line
    345 0000E122 0A 40 0E 18             	lea		r8,BUFFER	; point to the beginning of line
    346 0000E126 78 40 00 AF             	call	TSTNUM		; is there a number there?
    347 0000E12A 79 40 0F AF             	call	IGNBLK		; skip trailing blanks
    348 0000E12E 16 21                   	or      r1,r1       ; does line no. exist? (or nonzero?)
    349 0000E130 C1 A8                   	beq		DIRECT		; if not, it's a direct statement
    350 0000E132 00 40 11 10             	cmp		r1,#0xFFFF	; see if line no. is <= 16 bits
    351 0000E136 04 A6                   	bleu	ST2
    352 0000E138 33 4F 02 11             	lea		r1,msgLineRange	; if not, we've overflowed
    353 0000E13C 5B 40 0F AE             	br		ERROR
    354 0000E140                        ST2
                                            ; ugliness - store a character at potentially an
                                            ; odd address (unaligned).
    357 0000E140 10 12                   	lw		r2,r1       ; r2 = line number
    358 0000E142 8E C2                   	sb		r2,-2[r8]
    359 0000E144 A1 32                   	shr		r2,#1
    360 0000E146 A1 32                   	shr		r2,#1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 7
noc_boot21.a
    361 0000E148 A1 32                   	shr		r2,#1
    362 0000E14A A1 32                   	shr		r2,#1
    363 0000E14C A1 32                   	shr		r2,#1
    364 0000E14E A1 32                   	shr		r2,#1
    365 0000E150 A1 32                   	shr		r2,#1
    366 0000E152 A1 32                   	shr		r2,#1
    367 0000E154 8F C2                   	sb		r2,-1[r8]	; store the binary line no.
    368 0000E156 FE 68                   	sub		r8,r8,#2
    369 0000E158 61 40 0F AF             	call	FNDLN		; find this line in save area
    370 0000E15C E0 31                   	tsr		r1,sr
    371 0000E15E 90 1D                   	lw		r13,r9		; save possible line pointer
    372 0000E160 F0 31                   	trs		r1,sr
    373 0000E162 11 A9                   	bne		ST4			; if not found, insert
                                        	; here we found the line, so we're replacing the line
                                        	; in the text area
                                        	; first step - delete the line
    377 0000E164 00 11                   	lw		r1,#0
    378 0000E166 63 40 05 AF             	call	FNDNXT		; find the next line (into r9)
    379 0000E16A 0A A7                   	bgtu	ST6			; no more lines
    380 0000E16C 90 11                   	lw		r1,r9		; r1 = pointer to next line
    381 0000E16E D0 12                   	lw		r2,r13		; pointer to line to be deleted
    382 0000E170 09 40 06 F3             	lw		r3,TXTUNF	; points to top of save area
    383 0000E174 63 40 09 AF             	call	MVUP		; move up to delete
    384 0000E178 09 40 06 D2             	sw		r2,TXTUNF	; update the end pointer
                                        	; we moved the lines of text after the line being
                                        	; deleted down, so the pointer to the next line
                                        	; needs to be reset
    388 0000E17C D0 19                   	lw		r9,r13
    389 0000E17E 03 AE                   	br		ST4
                                        	; here there were no more lines, so just move the
                                        	; end of text pointer down
    392 0000E180                        ST6
    393 0000E180 09 40 06 DD             	sw		r13,TXTUNF
    394 0000E184 D0 19                   	lw		r9,r13
    395 0000E186                        ST4
                                        	; here we're inserting because the line wasn't found
                                        	; or it was deleted	from the text area
    398 0000E186 C0 11                   	lw		r1,r12		; calculate the length of new line
    399 0000E188 82 21                   	sub		r1,r8
    400 0000E18A 1D 10                   	cmp		r1,#3		; is it just a line no. & CR?
    401 0000E18C C3 B2                   	ble		ST3			; if so, it was just a delete
                                        
    403 0000E18E 09 40 06 FB             	lw		r11,TXTUNF	; compute new end of text
    404 0000E192 B0 1A                   	lw		r10,r11		; r10 = old TXTUNF
    405 0000E194 10 2B                   	add		r11,r1		; r11 = new top of TXTUNF (r1=line length)
                                        
    407 0000E196 09 40 08 F1             	lw		r1,VARBGN	; see if there's enough room
    408 0000E19A 1D 2B                   	cmp		r11,r1
    409 0000E19C 04 A4                   	bltu	ST5
    410 0000E19E 40 4F 0D 11             	lea		r1,msgTooBig	; if not, say so
    411 0000E1A2 58 40 0C AE             	jmp		ERROR
                                        
                                        	; open a space in the text area
    414 0000E1A6                        ST5
    415 0000E1A6 09 40 06 DB             	sw		r11,TXTUNF	; if so, store new end position
    416 0000E1AA A0 11                   	lw		r1,r10		; points to old end of text
    417 0000E1AC B0 12                   	lw		r2,r11		; points to new end of text
    418 0000E1AE 90 13                   	lw		r3,r9       ; points to start of line after insert line
    419 0000E1B0 62 40 02 AF             	call	MVDOWN		; move things out of the way
                                        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 8
noc_boot21.a
                                        	; copy line into text space
    422 0000E1B4 80 11                   	lw		r1,r8		; set up to do the insertion; move from buffer
    423 0000E1B6 D0 12                   	lw		r2,r13		; to vacated space
    424 0000E1B8 C0 13                   	lw		r3,r12		; until end of buffer
    425 0000E1BA 61 40 06 AF             	call	MVUP		; do it
    426 0000E1BE AA BE                   	br		ST3			; go back and get another line
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** Tables *** DIRECT *** EXEC ***
                                        ;
                                        ; This section of the code tests a string against a table. When
                                        ; a match is found, control is transferred to the section of
                                        ; code according to the table.
                                        ;
                                        ; At 'EXEC', r8 should point to the string, r9 should point to
                                        ; the character table, and r10 should point to the execution
                                        ; table. At 'DIRECT', r8 should point to the string, r9 and
                                        ; r10 will be set up to point to TAB1 and TAB1_1, which are
                                        ; the tables of all direct and statement commands.
                                        ;
                                        ; A '.' in the string will terminate the test and the partial
                                        ; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                                        ; 'PRIN.', or 'PRINT' will all match 'PRINT'.
                                        ;
                                        ; There are two tables: the character table and the execution
                                        ; table. The character table consists of any number of text items.
                                        ; Each item is a string of characters with the last character's
                                        ; high bit set to one. The execution table holds a 32-bit
                                        ; execution addresses that correspond to each entry in the
                                        ; character table.
                                        ;
                                        ; The end of the character table is a 0 byte which corresponds
                                        ; to the default routine in the execution table, which is
                                        ; executed if none of the other table items are matched.
                                        ;
                                        ; Character-matching tables:
    459 0000E1C0                        TAB1
    460 0000E1C0 4C 49 53 D4             	db	"LIS",('T'+0x80)        ; Direct commands
    461 0000E1C4 4C 4F 41 C4             	db	"LOA",('D'+0x80)
    462 0000E1C8 4E 45 D7                	db	"NE",('W'+0x80)
    463 0000E1CB 52 55 CE                	db	"RU",('N'+0x80)
    464 0000E1CE 53 41 56 C5             	db	"SAV",('E'+0x80)
    465 0000E1D2                        TAB2
    466 0000E1D2 4E 45 58 D4             	db	"NEX",('T'+0x80)         ; Direct / statement
    467 0000E1D6 4C 45 D4                	db	"LE",('T'+0x80)
    468 0000E1D9 49 C6                   	db	"I",('F'+0x80)
    469 0000E1DB 47 4F 54 CF             	db	"GOT",('O'+0x80)
    470 0000E1DF 47 4F 53 55 C2          	db	"GOSU",('B'+0x80)
    471 0000E1E4 52 45 54 55 52 CE       	db	"RETUR",('N'+0x80)
    472 0000E1EA 52 45 CD                	db	"RE",('M'+0x80)
    473 0000E1ED 46 4F D2                	db	"FO",('R'+0x80)
    474 0000E1F0 49 4E 50 55 D4          	db	"INPU",('T'+0x80)
    475 0000E1F5 50 52 49 4E D4          	db	"PRIN",('T'+0x80)
    476 0000E1FA 50 4F 4B 45 D7          	db	"POKE",('W'+0x80)
    477 0000E1FF 50 4F 4B C5             	db	"POK",('E'+0x80)
    478 0000E203 53 54 4F D0             	db	"STO",('P'+0x80)
    479 0000E207 42 59 C5                	db	"BY",('E'+0x80)
    480 0000E20A 53 59 D3                	db	"SY",('S'+0x80)
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 9
noc_boot21.a
    481 0000E20D 43 4C D3                	db	"CL",('S'+0x80)
    482 0000E210 43 4C D2                    db  "CL",('R'+0x80)
    483 0000E213 52 44 43 C6                 db	"RDC",('F'+0x80)
    484 0000E217 00                      	db	0
    485 0000E218                        TAB4
    486 0000E218 4E 4F 44 45 4E 55 CD    	db	"NODENU",('M'+0x80)
                                      
    487 0000E21F 50 45 45 4B C3          	db	"PEEK",('C'+0x80)        ;Functions
    488 0000E224 50 45 45 4B D7          	db	"PEEK",('W'+0x80)        ;Functions
    489 0000E229 50 45 45 CB             	db	"PEE",('K'+0x80)         ;Functions
    490 0000E22D 52 4E C4                	db	"RN",('D'+0x80)
    491 0000E230 41 42 D3                	db	"AB",('S'+0x80)
    492 0000E233 53 49 5A C5             	db	"SIZ",('E'+0x80)
    493 0000E237 55 53 D2                	db  "US",('R'+0x80)
    494 0000E23A 00                      	db	0
    495 0000E23B                        TAB5
    496 0000E23B 54 CF                   	db	"T",('O'+0x80)           ;"TO" in "FOR"
    497 0000E23D 00                      	db	0
    498 0000E23E                        TAB6
    499 0000E23E 53 54 45 D0             	db	"STE",('P'+0x80)         ;"STEP" in "FOR"
    500 0000E242 00                      	db	0
    501 0000E243                        TAB8
    502 0000E243 3E BD                   	db	'>',('='+0x80)           ;Relational operators
    503 0000E245 3C BE                   	db	'<',('>'+0x80)
    504 0000E247 BE                      	db	('>'+0x80)
    505 0000E248 BD                      	db	('='+0x80)
    506 0000E249 3C BD                   	db	'<',('='+0x80)
    507 0000E24B BC                      	db	('<'+0x80)
    508 0000E24C 00                      	db	0
    509 0000E24D                        TAB9
    510 0000E24D 41 4E C4                    db  "AN",('D'+0x80)
    511 0000E250 00                          db  0
    512 0000E251                        TAB10
    513 0000E251 4F D2                       db  "O",('R'+0x80)
    514 0000E253 00                          db  0
                                        
                                        	.align	4
                                        
                                        ;* Execution address tables:
    519 0000E254                        TAB1_1
    520 0000E254 C0 E3                   	dw	LISTX			;Direct commands
    521 0000E256 26 E6                   	dw	LOAD
    522 0000E258 0A E3                   	dw	NEW
    523 0000E25A 20 E3                   	dw	RUN
    524 0000E25C BA E6                   	dw	SAVE
    525 0000E25E                        TAB2_1
    526 0000E25E 18 E5                   	dw	NEXT		;	Direct / statement
    527 0000E260 18 E6                   	dw	LET
    528 0000E262 72 E5                   	dw	IF
    529 0000E264 84 E3                   	dw	GOTO
    530 0000E266 5A E4                   	dw	GOSUB
    531 0000E268 8A E4                   	dw	RETURN
    532 0000E26A 7C E5                   	dw	IF2			; REM
    533 0000E26C B4 E4                   	dw	FOR
    534 0000E26E 9A E5                   	dw	INPUT
    535 0000E270 F6 E3                   	dw	PRINT
    536 0000E272 E6 E7                   	dw	POKEW
    537 0000E274 C6 E7                   	dw	POKE
    538 0000E276 18 E3                   	dw	STOP
    539 0000E278 82 E0                   	dw	GOBYE
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 10
noc_boot21.a
    540 0000E27A FE E7                   	dw	SYSX
    541 0000E27C 46 F2                   	dw	_cls
    542 0000E27E 9E E3                   	dw  _clr
    543 0000E280 80 E2                   	dw	_rdcf
    544 0000E282 10 E6                   	dw	DEFLT
    545 0000E284                        TAB4_1
    546 0000E284 3A EC                   	dw	NODENUM
    547 0000E286 7C EB                   	dw  PEEKC
    548 0000E288 8A EB                   	dw  PEEKW
    549 0000E28A 70 EB                   	dw	PEEK			;Functions
    550 0000E28C AA EB                   	dw	RND
    551 0000E28E 04 EC                   	dw	ABS
    552 0000E290 2A EC                   	dw	SIZEX
    553 0000E292 96 EB                   	dw  USRX
    554 0000E294 A6 E9                   	dw	XP40
    555 0000E296                        TAB5_1
    556 0000E296 CC E4                   	dw	FR1			;"TO" in "FOR"
    557 0000E298 BA EC                   	dw	QWHAT
    558 0000E29A                        TAB6_1
    559 0000E29A E0 E4                   	dw	FR2			;"STEP" in "FOR"
    560 0000E29C E6 E4                   	dw	FR3
    561 0000E29E                        TAB8_1
    562 0000E29E C8 E8                   	dw	XP11	;>=		Relational operators
    563 0000E2A0 D2 E8                   	dw	XP12	;<>
    564 0000E2A2 DC E8                   	dw	XP13	;>
    565 0000E2A4 F0 E8                   	dw	XP15	;=
    566 0000E2A6 E6 E8                   	dw	XP14	;<=
    567 0000E2A8 FA E8                   	dw	XP16	;<
    568 0000E2AA 14 E9                   	dw	XP17
    569 0000E2AC                        TAB9_1
    570 0000E2AC 54 E8                       dw  XP_AND
    571 0000E2AE 5C E8                       dw  XP_ANDX
    572 0000E2B0                        TAB10_1
    573 0000E2B0 30 E8                       dw  XP_OR
    574 0000E2B2 38 E8                       dw  XP_ORX
                                        
                                        ;*
                                        ; r3 = match flag (trashed)
                                        ; r9 = text table
                                        ; r10 = exec table
                                        ; r11 = trashed
    581 0000E2B4                        DIRECT
    582 0000E2B4 1C 4E 00 19             	lea		r9,TAB1
    583 0000E2B8 25 4E 04 1A             	lea		r10,TAB1_1
    584 0000E2BC                        EXEC
    585 0000E2BC F0 1B                   	lw		r11,lr		; save link reg
    586 0000E2BE 6D 40 05 AF             	call	IGNBLK		; ignore leading blanks
    587 0000E2C2 B0 1F                   	lw		lr,r11		; restore link reg
    588 0000E2C4 80 1B                   	lw		r11,r8		; save the pointer
    589 0000E2C6 00 13                   	lw		r3,#0		; clear match flag
    590 0000E2C8                        EXLP
    591 0000E2C8 80 E1                   	lb		r1,[r8]		; get the program character
    592 0000E2CA 01 68                   	add		r8,r8,#1
    593 0000E2CC 90 E2                   	lb		r2,[r9]		; get the table character
    594 0000E2CE 02 A9                   	bne		EXNGO		; If end of table,
    595 0000E2D0 B0 18                   	lw		r8,r11		;	restore the text pointer and...
    596 0000E2D2 12 AE                   	br		EXGO		;   execute the default.
    597 0000E2D4                        EXNGO
    598 0000E2D4 3D 21                   	cmp		r1,r3		; Else check for period...
    599 0000E2D6 10 A8                   	beq		EXGO		; if so, execute
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 11
noc_boot21.a
    600 0000E2D8 07 40 5F 32             	and		r2,#0x7f	; ignore the table's high bit
    601 0000E2DC 1D 22                   	cmp		r2,r1		;		is there a match?
    602 0000E2DE 07 A8                   	beq		EXMAT
    603 0000E2E0 04 6A                   	add		r10,r10,#4	;if not, try the next entry
    604 0000E2E2 B0 18                   	lw		r8,r11		; reset the program pointer
    605 0000E2E4 00 13                   	lw		r3,#0		; sorry, no match
    606 0000E2E6                        EX1
    607 0000E2E6 01 69                   	add		r9,r9,#1
    608 0000E2E8 9F E1                   	lb		r1,-1[r9]	; get to the end of the entry
    609 0000E2EA FD BB                   	bpl		EX1
    610 0000E2EC ED BE                   	br		EXLP		; back for more matching
    611 0000E2EE                        EXMAT
    612 0000E2EE 02 40 0E 13             	lw		r3,#'.'		; we've got a match so far
    613 0000E2F2 01 69                   	add		r9,r9,#1
    614 0000E2F4 9F E1                   	lb		r1,-1[r9]	; end of table entry?
    615 0000E2F6 E8 BB                   	bpl		EXLP		; if not, go back for more
    616 0000E2F8                        EXGO
    617 0000E2F8 01 4B 00 E1             	lb		r1,ROUTER+RTR_RXSTAT
    618 0000E2FC 04 A8                   	beq		EXGO1
    619 0000E2FE E9 4F 0F AF             	call	Recv
    620 0000E302 8E 40 0E AF             	call	RecvDispatch
    621 0000E306                        EXGO1
    622 0000E306 A0 FB                   	lw		r11,[r10]	; execute the appropriate routine
    623 0000E308 B0 80                   	jmp		[r11]
                                        
                                        
                                        ;    lb      r1,[r8]     ; get token from text space
                                        ;    bpl
                                        ;    and     r1,#0x7f
                                        ;    shl     r1,#2       ; * 4 - word offset
                                        ;    add     r1,r1,#TAB1_1
                                        ;    lw      r1,[r1]
                                        ;    jmp     [r1]
                                        
                                            
                                        ;
                                        ; What follows is the code to execute direct and statement
                                        ; commands. Control is transferred to these points via the command
                                        ; table lookup code of 'DIRECT' and 'EXEC' in the last section.
                                        ; After the command is executed, control is transferred to other
                                        ; sections as follows:
                                        ;
                                        ; For 'LISTX', 'NEW', and 'STOP': go back to the warm start point.
                                        ; For 'RUN': go execute the first stored line if any; else go
                                        ; back to the warm start point.
                                        ; For 'GOTO' and 'GOSUB': go execute the target line.
                                        ; For 'RETURN' and 'NEXT'; go back to saved return line.
                                        ; For all others: if 'CURRNT' is 0, go to warm start; else go
                                        ; execute next command. (This is done in 'FINISH'.)
                                        ;
                                        ;******************************************************************
                                        ;
                                        ; *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                                        ;
                                        ; 'NEW<CR>' sets TXTUNF to point to TXTBGN
                                        ;
                                        ; 'STOP<CR>' goes back to WSTART
                                        ;
                                        ; 'RUN<CR>' finds the first stored line, stores its address
                                        ; in CURRNT, and starts executing it. Note that only those
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 12
noc_boot21.a
                                        ; commands in TAB2 are legal for a stored program.
                                        ;
                                        ; RUN ON <node number> sends a run command to the specified node
                                        ;
                                        ; There are 3 more entries in 'RUN':
                                        ; 'RUNNXL' finds next line, stores it's address and executes it.
                                        ; 'RUNTSL' stores the address of this line and executes it.
                                        ; 'RUNSML' continues the execution on same line.
                                        ;
                                        ; 'GOTO expr<CR>' evaluates the expression, finds the target
                                        ; line, and jumps to 'RUNTSL' to do it.
                                        ;
    672 0000E30A                        NEW
    673 0000E30A 4C 40 02 AF             	call	ENDCHK
    674 0000E30E 08 4E 06 F1             	lw		r1,TXTBGN
    675 0000E312 09 40 06 D1             	sw		r1,TXTUNF	;	set the end pointer
    676 0000E316 45 AF                   	call    clearVars
                                        
    678 0000E318                        STOP
    679 0000E318 4B 40 0B AF             	call	ENDCHK
    680 0000E31C EE 4F 0E AE             	br		WSTART		; WSTART will reset the stack
                                        
    682 0000E320                        RUN
    683 0000E320 6A 40 04 AF             	call	IGNBLK
    684 0000E324 80 E1                   	lb		r1,[r8]
    685 0000E326 FB 4F 11 10             	cmp		r1,#'O'
    686 0000E32A 11 A9                   	bne		RUN1
    687 0000E32C 81 E1                   	lb		r1,1[r8]
    688 0000E32E FB 4F 12 10             	cmp		r1,#'N'
    689 0000E332 0D A9                   	bne		RUN1
    690 0000E334 02 68                   	add		r8,r8,#2
    691 0000E336 27 40 01 AF             	call	OREXPR
    692 0000E33A 02 40 0F C1             	sb		r1,txBuf+MSG_DST
                                        	lb		r1,#$11
    694 0000E33E 02 40 0E C1             	sb		r1,txBuf+MSG_SRC
                                        	lb		r1,#MT_RUN_BASIC_PROG
    696 0000E342 02 40 07 C1             	sb		r1,txBuf+MSG_TYPE
    697 0000E346 E6 4F 06 AF             	call	Xmit
    698 0000E34A ED 4F 07 AE             	br		WSTART
    699 0000E34E                        RUN1
    700 0000E34E 4A 40 00 AF             	call	ENDCHK
    701 0000E352 08 4E 06 F8             	lw		r8,TXTBGN	;	set pointer to beginning
    702 0000E356 08 40 06 D8             	sw		r8,CURRNT
    703 0000E35A 23 AF                   	call    clearVars
                                        
    705 0000E35C                        RUNNXL					; RUN <next line>
    706 0000E35C 08 40 06 F1             	lw		r1,CURRNT	; executing a program?
    707 0000E360 EC 4F 0C A8             	beq		WSTART		; if not, we've finished a direct stat.
    708 0000E364 00 11                   	lw		r1,#0	    ; else find the next line number
    709 0000E366 80 19                   	lw		r9,r8
    710 0000E368 51 40 0F AF             	call	FNDLNP		; search for the next line
    711 0000E36C EC 4F 06 A7             	bgtu	WSTART		; if we've fallen off the end, stop
                                        
    713 0000E370                        RUNTSL					; RUN <this line>
    714 0000E370 08 40 06 D9             	sw		r9,CURRNT	; set CURRNT to point to the line no.
    715 0000E374 92 18                   	lea		r8,2[r9]	; set the text pointer to
                                        
    717 0000E376                        RUNSML                  ; RUN <same line>
    718 0000E376 6A 40 0F AF             	call	CHKIO		; see if a control-C was pressed
    719 0000E37A 1D 4E 02 19             	lea		r9,TAB2		; find command in TAB2
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 13
noc_boot21.a
    720 0000E37E 25 4E 0E 1A             	lea		r10,TAB2_1
    721 0000E382 9C BE                   	br		EXEC		; and execute it
                                        
    723 0000E384                        GOTO
    724 0000E384 24 40 0A AF             	call	OREXPR		;evaluate the following expression
    725 0000E388 10 15                   	lw      r5,r1
    726 0000E38A 48 40 02 AF             	call	ENDCHK		;must find end of line
    727 0000E38E 50 11                   	lw      r1,r5
    728 0000E390 50 40 03 AF             	call	FNDLN		; find the target line
    729 0000E394 ED B8                   	beq		RUNTSL		; go do it
    730 0000E396 3D 4F 09 11             	lea		r1,msgBadGotoGosub
    731 0000E39A 49 40 00 AE             	br		ERROR		; no such line no.
                                        
                                        
    734 0000E39E                        _clr
    735 0000E39E 01 AF                       call    clearVars
    736 0000E3A0 58 AE                       br      FINISH
                                        
                                        ; Clear the variable area of memory
    739 0000E3A2                        clearVars
    740 0000E3A2 FC 6E                       sub     sp,sp,#4
    741 0000E3A4 E0 DF                       sw      lr,[sp]
    742 0000E3A6 E2 D6                       sw      r6,2[sp]
    743 0000E3A8 80 40 00 16                 lw      r6,#2048    ; number of words to clear
    744 0000E3AC 09 40 08 F1                 lw      r1,VARBGN
    745 0000E3B0                        cv1
    746 0000E3B0 10 D0                       sw      r0,[r1]
    747 0000E3B2 04 61                       add     r1,r1,#4
    748 0000E3B4 FF 66                       sub		r6,r6,#1
    749 0000E3B6 FC B9                       bne     cv1
    750 0000E3B8 E0 FF                       lw      lr,[sp]
    751 0000E3BA E2 F6                       lw      r6,2[sp]
    752 0000E3BC 04 6E                       add     sp,sp,#4
    753 0000E3BE F0 80                       ret    
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; LIST
                                        ;
                                        ; LISTX has two forms:
                                        ; 'LIST<CR>' lists all saved lines
                                        ; 'LIST #<CR>' starts listing at the line #
                                        ; Control-S pauses the listing, control-C stops it.
                                        ;
                                        
    766 0000E3C0                        LISTX
    767 0000E3C0 63 40 03 AF             	call	TSTNUM		; see if there's a line no.
    768 0000E3C4 10 15                   	lw      r5,r1
    769 0000E3C6 46 40 04 AF             	call	ENDCHK		; if not, we get a zero
    770 0000E3CA 50 11                   	lw      r1,r5
    771 0000E3CC 4E 40 05 AF             	call	FNDLN		; find this or next line
    772 0000E3D0                        LS1
    773 0000E3D0 E9 4F 04 A7             	bgtu	WSTART		; warm start if we passed the end
                                        
    775 0000E3D4 90 11                   	lw		r1,r9
    776 0000E3D6 5F 40 08 AF             	call	PRTLN		; print the line
    777 0000E3DA 10 19                   	lw		r9,r1		; set pointer for next
    778 0000E3DC 67 40 0C AF             	call	CHKIO		; check for listing halt request
    779 0000E3E0 06 A8                   	beq		LS3
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 14
noc_boot21.a
    780 0000E3E2 FE 4F 1D 10             	cmp		r1,#CTRLS	; pause the listing?
    781 0000E3E6 03 A9                   	bne		LS3
    782 0000E3E8                        LS2
    783 0000E3E8 67 40 06 AF             	call	CHKIO		; if so, wait for another keypress
    784 0000E3EC FD B8                   	beq		LS2
    785 0000E3EE                        LS3
    786 0000E3EE 00 11                   	lw		r1,#0
    787 0000E3F0 4D 40 0B AF             	call	FNDLNP		; find the next line
    788 0000E3F4 ED BE                   	br		LS1
                                        
                                        
                                        ;******************************************************************
                                        ; PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                                        ; where '....' is a list of expressions, formats, back-arrows,
                                        ; and strings.	These items a separated by commas.
                                        ;
                                        ; A format is a pound sign followed by a number.  It controls
                                        ; the number of spaces the value of an expression is going to
                                        ; be printed in.  It stays effective for the rest of the print
                                        ; command unless changed by another format.  If no format is
                                        ; specified, 11 positions will be used.
                                        ;
                                        ; A string is quoted in a pair of single- or double-quotes.
                                        ;
                                        ; An underline (back-arrow) means generate a <CR> without a <LF>
                                        ;
                                        ; A <CR LF> is generated after the entire list has been printed
                                        ; or if the list is empty.  If the list ends with a semicolon,
                                        ; however, no <CR LF> is generated.
                                        ;
                                        
    811 0000E3F6                        PRINT
    812 0000E3F6 0B 15                   	lw		r5,#11		; D4 = number of print spaces
    813 0000E3F8 60 40 05 AF             	call	TSTC		; if null list and ":"
    814 0000E3FC 3A 08                   	db	':',PR2-*+1
    815 0000E3FE 67 40 0B AF             	call	CRLF		; give CR-LF and continue
    816 0000E402 B9 BE                   	br		RUNSML		;		execution on the same line
    817 0000E404                        PR2
    818 0000E404 5F 40 0F AF             	call	TSTC		;if null list and <CR>
    819 0000E408 0D 08                   	db	CR,PR0-*+1
    820 0000E40A 67 40 05 AF             	call	CRLF		;also give CR-LF and
    821 0000E40E A6 BE                   	br		RUNNXL		;execute the next line
    822 0000E410                        PR0
    823 0000E410 5F 40 09 AF             	call	TSTC		;else is it a format?
    824 0000E414 23 0A                   	db	'#',PR1-*+1
    825 0000E416 20 40 01 AF             	call	OREXPR		; yes, evaluate expression
    826 0000E41A 10 15                   	lw		r5,r1		; and save it as print width
    827 0000E41C 0B AE                   	br		PR3		; look for more to print
    828 0000E41E                        PR1
    829 0000E41E 5F 40 02 AF             	call	TSTC	;	is character expression? (MRL)
    830 0000E422 24 0C                   	db	'$',PR4-*+1
    831 0000E424 1F 40 0A AF             	call	OREXPR	;	yep. Evaluate expression (MRL)
    832 0000E428 E2 4F 03 AF             	call	GOOUT	;	print low byte (MRL)
    833 0000E42C 03 AE                   	br		PR3		;look for more. (MRL)
    834 0000E42E                        PR4
    835 0000E42E 53 40 00 AF             	call	QTSTG	;	is it a string?
                                        	; the following branch must occupy only two bytes!
    837 0000E432 09 AE                   	br		PR8		;	if not, must be an expression
    838 0000E434                        PR3
    839 0000E434 5E 40 07 AF             	call	TSTC	;	if ",", go find next
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 15
noc_boot21.a
    840 0000E438 2C 08                   	db	',',PR6-*+1
    841 0000E43A 41 40 08 AF             	call	FIN		;in the list.
    842 0000E43E E8 BE                   	br		PR0
    843 0000E440                        PR6
    844 0000E440 65 40 0A AF             	call	CRLF		;list ends here
    845 0000E444 06 AE                   	br		FINISH
    846 0000E446                        PR8
    847 0000E446 1E 40 09 AF             	call	OREXPR		; evaluate the expression
    848 0000E44A 50 12                   	lw		r2,r5		; set the width
    849 0000E44C 54 40 0D AF             	call	PRTNUM		; print its value
    850 0000E450 F1 BE                   	br		PR3			; more to print?
                                        
    852 0000E452                        FINISH
    853 0000E452 40 40 0C AF             	call	FIN		; Check end of command
    854 0000E456 43 40 00 AE             	jmp		QWHAT	; print "What?" if wrong
                                        
                                        
                                        ;*******************************************************************
                                        ;
                                        ; *** GOSUB *** & RETURN ***
                                        ;
                                        ; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                                        ; except that the current text pointer, stack pointer, etc. are
                                        ; saved so that execution can be continued after the subroutine
                                        ; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                                        ; recursive), the save area must be stacked.  The stack pointer
                                        ; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                                        ; If we are in the main routine, 'STKGOS' is zero (this was done
                                        ; in the initialization section of the interpreter), but we still
                                        ; save it as a flag for no further 'RETURN's.
                                        ;
    871 0000E45A                        GOSUB
    872 0000E45A 4E 40 04 AF             	call	PUSHA		; save the current 'FOR' parameters
    873 0000E45E 1D 40 0D AF             	call	OREXPR		; get line number
    874 0000E462 49 40 0A AF             	call	FNDLN		; find the target line
    875 0000E466 04 A8                   	beq		gosub1
    876 0000E468 3D 4F 09 11             	lea		r1,msgBadGotoGosub
    877 0000E46C 42 40 07 AE             	br		ERROR		; if not there, say "How?"
    878 0000E470                        gosub1
    879 0000E470 FA 6E                   	sub		sp,sp,#6
    880 0000E472 E0 D8                   	sw		r8,[sp]		; save text pointer
    881 0000E474 08 40 06 F1             	lw		r1,CURRNT
    882 0000E478 E2 D1                   	sw		r1,2[sp]	; found it, save old 'CURRNT'...
    883 0000E47A 08 40 08 F1             	lw		r1,STKGOS
    884 0000E47E E4 D1                   	sw		r1,4[sp]	; and 'STKGOS'
    885 0000E480 08 40 0C D0             	sw		r0,LOPVAR	; load new values
    886 0000E484 08 40 08 DE             	sw		sp,STKGOS
    887 0000E488 73 BE                   	br		RUNTSL
                                        
                                        
                                        ; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                                        ; returns the execution to the command after the most recent
                                        ; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                                        ; a 'GOSUB' and is thus an error.
                                        ;
    895 0000E48A                        RETURN
    896 0000E48A 40 40 02 AF             	call	ENDCHK		; there should be just a <CR>
    897 0000E48E 08 40 08 F1             	lw		r1,STKGOS	; get old stack pointer
    898 0000E492 04 A9                   	bne		return1
    899 0000E494 3F 4F 06 11             	lea		r1,msgRetWoGosub
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 16
noc_boot21.a
    900 0000E498 41 40 01 AE             	br		ERROR		; if zero, it doesn't exist
    901 0000E49C                        return1
    902 0000E49C 10 1E                   	lw		sp,r1		; else restore it
    903 0000E49E E4 F1                   	lw		r1,4[sp]
    904 0000E4A0 08 40 08 D1             	sw		r1,STKGOS	; and the old 'STKGOS'
    905 0000E4A4 E2 F1                   	lw		r1,2[sp]
    906 0000E4A6 08 40 06 D1             	sw		r1,CURRNT	; and the old 'CURRNT'
    907 0000E4AA E0 F8                   	lw		r8,[sp]		; and the old text pointer
    908 0000E4AC 06 6E                   	add		sp,sp,#6
    909 0000E4AE 4A 40 06 AF             	call	POPA		;and the old 'FOR' parameters
    910 0000E4B2 CF BE                   	br		FINISH		;and we are back home
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** FOR *** & NEXT ***
                                        ;
                                        ; 'FOR' has two forms:
                                        ; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                                        ; The second form means the same thing as the first form with a
                                        ; STEP of positive 1.  The interpreter will find the variable 'var'
                                        ; and set its value to the current value of 'exp1'.  It also
                                        ; evaluates 'exp2' and 'exp1' and saves all these together with
                                        ; the text pointer, etc. in the 'FOR' save area, which consisits of
                                        ; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                                        ; already something in the save area (indicated by a non-zero
                                        ; 'LOPVAR'), then the old save area is saved on the stack before
                                        ; the new values are stored.  The interpreter will then dig in the
                                        ; stack and find out if this same variable was used in another
                                        ; currently active 'FOR' loop.  If that is the case, then the old
                                        ; 'FOR' loop is deactivated. (i.e. purged from the stack)
                                        ;
    932 0000E4B4                        FOR
    933 0000E4B4 4B 40 07 AF             	call	PUSHA		; save the old 'FOR' save area
    934 0000E4B8 3C 40 03 AF             	call	SETVAL		; set the control variable
    935 0000E4BC 08 40 0C D1             	sw		r1,LOPVAR	; save its address
    936 0000E4C0 23 4E 0B 19             	lea		r9,TAB5		; use 'EXEC' to test for 'TO'
    937 0000E4C4 29 4E 06 1A             	lea		r10,TAB5_1
    938 0000E4C8 EF 4F 08 AE             	jmp		EXEC
    939 0000E4CC                        FR1
    940 0000E4CC 1A 40 06 AF             	call	OREXPR		; evaluate the limit
    941 0000E4D0 09 40 00 D1             	sw		r1,LOPLMT	; save that
    942 0000E4D4 23 4E 0E 19             	lea		r9,TAB6		; use 'EXEC' to look for the
    943 0000E4D8 29 4E 0A 1A             	lea		r10,TAB6_1	; word 'STEP'
    944 0000E4DC EE 4F 0E AE             	jmp		EXEC
    945 0000E4E0                        FR2
    946 0000E4E0 19 40 0C AF             	call	OREXPR		; found it, get the step value
    947 0000E4E4 01 AE                   	br		FR4
    948 0000E4E6                        FR3
    949 0000E4E6 01 11                   	lw		r1,#1		; not found, step defaults to 1
    950 0000E4E8                        FR4
    951 0000E4E8 08 40 0E D1             	sw		r1,LOPINC	; save that too
                                        
    953 0000E4EC                        FR5
    954 0000E4EC 08 40 06 F2             	lw		r2,CURRNT
    955 0000E4F0 09 40 02 D2             	sw		r2,LOPLN	; save address of current line number
    956 0000E4F4 09 40 04 D8             	sw		r8,LOPPT	; and text pointer
                                        
                                        
    959 0000E4F8 E0 13                   	lw		r3,sp		; dig into the stack to find 'LOPVAR'
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 17
noc_boot21.a
    960 0000E4FA 08 40 0C F6             	lw		r6,LOPVAR
    961 0000E4FE 01 AE                   	br		FR7
    962 0000E500                        FR6
    963 0000E500 3A 13                   	lea		r3,10[r3]	; look at next stack frame
    964 0000E502                        FR7
    965 0000E502 30 F2                   	lw		r2,[r3]		; is it zero?
    966 0000E504 08 A8                   	beq		FR8			; if so, we're done
    967 0000E506 6D 22                   	cmp		r2,r6		; same as current LOPVAR?
    968 0000E508 FB B9                   	bne		FR6			; nope, look some more
                                        
    970 0000E50A 30 11                       lw      r1,r3       ; Else remove 5 words from...
    971 0000E50C 3A 12                   	lea		r2,10[r3]   ; inside the stack.
    972 0000E50E E0 13                   	lw		r3,sp		
    973 0000E510 47 40 02 AF             	call	MVDOWN
    974 0000E514 0A 6E                   	add		sp,sp,#10	; set the SP 5 words up
    975 0000E516                        FR8
    976 0000E516 9D BE                       br	    FINISH		; and continue execution
                                        
                                        
                                        ; 'NEXT var' serves as the logical (not necessarily physical) end
                                        ; of the 'FOR' loop.  The control variable 'var' is checked with
                                        ; the 'LOPVAR'.  If they are not the same, the interpreter digs in
                                        ; the stack to find the right one and purges all those that didn't
                                        ; match.  Either way, it then adds the 'STEP' to that variable and
                                        ; checks the result with against the limit value.  If it is within
                                        ; the limit, control loops back to the command following the
                                        ; 'FOR'.  If it's outside the limit, the save area is purged and
                                        ; execution continues.
                                        ;
    989 0000E518                        NEXT
    990 0000E518 00 11                   	lw		r1,#0		; don't allocate it
    991 0000E51A 26 40 03 AF             	call	TSTV		; get address of variable
    992 0000E51E 04 A9                   	bne		NX4
    993 0000E520 3B 4F 05 11             	lea		r1,msgNextVar
    994 0000E524 3C 40 0B AE             	br		ERROR		; if no variable, say "What?"
    995 0000E528                        NX4
    996 0000E528 10 19                   	lw		r9,r1		; save variable's address
    997 0000E52A                        NX0
    998 0000E52A 08 40 0C F1             	lw		r1,LOPVAR	; If 'LOPVAR' is zero, we never...
    999 0000E52E 04 A9                   	bne		NX5         ; had a FOR loop
   1000 0000E530 3A 4F 02 11             	lea		r1,msgNextFor
   1001 0000E534 3C 40 03 AE             	br		ERROR		
   1002 0000E538                        NX5
   1003 0000E538 9D 21                   	cmp		r1,r9		; else we check them
   1004 0000E53A 03 A8                   	beq		NX2			; OK, they agree
   1005 0000E53C 45 40 0F AF             	call	POPA		; nope, let's see the next frame
   1006 0000E540 F4 BE                   	br		NX0
   1007 0000E542                        NX2
   1008 0000E542 90 F1                   	lw		r1,[r9]		; get control variable's value
   1009 0000E544 08 40 0E F2             	lw		r2,LOPINC
   1010 0000E548 20 21                   	add		r1,r2		; add in loop increment
                                        ;	BVS.L	QHOW		say "How?" for 32-bit overflow
   1012 0000E54A 90 D1                   	sw		r1,[r9]		; save control variable's new value
   1013 0000E54C 09 40 00 F3             	lw		r3,LOPLMT	; get loop's limit value
   1014 0000E550 26 22                   	or		r2,r2       ; check loop increment
   1015 0000E552 03 AB                   	bpl		NX1			; branch if loop increment is positive
   1016 0000E554 3D 21                   	cmp		r1,r3		; test against limit
   1017 0000E556 0A A0                   	blt		NXPurge
   1018 0000E558 02 AE                   	br      NX3
   1019 0000E55A                        NX1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 18
noc_boot21.a
   1020 0000E55A 3D 21                   	cmp		r1,r3
   1021 0000E55C 07 A3                   	bgt		NXPurge
   1022 0000E55E                        NX3	
   1023 0000E55E 09 40 02 F8             	lw		r8,LOPLN	; Within limit, go back to the...
   1024 0000E562 08 40 06 D8             	sw		r8,CURRNT
   1025 0000E566 09 40 04 F8             	lw		r8,LOPPT	; saved 'CURRNT' and text pointer.
   1026 0000E56A 73 BE                   	br		FINISH
                                        
   1028 0000E56C                        NXPurge
   1029 0000E56C 44 40 07 AF                 call    POPA        ; purge this loop
   1030 0000E570 70 BE                       br      FINISH
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                                        ;
                                        ; 'REM' can be followed by anything and is ignored by the
                                        ; interpreter.
                                        ;
                                        ;REM
                                        ;    br	    IF2		    ; skip the rest of the line
                                        
                                        ; 'IF' is followed by an expression, as a condition and one or
                                        ; more commands (including other 'IF's) separated by colons.
                                        ; Note that the word 'THEN' is not used.  The interpreter evaluates
                                        ; the expression.  If it is non-zero, execution continues.  If it
                                        ; is zero, the commands that follow are ignored and execution
                                        ; continues on the next line.
                                        ;
   1050 0000E572                        IF
   1051 0000E572 15 40 03 AF                 call	OREXPR		; evaluate the expression
   1052 0000E576                        IF1
   1053 0000E576 16 21                       or      r1,r1       ; is it zero?
   1054 0000E578 EF 4F 0D A9                 bne	    RUNSML		; if not, continue
   1055 0000E57C                        IF2
   1056 0000E57C 80 19                       lw		r9,r8		; set lookup pointer
   1057 0000E57E 00 11                   	lw		r1,#0		; find line #0 (impossible)
   1058 0000E580 42 40 09 AF             	call	FNDSKP		; if so, skip the rest of the line
   1059 0000E584 DB 4F 0A A7             	bgtu	WSTART		; if no next line, do a warm start
   1060 0000E588                        IF3
   1061 0000E588 EF 4F 02 AE             	br		RUNTSL		; run the next line
                                        
                                        
                                        ; INPUT is called first and establishes a stack frame
   1065 0000E58C                        INPERR
   1066 0000E58C 08 40 0A FE             	lw		sp,STKINP	; restore the old stack pointer
   1067 0000E590 E4 F8                   	lw		r8,4[sp]
   1068 0000E592 08 40 06 D8             	sw		r8,CURRNT	; and old 'CURRNT'
   1069 0000E596 E2 F8                   	lw		r8,2[sp]	; and old text pointer
   1070 0000E598 0A 6E                   	add		sp,sp,#10	; fall through will subtract 10
                                        
                                        ; 'INPUT' is like the 'PRINT' command, and is followed by a list
                                        ; of items.  If the item is a string in single or double quotes,
                                        ; or is an underline (back arrow), it has the same effect as in
                                        ; 'PRINT'.  If an item is a variable, this variable name is
                                        ; printed out followed by a colon, then the interpreter waits for
                                        ; an expression to be typed in.  The variable is then set to the
                                        ; value of this expression.  If the variable is preceeded by a
                                        ; string (again in single or double quotes), the string will be
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 19
noc_boot21.a
                                        ; displayed followed by a colon.  The interpreter the waits for an
                                        ; expression to be entered and sets the variable equal to the
                                        ; expression's value.  If the input expression is invalid, the
                                        ; interpreter will print "What?", "How?", or "Sorry" and reprint
                                        ; the prompt and redo the input.  The execution will not terminate
                                        ; unless you press control-C.  This is handled in 'INPERR'.
                                        ;
   1087 0000E59A                        INPUT
   1088 0000E59A F6 6E                   	sub		sp,sp,#10	; allocate stack frame
   1089 0000E59C E8 D5                   	sw      r5,8[sp]
   1090 0000E59E                        IP6
   1091 0000E59E E0 D8                   	sw		r8,[sp]		; save in case of error
   1092 0000E5A0 47 40 07 AF             	call	QTSTG		; is next item a string?
   1093 0000E5A4 06 AE                   	br		IP2			; nope - this branch must take only two bytes
   1094 0000E5A6 01 11                   	lw		r1,#1		; allocate var
   1095 0000E5A8 21 40 0C AF             	call	TSTV		; yes, but is it followed by a variable?
   1096 0000E5AC 2A A8                   	beq     IP4		    ; if not, brnch
   1097 0000E5AE 10 1A                   	lw		r10,r1		; put away the variable's address
   1098 0000E5B0 10 AE                   	br		IP3			; if so, input to variable
   1099 0000E5B2                        IP2
   1100 0000E5B2 E2 D8                   	sw		r8,2[sp]	; save for 'PRTSTG'
   1101 0000E5B4 01 11                   	lw		r1,#1
   1102 0000E5B6 21 40 05 AF             	call	TSTV		; must be a variable now
   1103 0000E5BA 04 A9                   	bne		IP7
   1104 0000E5BC 38 4F 05 11             	lea		r1,msgInputVar
   1105 0000E5C0 37 40 0D AE             	br		ERROR		; "What?" it isn't?
   1106 0000E5C4                        IP7
   1107 0000E5C4 10 1A                   	lw		r10,r1		; put away the variable's address
   1108 0000E5C6 80 E5                   	lb		r5,[r8]		; get ready for 'PRTSTG' by null terminating
   1109 0000E5C8 80 C0                   	sb		r0,[r8]
   1110 0000E5CA E2 F1                   	lw		r1,2[sp]	; get back text pointer
   1111 0000E5CC 44 40 05 AF             	call	PRTSTG		; print string as prompt
   1112 0000E5D0 80 C5                   	sb		r5,[r8]		; un-null terminate
   1113 0000E5D2                        IP3
   1114 0000E5D2 E2 D8                   	sw		r8,2[sp]	; save in case of error
   1115 0000E5D4 08 40 06 F1             	lw		r1,CURRNT
   1116 0000E5D8 E4 D1                   	sw		r1,4[sp]	; also save 'CURRNT'
   1117 0000E5DA 0F 11                   	lw		r1,#-1
   1118 0000E5DC 08 40 06 D1             	sw		r1,CURRNT	; flag that we are in INPUT
   1119 0000E5E0 08 40 0A DE             	sw		sp,STKINP	; save the stack pointer too
   1120 0000E5E4 E6 DA                   	sw		r10,6[sp]	; save the variable address
   1121 0000E5E6 03 40 0A 11             	lw		r1,#':'		; print a colon first
   1122 0000E5EA 38 40 02 AF             	call	GETLN		; then get an input line
   1123 0000E5EE 0A 40 0E 18             	lea		r8,BUFFER	; point to the buffer
   1124 0000E5F2 11 40 03 AF             	call	OREXPR		; evaluate the input
   1125 0000E5F6 E6 FA                   	lw		r10,6[sp]	; restore the variable address
   1126 0000E5F8 A0 D1                   	sw		r1,[r10]	; save value in variable
   1127 0000E5FA E4 F1                   	lw		r1,4[sp]	; restore old 'CURRNT'
   1128 0000E5FC 08 40 06 D1             	sw		r1,CURRNT
   1129 0000E600 E2 F8                   	lw		r8,2[sp]	; and the old text pointer
   1130 0000E602                        IP4
   1131 0000E602 50 40 00 AF             	call	TSTC		; is the next thing a comma?
   1132 0000E606 2C 04                   	db	',',IP5-*+1
   1133 0000E608 CA BE                   	br		IP6			; yes, more items
   1134 0000E60A                        IP5
   1135 0000E60A E8 F5                       lw      r5,8[sp]
   1136 0000E60C 0A 6E                   	add		sp,sp,#10	; clean up the stack
   1137 0000E60E 21 BE                   	jmp		FINISH
                                        
                                        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 20
noc_boot21.a
   1140 0000E610                        DEFLT
   1141 0000E610 80 E1                       lb      r1,[r8]
   1142 0000E612 FF 4F 13 10                 cmp     r1,#CR      ; empty line is OK
   1143 0000E616 1D B8                   	beq	    FINISH	    ; else it is 'LET'
                                        
                                        
                                        ; 'LET' is followed by a list of items separated by commas.
                                        ; Each item consists of a variable, an equals sign, and an
                                        ; expression.  The interpreter evaluates the expression and sets
                                        ; the variable to that value.  The interpreter will also handle
                                        ; 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                                        ;
   1152 0000E618                        LET
   1153 0000E618 31 40 03 AF                 call	SETVAL		; do the assignment
   1154 0000E61C 4F 40 03 AF             	call	TSTC		; check for more 'LET' items
   1155 0000E620 2C 04                   	db	',',LT1-*+1
   1156 0000E622 FA BE                   	br	    LET
   1157 0000E624                        LT1
   1158 0000E624 16 BE                       br	    FINISH		; until we are finished.
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** LOAD *** & SAVE ***
                                        ;
                                        ; These two commands transfer a program to/from an auxiliary
                                        ; device such as a cassette, another computer, etc.  The program
                                        ; is converted to an easily-stored format: each line starts with
                                        ; a colon, the line no. as 4 hex digits, and the rest of the line.
                                        ; At the end, a line starting with an '@' sign is sent.  This
                                        ; format can be read back with a minimum of processing time by
                                        ; the Butterfly.
                                        ;
   1173 0000E626                        LOAD
   1174 0000E626 08 4E 06 F8             	lw		r8,TXTBGN	; set pointer to start of prog. area
   1175 0000E62A 00 40 0D 11             	lw		r1,#CR		; For a CP/M host, tell it we're ready...
   1176 0000E62E D2 4F 04 AF             	call	GOAUXO		; by sending a CR to finish PIP command.
   1177 0000E632                        LOD1
   1178 0000E632 D2 4F 04 AF             	call	GOAUXI		; look for start of line
   1179 0000E636 FD BA                   	bmi		LOD1
   1180 0000E638 FC 4F 10 10             	cmp		r1,#'@'		; end of program?
   1181 0000E63C 1B A8                   	beq		LODEND
   1182 0000E63E FE 4F 16 10             	cmp     r1,#0x1A    ; or EOF marker
   1183 0000E642 18 A8                   	beq     LODEND
   1184 0000E644 FC 4F 16 10             	cmp		r1,#':'		; if not, is it start of line?
   1185 0000E648 F4 B9                   	bne		LOD1		; if not, wait for it
   1186 0000E64A 18 AF                   	call	GCHAR		; get line number
   1187 0000E64C 80 C1                   	sb		r1,[r8]		; store it
   1188 0000E64E A1 31                   	shr		r1,#1
   1189 0000E650 A1 31                   	shr		r1,#1
   1190 0000E652 A1 31                   	shr		r1,#1
   1191 0000E654 A1 31                   	shr		r1,#1
   1192 0000E656 A1 31                   	shr		r1,#1
   1193 0000E658 A1 31                   	shr		r1,#1
   1194 0000E65A A1 31                   	shr		r1,#1
   1195 0000E65C A1 31                   	shr		r1,#1
   1196 0000E65E 81 C1                   	sb		r1,1[r8]
   1197 0000E660 02 68                   	add		r8,r8,#2
   1198 0000E662                        LOD2
   1199 0000E662 D0 4F 0C AF             	call	GOAUXI		; get another text char.
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 21
noc_boot21.a
   1200 0000E666 FD BA                   	bmi		LOD2
   1201 0000E668 80 C1                   	sb		r1,[r8]
   1202 0000E66A 01 68                   	add		r8,r8,#1	; store it
   1203 0000E66C FF 4F 13 10             	cmp		r1,#CR		; is it the end of the line?
   1204 0000E670 F8 B9                   	bne		LOD2		; if not, go back for more
   1205 0000E672 DF BE                   	br		LOD1		; if so, start a new line
   1206 0000E674                        LODEND
   1207 0000E674 09 40 06 D8             	sw		r8,TXTUNF	; set end-of program pointer
   1208 0000E678 D4 4F 00 AE             	br		WSTART		; back to direct mode
                                        
                                        ; get character from input (16 bit value)
   1211 0000E67C                        GCHAR
   1212 0000E67C FA 6E                   	sub		sp,sp,#6
   1213 0000E67E E0 DF                   	sw		lr,[sp]
   1214 0000E680 E2 D5                   	sw		r5,2[sp]
   1215 0000E682 E4 D6                   	sw		r6,4[sp]
   1216 0000E684 04 16                   	lw      r6,#4       ; repeat four times
   1217 0000E686 00 15                   	lw		r5,#0
   1218 0000E688                        GCHAR1
   1219 0000E688 CF 4F 09 AF             	call	GOAUXI		; get a char
   1220 0000E68C FD BA                   	bmi		GCHAR1
   1221 0000E68E 0D AF                   	call	asciiToHex
   1222 0000E690 81 35                   	shl		r5,#1
   1223 0000E692 81 35                   	shl		r5,#1
   1224 0000E694 81 35                   	shl		r5,#1
   1225 0000E696 81 35                   	shl		r5,#1
   1226 0000E698 16 25                   	or		r5,r1
   1227 0000E69A FF 66                   	sub		r6,r6,#1
   1228 0000E69C F5 B9                   	bne     GCHAR1
   1229 0000E69E 50 11                   	lw		r1,r5
   1230 0000E6A0 E0 FF                   	lw		lr,[sp]
   1231 0000E6A2 E2 F5                   	lw		r5,2[sp]
   1232 0000E6A4 E4 F6                   	lw		r6,4[sp]
   1233 0000E6A6 06 6E                   	add     sp,sp,#6
   1234 0000E6A8 F0 80                   	ret
                                        
                                        ; convert an ascii char to hex code
                                        ; input
                                        ;	r2 = char to convert
                                        
   1240 0000E6AA                        asciiToHex
   1241 0000E6AA FC 4F 17 10             	cmp		r1,#'9'
   1242 0000E6AE 01 A2                   	ble		a2h1		; less than '9'
   1243 0000E6B0 F9 61                   	sub		r1,r1,#7	; shift 'A' to '9'+1
   1244 0000E6B2                        a2h1
   1245 0000E6B2 D0 61                   	sub		r1,r1,#'0'	;
   1246 0000E6B4 00 40 5F 31             	and		r1,#15		; make sure a nybble
   1247 0000E6B8 F0 80                   	ret
                                        
                                        ; SAVE
                                        ; SAVE ON <node number> - copies the code to the specified node
                                        
   1252 0000E6BA                        SAVE
   1253 0000E6BA 4D 40 07 AF             	call	IGNBLK		; ignore blanks
   1254 0000E6BE 80 E1                   	lb		r1,[r8]
   1255 0000E6C0 FB 4F 11 10             	cmp		r1,#'O'
   1256 0000E6C4 0A A9                   	bne		SAVE3
   1257 0000E6C6 81 E1                   	lb		r1,1[r8]
   1258 0000E6C8 FB 4F 12 10             	cmp		r1,#'N'
   1259 0000E6CC 06 A9                   	bne		SAVE3
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 22
noc_boot21.a
   1260 0000E6CE 02 68                   	add		r8,r8,#2
   1261 0000E6D0 A5 AF                   	call	OREXPR		; get core #
   1262 0000E6D2 03 40 06 C1             	sb		r1,tgtNode
   1263 0000E6D6 55 40 01 AF             	call	TriggerTgtLoad
   1264 0000E6DA                        SAVE3:
   1265 0000E6DA 08 4E 06 F8             	lw		r8,TXTBGN	;set pointer to start of prog. area
   1266 0000E6DE 09 40 06 F9             	lw		r9,TXTUNF	;set pointer to end of prog. area
   1267 0000E6E2                        SAVE1
   1268 0000E6E2 41 AF                   	call    AUXOCRLF    ; send out a CR & LF (CP/M likes this)
   1269 0000E6E4 9D 28                   	cmp		r8,r9		; are we finished?
   1270 0000E6E6 34 A5                   	bgeu	SAVEND
   1271 0000E6E8 03 40 06 E2             	lb		r2,tgtNode
   1272 0000E6EC FE 4F 2F 10             	cmp		r2,#$11
   1273 0000E6F0 14 A8                   	beq		SAVE4
                                        	lb		r1,#':'
   1275 0000E6F2 02 40 00 C1             	sb		r1,txBuf
   1276 0000E6F6 80 E1                   	lb		r1,[r8]
   1277 0000E6F8 02 40 01 C1             	sb		r1,txBuf+1
   1278 0000E6FC 81 E1                   	lb		r1,1[r8]
   1279 0000E6FE 02 40 02 C1             	sb		r1,txBuf+2
   1280 0000E702 03 40 06 E1             	lb		r1,tgtNode
   1281 0000E706 02 40 0F C1             	sb		r1,txBuf+MSG_DST
                                        	lb		r1,#$11
   1283 0000E70A 02 40 0E C1             	sb		r1,txBuf+MSG_SRC
                                        	lb		r1,#11
   1285 0000E70E 02 40 07 C1             	sb		r1,txBuf+MSG_TYPE
   1286 0000E712 C8 4F 00 AF             	call	Xmit
   1287 0000E716 02 68                   	add		r8,r8,#2
   1288 0000E718 13 AE                   	br		SAVE2
   1289 0000E71A                        SAVE4:
   1290 0000E71A 03 40 0A 11             	lw		r1,#':'		; if not, start a line
   1291 0000E71E CA 4F 0C AF             	call	GOAUXO
   1292 0000E722 80 E1                   	lb		r1,[r8]		; get line number
   1293 0000E724 0E 21                   	zxb		r1
   1294 0000E726 81 E2                   	lb		r2,1[r8]
   1295 0000E728 0E 22                   	zxb		r2
   1296 0000E72A 81 32                   	shl		r2,#1
   1297 0000E72C 81 32                   	shl		r2,#1
   1298 0000E72E 81 32                   	shl		r2,#1
   1299 0000E730 81 32                   	shl		r2,#1
   1300 0000E732 81 32                   	shl		r2,#1
   1301 0000E734 81 32                   	shl		r2,#1
   1302 0000E736 81 32                   	shl		r2,#1
   1303 0000E738 81 32                   	shl		r2,#1
   1304 0000E73A 26 21                   	or		r1,r2
   1305 0000E73C 02 68                   	add		r8,r8,#2
   1306 0000E73E 1F AF                   	call	PWORD       ; output line number as 4-digit hex
   1307 0000E740                        SAVE2
   1308 0000E740 80 E1                   	lb		r1,[r8]		; get a text char.
   1309 0000E742 01 68                   	add		r8,r8,#1
   1310 0000E744 FF 4F 13 10             	cmp		r1,#CR		; is it the end of the line?
   1311 0000E748 CC B8                   	beq		SAVE1		; if so, send CR & LF and start new line
   1312 0000E74A C9 4F 06 AF             	call	GOAUXO		; send it out
   1313 0000E74E F8 BE                   	br		SAVE2		; go back for more text
   1314 0000E750                        SAVEND
   1315 0000E750 04 40 00 11             	lw		r1,#'@'		; send end-of-program indicator
   1316 0000E754 C9 4F 01 AF             	call	GOAUXO
   1317 0000E758 06 AF                   	call    AUXOCRLF    ; followed by a CR & LF
   1318 0000E75A 01 40 0A 11             	lw		r1,#0x1A	; and a control-Z to end the CP/M file
   1319 0000E75E C8 4F 0C AF             	call	GOAUXO
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 23
noc_boot21.a
   1320 0000E762 CC 4F 0B AE             	br		WSTART		; then go do a warm start
                                        
                                        
                                        ; output a CR LF sequence to auxillary output
                                        ; Registers Affected
                                        ;   r3 = LF
   1326 0000E766                        AUXOCRLF
   1327 0000E766 FE 6E                       sub     sp,sp,#2
   1328 0000E768 E0 DF                       sw      lr,[sp]
   1329 0000E76A 00 40 0D 11                 lw      r1,#CR
   1330 0000E76E C8 4F 04 AF                 call    GOAUXO
   1331 0000E772 0A 11                       lw      r1,#LF
   1332 0000E774 C8 4F 01 AF                 call    GOAUXO
   1333 0000E778 E0 FF                       lw      lr,[sp]
   1334 0000E77A 02 6E                   	add		sp,sp,#2
   1335 0000E77C F0 80                       ret
                                        
                                        
                                        ; output a word in hex format
                                        ; tricky because of the need to reverse the order of the chars
   1340 0000E77E                        PWORD
   1341 0000E77E FC 6E                   	sub		sp,sp,#4
   1342 0000E780 E0 DF                   	sw		lr,[sp]
   1343 0000E782 E2 D5                   	sw		r5,2[sp]
   1344 0000E784 0A 40 05 15             	lea     r5,NUMWKA+3
   1345 0000E788 10 14                   	lw		r4,r1		; r4 = value
   1346 0000E78A                        pword1
   1347 0000E78A 40 11                       lw      r1,r4       ; r1 = value
   1348 0000E78C A1 34                       shr     r4,#1       ; shift over to next nybble
   1349 0000E78E A1 34                       shr     r4,#1
   1350 0000E790 A1 34                       shr     r4,#1
   1351 0000E792 A1 34                       shr     r4,#1
   1352 0000E794 10 AF                       call    toAsciiHex  ; convert LS nybble to ascii hex
   1353 0000E796 50 C1                       sb      r1,[r5]     ; save in work area
   1354 0000E798 FF 65                       sub     r5,r5,#1
   1355 0000E79A F5 4F 5E 10                 cmp     r5,#NUMWKA
   1356 0000E79E F5 B5                       bgeu    pword1
   1357 0000E7A0                        pword2
   1358 0000E7A0 01 65                       add     r5,r5,#1
   1359 0000E7A2 50 E1                       lb      r1,[r5]     ; get char to output
   1360 0000E7A4 C6 4F 09 AF             	call	GOAUXO		; send it
   1361 0000E7A8 F5 4F 5B 10             	cmp     r5,#NUMWKA+3
   1362 0000E7AC F9 B4                   	bltu    pword2
                                        
   1364 0000E7AE E2 F5                   	lw		r5,2[sp]
   1365 0000E7B0 E0 FF                   	lw		lr,[sp]
   1366 0000E7B2 04 6E                   	add		sp,sp,#4
   1367 0000E7B4 F0 80                   	ret
                                        
                                        
                                        ; convert nybble in r2 to ascii hex char2
                                        ; r2 = character to convert
                                        
   1373 0000E7B6                        toAsciiHex
   1374 0000E7B6 00 40 5F 31             	and		r1,#15		; make sure it's a nybble
   1375 0000E7BA FF 4F 16 10             	cmp		r1,#10		; > 10 ?
   1376 0000E7BE 01 A0                   	blt		tah1
   1377 0000E7C0 07 61                   	add		r1,r1,#7	; bump it up to the letter 'A'
   1378 0000E7C2                        tah1
   1379 0000E7C2 30 61                   	add		r1,r1,#'0'	; bump up to ascii '0'
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 24
noc_boot21.a
   1380 0000E7C4 F0 80                   	ret
                                        
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** POKE *** & SYSX ***
                                        ;
                                        ; 'POKE expr1,expr2' stores the byte from 'expr2' into the memory
                                        ; address specified by 'expr1'.
                                        ;
                                        ; 'SYSX expr' jumps to the machine language subroutine whose
                                        ; starting address is specified by 'expr'.  The subroutine can use
                                        ; all registers but must leave the stack the way it found it.
                                        ; The subroutine returns to the interpreter by executing an RET.
                                        ;
   1396 0000E7C6                        POKE
   1397 0000E7C6 FE 6E                   	sub		sp,sp,#2
   1398 0000E7C8 29 AF                   	call	OREXPR		; get the memory address
   1399 0000E7CA 41 40 0C AF             	call	TSTC		; it must be followed by a comma
   1400 0000E7CE 2C 10                   	db	',',PKER-*+1
   1401 0000E7D0 E0 D1                   	sw		r1,[sp]	    ; save the address
   1402 0000E7D2 24 AF                   	call	OREXPR		; get the byte to be POKE'd
   1403 0000E7D4 E0 F2                   	lw		r2,[sp]	    ; get the address back
   1404 0000E7D6 20 C1                   	sb		r1,[r2]		; store the byte in memory
   1405 0000E7D8 02 6E                   	add		sp,sp,#2
   1406 0000E7DA E3 4F 0A AE             	br		FINISH
   1407 0000E7DE                        PKER
   1408 0000E7DE 31 4F 0E 11             	lea		r1,msgComma
   1409 0000E7E2 26 40 0C AE             	br		ERROR		; if no comma, say "What?"
                                        
                                        
   1412 0000E7E6                        POKEW
   1413 0000E7E6 FE 6E                   	sub		sp,sp,#2
   1414 0000E7E8 19 AF                   	call	OREXPR		; get the memory address
   1415 0000E7EA 40 40 0C AF             	call	TSTC		; it must be followed by a comma
   1416 0000E7EE 2C F0                   	db	',',PKER-*+1
   1417 0000E7F0 E0 D1                   	sw		r1,[sp]	    ; save the address
   1418 0000E7F2 14 AF                   	call	OREXPR		; get the byte to be POKE'd
   1419 0000E7F4 E0 F2                   	lw		r2,[sp]	    ; get the address back
   1420 0000E7F6 20 D1                   	sw		r1,[r2]		; store the word in memory
   1421 0000E7F8 02 6E                   	add		sp,sp,#2
   1422 0000E7FA E2 4F 0A AE             	jmp		FINISH
                                        
                                        
   1425 0000E7FE                        SYSX
   1426 0000E7FE FE 6E                   	sub		sp,sp,#2
   1427 0000E800 0D AF                   	call	OREXPR		; get the subroutine's address
   1428 0000E802 16 20                   	or		r0,r1		; make sure we got a valid address
   1429 0000E804 04 A9                   	bne		sysx1
   1430 0000E806 37 4F 03 11             	lea		r1,msgSYSBad
   1431 0000E80A 25 40 08 AE             	br		ERROR
   1432 0000E80E                        sysx1
   1433 0000E80E E0 D8                   	sw		r8,[sp]	    ; save the text pointer
   1434 0000E810 BF 48 06 AF             	call	[r1]		; jump to the subroutine
   1435 0000E814 E0 F8                   	lw		r8,[sp]	    ; restore the text pointer
   1436 0000E816 02 6E                   	add		sp,sp,#2
   1437 0000E818 E1 4F 0B AE             	br		FINISH
                                        
                                        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 25
noc_boot21.a
                                        ;******************************************************************
                                        ;
                                        ; *** EXPR ***
                                        ;
                                        ; 'EXPR' evaluates arithmetical or logical expressions.
                                        ; <OREXPR>::= <ANDEXPR> OR <ANDEXPR> ...
                                        ; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                                        ; <EXPR>::=<EXPR2>
                                        ;	   <EXPR2><rel.op.><EXPR2>
                                        ; where <rel.op.> is one of the operators in TAB8 and the result
                                        ; of these operations is 1 if true and 0 if false.
                                        ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                                        ; where () are optional and (... are optional repeats.
                                        ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                                        ; <EXPR4>::=<variable>
                                        ;	    <function>
                                        ;	    (<EXPR>)
                                        ; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                                        ; as an index, functions can have an <EXPR> as arguments, and
                                        ; <EXPR4> can be an <EXPR> in parenthesis.
                                        ;
                                        
                                        
                                        ; <OREXPR>::=<ANDEXPR> OR <ANDEXPR> ...
                                        ;
   1465 0000E81C                        OREXPR
   1466 0000E81C FC 6E                   	sub		sp,sp,#4
   1467 0000E81E E0 DF                   	sw		lr,[sp]
   1468 0000E820 0F AF                   	call	ANDEXPR		; get first <ANDEXPR>
   1469 0000E822                        XP_OR1
   1470 0000E822 E2 D1                   	sw		r1,2[sp]	; save <ANDEXPR> value
   1471 0000E824 25 4E 01 19             	lea		r9,TAB10		; look up a logical operator
   1472 0000E828 2B 4E 00 1A             	lea		r10,TAB10_1
   1473 0000E82C D4 4F 06 AE             	jmp		EXEC		; go do it
                                        
   1475 0000E830                        XP_OR
   1476 0000E830 07 AF                       call    ANDEXPR
   1477 0000E832 E2 F2                       lw      r2,2[sp]
   1478 0000E834 26 21                       or      r1,r2
   1479 0000E836 F5 BE                       br      XP_OR1
                                        
   1481 0000E838                        XP_ORX
   1482 0000E838 E2 F1                   	lw		r1,2[sp]
   1483 0000E83A E0 FF                       lw      lr,[sp]
   1484 0000E83C 04 6E                       add     sp,sp,#4
   1485 0000E83E F0 80                       ret
                                        
                                        
                                        ; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                                        ;
   1490 0000E840                        ANDEXPR
   1491 0000E840 FC 6E                   	sub		sp,sp,#4
   1492 0000E842 E0 DF                   	sw		lr,[sp]
   1493 0000E844 37 AF                   	call	EXPR		; get first <EXPR>
   1494 0000E846                        XP_AND1
   1495 0000E846 E2 D1                   	sw		r1,2[sp]	; save <EXPR> value
   1496 0000E848 24 4E 0D 19             	lea		r9,TAB9		; look up a logical operator
   1497 0000E84C 2A 4E 0C 1A             	lea		r10,TAB9_1
   1498 0000E850 D3 4F 04 AE             	jmp		EXEC		; go do it
                                        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 26
noc_boot21.a
   1500 0000E854                        XP_AND
   1501 0000E854 2F AF                       call    EXPR
   1502 0000E856 E2 F2                       lw      r2,2[sp]
   1503 0000E858 25 21                       and     r1,r2
   1504 0000E85A F5 BE                       br      XP_AND1
                                        
   1506 0000E85C                        XP_ANDX
   1507 0000E85C E2 F1                   	lw		r1,2[sp]
   1508 0000E85E E0 FF                       lw      lr,[sp]
   1509 0000E860 04 6E                       add     sp,sp,#4
   1510 0000E862 F0 80                       ret
                                        
                                        
                                        ; Determine if the character is a digit
                                        ;   Parameters
                                        ;       r2 = char to test
                                        ;   Returns
                                        ;       r1 = 1 if digit, otherwise 0
                                        ;
   1519 0000E864                        isDigit
   1520 0000E864 FD 4F 10 10                 cmp     r1,#'0'
   1521 0000E868 05 A0                       blt     isDigitFalse
   1522 0000E86A FC 4F 17 10                 cmp     r1,#'9'
   1523 0000E86E 02 A3                       bgt     isDigitFalse
   1524 0000E870 01 11                       lw      r1,#1
   1525 0000E872 F0 80                       ret
   1526 0000E874                        isDigitFalse
   1527 0000E874 00 11                       lw      r1,#0
   1528 0000E876 F0 80                       ret
                                        
                                        
                                        ; Determine if the character is a alphabetic
                                        ;   Parameters
                                        ;       r2 = char to test
                                        ;   Returns
                                        ;       r1 = 1 if alpha, otherwise 0
                                        ;
   1537 0000E878                        isAlpha
   1538 0000E878 FB 4F 1F 10                 cmp     r1,#'A'
   1539 0000E87C 0B A0                       blt     isAlphaFalse
   1540 0000E87E FA 4F 16 10                 cmp     r1,#'Z'
   1541 0000E882 06 A2                       ble     isAlphaTrue
   1542 0000E884 F9 4F 1F 10                 cmp     r1,#'a'
   1543 0000E888 05 A0                       blt     isAlphaFalse
   1544 0000E88A F8 4F 16 10                 cmp     r1,#'z'
   1545 0000E88E 02 A3                       bgt     isAlphaFalse
   1546 0000E890                        isAlphaTrue
   1547 0000E890 01 11                       lw      r1,#1
   1548 0000E892 F0 80                       ret
   1549 0000E894                        isAlphaFalse
   1550 0000E894 00 11                       lw      r1,#0
   1551 0000E896 F0 80                       ret
                                        
                                        
                                        ; Determine if the character is a alphanumeric
                                        ;   Parameters
                                        ;       r1 = char to test
                                        ;   Returns
                                        ;       r1 = 1 if alpha, otherwise 0
                                        ;
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 27
noc_boot21.a
   1560 0000E898                        isAlnum
   1561 0000E898 FE 6E                       sub     sp,sp,#2
   1562 0000E89A E0 DF                       sw      lr,[sp]
   1563 0000E89C 10 12                       lw      r2,r1		; save test char
   1564 0000E89E E2 BF                       call    isDigit
   1565 0000E8A0 06 A9                       bne		isDigitx	; if it is a digit
   1566 0000E8A2 20 11                       lw      r1,r2		; get back test char
   1567 0000E8A4 E9 BF                       call    isAlpha
   1568 0000E8A6 E0 FF                       lw      lr,[sp]
   1569 0000E8A8 02 6E                       add		sp,sp,#2
   1570 0000E8AA 16 21                       or      r1,r1
   1571 0000E8AC F0 80                       ret
   1572 0000E8AE                        isDigitx
   1573 0000E8AE E0 FF                       lw      lr,[sp]
   1574 0000E8B0 02 6E                       add     sp,sp,#2	; return Z=0
   1575 0000E8B2 F0 80                       ret
                                        
                                        
   1578 0000E8B4                        EXPR
   1579 0000E8B4 FC 6E                   	sub		sp,sp,#4
   1580 0000E8B6 E0 DF                   	sw		lr,[sp]
   1581 0000E8B8 39 AF                   	call	EXPR2
   1582 0000E8BA E2 D1                   	sw		r1,2[sp]	; save <EXPR2> value
   1583 0000E8BC 24 4E 03 19             	lea		r9,TAB8		; look up a relational operator
   1584 0000E8C0 29 4E 0E 1A             	lea		r10,TAB8_1
   1585 0000E8C4 CF 4F 0A AE             	jmp		EXEC		; go do it
                                        
   1587 0000E8C8                        XP11
   1588 0000E8C8 E2 F1                   	lw		r1,2[sp]
   1589 0000E8CA 28 AF                   	call	XP18	; is it ">="?
   1590 0000E8CC 1D 22                   	cmp		r2,r1
   1591 0000E8CE 1E A1                   	bge		XPRT1	; no, return r2=1
   1592 0000E8D0 19 AE                   	br		XPRT0	; else return r2=0
                                        
   1594 0000E8D2                        XP12
   1595 0000E8D2 E2 F1                   	lw		r1,2[sp]
   1596 0000E8D4 23 AF                   	call	XP18	; is it "<>"?
   1597 0000E8D6 1D 22                   	cmp		r2,r1
   1598 0000E8D8 19 A9                   	bne		XPRT1	; no, return r2=1
   1599 0000E8DA 14 AE                   	br		XPRT0	; else return r2=0
                                        
   1601 0000E8DC                        XP13
   1602 0000E8DC E2 F1                   	lw		r1,2[sp]
   1603 0000E8DE 1E AF                   	call	XP18	; is it ">"?
   1604 0000E8E0 1D 22                   	cmp		r2,r1
   1605 0000E8E2 14 A3                   	bgt		XPRT1	; no, return r2=1
   1606 0000E8E4 0F AE                   	br		XPRT0	; else return r2=0
                                        
   1608 0000E8E6                        XP14
   1609 0000E8E6 E2 F1                   	lw		r1,2[sp]
   1610 0000E8E8 19 AF                   	call	XP18	; is it "<="?
   1611 0000E8EA 1D 22                   	cmp		r2,r1
   1612 0000E8EC 0F A2                   	ble		XPRT1	; no, return r2=1
   1613 0000E8EE 0A AE                   	br		XPRT0	; else return r2=0
                                        
   1615 0000E8F0                        XP15
   1616 0000E8F0 E2 F1                   	lw		r1,2[sp]
   1617 0000E8F2 14 AF                   	call	XP18	; is it "="?
   1618 0000E8F4 1D 22                   	cmp		r2,r1
   1619 0000E8F6 0A A8                   	beq		XPRT1	; if not, return r2=1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 28
noc_boot21.a
   1620 0000E8F8 05 AE                   	br		XPRT0	; else return r2=0
                                        
                                        
   1623 0000E8FA                        XP16
   1624 0000E8FA E2 F1                   	lw		r1,2[sp]
   1625 0000E8FC 0F AF                   	call	XP18	; is it "<"?
   1626 0000E8FE 1D 22                   	cmp		r2,r1
   1627 0000E900 05 A0                   	blt		XPRT1	; if not, return r2=1
   1628 0000E902 00 AE                   	br		XPRT0	; else return r2=0
                                        
   1630 0000E904                        XPRT0
   1631 0000E904 E0 FF                   	lw		lr,[sp]
   1632 0000E906 04 6E                   	add		sp,sp,#4
   1633 0000E908 00 11                   	lw		r1,#0   ; return r1=0 (false)
   1634 0000E90A F0 80                   	ret
                                        
   1636 0000E90C                        XPRT1
   1637 0000E90C E0 FF                   	lw		lr,[sp]
   1638 0000E90E 04 6E                   	add		sp,sp,#4
   1639 0000E910 01 11                   	lw		r1,#1	; return r1=1 (true)
   1640 0000E912 F0 80                   	ret
                                        
   1642 0000E914                        XP17				; it's not a rel. operator
   1643 0000E914 E2 F1                   	lw		r1,2[sp]	; return r2=<EXPR2>
   1644 0000E916 E0 FF                   	lw		lr,[sp]
   1645 0000E918 04 6E                   	add		sp,sp,#4
   1646 0000E91A F0 80                   	ret
                                        
   1648 0000E91C                        XP18
   1649 0000E91C FC 6E                   	sub		sp,sp,#4
   1650 0000E91E E0 DF                   	sw		lr,[sp]
   1651 0000E920 E2 D1                   	sw		r1,2[sp]
   1652 0000E922 04 AF                   	call	EXPR2		; do a second <EXPR2>
   1653 0000E924 E2 F2                   	lw		r2,2[sp]
   1654 0000E926 E0 FF                   	lw		lr,[sp]
   1655 0000E928 04 6E                   	add		sp,sp,#4
   1656 0000E92A F0 80                   	ret
                                        
                                        ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                                        
   1660 0000E92C                        EXPR2
   1661 0000E92C FC 6E                   	sub		sp,sp,#4
   1662 0000E92E E0 DF                   	sw		lr,[sp]
   1663 0000E930 36 40 09 AF             	call	TSTC		; negative sign?
   1664 0000E934 2D 08                   	db	'-',XP21-*+1
   1665 0000E936 00 11                   	lw		r1,#0		; yes, fake '0-'
   1666 0000E938 E2 D1                   	sw		r1,2[sp]
   1667 0000E93A 0F AE                   	br		XP26
   1668 0000E93C                        XP21
   1669 0000E93C 36 40 03 AF             	call	TSTC		; positive sign? ignore it
   1670 0000E940 2B 02                   	db	'+',XP22-*+1
   1671 0000E942                        XP22
   1672 0000E942 12 AF                   	call	EXPR3		; first <EXPR3>
   1673 0000E944                        XP23
   1674 0000E944 E2 D1                   	sw		r1,2[sp]	; yes, save the value
   1675 0000E946 35 40 0E AF             	call	TSTC		; add?
   1676 0000E94A 2B 0A                   	db	'+',XP25-*+1
   1677 0000E94C 0D AF                   	call	EXPR3		; get the second <EXPR3>
   1678 0000E94E                        XP24
   1679 0000E94E E2 F2                   	lw		r2,2[sp]
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 29
noc_boot21.a
   1680 0000E950 20 21                   	add		r1,r2		; add it to the first <EXPR3>
                                        ;	BVS.L	QHOW		brnch if there's an overflow
   1682 0000E952 F8 BE                   	br		XP23		; else go back for more operations
   1683 0000E954                        XP25
   1684 0000E954 35 40 07 AF             	call	TSTC		; subtract?
   1685 0000E958 2D 08                   	db	'-',XP45-*+1
   1686 0000E95A                        XP26
   1687 0000E95A 06 AF                   	call	EXPR3		; get second <EXPR3>
   1688 0000E95C 20 31                   	neg		r1			; change its sign
   1689 0000E95E F7 BE                   	br		XP24		; and do an addition
                                        
   1691 0000E960                        XP45
   1692 0000E960 E2 F1                   	lw		r1,2[sp]
   1693 0000E962 E0 FF                   	lw		lr,[sp]
   1694 0000E964 04 6E                   	add		sp,sp,#4
   1695 0000E966 F0 80                   	ret
                                        
                                        
                                        ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                                        
   1700 0000E968                        EXPR3
   1701 0000E968 FC 6E                   	sub		sp,sp,#4
   1702 0000E96A E0 DF                   	sw		lr,[sp]
   1703 0000E96C 14 AF                   	call	EXPR4		; get first <EXPR4>
   1704 0000E96E                        XP31
   1705 0000E96E E2 D1                   	sw		r1,2[sp]	; yes, save that first result
   1706 0000E970 34 40 09 AF             	call	TSTC		; multiply?
   1707 0000E974 2A 0A                   	db	'*',XP34-*+1
   1708 0000E976 0F AF                   	call	EXPR4		; get second <EXPR4>
   1709 0000E978 E2 F2                   	lw		r2,2[sp]
   1710 0000E97A B8 AF                   	call	MULT32		; multiply the two
   1711 0000E97C F8 BE                   	br		XP31		 ; then look for more terms
   1712 0000E97E                        XP34
   1713 0000E97E 34 40 02 AF             	call	TSTC		; divide?
   1714 0000E982 2F 0C                   	db	'/',XP47-*+1
   1715 0000E984 08 AF                   	call	EXPR4		; get second <EXPR4>
   1716 0000E986 10 12                   	lw      r2,r1
   1717 0000E988 E2 F1                   	lw		r1,2[sp]
   1718 0000E98A CD AF                   	call	DIV32		; do the division
   1719 0000E98C F0 BE                   	br		XP31		; go back for any more terms
                                        
   1721 0000E98E                        XP47
   1722 0000E98E E2 F1                   	lw		r1,2[sp]
   1723 0000E990 E0 FF                   	lw		lr,[sp]
   1724 0000E992 04 6E                   	add		sp,sp,#4
   1725 0000E994 F0 80                   	ret
                                        
                                        
                                        ; Functions are called through EXPR4
                                        ; <EXPR4>::=<variable>
                                        ;	    <function>
                                        ;	    (<EXPR>)
                                        
   1733 0000E996                        EXPR4
   1734 0000E996 FA 6E                       sub     sp,sp,#6
   1735 0000E998 E0 DF                       sw      lr,[sp]
   1736 0000E99A 21 4E 08 19             	lea		r9,TAB4		; find possible function
   1737 0000E99E 28 4E 04 1A             	lea		r10,TAB4_1
   1738 0000E9A2 C8 4F 0B AE             	jmp		EXEC        ; branch to function which does subsequent
                                        	                    ; ret for EXPR4
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 30
noc_boot21.a
                                        
   1741 0000E9A6                        XP40                    ; we get here if it wasn't a function
   1742 0000E9A6 00 11                   	lw		r1,#0
   1743 0000E9A8 1D AF                   	call	TSTV		
   1744 0000E9AA 04 A8                   	beq     XP41        ; nor a variable
   1745 0000E9AC 10 F1                   	lw		r1,[r1]		; if a variable, return its value in r1
   1746 0000E9AE E0 FF                   	lw      lr,[sp]
   1747 0000E9B0 06 6E                   	add     sp,sp,#6
   1748 0000E9B2 F0 80                   	ret
   1749 0000E9B4                        XP41
   1750 0000E9B4 33 40 09 AF             	call	TSTNUM		; or is it a number?
   1751 0000E9B8 26 22                   	or		r2,r2		; (if not, # of digits will be zero)
   1752 0000E9BA 01 A9                   	bne		XP46		; if so, return it in r1
   1753 0000E9BC 03 AF                   	call    PARN        ; check for (EXPR)
   1754 0000E9BE                        XP46
   1755 0000E9BE E0 FF                   	lw      lr,[sp]
   1756 0000E9C0 06 6E                   	add     sp,sp,#6
   1757 0000E9C2 F0 80                   	ret
                                        
                                        
                                        ; Check for a parenthesized expression
   1761 0000E9C4                        PARN
   1762 0000E9C4 FE 6E                   	sub		sp,sp,#2
   1763 0000E9C6 E0 DF                   	sw		lr,[sp]
   1764 0000E9C8 31 40 0D AF             	call	TSTC		; else look for ( OREXPR )
   1765 0000E9CC 28 10                   	db	'(',XP43-*+1
   1766 0000E9CE 26 BF                   	call	OREXPR
   1767 0000E9D0 31 40 09 AF             	call	TSTC
   1768 0000E9D4 29 08                   	db	')',XP43-*+1
   1769 0000E9D6                        XP42
   1770 0000E9D6 E0 FF                   	lw		lr,[sp]
   1771 0000E9D8 02 6E                   	add		sp,sp,#2
   1772 0000E9DA F0 80                   	ret
   1773 0000E9DC                        XP43
   1774 0000E9DC 29 4F 0B 11             	lea		r1,msgWhat
   1775 0000E9E0 16 40 0D AE             	br		ERROR
                                        
                                        
                                        ; ===== Test for a valid variable name.  Returns Z=1 if not
                                        ;	found, else returns Z=0 and the address of the
                                        ;	variable in r1.
                                        ; Parameters
                                        ;	r1 = 1 = allocate if not found
                                        ; Returns
                                        ;	r1 = address of variable, zero if not found
                                        
   1786 0000E9E4                        TSTV
   1787 0000E9E4 FA 6E                   	sub		sp,sp,#6
   1788 0000E9E6 E0 DF                   	sw		lr,[sp]
   1789 0000E9E8 E2 D5                   	sw		r5,2[sp]
   1790 0000E9EA 10 15                   	lw		r5,r1		; allocate flag
   1791 0000E9EC 33 40 0E AF             	call	IGNBLK
   1792 0000E9F0 80 E1                   	lb		r1,[r8]		; look at the program text
   1793 0000E9F2 FC 4F 10 10             	cmp     r1,#'@'
   1794 0000E9F6 1C A0                   	blt     tstv_notfound   ; C=1: not a variable
   1795 0000E9F8 12 A9                   	bne		TV1			; brnch if not "@" array
   1796 0000E9FA 01 68                   	add		r8,r8,#1	; If it is, it should be
   1797 0000E9FC E3 BF                   	call	PARN		; followed by (EXPR) as its index.
   1798 0000E9FE 81 31                   	shl     r1,#1
   1799 0000EA00 81 31                   	shl     r1,#1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 31
noc_boot21.a
                                        ;	BCS.L	QHOW		say "How?" if index is too big
   1801 0000EA02 E4 D1                       sw      r1,4[sp]    ; save the index
   1802 0000EA04 F4 6E                       sub		sp,sp,#12
   1803 0000EA06 E0 DF                       sw		lr,[sp]
   1804 0000EA08 10 40 0F AF             	call	SIZEX		; get amount of free memory
   1805 0000EA0C E4 F2                   	lw      r2,4[sp]    ; get back the index
   1806 0000EA0E 1D 22                   	cmp     r2,r1       ; see if there's enough memory
   1807 0000EA10 02 A4                   	bltu	TV2
   1808 0000EA12 14 40 0F AE             	jmp    	QSORRY		; if not, say "Sorry"
   1809 0000EA16                        TV2
   1810 0000EA16 09 40 08 F1             	lw      r1,VARBGN   ; put address of array element...
   1811 0000EA1A 22 21                   	sub     r1,r2       ; into r1 (neg. offset is used)
   1812 0000EA1C 05 AE                   	br      TSTVRT
   1813 0000EA1E                        TV1	
   1814 0000EA1E 0D AF                       call    getVarName      ; get variable name
   1815 0000EA20 07 A8                       beq     tstv_notfound   ; if not, set Z=1 and return
   1816 0000EA22 50 12                       lw		r2,r5
   1817 0000EA24 45 AF                       call    findVar     ; find or allocate
   1818 0000EA26 04 A8                       beq		tstv_notfound
   1819 0000EA28                        TSTVRT
   1820 0000EA28 E2 F5                   	lw		r5,2[sp]
   1821 0000EA2A E0 FF                   	lw		lr,[sp]
   1822 0000EA2C 06 6E                   	add		sp,sp,#6    ; Z=0 (found)
   1823 0000EA2E F0 80                   	ret
   1824 0000EA30                        tstv_notfound
   1825 0000EA30 E2 F5                   	lw		r5,2[sp]
   1826 0000EA32 E0 FF                       lw      lr,[sp]
   1827 0000EA34 06 6E                       add     sp,sp,#6
   1828 0000EA36 00 11                       lw      r1,#0       ; Z=1 if not found
   1829 0000EA38 F0 80                       ret
                                        
                                        
                                        ; Returns
                                        ;   r1 = 3 character variable name + type
                                        ;
   1835 0000EA3A                        getVarName
   1836 0000EA3A FA 6E                       sub     sp,sp,#6
   1837 0000EA3C E0 DF                       sw      lr,[sp]
   1838 0000EA3E E4 D5                       sw		r5,4[sp]
                                        
   1840 0000EA40 80 E1                       lb      r1,[r8]     ; get first character
   1841 0000EA42 E2 D1                       sw		r1,2[sp]	; save off current name
   1842 0000EA44 19 BF                       call    isAlpha
   1843 0000EA46 2F A8                       beq     gvn1
   1844 0000EA48 02 15                       lw      r5,#2       ; loop twice more
                                        
                                        	; check for second/third character
   1847 0000EA4A                        gvn4
   1848 0000EA4A 01 68                   	add     r8,r8,#1
   1849 0000EA4C 80 E1                   	lb      r1,[r8]     ; do we have another char ?
   1850 0000EA4E 24 BF                   	call    isAlnum
   1851 0000EA50 12 A8                   	beq     gvn2        ; nope
   1852 0000EA52 E2 F1                   	lw      r1,2[sp]    ; get varname
   1853 0000EA54 81 31                   	shl     r1,#1       ; shift left by eight
   1854 0000EA56 81 31                   	shl     r1,#1       ; shift left by eight
   1855 0000EA58 81 31                   	shl     r1,#1       ; shift left by eight
   1856 0000EA5A 81 31                   	shl     r1,#1       ; shift left by eight
   1857 0000EA5C 81 31                   	shl     r1,#1       ; shift left by eight
   1858 0000EA5E 81 31                   	shl     r1,#1       ; shift left by eight
   1859 0000EA60 81 31                   	shl     r1,#1       ; shift left by eight
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 32
noc_boot21.a
   1860 0000EA62 81 31                   	shl     r1,#1       ; shift left by eight
   1861 0000EA64 80 E2                   	lb      r2,[r8]
   1862 0000EA66 26 21                   	or      r1,r2       ; add in new char
   1863 0000EA68 E2 D1                       sw      r1,2[sp]   ; save off name again
   1864 0000EA6A FF 65                       sub		r5,r5,#1
   1865 0000EA6C EE B9                       bne     gvn4
                                        
                                            ; now ignore extra variable name characters
   1868 0000EA6E                        gvn6
   1869 0000EA6E 01 68                       add     r8,r8,#1
   1870 0000EA70 80 E1                       lb      r1,[r8]
   1871 0000EA72 12 BF                       call    isAlnum
   1872 0000EA74 FC B9                       bne     gvn6        ; keep looping as long as we have identifier chars
                                            
   1874 0000EA76                        gvn2
   1875 0000EA76 80 E1                   	lb		r1,[r8]
   1876 0000EA78 FD 4F 1B 10                 cmp     r1,#'%'
   1877 0000EA7C 05 A8                       beq     gvn3
   1878 0000EA7E FD 4F 1C 10                 cmp     r1,#'$'
   1879 0000EA82 02 A8                       beq     gvn3
   1880 0000EA84 00 11                       lw      r1,#0
   1881 0000EA86 FF 68                       sub     r8,r8,#1
                                        
                                            ; insert variable type indicator and return
   1884 0000EA88                        gvn3
   1885 0000EA88 01 68                       add     r8,r8,#1
   1886 0000EA8A E2 F2                       lw      r2,2[sp]
   1887 0000EA8C 81 32                       shl     r2,#1
   1888 0000EA8E 81 32                       shl     r2,#1
   1889 0000EA90 81 32                       shl     r2,#1
   1890 0000EA92 81 32                       shl     r2,#1
   1891 0000EA94 81 32                       shl     r2,#1
   1892 0000EA96 81 32                       shl     r2,#1
   1893 0000EA98 81 32                       shl     r2,#1
   1894 0000EA9A 81 32                       shl     r2,#1
   1895 0000EA9C 26 21                       or      r1,r2       ; add in variable type
   1896 0000EA9E E0 FF                       lw      lr,[sp]
   1897 0000EAA0 E4 F5                       lw		r5,4[sp]
   1898 0000EAA2 06 6E                       add     sp,sp,#6   ; return Z = 0, r1 = varname
   1899 0000EAA4 F0 80                       ret
                                        
                                            ; not a variable name
   1902 0000EAA6                        gvn1
   1903 0000EAA6 E0 FF                       lw      lr,[sp]
   1904 0000EAA8 E4 F5                       lw		r5,4[sp]
   1905 0000EAAA 06 6E                       add     sp,sp,#6
   1906 0000EAAC 00 11                       lw      r1,#0       ; return Z = 1 if not a varname
   1907 0000EAAE F0 80                       ret
                                        
                                        
                                        ; Find variable
                                        ;   r1 = varname
                                        ;	r2 = allocate flag
                                        ; Returns
                                        ;   r1 = variable address, Z =0 if found / allocated, Z=1 if not found
                                        
   1916 0000EAB0                        findVar
   1917 0000EAB0 FC 6E                       sub     sp,sp,#4
   1918 0000EAB2 E0 DF                       sw      lr,[sp]
   1919 0000EAB4 E2 D7                       sw      r7,2[sp]
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 33
noc_boot21.a
   1920 0000EAB6 09 40 08 F3                 lw      r3,VARBGN
   1921 0000EABA                        fv4
   1922 0000EABA 30 F7                       lw      r7,[r3]     ; get varname / type
   1923 0000EABC 0A A8                       beq     fv3         ; no more vars ?
   1924 0000EABE 7D 21                       cmp     r1,r7       ; match ?
   1925 0000EAC0 0B A8                       beq     fv1
   1926 0000EAC2 08 63                       add     r3,r3,#8    ; move to next var
   1927 0000EAC4 0A 40 00 F7                 lw      r7,STKBOT
   1928 0000EAC8 7D 23                       cmp     r3,r7
   1929 0000EACA F7 B0                       blt     fv4         ; loop back to look at next var
                                        
                                            ; variable not found
                                            ; no more memory
   1933 0000EACC 2E 4F 0E 11                 lea     r1,msgVarSpace
   1934 0000EAD0 F6 AE                       br      ERROR
                                        ;    lw      lr,[sp]
                                        ;    lw      r7,2[sp]
                                        ;    add     sp,sp,#4
                                        ;    lw      r1,#0
                                        ;    ret
                                        
                                            ; variable not found
                                            ; allocate new ?
   1943 0000EAD2                        fv3
   1944 0000EAD2 26 22                   	or		r2,r2
   1945 0000EAD4 06 A8                   	beq		fv2
   1946 0000EAD6 30 D1                       sw      r1,[r3]     ; save varname / type
                                            ; found variable
                                            ; return address
   1949 0000EAD8                        fv1
   1950 0000EAD8 34 11                       add     r1,r3,#4
   1951 0000EADA E0 FF                       lw      lr,[sp]
   1952 0000EADC E2 F7                       lw      r7,2[sp]
   1953 0000EADE 04 6E                       add     sp,sp,#4    ; Z = 0, r1 = address
   1954 0000EAE0 F0 80                       ret
                                        
                                            ; didn't find var and not allocating
   1957 0000EAE2                        fv2
   1958 0000EAE2 E0 FF                       lw      lr,[sp]
   1959 0000EAE4 E2 F7                       lw      r7,2[sp]
   1960 0000EAE6 04 6E                       add     sp,sp,#4    ; Z = 0, r1 = address
   1961 0000EAE8 00 11                   	lw		r1,#0		; Z = 1, r1 = 0
   1962 0000EAEA F0 80                       ret
                                        
                                        
                                        ; ===== Multiplies the 32 bit values in r1 and r2, returning
                                        ;	the 32 bit result in r1.
                                        ;
                                        
   1969 0000EAEC                        MULT32
   1970 0000EAEC FA 6E                   	sub		sp,sp,#6
   1971 0000EAEE E0 D5                   	sw		r5,[sp]		; w
   1972 0000EAF0 E2 D6                   	sw		r6,2[sp]	; s
   1973 0000EAF2 E4 D7                   	sw		r7,4[sp]
                                        
   1975 0000EAF4 00 15                   	lw		r5,#0		; w = 0;
   1976 0000EAF6 10 16                   	lw		r6,r1
   1977 0000EAF8 24 26                   	xor		r6,r2		; s = a ^ b
   1978 0000EAFA 16 21                   	or		r1,r1
   1979 0000EAFC 01 AB                   	bpl		mult1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 34
noc_boot21.a
   1980 0000EAFE 20 31                   	neg		r1
   1981 0000EB00                        mult1
   1982 0000EB00 26 22                   	or		r2,r2
   1983 0000EB02 01 AB                   	bpl		mult2
   1984 0000EB04 20 32                   	neg		r2
   1985 0000EB06                        mult2
   1986 0000EB06 10 17                   	lw		r7,r1
   1987 0000EB08 51 37                   	and		r7,#1
   1988 0000EB0A 01 A8                   	beq		mult3
   1989 0000EB0C 20 25                   	add		r5,r2		; w += b
   1990 0000EB0E                        mult3
   1991 0000EB0E 81 32                   	shl		r2,#1		; b <<= 1
   1992 0000EB10 A1 31                   	shr		r1,#1		; a >>= 1
   1993 0000EB12 F9 B9                   	bne		mult2       ; a = 0 ?
   1994 0000EB14                        mult4
   1995 0000EB14 66 26                       or      r6,r6
   1996 0000EB16 01 AB                   	bpl		mult5
   1997 0000EB18 20 35                   	neg		r5
   1998 0000EB1A                        mult5
   1999 0000EB1A 50 11                   	lw		r1,r5
   2000 0000EB1C E4 F7                   	lw		r7,4[sp]
   2001 0000EB1E E2 F6                   	lw		r6,2[sp]
   2002 0000EB20 E0 F5                   	lw		r5,[sp]
   2003 0000EB22 06 6E                   	add		sp,sp,#6
   2004 0000EB24 F0 80                   	ret
                                        
                                        
                                        ; ===== Divide the 32 bit value in r2 by the 32 bit value in r3.
                                        ;	Returns the 32 bit quotient in r1, remainder in r2
                                        ;
                                        ; r2 = a
                                        ; r3 = b
                                        ; r6 = remainder
                                        ; r7 = iteration count
                                        ; r8 = sign
                                        ;
                                        
                                        ; q = a / b
                                        ; a = r1
                                        ; b = r2
                                        ; q = r2
                                        
   2022 0000EB26                        DIV32
   2023 0000EB26 26 22                       or      r2,r2       ; check for divide-by-zero
   2024 0000EB28 03 A9                       bne		div6
   2025 0000EB2A 2D 4F 0B 11                 lea		r1,msgDivZero
   2026 0000EB2E C7 AE                       br		ERROR		; divide by zero error
   2027 0000EB30                        div6
   2028 0000EB30 FA 6E                   	sub		sp,sp,#6
   2029 0000EB32 E0 D6                   	sw		r6,[sp]
   2030 0000EB34 E2 D7                   	sw		r7,2[sp]
   2031 0000EB36 E4 D8                   	sw		r8,4[sp]
                                        
   2033 0000EB38 02 40 00 18                 lw      r8,#32      ; iteration count for 32 bits
   2034 0000EB3C 00 16                   	lw		r6,#0		; r = 0
   2035 0000EB3E 20 17                       lw      r7,r2       ; r7 = sign of result
   2036 0000EB40 14 27                       xor     r7,r1
   2037 0000EB42 16 21                   	or	    r1,r1	    ; take absolute value of r1 (a)
   2038 0000EB44 01 AB                   	bpl     div1
   2039 0000EB46 20 31                   	neg     r1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 35
noc_boot21.a
   2040 0000EB48                        div1
   2041 0000EB48 26 22                       or      r2,r2	    ; take absolute value of r2 (b)
   2042 0000EB4A 01 AB                   	bpl	    div2
   2043 0000EB4C 20 32                   	neg     r2
   2044 0000EB4E                        div2
   2045 0000EB4E 81 31                   	shl		r1,#1		; a <<= 1
   2046 0000EB50 61 26                   	adc		r6,r6		; r <<= 1
   2047 0000EB52 6D 22                   	cmp		r2,r6		; b < r ?
   2048 0000EB54 02 A7                   	bgtu	div4
   2049 0000EB56 22 26                   	sub		r6,r2		; r -= b
   2050 0000EB58 61 31                   	or      r1,#1       ; a |= 1
   2051 0000EB5A                        div4
   2052 0000EB5A FF 68                   	sub		r8,r8,#1
   2053 0000EB5C F8 B9                       bne     div2        ; n--
   2054 0000EB5E 76 27                   	or      r7,r7
   2055 0000EB60 01 AB                   	bpl     div5
   2056 0000EB62 20 31                   	neg     r1
   2057 0000EB64                        div5
   2058 0000EB64 60 12                   	lw		r2,r6		; r2 = r
   2059 0000EB66 E2 F7                   	lw		r7,2[sp]
   2060 0000EB68 E4 F8                   	lw		r8,4[sp]
   2061 0000EB6A E0 F6                   	lw		r6,[sp]
   2062 0000EB6C 06 6E                   	add		sp,sp,#6
   2063 0000EB6E F0 80                   	ret
                                        
                                        ; ===== The PEEK function returns the byte stored at the address
                                        ;	contained in the following expression.
                                        ;
   2068 0000EB70                        PEEK
   2069 0000EB70 29 BF                   	call	PARN		; get the memory address
   2070 0000EB72 10 E1                   	lb		r1,[r1]		; get the addressed byte
   2071 0000EB74 0E 21                   	zxb		r1			; upper 3 bytes will be zero
   2072 0000EB76 E0 FF                   	lw		lr,[sp]	; and return it
   2073 0000EB78 06 6E                   	add		sp,sp,#6
   2074 0000EB7A F0 80                   	ret
                                        
                                        
                                        ; ===== The PEEK function returns the byte stored at the address
                                        ;	contained in the following expression.
                                        ;
   2080 0000EB7C                        PEEKC
   2081 0000EB7C 23 BF                   	call	PARN		; get the memory address
   2082 0000EB7E 5E 31                   	and		r1,#-2		; align to char address
   2083 0000EB80 10 F1                   	lh		r1,[r1]		; get the addressed char
   2084 0000EB82 1E 21                   	zxc		r1
   2085 0000EB84 E0 FF                   	lw		lr,[sp]	; and return it
   2086 0000EB86 06 6E                   	add		sp,sp,#6
   2087 0000EB88 F0 80                   	ret
                                        
                                        
                                        ; ===== The PEEK function returns the byte stored at the address
                                        ;	contained in the following expression.
                                        ;
   2093 0000EB8A                        PEEKW
   2094 0000EB8A 1C BF                   	call	PARN		; get the memory address
   2095 0000EB8C 5C 31                   	and		r1,#-4		; align to word address
   2096 0000EB8E 10 F1                   	lw		r1,[r1]		; get the addressed word
   2097 0000EB90 E0 FF                   	lw		lr,[sp]	; and return it
   2098 0000EB92 06 6E                   	add		sp,sp,#6
   2099 0000EB94 F0 80                   	ret
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 36
noc_boot21.a
                                        
                                        
                                        ; user function call
                                        ; call the user function with argument in r1
   2104 0000EB96                        USRX
   2105 0000EB96 16 BF                   	call	PARN		; get expression value
   2106 0000EB98 E2 D8                   	sw		r8,2[sp]	; save the text pointer
   2107 0000EB9A 02 40 04 F2             	lw      r2,usrJmp   ; get usr vector
   2108 0000EB9E A2 48 0F AF             	call	[r2]		; jump to the subroutine
   2109 0000EBA2 E2 F8                   	lw		r8,2[sp]	; restore the text pointer
   2110 0000EBA4 E0 FF                   	lw		lr,[sp]
   2111 0000EBA6 06 6E                   	add		sp,sp,#6
   2112 0000EBA8 F0 80                   	ret
                                        
                                        
                                        ; ===== The RND function returns a random number from 1 to
                                        ;	the value of the following expression in D0.
                                        ;
   2118 0000EBAA                        RND
   2119 0000EBAA 0C BF                   	call	PARN		; get the upper limit
   2120 0000EBAC 16 21                   	or		r1,r1		; it must be positive and non-zero
   2121 0000EBAE 0E A8                   	beq		rnd2
   2122 0000EBB0 0A AA                   	bmi		rnd1
   2123 0000EBB2 10 12                   	lw		r2,r1
   2124 0000EBB4 CA 4D 04 D0             	sh		r0,RAND+4	; read command
   2125 0000EBB8 CA 4D 00 F1             	lw		r1,RAND		; get a number
   2126 0000EBBC 0E AF                   	call	modu4		; RND(n)=MOD(number,n)+1
   2127 0000EBBE 01 61                   	add		r1,r1,#1
   2128 0000EBC0 E0 FF                   	lw		lr,[sp]
   2129 0000EBC2 06 6E                   	add		sp,sp,#6
   2130 0000EBC4 F0 80                   	ret
   2131 0000EBC6                        rnd1
   2132 0000EBC6 35 4F 0F 11             	lea		r1,msgRNDBad
   2133 0000EBCA 79 AE                   	br		ERROR
   2134 0000EBCC                        rnd2
   2135 0000EBCC CA 4D 04 D0             	sh		r0,RAND+4
   2136 0000EBD0 CA 4D 00 F1             	lw		r1,RAND
   2137 0000EBD4 E0 FF                   	lw		lr,[sp]
   2138 0000EBD6 06 6E                   	add		sp,sp,#6
   2139 0000EBD8 F0 80                   	ret
                                        
                                        
                                        ; r = a mod b
                                        ; a = r2
                                        ; b = r3
                                        ; r = r1
   2146 0000EBDA                        modu4
   2147 0000EBDA FA 6E                   	sub		sp,sp,#6
   2148 0000EBDC E0 D5                   	sw		r5,[sp]
   2149 0000EBDE E2 D6                   	sw		r6,2[sp]
   2150 0000EBE0 E4 D7                   	sw		r7,4[sp]
   2151 0000EBE2 02 40 00 17             	lw      r7,#32		; n = 32
   2152 0000EBE6 00 15                   	lw		r5,#0		; w = 0
   2153 0000EBE8 00 16                   	lw		r6,#0		; r = 0
   2154 0000EBEA                        mod2
   2155 0000EBEA 81 31                   	shl		r1,#1		; a <<= 1
   2156 0000EBEC 61 26                   	adc		r6,r6		; r <<= 1
   2157 0000EBEE 6D 22                   	cmp		r2,r6		; b < r ?
   2158 0000EBF0 01 A7                   	bgtu	mod1
   2159 0000EBF2 22 26                   	sub		r6,r2		; r -= b
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 37
noc_boot21.a
   2160 0000EBF4                        mod1
   2161 0000EBF4 FF 67                   	sub		r7,r7,#1
   2162 0000EBF6 F9 B9                       bne     mod2        ; n--
   2163 0000EBF8 60 11                   	lw		r1,r6
   2164 0000EBFA E0 F5                   	lw		r5,[sp]
   2165 0000EBFC E2 F6                   	lw		r6,2[sp]
   2166 0000EBFE E4 F7                   	lw		r7,4[sp]
   2167 0000EC00 06 6E                   	add		sp,sp,#6
   2168 0000EC02 F0 80                   	ret
                                        
                                        
                                        
                                        ; ===== The ABS function returns an absolute value in r2.
                                        ;
   2174 0000EC04                        ABS
   2175 0000EC04 ED 4F 0E AF             	call	PARN		; get the following expr.'s value
   2176 0000EC08 16 21                   	or		r1,r1
   2177 0000EC0A 01 AB                   	bpl		abs1
   2178 0000EC0C 20 31                   	neg		r1			; if negative, complement it
                                        ;	bmi		QHOW		; if still negative, it was too big
   2180 0000EC0E                        abs1
   2181 0000EC0E E0 FF                   	lw		lr,[sp]
   2182 0000EC10 06 6E                   	add		sp,sp,#6
   2183 0000EC12 F0 80                   	ret
                                        
                                        
                                        ; ===== The SGN function returns the sign in r1. +1,0, or -1
                                        ;
   2188 0000EC14                        SGN
   2189 0000EC14 ED 4F 06 AF             	call	PARN		; get the following expr.'s value
   2190 0000EC18 16 21                   	or		r1,r1
   2191 0000EC1A 04 A8                   	beq		sgn1
   2192 0000EC1C 02 AB                   	bpl		sgn2
   2193 0000EC1E 0F 11                   	lw		r1,#-1
   2194 0000EC20 01 AE                   	br		sgn1
   2195 0000EC22                        sgn2
   2196 0000EC22 01 11                   	lw		r1,#1
   2197 0000EC24                        sgn1
   2198 0000EC24 E0 FF                   	lw		lr,[sp]
   2199 0000EC26 06 6E                   	add		sp,sp,#6
   2200 0000EC28 F0 80                   	ret
                                        
                                        
                                        ; ===== The SIZE function returns the size of free memory in r1.
                                        ;
   2205 0000EC2A                        SIZEX
   2206 0000EC2A 09 40 08 F1             	lw		r1,VARBGN	; get the number of free bytes...
   2207 0000EC2E 09 40 06 F2             	lw		r2,TXTUNF	; between 'TXTUNF' and 'VARBGN'
   2208 0000EC32 22 21                   	sub		r1,r2
   2209 0000EC34 E0 FF                   	lw		lr,[sp]
   2210 0000EC36 06 6E                   	add		sp,sp,#6
   2211 0000EC38 F0 80                   	ret					; return the number in r2
                                        
                                        ; ==== Return the node number that the code is running on
                                        ;
   2215 0000EC3A                        NODENUM
   2216 0000EC3A E4 31                   	tsr		r1,ID
   2217 0000EC3C E0 FF                   	lw		lr,[sp]
   2218 0000EC3E 06 6E                   	add		sp,sp,#6
   2219 0000EC40 F0 80                   	ret
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 38
noc_boot21.a
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                                        ;
                                        ; 'SETVAL' expects a variable, followed by an equal sign and then
                                        ; an expression.  It evaluates the expression and sets the variable
                                        ; to that value.
                                        ;
                                        ; 'FIN' checks the end of a command.  If it ended with ":",
                                        ; execution continues.	If it ended with a CR, it finds the
                                        ; the next line and continues from there.
                                        ;
                                        ; 'ENDCHK' checks if a command is ended with a CR. This is
                                        ; required in certain commands, such as GOTO, RETURN, STOP, etc.
                                        ;
                                        ; 'ERROR' prints the string pointed to by A0. It then prints the
                                        ; line pointed to by CURRNT with a "?" inserted at where the
                                        ; old text pointer (should be on top of the stack) points to.
                                        ; Execution of Tiny BASIC is stopped and a warm start is done.
                                        ; If CURRNT is zero (indicating a direct command), the direct
                                        ; command is not printed. If CURRNT is -1 (indicating
                                        ; 'INPUT' command in progress), the input line is not printed
                                        ; and execution is not terminated but continues at 'INPERR'.
                                        ;
                                        ; Related to 'ERROR' are the following:
                                        ; 'QWHAT' saves text pointer on stack and gets "What?" message.
                                        ; 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                                        ; 'QSORRY' and 'ASORRY' do the same kind of thing.
                                        ; 'QHOW' and 'AHOW' also do this for "How?".
                                        ;
                                        
                                        ; returns
                                        ; r2 = variable's address
                                        ;
   2255 0000EC42                        SETVAL
   2256 0000EC42 FC 6E                       sub     sp,sp,#4
   2257 0000EC44 E0 DF                       sw      lr,[sp]
   2258 0000EC46 01 11                       lw		r1,#1		; allocate var
   2259 0000EC48 EC 4F 0C AF                 call	TSTV		; variable name?
   2260 0000EC4C 03 A9                       bne		sv2
   2261 0000EC4E 34 4F 08 11                	lea		r1,msgVar
   2262 0000EC52 35 AE                      	br		ERROR 
   2263 0000EC54                        sv2
   2264 0000EC54 E2 D1                   	sw      r1,2[sp]    ; save the variable's address
   2265 0000EC56 1D 40 06 AF             	call	TSTC		; get past the "=" sign
   2266 0000EC5A 3D 12                   	db	'=',SV1-*+1
   2267 0000EC5C DD 4F 0E AF             	call	OREXPR		; evaluate the expression
   2268 0000EC60 E2 F2                   	lw      r2,2[sp]    ; get back the variable's address
   2269 0000EC62 20 D1                   	sw      r1,[r2]     ; and save value in the variable
   2270 0000EC64 20 11                   	lw		r1,r2		; return r1 = variable address
   2271 0000EC66 E0 FF                   	lw      lr,[sp]
   2272 0000EC68 04 6E                   	add     sp,sp,#4
   2273 0000EC6A F0 80                   	ret
   2274 0000EC6C                        SV1
   2275 0000EC6C 26 AE                       br	    QWHAT		; if no "=" sign
                                        
                                        
   2278 0000EC6E                        FIN
   2279 0000EC6E FE 6E                   	sub		sp,sp,#2
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 39
noc_boot21.a
   2280 0000EC70 E0 DF                   	sw		lr,[sp]
   2281 0000EC72 1C 40 08 AF             	call	TSTC		; *** FIN ***
   2282 0000EC76 3A 08                   	db	':',FI1-*+1
   2283 0000EC78 02 6E                   	add		sp,sp,#2	; if ":", discard return address
   2284 0000EC7A B7 4F 0C AE             	br		RUNSML		; continue on the same line
   2285 0000EC7E                        FI1
   2286 0000EC7E 1C 40 02 AF             	call	TSTC		; not ":", is it a CR?
   2287 0000EC82 0D 0A                   	db	CR,FI2-*+1
   2288 0000EC84 E0 FF                   	lw		lr,[sp]	; else return to the caller
   2289 0000EC86 02 6E                   	add		sp,sp,#2	; yes, purge return address
   2290 0000EC88 B6 4F 08 AE             	br		RUNNXL		; execute the next line
   2291 0000EC8C                        FI2
   2292 0000EC8C E0 FF                   	lw		lr,[sp]	; else return to the caller
   2293 0000EC8E 02 6E                   	add		sp,sp,#2
   2294 0000EC90 F0 80                   	ret
                                        
                                        
                                        ; Check that there is nothing else on the line
                                        ; Registers Affected
                                        ;   r1
                                        ;
   2301 0000EC92                        ENDCHK
   2302 0000EC92 FE 6E                   	sub		sp,sp,#2
   2303 0000EC94 E0 DF                   	sw		lr,[sp]
   2304 0000EC96 1E 40 09 AF             	call	IGNBLK
   2305 0000EC9A 80 E1                   	lb		r1,[r8]
   2306 0000EC9C FF 4F 13 10             	cmp		r1,#CR		; does it end with a CR?
   2307 0000ECA0 03 A8                   	beq		ec1
   2308 0000ECA2 42 4F 02 11             	lea		r1,msgExtraChars
   2309 0000ECA6 0B AE                   	jmp		ERROR
   2310 0000ECA8                        ec1
   2311 0000ECA8 E0 FF                   	lw		lr,[sp]
   2312 0000ECAA 02 6E                   	add		sp,sp,#2
   2313 0000ECAC F0 80                   	ret
                                        
                                        
   2316 0000ECAE                        TOOBIG
   2317 0000ECAE 40 4F 0D 11             	lea		r1,msgTooBig
   2318 0000ECB2 05 AE                   	br		ERROR
   2319 0000ECB4                        QSORRY
   2320 0000ECB4 2A 4F 03 11                 lea     r1,SRYMSG
   2321 0000ECB8 02 AE                   	br	    ERROR
   2322 0000ECBA                        QWHAT
   2323 0000ECBA 29 4F 0B 11             	lea		r1,msgWhat
   2324 0000ECBE                        ERROR
   2325 0000ECBE 21 40 0D AF             	call	PRMESG		; display the error message
   2326 0000ECC2 08 40 06 F1             	lw		r1,CURRNT	; get the current line number
   2327 0000ECC6 A1 4F 09 A8             	beq		WSTART		; if zero, do a warm start
   2328 0000ECCA 11 10                   	cmp		r1,#-1		; is the line no. pointer = -1?
   2329 0000ECCC C5 4F 0E A8             	beq		INPERR		; if so, redo input
   2330 0000ECD0 80 E5                   	lb		r5,[r8]		; save the char. pointed to
   2331 0000ECD2 80 C0                   	sb		r0,[r8]		; put a zero where the error is
   2332 0000ECD4 08 40 06 F1             	lw		r1,CURRNT	; point to start of current line
   2333 0000ECD8 17 40 07 AF             	call	PRTLN		; display the line in error up to the 0
   2334 0000ECDC 10 16                   	lw      r6,r1       ; save off end pointer
   2335 0000ECDE 80 C5                   	sb		r5,[r8]		; restore the character
   2336 0000ECE0 03 40 0F 11             	lw		r1,#'?'		; display a "?"
   2337 0000ECE4 9C 4F 05 AF             	call	GOOUT
   2338 0000ECE8 00 12                   	lw      r2,#0       ; stop char = 0
   2339 0000ECEA 6F 11                   	sub		r1,r6,#1	; point back to the error char.
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 40
noc_boot21.a
   2340 0000ECEC B6 AF                   	call	PRTSTG		; display the rest of the line
   2341 0000ECEE A0 4F 05 AE             	jmp	    WSTART		; and do a warm start
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** GETLN *** FNDLN (& friends) ***
                                        ;
                                        ; 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                                        ; the character in r3 (given by the caller), then it fills the
                                        ; buffer and echos. It ignores LF's but still echos
                                        ; them back. Control-H is used to delete the last character
                                        ; entered (if there is one), and control-X is used to delete the
                                        ; whole line and start over again. CR signals the end of a line,
                                        ; and causes 'GETLN' to return.
                                        ;
                                        ;
   2357 0000ECF2                        GETLN
   2358 0000ECF2 FC 6E                   	sub		sp,sp,#4
   2359 0000ECF4 E0 DF                   	sw		lr,[sp]
   2360 0000ECF6 E2 D5                   	sw		r5,2[sp]
   2361 0000ECF8 9B 4F 0B AF             	call	GOOUT		; display the prompt
   2362 0000ECFC 01 11                   	lw		r1,#1		; turn on cursor flash
   2363 0000ECFE 03 40 0C C1             	sb		r1,cursFlash
   2364 0000ED02 02 40 00 11             	lw		r1,#' '		; and a space
   2365 0000ED06 9B 4F 04 AF             	call	GOOUT
   2366 0000ED0A 0A 40 0E 18             	lea		r8,BUFFER	; r8 is the buffer pointer
   2367 0000ED0E                        GL1
   2368 0000ED0E 1E 40 03 AF             	call	CHKIO		; check keyboard
   2369 0000ED12 FD B8                   	beq		GL1			; wait for a char. to come in
   2370 0000ED14 FF 4F 18 10             	cmp		r1,#CTRLH	; delete last character?
   2371 0000ED18 14 A8                   	beq		GL3			; if so
   2372 0000ED1A FE 4F 18 10             	cmp		r1,#CTRLX	; delete the whole line?
   2373 0000ED1E 20 A8                   	beq		GL4			; if so
   2374 0000ED20 FF 4F 13 10             	cmp		r1,#CR		; accept a CR
   2375 0000ED24 03 A8                   	beq		GL2
   2376 0000ED26 FE 4F 10 10             	cmp		r1,#' '		; if other control char., discard it
   2377 0000ED2A F1 B4                   	bltu	GL1
   2378 0000ED2C                        GL2
   2379 0000ED2C 80 C1                   	sb		r1,[r8]		; save the char.
   2380 0000ED2E 01 68                   	add		r8,r8,#1
   2381 0000ED30 99 4F 0F AF             	call	GOOUT		; echo the char back out
   2382 0000ED34 8F E1                   	lb      r1,-1[r8]   ; get char back (GOOUT destroys r1)
   2383 0000ED36 FF 4F 13 10             	cmp		r1,#CR		; if it's a CR, end the line
   2384 0000ED3A 25 A8                   	beq		GL7
   2385 0000ED3C F0 4F 83 10             	cmp		r8,#(BUFFER+BUFLEN-1)	; any more room?
   2386 0000ED40 E6 B4                   	bltu	GL1			; yes: get some more, else delete last char.
                                        
   2388 0000ED42                        GL3
   2389 0000ED42 08 11                   	lw		r1,#CTRLH	; delete a char. if possible
   2390 0000ED44 99 4F 05 AF             	call	GOOUT
   2391 0000ED48 02 40 00 11             	lw		r1,#' '
   2392 0000ED4C 99 4F 01 AF             	call	GOOUT
   2393 0000ED50 F5 4F 82 10             	cmp		r8,#BUFFER	; any char.'s left?
   2394 0000ED54 DC B6                   	bleu	GL1			; if not
   2395 0000ED56 08 11                   	lw		r1,#CTRLH	; if so, finish the BS-space-BS sequence
   2396 0000ED58 98 4F 0B AF             	call	GOOUT
   2397 0000ED5C FF 68                   	sub		r8,r8,#1	; decrement the text pointer
   2398 0000ED5E D7 BE                   	br		GL1			; back for more
                                        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 41
noc_boot21.a
   2400 0000ED60                        GL4
   2401 0000ED60 80 11                   	lw		r1,r8		; delete the whole line
   2402 0000ED62 F5 4F 12 15             	sub		r5,r1,#BUFFER   ; figure out how many backspaces we need
   2403 0000ED66 0C A8                   	beq		GL6			; if none needed, brnch
   2404 0000ED68                        GL5	
   2405 0000ED68 08 11                   	lw		r1,#CTRLH	; and display BS-space-BS sequences
   2406 0000ED6A 98 4F 02 AF             	call	GOOUT
   2407 0000ED6E 02 40 00 11             	lw		r1,#' '
   2408 0000ED72 97 4F 0E AF             	call	GOOUT
   2409 0000ED76 08 11                   	lw		r1,#CTRLH
   2410 0000ED78 97 4F 0B AF             	call	GOOUT
   2411 0000ED7C FF 65                   	sub		r5,r5,#1
   2412 0000ED7E F4 B9                   	bne     GL5
   2413 0000ED80                        GL6
   2414 0000ED80 0A 40 0E 18             	lea		r8,BUFFER	; reinitialize the text pointer
   2415 0000ED84 C4 BE                   	br		GL1			; and go back for more
   2416 0000ED86                        GL7
   2417 0000ED86 00 11                   	lw		r1,#0		; turn off cursor flash
   2418 0000ED88 03 40 0C C1             	sb		r1,cursFlash
   2419 0000ED8C 0A 11                   	lw		r1,#LF		; echo a LF for the CR
   2420 0000ED8E 97 4F 00 AF             	call	GOOUT
   2421 0000ED92 E0 FF                   	lw		lr,[sp]
   2422 0000ED94 E2 F5                   	lw		r5,2[sp]
   2423 0000ED96 04 6E                   	add		sp,sp,#4
   2424 0000ED98 F0 80                   	ret
                                        
                                        
                                        ; 'FNDLN' finds a line with a given line no. (in r1) in the
                                        ; text save area.  r9 is used as the text pointer. If the line
                                        ; is found, r9 will point to the beginning of that line
                                        ; (i.e. the high byte of the line no.), and flags are Z.
                                        ; If that line is not there and a line with a higher line no.
                                        ; is found, r9 points there and flags are NC & NZ. If we reached
                                        ; the end of the text save area and cannot find the line, flags
                                        ; are C & NZ.
                                        ; Z=1 if line found
                                        ; N=1 if end of text save area
                                        ; Z=0 & N=0 if higher line found
                                        ;
                                        ; 'FNDLN' will initialize r9 to the beginning of the text save
                                        ; area to start the search. Some other entries of this routine
                                        ; will not initialize r9 and do the search.
                                        ; 'FNDLNP' will start with r9 and search for the line no.
                                        ; 'FNDNXT' will bump r9 by 2, find a CR and then start search.
                                        ; 'FNDSKP' uses r9 to find a CR, and then starts the search.
                                        ; return Z=1 if line is found, r9 = pointer to line
                                        ;
                                        ; Parameters
                                        ;	r1 = line number to find
                                        ;
   2450 0000ED9A                        FNDLN
   2451 0000ED9A 00 40 11 10             	cmp		r1,#0xFFFF	; line no. must be < 65535
   2452 0000ED9E 03 A6                   	bleu	fl1
   2453 0000EDA0 33 4F 02 11             	lea		r1,msgLineRange
   2454 0000EDA4 8C BE                   	br		ERROR
   2455 0000EDA6                        fl1
   2456 0000EDA6 08 4E 06 F9             	lw		r9,TXTBGN	; init. the text save pointer
                                        
   2458 0000EDAA                        FNDLNP
   2459 0000EDAA 09 40 06 FA             	lw		r10,TXTUNF	; check if we passed the end
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 42
noc_boot21.a
   2460 0000EDAE FF 6A                   	sub		r10,r10,#1
   2461 0000EDB0 AD 29                   	cmp		r9,r10
   2462 0000EDB2 0F A7                   	bgtu	FNDRET		; if so, return with Z=0 & C=1
   2463 0000EDB4 90 E3                   	lb		r3,[r9]		; get low order byte of line number
   2464 0000EDB6 0E 23                   	zxb		r3
   2465 0000EDB8 91 E2                   	lb		r2,1[r9]	; get high order byte
   2466 0000EDBA 0E 22                   	zxb		r2
   2467 0000EDBC 81 32                   	shl		r2,#1
   2468 0000EDBE 81 32                   	shl		r2,#1
   2469 0000EDC0 81 32                   	shl		r2,#1
   2470 0000EDC2 81 32                   	shl		r2,#1
   2471 0000EDC4 81 32                   	shl		r2,#1
   2472 0000EDC6 81 32                   	shl		r2,#1
   2473 0000EDC8 81 32                   	shl		r2,#1
   2474 0000EDCA 81 32                   	shl		r2,#1
   2475 0000EDCC 36 22                   	or		r2,r3		; build whole line number
   2476 0000EDCE 2D 21                   	cmp		r1,r2		; is this the line we want?
   2477 0000EDD0 01 A7                   	bgtu	FNDNXT		; no, not there yet
   2478 0000EDD2                        FNDRET
   2479 0000EDD2 F0 80                   	ret			; return the cond. codes
                                        
   2481 0000EDD4                        FNDNXT
   2482 0000EDD4 02 69                   	add		r9,r9,#2	; find the next line
                                        
   2484 0000EDD6                        FNDSKP
   2485 0000EDD6 90 E2                   	lb		r2,[r9]
   2486 0000EDD8 01 69                   	add		r9,r9,#1
   2487 0000EDDA FF 4F 23 10             	cmp		r2,#CR		; try to find a CR
   2488 0000EDDE FB B9                   	bne		FNDSKP		; keep looking
   2489 0000EDE0 E4 BE                   	br		FNDLNP		; check if end of text
                                        
                                        
                                        ;******************************************************************
                                        ; 'MVUP' moves a block up from where r1 points to where r2 points
                                        ; until r1=r3
                                        ;
   2496 0000EDE2                        MVUP1
   2497 0000EDE2 10 E4                   	lb		r4,[r1]
   2498 0000EDE4 20 C4                   	sb		r4,[r2]
   2499 0000EDE6 01 61                   	add		r1,r1,#1
   2500 0000EDE8 01 62                   	add		r2,r2,#1
   2501 0000EDEA                        MVUP
   2502 0000EDEA 3D 21                   	cmp		r1,r3
   2503 0000EDEC FA B9                   	bne		MVUP1
   2504 0000EDEE                        MVRET
   2505 0000EDEE F0 80                   	ret
                                        
                                        
                                        ; 'MVDOWN' moves a block down from where r1 points to where r2
                                        ; points until r1=r3
                                        ;
   2511 0000EDF0                        MVDOWN1
   2512 0000EDF0 FF 61                   	sub		r1,r1,#1
   2513 0000EDF2 FF 62                   	sub		r2,r2,#1
   2514 0000EDF4 10 E4                   	lb		r4,[r1]
   2515 0000EDF6 20 C4                   	sb		r4,[r2]
   2516 0000EDF8                        MVDOWN
   2517 0000EDF8 3D 21                   	cmp		r1,r3
   2518 0000EDFA FA B9                   	bne		MVDOWN1
   2519 0000EDFC F0 80                   	ret
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 43
noc_boot21.a
                                        
                                        
                                        ; 'POPA' restores the 'FOR' loop variable save area from the stack
                                        ;
                                        ; 'PUSHA' stacks for 'FOR' loop variable save area onto the stack
                                        ;
                                        ; Note: a single zero word is stored on the stack in the
                                        ; case that no FOR loops need to be saved. This needs to be
                                        ; done because PUSHA / POPA is called all the time.
                                        
   2530 0000EDFE                        POPA
   2531 0000EDFE E0 F1                   	lw		r1,[sp]		; restore LOPVAR, but zero means no more
   2532 0000EE00 08 40 0C D1             	sw		r1,LOPVAR
   2533 0000EE04 0E A8                   	beq		PP1
   2534 0000EE06 E8 F1                   	lw		r1,8[sp]	; if not zero, restore the rest
   2535 0000EE08 09 40 04 D1             	sw		r1,LOPPT
   2536 0000EE0C E6 F1                   	lw		r1,6[sp]
   2537 0000EE0E 09 40 02 D1             	sw		r1,LOPLN
   2538 0000EE12 E4 F1                   	lw		r1,4[sp]
   2539 0000EE14 09 40 00 D1             	sw		r1,LOPLMT
   2540 0000EE18 E2 F1                   	lw		r1,2[sp]
   2541 0000EE1A 08 40 0E D1             	sw		r1,LOPINC
   2542 0000EE1E 0A 6E                   	add		sp,sp,#10
   2543 0000EE20 F0 80                   	ret
   2544 0000EE22                        PP1
   2545 0000EE22 02 6E                   	add		sp,sp,#2
   2546 0000EE24 F0 80                   	ret
                                        
                                        
   2549 0000EE26                        PUSHA
   2550 0000EE26 0A 40 00 F1             	lw		r1,STKBOT	; Are we running out of stack room?
   2551 0000EE2A 0A 61                   	add		r1,r1,#10	; we might need this many bytes
   2552 0000EE2C 1D 2E                   	cmp		sp,r1
   2553 0000EE2E 42 B4                   	bltu	QSORRY		; out of stack space
   2554 0000EE30 08 40 0C F1             	lw		r1,LOPVAR	; save loop variables
   2555 0000EE34 0F A8                   	beq		PU1			; if LOPVAR is zero, that's all
   2556 0000EE36 F6 6E                   	sub		sp,sp,#10
   2557 0000EE38 E0 D1                   	sw		r1,[sp]
   2558 0000EE3A 09 40 04 F1             	lw		r1,LOPPT
   2559 0000EE3E E8 D1                   	sw		r1,8[sp]	; else save all the others
   2560 0000EE40 09 40 02 F1             	lw		r1,LOPLN
   2561 0000EE44 E6 D1                   	sw		r1,6[sp]
   2562 0000EE46 09 40 00 F1             	lw		r1,LOPLMT
   2563 0000EE4A E4 D1                   	sw		r1,4[sp]
   2564 0000EE4C 08 40 0E F1             	lw		r1,LOPINC
   2565 0000EE50 E2 D1                   	sw		r1,2[sp]
   2566 0000EE52 F0 80                   	ret
   2567 0000EE54                        PU1
   2568 0000EE54 FE 6E                   	sub		sp,sp,#2
   2569 0000EE56 E0 D1                   	sw		r1,[sp]
   2570 0000EE58 F0 80                   	ret
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** PRTSTG *** QTSTG *** PRTNUM *** PRTLN ***
                                        ;
                                        ; 'PRTSTG' prints a string pointed to by r3. It stops printing
                                        ; and returns to the caller when either a CR is printed or when
                                        ; the next byte is the same as what was passed in r4 by the
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 44
noc_boot21.a
                                        ; caller.
                                        ;
                                        ; 'QTSTG' looks for an underline (back-arrow on some systems),
                                        ; single-quote, or double-quote.  If none of these are found, returns
                                        ; to the caller.  If underline, outputs a CR without a LF.  If single
                                        ; or double quote, prints the quoted string and demands a matching
                                        ; end quote.  After the printing, the next 2 bytes of the caller are
                                        ; skipped over (usually a short brnch instruction).
                                        ;
                                        ; 'PRTNUM' prints the 32 bit number in r3, leading blanks are added if
                                        ; needed to pad the number of spaces to the number in r4.
                                        ; However, if the number of digits is larger than the no. in
                                        ; r4, all digits are printed anyway. Negative sign is also
                                        ; printed and counted in, positive sign is not.
                                        ;
                                        ; 'PRTLN' prints the saved text line pointed to by r3
                                        ; with line no. and all.
                                        ;
                                        
                                        ; r1 = pointer to string
                                        ; r2 = stop character
                                        ; return r1 = pointer to end of line + 1
                                        
   2603 0000EE5A                        PRTSTG
   2604 0000EE5A F8 6E                       sub     sp,sp,#8
   2605 0000EE5C E0 DF                       sw      lr,[sp]
   2606 0000EE5E E2 D5                       sw      r5,2[sp]
   2607 0000EE60 E4 D6                       sw      r6,4[sp]
   2608 0000EE62 E6 D7                       sw      r7,6[sp]
   2609 0000EE64 10 15                       lw      r5,r1       ; r5 = pointer
   2610 0000EE66 20 16                       lw      r6,r2       ; r6 = stop char
   2611 0000EE68                        PS1
   2612 0000EE68 50 E7                       lb      r7,[r5]     ; get a text character
   2613 0000EE6A 01 65                       add     r5,r5,#1
   2614 0000EE6C 6D 27                   	cmp     r7,r6		; same as stop character?
   2615 0000EE6E 09 A8                   	beq	    PRTRET		; if so, return
   2616 0000EE70 70 11                   	lw      r1,r7
   2617 0000EE72 8F 4F 0E AF             	call	GOOUT		; display the char.
   2618 0000EE76 FF 4F 73 10             	cmp     r7,#CR      ; is it a C.R.?
   2619 0000EE7A F6 B9                   	bne	    PS1		    ; no, go back for more
   2620 0000EE7C 0A 11                   	lw      r1,#LF      ; yes, add a L.F.
   2621 0000EE7E 8F 4F 08 AF             	call	GOOUT
   2622 0000EE82                        PRTRET
   2623 0000EE82 70 12                       lw      r2,r7       ; return r2 = stop char
   2624 0000EE84 50 11                   	lw		r1,r5		; return r1 = line pointer
   2625 0000EE86 E2 F5                       lw      r5,2[sp]
   2626 0000EE88 E4 F6                       lw      r6,4[sp]
   2627 0000EE8A E6 F7                       lw      r7,6[sp]
   2628 0000EE8C E0 FF                       lw      lr,[sp]
   2629 0000EE8E 08 6E                       add     sp,sp,#8
   2630 0000EE90 F0 80                       ret			        ; then return
                                        
                                        
   2633 0000EE92                        QTSTG
   2634 0000EE92 FE 6E                   	sub		sp,sp,#2
   2635 0000EE94 E0 DF                   	sw		lr,[sp]
   2636 0000EE96 B7 AF                   	call	TSTC		; *** QTSTG ***
   2637 0000EE98 22 18                   	db	'"',QT3-*+1
   2638 0000EE9A 02 40 02 12             	lw		r2,#'"'		; it is a "
   2639 0000EE9E                        QT1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 45
noc_boot21.a
   2640 0000EE9E 80 11                   	lw		r1,r8
   2641 0000EEA0 DC BF                   	call	PRTSTG		; print until another
   2642 0000EEA2 10 18                   	lw		r8,r1
   2643 0000EEA4 FF 4F 26 10             	cmp		r2,#LF		; was last one a CR?
   2644 0000EEA8 0E A9                   	bne		QT2
   2645 0000EEAA 02 6E                   	add		sp,sp,#2
   2646 0000EEAC A5 4F 06 AE             	br		RUNNXL		; if so, run next line
   2647 0000EEB0                        QT3
   2648 0000EEB0 AA AF                   	call	TSTC		; is it a single quote?
   2649 0000EEB2 27 08                   	db	"'",QT4-*+1
   2650 0000EEB4 02 40 07 12             	lw		r2,#''''	; if so, do same as above
   2651 0000EEB8 F2 BE                   	br		QT1
   2652 0000EEBA                        QT4
   2653 0000EEBA A5 AF                   	call	TSTC		; is it an underline?
   2654 0000EEBC 5F 10                   	db	'_',QT5-*+1
   2655 0000EEBE 00 40 0D 11             	lw		r1,#CR		; if so, output a CR without LF
   2656 0000EEC2 8D 4F 06 AF             	call	GOOUT
   2657 0000EEC6                        QT2
   2658 0000EEC6 E0 FF                   	lw		lr,[sp]
   2659 0000EEC8 02 6E                   	add		sp,sp,#2
   2660 0000EECA F2 80                   	jmp		2[lr]		; skip over 2 bytes when returning
   2661 0000EECC                        QT5						; not " ' or _
   2662 0000EECC E0 FF                   	lw		lr,[sp]
   2663 0000EECE 02 6E                   	add		sp,sp,#2
   2664 0000EED0 F0 80                   	ret
                                        
                                        
                                        ; Output a CR LF sequence
                                        ;
   2669 0000EED2                        prCRLF
   2670 0000EED2 FE 6E                   	sub		sp,sp,#2
   2671 0000EED4 E0 DF                   	sw		lr,[sp]
   2672 0000EED6 00 40 0D 11             	lw		r1,#CR
   2673 0000EEDA 8C 4F 0A AF             	call	GOOUT
   2674 0000EEDE 0A 11                   	lw		r1,#LF
   2675 0000EEE0 8C 4F 07 AF             	call	GOOUT
   2676 0000EEE4 E0 FF                   	lw		lr,[sp]
   2677 0000EEE6 02 6E                   	add		sp,sp,#2
   2678 0000EEE8 F0 80                   	ret
                                        
                                        
                                        ; r1 = number to print
                                        ; r2 = number of digits
                                        ; Register Usage
                                        ;	r5 = number of padding spaces
   2685 0000EEEA                        PRTNUM
   2686 0000EEEA F8 6E                   	sub		sp,sp,#8
   2687 0000EEEC E0 DF                   	sw		lr,[sp]
   2688 0000EEEE E2 D5                   	sw		r5,2[sp]
   2689 0000EEF0 E4 D6                   	sw		r6,4[sp]
   2690 0000EEF2 E6 D7                   	sw		r7,6[sp]
                                        
   2692 0000EEF4 0A 40 02 17             	lea		r7,NUMWKA	; r7 = pointer to numeric work area
   2693 0000EEF8 10 16                   	lw		r6,r1		; save number for later
   2694 0000EEFA 20 15                   	lw		r5,r2		; r5 = min number of chars
   2695 0000EEFC 16 21                   	
   2696 0000EEFE 02 AB                   	bpl		PN1			; if not
   2697 0000EF00 20 31                   	neg		r1			; else make it positive
   2698 0000EF02 FF 65                   	sub		r5,r5,#1	; one less for width count
   2699 0000EF04                        PN1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 46
noc_boot21.a
   2700 0000EF04 0A 12                   	lw		r2,#10		; divide by 10
   2701 0000EF06 E0 4F 0E AF             	call	DIV32
   2702 0000EF0A 30 62                   	add		r2,r2,#'0'	; convert remainder to ascii
   2703 0000EF0C 70 C2                   	sb		r2,[r7]		; and store in buffer
   2704 0000EF0E 01 67                   	add		r7,r7,#1
   2705 0000EF10 FF 65                   	sub		r5,r5,#1	; decrement width
   2706 0000EF12 10 10                   	cmp		r1,#0
   2707 0000EF14 F7 B9                   	bne		PN1
   2708 0000EF16                        PN6
   2709 0000EF16 56 25                   	or		r5,r5		; test pad count
   2710 0000EF18 06 A2                   	ble		PN4			; skip padding if not needed
   2711 0000EF1A                        PN3
   2712 0000EF1A 02 40 00 11             	lw		r1,#' '		; display the required leading spaces
   2713 0000EF1E 8A 4F 08 AF             	call	GOOUT
   2714 0000EF22 FF 65                   	sub		r5,r5,#1
   2715 0000EF24 FA B9                   	bne		PN3
   2716 0000EF26                        PN4
   2717 0000EF26 66 26                   	or		r6,r6		; is number negative?
   2718 0000EF28 04 AB                   	bpl		PN5
   2719 0000EF2A 02 40 0D 11             	lw		r1,#'-'		; if so, display the sign
   2720 0000EF2E 8A 4F 00 AF             	call	GOOUT
   2721 0000EF32                        PN5
   2722 0000EF32 FF 67                   	sub		r7,r7,#1
   2723 0000EF34 70 E1                   	lb		r1,[r7]		; now unstack the digits and display
   2724 0000EF36 89 4F 0C AF             	call	GOOUT
   2725 0000EF3A F5 4F 7E 10             	cmp		r7,#NUMWKA
   2726 0000EF3E F9 B7                   	bgtu	PN5
   2727 0000EF40                        PNRET
   2728 0000EF40 E0 FF                   	lw		lr,[sp]
   2729 0000EF42 E2 F5                   	lw		r5,2[sp]
   2730 0000EF44 E4 F6                   	lw		r6,4[sp]
   2731 0000EF46 E6 F7                   	lw		r7,6[sp]
   2732 0000EF48 08 6E                   	add		sp,sp,#8
   2733 0000EF4A F0 80                   	ret
                                        
                                        
                                        ; r1 = number to print
                                        ; r2 = number of digits
   2738 0000EF4C                        PRTHEXNUM
   2739 0000EF4C F6 6E                   	sub		sp,sp,#10
   2740 0000EF4E E0 DF                   	sw		lr,[sp]
   2741 0000EF50 E2 D5                   	sw		r5,2[sp]
   2742 0000EF52 E4 D6                   	sw		r6,4[sp]
   2743 0000EF54 E6 D7                   	sw		r7,6[sp]
   2744 0000EF56 E8 D8                   	sw		r8,8[sp]
                                        
   2746 0000EF58 0A 40 02 17             	lea		r7,NUMWKA	; r7 = pointer to numeric work area
   2747 0000EF5C 10 16                   	lw		r6,r1		; save number for later
   2748 0000EF5E 0A 15                   	lw		r5,#10		; r5 = min number of chars
   2749 0000EF60 10 14                   	lw		r4,r1
   2750 0000EF62 46 24                   	
   2751 0000EF64 03 AB                   	bpl		PHN1		; if not
   2752 0000EF66 20 34                   	neg		r4			; else make it positive
   2753 0000EF68 FF 65                   	sub		r5,r5,#1	; one less for width count
   2754 0000EF6A 0A 18                   	lw		r8,#10		; maximum of 10 digits
   2755 0000EF6C                        PHN1
   2756 0000EF6C 40 11                   	lw		r1,r4
   2757 0000EF6E 00 40 5F 31             	and		r1,#15
   2758 0000EF72 FF 4F 16 10             	cmp		r1,#10
   2759 0000EF76 02 A0                   	blt		PHN7
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 47
noc_boot21.a
   2760 0000EF78 37 61                   	add		r1,r1,#'A'-10
   2761 0000EF7A 01 AE                   	br		PHN8
   2762 0000EF7C                        PHN7
   2763 0000EF7C 30 61                   	add		r1,r1,#'0'		; convert remainder to ascii
   2764 0000EF7E                        PHN8
   2765 0000EF7E 70 C1                   	sb		r1,[r7]		; and store in buffer
   2766 0000EF80 01 67                   	add		r7,r7,#1
   2767 0000EF82 FF 65                   	sub		r5,r5,#1	; decrement width
   2768 0000EF84 A1 34                   	shr		r4,#1
   2769 0000EF86 A1 34                   	shr		r4,#1
   2770 0000EF88 A1 34                   	shr		r4,#1
   2771 0000EF8A A1 34                   	shr		r4,#1
   2772 0000EF8C 02 A8                   	beq		PHN6			; is it zero yet ?
   2773 0000EF8E FF 68                   	sub		r8,r8,#1	; safety
   2774 0000EF90 ED B9                   	bne		PHN1
   2775 0000EF92                        PHN6
   2776 0000EF92 56 25                   	or		r5,r5		; test pad count
   2777 0000EF94 06 A2                   	ble		PHN4			; skip padding if not needed
   2778 0000EF96                        PHN3
   2779 0000EF96 02 40 00 11             	lw		r1,#' '		; display the required leading spaces
   2780 0000EF9A 86 4F 0A AF             	call	GOOUT
   2781 0000EF9E FF 65                   	sub		r5,r5,#1
   2782 0000EFA0 FA B9                   	bne		PHN3
   2783 0000EFA2                        PHN4
   2784 0000EFA2 66 26                   	or		r6,r6		; is number negative?
   2785 0000EFA4 04 AB                   	bpl		PHN5
   2786 0000EFA6 02 40 0D 11             	lw		r1,#'-'		; if so, display the sign
   2787 0000EFAA 86 4F 02 AF             	call	GOOUT
   2788 0000EFAE                        PHN5
   2789 0000EFAE FF 67                   	sub		r7,r7,#1
   2790 0000EFB0 70 E1                   	lb		r1,[r7]		; now unstack the digits and display
   2791 0000EFB2 85 4F 0E AF             	call	GOOUT
   2792 0000EFB6 F5 4F 7E 10             	cmp		r7,#NUMWKA
   2793 0000EFBA F9 B7                   	bgtu	PHN5
   2794 0000EFBC                        PHNRET
   2795 0000EFBC E0 FF                   	lw		lr,[sp]
   2796 0000EFBE E2 F5                   	lw		r5,2[sp]
   2797 0000EFC0 E4 F6                   	lw		r6,4[sp]
   2798 0000EFC2 E6 F7                   	lw		r7,6[sp]
   2799 0000EFC4 E8 F8                   	lw		r8,8[sp]
   2800 0000EFC6 0A 6E                   	add		sp,sp,#10
   2801 0000EFC8 F0 80                   	ret
                                        
                                        
                                        ; r1 = pointer to line
                                        ; returns r1 = pointer to end of line + 1
   2806 0000EFCA                        PRTLN
   2807 0000EFCA FC 6E                       sub     sp,sp,#4
   2808 0000EFCC E0 DF                       sw      lr,[sp]
   2809 0000EFCE E2 D5                       sw      r5,2[sp]
   2810 0000EFD0 12 15                       add     r5,r1,#2
   2811 0000EFD2 5E E1                       lb		r1,-2[r5]	; get the binary line number
   2812 0000EFD4 0E 21                       zxb		r1
   2813 0000EFD6 5F E2                       lb		r2,-1[r5]
   2814 0000EFD8 0E 22                       zxb		r2
   2815 0000EFDA 81 32                       shl		r2,#1
   2816 0000EFDC 81 32                       shl		r2,#1
   2817 0000EFDE 81 32                       shl		r2,#1
   2818 0000EFE0 81 32                       shl		r2,#1
   2819 0000EFE2 81 32                       shl		r2,#1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 48
noc_boot21.a
   2820 0000EFE4 81 32                       shl		r2,#1
   2821 0000EFE6 81 32                       shl		r2,#1
   2822 0000EFE8 81 32                       shl		r2,#1
   2823 0000EFEA 26 21                       or		r1,r2
   2824 0000EFEC 00 12                       lw      r2,#0       ; display a 0 or more digit line no.
   2825 0000EFEE 7D BF                   	call	PRTNUM
   2826 0000EFF0 02 40 00 11             	lw      r1,#' '     ; followed by a blank
   2827 0000EFF4 83 4F 0D AF             	call	GOOUT
   2828 0000EFF8 00 12                   	lw      r2,#0       ; stop char. is a zero
   2829 0000EFFA 50 11                   	lw      r1,r5
   2830 0000EFFC 2E BF                   	call    PRTSTG		; display the rest of the line
   2831 0000EFFE E2 F5                   	lw      r5,2[sp]
   2832 0000F000 E0 FF                   	lw      lr,[sp]
   2833 0000F002 04 6E                   	add     sp,sp,#4
   2834 0000F004 F0 80                   	ret
                                        
                                        
                                        ; ===== Test text byte following the call to this subroutine. If it
                                        ;	equals the byte pointed to by r8, return to the code following
                                        ;	the call. If they are not equal, brnch to the point
                                        ;	indicated by the offset byte following the text byte.
                                        ;
                                        ; Registers Affected
                                        ;   r3,r8
                                        ; Returns
                                        ;	r8 = updated text pointer
                                        ;
   2847 0000F006                        TSTC
   2848 0000F006 FC 6E                   	sub		sp,sp,#4
   2849 0000F008 E0 DF                   	sw		lr,[sp]
   2850 0000F00A E2 D1                   	sw		r1,2[sp]
   2851 0000F00C 2F AF                   	call	IGNBLK		; ignore leading blanks
   2852 0000F00E E0 FF                   	lw		lr,[sp]	; get the return address
   2853 0000F010 F0 E3                   	lb		r3,[lr]	; get the byte to compare
   2854 0000F012 80 E1                   	lb		r1,[r8]
   2855 0000F014 1D 23                   	cmp		r3,r1		; is it = to what r8 points to?
   2856 0000F016 05 A8                   	beq		TC1			; if so
                                        						; If not, add the second
   2858 0000F018 F1 E3                   	lb		r3,1[lr]	; byte following the call to
   2859 0000F01A 30 2F                   	add		lr,r3		; the return address.
   2860 0000F01C E2 F1                   	lw		r1,2[sp]
   2861 0000F01E 04 6E                   	add		sp,sp,#4
   2862 0000F020 F0 80                   	ret					; jump to the routine
   2863 0000F022                        TC1
   2864 0000F022 01 68                   	add		r8,r8,#1	; if equal, bump text pointer
   2865 0000F024 E2 F1                   	lw		r1,2[sp]
   2866 0000F026 04 6E                   	add     sp,sp,#4
   2867 0000F028 F2 80                   	jmp		2[lr]		; Skip the 2 bytes following
                                        						; the call and continue.
                                        
                                        
                                        ; ===== See if the text pointed to by r8 is a number. If so,
                                        ;	return the number in r2 and the number of digits in r3,
                                        ;	else return zero in r2 and r3.
                                        ; Registers Affected
                                        ;   r1,r2,r3,r4
                                        ; Returns
                                        ; 	r1 = number
                                        ;	r2 = number of digits in number
                                        ;	r8 = updated text pointer
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 49
noc_boot21.a
                                        ;
   2881 0000F02A                        TSTNUM
   2882 0000F02A FE 6E                   	sub		sp,sp,#2
   2883 0000F02C E0 DF                   	sw		lr,[sp]
   2884 0000F02E 1E AF                   	call	IGNBLK		; skip over blanks
   2885 0000F030 00 11                   	lw		r1,#0		; initialize return parameters
   2886 0000F032 00 12                   	lw		r2,#0
   2887 0000F034                        TN1
   2888 0000F034 80 E3                   	lb		r3,[r8]
   2889 0000F036 FD 4F 30 10             	cmp		r3,#'0'		; is it less than zero?
   2890 0000F03A 15 A4                   	bltu	TSNMRET 	; if so, that's all
   2891 0000F03C FC 4F 37 10             	cmp		r3,#'9'		; is it greater than nine?
   2892 0000F040 12 A7                   	bgtu	TSNMRET 	; if so, return
   2893 0000F042 33 43 14 10             	cmp		r1,#214748364	; see if there's room for new digit
   2894 0000F046 04 A6                   	bleu	TN2
   2895 0000F048 2C 4F 07 11             	lea		r1,msgNumTooBig
   2896 0000F04C E3 4F 07 AE             	br		ERROR		; if not, we've overflowd
   2897 0000F050                        TN2
   2898 0000F050 10 14                   	lw		r4,r1		; quickly multiply result by 10
   2899 0000F052 81 31                   	shl		r1,#1		; * 2
   2900 0000F054 81 31                   	shl		r1,#1		; * 4
   2901 0000F056 40 21                   	add		r1,r4		; * 5
   2902 0000F058 81 31                   	shl		r1,#1		; * 10
   2903 0000F05A 01 68                   	add		r8,r8,#1	; adjust text pointer
   2904 0000F05C 00 40 5F 33             	and		r3,#0xF		; add in the new digit
   2905 0000F060 30 21                   	add		r1,r3
   2906 0000F062 01 62                   	add		r2,r2,#1	; increment the no. of digits
   2907 0000F064 E7 BE                   	br		TN1
   2908 0000F066                        TSNMRET
   2909 0000F066 E0 FF                   	lw		lr,[sp]
   2910 0000F068 02 6E                   	add		sp,sp,#2
   2911 0000F06A F0 80                   	ret
                                        
                                        
                                        ;===== Skip over blanks in the text pointed to by r8.
                                        ;
                                        ; Registers Affected:
                                        ;	r8
                                        ; Returns
                                        ;	r8 = pointer updateded past any spaces or tabs
                                        ;
   2921 0000F06C                        IGNBLK
   2922 0000F06C FE 6E                   	sub		sp,sp,#2
   2923 0000F06E E0 D1                   	sw		r1,[sp]
   2924 0000F070                        IGB2
   2925 0000F070 80 E1                   	lb		r1,[r8]			; get char
   2926 0000F072 FE 4F 10 10             	cmp		r1,#' '			; see if it's a space
   2927 0000F076 03 A8                   	beq		IGB1			; if so, swallow it
   2928 0000F078 FF 4F 17 10             	cmp		r1,#'\t'		; or a tab
   2929 0000F07C 02 A9                   	bne		IGBRET
   2930 0000F07E                        IGB1
   2931 0000F07E 01 68                   	add		r8,r8,#1		; increment the text pointer
   2932 0000F080 F7 BE                   	br		IGB2
   2933 0000F082                        IGBRET
   2934 0000F082 E0 F1                   	lw		r1,[sp]
   2935 0000F084 02 6E                   	add		sp,sp,#2
   2936 0000F086 F0 80                   	ret
                                        
                                        
                                        ; ===== Convert the line of text in the input buffer to upper
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 50
noc_boot21.a
                                        ;	case (except for stuff between quotes).
                                        ;
                                        ; Registers Affected
                                        ;   r1,r3
                                        ; Returns
                                        ;	r8 = pointing to end of text in buffer
                                        ;
   2947 0000F088                        TOUPBUF
   2948 0000F088 FE 6E                   	sub		sp,sp,#2
   2949 0000F08A E0 DF                   	sw		lr,[sp]
   2950 0000F08C 0A 40 0E 18             	lea		r8,BUFFER	; set up text pointer
   2951 0000F090 00 13                   	lw		r3,#0		; clear quote flag
   2952 0000F092                        TOUPB1
   2953 0000F092 80 E1                   	lb		r1,[r8]		; get the next text char.
   2954 0000F094 01 68                   	add		r8,r8,#1
   2955 0000F096 FF 4F 13 10             	cmp		r1,#CR		; is it end of line?
   2956 0000F09A 13 A8                   	beq		TOUPBRT 	; if so, return
   2957 0000F09C FD 4F 1E 10             	cmp		r1,#'"'		; a double quote?
   2958 0000F0A0 08 A8                   	beq		DOQUO
   2959 0000F0A2 FD 4F 19 10             	cmp		r1,#''''	; or a single quote?
   2960 0000F0A6 05 A8                   	beq		DOQUO
   2961 0000F0A8 30 10                   	cmp		r3,#0		; inside quotes?
   2962 0000F0AA F3 B9                   	bne		TOUPB1		; if so, do the next one
   2963 0000F0AC 0D AF                   	call	toUpper 	; convert to upper case
   2964 0000F0AE 8F C1                   	sb		r1,-1[r8]	; store it
   2965 0000F0B0 F0 BE                   	br		TOUPB1		; and go back for more
   2966 0000F0B2                        DOQUO
   2967 0000F0B2 30 10                   	cmp		r3,#0		; are we inside quotes?
   2968 0000F0B4 02 A9                   	bne		DOQUO1
   2969 0000F0B6 10 13                   	lw		r3,r1		; if not, toggle inside-quotes flag
   2970 0000F0B8 EC BE                   	br		TOUPB1
   2971 0000F0BA                        DOQUO1
   2972 0000F0BA 1D 23                   	cmp		r3,r1		; make sure we're ending proper quote
   2973 0000F0BC EA B9                   	bne		TOUPB1		; if not, ignore it
   2974 0000F0BE 00 13                   	lw		r3,#0		; else clear quote flag
   2975 0000F0C0 E8 BE                   	br		TOUPB1
   2976 0000F0C2                        TOUPBRT
   2977 0000F0C2 E0 FF                   	lw		lr,[sp]
   2978 0000F0C4 02 6E                   	add		sp,sp,#2
   2979 0000F0C6 F0 80                   	ret
                                        
                                        
                                        ; ===== Convert the character in r1 to upper case
                                        ;
   2984 0000F0C8                        toUpper
   2985 0000F0C8 F9 4F 1F 10             	cmp		r1,#'a'		; is it < 'a'?
   2986 0000F0CC 04 A0                   	blt	    TOUPRET
   2987 0000F0CE F8 4F 16 10             	cmp		r1,#'z'		; or > 'z'?
   2988 0000F0D2 01 A3                   	bgt	    TOUPRET
   2989 0000F0D4 E0 61                   	sub		r1,r1,#32	; if not, make it upper case
   2990 0000F0D6                        TOUPRET
   2991 0000F0D6 F0 80                   	ret
                                        
                                        
                                        ; 'CHKIO' checks the input. If there's no input, it will return
                                        ; to the caller with the Z flag set. If there is input, the Z
                                        ; flag is cleared and the input byte is in r2. However, if a
                                        ; control-C is read, 'CHKIO' will warm-start BASIC and will not
                                        ; return to the caller.
                                        ;
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 51
noc_boot21.a
   3000 0000F0D8                        CHKIO
   3001 0000F0D8 FE 6E                   	sub		sp,sp,#2	; save link reg
   3002 0000F0DA E0 DF                   	sw		lr,[sp]
   3003 0000F0DC 7C 4F 0B AF             	call	GOIN		; get input if possible
   3004 0000F0E0 07 A8                   	beq		CHKRET2		; if Zero, no input
   3005 0000F0E2 1D 10                   	cmp		r1,#CTRLC	; is it control-C?
   3006 0000F0E4 02 A9                   	bne		CHKRET		; if not
   3007 0000F0E6 80 4F 09 AE             	jmp		WSTART		; if so, do a warm start
   3008 0000F0EA                        CHKRET
   3009 0000F0EA E0 FF                   	lw		lr,[sp]
   3010 0000F0EC 02 6E                   	add		sp,sp,#2	; Z=0
   3011 0000F0EE F0 80                   	ret
   3012 0000F0F0                        CHKRET2
   3013 0000F0F0 E0 FF                   	lw		lr,[sp]
   3014 0000F0F2 02 6E                   	add		sp,sp,#2
   3015 0000F0F4 00 11                   	lw		r1,#0		; Z=1
   3016 0000F0F6 F0 80                   	ret
                                        
                                        
                                        ; ===== Display a CR-LF sequence
                                        ;
   3021 0000F0F8                        CRLF
   3022 0000F0F8 2A 4F 09 11             	lea		r1,CLMSG
                                        
                                        
                                        ; ===== Display a zero-ended string pointed to by register r1
                                        ; Registers Affected
                                        ;   r1,r2,r4
                                        ;
   3029 0000F0FC                        PRMESG
   3030 0000F0FC FC 6E                   	sub		sp,sp,#4
   3031 0000F0FE E0 DF                   	sw		lr,[sp]
   3032 0000F100 E2 D5                   	sw		r5,2[sp]
   3033 0000F102 10 15                   	lw      r5,r1       ; r5 = pointer to message
   3034 0000F104                        PRMESG1
   3035 0000F104 01 65                   	add		r5,r5,#1
   3036 0000F106 5F E1                   	lb		r1,-1[r5]	; 	get the char.
   3037 0000F108 03 A8                   	beq		PRMRET
   3038 0000F10A 7B 4F 02 AF             	call	GOOUT		;else display it trashes r4
   3039 0000F10E FA BE                   	br		PRMESG1
   3040 0000F110                        PRMRET
   3041 0000F110 50 11                   	lw		r1,r5
   3042 0000F112 E2 F5                   	lw		r5,2[sp]
   3043 0000F114 E0 FF                   	lw		lr,[sp]
   3044 0000F116 04 6E                   	add		sp,sp,#4
   3045 0000F118 F0 80                   	ret
                                        
                                        
                                        ; ===== Display a zero-ended string pointed to by register r1
                                        ; Registers Affected
                                        ;   r1,r2,r3
                                        ;
   3052 0000F11A                        PRMESGAUX
   3053 0000F11A FC 6E                   	sub		sp,sp,#4
   3054 0000F11C E0 DF                   	sw		lr,[sp]
   3055 0000F11E E2 D5                   	sw		r5,2[sp]
   3056 0000F120 10 15                   	lw      r5,r1       ; r3 = pointer
   3057 0000F122                        PRMESGA1
   3058 0000F122 01 65                   	add		r5,r5,#1
   3059 0000F124 5F E1                   	lb		r1,-1[r5]	; 	get the char.
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 52
noc_boot21.a
   3060 0000F126 03 A8                   	beq		PRMRETA
   3061 0000F128 7A 4F 07 AF             	call	GOAUXO		;else display it
   3062 0000F12C FA BE                   	br		PRMESGA1
   3063 0000F12E                        PRMRETA
   3064 0000F12E 50 11                   	lw		r1,r5
   3065 0000F130 E2 F5                   	lw		r5,2[sp]
   3066 0000F132 E0 FF                   	lw		lr,[sp]
   3067 0000F134 04 6E                   	add		sp,sp,#4
   3068 0000F136 F0 80                   	ret
                                        
                                        ;*****************************************************
                                        ; The following routines are the only ones that need *
                                        ; to be changed for a different I/O environment.     *
                                        ;*****************************************************
                                        
                                        
                                        ; ===== Output character to the console (Port 1) from register D0
                                        ;	(Preserves all registers.)
                                        ;
   3079 0000F138                        OUTC
   3080 0000F138 FF BE                   	jmp		_putChar
                                        
                                        
                                        ; ===== Input a character from the console into register D0 (or
                                        ;	return Zero status if there's no character available).
                                        ;
   3086 0000F13A                        INC
   3087 0000F13A FE 6E                   	add		sp,sp,#-2
   3088 0000F13C E0 DF                   	sw		lr,[sp]
   3089 0000F13E 01 4B 00 E1             	lb		r1,ROUTER+RTR_RXSTAT
   3090 0000F142 04 A8                   	beq		INC1
   3091 0000F144 77 4F 0C AF             	call	Recv
   3092 0000F148 1C 40 0B AF             	call	RecvDispatch
   3093 0000F14C                        INC1
                                        ; get char from keyboard
                                        ; returns char in r1
   3096 0000F14C                        _getChar
   3097 0000F14C C5 4D 02 E1             	lb		r1,KBD+2	; get keyboard strobe
   3098 0000F150 08 AB                   	bpl		gc1
   3099 0000F152 C5 4D 00 E1             	lb		r1,KBD		; get character and clear keyboard strobe
   3100 0000F156 05 AA                   	bmi		gc1			; was it a keyup event ? (ignore)
   3101 0000F158 07 40 5F 31             	and		r1,#0x7f
   3102 0000F15C E0 FF                   	lw		lr,[sp]
   3103 0000F15E 02 6E                   	add		sp,sp,#2
   3104 0000F160 F0 80                   	ret
   3105 0000F162                        gc1
   3106 0000F162 E0 FF                   	lw		lr,[sp]
   3107 0000F164 02 6E                   	add		sp,sp,#2
   3108 0000F166 00 11                   	lw		r1,#0		; return Z=1 (no character)
   3109 0000F168 F0 80                   	ret
                                        
                                        
                                        ; get char from keyboard
                                        ; returns char in r1
   3114 0000F16A                        _getCharWait
   3115 0000F16A                        gc2
   3116 0000F16A C5 4D 02 E1             	lb		r1,KBD+2	; get keyboard strobe
   3117 0000F16E FD BB                   	bpl		gc2
   3118 0000F170 C5 4D 00 E1             	lb		r1,KBD		; get character and clear keyboard strobe
   3119 0000F174 FA BA                   	bmi		gc2			; was it a keyup event ? (ignore)
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 53
noc_boot21.a
   3120 0000F176 07 40 5F 31             	and		r1,#0x7f
   3121 0000F17A F0 80                   	ret
                                        
                                        
                                        ; Trigger a load operation on the target node.
                                        
   3126 0000F17C                        TriggerTgtLoad:
   3127 0000F17C 74 4F 00 AF             	call	zeroTxBuf
   3128 0000F180 03 40 06 E2             	lb		r2,tgtNode
   3129 0000F184 02 40 0F C2             	sb		r2,txBuf+MSG_DST
   3130 0000F188 01 40 01 12             	lw		r2,#$11
   3131 0000F18C 02 40 0E C2             	sb		r2,txBuf+MSG_SRC
   3132 0000F190 0A 12                   	lw		r2,#10				; trigger load on target node
   3133 0000F192 02 40 07 C2             	sb		r2,txBuf+MSG_TYPE
   3134 0000F196 73 4F 0E AF             	call	Xmit
   3135 0000F19A E2 F2                   	lw		r2,2[sp]
   3136 0000F19C E0 FF                   	lw		lr,[sp]
   3137 0000F19E F0 80                   	ret
                                        
                                        ; ===== Output character to the host (Port 2) from register r1
                                        ;	(Preserves all registers.)
                                        ;
   3142 0000F1A0                        AUXOUT
   3143 0000F1A0 FC 6E                   	add		sp,sp,#-4
   3144 0000F1A2 E0 DF                   	sw		lr,[sp]
   3145 0000F1A4 E2 D2                   	sw		r2,2[sp]
   3146 0000F1A6 03 40 06 E2             	lb		r2,tgtNode
                                        	cmp		#$11
   3148 0000F1AA 05 A9                   	bne		auxout1
   3149 0000F1AC 32 48 0D AF             	call	putSerial	; call boot rom routine
   3150 0000F1B0 E2 F2                   	lw		r2,2[sp]
   3151 0000F1B2 E0 FF                   	lw		lr,[sp]
   3152 0000F1B4 F0 80                   	ret
   3153 0000F1B6                        auxout1:
   3154 0000F1B6 72 4F 03 AF             	call	zeroTxBuf
   3155 0000F1BA 02 40 00 C1             	sb		r1,txBuf
   3156 0000F1BE 03 40 06 E2             	lb		r2,tgtNode
   3157 0000F1C2 02 40 0F C2             	sb		r2,txBuf+MSG_DST
   3158 0000F1C6 01 40 01 12             	lw		r2,#$11
   3159 0000F1CA 02 40 0E C2             	sb		r2,txBuf+MSG_SRC
   3160 0000F1CE 0B 12                   	lw		r2,#11				; recieve BASIC program char
   3161 0000F1D0 02 40 07 C2             	sb		r2,txBuf+MSG_TYPE
   3162 0000F1D4 71 4F 0F AF             	call	Xmit
   3163 0000F1D8 E2 F2                   	lw		r2,2[sp]
   3164 0000F1DA E0 FF                   	lw		lr,[sp]
   3165 0000F1DC F0 80                   	ret
                                        ;
                                        ; ===== Input a character from the host into register D0 (or
                                        ;	return negative status if there's no character available).
                                        ;
   3170 0000F1DE                        AUXIN
                                        ; get character from serial port
                                        ; return  N=1 if no character available
   3173 0000F1DE 31 48 02 AE             	jmp		peekSerial
                                        
                                        
   3176 0000F1E2                        _scrollScreen
   3177 0000F1E2 FC 6E                   	sub		sp,sp,#4
   3178 0000F1E4 E0 D5                   	sw		r5,[sp]
   3179 0000F1E6 60 40 00 13             	lw		r3,#1536	; number of chars to move - 1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 54
noc_boot21.a
   3180 0000F1EA 00 42 00 12             	lw		r2,#VIDEORAM
   3181 0000F1EE 03 40 00 E1             	lb		r1,txtWidth
   3182 0000F1F2 81 31                   	shl		r1,#1
   3183 0000F1F4 81 31                   	shl		r1,#1
   3184 0000F1F6                        ss1:
   3185 0000F1F6 20 15                   	lw		r5,r2
   3186 0000F1F8 10 25                   	add		r5,r1
   3187 0000F1FA 50 F4                   	lw		r4,[r5]		; char at next line
   3188 0000F1FC 20 D4                   	sw		r4,[r2]		; goes to this line
   3189 0000F1FE 04 62                   	add		r2,r2,#4
   3190 0000F200 FF 63                   	sub		r3,r3,#1
   3191 0000F202 F9 B9                   	bne     ss1
                                        	; blank out last line
   3193 0000F204 02 40 00 13             	lw		r3,#' '
   3194 0000F208 03 40 08 D3             	sh		r3,charToPrint
   3195 0000F20C 03 40 00 E3             	lb		r3,txtWidth
   3196 0000F210 03 40 08 F4             	lw		r4,charToPrint	; and colors
   3197 0000F214                        ss2
   3198 0000F214 20 D4                   	sw		r4,[r2]
   3199 0000F216 04 62                   	add		r2,r2,#4
   3200 0000F218 FF 63                   	sub		r3,r3,#1
   3201 0000F21A FC B9                   	bne     ss2
   3202 0000F21C E0 F5                   	lw		r5,[sp]
   3203 0000F21E 04 6E                   	add		sp,sp,#4
   3204 0000F220 F0 80                   	ret
                                        
                                        
                                        ; flash the character at the screen position
                                        ;   r1: 1 = flash, 0 = no flash
   3209 0000F222                        _flashCursor
   3210 0000F222 00 42 00 12             	lw		r2,#VIDEORAM
   3211 0000F226 03 40 04 F3             	lh		r3,pos
   3212 0000F22A 81 33                   	shl		r3,#1
   3213 0000F22C 81 33                   	shl		r3,#1
   3214 0000F22E 20 23                   	add		r3,r2		; r3 = scr[pos]
                                        
   3216 0000F230 16 21                   	or		r1,r1
   3217 0000F232 04 A8                   	beq		fc1
   3218 0000F234 33 E2                   	lb		r2,3[r3]	; get background color
   3219 0000F236 08 40 60 32             	or		r2,#0x80	; set flash indicator
   3220 0000F23A 03 AE                   	br		fcx
   3221 0000F23C                        fc1
   3222 0000F23C 33 E2                   	lb		r2,3[r3]	; get background color
   3223 0000F23E 07 40 5F 32             	and		r2,#0x7f	; clear flash indicator
   3224 0000F242                        fcx:
   3225 0000F242 33 C2                   	sb		r2,3[r3]
   3226 0000F244 F0 80                   	ret
                                        
                                        
   3229 0000F246                        _cls
   3230 0000F246 2F 48 00 AF             	call	clearScreen
   3231 0000F24A 90 4F 02 AE             	br		FINISH
                                        
                                        
                                        ; ===== Return to the resident monitor, operating system, etc.
                                        ;
   3236 0000F24E                        BYEBYE
   3237 0000F24E 08 40 04 FE             	lw		sp,OSSP
   3238 0000F252 E0 FF                       lw      lr,[sp]
   3239 0000F254 02 6E                       add		sp,sp,#2
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 55
noc_boot21.a
   3240 0000F256 F0 80                   	ret
                                        
                                        ;	MOVE.B	#228,D7 	return to Tutor
                                        ;	TRAP	#14
                                        
   3245 0000F258 0D 0A 42 75 74 74      msgInit db	CR,LF,"Butterfly Tiny BASIC v1.1",CR,LF,"(C) 2005-2017  Robert Finch",CR,LF,LF,0
   3245 0000F25E 65 72 66 6C 79 20 54  
   3245 0000F265 69 6E 79 20 42 41 53  
   3245 0000F26C 49 43 20 76 31 2E 31  
   3245 0000F273 0D 0A 28 43 29 20 32  
   3245 0000F27A 30 30 35 2D 32 30 31  
   3245 0000F281 37 20 20 52 6F 62 65  
   3245 0000F288 72 74 20 46 69 6E 63  
   3245 0000F28F 68 0D 0A 0A 00        
   3246 0000F294 0D 0A 4F 4B 0D 0A      OKMSG	db	CR,LF,"OK",CR,LF,0
   3246 0000F29A 00                    
   3247 0000F29B 57 68 61 74 3F 0D      msgWhat	db	"What?",CR,LF,0
   3247 0000F2A1 0A 00                 
   3248 0000F2A3 53 6F 72 72 79 2E      SRYMSG	db	"Sorry."
                                      
   3249 0000F2A9 0D 0A 00               CLMSG	db	CR,LF,0
   3250 0000F2AC 43 6F 6D 70 61 63      msgReadError	db	"Compact FLASH read error",CR,LF,0
   3250 0000F2B2 74 20 46 4C 41 53 48  
   3250 0000F2B9 20 72 65 61 64 20 65  
   3250 0000F2C0 72 72 6F 72 0D 0A 00  
                                      
   3251 0000F2C7 4E 75 6D 62 65 72      msgNumTooBig	db	"Number is too big",CR,LF,0
   3251 0000F2CD 20 69 73 20 74 6F 6F  
   3251 0000F2D4 20 62 69 67 0D 0A 00  
                                      
   3252 0000F2DB 44 69 76 69 73 69      msgDivZero		db	"Division by zero",CR,LF,0
   3252 0000F2E1 6F 6E 20 62 79 20 7A  
   3252 0000F2E8 65 72 6F 0D 0A 00     
   3253 0000F2EE 4F 75 74 20 6F 66      msgVarSpace     db  "Out of variable space",CR,LF,0
   3253 0000F2F4 20 76 61 72 69 61 62  
   3253 0000F2FB 6C 65 20 73 70 61 63  
   3253 0000F302 65 0D 0A 00           
   3254 0000F306 20 62 79 74 65 73      msgBytesFree	db	" bytes free",CR,LF,0
   3254 0000F30C 20 66 72 65 65 0D 0A  
   3254 0000F313 00                    
   3255 0000F314 0D 0A 52 65 61 64      msgReady		db	CR,LF,"Ready",CR,LF,0
   3255 0000F31A 79 0D 0A 00           
   3256 0000F31E 45 78 70 65 63 74      msgComma		db	"Expecting a comma",CR,LF,0
   3256 0000F324 69 6E 67 20 61 20 63  
   3256 0000F32B 6F 6D 6D 61 0D 0A 00  
                                      
   3257 0000F332 4C 69 6E 65 20 6E      msgLineRange	db	"Line number too big",CR,LF,0
   3257 0000F338 75 6D 62 65 72 20 74  
   3257 0000F33F 6F 6F 20 62 69 67 0D  
   3257 0000F346 0A 00                 
   3258 0000F348 45 78 70 65 63 74      msgVar			db	"Expecting a variable",CR,LF,0
   3258 0000F34E 69 6E 67 20 61 20 76  
   3258 0000F355 61 72 69 61 62 6C 65  
   3258 0000F35C 0D 0A 00              
   3259 0000F35F 52 4E 44 20 62 61      msgRNDBad		db	"RND bad parameter",CR,LF,0
   3259 0000F365 64 20 70 61 72 61 6D  
   3259 0000F36C 65 74 65 72 0D 0A 00  
                                      
   3260 0000F373 53 59 53 20 62 61      msgSYSBad		db	"SYS bad address",CR,LF,0
   3260 0000F379 64 20 61 64 64 72 65  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 56
noc_boot21.a
   3260 0000F380 73 73 0D 0A 00        
   3261 0000F385 49 4E 50 55 54 20      msgInputVar		db	"INPUT expecting a variable",CR,LF,0
   3261 0000F38B 65 78 70 65 63 74 69  
   3261 0000F392 6E 67 20 61 20 76 61  
   3261 0000F399 72 69 61 62 6C 65 0D  
   3261 0000F3A0 0A 00                 
   3262 0000F3A2 4E 45 58 54 20 77      msgNextFor		db	"NEXT without FOR",CR,LF,0
   3262 0000F3A8 69 74 68 6F 75 74 20  
   3262 0000F3AF 46 4F 52 0D 0A 00     
   3263 0000F3B5 4E 45 58 54 20 65      msgNextVar		db	"NEXT expecting a defined variable",CR,LF,0
   3263 0000F3BB 78 70 65 63 74 69 6E  
   3263 0000F3C2 67 20 61 20 64 65 66  
   3263 0000F3C9 69 6E 65 64 20 76 61  
   3263 0000F3D0 72 69 61 62 6C 65 0D  
   3263 0000F3D7 0A 00                 
   3264 0000F3D9 47 4F 54 4F 2F 47      msgBadGotoGosub	db	"GOTO/GOSUB bad line number",CR,LF,0
   3264 0000F3DF 4F 53 55 42 20 62 61  
   3264 0000F3E6 64 20 6C 69 6E 65 20  
   3264 0000F3ED 6E 75 6D 62 65 72 0D  
   3264 0000F3F4 0A 00                 
   3265 0000F3F6 52 45 54 55 52 4E      msgRetWoGosub   db	"RETURN without GOSUB",CR,LF,0
   3265 0000F3FC 20 77 69 74 68 6F 75  
   3265 0000F403 74 20 47 4F 53 55 42  
   3265 0000F40A 0D 0A 00              
   3266 0000F40D 50 72 6F 67 72 61      msgTooBig		db	"Program is too big",CR,LF,0
   3266 0000F413 6D 20 69 73 20 74 6F  
   3266 0000F41A 6F 20 62 69 67 0D 0A  
   3266 0000F421 00                    
   3267 0000F422 45 78 74 72 61 20      msgExtraChars	db	"Extra characters on line ignored",CR,LF,0
   3267 0000F428 63 68 61 72 61 63 74  
   3267 0000F42F 65 72 73 20 6F 6E 20  
   3267 0000F436 6C 69 6E 65 20 69 67  
   3267 0000F43D 6E 6F 72 65 64 0D 0A  
   3267 0000F444 00                    
                                        
   3269 0000F445 FF FF FF                	.align	4
   3336 = 0000F448                      LSTROM	equ	*		; end of possible ROM area
                                        ;
                                        ; Internal variables follow:
                                        ;
                                        		bss
                                        		org		0x0030
   3276 00000030                        txtWidth	db	0		; BIOS var =60
   3277 00000031                        txtHeight	db	0		; BIOS var =27
   3278 00000032                        cursx	db		0		; cursor x position
   3279 00000033                        cursy	db		0		; cursor y position
   3280 00000034                        pos		dw		0		; text screen position
   3281 00000036                        tgtNode	db		0
   3282 00000037                        srcNode	db		0
                                        		org		0x0038
   3284 00000038                        charToPrint		dw		0
   3285 0000003A                        fgColor			db		0
   3286 0000003B                        bkColor			db		0
   3287 0000003C                        cursFlash		db		0	; flash the cursor ?
   3288 0000003D                         				db		0
   3289 0000003E                        NormAttr		dw		0
                                        
   3291 00000040                        lineLinkTbl		fill.b	25,0	; screen line link table
   3292 00000059                         	align 4
                                        
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 57
noc_boot21.a
                                        		org		0x0080
   3295 00000080                        typef   db      0   ; variable / expression type
   3296 00000081                                 align   4
   3297 00000084                        OSSP	dw	1	; OS value of sp
   3298 00000086                        CURRNT	dw	1	;	Current line pointer
   3299 00000088                        STKGOS	dw	1	;	Saves stack pointer in 'GOSUB'
   3300 0000008A                        STKINP	dw	1	;	Saves stack pointer during 'INPUT'
   3301 0000008C                        LOPVAR	dw	1	;	'FOR' loop save area
   3302 0000008E                        LOPINC	dw	1	;	increment
   3303 00000090                        LOPLMT	dw	1	;	limit
   3304 00000092                        LOPLN	dw	1	;	line number
   3305 00000094                        LOPPT	dw	1	;	text pointer
   3306 00000096                        TXTUNF	dw	1	;	points to unfilled text area
   3307 00000098                        VARBGN	dw	1	;	points to variable area
   3308 0000009A                        IVARBGN dw  1   ;   points to integer variable area
   3309 0000009C                        SVARBGN dw  1   ;   points to string variable area
   3310 0000009E                        FVARBGN dw  1   ;   points to float variable area
   3311 000000A0                        STKBOT	dw	1	;	holds lower limit for stack growth
   3312 000000A2                        NUMWKA	fill.b	12,0			; numeric work area
   3313 000000AE                        BUFFER	fill.b	BUFLEN,0x00		;		Keyboard input buffer
                                        
                                                bss
                                                org     0x2000
   3317 00002000                        textScr1
                                                org     0x2000
                                        ;	END
                                        
                                        		.code
   3322 0000F448                        start:
   3323 0000F448 FF 41 0E 1E             		lw		sp,#$1FFE
   3324 0000F44C 00 40 0F C0             		sb		r0,HTInputFocus
   3325 0000F450                        start1:
   3326 0000F450                        noMsg1:
   3327 0000F450 7F AF                   		call	KeybdGetChar
   3328 0000F452 29 A9                   		bne		noKey
   3329 0000F454 F9 4F 1D 10             		cmp		r1,#'c'
   3330 0000F458 13 A9                   		bne		notC
   3331 0000F45A 01 40 01 E1             		lb		r1,KeyState2	; test if CTRL down
   3332 0000F45E 54 31                   		and		r1,#4
   3333 0000F460 22 A8                   		beq		noKey
                                        		; CTRL-C
                                        		; If CTRL-C was pressed broadcast a global stop message
   3336 0000F462 5C 4F 0D AF             		call	zeroTxBuf
   3337 0000F466 E4 31                   		tsr		r1,ID
   3338 0000F468 02 40 0E C1             		sb		r1,txBuf+MSG_SRC
   3339 0000F46C 0F 40 0F 11             		lw		r1,#$FF
   3340 0000F470 02 40 0F C1             		sb		r1,txBuf+MSG_DST
   3341 0000F474 03 11                   		lw		r1,#MT_STOP
   3342 0000F476 02 40 07 C1             		sb		r1,txBuf+MSG_TYPE
   3343 0000F47A 5C 4F 0C AF             		call	Xmit
   3344 0000F47E 13 AE                   		bra		noKey
                                        		; There was a keystroke available so transmit a character
                                        		; message to the thread with the input focus
   3347 0000F480                        notC:
   3348 0000F480 00 40 0F E5             		lb		r5,HTInputFocus		; any thread with input focus ?
   3349 0000F484 10 A8                   		beq		noKey
   3350 0000F486 5B 4F 0B AF             		call	zeroTxBuf
   3351 0000F48A 02 40 0F C5             		sb		r5,txBuf+MSG_DST	; destination is input focus thread
   3352 0000F48E E4 35                   		tsr		r5,ID				; source is this node
   3353 0000F490 02 40 0E C5             		sb		r5,txBuf+MSG_SRC
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 58
noc_boot21.a
   3354 0000F494 02 40 00 C1             		sb		r1,txBuf			; store ascii char
   3355 0000F498 02 40 01 C3             		sb		r3,txBuf+1			; and scan code
   3356 0000F49C 04 11                   		lw		r1,#MT_KEYSTROKE	; keyboard message
   3357 0000F49E 02 40 07 C1             		sb		r1,txBuf+MSG_TYPE
   3358 0000F4A2 5B 4F 08 AF             		call	Xmit
   3359 0000F4A6                        noKey:
   3360 0000F4A6 01 4B 00 E1             		lb		r1,ROUTER+RTR_RXSTAT
   3361 0000F4AA 03 40 5F 31             		and		r1,#63
   3362 0000F4AE D0 B8                   		beq		noMsg1
   3363 0000F4B0 5C 4F 06 AF             		call	Recv
   3364 0000F4B4 16 AF                   		call	RecvDispatch
   3365 0000F4B6 CC BE                   		bra		start1
   3366 0000F4B8                        lockup:
   3367 0000F4B8 FF BE                   		bra		lockup
                                        
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Broadcast a reset message on the network.
                                        ;----------------------------------------------------------------------------
                                        
   3374 0000F4BA                        broadcastReset:
   3375 0000F4BA FE 6E                   		add		sp,sp,#-2
   3376 0000F4BC E0 DF                   		sw		lr,[sp]
   3377 0000F4BE 59 4F 0F AF             		call	zeroTxBuf
   3378 0000F4C2 0F 40 0F 11             		lw		r1,#$FF		; global broadcast address
   3379 0000F4C6 02 40 0F C1             		sb		r1,txBuf+MSG_DST
   3380 0000F4CA 01 40 01 11             		lw		r1,#$11		; source of message
   3381 0000F4CE 02 40 0E C1             		sb		r1,txBuf+MSG_SRC
   3382 0000F4D2 01 11                   		lw		r1,#1
   3383 0000F4D4 02 40 07 C1             		sb		r1,txBuf+MSG_TYPE	; reset message
   3384 0000F4D8 59 4F 0D AF             		call	Xmit
   3385 0000F4DC E0 FF                   		lw		lr,[sp]
   3386 0000F4DE 02 6E                   		add		sp,sp,#2
   3387 0000F4E0 F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Received message dispatch.
                                        ;----------------------------------------------------------------------------
                                        
   3393 0000F4E2                        RecvDispatch:
   3394 0000F4E2 FE 6E                   		add		sp,sp,#-2
   3395 0000F4E4 E0 DF                   		sw		lr,[sp]
   3396 0000F4E6 03 40 07 E1             		lb		r1,rxBuf+MSG_TYPE
                                        		; Reset request ?
   3398 0000F4EA 1F 10                   		cmp		r1,#MT_RST
   3399 0000F4EC 11 A9                   		bne		RecvDispatch2
   3400 0000F4EE 00 40 0F C0             		sb		r0,HTInputFocus
   3401 0000F4F2 58 4F 05 AF             		call	zeroTxBuf
   3402 0000F4F6 E4 31                   		tsr		r1,ID
   3403 0000F4F8 02 40 0E C1             		sb		r1,txBuf+MSG_SRC
   3404 0000F4FC 01 40 01 11             		lw		r1,#$11
   3405 0000F500 02 40 0F C1             		sb		r1,txBuf+MSG_DST
   3406 0000F504 02 11                   		lw		r1,#MT_RST_ACK
   3407 0000F506 02 40 07 C1             		sb		r1,txBuf+MSG_TYPE
   3408 0000F50A 58 4F 04 AF             		call	Xmit
   3409 0000F50E 1D AE                   		bra		RecvDispatchXit
   3410 0000F510                        RecvDispatch2:
                                        		; Set input focus ?
                                        		; Check for request to set input focus
   3413 0000F510 FF 4F 1B 10             		cmp		r1,#MT_SET_INPUT_FOCUS
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 59
noc_boot21.a
   3414 0000F514 03 A9                   		bne		RecvDispatch3
   3415 0000F516 03 40 00 E1             		lb		r1,rxBuf
                                        		sb		HTInputFocus
   3417 0000F51A 17 AE                   		bra		RecvDispatchXit
   3418 0000F51C                        RecvDispatch3:
                                        		; Get button status ?
   3420 0000F51C FF 4F 1A 10             		cmp		r1,#MT_BUTTON_STATUS
   3421 0000F520 13 A9                   		bne		RecvDispatch4
   3422 0000F522 56 4F 0D AF             		call	zeroTxBuf
   3423 0000F526 E4 31                   		tsr		r1,ID
   3424 0000F528 02 40 0E C1             		sb		r1,txBuf+MSG_SRC
   3425 0000F52C 03 40 0E E1             		lb		r1,rxBuf+MSG_SRC		; where did message come from
   3426 0000F530 02 40 0F C1             		sb		r1,txBuf+MSG_DST		; send back to sender
   3427 0000F534 06 11                   		lw		r1,#MT_BUTTON_STATUS
   3428 0000F536 02 40 07 C1             		sb		r1,txBuf+MSG_TYPE
   3429 0000F53A 20 4B 00 E1             		lb		r1,BTNS
   3430 0000F53E 02 40 00 C1             		sb		r1,txBuf
   3431 0000F542 56 4F 08 AF             		call	Xmit
   3432 0000F546 01 AE                   		bra		RecvDispatchXit
   3433 0000F548                        RecvDispatch4:
   3434 0000F548 00 AE                   		bra		RecvDispatchXit
   3435 0000F54A                        RecvDispatchXit:
   3436 0000F54A E0 FF                   		lw		lr,[sp]
   3437 0000F54C 02 6E                   		add		sp,sp,#2
   3438 0000F54E F0 80                   		ret
                                        
                                        ;============================================================================
                                        ; Keyboard Code
                                        ;============================================================================
                                        
                                        ;----------------------------------------------------------------------------
                                        ; KeybdGetChar:
                                        ;
                                        ; Returns:
                                        ; r1 = ascii code
                                        ; r2 = 0 if key available, 1 if no key available, 2 if keyboard busy
                                        ; r3 = scan code
                                        ; .ZF = 1 if a key is available, otherwise .ZF = 0
                                        ;----------------------------------------------------------------------------
                                        
   3454 0000F550                        KeybdGetChar:
   3455 0000F550 FC 6E                   		add		sp,sp,#-4
   3456 0000F552 E2 D4                   		sw		r4,2[sp]
   3457 0000F554 E0 DF                   		sw		lr,[sp]
   3458 0000F556                        kbd3:
   3459 0000F556 C5 4D 01 E1             		lb		r1,KBD+KBD_STAT	; get keyboard status flag
   3460 0000F55A 10 12                   		mov		r2,r1
   3461 0000F55C 04 40 50 31             		and		r1,#$40
   3462 0000F560 09 A9                   		bne		kbd1		; is it busy ?
   3463 0000F562 20 11                   		mov		r1,r2
   3464 0000F564 08 40 50 31             		and		r1,#$80
   3465 0000F568 0A A9                   		bne		kbd6		; branch if key available
   3466 0000F56A E0 FF                   		lw		lr,[sp]
   3467 0000F56C E2 F4                   		lw		r4,2[sp]
   3468 0000F56E 04 6E                   		add		sp,sp,#4
   3469 0000F570 01 12                   		lw		r2,#1		; no key available
   3470 0000F572 F0 80                   		ret
   3471 0000F574                        kbd1:
   3472 0000F574 E0 FF                   		lw		lr,[sp]
   3473 0000F576 E2 F4                   		lw		r4,2[sp]
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 60
noc_boot21.a
   3474 0000F578 04 6E                   		add		sp,sp,#4
   3475 0000F57A 02 12                   		lw		r2,#2		; keyboard busy
   3476 0000F57C F0 80                   		ret
   3477 0000F57E                        kbd6:
   3478 0000F57E C5 4D 00 E1             		lb		r1,KBD		; get scancode
   3479 0000F582 10 13                   		mov		r3,r1		; save in r3
   3480 0000F584 C5 4D 02 C0             		sb		r0,KBD+2	; clear read flag
   3481 0000F588 F1 4F 10 10             		cmp		r1,#SC_KEYUP
   3482 0000F58C 01 A9                   		bne		notKeyup
   3483 0000F58E 56 AE                   		jmp		doKeyup
   3484 0000F590                        notKeyup:
   3485 0000F590 F2 4F 10 10             		cmp		r1,#SC_EXTEND
   3486 0000F594 01 A9                   		bne		notExtend
   3487 0000F596 58 AE                   		jmp		doExtend
   3488 0000F598                        notExtend:
   3489 0000F598 FE 4F 1C 10             		cmp		r1,#$14		; control ?
   3490 0000F59C 01 A9                   		bne		notCtrl
   3491 0000F59E 5B AE                   		jmp		doCtrl
   3492 0000F5A0                        notCtrl:
   3493 0000F5A0 FE 4F 1E 10             		cmp		r1,#$12
   3494 0000F5A4 01 A9                   		bne		notShift
   3495 0000F5A6 68 AE                   		jmp		doShift
   3496 0000F5A8                        notShift:
   3497 0000F5A8 FA 4F 17 10             		cmp		r1,#$59
   3498 0000F5AC 01 A9                   		bne		notShift2
   3499 0000F5AE 64 AE                   		jmp		doShift
   3500 0000F5B0                        notShift2:
   3501 0000F5B0 F8 4F 19 10             		cmp		r1,#SC_NUMLOCK
   3502 0000F5B4 01 A9                   		bne		notNumLock
   3503 0000F5B6 71 AE                   		jmp		doNumLock
   3504 0000F5B8                        notNumLock:
   3505 0000F5B8 FA 4F 18 10             		cmp		r1,#SC_CAPSLOCK
   3506 0000F5BC 01 A9                   		bne		notCapsLock
   3507 0000F5BE 75 AE                   		jmp		doCapsLock
   3508 0000F5C0                        notCapsLock:
   3509 0000F5C0 F8 4F 12 10             		cmp		r1,#SC_SCROLLLOCK
   3510 0000F5C4 01 A9                   		bne		notScrollLock
   3511 0000F5C6 79 AE                   		jmp		doScrollLock
   3512 0000F5C8                        notScrollLock:
   3513 0000F5C8 01 40 00 E2             		lb		r2,KeyState1
   3514 0000F5CC 20 14                   		mov		r4,r2
   3515 0000F5CE A1 32                   		shr		r2,#1
   3516 0000F5D0 01 40 00 C2             		sb		r2,KeyState1
   3517 0000F5D4 51 34                   		and		r4,#1
   3518 0000F5D6 01 A8                   		beq		kbd11
   3519 0000F5D8 BE BE                   		jmp		kbd3
   3520 0000F5DA                        kbd11:
   3521 0000F5DA 10 12                   		mov		r2,r1
                                        		; Check for extended code
   3523 0000F5DC 08 40 00 11             		lw		r1,#$80
   3524 0000F5E0 01 40 01 E4             		lb		r4,KeyState2
   3525 0000F5E4 45 21                   		and		r1,r4
   3526 0000F5E6 11 A8                   		beq		kbd10
   3527 0000F5E8 07 40 0F 11             		lw		r1,#$7F
   3528 0000F5EC 45 21                   		and		r1,r4
   3529 0000F5EE 01 40 01 C1             		sb		r1,KeyState2
                                        		; clear keyup
   3531 0000F5F2 01 40 00 E4             		lb		r4,KeyState1
   3532 0000F5F6 A1 34                   		shr		r4,#1
   3533 0000F5F8 01 40 00 C4             		sb		r4,KeyState1
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 61
noc_boot21.a
   3534 0000F5FC 20 11                   		mov		r1,r2
   3535 0000F5FE 07 40 5F 31             		and		r1,#$7F
   3536 0000F602 10 12                   		mov		r2,r1
   3537 0000F604 94 4F 2C E1             		lb		r1,keybdExtendedCodes[r2]
   3538 0000F608 14 AE                   		bra		kbd8
   3539 0000F60A                        kbd10:
   3540 0000F60A 01 40 01 E1             		lb		r1,KeyState2
   3541 0000F60E 54 31                   		and		r1,#4
   3542 0000F610 07 A8                   		beq		kbd9
   3543 0000F612 20 11                   		mov		r1,r2
   3544 0000F614 07 40 5F 31             		and		r1,#$7F
   3545 0000F618 10 12                   		mov		r2,r1
   3546 0000F61A 8C 4F 2C E1             		lb		r1,keybdControlCodes[r2]
   3547 0000F61E 09 AE                   		bra		kbd8
   3548 0000F620                        kbd9:
   3549 0000F620 01 40 01 E1             		lb		r1,KeyState2
   3550 0000F624 51 31                   		and		r1,#1			; Is shift down ?
   3551 0000F626 03 A8                   		beq		kbd7
   3552 0000F628 7C 4F 2C E1             		lb		r1,shiftedScanCodes[r2]
   3553 0000F62C 02 AE                   		bra		kbd8
   3554 0000F62E                        kbd7:
   3555 0000F62E 6C 4F 2C E1             		lb		r1,unshiftedScanCodes[r2]
   3556 0000F632                        kbd8:
                                        		; return zero in r2 to indicate key available
   3558 0000F632 E0 FF                   		lw		lr,[sp]
   3559 0000F634 E2 F4                   		lw		r4,2[sp]
   3560 0000F636 04 6E                   		add		sp,sp,#4
   3561 0000F638 00 12                   		lw		r2,#0
   3562 0000F63A F0 80                   		ret
   3563 0000F63C                        doKeyup:
   3564 0000F63C 01 40 00 E1             		lb		r1,KeyState1
   3565 0000F640 61 31                   		or		r1,#1
   3566 0000F642 01 40 00 C1             		sb		r1,KeyState1
   3567 0000F646 87 BE                   		jmp		kbd3
   3568 0000F648                        doExtend:
   3569 0000F648 01 40 01 E1             		lb		r1,KeyState2
   3570 0000F64C 08 40 60 31             		or		r1,#$80
   3571 0000F650 01 40 01 C1             		sb		r1,KeyState2
   3572 0000F654 80 BE                   		jmp		kbd3
   3573 0000F656                        doCtrl:
   3574 0000F656 01 40 00 E1             		lb		r1,KeyState1
   3575 0000F65A C1 31                   		ror		r1,#1
   3576 0000F65C 07 AB                   		bpl		kbd4
   3577 0000F65E 01 40 01 E1             		lb		r1,KeyState2
   3578 0000F662 FF 4F 5B 31             		and		r1,#$FFFB
   3579 0000F666 01 40 01 C1             		sb		r1,KeyState2
   3580 0000F66A 75 BE                   		jmp		kbd3
   3581 0000F66C                        kbd4:
   3582 0000F66C 01 40 01 E1             		lb		r1,KeyState2
   3583 0000F670 64 31                   		or		r1,#4
   3584 0000F672 01 40 01 C1             		sb		r1,KeyState2
   3585 0000F676 6F BE                   		jmp		kbd3		
   3586 0000F678                        doShift:
   3587 0000F678 01 40 00 E1             		lb		r1,KeyState1
   3588 0000F67C C1 31                   		ror		r1,#1
   3589 0000F67E 07 AB                   		bpl		kbd5
   3590 0000F680 01 40 01 E1             		lb		r1,KeyState2
   3591 0000F684 FF 4F 5E 31             		and		r1,#$FFFE
   3592 0000F688 01 40 01 C1             		sb		r1,KeyState2
   3593 0000F68C 64 BE                   		jmp		kbd3
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 62
noc_boot21.a
   3594 0000F68E                        kbd5:
   3595 0000F68E 01 40 01 E1             		lb		r1,KeyState2
   3596 0000F692 61 31                   		or		r1,#1
   3597 0000F694 01 40 01 C1             		sb		r1,KeyState2
   3598 0000F698 5E BE                   		jmp		kbd3
   3599 0000F69A                        doNumLock:
   3600 0000F69A 01 40 01 E1             		lb		r1,KeyState2
   3601 0000F69E 01 40 40 31             		xor		r1,#16
   3602 0000F6A2 01 40 01 C1             		sb		r1,KeyState2
   3603 0000F6A6 11 AF                   		call	KeybdSetLEDStatus
   3604 0000F6A8 56 BE                   		jmp		kbd3
   3605 0000F6AA                        doCapsLock:
   3606 0000F6AA 01 40 01 E1             		lb		r1,KeyState2
   3607 0000F6AE 02 40 40 31             		xor		r1,#32
   3608 0000F6B2 01 40 01 C1             		sb		r1,KeyState2
   3609 0000F6B6 09 AF                   		call	KeybdSetLEDStatus
   3610 0000F6B8 4E BE                   		jmp		kbd3
   3611 0000F6BA                        doScrollLock:
   3612 0000F6BA 01 40 01 E1             		lb		r1,KeyState2
   3613 0000F6BE 04 40 40 31             		xor		r1,#64
   3614 0000F6C2 01 40 01 C1             		sb		r1,KeyState2
   3615 0000F6C6 01 AF                   		call	KeybdSetLEDStatus
   3616 0000F6C8 46 BE                   		jmp		kbd3
                                        
   3618 0000F6CA                        KeybdSetLEDStatus:
   3619 0000F6CA F0 80                   		ret
                                        
                                        	;--------------------------------------------------------------------------
                                        	; PS2 scan codes to ascii conversion tables.
                                        	;--------------------------------------------------------------------------
                                        	;
   3625 0000F6CC                        unshiftedScanCodes:
   3626 0000F6CC 2E A9 2E A5 A3 A1 A2    	.byte	$2e,$a9,$2e,$a5,$a3,$a1,$a2,$ac
   3626 0000F6D3 AC                    
   3627 0000F6D4 2E AA A8 A6 A4 09 60    	.byte	$2e,$aa,$a8,$a6,$a4,$09,$60,$2e
   3627 0000F6DB 2E                    
   3628 0000F6DC 2E 2E 2E 2E 2E 71 31    	.byte	$2e,$2e,$2e,$2e,$2e,$71,$31,$2e
   3628 0000F6E3 2E                    
   3629 0000F6E4 2E 2E 7A 73 61 77 32    	.byte	$2e,$2e,$7a,$73,$61,$77,$32,$2e
   3629 0000F6EB 2E                    
   3630 0000F6EC 2E 63 78 64 65 34 33    	.byte	$2e,$63,$78,$64,$65,$34,$33,$2e
   3630 0000F6F3 2E                    
   3631 0000F6F4 2E 20 76 66 74 72 35    	.byte	$2e,$20,$76,$66,$74,$72,$35,$2e
   3631 0000F6FB 2E                    
   3632 0000F6FC 2E 6E 62 68 67 79 36    	.byte	$2e,$6e,$62,$68,$67,$79,$36,$2e
   3632 0000F703 2E                    
   3633 0000F704 2E 2E 6D 6A 75 37 38    	.byte	$2e,$2e,$6d,$6a,$75,$37,$38,$2e
   3633 0000F70B 2E                    
   3634 0000F70C 2E 2C 6B 69 6F 30 39    	.byte	$2e,$2c,$6b,$69,$6f,$30,$39,$2e
   3634 0000F713 2E                    
   3635 0000F714 2E 2E 2F 6C 3B 70 2D    	.byte	$2e,$2e,$2f,$6c,$3b,$70,$2d,$2e
   3635 0000F71B 2E                    
   3636 0000F71C 2E 2E 27 2E 5B 3D 2E    	.byte	$2e,$2e,$27,$2e,$5b,$3d,$2e,$2e
   3636 0000F723 2E                    
   3637 0000F724 AD 2E 0D 5D 2E 5C 2E    	.byte	$ad,$2e,$0d,$5d,$2e,$5c,$2e,$2e
   3637 0000F72B 2E                    
   3638 0000F72C 2E 2E 2E 2E 2E 2E 08    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
   3638 0000F733 2E                    
   3639 0000F734 2E 95 2E 93 94 2E 2E    	.byte	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
   3639 0000F73B 2E                    
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 63
noc_boot21.a
   3640 0000F73C 98 7F 92 2E 91 90 1B    	.byte	$98,$7f,$92,$2e,$91,$90,$1b,$af
   3640 0000F743 AF                    
   3641 0000F744 AB 2E 97 2E 2E 96 AE    	.byte	$ab,$2e,$97,$2e,$2e,$96,$ae,$2e
   3641 0000F74B 2E                    
                                        
   3643 0000F74C 2E 2E 2E A7 2E 2E 2E    	.byte	$2e,$2e,$2e,$a7,$2e,$2e,$2e,$2e
   3643 0000F753 2E                    
   3644 0000F754 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3644 0000F75B 2E                    
   3645 0000F75C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3645 0000F763 2E                    
   3646 0000F764 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3646 0000F76B 2E                    
   3647 0000F76C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3647 0000F773 2E                    
   3648 0000F774 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3648 0000F77B 2E                    
   3649 0000F77C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3649 0000F783 2E                    
   3650 0000F784 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3650 0000F78B 2E                    
   3651 0000F78C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3651 0000F793 2E                    
   3652 0000F794 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3652 0000F79B 2E                    
   3653 0000F79C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3653 0000F7A3 2E                    
   3654 0000F7A4 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3654 0000F7AB 2E                    
   3655 0000F7AC 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3655 0000F7B3 2E                    
   3656 0000F7B4 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3656 0000F7BB 2E                    
   3657 0000F7BC 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3657 0000F7C3 2E                    
   3658 0000F7C4 2E 2E FA 2E 2E 2E 2E    	.byte	$2e,$2e,$fa,$2e,$2e,$2e,$2e,$2e
   3658 0000F7CB 2E                    
                                        
   3660 0000F7CC                        shiftedScanCodes:
   3661 0000F7CC 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3661 0000F7D3 2E                    
   3662 0000F7D4 2E 2E 2E 2E 2E 09 7E    	.byte	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
   3662 0000F7DB 2E                    
   3663 0000F7DC 2E 2E 2E 2E 2E 51 21    	.byte	$2e,$2e,$2e,$2e,$2e,$51,$21,$2e
   3663 0000F7E3 2E                    
   3664 0000F7E4 2E 2E 5A 53 41 57 40    	.byte	$2e,$2e,$5a,$53,$41,$57,$40,$2e
   3664 0000F7EB 2E                    
   3665 0000F7EC 2E 43 58 44 45 24 23    	.byte	$2e,$43,$58,$44,$45,$24,$23,$2e
   3665 0000F7F3 2E                    
   3666 0000F7F4 2E 20 56 46 54 52 25    	.byte	$2e,$20,$56,$46,$54,$52,$25,$2e
   3666 0000F7FB 2E                    
   3667 0000F7FC 2E 4E 42 48 47 59 5E    	.byte	$2e,$4e,$42,$48,$47,$59,$5e,$2e
   3667 0000F803 2E                    
   3668 0000F804 2E 2E 4D 4A 55 26 2A    	.byte	$2e,$2e,$4d,$4a,$55,$26,$2a,$2e
   3668 0000F80B 2E                    
   3669 0000F80C 2E 3C 4B 49 4F 29 28    	.byte	$2e,$3c,$4b,$49,$4f,$29,$28,$2e
   3669 0000F813 2E                    
   3670 0000F814 2E 3E 3F 4C 3A 50 5F    	.byte	$2e,$3e,$3f,$4c,$3a,$50,$5f,$2e
   3670 0000F81B 2E                    
   3671 0000F81C 2E 2E 22 2E 7B 2B 2E    	.byte	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 64
noc_boot21.a
   3671 0000F823 2E                    
   3672 0000F824 2E 2E 0D 7D 2E 7C 2E    	.byte	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
   3672 0000F82B 2E                    
   3673 0000F82C 2E 2E 2E 2E 2E 2E 08    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
   3673 0000F833 2E                    
   3674 0000F834 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3674 0000F83B 2E                    
   3675 0000F83C 2E 7F 2E 2E 2E 2E 1B    	.byte	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
   3675 0000F843 2E                    
   3676 0000F844 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3676 0000F84B 2E                    
                                        
   3678 0000F84C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3678 0000F853 2E                    
   3679 0000F854 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3679 0000F85B 2E                    
   3680 0000F85C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3680 0000F863 2E                    
   3681 0000F864 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3681 0000F86B 2E                    
   3682 0000F86C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3682 0000F873 2E                    
   3683 0000F874 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3683 0000F87B 2E                    
   3684 0000F87C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3684 0000F883 2E                    
   3685 0000F884 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3685 0000F88B 2E                    
   3686 0000F88C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3686 0000F893 2E                    
   3687 0000F894 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3687 0000F89B 2E                    
   3688 0000F89C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3688 0000F8A3 2E                    
   3689 0000F8A4 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3689 0000F8AB 2E                    
   3690 0000F8AC 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3690 0000F8B3 2E                    
   3691 0000F8B4 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3691 0000F8BB 2E                    
   3692 0000F8BC 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3692 0000F8C3 2E                    
   3693 0000F8C4 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3693 0000F8CB 2E                    
                                        
                                        ; control
   3696 0000F8CC                        keybdControlCodes:
   3697 0000F8CC 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3697 0000F8D3 2E                    
   3698 0000F8D4 2E 2E 2E 2E 2E 09 7E    	.byte	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
   3698 0000F8DB 2E                    
   3699 0000F8DC 2E 2E 2E 2E 2E 11 21    	.byte	$2e,$2e,$2e,$2e,$2e,$11,$21,$2e
   3699 0000F8E3 2E                    
   3700 0000F8E4 2E 2E 1A 13 01 17 40    	.byte	$2e,$2e,$1a,$13,$01,$17,$40,$2e
   3700 0000F8EB 2E                    
   3701 0000F8EC 2E 03 18 04 05 24 23    	.byte	$2e,$03,$18,$04,$05,$24,$23,$2e
   3701 0000F8F3 2E                    
   3702 0000F8F4 2E 20 16 06 14 12 25    	.byte	$2e,$20,$16,$06,$14,$12,$25,$2e
   3702 0000F8FB 2E                    
   3703 0000F8FC 2E 0E 02 08 07 19 5E    	.byte	$2e,$0e,$02,$08,$07,$19,$5e,$2e
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 65
noc_boot21.a
   3703 0000F903 2E                    
   3704 0000F904 2E 2E 0D 0A 15 26 2A    	.byte	$2e,$2e,$0d,$0a,$15,$26,$2a,$2e
   3704 0000F90B 2E                    
   3705 0000F90C 2E 3C 0B 09 0F 29 28    	.byte	$2e,$3c,$0b,$09,$0f,$29,$28,$2e
   3705 0000F913 2E                    
   3706 0000F914 2E 3E 3F 0C 3A 10 5F    	.byte	$2e,$3e,$3f,$0c,$3a,$10,$5f,$2e
   3706 0000F91B 2E                    
   3707 0000F91C 2E 2E 22 2E 7B 2B 2E    	.byte	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
   3707 0000F923 2E                    
   3708 0000F924 2E 2E 0D 7D 2E 7C 2E    	.byte	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
   3708 0000F92B 2E                    
   3709 0000F92C 2E 2E 2E 2E 2E 2E 08    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
   3709 0000F933 2E                    
   3710 0000F934 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3710 0000F93B 2E                    
   3711 0000F93C 2E 7F 2E 2E 2E 2E 1B    	.byte	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
   3711 0000F943 2E                    
   3712 0000F944 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3712 0000F94B 2E                    
                                        
   3714 0000F94C                        keybdExtendedCodes:
   3715 0000F94C 2E 2E 2E 2E A3 A1 A2    	.byte	$2e,$2e,$2e,$2e,$a3,$a1,$a2,$2e
   3715 0000F953 2E                    
   3716 0000F954 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3716 0000F95B 2E                    
   3717 0000F95C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3717 0000F963 2E                    
   3718 0000F964 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3718 0000F96B 2E                    
   3719 0000F96C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3719 0000F973 2E                    
   3720 0000F974 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3720 0000F97B 2E                    
   3721 0000F97C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3721 0000F983 2E                    
   3722 0000F984 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3722 0000F98B 2E                    
   3723 0000F98C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3723 0000F993 2E                    
   3724 0000F994 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3724 0000F99B 2E                    
   3725 0000F99C 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3725 0000F9A3 2E                    
   3726 0000F9A4 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3726 0000F9AB 2E                    
   3727 0000F9AC 2E 2E 2E 2E 2E 2E 2E    	.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
   3727 0000F9B3 2E                    
   3728 0000F9B4 2E 95 2E 93 94 2E 2E    	.byte	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
   3728 0000F9BB 2E                    
   3729 0000F9BC 98 99 92 2E 91 90 2E    	.byte	$98,$99,$92,$2e,$91,$90,$2e,$2e
   3729 0000F9C3 2E                    
   3730 0000F9C4 2E 2E 97 2E 2E 96 2E    	.byte	$2e,$2e,$97,$2e,$2e,$96,$2e,$2e
   3730 0000F9CB 2E                    
                                        
                                        
   3733 0000F9CC FF FF FF FF FF FF FF    		org		0xFFFE
   3733 0000F9D3 FF FF FF FF FF FF FF  
   3733 0000F9DA FF FF FF FF FF FF FF  
   3733 0000F9E1 FF FF FF FF FF FF FF  
   3733 0000F9E8 FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 66
noc_boot21.a
   3733 0000F9EF FF FF FF FF FF FF FF  
   3733 0000F9F6 FF FF FF FF FF FF FF  
   3733 0000F9FD FF FF FF FF FF FF FF  
   3733 0000FA04 FF FF FF FF FF FF FF  
   3733 0000FA0B FF FF FF FF FF FF FF  
   3733 0000FA12 FF FF FF FF FF FF FF  
   3733 0000FA19 FF FF FF FF FF FF FF  
   3733 0000FA20 FF FF FF FF FF FF FF  
   3733 0000FA27 FF FF FF FF FF FF FF  
   3733 0000FA2E FF FF FF FF FF FF FF  
   3733 0000FA35 FF FF FF FF FF FF FF  
   3733 0000FA3C FF FF FF FF FF FF FF  
   3733 0000FA43 FF FF FF FF FF FF FF  
   3733 0000FA4A FF FF FF FF FF FF FF  
   3733 0000FA51 FF FF FF FF FF FF FF  
   3733 0000FA58 FF FF FF FF FF FF FF  
   3733 0000FA5F FF FF FF FF FF FF FF  
   3733 0000FA66 FF FF FF FF FF FF FF  
   3733 0000FA6D FF FF FF FF FF FF FF  
   3733 0000FA74 FF FF FF FF FF FF FF  
   3733 0000FA7B FF FF FF FF FF FF FF  
   3733 0000FA82 FF FF FF FF FF FF FF  
   3733 0000FA89 FF FF FF FF FF FF FF  
   3733 0000FA90 FF FF FF FF FF FF FF  
   3733 0000FA97 FF FF FF FF FF FF FF  
   3733 0000FA9E FF FF FF FF FF FF FF  
   3733 0000FAA5 FF FF FF FF FF FF FF  
   3733 0000FAAC FF FF FF FF FF FF FF  
   3733 0000FAB3 FF FF FF FF FF FF FF  
   3733 0000FABA FF FF FF FF FF FF FF  
   3733 0000FAC1 FF FF FF FF FF FF FF  
   3733 0000FAC8 FF FF FF FF FF FF FF  
   3733 0000FACF FF FF FF FF FF FF FF  
   3733 0000FAD6 FF FF FF FF FF FF FF  
   3733 0000FADD FF FF FF FF FF FF FF  
   3733 0000FAE4 FF FF FF FF FF FF FF  
   3733 0000FAEB FF FF FF FF FF FF FF  
   3733 0000FAF2 FF FF FF FF FF FF FF  
   3733 0000FAF9 FF FF FF FF FF FF FF  
   3733 0000FB00 FF FF FF FF FF FF FF  
   3733 0000FB07 FF FF FF FF FF FF FF  
   3733 0000FB0E FF FF FF FF FF FF FF  
   3733 0000FB15 FF FF FF FF FF FF FF  
   3733 0000FB1C FF FF FF FF FF FF FF  
   3733 0000FB23 FF FF FF FF FF FF FF  
   3733 0000FB2A FF FF FF FF FF FF FF  
   3733 0000FB31 FF FF FF FF FF FF FF  
   3733 0000FB38 FF FF FF FF FF FF FF  
   3733 0000FB3F FF FF FF FF FF FF FF  
   3733 0000FB46 FF FF FF FF FF FF FF  
   3733 0000FB4D FF FF FF FF FF FF FF  
   3733 0000FB54 FF FF FF FF FF FF FF  
   3733 0000FB5B FF FF FF FF FF FF FF  
   3733 0000FB62 FF FF FF FF FF FF FF  
   3733 0000FB69 FF FF FF FF FF FF FF  
   3733 0000FB70 FF FF FF FF FF FF FF  
   3733 0000FB77 FF FF FF FF FF FF FF  
   3733 0000FB7E FF FF FF FF FF FF FF  
   3733 0000FB85 FF FF FF FF FF FF FF  
   3733 0000FB8C FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 67
noc_boot21.a
   3733 0000FB93 FF FF FF FF FF FF FF  
   3733 0000FB9A FF FF FF FF FF FF FF  
   3733 0000FBA1 FF FF FF FF FF FF FF  
   3733 0000FBA8 FF FF FF FF FF FF FF  
   3733 0000FBAF FF FF FF FF FF FF FF  
   3733 0000FBB6 FF FF FF FF FF FF FF  
   3733 0000FBBD FF FF FF FF FF FF FF  
   3733 0000FBC4 FF FF FF FF FF FF FF  
   3733 0000FBCB FF FF FF FF FF FF FF  
   3733 0000FBD2 FF FF FF FF FF FF FF  
   3733 0000FBD9 FF FF FF FF FF FF FF  
   3733 0000FBE0 FF FF FF FF FF FF FF  
   3733 0000FBE7 FF FF FF FF FF FF FF  
   3733 0000FBEE FF FF FF FF FF FF FF  
   3733 0000FBF5 FF FF FF FF FF FF FF  
   3733 0000FBFC FF FF FF FF FF FF FF  
   3733 0000FC03 FF FF FF FF FF FF FF  
   3733 0000FC0A FF FF FF FF FF FF FF  
   3733 0000FC11 FF FF FF FF FF FF FF  
   3733 0000FC18 FF FF FF FF FF FF FF  
   3733 0000FC1F FF FF FF FF FF FF FF  
   3733 0000FC26 FF FF FF FF FF FF FF  
   3733 0000FC2D FF FF FF FF FF FF FF  
   3733 0000FC34 FF FF FF FF FF FF FF  
   3733 0000FC3B FF FF FF FF FF FF FF  
   3733 0000FC42 FF FF FF FF FF FF FF  
   3733 0000FC49 FF FF FF FF FF FF FF  
   3733 0000FC50 FF FF FF FF FF FF FF  
   3733 0000FC57 FF FF FF FF FF FF FF  
   3733 0000FC5E FF FF FF FF FF FF FF  
   3733 0000FC65 FF FF FF FF FF FF FF  
   3733 0000FC6C FF FF FF FF FF FF FF  
   3733 0000FC73 FF FF FF FF FF FF FF  
   3733 0000FC7A FF FF FF FF FF FF FF  
   3733 0000FC81 FF FF FF FF FF FF FF  
   3733 0000FC88 FF FF FF FF FF FF FF  
   3733 0000FC8F FF FF FF FF FF FF FF  
   3733 0000FC96 FF FF FF FF FF FF FF  
   3733 0000FC9D FF FF FF FF FF FF FF  
   3733 0000FCA4 FF FF FF FF FF FF FF  
   3733 0000FCAB FF FF FF FF FF FF FF  
   3733 0000FCB2 FF FF FF FF FF FF FF  
   3733 0000FCB9 FF FF FF FF FF FF FF  
   3733 0000FCC0 FF FF FF FF FF FF FF  
   3733 0000FCC7 FF FF FF FF FF FF FF  
   3733 0000FCCE FF FF FF FF FF FF FF  
   3733 0000FCD5 FF FF FF FF FF FF FF  
   3733 0000FCDC FF FF FF FF FF FF FF  
   3733 0000FCE3 FF FF FF FF FF FF FF  
   3733 0000FCEA FF FF FF FF FF FF FF  
   3733 0000FCF1 FF FF FF FF FF FF FF  
   3733 0000FCF8 FF FF FF FF FF FF FF  
   3733 0000FCFF FF FF FF FF FF FF FF  
   3733 0000FD06 FF FF FF FF FF FF FF  
   3733 0000FD0D FF FF FF FF FF FF FF  
   3733 0000FD14 FF FF FF FF FF FF FF  
   3733 0000FD1B FF FF FF FF FF FF FF  
   3733 0000FD22 FF FF FF FF FF FF FF  
   3733 0000FD29 FF FF FF FF FF FF FF  
   3733 0000FD30 FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 68
noc_boot21.a
   3733 0000FD37 FF FF FF FF FF FF FF  
   3733 0000FD3E FF FF FF FF FF FF FF  
   3733 0000FD45 FF FF FF FF FF FF FF  
   3733 0000FD4C FF FF FF FF FF FF FF  
   3733 0000FD53 FF FF FF FF FF FF FF  
   3733 0000FD5A FF FF FF FF FF FF FF  
   3733 0000FD61 FF FF FF FF FF FF FF  
   3733 0000FD68 FF FF FF FF FF FF FF  
   3733 0000FD6F FF FF FF FF FF FF FF  
   3733 0000FD76 FF FF FF FF FF FF FF  
   3733 0000FD7D FF FF FF FF FF FF FF  
   3733 0000FD84 FF FF FF FF FF FF FF  
   3733 0000FD8B FF FF FF FF FF FF FF  
   3733 0000FD92 FF FF FF FF FF FF FF  
   3733 0000FD99 FF FF FF FF FF FF FF  
   3733 0000FDA0 FF FF FF FF FF FF FF  
   3733 0000FDA7 FF FF FF FF FF FF FF  
   3733 0000FDAE FF FF FF FF FF FF FF  
   3733 0000FDB5 FF FF FF FF FF FF FF  
   3733 0000FDBC FF FF FF FF FF FF FF  
   3733 0000FDC3 FF FF FF FF FF FF FF  
   3733 0000FDCA FF FF FF FF FF FF FF  
   3733 0000FDD1 FF FF FF FF FF FF FF  
   3733 0000FDD8 FF FF FF FF FF FF FF  
   3733 0000FDDF FF FF FF FF FF FF FF  
   3733 0000FDE6 FF FF FF FF FF FF FF  
   3733 0000FDED FF FF FF FF FF FF FF  
   3733 0000FDF4 FF FF FF FF FF FF FF  
   3733 0000FDFB FF FF FF FF FF FF FF  
   3733 0000FE02 FF FF FF FF FF FF FF  
   3733 0000FE09 FF FF FF FF FF FF FF  
   3733 0000FE10 FF FF FF FF FF FF FF  
   3733 0000FE17 FF FF FF FF FF FF FF  
   3733 0000FE1E FF FF FF FF FF FF FF  
   3733 0000FE25 FF FF FF FF FF FF FF  
   3733 0000FE2C FF FF FF FF FF FF FF  
   3733 0000FE33 FF FF FF FF FF FF FF  
   3733 0000FE3A FF FF FF FF FF FF FF  
   3733 0000FE41 FF FF FF FF FF FF FF  
   3733 0000FE48 FF FF FF FF FF FF FF  
   3733 0000FE4F FF FF FF FF FF FF FF  
   3733 0000FE56 FF FF FF FF FF FF FF  
   3733 0000FE5D FF FF FF FF FF FF FF  
   3733 0000FE64 FF FF FF FF FF FF FF  
   3733 0000FE6B FF FF FF FF FF FF FF  
   3733 0000FE72 FF FF FF FF FF FF FF  
   3733 0000FE79 FF FF FF FF FF FF FF  
   3733 0000FE80 FF FF FF FF FF FF FF  
   3733 0000FE87 FF FF FF FF FF FF FF  
   3733 0000FE8E FF FF FF FF FF FF FF  
   3733 0000FE95 FF FF FF FF FF FF FF  
   3733 0000FE9C FF FF FF FF FF FF FF  
   3733 0000FEA3 FF FF FF FF FF FF FF  
   3733 0000FEAA FF FF FF FF FF FF FF  
   3733 0000FEB1 FF FF FF FF FF FF FF  
   3733 0000FEB8 FF FF FF FF FF FF FF  
   3733 0000FEBF FF FF FF FF FF FF FF  
   3733 0000FEC6 FF FF FF FF FF FF FF  
   3733 0000FECD FF FF FF FF FF FF FF  
   3733 0000FED4 FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Thu Jun 15 19:02:50 2017     Page 69
noc_boot21.a
   3733 0000FEDB FF FF FF FF FF FF FF  
   3733 0000FEE2 FF FF FF FF FF FF FF  
   3733 0000FEE9 FF FF FF FF FF FF FF  
   3733 0000FEF0 FF FF FF FF FF FF FF  
   3733 0000FEF7 FF FF FF FF FF FF FF  
   3733 0000FEFE FF FF FF FF FF FF FF  
   3733 0000FF05 FF FF FF FF FF FF FF  
   3733 0000FF0C FF FF FF FF FF FF FF  
   3733 0000FF13 FF FF FF FF FF FF FF  
   3733 0000FF1A FF FF FF FF FF FF FF  
   3733 0000FF21 FF FF FF FF FF FF FF  
   3733 0000FF28 FF FF FF FF FF FF FF  
   3733 0000FF2F FF FF FF FF FF FF FF  
   3733 0000FF36 FF FF FF FF FF FF FF  
   3733 0000FF3D FF FF FF FF FF FF FF  
   3733 0000FF44 FF FF FF FF FF FF FF  
   3733 0000FF4B FF FF FF FF FF FF FF  
   3733 0000FF52 FF FF FF FF FF FF FF  
   3733 0000FF59 FF FF FF FF FF FF FF  
   3733 0000FF60 FF FF FF FF FF FF FF  
   3733 0000FF67 FF FF FF FF FF FF FF  
   3733 0000FF6E FF FF FF FF FF FF FF  
   3733 0000FF75 FF FF FF FF FF FF FF  
   3733 0000FF7C FF FF FF FF FF FF FF  
   3733 0000FF83 FF FF FF FF FF FF FF  
   3733 0000FF8A FF FF FF FF FF FF FF  
   3733 0000FF91 FF FF FF FF FF FF FF  
   3733 0000FF98 FF FF FF FF FF FF FF  
   3733 0000FF9F FF FF FF FF FF FF FF  
   3733 0000FFA6 FF FF FF FF FF FF FF  
   3733 0000FFAD FF FF FF FF FF FF FF  
   3733 0000FFB4 FF FF FF FF FF FF FF  
   3733 0000FFBB FF FF FF FF FF FF FF  
   3733 0000FFC2 FF FF FF FF FF FF FF  
   3733 0000FFC9 FF FF FF FF FF FF FF  
   3733 0000FFD0 FF FF FF FF FF FF FF  
   3733 0000FFD7 FF FF FF FF FF FF FF  
   3733 0000FFDE FF FF FF FF FF FF FF  
   3733 0000FFE5 FF FF FF FF FF FF FF  
   3733 0000FFEC FF FF FF FF FF FF FF  
   3733 0000FFF3 FF FF FF FF FF FF FF  
   3733 0000FFFA FF FF FF FF           
   3734 0000FFFE 48 F4                   		dw		start
