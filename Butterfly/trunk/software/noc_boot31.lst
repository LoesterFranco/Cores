Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 1
noc_boot31.a

                                        ; ============================================================================
                                        ;        __
                                        ;   \\__/ o\    (C) 2017  Robert Finch, Waterloo
                                        ;    \  __ /    All rights reserved.
                                        ;     \/_//     robfinch<remove>@finitron.ca
                                        ;       ||
                                        ;  
                                        ;
                                        ; This source file is free software: you can redistribute it and/or modify 
                                        ; it under the terms of the GNU Lesser General Public License as published 
                                        ; by the Free Software Foundation, either version 3 of the License, or     
                                        ; (at your option) any later version.                                      
                                        ;                                                                          
                                        ; This source file is distributed in the hope that it will be useful,      
                                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                                        ; GNU General Public License for more details.                             
                                        ;                                                                          
                                        ; You should have received a copy of the GNU General Public License        
                                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                                        ;                                    
                                        ;                                      
                                        ; This boot rom for node $31.
                                        ; ============================================================================
                                        ;
     26 = 0D                            CR	= 13
     27 = 0A                            LF	= 10
     28 = 09                            CTRLH	equ		9
     29 = 20                            txBuf	equ		32
     30 = 30                            rxBuf	equ		48
                                        
     32 = 01                            MT_RST		equ		1
     33 = 02                            MT_RST_ACK	equ		2
     34 = 03                            MT_STOP		equ		3
     35 = 04                            MT_KEYSTROKE			equ	4
     36 = 05                            MT_SET_INPUT_FOCUS		equ	5
     37 = 06                            MT_BUTTON_STATUS		equ	6
     38 = 07                            MT_REQ_INP_FOCUS		equ	7
     39 = 08                            MT_GRNT_INP_FOCUS		equ 8
     40 = 09                            MT_PING					equ	9
     41 = 0A                            MT_START_BASIC_LOAD		equ	10
     42 = 0B                            MT_LOAD_BASIC_CHAR		equ	11
     43 = 0C                            MT_RUN_BASIC_PROG		equ	12
     44 = 0D                            MT_BASIC_EXIT			equ	13
     45 = 0F                            MT_REQ_OUT_FOCUS		equ	15
     46 = 10                            MT_GRNT_OUT_FOCUS		equ	16
     47 = 11                            MT_OUT_CHAR				equ	17
     48 = 12                            MT_PING_ACK				equ	18
     49 = 13                            MT_ETH_PACKET			equ	19
     50 = 14                            MT_GET_DATETIME			equ	20
     51 = 15                            MT_SET_DATETIME			equ	21
     52 = 16                            MT_DATETIME_ACK			equ	22
                                        
     54 = 000000000000B000                              ROUTER		equ	$B000
     55 = 10                            RTR_RXSTAT	equ	$10
     56 = 12                            RTR_TXSTAT	equ	$12
                                        
     58 = 00                            ROUTER_TRB	equ	0
                                        
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 2
noc_boot31.a
     60 = 0F                            MSG_DST		equ	15
     61 = 0E                            MSG_SRC		equ	14
     62 = 09                            MSG_TTL		equ	9
     63 = 08                            MSG_TYPE	equ	8
     64 = 07                            MSG_GSD		equ	7
                                        
     66 = 000000000000A000                              ETHERNET	EQU		0xA000
     67 = 00                            ETH_MODER		EQU		0x00
     68 = 04                            ETH_INT_SOURCE	EQU		0x04
     69 = 08                            ETH_INT_MASK	EQU		0x08
     70 = 0C                            ETH_IPGT		EQU		0x0C
     71 = 10                            ETH_IPGR1		EQU		0x10
     72 = 14                            ETH_IPGR2		EQU		0x14
     73 = 18                            ETH_PACKETLEN	EQU		0x18
     74 = 1C                            ETH_COLLCONF	EQU		0x1C
     75 = 20                            ETH_TX_DB_NUM	EQU		0x20
     76 = 24                            ETH_CTRLMODER	EQU		0x24
     77 = 28                            ETH_MIIMODER	EQU		0x28
     78 = 2C                            ETH_MIICOMMAND	EQU		0x2C
     79 = 30                            ETH_MIIADDRESS	EQU		0x30
     80 = 34                            ETH_MIITXDATA	EQU		0x34
     81 = 38                            ETH_MIIRXDATA	EQU		0x38
     82 = 3C                            ETH_MIISTATUS	EQU		0x3C
     83 = 40                            ETH_MACADDR0	EQU		0x40
     84 = 44                            ETH_MACADDR1	EQU		0x44
     85 = 48                            ETH_HASH0_ADDR	EQU		0x48
     86 = 4C                            ETH_HASH1_ADDR	EQU		0x4C
     87 = 50                            ETH_TXCTRL		EQU		0x50
                                        
     89 = 4000                          eth_txbuf		EQU		$4000
     90 = 6000                          eth_rxbuf		EQU		$6000
                                        
                                        		bss
                                        		org		$10
     95 00000010                        unique_id	dw	0
                                        
                                        		.code
                                        		cpu		Butterfly16
                                        		org		0xE000
                                        ; ============================================================================
                                        ;        __
                                        ;   \\__/ o\    (C) 2017  Robert Finch, Waterloo
                                        ;    \  __ /    All rights reserved.
                                        ;     \/_//     robfinch<remove>@finitron.ca
                                        ;       ||
                                        ;  
                                        ;
                                        ; This source file is free software: you can redistribute it and/or modify 
                                        ; it under the terms of the GNU Lesser General Public License as published 
                                        ; by the Free Software Foundation, either version 3 of the License, or     
                                        ; (at your option) any later version.                                      
                                        ;                                                                          
                                        ; This source file is distributed in the hope that it will be useful,      
                                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                                        ; GNU General Public License for more details.                             
                                        ;                                                                          
                                        ; You should have received a copy of the GNU General Public License        
                                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                                        ;                                    
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 3
noc_boot31.a
                                        ;                                      
                                        ; Networking software components
                                        ; ============================================================================
                                        ;
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Zero out the transmit buffer.
                                        ; Used before building transmit buffer.
                                        ; Automatically inserts a time-to-live of 63, and the source id.
                                        ;
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	<none>
                                        ;----------------------------------------------------------------------------
                                        
    139 0000E000                        zeroTxBuf:
    140 0000E000 FE 6E                   		add		sp,sp,#-2
    141 0000E002 E0 D2                   		sw		r2,[sp]
    142 0000E004 00 40 0F 12             		lw		r2,#15
    143 0000E008                        zeroTxBuf1:
    144 0000E008 02 40 20 C0             		sb		r0,txBuf[r2]
    145 0000E00C FF 62                   		sub		r2,r2,#1
    146 0000E00E FC BB                   		bpl		zeroTxBuf1
    147 0000E010 03 40 0F 12             		lw		r2,#63
    148 0000E014 02 40 09 C2             		sb		r2,txBuf+MSG_TTL
    149 0000E018 E4 32                   		tsr		r2,ID
    150 0000E01A A1 32                   		shr		r2,#1
    151 0000E01C A1 32                   		shr		r2,#1
    152 0000E01E A1 32                   		shr		r2,#1
    153 0000E020 A1 32                   		shr		r2,#1
    154 0000E022 02 40 0E C2             		sb		r2,txBuf+MSG_SRC	; X+Y
    155 0000E026 E4 32                   		tsr		r2,ID
    156 0000E028 00 40 5F 32             		and		r2,#$F
    157 0000E02C 04 4E 0C C2             		sb		r2,txBuf+MSG_GDS	; and Z
    158 0000E030 E0 F2                   		lw		r2,[sp]
    159 0000E032 02 6E                   		add		sp,sp,#2
    160 0000E034 F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Set the destination address field in the transmit buffer based on the
                                        ; source address in the receive buffer.
                                        ;----------------------------------------------------------------------------
                                        
    167 0000E036                        SetDestFromRx:
    168 0000E036 03 40 0E E1             		lb		r1,rxBuf+MSG_SRC
    169 0000E03A 02 40 0F C1             		sb		r1,txBuf+MSG_DST
    170 0000E03E 06 4E 0E E1             		lb		r1,rxBuf+MSG_GDS
    171 0000E042 06 4E 02 E2             		lb		r2,txBuf+MSG_GDS
    172 0000E046 81 31                   		shl		r1,#1
    173 0000E048 81 31                   		shl		r1,#1
    174 0000E04A 81 31                   		shl		r1,#1
    175 0000E04C 81 31                   		shl		r1,#1
    176 0000E04E 26 21                   		or		r1,r2
    177 0000E050 07 4E 00 C1             		sb		r1,txBuf+MSG_GDS
    178 0000E054 F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 4
noc_boot31.a
                                        ; Transmit on the network.
                                        ; Blocks until the transmit buffer is open.
                                        ;
                                        ; Prerequisites:
                                        ;	The transmit buffer txBuf must have already been loaded.
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	<none>
                                        ;----------------------------------------------------------------------------
                                        
    194 0000E056 FC 6E                  Xmit:	
    195 0000E058 E0 D1                   		sw		r1,[sp]
    196 0000E05A E2 D2                   		sw		r2,2[sp]
                                        		; wait for transmit buffer to empty
    198 0000E05C                        Xmit2:
    199 0000E05C 01 4B 02 E1             		lb		r1,ROUTER+RTR_TXSTAT
    200 0000E060 FD B9                   		bne		Xmit2
    201 0000E062 00 40 0F 12             		lw		r2,#15
    202 0000E066                        Xmit1:
    203 0000E066 02 40 20 E1             		lb		r1,txBuf[r2]
    204 0000E06A 00 4B 20 C1             		sb		r1,ROUTER[r2]
    205 0000E06E FF 62                   		add		r2,r2,#-1
    206 0000E070 FA BB                   		bpl		Xmit1
                                        		; trigger a transmit
    208 0000E072 01 11                   		lw		r1,#1
    209 0000E074 01 4B 02 C2             		sb		r2,ROUTER+RTR_TXSTAT
    210 0000E078 E2 F2                   		lw		r2,2[sp]
    211 0000E07A E0 F1                   		lw		r1,[sp]
    212 0000E07C 04 6E                   		add		sp,sp,#4
    213 0000E07E F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Receive from network.
                                        ; Receive status must have already indicated a message present.
                                        ; Copies recieve buffer from router to rxBuf.
                                        ; The router fifo is configured with first word fall-through. This means
                                        ; the data word appears on the fifo output before the fifo is popped.
                                        ; A fifo pop signal has to be sent after reading the data.
                                        ;
                                        ; Parameters:
                                        ;	<none>
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	<none>
                                        ;----------------------------------------------------------------------------
                                        
    231 0000E080                        Recv:
    232 0000E080 FC 6E                   		add		sp,sp,#-4
    233 0000E082 E0 D1                   		sw		r1,[sp]
    234 0000E084 E2 D2                   		sw		r2,2[sp]
    235 0000E086 00 40 0F 12             		lw		r2,#15
    236 0000E08A                        Recv1:
    237 0000E08A 00 4B 20 E1             		lb		r1,ROUTER[r2]			; copy message to local buffer
    238 0000E08E 03 40 20 C1             		sb		r1,rxBuf[r2]
    239 0000E092 FF 62                   		add		r2,r2,#-1
    240 0000E094 FA BB                   		bpl		Recv1
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 5
noc_boot31.a
    241 0000E096 01 4B 00 E1             		lb		r1,ROUTER+RTR_RXSTAT
    242 0000E09A 04 40 60 31             		or		r1,#$40
    243 0000E09E 01 4B 00 C1             		sb		r1,ROUTER+RTR_RXSTAT	; pop the rx fifo
    244 0000E0A2 E0 F1                   		lw		r1,[sp]
    245 0000E0A4 E2 F2                   		lw		r2,2[sp]
    246 0000E0A6 04 6E                   		add		sp,sp,#4
    247 0000E0A8 F0 80                   		ret
                                        
                                        ;****************************************************************;
                                        ;                                                                ;
                                        ;		Tiny BASIC Worker for the Finitron Butterfly             ;
                                        ;                                                                ;
                                        ; Supports worker threads.                                       ;
                                        ; There is no user interface to worker threads so the commands   ;
                                        ; LOAD and SAVE are removed.                                     ;
                                        ;                                                                ;
                                        ; Derived from a 68000 derivative of Palo Alto Tiny BASIC as     ;
                                        ; published in the May 1976 issue of Dr. Dobb's Journal.         ;
                                        ; Adapted to the 68000 by:                                       ;
                                        ;	Gordon brndly						                         ;
                                        ;	12147 - 51 Street					                         ;
                                        ;	Edmonton AB  T5W 3G8					                     ;
                                        ;	Canada							                             ;
                                        ;	(updated mailing address for 1996)			                 ;
                                        ;                                                                ;
                                        ; Adapted to the Butterfly by:                                    ;
                                        ;    Robert Finch                                                ;
                                        ;    Ontario, Canada                                             ;
                                        ;	 rob<remove>@finitron.ca                                     ;  
                                        ;****************************************************************;
                                        ;   Copyright (C) 2005-2017 by Robert Finch. This program may be ;
                                        ;    freely distributed for personal use only. All commercial	 ;
                                        ;		       rights are reserved.			                     ;
                                        ;****************************************************************;
                                        ;
                                        ; Register Usage
                                        ; r8 = text pointer (global usage)
                                        ; r3,r4 = inputs parameters to subroutines
                                        ; r2 = return value
                                        ;
                                        ;* Vers. 1.0  1984/7/17	- Original version by Gordon brndly
                                        ;*	1.1  1984/12/9	- Addition of '0x' print term by Marvin Lipford
                                        ;*	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                                        
                                        ;	OPT	FRS,BRS 	forward ref.'s & brnches default to short
                                        
                                        ;XMIT_FULL		equ	0x40		; the transmit buffer is full
                                        ;DATA_PRESENT	equ	0x08		; there is data preset at the serial port bc_uart3
    288 = 01                            DATA_PRESENT	equ	0x01		; there is data preset at the serial port bc_uart3
    289 = 20                            XMIT_NOT_FULL	equ	0x20
                                        
    291 = 00000000FFFFDC40                              TS_TIMER	equ		0xFFFFDC40		; system time slice timer
    292 = 00000000FFFFDC50                              KBD			equ		0xFFFFDC50
                                        
    294 = 00000000FFFFDCA0                              RAND		equ		0xFFFFDCA0
    295 = 00000000FFFFD800                              VIC			equ		0xFFFFD800
                                        
    297 = 2000                          VIDEORAM	equ		0x00002000
                                        
                                        ; BOOT ROM routines
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 6
noc_boot31.a
                                        
    301 = 0000000FFFFFF804                              getSerial	equ		0xFFFFFF804	; get a serial port character
    302 = 0000000FFFFFF808                              peekSerial	equ		0xFFFFFF808	; get a serial port character
    303 = 0000000FFFFFF80C                              putSerial	equ		0xFFFFFF80C	; put a character to serial port
    304 = 0000000FFFFFF82C                              clearScreen	equ		0xFFFFFF82C	; clear the screen
    305 = 0000000FFFFFF840                              getKbdCharWait	equ	0xFFFFFF840
    306 = 0000000FFFFFF844                              getKbdChar		equ	0xFFFFFF844
                                        
    308 = 20                            warmStart   equ     0x20
    309 = 24                            usrJmp      equ     0x24
                                        
    311 = 0D                            CR		equ	0x0D		; ASCII equates
    312 = 0A                            LF		equ	0x0A
    313 = 09                            TAB		equ	0x09
    314 = 03                            CTRLC	equ	0x03
    315 = 08                            CTRLH	equ	0x08
    316 = 13                            CTRLS	equ	0x13
    317 = 18                            CTRLX	equ	0x18
                                        
    319 = 50                            BUFLEN	equ	80	;	length of keyboard input buffer
                                        
                                        	code
                                        ;	org	0xC000	;
                                        ;
                                        ; Standard jump table. You can change these addresses if you are
                                        ; customizing this interpreter for a different environment.
                                        ;
    328 0000E0AA FF BE                  START	jmp	CSTART	;	Cold Start entry point
    329 0000E0AC 26 AE                  GOWARM	jmp	WSTART	;	Warm Start entry point
    330 0000E0AE 75 40 01 AE            GOOUT	jmp	OUTC	;	Jump to character-out routine
    331 0000E0B2 75 40 00 AE            GOIN	jmp	INC		;Jump to character-in routine
    332 0000E0B6 78 40 01 AE            GOAUXO	jmp	AUXOUT	;	Jump to auxiliary-out routine
    333 0000E0BA 79 40 0E AE            GOAUXI	jmp	AUXIN	;	Jump to auxiliary-in routine
    334 0000E0BE 7D 40 00 AE            GOBYE	jmp	BYEBYE	;	Jump to monitor, DOS, etc.
                                        ;
                                        ; Modifiable system constants:
                                        ;
    338 0000E0C2 00 02                  TXTBGN	dw	0x0200		;beginning of program memory
    339 0000E0C4 00 1E                  ENDMEM	dw	0x1E00	;	end of available memory
                                        ;
    341 0000E0C6                        INITTBW:
                                        	; First save off the link register and OS sp value
    343 0000E0C6 FE 6E                   	sub		sp,sp,#2
    344 0000E0C8 E0 DF                   	sw		lr,[sp]
    345 0000E0CA 0C 4E 02 F1             	lw		r1,TXTBGN	;	init. end-of-program pointer
    346 0000E0CE 09 40 06 D1             	sw		r1,TXTUNF
    347 0000E0D2 0C 4E 04 F1             	lw		r1,ENDMEM	;	get address of end of memory
    348 0000E0D6 E0 4F 10 11             	sub		r1,r1,#512	; 	reserve 512 bytes for the stack
    349 0000E0DA 0A 40 00 D1             	sw		r1,STKBOT
    350 0000E0DE E0 4F 10 11             	sub     r1,r1,#512 ;   128 vars
    351 0000E0E2 09 40 08 D1             	sw      r1,VARBGN
    352 0000E0E6 EA AF                   	call    clearVars   ; clear the variable area
    353 0000E0E8 08 40 0C D0             	sw		r0,LOPVAR   ; initialize internal variables
    354 0000E0EC 08 40 08 D0             	sw		r0,STKGOS
    355 0000E0F0 08 40 06 D0             	sw		r0,CURRNT	;	current line number pointer = 0
    356 0000E0F4 E0 FF                   	lw		lr,[sp]
    357 0000E0F6 02 6E                   	add		sp,sp,#2
    358 0000E0F8 F0 80                   	ret
                                        ;
                                        ; The main interpreter starts here:
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 7
noc_boot31.a
                                        ;
                                        ; Usage
                                        ; r1 = temp
                                        ; r8 = text buffer pointer
                                        ; r12 = end of text in text buffer
                                        ;
                                        	; At the end of the running program it'll go back to
                                        	; the warm start location. Use this to return.
    369 0000E0FA                        WSTART
    370 0000E0FA 08 40 0C D0             	sw		r0,LOPVAR   ; initialize internal variables
    371 0000E0FE 08 40 08 D0             	sw		r0,STKGOS
    372 0000E102 08 40 06 D0             	sw		r0,CURRNT	;	current line number pointer = 0
    373 0000E106 08 40 04 FE             	lw		sp,OSSP
    374 0000E10A E0 FF                   	lw		lr,[sp]
    375 0000E10C 02 6E                   	add		sp,sp,#2
    376 0000E10E F0 80                   	ret
                                        
                                        	; Entry point which is called by the reciever dispatcher.
    379 0000E110                        ST3:
    380 0000E110 FE 6E                   	add		sp,sp,#-2
    381 0000E112 E0 DF                   	sw		lr,[sp]
    382 0000E114 08 40 04 DE             	sw		sp,OSSP
    383 0000E118 0C 4E 04 FE             	lw		sp,ENDMEM	;	init S.P.
    384 0000E11C 6C 40 02 AF             	call	TOUPBUF 	; convert to upper case
    385 0000E120 80 1C                   	lw		r12,r8		; save pointer to end of line
    386 0000E122 0A 40 0E 18             	lea		r8,BUFFER	; point to the beginning of line
    387 0000E126 6E AE                   	br		DIRECT
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** Tables *** DIRECT *** EXEC ***
                                        ;
                                        ; This section of the code tests a string against a table. When
                                        ; a match is found, control is transferred to the section of
                                        ; code according to the table.
                                        ;
                                        ; At 'EXEC', r8 should point to the string, r9 should point to
                                        ; the character table, and r10 should point to the execution
                                        ; table. At 'DIRECT', r8 should point to the string, r9 and
                                        ; r10 will be set up to point to TAB1 and TAB1_1, which are
                                        ; the tables of all direct and statement commands.
                                        ;
                                        ; A '.' in the string will terminate the test and the partial
                                        ; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                                        ; 'PRIN.', or 'PRINT' will all match 'PRINT'.
                                        ;
                                        ; There are two tables: the character table and the execution
                                        ; table. The character table consists of any number of text items.
                                        ; Each item is a string of characters with the last character's
                                        ; high bit set to one. The execution table holds a 32-bit
                                        ; execution addresses that correspond to each entry in the
                                        ; character table.
                                        ;
                                        ; The end of the character table is a 0 byte which corresponds
                                        ; to the default routine in the execution table, which is
                                        ; executed if none of the other table items are matched.
                                        ;
                                        ; Character-matching tables:
    420 0000E128                        TAB1
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 8
noc_boot31.a
    421 0000E128 4C 49 53 D4             	db	"LIS",('T'+0x80)        ; Direct commands
    422 0000E12C 4E 45 D7                	db	"NE",('W'+0x80)
    423 0000E12F 52 55 CE                	db	"RU",('N'+0x80)
    424 0000E132                        TAB2
    425 0000E132 4E 45 58 D4             	db	"NEX",('T'+0x80)         ; Direct / statement
    426 0000E136 4C 45 D4                	db	"LE",('T'+0x80)
    427 0000E139 49 C6                   	db	"I",('F'+0x80)
    428 0000E13B 47 4F 54 CF             	db	"GOT",('O'+0x80)
    429 0000E13F 47 4F 53 55 C2          	db	"GOSU",('B'+0x80)
    430 0000E144 52 45 54 55 52 CE       	db	"RETUR",('N'+0x80)
    431 0000E14A 52 45 CD                	db	"RE",('M'+0x80)
    432 0000E14D 46 4F D2                	db	"FO",('R'+0x80)
    433 0000E150 49 4E 50 55 D4          	db	"INPU",('T'+0x80)
    434 0000E155 50 52 49 4E D4          	db	"PRIN",('T'+0x80)
    435 0000E15A 50 4F 4B 45 D7          	db	"POKE",('W'+0x80)
    436 0000E15F 50 4F 4B C5             	db	"POK",('E'+0x80)
    437 0000E163 53 54 4F D0             	db	"STO",('P'+0x80)
    438 0000E167 42 59 C5                	db	"BY",('E'+0x80)
    439 0000E16A 53 59 D3                	db	"SY",('S'+0x80)
    440 0000E16D 43 4C D2                    db  "CL",('R'+0x80)
    441 0000E170 45 58 49 D4             	db	"EXI",('T'+0x80)
    442 0000E174 00                      	db	0
    443 0000E175                        TAB4
    444 0000E175 4E 4F 44 45 4E 55 CD    	db	"NODENU",('M'+0x80)
                                      
    445 0000E17C 50 45 45 4B D7          	db	"PEEK",('W'+0x80)        ;Functions
    446 0000E181 50 45 45 CB             	db	"PEE",('K'+0x80)         ;Functions
    447 0000E185 52 4E C4                	db	"RN",('D'+0x80)
    448 0000E188 41 42 D3                	db	"AB",('S'+0x80)
    449 0000E18B 53 49 5A C5             	db	"SIZ",('E'+0x80)
    450 0000E18F 55 53 D2                	db  "US",('R'+0x80)
    451 0000E192 00                      	db	0
    452 0000E193                        TAB5
    453 0000E193 54 CF                   	db	"T",('O'+0x80)           ;"TO" in "FOR"
    454 0000E195 00                      	db	0
    455 0000E196                        TAB6
    456 0000E196 53 54 45 D0             	db	"STE",('P'+0x80)         ;"STEP" in "FOR"
    457 0000E19A 00                      	db	0
    458 0000E19B                        TAB8
    459 0000E19B 3E BD                   	db	'>',('='+0x80)           ;Relational operators
    460 0000E19D 3C BE                   	db	'<',('>'+0x80)
    461 0000E19F BE                      	db	('>'+0x80)
    462 0000E1A0 BD                      	db	('='+0x80)
    463 0000E1A1 3C BD                   	db	'<',('='+0x80)
    464 0000E1A3 BC                      	db	('<'+0x80)
    465 0000E1A4 00                      	db	0
    466 0000E1A5                        TAB9
    467 0000E1A5 41 4E C4                    db  "AN",('D'+0x80)
    468 0000E1A8 00                          db  0
    469 0000E1A9                        TAB10
    470 0000E1A9 4F D2                       db  "O",('R'+0x80)
    471 0000E1AB 00                          db  0
                                        
                                        	.align	4
                                        
                                        ;* Execution address tables:
    476 0000E1AC                        TAB1_1
    477 0000E1AC DA E2                   	dw	LISTX			;Direct commands
    478 0000E1AE 58 E2                   	dw	NEW
    479 0000E1B0 6C E2                   	dw	RUN
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 9
noc_boot31.a
    480 0000E1B2                        TAB2_1
    481 0000E1B2 2C E4                   	dw	NEXT		;	Direct / statement
    482 0000E1B4 26 E5                   	dw	LET
    483 0000E1B6 86 E4                   	dw	IF
    484 0000E1B8 9E E2                   	dw	GOTO
    485 0000E1BA 72 E3                   	dw	GOSUB
    486 0000E1BC A2 E3                   	dw	RETURN
    487 0000E1BE 8C E4                   	dw	IF2			; REM
    488 0000E1C0 CC E3                   	dw	FOR
    489 0000E1C2 AA E4                   	dw	INPUT
    490 0000E1C4 0E E3                   	dw	PRINT
    491 0000E1C6 10 E6                   	dw	POKEW
    492 0000E1C8 F0 E5                   	dw	POKE
    493 0000E1CA 66 E2                   	dw	STOP
    494 0000E1CC BE E0                   	dw	GOBYE
    495 0000E1CE 28 E6                   	dw	SYSX
    496 0000E1D0 B8 E2                   	dw  _clr
    497 0000E1D2 7C F0                   	dw	EXIT
    498 0000E1D4 1E E5                   	dw	DEFLT
    499 0000E1D6                        TAB4_1
    500 0000E1D6 56 EA                   	dw	NODENUM
    501 0000E1D8 A6 E9                   	dw  PEEKW
    502 0000E1DA 9A E9                   	dw	PEEK			;Functions
    503 0000E1DC C6 E9                   	dw	RND
    504 0000E1DE 20 EA                   	dw	ABS
    505 0000E1E0 46 EA                   	dw	SIZEX
    506 0000E1E2 B2 E9                   	dw  USRX
    507 0000E1E4 D0 E7                   	dw	XP40
    508 0000E1E6                        TAB5_1
    509 0000E1E6 E2 E3                   	dw	FR1			;"TO" in "FOR"
    510 0000E1E8 D6 EA                   	dw	QWHAT
    511 0000E1EA                        TAB6_1
    512 0000E1EA F4 E3                   	dw	FR2			;"STEP" in "FOR"
    513 0000E1EC FA E3                   	dw	FR3
    514 0000E1EE                        TAB8_1
    515 0000E1EE F2 E6                   	dw	XP11	;>=		Relational operators
    516 0000E1F0 FC E6                   	dw	XP12	;<>
    517 0000E1F2 06 E7                   	dw	XP13	;>
    518 0000E1F4 1A E7                   	dw	XP15	;=
    519 0000E1F6 10 E7                   	dw	XP14	;<=
    520 0000E1F8 24 E7                   	dw	XP16	;<
    521 0000E1FA 3E E7                   	dw	XP17
    522 0000E1FC                        TAB9_1
    523 0000E1FC 7E E6                       dw  XP_AND
    524 0000E1FE 86 E6                       dw  XP_ANDX
    525 0000E200                        TAB10_1
    526 0000E200 5A E6                       dw  XP_OR
    527 0000E202 62 E6                       dw  XP_ORX
                                        
                                        ;*
                                        ; r3 = match flag (trashed)
                                        ; r9 = text table
                                        ; r10 = exec table
                                        ; r11 = trashed
    534 0000E204                        DIRECT
    535 0000E204 12 4E 08 19             	lea		r9,TAB1
    536 0000E208 1A 4E 0C 1A             	lea		r10,TAB1_1
    537 0000E20C                        EXEC
    538 0000E20C F0 1B                   	lw		r11,lr		; save link reg
    539 0000E20E 63 40 0B AF             	call	IGNBLK		; ignore leading blanks
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 10
noc_boot31.a
    540 0000E212 B0 1F                   	lw		lr,r11		; restore link reg
    541 0000E214 80 1B                   	lw		r11,r8		; save the pointer
    542 0000E216 00 13                   	lw		r3,#0		; clear match flag
    543 0000E218                        EXLP
    544 0000E218 80 E1                   	lb		r1,[r8]		; get the program character
    545 0000E21A 01 68                   	add		r8,r8,#1
    546 0000E21C 90 E2                   	lb		r2,[r9]		; get the table character
    547 0000E21E 02 A9                   	bne		EXNGO		; If end of table,
    548 0000E220 B0 18                   	lw		r8,r11		;	restore the text pointer and...
    549 0000E222 12 AE                   	br		EXGO		;   execute the default.
    550 0000E224                        EXNGO
    551 0000E224 3D 21                   	cmp		r1,r3		; Else check for period...
    552 0000E226 10 A8                   	beq		EXGO		; if so, execute
    553 0000E228 07 40 5F 32             	and		r2,#0x7f	; ignore the table's high bit
    554 0000E22C 1D 22                   	cmp		r2,r1		;		is there a match?
    555 0000E22E 07 A8                   	beq		EXMAT
    556 0000E230 04 6A                   	add		r10,r10,#4	;if not, try the next entry
    557 0000E232 B0 18                   	lw		r8,r11		; reset the program pointer
    558 0000E234 00 13                   	lw		r3,#0		; sorry, no match
    559 0000E236                        EX1
    560 0000E236 01 69                   	add		r9,r9,#1
    561 0000E238 9F E1                   	lb		r1,-1[r9]	; get to the end of the entry
    562 0000E23A FD BB                   	bpl		EX1
    563 0000E23C ED BE                   	br		EXLP		; back for more matching
    564 0000E23E                        EXMAT
    565 0000E23E 02 40 0E 13             	lw		r3,#'.'		; we've got a match so far
    566 0000E242 01 69                   	add		r9,r9,#1
    567 0000E244 9F E1                   	lb		r1,-1[r9]	; end of table entry?
    568 0000E246 E8 BB                   	bpl		EXLP		; if not, go back for more
    569 0000E248                        EXGO
    570 0000E248 01 4B 00 E1             	lb		r1,ROUTER+RTR_RXSTAT
    571 0000E24C 03 A8                   	beq		EXGO1
    572 0000E24E 18 BF                   	call	Recv
    573 0000E250 84 40 02 AF             	call	RecvDispatch
    574 0000E254                        EXGO1
    575 0000E254 A0 FB                   	lw		r11,[r10]	; execute the appropriate routine
    576 0000E256 B0 80                   	jmp		[r11]
                                        
                                        
                                        ;    lb      r1,[r8]     ; get token from text space
                                        ;    bpl
                                        ;    and     r1,#0x7f
                                        ;    shl     r1,#2       ; * 4 - word offset
                                        ;    add     r1,r1,#TAB1_1
                                        ;    lw      r1,[r1]
                                        ;    jmp     [r1]
                                        
                                            
                                        ;
                                        ; What follows is the code to execute direct and statement
                                        ; commands. Control is transferred to these points via the command
                                        ; table lookup code of 'DIRECT' and 'EXEC' in the last section.
                                        ; After the command is executed, control is transferred to other
                                        ; sections as follows:
                                        ;
                                        ; For 'LISTX', 'NEW', and 'STOP': go back to the warm start point.
                                        ; For 'RUN': go execute the first stored line if any; else go
                                        ; back to the warm start point.
                                        ; For 'GOTO' and 'GOSUB': go execute the target line.
                                        ; For 'RETURN' and 'NEXT'; go back to saved return line.
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 11
noc_boot31.a
                                        ; For all others: if 'CURRNT' is 0, go to warm start; else go
                                        ; execute next command. (This is done in 'FINISH'.)
                                        ;
                                        ;******************************************************************
                                        ;
                                        ; *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                                        ;
                                        ; 'NEW<CR>' sets TXTUNF to point to TXTBGN
                                        ;
                                        ; 'STOP<CR>' goes back to WSTART
                                        ;
                                        ; 'RUN<CR>' finds the first stored line, stores its address
                                        ; in CURRNT, and starts executing it. Note that only those
                                        ; commands in TAB2 are legal for a stored program.
                                        ;
                                        ; RUN ON <node number> sends a run command to the specified node
                                        ;
                                        ; There are 3 more entries in 'RUN':
                                        ; 'RUNNXL' finds next line, stores it's address and executes it.
                                        ; 'RUNTSL' stores the address of this line and executes it.
                                        ; 'RUNSML' continues the execution on same line.
                                        ;
                                        ; 'GOTO expr<CR>' evaluates the expression, finds the target
                                        ; line, and jumps to 'RUNTSL' to do it.
                                        ;
    625 0000E258                        NEW
    626 0000E258 42 40 09 AF             	call	ENDCHK
    627 0000E25C 0C 4E 02 F1             	lw		r1,TXTBGN
    628 0000E260 09 40 06 D1             	sw		r1,TXTUNF	;	set the end pointer
    629 0000E264 2B AF                   	call    clearVars
                                        
    631 0000E266                        STOP
    632 0000E266 42 40 02 AF             	call	ENDCHK
    633 0000E26A 47 BE                   	br		WSTART		; WSTART will reset the stack
                                        
    635 0000E26C                        RUN
    636 0000E26C 41 40 0F AF             	call	ENDCHK
    637 0000E270 0C 4E 02 F8             	lw		r8,TXTBGN	;	set pointer to beginning
    638 0000E274 08 40 06 D8             	sw		r8,CURRNT
    639 0000E278 21 AF                   	call    clearVars
                                        
    641 0000E27A                        RUNNXL					; RUN <next line>
    642 0000E27A 08 40 06 F1             	lw		r1,CURRNT	; executing a program?
    643 0000E27E 3D B8                   	beq		WSTART		; if not, we've finished a direct stat.
    644 0000E280 00 11                   	lw		r1,#0	    ; else find the next line number
    645 0000E282 80 19                   	lw		r9,r8
    646 0000E284 49 40 0F AF             	call	FNDLNP		; search for the next line
    647 0000E288 38 B7                   	bgtu	WSTART		; if we've fallen off the end, stop
                                        
    649 0000E28A                        RUNTSL					; RUN <this line>
    650 0000E28A 08 40 06 D9             	sw		r9,CURRNT	; set CURRNT to point to the line no.
    651 0000E28E 92 18                   	lea		r8,2[r9]	; set the text pointer to
                                        
    653 0000E290                        RUNSML                  ; RUN <same line>
    654 0000E290 63 40 00 AF             	call	CHKIO		; see if a control-C was pressed
    655 0000E294 13 4E 02 19             	lea		r9,TAB2		; find command in TAB2
    656 0000E298 1B 4E 02 1A             	lea		r10,TAB2_1
    657 0000E29C B7 BE                   	br		EXEC		; and execute it
                                        
    659 0000E29E                        GOTO
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 12
noc_boot31.a
    660 0000E29E 1D 40 02 AF             	call	OREXPR		;evaluate the following expression
    661 0000E2A2 10 15                   	lw      r5,r1
    662 0000E2A4 40 40 03 AF             	call	ENDCHK		;must find end of line
    663 0000E2A8 50 11                   	lw      r1,r5
    664 0000E2AA 48 40 04 AF             	call	FNDLN		; find the target line
    665 0000E2AE ED B8                   	beq		RUNTSL		; go do it
    666 0000E2B0 24 4F 0F 11             	lea		r1,msgBadGotoGosub
    667 0000E2B4 41 40 01 AE             	br		ERROR		; no such line no.
                                        
                                        
    670 0000E2B8                        _clr
    671 0000E2B8 01 AF                       call    clearVars
    672 0000E2BA 57 AE                       br      FINISH
                                        
                                        ; Clear the variable area of memory
    675 0000E2BC                        clearVars
    676 0000E2BC FC 6E                       sub     sp,sp,#4
    677 0000E2BE E0 DF                       sw      lr,[sp]
    678 0000E2C0 E2 D6                       sw      r6,2[sp]
    679 0000E2C2 80 40 00 16                 lw      r6,#2048    ; number of words to clear
    680 0000E2C6 09 40 08 F1                 lw      r1,VARBGN
    681 0000E2CA                        cv1
    682 0000E2CA 10 D0                       sw      r0,[r1]
    683 0000E2CC 04 61                       add     r1,r1,#4
    684 0000E2CE FF 66                       sub		r6,r6,#1
    685 0000E2D0 FC B9                       bne     cv1
    686 0000E2D2 E0 FF                       lw      lr,[sp]
    687 0000E2D4 E2 F6                       lw      r6,2[sp]
    688 0000E2D6 04 6E                       add     sp,sp,#4
    689 0000E2D8 F0 80                       ret    
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; LIST
                                        ;
                                        ; LISTX has two forms:
                                        ; 'LIST<CR>' lists all saved lines
                                        ; 'LIST #<CR>' starts listing at the line #
                                        ; Control-S pauses the listing, control-C stops it.
                                        ;
                                        
    702 0000E2DA                        LISTX
    703 0000E2DA 5B 40 04 AF             	call	TSTNUM		; see if there's a line no.
    704 0000E2DE 10 15                   	lw      r5,r1
    705 0000E2E0 3E 40 05 AF             	call	ENDCHK		; if not, we get a zero
    706 0000E2E4 50 11                   	lw      r1,r5
    707 0000E2E6 46 40 06 AF             	call	FNDLN		; find this or next line
    708 0000E2EA                        LS1
    709 0000E2EA 07 B7                   	bgtu	WSTART		; warm start if we passed the end
                                        
    711 0000E2EC 90 11                   	lw		r1,r9
    712 0000E2EE 57 40 0A AF             	call	PRTLN		; print the line
    713 0000E2F2 10 19                   	lw		r9,r1		; set pointer for next
    714 0000E2F4 5F 40 0E AF             	call	CHKIO		; check for listing halt request
    715 0000E2F8 06 A8                   	beq		LS3
    716 0000E2FA FE 4F 1D 10             	cmp		r1,#CTRLS	; pause the listing?
    717 0000E2FE 03 A9                   	bne		LS3
    718 0000E300                        LS2
    719 0000E300 5F 40 08 AF             	call	CHKIO		; if so, wait for another keypress
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 13
noc_boot31.a
    720 0000E304 FD B8                   	beq		LS2
    721 0000E306                        LS3
    722 0000E306 00 11                   	lw		r1,#0
    723 0000E308 45 40 0D AF             	call	FNDLNP		; find the next line
    724 0000E30C EE BE                   	br		LS1
                                        
                                        
                                        ;******************************************************************
                                        ; PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                                        ; where '....' is a list of expressions, formats, back-arrows,
                                        ; and strings.	These items a separated by commas.
                                        ;
                                        ; A format is a pound sign followed by a number.  It controls
                                        ; the number of spaces the value of an expression is going to
                                        ; be printed in.  It stays effective for the rest of the print
                                        ; command unless changed by another format.  If no format is
                                        ; specified, 11 positions will be used.
                                        ;
                                        ; A string is quoted in a pair of single- or double-quotes.
                                        ;
                                        ; An underline (back-arrow) means generate a <CR> without a <LF>
                                        ;
                                        ; A <CR LF> is generated after the entire list has been printed
                                        ; or if the list is empty.  If the list ends with a semicolon,
                                        ; however, no <CR LF> is generated.
                                        ;
                                        
    747 0000E30E                        PRINT
    748 0000E30E 0B 15                   	lw		r5,#11		; D4 = number of print spaces
    749 0000E310 58 40 07 AF             	call	TSTC		; if null list and ":"
    750 0000E314 3A 08                   	db	':',PR2-*+1
    751 0000E316 5F 40 0D AF             	call	CRLF		; give CR-LF and continue
    752 0000E31A BA BE                   	br		RUNSML		;		execution on the same line
    753 0000E31C                        PR2
    754 0000E31C 58 40 01 AF             	call	TSTC		;if null list and <CR>
    755 0000E320 0D 08                   	db	CR,PR0-*+1
    756 0000E322 5F 40 07 AF             	call	CRLF		;also give CR-LF and
    757 0000E326 A9 BE                   	br		RUNNXL		;execute the next line
    758 0000E328                        PR0
    759 0000E328 57 40 0B AF             	call	TSTC		;else is it a format?
    760 0000E32C 23 0A                   	db	'#',PR1-*+1
    761 0000E32E 18 40 0A AF             	call	OREXPR		; yes, evaluate expression
    762 0000E332 10 15                   	lw		r5,r1		; and save it as print width
    763 0000E334 0B AE                   	br		PR3		; look for more to print
    764 0000E336                        PR1
    765 0000E336 57 40 04 AF             	call	TSTC	;	is character expression? (MRL)
    766 0000E33A 24 0C                   	db	'$',PR4-*+1
    767 0000E33C 18 40 03 AF             	call	OREXPR	;	yep. Evaluate expression (MRL)
    768 0000E340 EB 4F 05 AF             	call	GOOUT	;	print low byte (MRL)
    769 0000E344 03 AE                   	br		PR3		;look for more. (MRL)
    770 0000E346                        PR4
    771 0000E346 4B 40 02 AF             	call	QTSTG	;	is it a string?
                                        	; the following branch must occupy only two bytes!
    773 0000E34A 09 AE                   	br		PR8		;	if not, must be an expression
    774 0000E34C                        PR3
    775 0000E34C 56 40 09 AF             	call	TSTC	;	if ",", go find next
    776 0000E350 2C 08                   	db	',',PR6-*+1
    777 0000E352 39 40 0A AF             	call	FIN		;in the list.
    778 0000E356 E8 BE                   	br		PR0
    779 0000E358                        PR6
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 14
noc_boot31.a
    780 0000E358 5D 40 0C AF             	call	CRLF		;list ends here
    781 0000E35C 06 AE                   	br		FINISH
    782 0000E35E                        PR8
    783 0000E35E 17 40 02 AF             	call	OREXPR		; evaluate the expression
    784 0000E362 50 12                   	lw		r2,r5		; set the width
    785 0000E364 4C 40 0F AF             	call	PRTNUM		; print its value
    786 0000E368 F1 BE                   	br		PR3			; more to print?
                                        
    788 0000E36A                        FINISH
    789 0000E36A 38 40 0E AF             	call	FIN		; Check end of command
    790 0000E36E 3B 40 02 AE             	jmp		QWHAT	; print "What?" if wrong
                                        
                                        
                                        ;*******************************************************************
                                        ;
                                        ; *** GOSUB *** & RETURN ***
                                        ;
                                        ; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                                        ; except that the current text pointer, stack pointer, etc. are
                                        ; saved so that execution can be continued after the subroutine
                                        ; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                                        ; recursive), the save area must be stacked.  The stack pointer
                                        ; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                                        ; If we are in the main routine, 'STKGOS' is zero (this was done
                                        ; in the initialization section of the interpreter), but we still
                                        ; save it as a flag for no further 'RETURN's.
                                        ;
    807 0000E372                        GOSUB
    808 0000E372 46 40 06 AF             	call	PUSHA		; save the current 'FOR' parameters
    809 0000E376 16 40 06 AF             	call	OREXPR		; get line number
    810 0000E37A 41 40 0C AF             	call	FNDLN		; find the target line
    811 0000E37E 04 A8                   	beq		gosub1
    812 0000E380 24 4F 0F 11             	lea		r1,msgBadGotoGosub
    813 0000E384 3A 40 09 AE             	br		ERROR		; if not there, say "How?"
    814 0000E388                        gosub1
    815 0000E388 FA 6E                   	sub		sp,sp,#6
    816 0000E38A E0 D8                   	sw		r8,[sp]		; save text pointer
    817 0000E38C 08 40 06 F1             	lw		r1,CURRNT
    818 0000E390 E2 D1                   	sw		r1,2[sp]	; found it, save old 'CURRNT'...
    819 0000E392 08 40 08 F1             	lw		r1,STKGOS
    820 0000E396 E4 D1                   	sw		r1,4[sp]	; and 'STKGOS'
    821 0000E398 08 40 0C D0             	sw		r0,LOPVAR	; load new values
    822 0000E39C 08 40 08 DE             	sw		sp,STKGOS
    823 0000E3A0 74 BE                   	br		RUNTSL
                                        
                                        
                                        ; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                                        ; returns the execution to the command after the most recent
                                        ; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                                        ; a 'GOSUB' and is thus an error.
                                        ;
    831 0000E3A2                        RETURN
    832 0000E3A2 38 40 04 AF             	call	ENDCHK		; there should be just a <CR>
    833 0000E3A6 08 40 08 F1             	lw		r1,STKGOS	; get old stack pointer
    834 0000E3AA 04 A9                   	bne		return1
    835 0000E3AC 26 4F 0C 11             	lea		r1,msgRetWoGosub
    836 0000E3B0 39 40 03 AE             	br		ERROR		; if zero, it doesn't exist
    837 0000E3B4                        return1
    838 0000E3B4 10 1E                   	lw		sp,r1		; else restore it
    839 0000E3B6 E4 F1                   	lw		r1,4[sp]
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 15
noc_boot31.a
    840 0000E3B8 08 40 08 D1             	sw		r1,STKGOS	; and the old 'STKGOS'
    841 0000E3BC E2 F1                   	lw		r1,2[sp]
    842 0000E3BE 08 40 06 D1             	sw		r1,CURRNT	; and the old 'CURRNT'
    843 0000E3C2 E0 F8                   	lw		r8,[sp]		; and the old text pointer
    844 0000E3C4 06 6E                   	add		sp,sp,#6
    845 0000E3C6 42 40 08 AF             	call	POPA		;and the old 'FOR' parameters
    846 0000E3CA CF BE                   	br		FINISH		;and we are back home
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** FOR *** & NEXT ***
                                        ;
                                        ; 'FOR' has two forms:
                                        ; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                                        ; The second form means the same thing as the first form with a
                                        ; STEP of positive 1.  The interpreter will find the variable 'var'
                                        ; and set its value to the current value of 'exp1'.  It also
                                        ; evaluates 'exp2' and 'exp1' and saves all these together with
                                        ; the text pointer, etc. in the 'FOR' save area, which consisits of
                                        ; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                                        ; already something in the save area (indicated by a non-zero
                                        ; 'LOPVAR'), then the old save area is saved on the stack before
                                        ; the new values are stored.  The interpreter will then dig in the
                                        ; stack and find out if this same variable was used in another
                                        ; currently active 'FOR' loop.  If that is the case, then the old
                                        ; 'FOR' loop is deactivated. (i.e. purged from the stack)
                                        ;
    868 0000E3CC                        FOR
    869 0000E3CC 43 40 09 AF             	call	PUSHA		; save the old 'FOR' save area
    870 0000E3D0 34 40 05 AF             	call	SETVAL		; set the control variable
    871 0000E3D4 08 40 0C D1             	sw		r1,LOPVAR	; save its address
    872 0000E3D8 19 4E 03 19             	lea		r9,TAB5		; use 'EXEC' to test for 'TO'
    873 0000E3DC 1E 4E 06 1A             	lea		r10,TAB5_1
    874 0000E3E0 15 BE                   	jmp		EXEC
    875 0000E3E2                        FR1
    876 0000E3E2 13 40 00 AF             	call	OREXPR		; evaluate the limit
    877 0000E3E6 09 40 00 D1             	sw		r1,LOPLMT	; save that
    878 0000E3EA 19 4E 06 19             	lea		r9,TAB6		; use 'EXEC' to look for the
    879 0000E3EE 1E 4E 0A 1A             	lea		r10,TAB6_1	; word 'STEP'
    880 0000E3F2 0C BE                   	jmp		EXEC
    881 0000E3F4                        FR2
    882 0000E3F4 12 40 07 AF             	call	OREXPR		; found it, get the step value
    883 0000E3F8 01 AE                   	br		FR4
    884 0000E3FA                        FR3
    885 0000E3FA 01 11                   	lw		r1,#1		; not found, step defaults to 1
    886 0000E3FC                        FR4
    887 0000E3FC 08 40 0E D1             	sw		r1,LOPINC	; save that too
                                        
    889 0000E400                        FR5
    890 0000E400 08 40 06 F2             	lw		r2,CURRNT
    891 0000E404 09 40 02 D2             	sw		r2,LOPLN	; save address of current line number
    892 0000E408 09 40 04 D8             	sw		r8,LOPPT	; and text pointer
                                        
                                        
    895 0000E40C E0 13                   	lw		r3,sp		; dig into the stack to find 'LOPVAR'
    896 0000E40E 08 40 0C F6             	lw		r6,LOPVAR
    897 0000E412 01 AE                   	br		FR7
    898 0000E414                        FR6
    899 0000E414 3A 13                   	lea		r3,10[r3]	; look at next stack frame
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 16
noc_boot31.a
    900 0000E416                        FR7
    901 0000E416 30 F2                   	lw		r2,[r3]		; is it zero?
    902 0000E418 08 A8                   	beq		FR8			; if so, we're done
    903 0000E41A 6D 22                   	cmp		r2,r6		; same as current LOPVAR?
    904 0000E41C FB B9                   	bne		FR6			; nope, look some more
                                        
    906 0000E41E 30 11                       lw      r1,r3       ; Else remove 5 words from...
    907 0000E420 3A 12                   	lea		r2,10[r3]   ; inside the stack.
    908 0000E422 E0 13                   	lw		r3,sp		
    909 0000E424 3F 40 06 AF             	call	MVDOWN
    910 0000E428 0A 6E                   	add		sp,sp,#10	; set the SP 5 words up
    911 0000E42A                        FR8
    912 0000E42A 9F BE                       br	    FINISH		; and continue execution
                                        
                                        
                                        ; 'NEXT var' serves as the logical (not necessarily physical) end
                                        ; of the 'FOR' loop.  The control variable 'var' is checked with
                                        ; the 'LOPVAR'.  If they are not the same, the interpreter digs in
                                        ; the stack to find the right one and purges all those that didn't
                                        ; match.  Either way, it then adds the 'STEP' to that variable and
                                        ; checks the result with against the limit value.  If it is within
                                        ; the limit, control loops back to the command following the
                                        ; 'FOR'.  If it's outside the limit, the save area is purged and
                                        ; execution continues.
                                        ;
    925 0000E42C                        NEXT
    926 0000E42C 00 11                   	lw		r1,#0		; don't allocate it
    927 0000E42E 1E 40 0E AF             	call	TSTV		; get address of variable
    928 0000E432 04 A9                   	bne		NX4
    929 0000E434 22 4F 0B 11             	lea		r1,msgNextVar
    930 0000E438 34 40 0F AE             	br		ERROR		; if no variable, say "What?"
    931 0000E43C                        NX4
    932 0000E43C 10 19                   	lw		r9,r1		; save variable's address
    933 0000E43E                        NX0
    934 0000E43E 08 40 0C F1             	lw		r1,LOPVAR	; If 'LOPVAR' is zero, we never...
    935 0000E442 04 A9                   	bne		NX5         ; had a FOR loop
    936 0000E444 21 4F 08 11             	lea		r1,msgNextFor
    937 0000E448 34 40 07 AE             	br		ERROR		
    938 0000E44C                        NX5
    939 0000E44C 9D 21                   	cmp		r1,r9		; else we check them
    940 0000E44E 03 A8                   	beq		NX2			; OK, they agree
    941 0000E450 3E 40 03 AF             	call	POPA		; nope, let's see the next frame
    942 0000E454 F4 BE                   	br		NX0
    943 0000E456                        NX2
    944 0000E456 90 F1                   	lw		r1,[r9]		; get control variable's value
    945 0000E458 08 40 0E F2             	lw		r2,LOPINC
    946 0000E45C 20 21                   	add		r1,r2		; add in loop increment
                                        ;	BVS.L	QHOW		say "How?" for 32-bit overflow
    948 0000E45E 90 D1                   	sw		r1,[r9]		; save control variable's new value
    949 0000E460 09 40 00 F3             	lw		r3,LOPLMT	; get loop's limit value
    950 0000E464 26 22                   	or		r2,r2       ; check loop increment
    951 0000E466 03 AB                   	bpl		NX1			; branch if loop increment is positive
    952 0000E468 3D 21                   	cmp		r1,r3		; test against limit
    953 0000E46A 0A A0                   	blt		NXPurge
    954 0000E46C 02 AE                   	br      NX3
    955 0000E46E                        NX1
    956 0000E46E 3D 21                   	cmp		r1,r3
    957 0000E470 07 A3                   	bgt		NXPurge
    958 0000E472                        NX3	
    959 0000E472 09 40 02 F8             	lw		r8,LOPLN	; Within limit, go back to the...
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 17
noc_boot31.a
    960 0000E476 08 40 06 D8             	sw		r8,CURRNT
    961 0000E47A 09 40 04 F8             	lw		r8,LOPPT	; saved 'CURRNT' and text pointer.
    962 0000E47E 75 BE                   	br		FINISH
                                        
    964 0000E480                        NXPurge
    965 0000E480 3C 40 0B AF                 call    POPA        ; purge this loop
    966 0000E484 72 BE                       br      FINISH
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                                        ;
                                        ; 'REM' can be followed by anything and is ignored by the
                                        ; interpreter.
                                        ;
                                        ;REM
                                        ;    br	    IF2		    ; skip the rest of the line
                                        
                                        ; 'IF' is followed by an expression, as a condition and one or
                                        ; more commands (including other 'IF's) separated by colons.
                                        ; Note that the word 'THEN' is not used.  The interpreter evaluates
                                        ; the expression.  If it is non-zero, execution continues.  If it
                                        ; is zero, the commands that follow are ignored and execution
                                        ; continues on the next line.
                                        ;
    986 0000E486                        IF
    987 0000E486 DF AF                       call	OREXPR		; evaluate the expression
    988 0000E488                        IF1
    989 0000E488 16 21                       or      r1,r1       ; is it zero?
    990 0000E48A 02 B9                       bne	    RUNSML		; if not, continue
    991 0000E48C                        IF2
    992 0000E48C 80 19                       lw		r9,r8		; set lookup pointer
    993 0000E48E 00 11                   	lw		r1,#0		; find line #0 (impossible)
    994 0000E490 3A 40 0F AF             	call	FNDSKP		; if so, skip the rest of the line
    995 0000E494 E3 4F 01 A7             	bgtu	WSTART		; if no next line, do a warm start
    996 0000E498                        IF3
    997 0000E498 EF 4F 07 AE             	br		RUNTSL		; run the next line
                                        
                                        
                                        ; INPUT is called first and establishes a stack frame
   1001 0000E49C                        INPERR
   1002 0000E49C 08 40 0A FE             	lw		sp,STKINP	; restore the old stack pointer
   1003 0000E4A0 E4 F8                   	lw		r8,4[sp]
   1004 0000E4A2 08 40 06 D8             	sw		r8,CURRNT	; and old 'CURRNT'
   1005 0000E4A6 E2 F8                   	lw		r8,2[sp]	; and old text pointer
   1006 0000E4A8 0A 6E                   	add		sp,sp,#10	; fall through will subtract 10
                                        
                                        ; 'INPUT' is like the 'PRINT' command, and is followed by a list
                                        ; of items.  If the item is a string in single or double quotes,
                                        ; or is an underline (back arrow), it has the same effect as in
                                        ; 'PRINT'.  If an item is a variable, this variable name is
                                        ; printed out followed by a colon, then the interpreter waits for
                                        ; an expression to be typed in.  The variable is then set to the
                                        ; value of this expression.  If the variable is preceeded by a
                                        ; string (again in single or double quotes), the string will be
                                        ; displayed followed by a colon.  The interpreter the waits for an
                                        ; expression to be entered and sets the variable equal to the
                                        ; expression's value.  If the input expression is invalid, the
                                        ; interpreter will print "What?", "How?", or "Sorry" and reprint
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 18
noc_boot31.a
                                        ; the prompt and redo the input.  The execution will not terminate
                                        ; unless you press control-C.  This is handled in 'INPERR'.
                                        ;
   1023 0000E4AA                        INPUT
   1024 0000E4AA F6 6E                   	sub		sp,sp,#10	; allocate stack frame
   1025 0000E4AC E8 D5                   	sw      r5,8[sp]
   1026 0000E4AE                        IP6
   1027 0000E4AE E0 D8                   	sw		r8,[sp]		; save in case of error
   1028 0000E4B0 3F 40 0D AF             	call	QTSTG		; is next item a string?
   1029 0000E4B4 06 AE                   	br		IP2			; nope - this branch must take only two bytes
   1030 0000E4B6 01 11                   	lw		r1,#1		; allocate var
   1031 0000E4B8 1A 40 09 AF             	call	TSTV		; yes, but is it followed by a variable?
   1032 0000E4BC 29 A8                   	beq     IP4		    ; if not, brnch
   1033 0000E4BE 10 1A                   	lw		r10,r1		; put away the variable's address
   1034 0000E4C0 10 AE                   	br		IP3			; if so, input to variable
   1035 0000E4C2                        IP2
   1036 0000E4C2 E2 D8                   	sw		r8,2[sp]	; save for 'PRTSTG'
   1037 0000E4C4 01 11                   	lw		r1,#1
   1038 0000E4C6 1A 40 02 AF             	call	TSTV		; must be a variable now
   1039 0000E4CA 04 A9                   	bne		IP7
   1040 0000E4CC 1F 4F 0B 11             	lea		r1,msgInputVar
   1041 0000E4D0 30 40 03 AE             	br		ERROR		; "What?" it isn't?
   1042 0000E4D4                        IP7
   1043 0000E4D4 10 1A                   	lw		r10,r1		; put away the variable's address
   1044 0000E4D6 80 E5                   	lb		r5,[r8]		; get ready for 'PRTSTG' by null terminating
   1045 0000E4D8 80 C0                   	sb		r0,[r8]
   1046 0000E4DA E2 F1                   	lw		r1,2[sp]	; get back text pointer
   1047 0000E4DC 3C 40 0B AF             	call	PRTSTG		; print string as prompt
   1048 0000E4E0 80 C5                   	sb		r5,[r8]		; un-null terminate
   1049 0000E4E2                        IP3
   1050 0000E4E2 E2 D8                   	sw		r8,2[sp]	; save in case of error
   1051 0000E4E4 08 40 06 F1             	lw		r1,CURRNT
   1052 0000E4E8 E4 D1                   	sw		r1,4[sp]	; also save 'CURRNT'
   1053 0000E4EA 0F 11                   	lw		r1,#-1
   1054 0000E4EC 08 40 06 D1             	sw		r1,CURRNT	; flag that we are in INPUT
   1055 0000E4F0 08 40 0A DE             	sw		sp,STKINP	; save the stack pointer too
   1056 0000E4F4 E6 DA                   	sw		r10,6[sp]	; save the variable address
   1057 0000E4F6 03 40 0A 11             	lw		r1,#':'		; print a colon first
   1058 0000E4FA 30 40 08 AF             	call	GETLN		; then get an input line
   1059 0000E4FE 0A 40 0E 18             	lea		r8,BUFFER	; point to the buffer
   1060 0000E502 A1 AF                   	call	OREXPR		; evaluate the input
   1061 0000E504 E6 FA                   	lw		r10,6[sp]	; restore the variable address
   1062 0000E506 A0 D1                   	sw		r1,[r10]	; save value in variable
   1063 0000E508 E4 F1                   	lw		r1,4[sp]	; restore old 'CURRNT'
   1064 0000E50A 08 40 06 D1             	sw		r1,CURRNT
   1065 0000E50E E2 F8                   	lw		r8,2[sp]	; and the old text pointer
   1066 0000E510                        IP4
   1067 0000E510 48 40 07 AF             	call	TSTC		; is the next thing a comma?
   1068 0000E514 2C 04                   	db	',',IP5-*+1
   1069 0000E516 CB BE                   	br		IP6			; yes, more items
   1070 0000E518                        IP5
   1071 0000E518 E8 F5                       lw      r5,8[sp]
   1072 0000E51A 0A 6E                   	add		sp,sp,#10	; clean up the stack
   1073 0000E51C 26 BE                   	jmp		FINISH
                                        
                                        
   1076 0000E51E                        DEFLT
   1077 0000E51E 80 E1                       lb      r1,[r8]
   1078 0000E520 FF 4F 13 10                 cmp     r1,#CR      ; empty line is OK
   1079 0000E524 22 B8                   	beq	    FINISH	    ; else it is 'LET'
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 19
noc_boot31.a
                                        
                                        
                                        ; 'LET' is followed by a list of items separated by commas.
                                        ; Each item consists of a variable, an equals sign, and an
                                        ; expression.  The interpreter evaluates the expression and sets
                                        ; the variable to that value.  The interpreter will also handle
                                        ; 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                                        ;
   1088 0000E526                        LET
   1089 0000E526 29 40 0A AF                 call	SETVAL		; do the assignment
   1090 0000E52A 47 40 0A AF             	call	TSTC		; check for more 'LET' items
   1091 0000E52E 2C 04                   	db	',',LT1-*+1
   1092 0000E530 FA BE                   	br	    LET
   1093 0000E532                        LT1
   1094 0000E532 1B BE                       br	    FINISH		; until we are finished.
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** LOAD *** & SAVE ***
                                        ;
                                        ; These two commands transfer a program to/from an auxiliary
                                        ; device such as a cassette, another computer, etc.  The program
                                        ; is converted to an easily-stored format: each line starts with
                                        ; a colon, the line no. as 4 hex digits, and the rest of the line.
                                        ; At the end, a line starting with an '@' sign is sent.  This
                                        ; format can be read back with a minimum of processing time by
                                        ; the Butterfly.
                                        ;
   1109 0000E534                        LOAD
   1110 0000E534 0C 4E 02 F8             	lw		r8,TXTBGN	; set pointer to start of prog. area
   1111 0000E538 00 40 0D 11             	lw		r1,#CR		; For a CP/M host, tell it we're ready...
   1112 0000E53C DB 4F 0B AF             	call	GOAUXO		; by sending a CR to finish PIP command.
   1113 0000E540                        LOD1
   1114 0000E540 DB 4F 0B AF             	call	GOAUXI		; look for start of line
   1115 0000E544 FD BA                   	bmi		LOD1
   1116 0000E546 FC 4F 10 10             	cmp		r1,#'@'		; end of program?
   1117 0000E54A 1B A8                   	beq		LODEND
   1118 0000E54C FE 4F 16 10             	cmp     r1,#0x1A    ; or EOF marker
   1119 0000E550 18 A8                   	beq     LODEND
   1120 0000E552 FC 4F 16 10             	cmp		r1,#':'		; if not, is it start of line?
   1121 0000E556 F4 B9                   	bne		LOD1		; if not, wait for it
   1122 0000E558 18 AF                   	call	GCHAR		; get line number
   1123 0000E55A 80 C1                   	sb		r1,[r8]		; store it
   1124 0000E55C A1 31                   	shr		r1,#1
   1125 0000E55E A1 31                   	shr		r1,#1
   1126 0000E560 A1 31                   	shr		r1,#1
   1127 0000E562 A1 31                   	shr		r1,#1
   1128 0000E564 A1 31                   	shr		r1,#1
   1129 0000E566 A1 31                   	shr		r1,#1
   1130 0000E568 A1 31                   	shr		r1,#1
   1131 0000E56A A1 31                   	shr		r1,#1
   1132 0000E56C 81 C1                   	sb		r1,1[r8]
   1133 0000E56E 02 68                   	add		r8,r8,#2
   1134 0000E570                        LOD2
   1135 0000E570 DA 4F 03 AF             	call	GOAUXI		; get another text char.
   1136 0000E574 FD BA                   	bmi		LOD2
   1137 0000E576 80 C1                   	sb		r1,[r8]
   1138 0000E578 01 68                   	add		r8,r8,#1	; store it
   1139 0000E57A FF 4F 13 10             	cmp		r1,#CR		; is it the end of the line?
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 20
noc_boot31.a
   1140 0000E57E F8 B9                   	bne		LOD2		; if not, go back for more
   1141 0000E580 DF BE                   	br		LOD1		; if so, start a new line
   1142 0000E582                        LODEND
   1143 0000E582 09 40 06 D8             	sw		r8,TXTUNF	; set end-of program pointer
   1144 0000E586 DB 4F 08 AE             	br		WSTART		; back to direct mode
                                        
                                        ; get character from input (16 bit value)
   1147 0000E58A                        GCHAR
   1148 0000E58A FA 6E                   	sub		sp,sp,#6
   1149 0000E58C E0 DF                   	sw		lr,[sp]
   1150 0000E58E E2 D5                   	sw		r5,2[sp]
   1151 0000E590 E4 D6                   	sw		r6,4[sp]
   1152 0000E592 04 16                   	lw      r6,#4       ; repeat four times
   1153 0000E594 00 15                   	lw		r5,#0
   1154 0000E596                        GCHAR1
   1155 0000E596 D9 4F 00 AF             	call	GOAUXI		; get a char
   1156 0000E59A FD BA                   	bmi		GCHAR1
   1157 0000E59C 0D AF                   	call	asciiToHex
   1158 0000E59E 81 35                   	shl		r5,#1
   1159 0000E5A0 81 35                   	shl		r5,#1
   1160 0000E5A2 81 35                   	shl		r5,#1
   1161 0000E5A4 81 35                   	shl		r5,#1
   1162 0000E5A6 16 25                   	or		r5,r1
   1163 0000E5A8 FF 66                   	sub		r6,r6,#1
   1164 0000E5AA F5 B9                   	bne     GCHAR1
   1165 0000E5AC 50 11                   	lw		r1,r5
   1166 0000E5AE E0 FF                   	lw		lr,[sp]
   1167 0000E5B0 E2 F5                   	lw		r5,2[sp]
   1168 0000E5B2 E4 F6                   	lw		r6,4[sp]
   1169 0000E5B4 06 6E                   	add     sp,sp,#6
   1170 0000E5B6 F0 80                   	ret
                                        
                                        ; convert an ascii char to hex code
                                        ; input
                                        ;	r2 = char to convert
                                        
   1176 0000E5B8                        asciiToHex
   1177 0000E5B8 FC 4F 17 10             	cmp		r1,#'9'
   1178 0000E5BC 01 A2                   	ble		a2h1		; less than '9'
   1179 0000E5BE F9 61                   	sub		r1,r1,#7	; shift 'A' to '9'+1
   1180 0000E5C0                        a2h1
   1181 0000E5C0 D0 61                   	sub		r1,r1,#'0'	;
   1182 0000E5C2 00 40 5F 31             	and		r1,#15		; make sure a nybble
   1183 0000E5C6 F0 80                   	ret
                                        
                                        ; output a CR LF sequence to auxillary output
                                        ; Registers Affected
                                        ;   r3 = LF
   1188 0000E5C8                        AUXOCRLF
   1189 0000E5C8 FE 6E                       sub     sp,sp,#2
   1190 0000E5CA E0 DF                       sw      lr,[sp]
   1191 0000E5CC 00 40 0D 11                 lw      r1,#CR
   1192 0000E5D0 D7 4F 01 AF                 call    GOAUXO
   1193 0000E5D4 0A 11                       lw      r1,#LF
   1194 0000E5D6 D6 4F 0E AF                 call    GOAUXO
   1195 0000E5DA E0 FF                       lw      lr,[sp]
   1196 0000E5DC 02 6E                   	add		sp,sp,#2
   1197 0000E5DE F0 80                       ret
                                        
                                        
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 21
noc_boot31.a
                                        ; convert nybble in r2 to ascii hex char2
                                        ; r2 = character to convert
                                        
   1203 0000E5E0                        toAsciiHex
   1204 0000E5E0 00 40 5F 31             	and		r1,#15		; make sure it's a nybble
   1205 0000E5E4 FF 4F 16 10             	cmp		r1,#10		; > 10 ?
   1206 0000E5E8 01 A0                   	blt		tah1
   1207 0000E5EA 07 61                   	add		r1,r1,#7	; bump it up to the letter 'A'
   1208 0000E5EC                        tah1
   1209 0000E5EC 30 61                   	add		r1,r1,#'0'	; bump up to ascii '0'
   1210 0000E5EE F0 80                   	ret
                                        
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** POKE *** & SYSX ***
                                        ;
                                        ; 'POKE expr1,expr2' stores the byte from 'expr2' into the memory
                                        ; address specified by 'expr1'.
                                        ;
                                        ; 'SYSX expr' jumps to the machine language subroutine whose
                                        ; starting address is specified by 'expr'.  The subroutine can use
                                        ; all registers but must leave the stack the way it found it.
                                        ; The subroutine returns to the interpreter by executing an RET.
                                        ;
   1226 0000E5F0                        POKE
   1227 0000E5F0 FE 6E                   	sub		sp,sp,#2
   1228 0000E5F2 29 AF                   	call	OREXPR		; get the memory address
   1229 0000E5F4 41 40 05 AF             	call	TSTC		; it must be followed by a comma
   1230 0000E5F8 2C 10                   	db	',',PKER-*+1
   1231 0000E5FA E0 D1                   	sw		r1,[sp]	    ; save the address
   1232 0000E5FC 24 AF                   	call	OREXPR		; get the byte to be POKE'd
   1233 0000E5FE E0 F2                   	lw		r2,[sp]	    ; get the address back
   1234 0000E600 20 C1                   	sb		r1,[r2]		; store the byte in memory
   1235 0000E602 02 6E                   	add		sp,sp,#2
   1236 0000E604 EB 4F 01 AE             	br		FINISH
   1237 0000E608                        PKER
   1238 0000E608 19 4F 04 11             	lea		r1,msgComma
   1239 0000E60C 26 40 05 AE             	br		ERROR		; if no comma, say "What?"
                                        
                                        
   1242 0000E610                        POKEW
   1243 0000E610 FE 6E                   	sub		sp,sp,#2
   1244 0000E612 19 AF                   	call	OREXPR		; get the memory address
   1245 0000E614 40 40 05 AF             	call	TSTC		; it must be followed by a comma
   1246 0000E618 2C F0                   	db	',',PKER-*+1
   1247 0000E61A E0 D1                   	sw		r1,[sp]	    ; save the address
   1248 0000E61C 14 AF                   	call	OREXPR		; get the byte to be POKE'd
   1249 0000E61E E0 F2                   	lw		r2,[sp]	    ; get the address back
   1250 0000E620 20 D1                   	sw		r1,[r2]		; store the word in memory
   1251 0000E622 02 6E                   	add		sp,sp,#2
   1252 0000E624 EA 4F 01 AE             	jmp		FINISH
                                        
                                        
   1255 0000E628                        SYSX
   1256 0000E628 FE 6E                   	sub		sp,sp,#2
   1257 0000E62A 0D AF                   	call	OREXPR		; get the subroutine's address
   1258 0000E62C 16 20                   	or		r0,r1		; make sure we got a valid address
   1259 0000E62E 04 A9                   	bne		sysx1
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 22
noc_boot31.a
   1260 0000E630 1E 4F 09 11             	lea		r1,msgSYSBad
   1261 0000E634 25 40 01 AE             	br		ERROR
   1262 0000E638                        sysx1
   1263 0000E638 E0 D8                   	sw		r8,[sp]	    ; save the text pointer
   1264 0000E63A CE 48 01 AF             	call	[r1]		; jump to the subroutine
   1265 0000E63E E0 F8                   	lw		r8,[sp]	    ; restore the text pointer
   1266 0000E640 02 6E                   	add		sp,sp,#2
   1267 0000E642 E9 4F 02 AE             	br		FINISH
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** EXPR ***
                                        ;
                                        ; 'EXPR' evaluates arithmetical or logical expressions.
                                        ; <OREXPR>::= <ANDEXPR> OR <ANDEXPR> ...
                                        ; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                                        ; <EXPR>::=<EXPR2>
                                        ;	   <EXPR2><rel.op.><EXPR2>
                                        ; where <rel.op.> is one of the operators in TAB8 and the result
                                        ; of these operations is 1 if true and 0 if false.
                                        ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                                        ; where () are optional and (... are optional repeats.
                                        ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                                        ; <EXPR4>::=<variable>
                                        ;	    <function>
                                        ;	    (<EXPR>)
                                        ; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                                        ; as an index, functions can have an <EXPR> as arguments, and
                                        ; <EXPR4> can be an <EXPR> in parenthesis.
                                        ;
                                        
                                        
                                        ; <OREXPR>::=<ANDEXPR> OR <ANDEXPR> ...
                                        ;
   1295 0000E646                        OREXPR
   1296 0000E646 FC 6E                   	sub		sp,sp,#4
   1297 0000E648 E0 DF                   	sw		lr,[sp]
   1298 0000E64A 0F AF                   	call	ANDEXPR		; get first <ANDEXPR>
   1299 0000E64C                        XP_OR1
   1300 0000E64C E2 D1                   	sw		r1,2[sp]	; save <ANDEXPR> value
   1301 0000E64E 1A 4E 09 19             	lea		r9,TAB10		; look up a logical operator
   1302 0000E652 20 4E 00 1A             	lea		r10,TAB10_1
   1303 0000E656 DD 4F 09 AE             	jmp		EXEC		; go do it
                                        
   1305 0000E65A                        XP_OR
   1306 0000E65A 07 AF                       call    ANDEXPR
   1307 0000E65C E2 F2                       lw      r2,2[sp]
   1308 0000E65E 26 21                       or      r1,r2
   1309 0000E660 F5 BE                       br      XP_OR1
                                        
   1311 0000E662                        XP_ORX
   1312 0000E662 E2 F1                   	lw		r1,2[sp]
   1313 0000E664 E0 FF                       lw      lr,[sp]
   1314 0000E666 04 6E                       add     sp,sp,#4
   1315 0000E668 F0 80                       ret
                                        
                                        
                                        ; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                                        ;
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 23
noc_boot31.a
   1320 0000E66A                        ANDEXPR
   1321 0000E66A FC 6E                   	sub		sp,sp,#4
   1322 0000E66C E0 DF                   	sw		lr,[sp]
   1323 0000E66E 37 AF                   	call	EXPR		; get first <EXPR>
   1324 0000E670                        XP_AND1
   1325 0000E670 E2 D1                   	sw		r1,2[sp]	; save <EXPR> value
   1326 0000E672 1A 4E 05 19             	lea		r9,TAB9		; look up a logical operator
   1327 0000E676 1F 4E 0C 1A             	lea		r10,TAB9_1
   1328 0000E67A DC 4F 07 AE             	jmp		EXEC		; go do it
                                        
   1330 0000E67E                        XP_AND
   1331 0000E67E 2F AF                       call    EXPR
   1332 0000E680 E2 F2                       lw      r2,2[sp]
   1333 0000E682 25 21                       and     r1,r2
   1334 0000E684 F5 BE                       br      XP_AND1
                                        
   1336 0000E686                        XP_ANDX
   1337 0000E686 E2 F1                   	lw		r1,2[sp]
   1338 0000E688 E0 FF                       lw      lr,[sp]
   1339 0000E68A 04 6E                       add     sp,sp,#4
   1340 0000E68C F0 80                       ret
                                        
                                        
                                        ; Determine if the character is a digit
                                        ;   Parameters
                                        ;       r2 = char to test
                                        ;   Returns
                                        ;       r1 = 1 if digit, otherwise 0
                                        ;
   1349 0000E68E                        isDigit
   1350 0000E68E FD 4F 10 10                 cmp     r1,#'0'
   1351 0000E692 05 A0                       blt     isDigitFalse
   1352 0000E694 FC 4F 17 10                 cmp     r1,#'9'
   1353 0000E698 02 A3                       bgt     isDigitFalse
   1354 0000E69A 01 11                       lw      r1,#1
   1355 0000E69C F0 80                       ret
   1356 0000E69E                        isDigitFalse
   1357 0000E69E 00 11                       lw      r1,#0
   1358 0000E6A0 F0 80                       ret
                                        
                                        
                                        ; Determine if the character is a alphabetic
                                        ;   Parameters
                                        ;       r2 = char to test
                                        ;   Returns
                                        ;       r1 = 1 if alpha, otherwise 0
                                        ;
   1367 0000E6A2                        isAlpha
   1368 0000E6A2 FB 4F 1F 10                 cmp     r1,#'A'
   1369 0000E6A6 0B A0                       blt     isAlphaFalse
   1370 0000E6A8 FA 4F 16 10                 cmp     r1,#'Z'
   1371 0000E6AC 06 A2                       ble     isAlphaTrue
   1372 0000E6AE F9 4F 1F 10                 cmp     r1,#'a'
   1373 0000E6B2 05 A0                       blt     isAlphaFalse
   1374 0000E6B4 F8 4F 16 10                 cmp     r1,#'z'
   1375 0000E6B8 02 A3                       bgt     isAlphaFalse
   1376 0000E6BA                        isAlphaTrue
   1377 0000E6BA 01 11                       lw      r1,#1
   1378 0000E6BC F0 80                       ret
   1379 0000E6BE                        isAlphaFalse
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 24
noc_boot31.a
   1380 0000E6BE 00 11                       lw      r1,#0
   1381 0000E6C0 F0 80                       ret
                                        
                                        
                                        ; Determine if the character is a alphanumeric
                                        ;   Parameters
                                        ;       r1 = char to test
                                        ;   Returns
                                        ;       r1 = 1 if alpha, otherwise 0
                                        ;
   1390 0000E6C2                        isAlnum
   1391 0000E6C2 FE 6E                       sub     sp,sp,#2
   1392 0000E6C4 E0 DF                       sw      lr,[sp]
   1393 0000E6C6 10 12                       lw      r2,r1		; save test char
   1394 0000E6C8 E2 BF                       call    isDigit
   1395 0000E6CA 06 A9                       bne		isDigitx	; if it is a digit
   1396 0000E6CC 20 11                       lw      r1,r2		; get back test char
   1397 0000E6CE E9 BF                       call    isAlpha
   1398 0000E6D0 E0 FF                       lw      lr,[sp]
   1399 0000E6D2 02 6E                       add		sp,sp,#2
   1400 0000E6D4 16 21                       or      r1,r1
   1401 0000E6D6 F0 80                       ret
   1402 0000E6D8                        isDigitx
   1403 0000E6D8 E0 FF                       lw      lr,[sp]
   1404 0000E6DA 02 6E                       add     sp,sp,#2	; return Z=0
   1405 0000E6DC F0 80                       ret
                                        
                                        
   1408 0000E6DE                        EXPR
   1409 0000E6DE FC 6E                   	sub		sp,sp,#4
   1410 0000E6E0 E0 DF                   	sw		lr,[sp]
   1411 0000E6E2 39 AF                   	call	EXPR2
   1412 0000E6E4 E2 D1                   	sw		r1,2[sp]	; save <EXPR2> value
   1413 0000E6E6 19 4E 0B 19             	lea		r9,TAB8		; look up a relational operator
   1414 0000E6EA 1E 4E 0E 1A             	lea		r10,TAB8_1
   1415 0000E6EE D8 4F 0D AE             	jmp		EXEC		; go do it
                                        
   1417 0000E6F2                        XP11
   1418 0000E6F2 E2 F1                   	lw		r1,2[sp]
   1419 0000E6F4 28 AF                   	call	XP18	; is it ">="?
   1420 0000E6F6 1D 22                   	cmp		r2,r1
   1421 0000E6F8 1E A1                   	bge		XPRT1	; no, return r2=1
   1422 0000E6FA 19 AE                   	br		XPRT0	; else return r2=0
                                        
   1424 0000E6FC                        XP12
   1425 0000E6FC E2 F1                   	lw		r1,2[sp]
   1426 0000E6FE 23 AF                   	call	XP18	; is it "<>"?
   1427 0000E700 1D 22                   	cmp		r2,r1
   1428 0000E702 19 A9                   	bne		XPRT1	; no, return r2=1
   1429 0000E704 14 AE                   	br		XPRT0	; else return r2=0
                                        
   1431 0000E706                        XP13
   1432 0000E706 E2 F1                   	lw		r1,2[sp]
   1433 0000E708 1E AF                   	call	XP18	; is it ">"?
   1434 0000E70A 1D 22                   	cmp		r2,r1
   1435 0000E70C 14 A3                   	bgt		XPRT1	; no, return r2=1
   1436 0000E70E 0F AE                   	br		XPRT0	; else return r2=0
                                        
   1438 0000E710                        XP14
   1439 0000E710 E2 F1                   	lw		r1,2[sp]
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 25
noc_boot31.a
   1440 0000E712 19 AF                   	call	XP18	; is it "<="?
   1441 0000E714 1D 22                   	cmp		r2,r1
   1442 0000E716 0F A2                   	ble		XPRT1	; no, return r2=1
   1443 0000E718 0A AE                   	br		XPRT0	; else return r2=0
                                        
   1445 0000E71A                        XP15
   1446 0000E71A E2 F1                   	lw		r1,2[sp]
   1447 0000E71C 14 AF                   	call	XP18	; is it "="?
   1448 0000E71E 1D 22                   	cmp		r2,r1
   1449 0000E720 0A A8                   	beq		XPRT1	; if not, return r2=1
   1450 0000E722 05 AE                   	br		XPRT0	; else return r2=0
                                        
                                        
   1453 0000E724                        XP16
   1454 0000E724 E2 F1                   	lw		r1,2[sp]
   1455 0000E726 0F AF                   	call	XP18	; is it "<"?
   1456 0000E728 1D 22                   	cmp		r2,r1
   1457 0000E72A 05 A0                   	blt		XPRT1	; if not, return r2=1
   1458 0000E72C 00 AE                   	br		XPRT0	; else return r2=0
                                        
   1460 0000E72E                        XPRT0
   1461 0000E72E E0 FF                   	lw		lr,[sp]
   1462 0000E730 04 6E                   	add		sp,sp,#4
   1463 0000E732 00 11                   	lw		r1,#0   ; return r1=0 (false)
   1464 0000E734 F0 80                   	ret
                                        
   1466 0000E736                        XPRT1
   1467 0000E736 E0 FF                   	lw		lr,[sp]
   1468 0000E738 04 6E                   	add		sp,sp,#4
   1469 0000E73A 01 11                   	lw		r1,#1	; return r1=1 (true)
   1470 0000E73C F0 80                   	ret
                                        
   1472 0000E73E                        XP17				; it's not a rel. operator
   1473 0000E73E E2 F1                   	lw		r1,2[sp]	; return r2=<EXPR2>
   1474 0000E740 E0 FF                   	lw		lr,[sp]
   1475 0000E742 04 6E                   	add		sp,sp,#4
   1476 0000E744 F0 80                   	ret
                                        
   1478 0000E746                        XP18
   1479 0000E746 FC 6E                   	sub		sp,sp,#4
   1480 0000E748 E0 DF                   	sw		lr,[sp]
   1481 0000E74A E2 D1                   	sw		r1,2[sp]
   1482 0000E74C 04 AF                   	call	EXPR2		; do a second <EXPR2>
   1483 0000E74E E2 F2                   	lw		r2,2[sp]
   1484 0000E750 E0 FF                   	lw		lr,[sp]
   1485 0000E752 04 6E                   	add		sp,sp,#4
   1486 0000E754 F0 80                   	ret
                                        
                                        ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                                        
   1490 0000E756                        EXPR2
   1491 0000E756 FC 6E                   	sub		sp,sp,#4
   1492 0000E758 E0 DF                   	sw		lr,[sp]
   1493 0000E75A 36 40 02 AF             	call	TSTC		; negative sign?
   1494 0000E75E 2D 08                   	db	'-',XP21-*+1
   1495 0000E760 00 11                   	lw		r1,#0		; yes, fake '0-'
   1496 0000E762 E2 D1                   	sw		r1,2[sp]
   1497 0000E764 0F AE                   	br		XP26
   1498 0000E766                        XP21
   1499 0000E766 35 40 0C AF             	call	TSTC		; positive sign? ignore it
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 26
noc_boot31.a
   1500 0000E76A 2B 02                   	db	'+',XP22-*+1
   1501 0000E76C                        XP22
   1502 0000E76C 12 AF                   	call	EXPR3		; first <EXPR3>
   1503 0000E76E                        XP23
   1504 0000E76E E2 D1                   	sw		r1,2[sp]	; yes, save the value
   1505 0000E770 35 40 07 AF             	call	TSTC		; add?
   1506 0000E774 2B 0A                   	db	'+',XP25-*+1
   1507 0000E776 0D AF                   	call	EXPR3		; get the second <EXPR3>
   1508 0000E778                        XP24
   1509 0000E778 E2 F2                   	lw		r2,2[sp]
   1510 0000E77A 20 21                   	add		r1,r2		; add it to the first <EXPR3>
                                        ;	BVS.L	QHOW		brnch if there's an overflow
   1512 0000E77C F8 BE                   	br		XP23		; else go back for more operations
   1513 0000E77E                        XP25
   1514 0000E77E 35 40 00 AF             	call	TSTC		; subtract?
   1515 0000E782 2D 08                   	db	'-',XP45-*+1
   1516 0000E784                        XP26
   1517 0000E784 06 AF                   	call	EXPR3		; get second <EXPR3>
   1518 0000E786 20 31                   	neg		r1			; change its sign
   1519 0000E788 F7 BE                   	br		XP24		; and do an addition
                                        
   1521 0000E78A                        XP45
   1522 0000E78A E2 F1                   	lw		r1,2[sp]
   1523 0000E78C E0 FF                   	lw		lr,[sp]
   1524 0000E78E 04 6E                   	add		sp,sp,#4
   1525 0000E790 F0 80                   	ret
                                        
                                        
                                        ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                                        
   1530 0000E792                        EXPR3
   1531 0000E792 FC 6E                   	sub		sp,sp,#4
   1532 0000E794 E0 DF                   	sw		lr,[sp]
   1533 0000E796 14 AF                   	call	EXPR4		; get first <EXPR4>
   1534 0000E798                        XP31
   1535 0000E798 E2 D1                   	sw		r1,2[sp]	; yes, save that first result
   1536 0000E79A 34 40 02 AF             	call	TSTC		; multiply?
   1537 0000E79E 2A 0A                   	db	'*',XP34-*+1
   1538 0000E7A0 0F AF                   	call	EXPR4		; get second <EXPR4>
   1539 0000E7A2 E2 F2                   	lw		r2,2[sp]
   1540 0000E7A4 B8 AF                   	call	MULT32		; multiply the two
   1541 0000E7A6 F8 BE                   	br		XP31		 ; then look for more terms
   1542 0000E7A8                        XP34
   1543 0000E7A8 33 40 0B AF             	call	TSTC		; divide?
   1544 0000E7AC 2F 0C                   	db	'/',XP47-*+1
   1545 0000E7AE 08 AF                   	call	EXPR4		; get second <EXPR4>
   1546 0000E7B0 10 12                   	lw      r2,r1
   1547 0000E7B2 E2 F1                   	lw		r1,2[sp]
   1548 0000E7B4 CD AF                   	call	DIV32		; do the division
   1549 0000E7B6 F0 BE                   	br		XP31		; go back for any more terms
                                        
   1551 0000E7B8                        XP47
   1552 0000E7B8 E2 F1                   	lw		r1,2[sp]
   1553 0000E7BA E0 FF                   	lw		lr,[sp]
   1554 0000E7BC 04 6E                   	add		sp,sp,#4
   1555 0000E7BE F0 80                   	ret
                                        
                                        
                                        ; Functions are called through EXPR4
                                        ; <EXPR4>::=<variable>
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 27
noc_boot31.a
                                        ;	    <function>
                                        ;	    (<EXPR>)
                                        
   1563 0000E7C0                        EXPR4
   1564 0000E7C0 FA 6E                       sub     sp,sp,#6
   1565 0000E7C2 E0 DF                       sw      lr,[sp]
   1566 0000E7C4 17 4E 05 19             	lea		r9,TAB4		; find possible function
   1567 0000E7C8 1D 4E 06 1A             	lea		r10,TAB4_1
   1568 0000E7CC D1 4F 0E AE             	jmp		EXEC        ; branch to function which does subsequent
                                        	                    ; ret for EXPR4
                                        
   1571 0000E7D0                        XP40                    ; we get here if it wasn't a function
   1572 0000E7D0 00 11                   	lw		r1,#0
   1573 0000E7D2 1D AF                   	call	TSTV		
   1574 0000E7D4 04 A8                   	beq     XP41        ; nor a variable
   1575 0000E7D6 10 F1                   	lw		r1,[r1]		; if a variable, return its value in r1
   1576 0000E7D8 E0 FF                   	lw      lr,[sp]
   1577 0000E7DA 06 6E                   	add     sp,sp,#6
   1578 0000E7DC F0 80                   	ret
   1579 0000E7DE                        XP41
   1580 0000E7DE 33 40 02 AF             	call	TSTNUM		; or is it a number?
   1581 0000E7E2 26 22                   	or		r2,r2		; (if not, # of digits will be zero)
   1582 0000E7E4 01 A9                   	bne		XP46		; if so, return it in r1
   1583 0000E7E6 03 AF                   	call    PARN        ; check for (EXPR)
   1584 0000E7E8                        XP46
   1585 0000E7E8 E0 FF                   	lw      lr,[sp]
   1586 0000E7EA 06 6E                   	add     sp,sp,#6
   1587 0000E7EC F0 80                   	ret
                                        
                                        
                                        ; Check for a parenthesized expression
   1591 0000E7EE                        PARN
   1592 0000E7EE FE 6E                   	sub		sp,sp,#2
   1593 0000E7F0 E0 DF                   	sw		lr,[sp]
   1594 0000E7F2 31 40 06 AF             	call	TSTC		; else look for ( OREXPR )
   1595 0000E7F6 28 10                   	db	'(',XP43-*+1
   1596 0000E7F8 26 BF                   	call	OREXPR
   1597 0000E7FA 31 40 02 AF             	call	TSTC
   1598 0000E7FE 29 08                   	db	')',XP43-*+1
   1599 0000E800                        XP42
   1600 0000E800 E0 FF                   	lw		lr,[sp]
   1601 0000E802 02 6E                   	add		sp,sp,#2
   1602 0000E804 F0 80                   	ret
   1603 0000E806                        XP43
   1604 0000E806 11 4F 01 11             	lea		r1,msgWhat
   1605 0000E80A 16 40 06 AE             	br		ERROR
                                        
                                        
                                        ; ===== Test for a valid variable name.  Returns Z=1 if not
                                        ;	found, else returns Z=0 and the address of the
                                        ;	variable in r1.
                                        ; Parameters
                                        ;	r1 = 1 = allocate if not found
                                        ; Returns
                                        ;	r1 = address of variable, zero if not found
                                        
   1616 0000E80E                        TSTV
   1617 0000E80E FA 6E                   	sub		sp,sp,#6
   1618 0000E810 E0 DF                   	sw		lr,[sp]
   1619 0000E812 E2 D5                   	sw		r5,2[sp]
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 28
noc_boot31.a
   1620 0000E814 10 15                   	lw		r5,r1		; allocate flag
   1621 0000E816 33 40 07 AF             	call	IGNBLK
   1622 0000E81A 80 E1                   	lb		r1,[r8]		; look at the program text
   1623 0000E81C FC 4F 10 10             	cmp     r1,#'@'
   1624 0000E820 1C A0                   	blt     tstv_notfound   ; C=1: not a variable
   1625 0000E822 12 A9                   	bne		TV1			; brnch if not "@" array
   1626 0000E824 01 68                   	add		r8,r8,#1	; If it is, it should be
   1627 0000E826 E3 BF                   	call	PARN		; followed by (EXPR) as its index.
   1628 0000E828 81 31                   	shl     r1,#1
   1629 0000E82A 81 31                   	shl     r1,#1
                                        ;	BCS.L	QHOW		say "How?" if index is too big
   1631 0000E82C E4 D1                       sw      r1,4[sp]    ; save the index
   1632 0000E82E F4 6E                       sub		sp,sp,#12
   1633 0000E830 E0 DF                       sw		lr,[sp]
   1634 0000E832 10 40 08 AF             	call	SIZEX		; get amount of free memory
   1635 0000E836 E4 F2                   	lw      r2,4[sp]    ; get back the index
   1636 0000E838 1D 22                   	cmp     r2,r1       ; see if there's enough memory
   1637 0000E83A 02 A4                   	bltu	TV2
   1638 0000E83C 14 40 08 AE             	jmp    	QSORRY		; if not, say "Sorry"
   1639 0000E840                        TV2
   1640 0000E840 09 40 08 F1             	lw      r1,VARBGN   ; put address of array element...
   1641 0000E844 22 21                   	sub     r1,r2       ; into r1 (neg. offset is used)
   1642 0000E846 05 AE                   	br      TSTVRT
   1643 0000E848                        TV1	
   1644 0000E848 0D AF                       call    getVarName      ; get variable name
   1645 0000E84A 07 A8                       beq     tstv_notfound   ; if not, set Z=1 and return
   1646 0000E84C 50 12                       lw		r2,r5
   1647 0000E84E 45 AF                       call    findVar     ; find or allocate
   1648 0000E850 04 A8                       beq		tstv_notfound
   1649 0000E852                        TSTVRT
   1650 0000E852 E2 F5                   	lw		r5,2[sp]
   1651 0000E854 E0 FF                   	lw		lr,[sp]
   1652 0000E856 06 6E                   	add		sp,sp,#6    ; Z=0 (found)
   1653 0000E858 F0 80                   	ret
   1654 0000E85A                        tstv_notfound
   1655 0000E85A E2 F5                   	lw		r5,2[sp]
   1656 0000E85C E0 FF                       lw      lr,[sp]
   1657 0000E85E 06 6E                       add     sp,sp,#6
   1658 0000E860 00 11                       lw      r1,#0       ; Z=1 if not found
   1659 0000E862 F0 80                       ret
                                        
                                        
                                        ; Returns
                                        ;   r1 = 3 character variable name + type
                                        ;
   1665 0000E864                        getVarName
   1666 0000E864 FA 6E                       sub     sp,sp,#6
   1667 0000E866 E0 DF                       sw      lr,[sp]
   1668 0000E868 E4 D5                       sw		r5,4[sp]
                                        
   1670 0000E86A 80 E1                       lb      r1,[r8]     ; get first character
   1671 0000E86C E2 D1                       sw		r1,2[sp]	; save off current name
   1672 0000E86E 19 BF                       call    isAlpha
   1673 0000E870 2F A8                       beq     gvn1
   1674 0000E872 02 15                       lw      r5,#2       ; loop twice more
                                        
                                        	; check for second/third character
   1677 0000E874                        gvn4
   1678 0000E874 01 68                   	add     r8,r8,#1
   1679 0000E876 80 E1                   	lb      r1,[r8]     ; do we have another char ?
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 29
noc_boot31.a
   1680 0000E878 24 BF                   	call    isAlnum
   1681 0000E87A 12 A8                   	beq     gvn2        ; nope
   1682 0000E87C E2 F1                   	lw      r1,2[sp]    ; get varname
   1683 0000E87E 81 31                   	shl     r1,#1       ; shift left by eight
   1684 0000E880 81 31                   	shl     r1,#1       ; shift left by eight
   1685 0000E882 81 31                   	shl     r1,#1       ; shift left by eight
   1686 0000E884 81 31                   	shl     r1,#1       ; shift left by eight
   1687 0000E886 81 31                   	shl     r1,#1       ; shift left by eight
   1688 0000E888 81 31                   	shl     r1,#1       ; shift left by eight
   1689 0000E88A 81 31                   	shl     r1,#1       ; shift left by eight
   1690 0000E88C 81 31                   	shl     r1,#1       ; shift left by eight
   1691 0000E88E 80 E2                   	lb      r2,[r8]
   1692 0000E890 26 21                   	or      r1,r2       ; add in new char
   1693 0000E892 E2 D1                       sw      r1,2[sp]   ; save off name again
   1694 0000E894 FF 65                       sub		r5,r5,#1
   1695 0000E896 EE B9                       bne     gvn4
                                        
                                            ; now ignore extra variable name characters
   1698 0000E898                        gvn6
   1699 0000E898 01 68                       add     r8,r8,#1
   1700 0000E89A 80 E1                       lb      r1,[r8]
   1701 0000E89C 12 BF                       call    isAlnum
   1702 0000E89E FC B9                       bne     gvn6        ; keep looping as long as we have identifier chars
                                            
   1704 0000E8A0                        gvn2
   1705 0000E8A0 80 E1                   	lb		r1,[r8]
   1706 0000E8A2 FD 4F 1B 10                 cmp     r1,#'%'
   1707 0000E8A6 05 A8                       beq     gvn3
   1708 0000E8A8 FD 4F 1C 10                 cmp     r1,#'$'
   1709 0000E8AC 02 A8                       beq     gvn3
   1710 0000E8AE 00 11                       lw      r1,#0
   1711 0000E8B0 FF 68                       sub     r8,r8,#1
                                        
                                            ; insert variable type indicator and return
   1714 0000E8B2                        gvn3
   1715 0000E8B2 01 68                       add     r8,r8,#1
   1716 0000E8B4 E2 F2                       lw      r2,2[sp]
   1717 0000E8B6 81 32                       shl     r2,#1
   1718 0000E8B8 81 32                       shl     r2,#1
   1719 0000E8BA 81 32                       shl     r2,#1
   1720 0000E8BC 81 32                       shl     r2,#1
   1721 0000E8BE 81 32                       shl     r2,#1
   1722 0000E8C0 81 32                       shl     r2,#1
   1723 0000E8C2 81 32                       shl     r2,#1
   1724 0000E8C4 81 32                       shl     r2,#1
   1725 0000E8C6 26 21                       or      r1,r2       ; add in variable type
   1726 0000E8C8 E0 FF                       lw      lr,[sp]
   1727 0000E8CA E4 F5                       lw		r5,4[sp]
   1728 0000E8CC 06 6E                       add     sp,sp,#6   ; return Z = 0, r1 = varname
   1729 0000E8CE F0 80                       ret
                                        
                                            ; not a variable name
   1732 0000E8D0                        gvn1
   1733 0000E8D0 E0 FF                       lw      lr,[sp]
   1734 0000E8D2 E4 F5                       lw		r5,4[sp]
   1735 0000E8D4 06 6E                       add     sp,sp,#6
   1736 0000E8D6 00 11                       lw      r1,#0       ; return Z = 1 if not a varname
   1737 0000E8D8 F0 80                       ret
                                        
                                        
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 30
noc_boot31.a
                                        ; Find variable
                                        ;   r1 = varname
                                        ;	r2 = allocate flag
                                        ; Returns
                                        ;   r1 = variable address, Z =0 if found / allocated, Z=1 if not found
                                        
   1746 0000E8DA                        findVar
   1747 0000E8DA FC 6E                       sub     sp,sp,#4
   1748 0000E8DC E0 DF                       sw      lr,[sp]
   1749 0000E8DE E2 D7                       sw      r7,2[sp]
   1750 0000E8E0 09 40 08 F3                 lw      r3,VARBGN
   1751 0000E8E4                        fv4
   1752 0000E8E4 30 F7                       lw      r7,[r3]     ; get varname / type
   1753 0000E8E6 0A A8                       beq     fv3         ; no more vars ?
   1754 0000E8E8 7D 21                       cmp     r1,r7       ; match ?
   1755 0000E8EA 0B A8                       beq     fv1
   1756 0000E8EC 08 63                       add     r3,r3,#8    ; move to next var
   1757 0000E8EE 0A 40 00 F7                 lw      r7,STKBOT
   1758 0000E8F2 7D 23                       cmp     r3,r7
   1759 0000E8F4 F7 B0                       blt     fv4         ; loop back to look at next var
                                        
                                            ; variable not found
                                            ; no more memory
   1763 0000E8F6 16 4F 04 11                 lea     r1,msgVarSpace
   1764 0000E8FA EF AE                       br      ERROR
                                        ;    lw      lr,[sp]
                                        ;    lw      r7,2[sp]
                                        ;    add     sp,sp,#4
                                        ;    lw      r1,#0
                                        ;    ret
                                        
                                            ; variable not found
                                            ; allocate new ?
   1773 0000E8FC                        fv3
   1774 0000E8FC 26 22                   	or		r2,r2
   1775 0000E8FE 06 A8                   	beq		fv2
   1776 0000E900 30 D1                       sw      r1,[r3]     ; save varname / type
                                            ; found variable
                                            ; return address
   1779 0000E902                        fv1
   1780 0000E902 34 11                       add     r1,r3,#4
   1781 0000E904 E0 FF                       lw      lr,[sp]
   1782 0000E906 E2 F7                       lw      r7,2[sp]
   1783 0000E908 04 6E                       add     sp,sp,#4    ; Z = 0, r1 = address
   1784 0000E90A F0 80                       ret
                                        
                                            ; didn't find var and not allocating
   1787 0000E90C                        fv2
   1788 0000E90C E0 FF                       lw      lr,[sp]
   1789 0000E90E E2 F7                       lw      r7,2[sp]
   1790 0000E910 04 6E                       add     sp,sp,#4    ; Z = 0, r1 = address
   1791 0000E912 00 11                   	lw		r1,#0		; Z = 1, r1 = 0
   1792 0000E914 F0 80                       ret
                                        
                                        
                                        ; ===== Multiplies the 32 bit values in r1 and r2, returning
                                        ;	the 32 bit result in r1.
                                        ;
                                        
   1799 0000E916                        MULT32
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 31
noc_boot31.a
   1800 0000E916 FA 6E                   	sub		sp,sp,#6
   1801 0000E918 E0 D5                   	sw		r5,[sp]		; w
   1802 0000E91A E2 D6                   	sw		r6,2[sp]	; s
   1803 0000E91C E4 D7                   	sw		r7,4[sp]
                                        
   1805 0000E91E 00 15                   	lw		r5,#0		; w = 0;
   1806 0000E920 10 16                   	lw		r6,r1
   1807 0000E922 24 26                   	xor		r6,r2		; s = a ^ b
   1808 0000E924 16 21                   	or		r1,r1
   1809 0000E926 01 AB                   	bpl		mult1
   1810 0000E928 20 31                   	neg		r1
   1811 0000E92A                        mult1
   1812 0000E92A 26 22                   	or		r2,r2
   1813 0000E92C 01 AB                   	bpl		mult2
   1814 0000E92E 20 32                   	neg		r2
   1815 0000E930                        mult2
   1816 0000E930 10 17                   	lw		r7,r1
   1817 0000E932 51 37                   	and		r7,#1
   1818 0000E934 01 A8                   	beq		mult3
   1819 0000E936 20 25                   	add		r5,r2		; w += b
   1820 0000E938                        mult3
   1821 0000E938 81 32                   	shl		r2,#1		; b <<= 1
   1822 0000E93A A1 31                   	shr		r1,#1		; a >>= 1
   1823 0000E93C F9 B9                   	bne		mult2       ; a = 0 ?
   1824 0000E93E                        mult4
   1825 0000E93E 66 26                       or      r6,r6
   1826 0000E940 01 AB                   	bpl		mult5
   1827 0000E942 20 35                   	neg		r5
   1828 0000E944                        mult5
   1829 0000E944 50 11                   	lw		r1,r5
   1830 0000E946 E4 F7                   	lw		r7,4[sp]
   1831 0000E948 E2 F6                   	lw		r6,2[sp]
   1832 0000E94A E0 F5                   	lw		r5,[sp]
   1833 0000E94C 06 6E                   	add		sp,sp,#6
   1834 0000E94E F0 80                   	ret
                                        
                                        
                                        ; ===== Divide the 32 bit value in r2 by the 32 bit value in r3.
                                        ;	Returns the 32 bit quotient in r1, remainder in r2
                                        ;
                                        ; r2 = a
                                        ; r3 = b
                                        ; r6 = remainder
                                        ; r7 = iteration count
                                        ; r8 = sign
                                        ;
                                        
                                        ; q = a / b
                                        ; a = r1
                                        ; b = r2
                                        ; q = r2
                                        
   1852 0000E950                        DIV32
   1853 0000E950 26 22                       or      r2,r2       ; check for divide-by-zero
   1854 0000E952 03 A9                       bne		div6
   1855 0000E954 15 4F 01 11                 lea		r1,msgDivZero
   1856 0000E958 C0 AE                       br		ERROR		; divide by zero error
   1857 0000E95A                        div6
   1858 0000E95A FA 6E                   	sub		sp,sp,#6
   1859 0000E95C E0 D6                   	sw		r6,[sp]
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 32
noc_boot31.a
   1860 0000E95E E2 D7                   	sw		r7,2[sp]
   1861 0000E960 E4 D8                   	sw		r8,4[sp]
                                        
   1863 0000E962 02 40 00 18                 lw      r8,#32      ; iteration count for 32 bits
   1864 0000E966 00 16                   	lw		r6,#0		; r = 0
   1865 0000E968 20 17                       lw      r7,r2       ; r7 = sign of result
   1866 0000E96A 14 27                       xor     r7,r1
   1867 0000E96C 16 21                   	or	    r1,r1	    ; take absolute value of r1 (a)
   1868 0000E96E 01 AB                   	bpl     div1
   1869 0000E970 20 31                   	neg     r1
   1870 0000E972                        div1
   1871 0000E972 26 22                       or      r2,r2	    ; take absolute value of r2 (b)
   1872 0000E974 01 AB                   	bpl	    div2
   1873 0000E976 20 32                   	neg     r2
   1874 0000E978                        div2
   1875 0000E978 81 31                   	shl		r1,#1		; a <<= 1
   1876 0000E97A 61 26                   	adc		r6,r6		; r <<= 1
   1877 0000E97C 6D 22                   	cmp		r2,r6		; b < r ?
   1878 0000E97E 02 A7                   	bgtu	div4
   1879 0000E980 22 26                   	sub		r6,r2		; r -= b
   1880 0000E982 61 31                   	or      r1,#1       ; a |= 1
   1881 0000E984                        div4
   1882 0000E984 FF 68                   	sub		r8,r8,#1
   1883 0000E986 F8 B9                       bne     div2        ; n--
   1884 0000E988 76 27                   	or      r7,r7
   1885 0000E98A 01 AB                   	bpl     div5
   1886 0000E98C 20 31                   	neg     r1
   1887 0000E98E                        div5
   1888 0000E98E 60 12                   	lw		r2,r6		; r2 = r
   1889 0000E990 E2 F7                   	lw		r7,2[sp]
   1890 0000E992 E4 F8                   	lw		r8,4[sp]
   1891 0000E994 E0 F6                   	lw		r6,[sp]
   1892 0000E996 06 6E                   	add		sp,sp,#6
   1893 0000E998 F0 80                   	ret
                                        
                                        ; ===== The PEEK function returns the byte stored at the address
                                        ;	contained in the following expression.
                                        ;
   1898 0000E99A                        PEEK
   1899 0000E99A 29 BF                   	call	PARN		; get the memory address
   1900 0000E99C 10 E1                   	lb		r1,[r1]		; get the addressed byte
   1901 0000E99E 0E 21                   	zxb		r1			; upper 3 bytes will be zero
   1902 0000E9A0 E0 FF                   	lw		lr,[sp]	; and return it
   1903 0000E9A2 06 6E                   	add		sp,sp,#6
   1904 0000E9A4 F0 80                   	ret
                                        
                                        
                                        ; ===== The PEEK function returns the byte stored at the address
                                        ;	contained in the following expression.
                                        ;
   1910 0000E9A6                        PEEKW
   1911 0000E9A6 23 BF                   	call	PARN		; get the memory address
   1912 0000E9A8 5E 31                   	and		r1,#-2		; align to word address
   1913 0000E9AA 10 F1                   	lw		r1,[r1]		; get the addressed word
   1914 0000E9AC E0 FF                   	lw		lr,[sp]	; and return it
   1915 0000E9AE 06 6E                   	add		sp,sp,#6
   1916 0000E9B0 F0 80                   	ret
                                        
                                        
                                        ; user function call
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 33
noc_boot31.a
                                        ; call the user function with argument in r1
   1921 0000E9B2                        USRX
   1922 0000E9B2 1D BF                   	call	PARN		; get expression value
   1923 0000E9B4 E2 D8                   	sw		r8,2[sp]	; save the text pointer
   1924 0000E9B6 02 40 04 F2             	lw      r2,usrJmp   ; get usr vector
   1925 0000E9BA B2 48 01 AF             	call	[r2]		; jump to the subroutine
   1926 0000E9BE E2 F8                   	lw		r8,2[sp]	; restore the text pointer
   1927 0000E9C0 E0 FF                   	lw		lr,[sp]
   1928 0000E9C2 06 6E                   	add		sp,sp,#6
   1929 0000E9C4 F0 80                   	ret
                                        
                                        
                                        ; ===== The RND function returns a random number from 1 to
                                        ;	the value of the following expression in D0.
                                        ;
   1935 0000E9C6                        RND
   1936 0000E9C6 13 BF                   	call	PARN		; get the upper limit
   1937 0000E9C8 16 21                   	or		r1,r1		; it must be positive and non-zero
   1938 0000E9CA 0E A8                   	beq		rnd2
   1939 0000E9CC 0A AA                   	bmi		rnd1
   1940 0000E9CE 10 12                   	lw		r2,r1
   1941 0000E9D0 CA 4D 04 D0             	sh		r0,RAND+4	; read command
   1942 0000E9D4 CA 4D 00 F1             	lw		r1,RAND		; get a number
   1943 0000E9D8 0E AF                   	call	modu4		; RND(n)=MOD(number,n)+1
   1944 0000E9DA 01 61                   	add		r1,r1,#1
   1945 0000E9DC E0 FF                   	lw		lr,[sp]
   1946 0000E9DE 06 6E                   	add		sp,sp,#6
   1947 0000E9E0 F0 80                   	ret
   1948 0000E9E2                        rnd1
   1949 0000E9E2 1D 4F 05 11             	lea		r1,msgRNDBad
   1950 0000E9E6 79 AE                   	br		ERROR
   1951 0000E9E8                        rnd2
   1952 0000E9E8 CA 4D 04 D0             	sh		r0,RAND+4
   1953 0000E9EC CA 4D 00 F1             	lw		r1,RAND
   1954 0000E9F0 E0 FF                   	lw		lr,[sp]
   1955 0000E9F2 06 6E                   	add		sp,sp,#6
   1956 0000E9F4 F0 80                   	ret
                                        
                                        
                                        ; r = a mod b
                                        ; a = r2
                                        ; b = r3
                                        ; r = r1
   1963 0000E9F6                        modu4
   1964 0000E9F6 FA 6E                   	sub		sp,sp,#6
   1965 0000E9F8 E0 D5                   	sw		r5,[sp]
   1966 0000E9FA E2 D6                   	sw		r6,2[sp]
   1967 0000E9FC E4 D7                   	sw		r7,4[sp]
   1968 0000E9FE 02 40 00 17             	lw      r7,#32		; n = 32
   1969 0000EA02 00 15                   	lw		r5,#0		; w = 0
   1970 0000EA04 00 16                   	lw		r6,#0		; r = 0
   1971 0000EA06                        mod2
   1972 0000EA06 81 31                   	shl		r1,#1		; a <<= 1
   1973 0000EA08 61 26                   	adc		r6,r6		; r <<= 1
   1974 0000EA0A 6D 22                   	cmp		r2,r6		; b < r ?
   1975 0000EA0C 01 A7                   	bgtu	mod1
   1976 0000EA0E 22 26                   	sub		r6,r2		; r -= b
   1977 0000EA10                        mod1
   1978 0000EA10 FF 67                   	sub		r7,r7,#1
   1979 0000EA12 F9 B9                       bne     mod2        ; n--
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 34
noc_boot31.a
   1980 0000EA14 60 11                   	lw		r1,r6
   1981 0000EA16 E0 F5                   	lw		r5,[sp]
   1982 0000EA18 E2 F6                   	lw		r6,2[sp]
   1983 0000EA1A E4 F7                   	lw		r7,4[sp]
   1984 0000EA1C 06 6E                   	add		sp,sp,#6
   1985 0000EA1E F0 80                   	ret
                                        
                                        
                                        
                                        ; ===== The ABS function returns an absolute value in r2.
                                        ;
   1991 0000EA20                        ABS
   1992 0000EA20 EE 4F 05 AF             	call	PARN		; get the following expr.'s value
   1993 0000EA24 16 21                   	or		r1,r1
   1994 0000EA26 01 AB                   	bpl		abs1
   1995 0000EA28 20 31                   	neg		r1			; if negative, complement it
                                        ;	bmi		QHOW		; if still negative, it was too big
   1997 0000EA2A                        abs1
   1998 0000EA2A E0 FF                   	lw		lr,[sp]
   1999 0000EA2C 06 6E                   	add		sp,sp,#6
   2000 0000EA2E F0 80                   	ret
                                        
                                        
                                        ; ===== The SGN function returns the sign in r1. +1,0, or -1
                                        ;
   2005 0000EA30                        SGN
   2006 0000EA30 ED 4F 0D AF             	call	PARN		; get the following expr.'s value
   2007 0000EA34 16 21                   	or		r1,r1
   2008 0000EA36 04 A8                   	beq		sgn1
   2009 0000EA38 02 AB                   	bpl		sgn2
   2010 0000EA3A 0F 11                   	lw		r1,#-1
   2011 0000EA3C 01 AE                   	br		sgn1
   2012 0000EA3E                        sgn2
   2013 0000EA3E 01 11                   	lw		r1,#1
   2014 0000EA40                        sgn1
   2015 0000EA40 E0 FF                   	lw		lr,[sp]
   2016 0000EA42 06 6E                   	add		sp,sp,#6
   2017 0000EA44 F0 80                   	ret
                                        
                                        
                                        ; ===== The SIZE function returns the size of free memory in r1.
                                        ;
   2022 0000EA46                        SIZEX
   2023 0000EA46 09 40 08 F1             	lw		r1,VARBGN	; get the number of free bytes...
   2024 0000EA4A 09 40 06 F2             	lw		r2,TXTUNF	; between 'TXTUNF' and 'VARBGN'
   2025 0000EA4E 22 21                   	sub		r1,r2
   2026 0000EA50 E0 FF                   	lw		lr,[sp]
   2027 0000EA52 06 6E                   	add		sp,sp,#6
   2028 0000EA54 F0 80                   	ret					; return the number in r2
                                        
                                        ; ==== Return the node number that the code is running on
                                        ;
   2032 0000EA56                        NODENUM
   2033 0000EA56 E4 31                   	tsr		r1,ID
   2034 0000EA58 E0 FF                   	lw		lr,[sp]
   2035 0000EA5A 06 6E                   	add		sp,sp,#6
   2036 0000EA5C F0 80                   	ret
                                        
                                        ;******************************************************************
                                        ;
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 35
noc_boot31.a
                                        ; *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                                        ;
                                        ; 'SETVAL' expects a variable, followed by an equal sign and then
                                        ; an expression.  It evaluates the expression and sets the variable
                                        ; to that value.
                                        ;
                                        ; 'FIN' checks the end of a command.  If it ended with ":",
                                        ; execution continues.	If it ended with a CR, it finds the
                                        ; the next line and continues from there.
                                        ;
                                        ; 'ENDCHK' checks if a command is ended with a CR. This is
                                        ; required in certain commands, such as GOTO, RETURN, STOP, etc.
                                        ;
                                        ; 'ERROR' prints the string pointed to by A0. It then prints the
                                        ; line pointed to by CURRNT with a "?" inserted at where the
                                        ; old text pointer (should be on top of the stack) points to.
                                        ; Execution of Tiny BASIC is stopped and a warm start is done.
                                        ; If CURRNT is zero (indicating a direct command), the direct
                                        ; command is not printed. If CURRNT is -1 (indicating
                                        ; 'INPUT' command in progress), the input line is not printed
                                        ; and execution is not terminated but continues at 'INPERR'.
                                        ;
                                        ; Related to 'ERROR' are the following:
                                        ; 'QWHAT' saves text pointer on stack and gets "What?" message.
                                        ; 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                                        ; 'QSORRY' and 'ASORRY' do the same kind of thing.
                                        ; 'QHOW' and 'AHOW' also do this for "How?".
                                        ;
                                        
                                        ; returns
                                        ; r2 = variable's address
                                        ;
   2072 0000EA5E                        SETVAL
   2073 0000EA5E FC 6E                       sub     sp,sp,#4
   2074 0000EA60 E0 DF                       sw      lr,[sp]
   2075 0000EA62 01 11                       lw		r1,#1		; allocate var
   2076 0000EA64 ED 4F 03 AF                 call	TSTV		; variable name?
   2077 0000EA68 03 A9                       bne		sv2
   2078 0000EA6A 1B 4F 0E 11                	lea		r1,msgVar
   2079 0000EA6E 35 AE                      	br		ERROR 
   2080 0000EA70                        sv2
   2081 0000EA70 E2 D1                   	sw      r1,2[sp]    ; save the variable's address
   2082 0000EA72 1D 40 06 AF             	call	TSTC		; get past the "=" sign
   2083 0000EA76 3D 12                   	db	'=',SV1-*+1
   2084 0000EA78 DE 4F 05 AF             	call	OREXPR		; evaluate the expression
   2085 0000EA7C E2 F2                   	lw      r2,2[sp]    ; get back the variable's address
   2086 0000EA7E 20 D1                   	sw      r1,[r2]     ; and save value in the variable
   2087 0000EA80 20 11                   	lw		r1,r2		; return r1 = variable address
   2088 0000EA82 E0 FF                   	lw      lr,[sp]
   2089 0000EA84 04 6E                   	add     sp,sp,#4
   2090 0000EA86 F0 80                   	ret
   2091 0000EA88                        SV1
   2092 0000EA88 26 AE                       br	    QWHAT		; if no "=" sign
                                        
                                        
   2095 0000EA8A                        FIN
   2096 0000EA8A FE 6E                   	sub		sp,sp,#2
   2097 0000EA8C E0 DF                   	sw		lr,[sp]
   2098 0000EA8E 1C 40 08 AF             	call	TSTC		; *** FIN ***
   2099 0000EA92 3A 08                   	db	':',FI1-*+1
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 36
noc_boot31.a
   2100 0000EA94 02 6E                   	add		sp,sp,#2	; if ":", discard return address
   2101 0000EA96 BF 4F 0B AE             	br		RUNSML		; continue on the same line
   2102 0000EA9A                        FI1
   2103 0000EA9A 1C 40 02 AF             	call	TSTC		; not ":", is it a CR?
   2104 0000EA9E 0D 0A                   	db	CR,FI2-*+1
   2105 0000EAA0 E0 FF                   	lw		lr,[sp]	; else return to the caller
   2106 0000EAA2 02 6E                   	add		sp,sp,#2	; yes, purge return address
   2107 0000EAA4 BE 4F 09 AE             	br		RUNNXL		; execute the next line
   2108 0000EAA8                        FI2
   2109 0000EAA8 E0 FF                   	lw		lr,[sp]	; else return to the caller
   2110 0000EAAA 02 6E                   	add		sp,sp,#2
   2111 0000EAAC F0 80                   	ret
                                        
                                        
                                        ; Check that there is nothing else on the line
                                        ; Registers Affected
                                        ;   r1
                                        ;
   2118 0000EAAE                        ENDCHK
   2119 0000EAAE FE 6E                   	sub		sp,sp,#2
   2120 0000EAB0 E0 DF                   	sw		lr,[sp]
   2121 0000EAB2 1E 40 09 AF             	call	IGNBLK
   2122 0000EAB6 80 E1                   	lb		r1,[r8]
   2123 0000EAB8 FF 4F 13 10             	cmp		r1,#CR		; does it end with a CR?
   2124 0000EABC 03 A8                   	beq		ec1
   2125 0000EABE 29 4F 08 11             	lea		r1,msgExtraChars
   2126 0000EAC2 0B AE                   	jmp		ERROR
   2127 0000EAC4                        ec1
   2128 0000EAC4 E0 FF                   	lw		lr,[sp]
   2129 0000EAC6 02 6E                   	add		sp,sp,#2
   2130 0000EAC8 F0 80                   	ret
                                        
                                        
   2133 0000EACA                        TOOBIG
   2134 0000EACA 28 4F 03 11             	lea		r1,msgTooBig
   2135 0000EACE 05 AE                   	br		ERROR
   2136 0000EAD0                        QSORRY
   2137 0000EAD0 11 4F 09 11                 lea     r1,SRYMSG
   2138 0000EAD4 02 AE                   	br	    ERROR
   2139 0000EAD6                        QWHAT
   2140 0000EAD6 11 4F 01 11             	lea		r1,msgWhat
   2141 0000EADA                        ERROR
   2142 0000EADA 21 40 0D AF             	call	PRMESG		; display the error message
   2143 0000EADE 08 40 06 F1             	lw		r1,CURRNT	; get the current line number
   2144 0000EAE2 B0 4F 0A A8             	beq		WSTART		; if zero, do a warm start
   2145 0000EAE6 11 10                   	cmp		r1,#-1		; is the line no. pointer = -1?
   2146 0000EAE8 CD 4F 08 A8             	beq		INPERR		; if so, redo input
   2147 0000EAEC 80 E5                   	lb		r5,[r8]		; save the char. pointed to
   2148 0000EAEE 80 C0                   	sb		r0,[r8]		; put a zero where the error is
   2149 0000EAF0 08 40 06 F1             	lw		r1,CURRNT	; point to start of current line
   2150 0000EAF4 17 40 07 AF             	call	PRTLN		; display the line in error up to the 0
   2151 0000EAF8 10 16                   	lw      r6,r1       ; save off end pointer
   2152 0000EAFA 80 C5                   	sb		r5,[r8]		; restore the character
   2153 0000EAFC 03 40 0F 11             	lw		r1,#'?'		; display a "?"
   2154 0000EB00 AD 4F 05 AF             	call	GOOUT
   2155 0000EB04 00 12                   	lw      r2,#0       ; stop char = 0
   2156 0000EB06 6F 11                   	sub		r1,r6,#1	; point back to the error char.
   2157 0000EB08 B6 AF                   	call	PRTSTG		; display the rest of the line
   2158 0000EB0A AF 4F 06 AE             	jmp	    WSTART		; and do a warm start
                                        
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 37
noc_boot31.a
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** GETLN *** FNDLN (& friends) ***
                                        ;
                                        ; 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                                        ; the character in r3 (given by the caller), then it fills the
                                        ; buffer and echos. It ignores LF's but still echos
                                        ; them back. Control-H is used to delete the last character
                                        ; entered (if there is one), and control-X is used to delete the
                                        ; whole line and start over again. CR signals the end of a line,
                                        ; and causes 'GETLN' to return.
                                        ;
                                        ;
   2174 0000EB0E                        GETLN
   2175 0000EB0E FC 6E                   	sub		sp,sp,#4
   2176 0000EB10 E0 DF                   	sw		lr,[sp]
   2177 0000EB12 E2 D5                   	sw		r5,2[sp]
   2178 0000EB14 AC 4F 0B AF             	call	GOOUT		; display the prompt
   2179 0000EB18 01 11                   	lw		r1,#1		; turn on cursor flash
   2180 0000EB1A 03 40 0C C1             	sb		r1,cursFlash
   2181 0000EB1E 02 40 00 11             	lw		r1,#' '		; and a space
   2182 0000EB22 AC 4F 04 AF             	call	GOOUT
   2183 0000EB26 0A 40 0E 18             	lea		r8,BUFFER	; r8 is the buffer pointer
   2184 0000EB2A                        GL1
   2185 0000EB2A 1E 40 03 AF             	call	CHKIO		; check keyboard
   2186 0000EB2E FD B8                   	beq		GL1			; wait for a char. to come in
   2187 0000EB30 FF 4F 18 10             	cmp		r1,#CTRLH	; delete last character?
   2188 0000EB34 14 A8                   	beq		GL3			; if so
   2189 0000EB36 FE 4F 18 10             	cmp		r1,#CTRLX	; delete the whole line?
   2190 0000EB3A 20 A8                   	beq		GL4			; if so
   2191 0000EB3C FF 4F 13 10             	cmp		r1,#CR		; accept a CR
   2192 0000EB40 03 A8                   	beq		GL2
   2193 0000EB42 FE 4F 10 10             	cmp		r1,#' '		; if other control char., discard it
   2194 0000EB46 F1 B4                   	bltu	GL1
   2195 0000EB48                        GL2
   2196 0000EB48 80 C1                   	sb		r1,[r8]		; save the char.
   2197 0000EB4A 01 68                   	add		r8,r8,#1
   2198 0000EB4C AA 4F 0F AF             	call	GOOUT		; echo the char back out
   2199 0000EB50 8F E1                   	lb      r1,-1[r8]   ; get char back (GOOUT destroys r1)
   2200 0000EB52 FF 4F 13 10             	cmp		r1,#CR		; if it's a CR, end the line
   2201 0000EB56 25 A8                   	beq		GL7
   2202 0000EB58 F0 4F 83 10             	cmp		r8,#(BUFFER+BUFLEN-1)	; any more room?
   2203 0000EB5C E6 B4                   	bltu	GL1			; yes: get some more, else delete last char.
                                        
   2205 0000EB5E                        GL3
   2206 0000EB5E 08 11                   	lw		r1,#CTRLH	; delete a char. if possible
   2207 0000EB60 AA 4F 05 AF             	call	GOOUT
   2208 0000EB64 02 40 00 11             	lw		r1,#' '
   2209 0000EB68 AA 4F 01 AF             	call	GOOUT
   2210 0000EB6C F5 4F 82 10             	cmp		r8,#BUFFER	; any char.'s left?
   2211 0000EB70 DC B6                   	bleu	GL1			; if not
   2212 0000EB72 08 11                   	lw		r1,#CTRLH	; if so, finish the BS-space-BS sequence
   2213 0000EB74 A9 4F 0B AF             	call	GOOUT
   2214 0000EB78 FF 68                   	sub		r8,r8,#1	; decrement the text pointer
   2215 0000EB7A D7 BE                   	br		GL1			; back for more
                                        
   2217 0000EB7C                        GL4
   2218 0000EB7C 80 11                   	lw		r1,r8		; delete the whole line
   2219 0000EB7E F5 4F 12 15             	sub		r5,r1,#BUFFER   ; figure out how many backspaces we need
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 38
noc_boot31.a
   2220 0000EB82 0C A8                   	beq		GL6			; if none needed, brnch
   2221 0000EB84                        GL5	
   2222 0000EB84 08 11                   	lw		r1,#CTRLH	; and display BS-space-BS sequences
   2223 0000EB86 A9 4F 02 AF             	call	GOOUT
   2224 0000EB8A 02 40 00 11             	lw		r1,#' '
   2225 0000EB8E A8 4F 0E AF             	call	GOOUT
   2226 0000EB92 08 11                   	lw		r1,#CTRLH
   2227 0000EB94 A8 4F 0B AF             	call	GOOUT
   2228 0000EB98 FF 65                   	sub		r5,r5,#1
   2229 0000EB9A F4 B9                   	bne     GL5
   2230 0000EB9C                        GL6
   2231 0000EB9C 0A 40 0E 18             	lea		r8,BUFFER	; reinitialize the text pointer
   2232 0000EBA0 C4 BE                   	br		GL1			; and go back for more
   2233 0000EBA2                        GL7
   2234 0000EBA2 00 11                   	lw		r1,#0		; turn off cursor flash
   2235 0000EBA4 03 40 0C C1             	sb		r1,cursFlash
   2236 0000EBA8 0A 11                   	lw		r1,#LF		; echo a LF for the CR
   2237 0000EBAA A8 4F 00 AF             	call	GOOUT
   2238 0000EBAE E0 FF                   	lw		lr,[sp]
   2239 0000EBB0 E2 F5                   	lw		r5,2[sp]
   2240 0000EBB2 04 6E                   	add		sp,sp,#4
   2241 0000EBB4 F0 80                   	ret
                                        
                                        
                                        ; 'FNDLN' finds a line with a given line no. (in r1) in the
                                        ; text save area.  r9 is used as the text pointer. If the line
                                        ; is found, r9 will point to the beginning of that line
                                        ; (i.e. the high byte of the line no.), and flags are Z.
                                        ; If that line is not there and a line with a higher line no.
                                        ; is found, r9 points there and flags are NC & NZ. If we reached
                                        ; the end of the text save area and cannot find the line, flags
                                        ; are C & NZ.
                                        ; Z=1 if line found
                                        ; N=1 if end of text save area
                                        ; Z=0 & N=0 if higher line found
                                        ;
                                        ; 'FNDLN' will initialize r9 to the beginning of the text save
                                        ; area to start the search. Some other entries of this routine
                                        ; will not initialize r9 and do the search.
                                        ; 'FNDLNP' will start with r9 and search for the line no.
                                        ; 'FNDNXT' will bump r9 by 2, find a CR and then start search.
                                        ; 'FNDSKP' uses r9 to find a CR, and then starts the search.
                                        ; return Z=1 if line is found, r9 = pointer to line
                                        ;
                                        ; Parameters
                                        ;	r1 = line number to find
                                        ;
   2267 0000EBB6                        FNDLN
   2268 0000EBB6 00 40 11 10             	cmp		r1,#0xFFFF	; line no. must be < 65535
   2269 0000EBBA 03 A6                   	bleu	fl1
   2270 0000EBBC 1A 4F 08 11             	lea		r1,msgLineRange
   2271 0000EBC0 8C BE                   	br		ERROR
   2272 0000EBC2                        fl1
   2273 0000EBC2 0C 4E 02 F9             	lw		r9,TXTBGN	; init. the text save pointer
                                        
   2275 0000EBC6                        FNDLNP
   2276 0000EBC6 09 40 06 FA             	lw		r10,TXTUNF	; check if we passed the end
   2277 0000EBCA FF 6A                   	sub		r10,r10,#1
   2278 0000EBCC AD 29                   	cmp		r9,r10
   2279 0000EBCE 0F A7                   	bgtu	FNDRET		; if so, return with Z=0 & C=1
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 39
noc_boot31.a
   2280 0000EBD0 90 E3                   	lb		r3,[r9]		; get low order byte of line number
   2281 0000EBD2 0E 23                   	zxb		r3
   2282 0000EBD4 91 E2                   	lb		r2,1[r9]	; get high order byte
   2283 0000EBD6 0E 22                   	zxb		r2
   2284 0000EBD8 81 32                   	shl		r2,#1
   2285 0000EBDA 81 32                   	shl		r2,#1
   2286 0000EBDC 81 32                   	shl		r2,#1
   2287 0000EBDE 81 32                   	shl		r2,#1
   2288 0000EBE0 81 32                   	shl		r2,#1
   2289 0000EBE2 81 32                   	shl		r2,#1
   2290 0000EBE4 81 32                   	shl		r2,#1
   2291 0000EBE6 81 32                   	shl		r2,#1
   2292 0000EBE8 36 22                   	or		r2,r3		; build whole line number
   2293 0000EBEA 2D 21                   	cmp		r1,r2		; is this the line we want?
   2294 0000EBEC 01 A7                   	bgtu	FNDNXT		; no, not there yet
   2295 0000EBEE                        FNDRET
   2296 0000EBEE F0 80                   	ret			; return the cond. codes
                                        
   2298 0000EBF0                        FNDNXT
   2299 0000EBF0 02 69                   	add		r9,r9,#2	; find the next line
                                        
   2301 0000EBF2                        FNDSKP
   2302 0000EBF2 90 E2                   	lb		r2,[r9]
   2303 0000EBF4 01 69                   	add		r9,r9,#1
   2304 0000EBF6 FF 4F 23 10             	cmp		r2,#CR		; try to find a CR
   2305 0000EBFA FB B9                   	bne		FNDSKP		; keep looking
   2306 0000EBFC E4 BE                   	br		FNDLNP		; check if end of text
                                        
                                        
                                        ;******************************************************************
                                        ; 'MVUP' moves a block up from where r1 points to where r2 points
                                        ; until r1=r3
                                        ;
   2313 0000EBFE                        MVUP1
   2314 0000EBFE 10 E4                   	lb		r4,[r1]
   2315 0000EC00 20 C4                   	sb		r4,[r2]
   2316 0000EC02 01 61                   	add		r1,r1,#1
   2317 0000EC04 01 62                   	add		r2,r2,#1
   2318 0000EC06                        MVUP
   2319 0000EC06 3D 21                   	cmp		r1,r3
   2320 0000EC08 FA B9                   	bne		MVUP1
   2321 0000EC0A                        MVRET
   2322 0000EC0A F0 80                   	ret
                                        
                                        
                                        ; 'MVDOWN' moves a block down from where r1 points to where r2
                                        ; points until r1=r3
                                        ;
   2328 0000EC0C                        MVDOWN1
   2329 0000EC0C FF 61                   	sub		r1,r1,#1
   2330 0000EC0E FF 62                   	sub		r2,r2,#1
   2331 0000EC10 10 E4                   	lb		r4,[r1]
   2332 0000EC12 20 C4                   	sb		r4,[r2]
   2333 0000EC14                        MVDOWN
   2334 0000EC14 3D 21                   	cmp		r1,r3
   2335 0000EC16 FA B9                   	bne		MVDOWN1
   2336 0000EC18 F0 80                   	ret
                                        
                                        
                                        ; 'POPA' restores the 'FOR' loop variable save area from the stack
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 40
noc_boot31.a
                                        ;
                                        ; 'PUSHA' stacks for 'FOR' loop variable save area onto the stack
                                        ;
                                        ; Note: a single zero word is stored on the stack in the
                                        ; case that no FOR loops need to be saved. This needs to be
                                        ; done because PUSHA / POPA is called all the time.
                                        
   2347 0000EC1A                        POPA
   2348 0000EC1A E0 F1                   	lw		r1,[sp]		; restore LOPVAR, but zero means no more
   2349 0000EC1C 08 40 0C D1             	sw		r1,LOPVAR
   2350 0000EC20 0E A8                   	beq		PP1
   2351 0000EC22 E8 F1                   	lw		r1,8[sp]	; if not zero, restore the rest
   2352 0000EC24 09 40 04 D1             	sw		r1,LOPPT
   2353 0000EC28 E6 F1                   	lw		r1,6[sp]
   2354 0000EC2A 09 40 02 D1             	sw		r1,LOPLN
   2355 0000EC2E E4 F1                   	lw		r1,4[sp]
   2356 0000EC30 09 40 00 D1             	sw		r1,LOPLMT
   2357 0000EC34 E2 F1                   	lw		r1,2[sp]
   2358 0000EC36 08 40 0E D1             	sw		r1,LOPINC
   2359 0000EC3A 0A 6E                   	add		sp,sp,#10
   2360 0000EC3C F0 80                   	ret
   2361 0000EC3E                        PP1
   2362 0000EC3E 02 6E                   	add		sp,sp,#2
   2363 0000EC40 F0 80                   	ret
                                        
                                        
   2366 0000EC42                        PUSHA
   2367 0000EC42 0A 40 00 F1             	lw		r1,STKBOT	; Are we running out of stack room?
   2368 0000EC46 0A 61                   	add		r1,r1,#10	; we might need this many bytes
   2369 0000EC48 1D 2E                   	cmp		sp,r1
   2370 0000EC4A 42 B4                   	bltu	QSORRY		; out of stack space
   2371 0000EC4C 08 40 0C F1             	lw		r1,LOPVAR	; save loop variables
   2372 0000EC50 0F A8                   	beq		PU1			; if LOPVAR is zero, that's all
   2373 0000EC52 F6 6E                   	sub		sp,sp,#10
   2374 0000EC54 E0 D1                   	sw		r1,[sp]
   2375 0000EC56 09 40 04 F1             	lw		r1,LOPPT
   2376 0000EC5A E8 D1                   	sw		r1,8[sp]	; else save all the others
   2377 0000EC5C 09 40 02 F1             	lw		r1,LOPLN
   2378 0000EC60 E6 D1                   	sw		r1,6[sp]
   2379 0000EC62 09 40 00 F1             	lw		r1,LOPLMT
   2380 0000EC66 E4 D1                   	sw		r1,4[sp]
   2381 0000EC68 08 40 0E F1             	lw		r1,LOPINC
   2382 0000EC6C E2 D1                   	sw		r1,2[sp]
   2383 0000EC6E F0 80                   	ret
   2384 0000EC70                        PU1
   2385 0000EC70 FE 6E                   	sub		sp,sp,#2
   2386 0000EC72 E0 D1                   	sw		r1,[sp]
   2387 0000EC74 F0 80                   	ret
                                        
                                        
                                        ;******************************************************************
                                        ;
                                        ; *** PRTSTG *** QTSTG *** PRTNUM *** PRTLN ***
                                        ;
                                        ; 'PRTSTG' prints a string pointed to by r3. It stops printing
                                        ; and returns to the caller when either a CR is printed or when
                                        ; the next byte is the same as what was passed in r4 by the
                                        ; caller.
                                        ;
                                        ; 'QTSTG' looks for an underline (back-arrow on some systems),
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 41
noc_boot31.a
                                        ; single-quote, or double-quote.  If none of these are found, returns
                                        ; to the caller.  If underline, outputs a CR without a LF.  If single
                                        ; or double quote, prints the quoted string and demands a matching
                                        ; end quote.  After the printing, the next 2 bytes of the caller are
                                        ; skipped over (usually a short brnch instruction).
                                        ;
                                        ; 'PRTNUM' prints the 32 bit number in r3, leading blanks are added if
                                        ; needed to pad the number of spaces to the number in r4.
                                        ; However, if the number of digits is larger than the no. in
                                        ; r4, all digits are printed anyway. Negative sign is also
                                        ; printed and counted in, positive sign is not.
                                        ;
                                        ; 'PRTLN' prints the saved text line pointed to by r3
                                        ; with line no. and all.
                                        ;
                                        
                                        ; r1 = pointer to string
                                        ; r2 = stop character
                                        ; return r1 = pointer to end of line + 1
                                        
   2420 0000EC76                        PRTSTG
   2421 0000EC76 F8 6E                       sub     sp,sp,#8
   2422 0000EC78 E0 DF                       sw      lr,[sp]
   2423 0000EC7A E2 D5                       sw      r5,2[sp]
   2424 0000EC7C E4 D6                       sw      r6,4[sp]
   2425 0000EC7E E6 D7                       sw      r7,6[sp]
   2426 0000EC80 10 15                       lw      r5,r1       ; r5 = pointer
   2427 0000EC82 20 16                       lw      r6,r2       ; r6 = stop char
   2428 0000EC84                        PS1
   2429 0000EC84 50 E7                       lb      r7,[r5]     ; get a text character
   2430 0000EC86 01 65                       add     r5,r5,#1
   2431 0000EC88 6D 27                   	cmp     r7,r6		; same as stop character?
   2432 0000EC8A 09 A8                   	beq	    PRTRET		; if so, return
   2433 0000EC8C 70 11                   	lw      r1,r7
   2434 0000EC8E A0 4F 0E AF             	call	GOOUT		; display the char.
   2435 0000EC92 FF 4F 73 10             	cmp     r7,#CR      ; is it a C.R.?
   2436 0000EC96 F6 B9                   	bne	    PS1		    ; no, go back for more
   2437 0000EC98 0A 11                   	lw      r1,#LF      ; yes, add a L.F.
   2438 0000EC9A A0 4F 08 AF             	call	GOOUT
   2439 0000EC9E                        PRTRET
   2440 0000EC9E 70 12                       lw      r2,r7       ; return r2 = stop char
   2441 0000ECA0 50 11                   	lw		r1,r5		; return r1 = line pointer
   2442 0000ECA2 E2 F5                       lw      r5,2[sp]
   2443 0000ECA4 E4 F6                       lw      r6,4[sp]
   2444 0000ECA6 E6 F7                       lw      r7,6[sp]
   2445 0000ECA8 E0 FF                       lw      lr,[sp]
   2446 0000ECAA 08 6E                       add     sp,sp,#8
   2447 0000ECAC F0 80                       ret			        ; then return
                                        
                                        
   2450 0000ECAE                        QTSTG
   2451 0000ECAE FE 6E                   	sub		sp,sp,#2
   2452 0000ECB0 E0 DF                   	sw		lr,[sp]
   2453 0000ECB2 B7 AF                   	call	TSTC		; *** QTSTG ***
   2454 0000ECB4 22 18                   	db	'"',QT3-*+1
   2455 0000ECB6 02 40 02 12             	lw		r2,#'"'		; it is a "
   2456 0000ECBA                        QT1
   2457 0000ECBA 80 11                   	lw		r1,r8
   2458 0000ECBC DC BF                   	call	PRTSTG		; print until another
   2459 0000ECBE 10 18                   	lw		r8,r1
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 42
noc_boot31.a
   2460 0000ECC0 FF 4F 26 10             	cmp		r2,#LF		; was last one a CR?
   2461 0000ECC4 0E A9                   	bne		QT2
   2462 0000ECC6 02 6E                   	add		sp,sp,#2
   2463 0000ECC8 AD 4F 07 AE             	br		RUNNXL		; if so, run next line
   2464 0000ECCC                        QT3
   2465 0000ECCC AA AF                   	call	TSTC		; is it a single quote?
   2466 0000ECCE 27 08                   	db	"'",QT4-*+1
   2467 0000ECD0 02 40 07 12             	lw		r2,#''''	; if so, do same as above
   2468 0000ECD4 F2 BE                   	br		QT1
   2469 0000ECD6                        QT4
   2470 0000ECD6 A5 AF                   	call	TSTC		; is it an underline?
   2471 0000ECD8 5F 10                   	db	'_',QT5-*+1
   2472 0000ECDA 00 40 0D 11             	lw		r1,#CR		; if so, output a CR without LF
   2473 0000ECDE 9E 4F 06 AF             	call	GOOUT
   2474 0000ECE2                        QT2
   2475 0000ECE2 E0 FF                   	lw		lr,[sp]
   2476 0000ECE4 02 6E                   	add		sp,sp,#2
   2477 0000ECE6 F2 80                   	jmp		2[lr]		; skip over 2 bytes when returning
   2478 0000ECE8                        QT5						; not " ' or _
   2479 0000ECE8 E0 FF                   	lw		lr,[sp]
   2480 0000ECEA 02 6E                   	add		sp,sp,#2
   2481 0000ECEC F0 80                   	ret
                                        
                                        
                                        ; Output a CR LF sequence
                                        ;
   2486 0000ECEE                        prCRLF
   2487 0000ECEE FE 6E                   	sub		sp,sp,#2
   2488 0000ECF0 E0 DF                   	sw		lr,[sp]
   2489 0000ECF2 00 40 0D 11             	lw		r1,#CR
   2490 0000ECF6 9D 4F 0A AF             	call	GOOUT
   2491 0000ECFA 0A 11                   	lw		r1,#LF
   2492 0000ECFC 9D 4F 07 AF             	call	GOOUT
   2493 0000ED00 E0 FF                   	lw		lr,[sp]
   2494 0000ED02 02 6E                   	add		sp,sp,#2
   2495 0000ED04 F0 80                   	ret
                                        
                                        
                                        ; r1 = number to print
                                        ; r2 = number of digits
                                        ; Register Usage
                                        ;	r5 = number of padding spaces
   2502 0000ED06                        PRTNUM
   2503 0000ED06 F8 6E                   	sub		sp,sp,#8
   2504 0000ED08 E0 DF                   	sw		lr,[sp]
   2505 0000ED0A E2 D5                   	sw		r5,2[sp]
   2506 0000ED0C E4 D6                   	sw		r6,4[sp]
   2507 0000ED0E E6 D7                   	sw		r7,6[sp]
                                        
   2509 0000ED10 0A 40 02 17             	lea		r7,NUMWKA	; r7 = pointer to numeric work area
   2510 0000ED14 10 16                   	lw		r6,r1		; save number for later
   2511 0000ED16 20 15                   	lw		r5,r2		; r5 = min number of chars
   2512 0000ED18 16 21                   	
   2513 0000ED1A 02 AB                   	bpl		PN1			; if not
   2514 0000ED1C 20 31                   	neg		r1			; else make it positive
   2515 0000ED1E FF 65                   	sub		r5,r5,#1	; one less for width count
   2516 0000ED20                        PN1
   2517 0000ED20 0A 12                   	lw		r2,#10		; divide by 10
   2518 0000ED22 E1 4F 05 AF             	call	DIV32
   2519 0000ED26 30 62                   	add		r2,r2,#'0'	; convert remainder to ascii
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 43
noc_boot31.a
   2520 0000ED28 70 C2                   	sb		r2,[r7]		; and store in buffer
   2521 0000ED2A 01 67                   	add		r7,r7,#1
   2522 0000ED2C FF 65                   	sub		r5,r5,#1	; decrement width
   2523 0000ED2E 10 10                   	cmp		r1,#0
   2524 0000ED30 F7 B9                   	bne		PN1
   2525 0000ED32                        PN6
   2526 0000ED32 56 25                   	or		r5,r5		; test pad count
   2527 0000ED34 06 A2                   	ble		PN4			; skip padding if not needed
   2528 0000ED36                        PN3
   2529 0000ED36 02 40 00 11             	lw		r1,#' '		; display the required leading spaces
   2530 0000ED3A 9B 4F 08 AF             	call	GOOUT
   2531 0000ED3E FF 65                   	sub		r5,r5,#1
   2532 0000ED40 FA B9                   	bne		PN3
   2533 0000ED42                        PN4
   2534 0000ED42 66 26                   	or		r6,r6		; is number negative?
   2535 0000ED44 04 AB                   	bpl		PN5
   2536 0000ED46 02 40 0D 11             	lw		r1,#'-'		; if so, display the sign
   2537 0000ED4A 9B 4F 00 AF             	call	GOOUT
   2538 0000ED4E                        PN5
   2539 0000ED4E FF 67                   	sub		r7,r7,#1
   2540 0000ED50 70 E1                   	lb		r1,[r7]		; now unstack the digits and display
   2541 0000ED52 9A 4F 0C AF             	call	GOOUT
   2542 0000ED56 F5 4F 7E 10             	cmp		r7,#NUMWKA
   2543 0000ED5A F9 B7                   	bgtu	PN5
   2544 0000ED5C                        PNRET
   2545 0000ED5C E0 FF                   	lw		lr,[sp]
   2546 0000ED5E E2 F5                   	lw		r5,2[sp]
   2547 0000ED60 E4 F6                   	lw		r6,4[sp]
   2548 0000ED62 E6 F7                   	lw		r7,6[sp]
   2549 0000ED64 08 6E                   	add		sp,sp,#8
   2550 0000ED66 F0 80                   	ret
                                        
                                        
                                        ; r1 = number to print
                                        ; r2 = number of digits
   2555 0000ED68                        PRTHEXNUM
   2556 0000ED68 F6 6E                   	sub		sp,sp,#10
   2557 0000ED6A E0 DF                   	sw		lr,[sp]
   2558 0000ED6C E2 D5                   	sw		r5,2[sp]
   2559 0000ED6E E4 D6                   	sw		r6,4[sp]
   2560 0000ED70 E6 D7                   	sw		r7,6[sp]
   2561 0000ED72 E8 D8                   	sw		r8,8[sp]
                                        
   2563 0000ED74 0A 40 02 17             	lea		r7,NUMWKA	; r7 = pointer to numeric work area
   2564 0000ED78 10 16                   	lw		r6,r1		; save number for later
   2565 0000ED7A 0A 15                   	lw		r5,#10		; r5 = min number of chars
   2566 0000ED7C 10 14                   	lw		r4,r1
   2567 0000ED7E 46 24                   	
   2568 0000ED80 03 AB                   	bpl		PHN1		; if not
   2569 0000ED82 20 34                   	neg		r4			; else make it positive
   2570 0000ED84 FF 65                   	sub		r5,r5,#1	; one less for width count
   2571 0000ED86 0A 18                   	lw		r8,#10		; maximum of 10 digits
   2572 0000ED88                        PHN1
   2573 0000ED88 40 11                   	lw		r1,r4
   2574 0000ED8A 00 40 5F 31             	and		r1,#15
   2575 0000ED8E FF 4F 16 10             	cmp		r1,#10
   2576 0000ED92 02 A0                   	blt		PHN7
   2577 0000ED94 37 61                   	add		r1,r1,#'A'-10
   2578 0000ED96 01 AE                   	br		PHN8
   2579 0000ED98                        PHN7
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 44
noc_boot31.a
   2580 0000ED98 30 61                   	add		r1,r1,#'0'		; convert remainder to ascii
   2581 0000ED9A                        PHN8
   2582 0000ED9A 70 C1                   	sb		r1,[r7]		; and store in buffer
   2583 0000ED9C 01 67                   	add		r7,r7,#1
   2584 0000ED9E FF 65                   	sub		r5,r5,#1	; decrement width
   2585 0000EDA0 A1 34                   	shr		r4,#1
   2586 0000EDA2 A1 34                   	shr		r4,#1
   2587 0000EDA4 A1 34                   	shr		r4,#1
   2588 0000EDA6 A1 34                   	shr		r4,#1
   2589 0000EDA8 02 A8                   	beq		PHN6			; is it zero yet ?
   2590 0000EDAA FF 68                   	sub		r8,r8,#1	; safety
   2591 0000EDAC ED B9                   	bne		PHN1
   2592 0000EDAE                        PHN6
   2593 0000EDAE 56 25                   	or		r5,r5		; test pad count
   2594 0000EDB0 06 A2                   	ble		PHN4			; skip padding if not needed
   2595 0000EDB2                        PHN3
   2596 0000EDB2 02 40 00 11             	lw		r1,#' '		; display the required leading spaces
   2597 0000EDB6 97 4F 0A AF             	call	GOOUT
   2598 0000EDBA FF 65                   	sub		r5,r5,#1
   2599 0000EDBC FA B9                   	bne		PHN3
   2600 0000EDBE                        PHN4
   2601 0000EDBE 66 26                   	or		r6,r6		; is number negative?
   2602 0000EDC0 04 AB                   	bpl		PHN5
   2603 0000EDC2 02 40 0D 11             	lw		r1,#'-'		; if so, display the sign
   2604 0000EDC6 97 4F 02 AF             	call	GOOUT
   2605 0000EDCA                        PHN5
   2606 0000EDCA FF 67                   	sub		r7,r7,#1
   2607 0000EDCC 70 E1                   	lb		r1,[r7]		; now unstack the digits and display
   2608 0000EDCE 96 4F 0E AF             	call	GOOUT
   2609 0000EDD2 F5 4F 7E 10             	cmp		r7,#NUMWKA
   2610 0000EDD6 F9 B7                   	bgtu	PHN5
   2611 0000EDD8                        PHNRET
   2612 0000EDD8 E0 FF                   	lw		lr,[sp]
   2613 0000EDDA E2 F5                   	lw		r5,2[sp]
   2614 0000EDDC E4 F6                   	lw		r6,4[sp]
   2615 0000EDDE E6 F7                   	lw		r7,6[sp]
   2616 0000EDE0 E8 F8                   	lw		r8,8[sp]
   2617 0000EDE2 0A 6E                   	add		sp,sp,#10
   2618 0000EDE4 F0 80                   	ret
                                        
                                        
                                        ; r1 = pointer to line
                                        ; returns r1 = pointer to end of line + 1
   2623 0000EDE6                        PRTLN
   2624 0000EDE6 FC 6E                       sub     sp,sp,#4
   2625 0000EDE8 E0 DF                       sw      lr,[sp]
   2626 0000EDEA E2 D5                       sw      r5,2[sp]
   2627 0000EDEC 12 15                       add     r5,r1,#2
   2628 0000EDEE 5E E1                       lb		r1,-2[r5]	; get the binary line number
   2629 0000EDF0 0E 21                       zxb		r1
   2630 0000EDF2 5F E2                       lb		r2,-1[r5]
   2631 0000EDF4 0E 22                       zxb		r2
   2632 0000EDF6 81 32                       shl		r2,#1
   2633 0000EDF8 81 32                       shl		r2,#1
   2634 0000EDFA 81 32                       shl		r2,#1
   2635 0000EDFC 81 32                       shl		r2,#1
   2636 0000EDFE 81 32                       shl		r2,#1
   2637 0000EE00 81 32                       shl		r2,#1
   2638 0000EE02 81 32                       shl		r2,#1
   2639 0000EE04 81 32                       shl		r2,#1
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 45
noc_boot31.a
   2640 0000EE06 26 21                       or		r1,r2
   2641 0000EE08 00 12                       lw      r2,#0       ; display a 0 or more digit line no.
   2642 0000EE0A 7D BF                   	call	PRTNUM
   2643 0000EE0C 02 40 00 11             	lw      r1,#' '     ; followed by a blank
   2644 0000EE10 94 4F 0D AF             	call	GOOUT
   2645 0000EE14 00 12                   	lw      r2,#0       ; stop char. is a zero
   2646 0000EE16 50 11                   	lw      r1,r5
   2647 0000EE18 2E BF                   	call    PRTSTG		; display the rest of the line
   2648 0000EE1A E2 F5                   	lw      r5,2[sp]
   2649 0000EE1C E0 FF                   	lw      lr,[sp]
   2650 0000EE1E 04 6E                   	add     sp,sp,#4
   2651 0000EE20 F0 80                   	ret
                                        
                                        
                                        ; ===== Test text byte following the call to this subroutine. If it
                                        ;	equals the byte pointed to by r8, return to the code following
                                        ;	the call. If they are not equal, brnch to the point
                                        ;	indicated by the offset byte following the text byte.
                                        ;
                                        ; Registers Affected
                                        ;   r3,r8
                                        ; Returns
                                        ;	r8 = updated text pointer
                                        ;
   2664 0000EE22                        TSTC
   2665 0000EE22 FC 6E                   	sub		sp,sp,#4
   2666 0000EE24 E0 DF                   	sw		lr,[sp]
   2667 0000EE26 E2 D1                   	sw		r1,2[sp]
   2668 0000EE28 2F AF                   	call	IGNBLK		; ignore leading blanks
   2669 0000EE2A E0 FF                   	lw		lr,[sp]	; get the return address
   2670 0000EE2C F0 E3                   	lb		r3,[lr]	; get the byte to compare
   2671 0000EE2E 80 E1                   	lb		r1,[r8]
   2672 0000EE30 1D 23                   	cmp		r3,r1		; is it = to what r8 points to?
   2673 0000EE32 05 A8                   	beq		TC1			; if so
                                        						; If not, add the second
   2675 0000EE34 F1 E3                   	lb		r3,1[lr]	; byte following the call to
   2676 0000EE36 30 2F                   	add		lr,r3		; the return address.
   2677 0000EE38 E2 F1                   	lw		r1,2[sp]
   2678 0000EE3A 04 6E                   	add		sp,sp,#4
   2679 0000EE3C F0 80                   	ret					; jump to the routine
   2680 0000EE3E                        TC1
   2681 0000EE3E 01 68                   	add		r8,r8,#1	; if equal, bump text pointer
   2682 0000EE40 E2 F1                   	lw		r1,2[sp]
   2683 0000EE42 04 6E                   	add     sp,sp,#4
   2684 0000EE44 F2 80                   	jmp		2[lr]		; Skip the 2 bytes following
                                        						; the call and continue.
                                        
                                        
                                        ; ===== See if the text pointed to by r8 is a number. If so,
                                        ;	return the number in r2 and the number of digits in r3,
                                        ;	else return zero in r2 and r3.
                                        ; Registers Affected
                                        ;   r1,r2,r3,r4
                                        ; Returns
                                        ; 	r1 = number
                                        ;	r2 = number of digits in number
                                        ;	r8 = updated text pointer
                                        ;
   2698 0000EE46                        TSTNUM
   2699 0000EE46 FE 6E                   	sub		sp,sp,#2
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 46
noc_boot31.a
   2700 0000EE48 E0 DF                   	sw		lr,[sp]
   2701 0000EE4A 1E AF                   	call	IGNBLK		; skip over blanks
   2702 0000EE4C 00 11                   	lw		r1,#0		; initialize return parameters
   2703 0000EE4E 00 12                   	lw		r2,#0
   2704 0000EE50                        TN1
   2705 0000EE50 80 E3                   	lb		r3,[r8]
   2706 0000EE52 FD 4F 30 10             	cmp		r3,#'0'		; is it less than zero?
   2707 0000EE56 15 A4                   	bltu	TSNMRET 	; if so, that's all
   2708 0000EE58 FC 4F 37 10             	cmp		r3,#'9'		; is it greater than nine?
   2709 0000EE5C 12 A7                   	bgtu	TSNMRET 	; if so, return
   2710 0000EE5E 33 43 14 10             	cmp		r1,#214748364	; see if there's room for new digit
   2711 0000EE62 04 A6                   	bleu	TN2
   2712 0000EE64 13 4F 0D 11             	lea		r1,msgNumTooBig
   2713 0000EE68 E3 4F 07 AE             	br		ERROR		; if not, we've overflowd
   2714 0000EE6C                        TN2
   2715 0000EE6C 10 14                   	lw		r4,r1		; quickly multiply result by 10
   2716 0000EE6E 81 31                   	shl		r1,#1		; * 2
   2717 0000EE70 81 31                   	shl		r1,#1		; * 4
   2718 0000EE72 40 21                   	add		r1,r4		; * 5
   2719 0000EE74 81 31                   	shl		r1,#1		; * 10
   2720 0000EE76 01 68                   	add		r8,r8,#1	; adjust text pointer
   2721 0000EE78 00 40 5F 33             	and		r3,#0xF		; add in the new digit
   2722 0000EE7C 30 21                   	add		r1,r3
   2723 0000EE7E 01 62                   	add		r2,r2,#1	; increment the no. of digits
   2724 0000EE80 E7 BE                   	br		TN1
   2725 0000EE82                        TSNMRET
   2726 0000EE82 E0 FF                   	lw		lr,[sp]
   2727 0000EE84 02 6E                   	add		sp,sp,#2
   2728 0000EE86 F0 80                   	ret
                                        
                                        
                                        ;===== Skip over blanks in the text pointed to by r8.
                                        ;
                                        ; Registers Affected:
                                        ;	r8
                                        ; Returns
                                        ;	r8 = pointer updateded past any spaces or tabs
                                        ;
   2738 0000EE88                        IGNBLK
   2739 0000EE88 FE 6E                   	sub		sp,sp,#2
   2740 0000EE8A E0 D1                   	sw		r1,[sp]
   2741 0000EE8C                        IGB2
   2742 0000EE8C 80 E1                   	lb		r1,[r8]			; get char
   2743 0000EE8E FE 4F 10 10             	cmp		r1,#' '			; see if it's a space
   2744 0000EE92 03 A8                   	beq		IGB1			; if so, swallow it
   2745 0000EE94 FF 4F 17 10             	cmp		r1,#'\t'		; or a tab
   2746 0000EE98 02 A9                   	bne		IGBRET
   2747 0000EE9A                        IGB1
   2748 0000EE9A 01 68                   	add		r8,r8,#1		; increment the text pointer
   2749 0000EE9C F7 BE                   	br		IGB2
   2750 0000EE9E                        IGBRET
   2751 0000EE9E E0 F1                   	lw		r1,[sp]
   2752 0000EEA0 02 6E                   	add		sp,sp,#2
   2753 0000EEA2 F0 80                   	ret
                                        
                                        
                                        ; ===== Convert the line of text in the input buffer to upper
                                        ;	case (except for stuff between quotes).
                                        ;
                                        ; Registers Affected
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 47
noc_boot31.a
                                        ;   r1,r3
                                        ; Returns
                                        ;	r8 = pointing to end of text in buffer
                                        ;
   2764 0000EEA4                        TOUPBUF
   2765 0000EEA4 FE 6E                   	sub		sp,sp,#2
   2766 0000EEA6 E0 DF                   	sw		lr,[sp]
   2767 0000EEA8 0A 40 0E 18             	lea		r8,BUFFER	; set up text pointer
   2768 0000EEAC 00 13                   	lw		r3,#0		; clear quote flag
   2769 0000EEAE                        TOUPB1
   2770 0000EEAE 80 E1                   	lb		r1,[r8]		; get the next text char.
   2771 0000EEB0 01 68                   	add		r8,r8,#1
   2772 0000EEB2 FF 4F 13 10             	cmp		r1,#CR		; is it end of line?
   2773 0000EEB6 13 A8                   	beq		TOUPBRT 	; if so, return
   2774 0000EEB8 FD 4F 1E 10             	cmp		r1,#'"'		; a double quote?
   2775 0000EEBC 08 A8                   	beq		DOQUO
   2776 0000EEBE FD 4F 19 10             	cmp		r1,#''''	; or a single quote?
   2777 0000EEC2 05 A8                   	beq		DOQUO
   2778 0000EEC4 30 10                   	cmp		r3,#0		; inside quotes?
   2779 0000EEC6 F3 B9                   	bne		TOUPB1		; if so, do the next one
   2780 0000EEC8 0D AF                   	call	toUpper 	; convert to upper case
   2781 0000EECA 8F C1                   	sb		r1,-1[r8]	; store it
   2782 0000EECC F0 BE                   	br		TOUPB1		; and go back for more
   2783 0000EECE                        DOQUO
   2784 0000EECE 30 10                   	cmp		r3,#0		; are we inside quotes?
   2785 0000EED0 02 A9                   	bne		DOQUO1
   2786 0000EED2 10 13                   	lw		r3,r1		; if not, toggle inside-quotes flag
   2787 0000EED4 EC BE                   	br		TOUPB1
   2788 0000EED6                        DOQUO1
   2789 0000EED6 1D 23                   	cmp		r3,r1		; make sure we're ending proper quote
   2790 0000EED8 EA B9                   	bne		TOUPB1		; if not, ignore it
   2791 0000EEDA 00 13                   	lw		r3,#0		; else clear quote flag
   2792 0000EEDC E8 BE                   	br		TOUPB1
   2793 0000EEDE                        TOUPBRT
   2794 0000EEDE E0 FF                   	lw		lr,[sp]
   2795 0000EEE0 02 6E                   	add		sp,sp,#2
   2796 0000EEE2 F0 80                   	ret
                                        
                                        
                                        ; ===== Convert the character in r1 to upper case
                                        ;
   2801 0000EEE4                        toUpper
   2802 0000EEE4 F9 4F 1F 10             	cmp		r1,#'a'		; is it < 'a'?
   2803 0000EEE8 04 A0                   	blt	    TOUPRET
   2804 0000EEEA F8 4F 16 10             	cmp		r1,#'z'		; or > 'z'?
   2805 0000EEEE 01 A3                   	bgt	    TOUPRET
   2806 0000EEF0 E0 61                   	sub		r1,r1,#32	; if not, make it upper case
   2807 0000EEF2                        TOUPRET
   2808 0000EEF2 F0 80                   	ret
                                        
                                        
                                        ; 'CHKIO' checks the input. If there's no input, it will return
                                        ; to the caller with the Z flag set. If there is input, the Z
                                        ; flag is cleared and the input byte is in r2. However, if a
                                        ; control-C is read, 'CHKIO' will warm-start BASIC and will not
                                        ; return to the caller.
                                        ;
   2817 0000EEF4                        CHKIO
   2818 0000EEF4 FE 6E                   	sub		sp,sp,#2	; save link reg
   2819 0000EEF6 E0 DF                   	sw		lr,[sp]
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 48
noc_boot31.a
   2820 0000EEF8 8D 4F 0B AF             	call	GOIN		; get input if possible
   2821 0000EEFC 07 A8                   	beq		CHKRET2		; if Zero, no input
   2822 0000EEFE 1D 10                   	cmp		r1,#CTRLC	; is it control-C?
   2823 0000EF00 02 A9                   	bne		CHKRET		; if not
   2824 0000EF02 8F 4F 0A AE             	jmp		WSTART		; if so, do a warm start
   2825 0000EF06                        CHKRET
   2826 0000EF06 E0 FF                   	lw		lr,[sp]
   2827 0000EF08 02 6E                   	add		sp,sp,#2	; Z=0
   2828 0000EF0A F0 80                   	ret
   2829 0000EF0C                        CHKRET2
   2830 0000EF0C E0 FF                   	lw		lr,[sp]
   2831 0000EF0E 02 6E                   	add		sp,sp,#2
   2832 0000EF10 00 11                   	lw		r1,#0		; Z=1
   2833 0000EF12 F0 80                   	ret
                                        
                                        
                                        ; ===== Display a CR-LF sequence
                                        ;
   2838 0000EF14                        CRLF
   2839 0000EF14 11 4F 0F 11             	lea		r1,CLMSG
                                        
                                        
                                        ; ===== Display a zero-ended string pointed to by register r1
                                        ; Registers Affected
                                        ;   r1,r2,r4
                                        ;
   2846 0000EF18                        PRMESG
   2847 0000EF18 FC 6E                   	sub		sp,sp,#4
   2848 0000EF1A E0 DF                   	sw		lr,[sp]
   2849 0000EF1C E2 D5                   	sw		r5,2[sp]
   2850 0000EF1E 10 15                   	lw      r5,r1       ; r5 = pointer to message
   2851 0000EF20                        PRMESG1
   2852 0000EF20 01 65                   	add		r5,r5,#1
   2853 0000EF22 5F E1                   	lb		r1,-1[r5]	; 	get the char.
   2854 0000EF24 03 A8                   	beq		PRMRET
   2855 0000EF26 8C 4F 02 AF             	call	GOOUT		;else display it trashes r4
   2856 0000EF2A FA BE                   	br		PRMESG1
   2857 0000EF2C                        PRMRET
   2858 0000EF2C 50 11                   	lw		r1,r5
   2859 0000EF2E E2 F5                   	lw		r5,2[sp]
   2860 0000EF30 E0 FF                   	lw		lr,[sp]
   2861 0000EF32 04 6E                   	add		sp,sp,#4
   2862 0000EF34 F0 80                   	ret
                                        
                                        
                                        ; ===== Display a zero-ended string pointed to by register r1
                                        ; Registers Affected
                                        ;   r1,r2,r3
                                        ;
   2869 0000EF36                        PRMESGAUX
   2870 0000EF36 FC 6E                   	sub		sp,sp,#4
   2871 0000EF38 E0 DF                   	sw		lr,[sp]
   2872 0000EF3A E2 D5                   	sw		r5,2[sp]
   2873 0000EF3C 10 15                   	lw      r5,r1       ; r3 = pointer
   2874 0000EF3E                        PRMESGA1
   2875 0000EF3E 01 65                   	add		r5,r5,#1
   2876 0000EF40 5F E1                   	lb		r1,-1[r5]	; 	get the char.
   2877 0000EF42 03 A8                   	beq		PRMRETA
   2878 0000EF44 8B 4F 07 AF             	call	GOAUXO		;else display it
   2879 0000EF48 FA BE                   	br		PRMESGA1
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 49
noc_boot31.a
   2880 0000EF4A                        PRMRETA
   2881 0000EF4A 50 11                   	lw		r1,r5
   2882 0000EF4C E2 F5                   	lw		r5,2[sp]
   2883 0000EF4E E0 FF                   	lw		lr,[sp]
   2884 0000EF50 04 6E                   	add		sp,sp,#4
   2885 0000EF52 F0 80                   	ret
                                        
                                        ;*****************************************************
                                        ; The following routines are the only ones that need *
                                        ; to be changed for a different I/O environment.     *
                                        ;*****************************************************
                                        
                                        
                                        ; ===== Output character to the console (Port 1) from register D0
                                        ;	(Preserves all registers.)
                                        ;
   2896 0000EF54                        OUTC
   2897 0000EF54 FF BE                   	jmp		_putChar
                                        
                                        
                                        ; ===== Input a character from the console into register D0 (or
                                        ;	return Zero status if there's no character available).
                                        ;
   2903 0000EF56                        INC
   2904 0000EF56 FE 6E                   	add		sp,sp,#-2
   2905 0000EF58 E0 DF                   	sw		lr,[sp]
   2906 0000EF5A 01 4B 00 E1             	lb		r1,ROUTER+RTR_RXSTAT
   2907 0000EF5E 04 A8                   	beq		INC1
   2908 0000EF60 88 4F 0E AF             	call	Recv
   2909 0000EF64 1B 40 08 AF             	call	RecvDispatch
   2910 0000EF68                        INC1
                                        ; get char from keyboard
                                        ; returns char in r1
   2913 0000EF68                        _getChar
   2914 0000EF68 C5 4D 02 E1             	lb		r1,KBD+2	; get keyboard strobe
   2915 0000EF6C 08 AB                   	bpl		gc1
   2916 0000EF6E C5 4D 00 E1             	lb		r1,KBD		; get character and clear keyboard strobe
   2917 0000EF72 05 AA                   	bmi		gc1			; was it a keyup event ? (ignore)
   2918 0000EF74 07 40 5F 31             	and		r1,#0x7f
   2919 0000EF78 E0 FF                   	lw		lr,[sp]
   2920 0000EF7A 02 6E                   	add		sp,sp,#2
   2921 0000EF7C F0 80                   	ret
   2922 0000EF7E                        gc1
   2923 0000EF7E E0 FF                   	lw		lr,[sp]
   2924 0000EF80 02 6E                   	add		sp,sp,#2
   2925 0000EF82 00 11                   	lw		r1,#0		; return Z=1 (no character)
   2926 0000EF84 F0 80                   	ret
                                        
                                        
                                        ; get char from keyboard
                                        ; returns char in r1
   2931 0000EF86                        _getCharWait
   2932 0000EF86                        gc2
   2933 0000EF86 C5 4D 02 E1             	lb		r1,KBD+2	; get keyboard strobe
   2934 0000EF8A FD BB                   	bpl		gc2
   2935 0000EF8C C5 4D 00 E1             	lb		r1,KBD		; get character and clear keyboard strobe
   2936 0000EF90 FA BA                   	bmi		gc2			; was it a keyup event ? (ignore)
   2937 0000EF92 07 40 5F 31             	and		r1,#0x7f
   2938 0000EF96 F0 80                   	ret
                                        
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 50
noc_boot31.a
                                        
                                        ; Trigger a load operation on the target node.
                                        
   2943 0000EF98                        TriggerTgtLoad:
   2944 0000EF98 83 4F 02 AF             	call	zeroTxBuf
   2945 0000EF9C 03 40 06 E2             	lb		r2,tgtNode
   2946 0000EFA0 02 40 0F C2             	sb		r2,txBuf+MSG_DST
   2947 0000EFA4 01 40 01 12             	lw		r2,#$11
   2948 0000EFA8 02 40 0E C2             	sb		r2,txBuf+MSG_SRC
   2949 0000EFAC 0A 12                   	lw		r2,#10				; trigger load on target node
   2950 0000EFAE 02 40 08 C2             	sb		r2,txBuf+MSG_TYPE
   2951 0000EFB2 85 4F 00 AF             	call	Xmit
   2952 0000EFB6 E2 F2                   	lw		r2,2[sp]
   2953 0000EFB8 E0 FF                   	lw		lr,[sp]
   2954 0000EFBA F0 80                   	ret
                                        
                                        ; ===== Output character to the host (Port 2) from register r1
                                        ;	(Preserves all registers.)
                                        ;
   2959 0000EFBC                        AUXOUT
   2960 0000EFBC FC 6E                   	add		sp,sp,#-4
   2961 0000EFBE E0 DF                   	sw		lr,[sp]
   2962 0000EFC0 E2 D2                   	sw		r2,2[sp]
   2963 0000EFC2 03 40 06 E2             	lb		r2,tgtNode
                                        	cmp		#$11
   2965 0000EFC6 05 A9                   	bne		auxout1
   2966 0000EFC8 41 48 0F AF             	call	putSerial	; call boot rom routine
   2967 0000EFCC E2 F2                   	lw		r2,2[sp]
   2968 0000EFCE E0 FF                   	lw		lr,[sp]
   2969 0000EFD0 F0 80                   	ret
   2970 0000EFD2                        auxout1:
   2971 0000EFD2 81 4F 05 AF             	call	zeroTxBuf
   2972 0000EFD6 02 40 00 C1             	sb		r1,txBuf
   2973 0000EFDA 03 40 06 E2             	lb		r2,tgtNode
   2974 0000EFDE 02 40 0F C2             	sb		r2,txBuf+MSG_DST
   2975 0000EFE2 01 40 01 12             	lw		r2,#$11
   2976 0000EFE6 02 40 0E C2             	sb		r2,txBuf+MSG_SRC
   2977 0000EFEA 0B 12                   	lw		r2,#11				; recieve BASIC program char
   2978 0000EFEC 02 40 08 C2             	sb		r2,txBuf+MSG_TYPE
   2979 0000EFF0 83 4F 01 AF             	call	Xmit
   2980 0000EFF4 E2 F2                   	lw		r2,2[sp]
   2981 0000EFF6 E0 FF                   	lw		lr,[sp]
   2982 0000EFF8 F0 80                   	ret
                                        ;
                                        ; ===== Input a character from the host into register D0 (or
                                        ;	return negative status if there's no character available).
                                        ;
   2987 0000EFFA                        AUXIN
                                        ; get character from serial port
                                        ; return  N=1 if no character available
   2990 0000EFFA 40 48 04 AE             	jmp		peekSerial
                                        
                                        
   2993 0000EFFE                        _scrollScreen
   2994 0000EFFE FC 6E                   	sub		sp,sp,#4
   2995 0000F000 E0 D5                   	sw		r5,[sp]
   2996 0000F002 60 40 00 13             	lw		r3,#1536	; number of chars to move - 1
   2997 0000F006 00 42 00 12             	lw		r2,#VIDEORAM
   2998 0000F00A 03 40 00 E1             	lb		r1,txtWidth
   2999 0000F00E 81 31                   	shl		r1,#1
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 51
noc_boot31.a
   3000 0000F010 81 31                   	shl		r1,#1
   3001 0000F012                        ss1:
   3002 0000F012 20 15                   	lw		r5,r2
   3003 0000F014 10 25                   	add		r5,r1
   3004 0000F016 50 F4                   	lw		r4,[r5]		; char at next line
   3005 0000F018 20 D4                   	sw		r4,[r2]		; goes to this line
   3006 0000F01A 04 62                   	add		r2,r2,#4
   3007 0000F01C FF 63                   	sub		r3,r3,#1
   3008 0000F01E F9 B9                   	bne     ss1
                                        	; blank out last line
   3010 0000F020 02 40 00 13             	lw		r3,#' '
   3011 0000F024 03 40 08 D3             	sh		r3,charToPrint
   3012 0000F028 03 40 00 E3             	lb		r3,txtWidth
   3013 0000F02C 03 40 08 F4             	lw		r4,charToPrint	; and colors
   3014 0000F030                        ss2
   3015 0000F030 20 D4                   	sw		r4,[r2]
   3016 0000F032 04 62                   	add		r2,r2,#4
   3017 0000F034 FF 63                   	sub		r3,r3,#1
   3018 0000F036 FC B9                   	bne     ss2
   3019 0000F038 E0 F5                   	lw		r5,[sp]
   3020 0000F03A 04 6E                   	add		sp,sp,#4
   3021 0000F03C F0 80                   	ret
                                        
                                        
                                        ; flash the character at the screen position
                                        ;   r1: 1 = flash, 0 = no flash
   3026 0000F03E                        _flashCursor
   3027 0000F03E 00 42 00 12             	lw		r2,#VIDEORAM
   3028 0000F042 03 40 04 F3             	lh		r3,pos
   3029 0000F046 81 33                   	shl		r3,#1
   3030 0000F048 81 33                   	shl		r3,#1
   3031 0000F04A 20 23                   	add		r3,r2		; r3 = scr[pos]
                                        
   3033 0000F04C 16 21                   	or		r1,r1
   3034 0000F04E 04 A8                   	beq		fc1
   3035 0000F050 33 E2                   	lb		r2,3[r3]	; get background color
   3036 0000F052 08 40 60 32             	or		r2,#0x80	; set flash indicator
   3037 0000F056 03 AE                   	br		fcx
   3038 0000F058                        fc1
   3039 0000F058 33 E2                   	lb		r2,3[r3]	; get background color
   3040 0000F05A 07 40 5F 32             	and		r2,#0x7f	; clear flash indicator
   3041 0000F05E                        fcx:
   3042 0000F05E 33 C2                   	sb		r2,3[r3]
   3043 0000F060 F0 80                   	ret
                                        
                                        
                                        ; ===== Return to the resident monitor, operating system, etc.
                                        ;
   3048 0000F062                        BYEBYE
   3049 0000F062 08 40 04 FE             	lw		sp,OSSP
   3050 0000F066 E0 FF                       lw      lr,[sp]
   3051 0000F068 02 6E                       add		sp,sp,#2
   3052 0000F06A F0 80                   	ret
                                        
                                        ; Set the message address fields
                                        
   3056 0000F06C                        SetMsgAddr:
   3057 0000F06C E4 31                   	tsr		r1,ID
   3058 0000F06E 02 40 0E C1             	sb		r1,txBuf+MSG_SRC
   3059 0000F072 01 40 01 11             	lw		r1,#$11
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 52
noc_boot31.a
   3060 0000F076 02 40 0F C1             	sb		r1,txBuf+MSG_DST
   3061 0000F07A F0 80                   	ret
                                        
   3063 0000F07C                        EXIT
   3064 0000F07C AE 4F 03 AF             	call	OREXPR
   3065 0000F080 7B 4F 0E AF             	call	zeroTxBuf
   3066 0000F084 02 40 00 D1             	sw		r1,txBuf
   3067 0000F088 F1 BF                   	call	SetMsgAddr
   3068 0000F08A 00 40 0D 11             	lw		r1,#MT_BASIC_EXIT
   3069 0000F08E 02 40 08 C1             	sb		r1,txBuf+MSG_TYPE
   3070 0000F092 7E 4F 00 AF             	call	Xmit
   3071 0000F096 83 4F 00 AE             	jmp		WSTART
                                        
   3073 0000F09A                        RequestOutputFocus:
   3074 0000F09A FE 6E                   	add		sp,sp,#-2
   3075 0000F09C E0 DF                   	sw		lr,[sp]
   3076 0000F09E 7A 4F 0F AF             	call	zeroTxBuf
   3077 0000F0A2 E4 BF                   	call	SetMsgAddr
   3078 0000F0A4 00 40 0F 11             	lw		r1,#MT_REQ_OUT_FOCUS
   3079 0000F0A8 02 40 08 C1             	sb		r1,txBuf+MSG_TYPE
   3080 0000F0AC 7D 4F 03 AF             	call	Xmit
   3081 0000F0B0                        ROF1:
   3082 0000F0B0 01 4B 00 E1             	lb		r1,ROUTER+RTR_RXSTAT
   3083 0000F0B4 FD B8                   	beq		ROF1
   3084 0000F0B6 7E 4F 03 AF             	call	Recv
   3085 0000F0BA 10 40 0D AF             	call	RecvDispatch
   3086 0000F0BE 03 40 08 E1             	lb		r1,rxBuf+MSG_TYPE
   3087 0000F0C2 FF 4F 10 10             	cmp		r1,#MT_GRNT_OUT_FOCUS
   3088 0000F0C6 F4 B9                   	bne		ROF1
   3089 0000F0C8 E0 FF                   	lw		lr,[sp]
   3090 0000F0CA 02 6E                   	add		sp,sp,#2
   3091 0000F0CC F0 80                   	ret
                                        
                                        ;	MOVE.B	#228,D7 	return to Tutor
                                        ;	TRAP	#14
                                        
   3096 0000F0CE 0D 0A 42 75 74 74      msgInit db	CR,LF,"Butterfly Tiny BASIC v1.1",CR,LF,"(C) 2005-2017  Robert Finch",CR,LF,LF,0
   3096 0000F0D4 65 72 66 6C 79 20 54  
   3096 0000F0DB 69 6E 79 20 42 41 53  
   3096 0000F0E2 49 43 20 76 31 2E 31  
   3096 0000F0E9 0D 0A 28 43 29 20 32  
   3096 0000F0F0 30 30 35 2D 32 30 31  
   3096 0000F0F7 37 20 20 52 6F 62 65  
   3096 0000F0FE 72 74 20 46 69 6E 63  
   3096 0000F105 68 0D 0A 0A 00        
   3097 0000F10A 0D 0A 4F 4B 0D 0A      OKMSG	db	CR,LF,"OK",CR,LF,0
   3097 0000F110 00                    
   3098 0000F111 57 68 61 74 3F 0D      msgWhat	db	"What?",CR,LF,0
   3098 0000F117 0A 00                 
   3099 0000F119 53 6F 72 72 79 2E      SRYMSG	db	"Sorry."
                                      
   3100 0000F11F 0D 0A 00               CLMSG	db	CR,LF,0
   3101 0000F122 43 6F 6D 70 61 63      msgReadError	db	"Compact FLASH read error",CR,LF,0
   3101 0000F128 74 20 46 4C 41 53 48  
   3101 0000F12F 20 72 65 61 64 20 65  
   3101 0000F136 72 72 6F 72 0D 0A 00  
                                      
   3102 0000F13D 4E 75 6D 62 65 72      msgNumTooBig	db	"Number is too big",CR,LF,0
   3102 0000F143 20 69 73 20 74 6F 6F  
   3102 0000F14A 20 62 69 67 0D 0A 00  
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 53
noc_boot31.a
                                      
   3103 0000F151 44 69 76 69 73 69      msgDivZero		db	"Division by zero",CR,LF,0
   3103 0000F157 6F 6E 20 62 79 20 7A  
   3103 0000F15E 65 72 6F 0D 0A 00     
   3104 0000F164 4F 75 74 20 6F 66      msgVarSpace     db  "Out of variable space",CR,LF,0
   3104 0000F16A 20 76 61 72 69 61 62  
   3104 0000F171 6C 65 20 73 70 61 63  
   3104 0000F178 65 0D 0A 00           
   3105 0000F17C 20 62 79 74 65 73      msgBytesFree	db	" bytes free",CR,LF,0
   3105 0000F182 20 66 72 65 65 0D 0A  
   3105 0000F189 00                    
   3106 0000F18A 0D 0A 52 65 61 64      msgReady		db	CR,LF,"Ready",CR,LF,0
   3106 0000F190 79 0D 0A 00           
   3107 0000F194 45 78 70 65 63 74      msgComma		db	"Expecting a comma",CR,LF,0
   3107 0000F19A 69 6E 67 20 61 20 63  
   3107 0000F1A1 6F 6D 6D 61 0D 0A 00  
                                      
   3108 0000F1A8 4C 69 6E 65 20 6E      msgLineRange	db	"Line number too big",CR,LF,0
   3108 0000F1AE 75 6D 62 65 72 20 74  
   3108 0000F1B5 6F 6F 20 62 69 67 0D  
   3108 0000F1BC 0A 00                 
   3109 0000F1BE 45 78 70 65 63 74      msgVar			db	"Expecting a variable",CR,LF,0
   3109 0000F1C4 69 6E 67 20 61 20 76  
   3109 0000F1CB 61 72 69 61 62 6C 65  
   3109 0000F1D2 0D 0A 00              
   3110 0000F1D5 52 4E 44 20 62 61      msgRNDBad		db	"RND bad parameter",CR,LF,0
   3110 0000F1DB 64 20 70 61 72 61 6D  
   3110 0000F1E2 65 74 65 72 0D 0A 00  
                                      
   3111 0000F1E9 53 59 53 20 62 61      msgSYSBad		db	"SYS bad address",CR,LF,0
   3111 0000F1EF 64 20 61 64 64 72 65  
   3111 0000F1F6 73 73 0D 0A 00        
   3112 0000F1FB 49 4E 50 55 54 20      msgInputVar		db	"INPUT expecting a variable",CR,LF,0
   3112 0000F201 65 78 70 65 63 74 69  
   3112 0000F208 6E 67 20 61 20 76 61  
   3112 0000F20F 72 69 61 62 6C 65 0D  
   3112 0000F216 0A 00                 
   3113 0000F218 4E 45 58 54 20 77      msgNextFor		db	"NEXT without FOR",CR,LF,0
   3113 0000F21E 69 74 68 6F 75 74 20  
   3113 0000F225 46 4F 52 0D 0A 00     
   3114 0000F22B 4E 45 58 54 20 65      msgNextVar		db	"NEXT expecting a defined variable",CR,LF,0
   3114 0000F231 78 70 65 63 74 69 6E  
   3114 0000F238 67 20 61 20 64 65 66  
   3114 0000F23F 69 6E 65 64 20 76 61  
   3114 0000F246 72 69 61 62 6C 65 0D  
   3114 0000F24D 0A 00                 
   3115 0000F24F 47 4F 54 4F 2F 47      msgBadGotoGosub	db	"GOTO/GOSUB bad line number",CR,LF,0
   3115 0000F255 4F 53 55 42 20 62 61  
   3115 0000F25C 64 20 6C 69 6E 65 20  
   3115 0000F263 6E 75 6D 62 65 72 0D  
   3115 0000F26A 0A 00                 
   3116 0000F26C 52 45 54 55 52 4E      msgRetWoGosub   db	"RETURN without GOSUB",CR,LF,0
   3116 0000F272 20 77 69 74 68 6F 75  
   3116 0000F279 74 20 47 4F 53 55 42  
   3116 0000F280 0D 0A 00              
   3117 0000F283 50 72 6F 67 72 61      msgTooBig		db	"Program is too big",CR,LF,0
   3117 0000F289 6D 20 69 73 20 74 6F  
   3117 0000F290 6F 20 62 69 67 0D 0A  
   3117 0000F297 00                    
   3118 0000F298 45 78 74 72 61 20      msgExtraChars	db	"Extra characters on line ignored",CR,LF,0
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 54
noc_boot31.a
   3118 0000F29E 63 68 61 72 61 63 74  
   3118 0000F2A5 65 72 73 20 6F 6E 20  
   3118 0000F2AC 6C 69 6E 65 20 69 67  
   3118 0000F2B3 6E 6F 72 65 64 0D 0A  
   3118 0000F2BA 00                    
                                        
   3120 0000F2BB FF                      	.align	4
   3187 = 0000F2BC                      LSTROM	equ	*		; end of possible ROM area
                                        ;
                                        ; Internal variables follow:
                                        ;
                                        		bss
                                        		org		0x0030
   3127 00000030                        txtWidth	db	0		; BIOS var =60
   3128 00000031                        txtHeight	db	0		; BIOS var =27
   3129 00000032                        cursx	db		0		; cursor x position
   3130 00000033                        cursy	db		0		; cursor y position
   3131 00000034                        pos		dw		0		; text screen position
   3132 00000036                        tgtNode	db		0
   3133 00000037                        srcNode	db		0
                                        		org		0x0038
   3135 00000038                        charToPrint		dw		0
   3136 0000003A                        fgColor			db		0
   3137 0000003B                        bkColor			db		0
   3138 0000003C                        cursFlash		db		0	; flash the cursor ?
   3139 0000003D                         				db		0
   3140 0000003E                        NormAttr		dw		0
                                        
   3142 00000040                        lineLinkTbl		fill.b	25,0	; screen line link table
   3143 00000059                         	align 4
                                        
                                        		org		0x0080
   3146 00000080                        typef   db      0   ; variable / expression type
   3147 00000081                                 align   4
   3148 00000084                        OSSP	dw	1	; OS value of sp
   3149 00000086                        CURRNT	dw	1	;	Current line pointer
   3150 00000088                        STKGOS	dw	1	;	Saves stack pointer in 'GOSUB'
   3151 0000008A                        STKINP	dw	1	;	Saves stack pointer during 'INPUT'
   3152 0000008C                        LOPVAR	dw	1	;	'FOR' loop save area
   3153 0000008E                        LOPINC	dw	1	;	increment
   3154 00000090                        LOPLMT	dw	1	;	limit
   3155 00000092                        LOPLN	dw	1	;	line number
   3156 00000094                        LOPPT	dw	1	;	text pointer
   3157 00000096                        TXTUNF	dw	1	;	points to unfilled text area
   3158 00000098                        VARBGN	dw	1	;	points to variable area
   3159 0000009A                        IVARBGN dw  1   ;   points to integer variable area
   3160 0000009C                        SVARBGN dw  1   ;   points to string variable area
   3161 0000009E                        FVARBGN dw  1   ;   points to float variable area
   3162 000000A0                        STKBOT	dw	1	;	holds lower limit for stack growth
   3163 000000A2                        NUMWKA	fill.b	12,0			; numeric work area
   3164 000000AE                        BUFFER	fill.b	BUFLEN,0x00		;		Keyboard input buffer
                                        
                                                bss
                                                org     0x2000
   3168 00002000                        textScr1
                                                org     0x2000
                                        ;	END
                                        
                                        ; Operation of an ordinary (worker) node is pretty simple. It just waits in
                                        ; loop polling for recieved messages which are then dispatched.
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 55
noc_boot31.a
                                        
                                        		.code
   3176 0000F2BC                        start:
   3177 0000F2BC FF 41 0E 1E             		lw		sp,#$1FFE
   3178 0000F2C0 66 AF                   		call	ethInit
   3179 0000F2C2                        noMsg1:
   3180 0000F2C2 CE AF                   		call	ethPoll
   3181 0000F2C4 01 4B 00 E1             		lb		r1,ROUTER+RTR_RXSTAT
   3182 0000F2C8 03 40 5F 31             		and		r1,#63
   3183 0000F2CC FA B8                   		beq		noMsg1
   3184 0000F2CE 6D 4F 07 AF             		call	Recv
   3185 0000F2D2 02 AF                   		call	RecvDispatch
   3186 0000F2D4 F3 BE                   		bra		start
   3187 0000F2D6                        lockup:
   3188 0000F2D6 FF BE                   		bra		lockup
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Receiver dispatch
                                        ;
                                        ; Executes different message handlers based on the message type.
                                        ;----------------------------------------------------------------------------
                                        
   3196 0000F2D8                        RecvDispatch:
   3197 0000F2D8 FC 6E                   		add		sp,sp,#-4
   3198 0000F2DA E0 DF                   		sw		lr,[sp]
   3199 0000F2DC E2 D1                   		sw		r1,2[sp]
   3200 0000F2DE 03 40 08 E1             		lb		r1,rxBuf+MSG_TYPE
   3201 0000F2E2 1F 10                   		cmp		r1,#MT_RST			; reset message ?
   3202 0000F2E4 0C A9                   		bne		RecvDispatch2
                                        		; Send back a reset ACK message to indicate node is good to go.
   3204 0000F2E6 68 4F 0B AF             		call	zeroTxBuf
   3205 0000F2EA 01 40 01 11             		lw		r1,#$11
   3206 0000F2EE 02 40 0F C1             		sb		r1,txBuf+MSG_DST
   3207 0000F2F2 02 11                   		lw		r1,#MT_RST_ACK
   3208 0000F2F4 02 40 08 C1             		sb		r1,txBuf+MSG_TYPE
   3209 0000F2F8 6A 4F 0D AF             		call	Xmit
   3210 0000F2FC 44 AE                   		br		RecvDispatch5
   3211 0000F2FE                        RecvDispatch2:
   3212 0000F2FE FF 4F 17 10             		cmp		r1,#MT_PING
   3213 0000F302 0D A9                   		bne		RecvDispatch9
   3214 0000F304 67 4F 0C AF             		call	zeroTxBuf
   3215 0000F308 03 40 0E E1             		lb		r1,rxBuf+MSG_SRC
   3216 0000F30C 02 40 0F C1             		sb		r1,txBuf+MSG_DST
   3217 0000F310 01 40 02 11             		lw		r1,#MT_PING_ACK
   3218 0000F314 02 40 08 C1             		sb		r1,txBuf+MSG_TYPE
   3219 0000F318 69 4F 0D AF             		call	Xmit
   3220 0000F31C 34 AE                   		br		RecvDispatchXit
   3221 0000F31E                        RecvDispatch9:
   3222 0000F31E FF 4F 16 10             		cmp		r1,#MT_START_BASIC_LOAD	; start BASIC load
   3223 0000F322 07 A9                   		bne		RecvDispatch3
   3224 0000F324 03 40 0E E1             		lb		r1,rxBuf+MSG_SRC
   3225 0000F328 6C 4F 0D AF             		call	INITTBW
   3226 0000F32C 0C 4E 02 F8             		lw		r8,TXTBGN			; r8 = text begin
   3227 0000F330 2A AE                   		br		RecvDispatch5
   3228 0000F332                        RecvDispatch3:
   3229 0000F332 FF 4F 15 10             		cmp		r1,#MT_LOAD_BASIC_CHAR	; load BASIC program char
   3230 0000F336 0D A9                   		bne		RecvDispatch4
   3231 0000F338 03 40 00 F1             		lw		r1,rxBuf
   3232 0000F33C 80 D1                   		sw		r1,[r8]
   3233 0000F33E 03 40 02 F1             		lw		r1,rxBuf+2
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 56
noc_boot31.a
   3234 0000F342 82 D1                   		sw		r1,2[r8]
   3235 0000F344 03 40 04 F1             		lw		r1,rxBuf+4
   3236 0000F348 84 D1                   		sw		r1,4[r8]
   3237 0000F34A 06 68                   		add		r8,r8,#6
   3238 0000F34C 09 40 06 D8             		sw		r8,TXTUNF
   3239 0000F350 1A AE                   		br		RecvDispatch5
   3240 0000F352                        RecvDispatch4:
                                        		; Run a BASIC program by stuffing a 'RUN' command into the BASIC
                                        		; buffer.
   3243 0000F352 FF 4F 14 10             		cmp		r1,#MT_RUN_BASIC_PROG
   3244 0000F356 17 A9                   		bne		RecvDispatch5
   3245 0000F358 05 40 02 11             		lw		r1,#'R'
   3246 0000F35C 0A 40 0E C1             		sb		r1,BUFFER
   3247 0000F360 05 40 05 11             		lw		r1,#'U'
   3248 0000F364 0A 40 0F C1             		sb		r1,BUFFER+1
   3249 0000F368 04 40 0E 11             		lw		r1,#'N'
   3250 0000F36C 0B 40 00 C1             		sb		r1,BUFFER+2
   3251 0000F370 00 40 0D 11             		lw		r1,#13
   3252 0000F374 0B 40 01 C1             		sb		r1,BUFFER+3
   3253 0000F378 0B 40 02 C0             		sb		r0,BUFFER+4
   3254 0000F37C 0B 40 02 18             		lw		r8,#BUFFER+4
   3255 0000F380 6C 4F 06 AF             		call	ST3
   3256 0000F384 00 AE                   		br		RecvDispatch5
   3257 0000F386                        RecvDispatch5:
   3258 0000F386                        RecvDispatchXit:
   3259 0000F386 E0 FF                   		lw		lr,[sp]
   3260 0000F388 E2 F1                   		lw		r1,2[sp]
   3261 0000F38A 04 6E                   		add		sp,sp,#4
   3262 0000F38C F0 80                   		ret
                                        
                                        ;============================================================================
                                        ;============================================================================
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Initialize Ethernet controller.
                                        ;----------------------------------------------------------------------------
                                        
   3271 0000F38E                        ethInit:
   3272 0000F38E 00 4A 00 15             		lw		r5,#ETHERNET
   3273 0000F392 01 40 04 11             		lw		r1,#20				; MII clock divider (2.5MHz from 50MHz)
   3274 0000F396 02 40 58 D1             		sw		r1,ETH_MIIMODER[r5]	; 32 bit preamble
                                        
   3276 0000F39A 01 40 00 D0             		sw		r0,unique_id
                                        
                                        		; Set the MAC address
   3279 0000F39E 0F 40 0F 11             		lw		r1,#$00FF
   3280 0000F3A2 3A 4F 52 D1             		sw		r1,ETH_MAC_ADDR1[r5]
   3281 0000F3A6 EF 4E 00 11             		lw		r1,#$EEF0
   3282 0000F3AA 3A 4F 5C D1             		sw		r1,ETH_MAC_ADDR0+2[r5]
   3283 0000F3AE A4 4D 02 11             		lw		r1,#$DA42
   3284 0000F3B2 3B 4F 52 D1             		sw		r1,ETH_MAC_ADDR0[r5]
                                        
                                        		; Set the PHY address
   3287 0000F3B6 01 11                   		lw		r1,#1				; this spec'd according to board
   3288 0000F3B8 03 40 50 C1             		sb		r1,ETH_MIIADDRESS[r5]
   3289 0000F3BC 01 11                   		lw		r1,#1				; select BMSR (status register)
   3290 0000F3BE 03 40 51 C1             		sb		r1,ETH_MIIADDRESS+1[r5]
                                        		; MII should not be busy here, we haven't issued a command yet.
   3292 0000F3C2 03 40 5C F1            ethInit1:		
   3293 0000F3C6 52 31                   		and		r1,#2				; busy bit
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 57
noc_boot31.a
   3294 0000F3C8 FC B9                   		bne		ethInit1
                                        
   3296 0000F3CA 02 11                   		lw		r1,#2				; read status
   3297 0000F3CC 02 40 5C C1             		sb		r1,ETH_MIICOMMAND[r5]
   3298 0000F3D0                        ethInit4:
   3299 0000F3D0 04 11                   		lw		r1,#4
   3300 0000F3D2 10 40 01 12             		lw		r2,#$101				; auto-neg. advertise 100MBs full duplex
   3301 0000F3D6 30 AF                   		call	ethWriteMII
                                        
   3303 0000F3D8 00 11                   		lw		r1,#0					; perform software reset
   3304 0000F3DA 00 48 00 12             		lw		r2,#$8000
   3305 0000F3DE 2C AF                   		call	ethWriteMII
                                        
   3307 0000F3E0 04 11                   		lw		r1,#4
   3308 0000F3E2 10 40 01 12             		lw		r2,#$101				; auto-neg. advertise 100MBs full duplex
   3309 0000F3E6 28 AF                   		call	ethWriteMII
                                        
   3311 0000F3E8 00 11                   		lw		r1,#0					; select register #0 (BMCR)
   3312 0000F3EA 10 42 00 12             		lw		r2,#$2100				; select 100MBPs, full duplex
   3313 0000F3EE 24 AF                   		call	ethWriteMII
                                        
                                        		; For green ethernet
                                        		;
                                        		;	reg		data
                                        		;	31		$0003
                                        		;	25		$3247
                                        		;	16		$AC7C
                                        		;	31		$0000
   3322 0000F3F0 01 40 0F 11             		lw		r1,#31
   3323 0000F3F4 03 12                   		lw		r2,#3
   3324 0000F3F6 20 AF                   		call	ethWriteMII
   3325 0000F3F8 01 40 09 11             		lw		r1,#25
   3326 0000F3FC 24 43 06 F2             		lw		r2,$3247
   3327 0000F400 1B AF                   		call	ethWriteMII
   3328 0000F402 01 40 00 11             		lw		r1,#16
   3329 0000F406 C7 4A 0C 12             		lw		r2,#$AC7C
   3330 0000F40A 16 AF                   		call	ethWriteMII
   3331 0000F40C 01 40 0F 11             		lw		r1,#31
   3332 0000F410 00 12                   		lw		r2,#0
   3333 0000F412 12 AF                   		call	ethWriteMII
                                        
                                        		; setup receive buffer descriptor
   3336 0000F414 00 46 00 11             		lw		r1,#eth_rxbuf		; set buffer address
   3337 0000F418 A0 40 54 D1             		sw		r1,$A04[r5]
   3338 0000F41C A0 40 56 D0             		sw		r0,$A06[r5]
   3339 0000F420 00 4A 00 11             		lw		r1,#$A000			; empty, wrap buffer
   3340 0000F424 A0 40 50 D1             		sw		r1,$A00[r5]
   3341 0000F428 80 40 00 11             		lw		r1,#$0800
   3342 0000F42C A0 40 52 D1             		sw		r1,$A02[r5]
                                        
   3344 0000F430 02 4A 01 11             		lw		r1,#$A021			; enable recieve all frames
   3345 0000F434 50 D1                   		sw		r1,ETH_MODER[r5]
   3346 0000F436 F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Write to an MII register.
                                        ;
                                        ; Parameters:
                                        ;	r1 = register address
                                        ;	r2 = data for register
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 58
noc_boot31.a
                                        ; Returns:
                                        ;	<none>
                                        ; Registers Affected:
                                        ;	<none>
                                        ;----------------------------------------------------------------------------
                                        
   3360 0000F438                        ethWriteMII:
   3361 0000F438 FC 6E                   		add		sp,sp,#-4
   3362 0000F43A E0 D3                   		sw		r3,[sp]
   3363 0000F43C E2 D5                   		sw		r5,2[sp]
   3364 0000F43E 00 4A 00 15             		lw		r5,#ETHERNET
   3365 0000F442                        ethWriteMII1:
   3366 0000F442 03 40 5C E3             		lb		r3,ETH_MIISTATUS[r5]
   3367 0000F446 52 33                   		and		r3,#2				; busy bit
   3368 0000F448 FC B9                   		bne		ethWriteMII1
   3369 0000F44A 03 40 51 C1             		sb		r1,ETH_MIIADDRESS+1[r5]	; MII register number
   3370 0000F44E 44 4F 5E D2             		sw		r2,ETH_MIITX_DATA[r5]
   3371 0000F452 04 13                   		lw		r3,#4					; write control data
   3372 0000F454 02 40 5C C3             		sb		r3,ETH_MIICOMMAND[r5]
   3373 0000F458 E0 F3                   		lw		r3,[sp]
   3374 0000F45A E2 F5                   		lw		r5,2[sp]
   3375 0000F45C 04 6E                   		add		sp,sp,#4
   3376 0000F45E F0 80                   		ret
                                        
                                        
                                        ;----------------------------------------------------------------------------
                                        ;----------------------------------------------------------------------------
                                        ; Poll for ethernet packets and send them to node $11
                                        ;
   3383 0000F460                        ethPoll:
   3384 0000F460 FC 6E                   		add		sp,sp,#-4
                                        		sw		lw,[sp]
   3386 0000F462 A0 40 50 F1             		lw		r1,$A00[r5]				; get BD status
   3387 0000F466 00 48 50 31             		and		r1,#$8000
                                        		bne		r1,r0,ethPoll3
   3389 0000F46A 00 12                   		lw		r2,#0
   3390 0000F46C 00 14                   		lw		r4,#0
   3391 0000F46E 00 46 00 13             		lw		r3,#eth_rxbuf
   3392 0000F472                        ethPoll2:
   3393 0000F472 5C 4F 05 AF             		call	zeroTxBuf
   3394 0000F476 30 15                   		mov		r5,r3
   3395 0000F478 40 25                   		add		r5,r4
   3396 0000F47A 50 F1                   		lw		r1,[r5]
   3397 0000F47C 02 40 02 D1             		sw		r1,txBuf+2
   3398 0000F480 02 40 04 D4             		sw		r4,txBuf+4
   3399 0000F484 01 40 01 11             		lw		r1,#$11
   3400 0000F488 02 40 0F C1             		sb		r1,txBuf+MSG_DST
   3401 0000F48C 01 40 03 11             		lw		r1,#MT_ETH_PACKET
   3402 0000F490 02 40 08 C1             		sb		r1,txBuf+MSG_TYPE
   3403 0000F494 5D 4F 0F AF             		call	Xmit
   3404 0000F498 02 64                   		add		r4,r4,#2
   3405 0000F49A 01 62                   		add		r2,r2,#1
   3406 0000F49C 80 4F 20 10             		cmp		r2,#2048
   3407 0000F4A0 E8 B4                   		bltu	ethPoll2
   3408 0000F4A2 3E AE                   		br		ethPoll4				; for now
   3409 0000F4A4 00 46 00 11             		lw		r1,#eth_rxbuf
   3410 0000F4A8 47 AF                   		call	ethInterpretPacket
   3411 0000F4AA 1F 10                   		cmp		r1,#1
   3412 0000F4AC 39 A9                   		bne		ethPoll4
   3413 0000F4AE 00 46 00 11             		lw		r1,#eth_rxbuf
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 59
noc_boot31.a
   3414 0000F4B2 EE AF                   		call	ethVerifyIP
   3415 0000F4B4 FF B8                   		beq		ethPoll5
   3416 0000F4B6 00 46 00 11             		lw		r1,#eth_rxbuf
   3417 0000F4BA 01 12                   		lw		r2,#1
   3418 0000F4BC 7F AF                   		call	ethBuildPacket
   3419 0000F4BE 10 1A                   		mov		r10,r1					; r10 = icmpstart
   3420 0000F4C0 00 46 00 14             		lw		r4,#eth_rxbuf
   3421 0000F4C4 A0 24                   		add		r4,r10
   3422 0000F4C6 40 C0                   		sb		r0,[r4]
   3423 0000F4C8 00 46 00 14             		lw		r4,#eth_rxbuf
   3424 0000F4CC 01 40 41 E5             		lb		r5,17[r4]				; r5 = len
   3425 0000F4D0 0E 65                   		add		r5,r5,#14
   3426 0000F4D2 00 46 00 14             		lw		r4,#eth_rxbuf
   3427 0000F4D6 A0 24                   		add		r4,r10
   3428 0000F4D8 42 EB                   		lb		r11,2[r4]
   3429 0000F4DA 43 EC                   		lb		r12,3[r4]
   3430 0000F4DC C0 16                   		mov		r6,r12
   3431 0000F4DE 81 3B                   		shl		r11,#1
   3432 0000F4E0 81 3B                   		shl		r11,#1
   3433 0000F4E2 81 3B                   		shl		r11,#1
   3434 0000F4E4 81 3B                   		shl		r11,#1
   3435 0000F4E6 81 3B                   		shl		r11,#1
   3436 0000F4E8 81 3B                   		shl		r11,#1
   3437 0000F4EA 81 3B                   		shl		r11,#1
   3438 0000F4EC 81 3B                   		shl		r11,#1
   3439 0000F4EE B6 26                   		or		r6,r11
   3440 0000F4F0 4F 36                   		xor		r6,#-1
   3441 0000F4F2 80 4F 60 16             		sub		r6,r6,#$800
   3442 0000F4F6 4F 36                   		xor		r6,#-1
   3443 0000F4F8 43 C6                   		sb		r6,3[r4]
   3444 0000F4FA A1 36                   		shr		r6,#1
   3445 0000F4FC A1 36                   		shr		r6,#1
   3446 0000F4FE A1 36                   		shr		r6,#1
   3447 0000F500 A1 36                   		shr		r6,#1
   3448 0000F502 A1 36                   		shr		r6,#1
   3449 0000F504 A1 36                   		shr		r6,#1
   3450 0000F506 A1 36                   		shr		r6,#1
   3451 0000F508 A1 36                   		shr		r6,#1
   3452 0000F50A 42 C6                   		sb		r6,2[r4]
   3453 0000F50C 00 46 00 11             		lw		r1,#eth_rxbuf
   3454 0000F510 A0 12                   		mov		r2,r10					; r2= icmpstart
   3455 0000F512 92 AF                   		call	ethChecksum
   3456 0000F514 00 46 00 F1             		lw		r1,eth_rxbuf
   3457 0000F518 00 44 00 F2             		lw		r2,eth_txbuf
   3458 0000F51C 50 13                   		mov		r3,r5					; r3 = len
   3459 0000F51E 29 AF                   		call	ethSendPacket
                                        		;br
   3461 0000F520                        ethPoll4:
   3462 0000F520 1E 10                   		cmp		r1,#2
                                        
   3464 0000F522 00 4A 00 11             		lw		r1,#$A000				; empty, wrap buffer
   3465 0000F526 A0 40 50 D1             		sw		r1,$A00[r5]
   3466 0000F52A 80 40 00 11             		lw		r1,#$0800
   3467 0000F52E A0 40 52 D1             		sw		r1,$A02[r5]
   3468 0000F532                        ethPoll3:
   3469 0000F532 E0 FF                   		lw		lr,[sp]
   3470 0000F534 04 6E                   		add		sp,sp,#4
   3471 0000F536 F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 60
noc_boot31.a
                                        ; Detect what type of packet is received.
                                        ;----------------------------------------------------------------------------
                                        
   3477 0000F538                        ethInterpretPacket:
   3478 0000F538 10 12                   		mov		r2,r1
   3479 0000F53A 00 40 2C F1             		lw		r1,12[r2]
   3480 0000F53E 9F 4F 18 10             		cmp		r1,#$0608				; 806 = ARP (big endian words)
   3481 0000F542 02 A9                   		bne		ethInterpretPacket1
   3482 0000F544 02 11                   		lw		r1,#2
   3483 0000F546 F0 80                   		ret
   3484 0000F548                        ethInterpretPacket1:
   3485 0000F548 FF 4F 18 10             		cmp		r1,#$0008				; 800 = IP protocol
   3486 0000F54C 0A A9                   		bne		ethInterpretPacket2
   3487 0000F54E 01 40 27 E1             		lb		r1,23[r2]
   3488 0000F552 1F 10                   		cmp		r1,#1
   3489 0000F554 08 A8                   		beq		ethInterpretPacketICMP
   3490 0000F556 FE 4F 1F 10             		cmp		r1,#$11
   3491 0000F55A 07 A8                   		beq		ethInterpretPacketUDP
   3492 0000F55C FF 4F 1A 10             		cmp		r1,#$06
   3493 0000F560 06 A8                   		beq		ethInterpretPacketTCP
   3494 0000F562                        ethInterpretPacket2:
   3495 0000F562 00 11                   		lw		r1,#0
   3496 0000F564 F0 80                   		ret
   3497 0000F566                        ethInterpretPacketICMP:
   3498 0000F566 01 11                   		lw		r1,#1;
   3499 0000F568 F0 80                   		ret
   3500 0000F56A                        ethInterpretPacketUDP:
   3501 0000F56A 03 11                   		lw		r1,#3
   3502 0000F56C F0 80                   		ret
   3503 0000F56E                        ethInterpretPacketTCP:
   3504 0000F56E 04 11                   		lw		r1,#4
   3505 0000F570 F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ;
                                        ;----------------------------------------------------------------------------
                                        
   3511 0000F572                        ethSendPacket:
   3512 0000F572                        ethSendPacket1:
   3513 0000F572 80 4A 00 F1             		lw		r1,ETHERNET+$800
   3514 0000F576 00 48 50 31             		and		r1,#$8000			; wait for ready bit = 0
   3515 0000F57A FB B9                   		bne		ethSendPacket1
   3516 0000F57C 00 46 00 12             		lw		r2,#eth_rxbuf
   3517 0000F580 00 44 00 13             		lw		r3,#eth_txbuf
   3518 0000F584 80 40 00 14             		lw		r4,#$800
                                        		; Copy receive buffer to transmit buffer
   3520 0000F588                        ethSendPacket2:
   3521 0000F588 20 F1                   		lw		r1,[r2]
   3522 0000F58A 30 D1                   		sw		r1,[r3]
   3523 0000F58C FE 64                   		sub		r4,r4,#2
   3524 0000F58E FC BB                   		bpl		ethSendPacket2
   3525 0000F590 01 11                   		lw		r1,#1				; clear transmit interrupt
   3526 0000F592 00 4A 04 C1             		sb		r1,ETHERNET+ETH_INT_SOURCE
   3527 0000F596 00 44 00 11             		lw		r1,#eth_txbuf
   3528 0000F59A 80 4A 04 D1             		sw		r1,ETHERNET+$804	; set buffer address in TxBD
   3529 0000F59E 80 4A 06 D0             		sw		r0,ETHERNET+$806
   3530 0000F5A2 80 40 00 11             		lw		r1,#$0800
   3531 0000F5A6 80 4A 02 D1             		sw		r1,ETHERNET+$802	; set packet length
   3532 0000F5AA 00 4F 00 11             		lw		r1,#$F000
   3533 0000F5AE 80 4A 00 D1             		sw		r1,ETHERNET+$800	; 
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 61
noc_boot31.a
   3534 0000F5B2                        ethSendPacket3:
   3535 0000F5B2 00 4A 04 F1             		lw		r1,ETHERNET+ETH_INT_SOURCE
   3536 0000F5B6 51 31                   		and		r1,#1
   3537 0000F5B8 FC B8                   		beq		ethSendPacket3
   3538 0000F5BA F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ;----------------------------------------------------------------------------
                                        
   3543 0000F5BC                        ethBuildPacket:
   3544 0000F5BC 10 14                   		mov		r4,r1
   3545 0000F5BE 20 15                   		mov		r5,r2
                                        		; Read MAC address of source and copy to destination field
   3547 0000F5C0 46 F1                   		lw		r1,6[r4]
   3548 0000F5C2 48 F2                   		lw		r2,8[r4]
   3549 0000F5C4 4A F3                   		lw		r3,10[r4]
   3550 0000F5C6 40 D1                   		sw		r1,[r4]
   3551 0000F5C8 42 D2                   		sw		r2,2[r4]
   3552 0000F5CA 44 D3                   		sw		r3,4[r4]
                                        		; Write MAC address to source field
   3554 0000F5CC F0 4F 00 11             		lw		r1,#$FF00
   3555 0000F5D0 0E 4F 0E 12             		lw		r2,#$F0EE
   3556 0000F5D4 2D 44 0A 13             		lw		r3,#$42DA
   3557 0000F5D8 46 D1                   		sw		r1,6[r4]
   3558 0000F5DA 48 D2                   		sw		r2,8[r4]
   3559 0000F5DC 4A D3                   		sw		r3,10[r4]
                                        		; If swap IP address
   3561 0000F5DE 56 25                   		or		r5,r5
   3562 0000F5E0 10 A8                   		beq		ethBuildPacket1
   3563 0000F5E2 01 40 4A F1             		lw		r1,26[r4]
   3564 0000F5E6 01 40 4C F2             		lw		r2,28[r4]
   3565 0000F5EA 01 40 4E F6             		lw		r6,30[r4]
   3566 0000F5EE 02 40 40 F7             		lw		r7,32[r4]
   3567 0000F5F2 01 40 4A D6             		sw		r6,26[r4]
   3568 0000F5F6 01 40 4C D7             		sw		r7,28[r4]
   3569 0000F5FA 01 40 4E D1             		sw		r1,30[r4]
   3570 0000F5FE 02 40 40 D2             		sw		r2,32[r4]
   3571 0000F602                        ethBuildPacket1:
   3572 0000F602 01 40 00 F1             		lw		r1,unique_id
   3573 0000F606 01 61                   		add		r1,r1,#1
   3574 0000F608 01 40 00 D1             		sw		r1,unique_id
   3575 0000F60C 01 40 43 C1             		sb		r1,19[r4]
   3576 0000F610 A1 31                   		shr		r1,#1
   3577 0000F612 A1 31                   		shr		r1,#1
   3578 0000F614 A1 31                   		shr		r1,#1
   3579 0000F616 A1 31                   		shr		r1,#1
   3580 0000F618 A1 31                   		shr		r1,#1
   3581 0000F61A A1 31                   		shr		r1,#1
   3582 0000F61C A1 31                   		shr		r1,#1
   3583 0000F61E A1 31                   		shr		r1,#1
   3584 0000F620 01 40 42 C1             		sb		r1,18[r4]
                                        
                                        		; Get number of bytes in IP header
   3587 0000F624 00 40 4E E1             		lb		r1,14[r4]	; 
   3588 0000F628 00 40 5F 31             		and		r1,#$F
   3589 0000F62C 81 31                   		shl		r1,#1		; *4
   3590 0000F62E 81 31                   		shl		r1,#1
   3591 0000F630 0E 61                   		add		r1,#14
   3592 0000F632 63 4F 02 D1             		sw		r1,data_start
   3593 0000F636 F0 80                   		ret
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 62
noc_boot31.a
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Compute checksum and insert into buffer
                                        ;
                                        ; Parameters:
                                        ;	r1 = buffer address
                                        ;	r2 = start of data
                                        ;----------------------------------------------------------------------------
                                        
   3603 0000F638                        ethChecksum:
   3604 0000F638 10 14                   		mov		r4,r1
   3605 0000F63A 20 15                   		mov		r5,r2
   3606 0000F63C 01 40 48 D0             		sw		r0,24[r4]
   3607 0000F640 00 16                   		lw		r6,#0		; r6 = sum
   3608 0000F642 00 1B                   		lw		r11,#0		; r11 = sum[31:16]
   3609 0000F644 00 40 0E 17             		lw		r7,#14
   3610 0000F648 FF 65                   		sub		r5,r5,#1	; r5 = data_start - 1
   3611 0000F64A                        ethChecksum2:
   3612 0000F64A 5D 27                   		cmp		r7,r5
   3613 0000F64C 12 A1                   		bge		ethChecksum1
   3614 0000F64E 40 18                   		mov		r8,r4
   3615 0000F650 70 28                   		add		r8,r7
   3616 0000F652 80 E9                   		lb		r9,[r8]		; r9 = shi
   3617 0000F654 81 EA                   		lb		r10,1[r8]	; r10 = slo
   3618 0000F656 0E 2A                   		zxb		r10
   3619 0000F658 81 39                   		shl		r9,#1
   3620 0000F65A 81 39                   		shl		r9,#1
   3621 0000F65C 81 39                   		shl		r9,#1
   3622 0000F65E 81 39                   		shl		r9,#1
   3623 0000F660 81 39                   		shl		r9,#1
   3624 0000F662 81 39                   		shl		r9,#1
   3625 0000F664 81 39                   		shl		r9,#1
   3626 0000F666 81 39                   		shl		r9,#1
   3627 0000F668 96 2A                   		or		r10,r9
   3628 0000F66A A0 26                   		add		r6,r10		; sum = sum + ((shi<<8)|slo)
   3629 0000F66C 10 3B                   		adc		r11,#0
   3630 0000F66E 02 67                   		add		r7,r7,#2
   3631 0000F670 EC BE                   		br		ethChecksum2
   3632 0000F672                        ethChecksum1:
                                        		; add overflow bits (upper 16) to lower 16
   3634 0000F672 B0 26                   		add		r6,r11
   3635 0000F674 4F 36                   		xor		r6,#-1		; sum = ~sum
   3636 0000F676 01 40 49 C6             		sb		r6,25[r4]
   3637 0000F67A A1 36                   		shr		r6,#1
   3638 0000F67C A1 36                   		shr		r6,#1
   3639 0000F67E A1 36                   		shr		r6,#1
   3640 0000F680 A1 36                   		shr		r6,#1
   3641 0000F682 A1 36                   		shr		r6,#1
   3642 0000F684 A1 36                   		shr		r6,#1
   3643 0000F686 A1 36                   		shr		r6,#1
   3644 0000F688 A1 36                   		shr		r6,#1
   3645 0000F68A 01 40 48 C6             		sb		r6,24[r4]
   3646 0000F68E F0 80                   		ret
                                        
                                        ;----------------------------------------------------------------------------
                                        ; Verify that the IP address is either a general broadcast address, or it
                                        ; matches our IP address.
                                        ;
                                        ; Parameters:
                                        ;	r1 = pointer to receive buffer
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 63
noc_boot31.a
                                        ; Returns:
                                        ;	r1 = 1 if IP matches, 0 if no match
                                        ;----------------------------------------------------------------------------
                                        
   3658 0000F690                        ethVerifyIP:
   3659 0000F690 10 15                   		mov		r5,r1
   3660 0000F692 01 40 5E E1             		lb		r1,30[r5]
   3661 0000F696 01 40 5F E2             		lb		r2,31[r5]
   3662 0000F69A 02 40 50 E3             		lb		r3,32[r5]
   3663 0000F69E 02 40 51 E4             		lb		r4,33[r5]
   3664 0000F6A2 81 33                   		shl		r3,#1
   3665 0000F6A4 81 33                   		shl		r3,#1
   3666 0000F6A6 81 33                   		shl		r3,#1
   3667 0000F6A8 81 33                   		shl		r3,#1
   3668 0000F6AA 81 33                   		shl		r3,#1
   3669 0000F6AC 81 33                   		shl		r3,#1
   3670 0000F6AE 81 33                   		shl		r3,#1
   3671 0000F6B0 81 33                   		shl		r3,#1
   3672 0000F6B2 46 23                   		or		r3,r4
   3673 0000F6B4 81 31                   		shl		r1,#1
   3674 0000F6B6 81 31                   		shl		r1,#1
   3675 0000F6B8 81 31                   		shl		r1,#1
   3676 0000F6BA 81 31                   		shl		r1,#1
   3677 0000F6BC 81 31                   		shl		r1,#1
   3678 0000F6BE 81 31                   		shl		r1,#1
   3679 0000F6C0 81 31                   		shl		r1,#1
   3680 0000F6C2 81 31                   		shl		r1,#1
   3681 0000F6C4 26 21                   		or		r1,r2
   3682 0000F6C6 00 40 11 10             		cmp		r1,#$FFFF
   3683 0000F6CA 03 A9                   		bne		ethVerifyIP2
   3684 0000F6CC 00 40 31 10             		cmp		r3,#$FFFF
   3685 0000F6D0 06 A8                   		beq		ethVerifyIP3
   3686 0000F6D2                        ethVerifyIP2:
   3687 0000F6D2 F5 43 18 10             		cmp		r1,#$C0A8		; 192.168.
   3688 0000F6D6 05 A9                   		bne		ethVerifyIP1
   3689 0000F6D8 ED 4F 36 10             		cmp		r3,#$012A		; 1.42
   3690 0000F6DC 02 A9                   		bne		ethVerifyIP1
   3691 0000F6DE                        ethVerifyIP3:
   3692 0000F6DE 01 11                   		lw		r1,#1
   3693 0000F6E0 F0 80                   		ret
   3694 0000F6E2                        ethVerifyIP1:
   3695 0000F6E2 00 11                   		lw		r1,#0
   3696 0000F6E4 F0 80                   		ret
                                        
   3698 0000F6E6 FF FF FF FF FF FF FF    		org		0xFFFE
   3698 0000F6ED FF FF FF FF FF FF FF  
   3698 0000F6F4 FF FF FF FF FF FF FF  
   3698 0000F6FB FF FF FF FF FF FF FF  
   3698 0000F702 FF FF FF FF FF FF FF  
   3698 0000F709 FF FF FF FF FF FF FF  
   3698 0000F710 FF FF FF FF FF FF FF  
   3698 0000F717 FF FF FF FF FF FF FF  
   3698 0000F71E FF FF FF FF FF FF FF  
   3698 0000F725 FF FF FF FF FF FF FF  
   3698 0000F72C FF FF FF FF FF FF FF  
   3698 0000F733 FF FF FF FF FF FF FF  
   3698 0000F73A FF FF FF FF FF FF FF  
   3698 0000F741 FF FF FF FF FF FF FF  
   3698 0000F748 FF FF FF FF FF FF FF  
   3698 0000F74F FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 64
noc_boot31.a
   3698 0000F756 FF FF FF FF FF FF FF  
   3698 0000F75D FF FF FF FF FF FF FF  
   3698 0000F764 FF FF FF FF FF FF FF  
   3698 0000F76B FF FF FF FF FF FF FF  
   3698 0000F772 FF FF FF FF FF FF FF  
   3698 0000F779 FF FF FF FF FF FF FF  
   3698 0000F780 FF FF FF FF FF FF FF  
   3698 0000F787 FF FF FF FF FF FF FF  
   3698 0000F78E FF FF FF FF FF FF FF  
   3698 0000F795 FF FF FF FF FF FF FF  
   3698 0000F79C FF FF FF FF FF FF FF  
   3698 0000F7A3 FF FF FF FF FF FF FF  
   3698 0000F7AA FF FF FF FF FF FF FF  
   3698 0000F7B1 FF FF FF FF FF FF FF  
   3698 0000F7B8 FF FF FF FF FF FF FF  
   3698 0000F7BF FF FF FF FF FF FF FF  
   3698 0000F7C6 FF FF FF FF FF FF FF  
   3698 0000F7CD FF FF FF FF FF FF FF  
   3698 0000F7D4 FF FF FF FF FF FF FF  
   3698 0000F7DB FF FF FF FF FF FF FF  
   3698 0000F7E2 FF FF FF FF FF FF FF  
   3698 0000F7E9 FF FF FF FF FF FF FF  
   3698 0000F7F0 FF FF FF FF FF FF FF  
   3698 0000F7F7 FF FF FF FF FF FF FF  
   3698 0000F7FE FF FF FF FF FF FF FF  
   3698 0000F805 FF FF FF FF FF FF FF  
   3698 0000F80C FF FF FF FF FF FF FF  
   3698 0000F813 FF FF FF FF FF FF FF  
   3698 0000F81A FF FF FF FF FF FF FF  
   3698 0000F821 FF FF FF FF FF FF FF  
   3698 0000F828 FF FF FF FF FF FF FF  
   3698 0000F82F FF FF FF FF FF FF FF  
   3698 0000F836 FF FF FF FF FF FF FF  
   3698 0000F83D FF FF FF FF FF FF FF  
   3698 0000F844 FF FF FF FF FF FF FF  
   3698 0000F84B FF FF FF FF FF FF FF  
   3698 0000F852 FF FF FF FF FF FF FF  
   3698 0000F859 FF FF FF FF FF FF FF  
   3698 0000F860 FF FF FF FF FF FF FF  
   3698 0000F867 FF FF FF FF FF FF FF  
   3698 0000F86E FF FF FF FF FF FF FF  
   3698 0000F875 FF FF FF FF FF FF FF  
   3698 0000F87C FF FF FF FF FF FF FF  
   3698 0000F883 FF FF FF FF FF FF FF  
   3698 0000F88A FF FF FF FF FF FF FF  
   3698 0000F891 FF FF FF FF FF FF FF  
   3698 0000F898 FF FF FF FF FF FF FF  
   3698 0000F89F FF FF FF FF FF FF FF  
   3698 0000F8A6 FF FF FF FF FF FF FF  
   3698 0000F8AD FF FF FF FF FF FF FF  
   3698 0000F8B4 FF FF FF FF FF FF FF  
   3698 0000F8BB FF FF FF FF FF FF FF  
   3698 0000F8C2 FF FF FF FF FF FF FF  
   3698 0000F8C9 FF FF FF FF FF FF FF  
   3698 0000F8D0 FF FF FF FF FF FF FF  
   3698 0000F8D7 FF FF FF FF FF FF FF  
   3698 0000F8DE FF FF FF FF FF FF FF  
   3698 0000F8E5 FF FF FF FF FF FF FF  
   3698 0000F8EC FF FF FF FF FF FF FF  
   3698 0000F8F3 FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 65
noc_boot31.a
   3698 0000F8FA FF FF FF FF FF FF FF  
   3698 0000F901 FF FF FF FF FF FF FF  
   3698 0000F908 FF FF FF FF FF FF FF  
   3698 0000F90F FF FF FF FF FF FF FF  
   3698 0000F916 FF FF FF FF FF FF FF  
   3698 0000F91D FF FF FF FF FF FF FF  
   3698 0000F924 FF FF FF FF FF FF FF  
   3698 0000F92B FF FF FF FF FF FF FF  
   3698 0000F932 FF FF FF FF FF FF FF  
   3698 0000F939 FF FF FF FF FF FF FF  
   3698 0000F940 FF FF FF FF FF FF FF  
   3698 0000F947 FF FF FF FF FF FF FF  
   3698 0000F94E FF FF FF FF FF FF FF  
   3698 0000F955 FF FF FF FF FF FF FF  
   3698 0000F95C FF FF FF FF FF FF FF  
   3698 0000F963 FF FF FF FF FF FF FF  
   3698 0000F96A FF FF FF FF FF FF FF  
   3698 0000F971 FF FF FF FF FF FF FF  
   3698 0000F978 FF FF FF FF FF FF FF  
   3698 0000F97F FF FF FF FF FF FF FF  
   3698 0000F986 FF FF FF FF FF FF FF  
   3698 0000F98D FF FF FF FF FF FF FF  
   3698 0000F994 FF FF FF FF FF FF FF  
   3698 0000F99B FF FF FF FF FF FF FF  
   3698 0000F9A2 FF FF FF FF FF FF FF  
   3698 0000F9A9 FF FF FF FF FF FF FF  
   3698 0000F9B0 FF FF FF FF FF FF FF  
   3698 0000F9B7 FF FF FF FF FF FF FF  
   3698 0000F9BE FF FF FF FF FF FF FF  
   3698 0000F9C5 FF FF FF FF FF FF FF  
   3698 0000F9CC FF FF FF FF FF FF FF  
   3698 0000F9D3 FF FF FF FF FF FF FF  
   3698 0000F9DA FF FF FF FF FF FF FF  
   3698 0000F9E1 FF FF FF FF FF FF FF  
   3698 0000F9E8 FF FF FF FF FF FF FF  
   3698 0000F9EF FF FF FF FF FF FF FF  
   3698 0000F9F6 FF FF FF FF FF FF FF  
   3698 0000F9FD FF FF FF FF FF FF FF  
   3698 0000FA04 FF FF FF FF FF FF FF  
   3698 0000FA0B FF FF FF FF FF FF FF  
   3698 0000FA12 FF FF FF FF FF FF FF  
   3698 0000FA19 FF FF FF FF FF FF FF  
   3698 0000FA20 FF FF FF FF FF FF FF  
   3698 0000FA27 FF FF FF FF FF FF FF  
   3698 0000FA2E FF FF FF FF FF FF FF  
   3698 0000FA35 FF FF FF FF FF FF FF  
   3698 0000FA3C FF FF FF FF FF FF FF  
   3698 0000FA43 FF FF FF FF FF FF FF  
   3698 0000FA4A FF FF FF FF FF FF FF  
   3698 0000FA51 FF FF FF FF FF FF FF  
   3698 0000FA58 FF FF FF FF FF FF FF  
   3698 0000FA5F FF FF FF FF FF FF FF  
   3698 0000FA66 FF FF FF FF FF FF FF  
   3698 0000FA6D FF FF FF FF FF FF FF  
   3698 0000FA74 FF FF FF FF FF FF FF  
   3698 0000FA7B FF FF FF FF FF FF FF  
   3698 0000FA82 FF FF FF FF FF FF FF  
   3698 0000FA89 FF FF FF FF FF FF FF  
   3698 0000FA90 FF FF FF FF FF FF FF  
   3698 0000FA97 FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 66
noc_boot31.a
   3698 0000FA9E FF FF FF FF FF FF FF  
   3698 0000FAA5 FF FF FF FF FF FF FF  
   3698 0000FAAC FF FF FF FF FF FF FF  
   3698 0000FAB3 FF FF FF FF FF FF FF  
   3698 0000FABA FF FF FF FF FF FF FF  
   3698 0000FAC1 FF FF FF FF FF FF FF  
   3698 0000FAC8 FF FF FF FF FF FF FF  
   3698 0000FACF FF FF FF FF FF FF FF  
   3698 0000FAD6 FF FF FF FF FF FF FF  
   3698 0000FADD FF FF FF FF FF FF FF  
   3698 0000FAE4 FF FF FF FF FF FF FF  
   3698 0000FAEB FF FF FF FF FF FF FF  
   3698 0000FAF2 FF FF FF FF FF FF FF  
   3698 0000FAF9 FF FF FF FF FF FF FF  
   3698 0000FB00 FF FF FF FF FF FF FF  
   3698 0000FB07 FF FF FF FF FF FF FF  
   3698 0000FB0E FF FF FF FF FF FF FF  
   3698 0000FB15 FF FF FF FF FF FF FF  
   3698 0000FB1C FF FF FF FF FF FF FF  
   3698 0000FB23 FF FF FF FF FF FF FF  
   3698 0000FB2A FF FF FF FF FF FF FF  
   3698 0000FB31 FF FF FF FF FF FF FF  
   3698 0000FB38 FF FF FF FF FF FF FF  
   3698 0000FB3F FF FF FF FF FF FF FF  
   3698 0000FB46 FF FF FF FF FF FF FF  
   3698 0000FB4D FF FF FF FF FF FF FF  
   3698 0000FB54 FF FF FF FF FF FF FF  
   3698 0000FB5B FF FF FF FF FF FF FF  
   3698 0000FB62 FF FF FF FF FF FF FF  
   3698 0000FB69 FF FF FF FF FF FF FF  
   3698 0000FB70 FF FF FF FF FF FF FF  
   3698 0000FB77 FF FF FF FF FF FF FF  
   3698 0000FB7E FF FF FF FF FF FF FF  
   3698 0000FB85 FF FF FF FF FF FF FF  
   3698 0000FB8C FF FF FF FF FF FF FF  
   3698 0000FB93 FF FF FF FF FF FF FF  
   3698 0000FB9A FF FF FF FF FF FF FF  
   3698 0000FBA1 FF FF FF FF FF FF FF  
   3698 0000FBA8 FF FF FF FF FF FF FF  
   3698 0000FBAF FF FF FF FF FF FF FF  
   3698 0000FBB6 FF FF FF FF FF FF FF  
   3698 0000FBBD FF FF FF FF FF FF FF  
   3698 0000FBC4 FF FF FF FF FF FF FF  
   3698 0000FBCB FF FF FF FF FF FF FF  
   3698 0000FBD2 FF FF FF FF FF FF FF  
   3698 0000FBD9 FF FF FF FF FF FF FF  
   3698 0000FBE0 FF FF FF FF FF FF FF  
   3698 0000FBE7 FF FF FF FF FF FF FF  
   3698 0000FBEE FF FF FF FF FF FF FF  
   3698 0000FBF5 FF FF FF FF FF FF FF  
   3698 0000FBFC FF FF FF FF FF FF FF  
   3698 0000FC03 FF FF FF FF FF FF FF  
   3698 0000FC0A FF FF FF FF FF FF FF  
   3698 0000FC11 FF FF FF FF FF FF FF  
   3698 0000FC18 FF FF FF FF FF FF FF  
   3698 0000FC1F FF FF FF FF FF FF FF  
   3698 0000FC26 FF FF FF FF FF FF FF  
   3698 0000FC2D FF FF FF FF FF FF FF  
   3698 0000FC34 FF FF FF FF FF FF FF  
   3698 0000FC3B FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 67
noc_boot31.a
   3698 0000FC42 FF FF FF FF FF FF FF  
   3698 0000FC49 FF FF FF FF FF FF FF  
   3698 0000FC50 FF FF FF FF FF FF FF  
   3698 0000FC57 FF FF FF FF FF FF FF  
   3698 0000FC5E FF FF FF FF FF FF FF  
   3698 0000FC65 FF FF FF FF FF FF FF  
   3698 0000FC6C FF FF FF FF FF FF FF  
   3698 0000FC73 FF FF FF FF FF FF FF  
   3698 0000FC7A FF FF FF FF FF FF FF  
   3698 0000FC81 FF FF FF FF FF FF FF  
   3698 0000FC88 FF FF FF FF FF FF FF  
   3698 0000FC8F FF FF FF FF FF FF FF  
   3698 0000FC96 FF FF FF FF FF FF FF  
   3698 0000FC9D FF FF FF FF FF FF FF  
   3698 0000FCA4 FF FF FF FF FF FF FF  
   3698 0000FCAB FF FF FF FF FF FF FF  
   3698 0000FCB2 FF FF FF FF FF FF FF  
   3698 0000FCB9 FF FF FF FF FF FF FF  
   3698 0000FCC0 FF FF FF FF FF FF FF  
   3698 0000FCC7 FF FF FF FF FF FF FF  
   3698 0000FCCE FF FF FF FF FF FF FF  
   3698 0000FCD5 FF FF FF FF FF FF FF  
   3698 0000FCDC FF FF FF FF FF FF FF  
   3698 0000FCE3 FF FF FF FF FF FF FF  
   3698 0000FCEA FF FF FF FF FF FF FF  
   3698 0000FCF1 FF FF FF FF FF FF FF  
   3698 0000FCF8 FF FF FF FF FF FF FF  
   3698 0000FCFF FF FF FF FF FF FF FF  
   3698 0000FD06 FF FF FF FF FF FF FF  
   3698 0000FD0D FF FF FF FF FF FF FF  
   3698 0000FD14 FF FF FF FF FF FF FF  
   3698 0000FD1B FF FF FF FF FF FF FF  
   3698 0000FD22 FF FF FF FF FF FF FF  
   3698 0000FD29 FF FF FF FF FF FF FF  
   3698 0000FD30 FF FF FF FF FF FF FF  
   3698 0000FD37 FF FF FF FF FF FF FF  
   3698 0000FD3E FF FF FF FF FF FF FF  
   3698 0000FD45 FF FF FF FF FF FF FF  
   3698 0000FD4C FF FF FF FF FF FF FF  
   3698 0000FD53 FF FF FF FF FF FF FF  
   3698 0000FD5A FF FF FF FF FF FF FF  
   3698 0000FD61 FF FF FF FF FF FF FF  
   3698 0000FD68 FF FF FF FF FF FF FF  
   3698 0000FD6F FF FF FF FF FF FF FF  
   3698 0000FD76 FF FF FF FF FF FF FF  
   3698 0000FD7D FF FF FF FF FF FF FF  
   3698 0000FD84 FF FF FF FF FF FF FF  
   3698 0000FD8B FF FF FF FF FF FF FF  
   3698 0000FD92 FF FF FF FF FF FF FF  
   3698 0000FD99 FF FF FF FF FF FF FF  
   3698 0000FDA0 FF FF FF FF FF FF FF  
   3698 0000FDA7 FF FF FF FF FF FF FF  
   3698 0000FDAE FF FF FF FF FF FF FF  
   3698 0000FDB5 FF FF FF FF FF FF FF  
   3698 0000FDBC FF FF FF FF FF FF FF  
   3698 0000FDC3 FF FF FF FF FF FF FF  
   3698 0000FDCA FF FF FF FF FF FF FF  
   3698 0000FDD1 FF FF FF FF FF FF FF  
   3698 0000FDD8 FF FF FF FF FF FF FF  
   3698 0000FDDF FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 68
noc_boot31.a
   3698 0000FDE6 FF FF FF FF FF FF FF  
   3698 0000FDED FF FF FF FF FF FF FF  
   3698 0000FDF4 FF FF FF FF FF FF FF  
   3698 0000FDFB FF FF FF FF FF FF FF  
   3698 0000FE02 FF FF FF FF FF FF FF  
   3698 0000FE09 FF FF FF FF FF FF FF  
   3698 0000FE10 FF FF FF FF FF FF FF  
   3698 0000FE17 FF FF FF FF FF FF FF  
   3698 0000FE1E FF FF FF FF FF FF FF  
   3698 0000FE25 FF FF FF FF FF FF FF  
   3698 0000FE2C FF FF FF FF FF FF FF  
   3698 0000FE33 FF FF FF FF FF FF FF  
   3698 0000FE3A FF FF FF FF FF FF FF  
   3698 0000FE41 FF FF FF FF FF FF FF  
   3698 0000FE48 FF FF FF FF FF FF FF  
   3698 0000FE4F FF FF FF FF FF FF FF  
   3698 0000FE56 FF FF FF FF FF FF FF  
   3698 0000FE5D FF FF FF FF FF FF FF  
   3698 0000FE64 FF FF FF FF FF FF FF  
   3698 0000FE6B FF FF FF FF FF FF FF  
   3698 0000FE72 FF FF FF FF FF FF FF  
   3698 0000FE79 FF FF FF FF FF FF FF  
   3698 0000FE80 FF FF FF FF FF FF FF  
   3698 0000FE87 FF FF FF FF FF FF FF  
   3698 0000FE8E FF FF FF FF FF FF FF  
   3698 0000FE95 FF FF FF FF FF FF FF  
   3698 0000FE9C FF FF FF FF FF FF FF  
   3698 0000FEA3 FF FF FF FF FF FF FF  
   3698 0000FEAA FF FF FF FF FF FF FF  
   3698 0000FEB1 FF FF FF FF FF FF FF  
   3698 0000FEB8 FF FF FF FF FF FF FF  
   3698 0000FEBF FF FF FF FF FF FF FF  
   3698 0000FEC6 FF FF FF FF FF FF FF  
   3698 0000FECD FF FF FF FF FF FF FF  
   3698 0000FED4 FF FF FF FF FF FF FF  
   3698 0000FEDB FF FF FF FF FF FF FF  
   3698 0000FEE2 FF FF FF FF FF FF FF  
   3698 0000FEE9 FF FF FF FF FF FF FF  
   3698 0000FEF0 FF FF FF FF FF FF FF  
   3698 0000FEF7 FF FF FF FF FF FF FF  
   3698 0000FEFE FF FF FF FF FF FF FF  
   3698 0000FF05 FF FF FF FF FF FF FF  
   3698 0000FF0C FF FF FF FF FF FF FF  
   3698 0000FF13 FF FF FF FF FF FF FF  
   3698 0000FF1A FF FF FF FF FF FF FF  
   3698 0000FF21 FF FF FF FF FF FF FF  
   3698 0000FF28 FF FF FF FF FF FF FF  
   3698 0000FF2F FF FF FF FF FF FF FF  
   3698 0000FF36 FF FF FF FF FF FF FF  
   3698 0000FF3D FF FF FF FF FF FF FF  
   3698 0000FF44 FF FF FF FF FF FF FF  
   3698 0000FF4B FF FF FF FF FF FF FF  
   3698 0000FF52 FF FF FF FF FF FF FF  
   3698 0000FF59 FF FF FF FF FF FF FF  
   3698 0000FF60 FF FF FF FF FF FF FF  
   3698 0000FF67 FF FF FF FF FF FF FF  
   3698 0000FF6E FF FF FF FF FF FF FF  
   3698 0000FF75 FF FF FF FF FF FF FF  
   3698 0000FF7C FF FF FF FF FF FF FF  
   3698 0000FF83 FF FF FF FF FF FF FF  
Bird Computer Butterfly assembler   version 1.0.2   Wed Jun 21 12:36:17 2017     Page 69
noc_boot31.a
   3698 0000FF8A FF FF FF FF FF FF FF  
   3698 0000FF91 FF FF FF FF FF FF FF  
   3698 0000FF98 FF FF FF FF FF FF FF  
   3698 0000FF9F FF FF FF FF FF FF FF  
   3698 0000FFA6 FF FF FF FF FF FF FF  
   3698 0000FFAD FF FF FF FF FF FF FF  
   3698 0000FFB4 FF FF FF FF FF FF FF  
   3698 0000FFBB FF FF FF FF FF FF FF  
   3698 0000FFC2 FF FF FF FF FF FF FF  
   3698 0000FFC9 FF FF FF FF FF FF FF  
   3698 0000FFD0 FF FF FF FF FF FF FF  
   3698 0000FFD7 FF FF FF FF FF FF FF  
   3698 0000FFDE FF FF FF FF FF FF FF  
   3698 0000FFE5 FF FF FF FF FF FF FF  
   3698 0000FFEC FF FF FF FF FF FF FF  
   3698 0000FFF3 FF FF FF FF FF FF FF  
   3698 0000FFFA FF FF FF FF           
   3699 0000FFFE BC F2                   		dw		start
