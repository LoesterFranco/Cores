                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "../fmtk/const.asm",1
                        	.file "../fmtk/const.asm",1
                        	; First 128 bytes are for integer register set
                        	; Second 128 bytes are for float register set
                        	; Leave some room for 64-bit regs
                        	TCBsegs			EQU		$200		; segment register storage
                        	TCBepc			EQU		$280
                        	TCBStatus		EQU		$288
                        	TCBPriority	EQU		$289
                        	TCBWaitMbx	EQU		$28A
                        	TCBStackBot	EQU		$290
                        	TCBMsgD1		EQU		$298
                        	TCBMsgD2		EQU		$2A0
                        	TCBMsgD3		EQU		$2A8
                        	TCBStartTick	EQU	$2B0
                        	TCBEndTick	EQU		$2B8
                        	TCBTicks		EQU		$2C0
                        	TCBException	EQU	$2C8
                        	TCBNext			EQU		$2D0
                        	TCBPrev			EQU		$2D8
                        	TCBTimeout	EQU		$2E0
                        	
                        	TS_NONE			EQU		0
                        	TS_READY		EQU		1
                        	TS_DEAD			EQU		2
                        	TS_MSGRDY		EQU		4
                        	TS_WAITMSG	EQU		8
                        	TS_TIMEOUT	EQU		16
                        	TS_PREEMPT	EQU		32
                        	TS_RUNNING	EQU		128
                        	
                        	; error codes
                        	E_Ok		=		0x00
                        	E_Arg		=		0x01
                        	E_BadMbx	=		0x04
                        	E_QueFull	=		0x05
                        	E_NoThread	=		0x06
                        	E_NotAlloc	=		0x09
                        	E_NoMsg		=		0x0b
                        	E_Timeout	=		0x10
                        	E_BadAlarm	=		0x11
                        	E_NotOwner	=		0x12
                        	E_QueStrategy =		0x13
                        	E_BadDevNum	=		0x18
                        	E_DCBInUse	=		0x19
                        	; Device driver errors
                        	E_BadDevNum	=		0x20
                        	E_NoDev		=		0x21
                        	E_BadDevOp	=		0x22
                        	E_ReadError	=		0x23
                        	E_WriteError =		0x24
                        	E_BadBlockNum	=	0x25
                        	E_TooManyBlocks	=	0x26
                        	
                        	; resource errors
                        	E_NoMoreMbx	=		0x40
                        	E_NoMoreMsgBlks	=	0x41
                        	E_NoMoreAlarmBlks	=0x44
                        	E_NoMoreTCBs	=	0x45
                        	E_NoMem		= 12
                        	
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "../fmtk/config.asm",1
                        	.file "../fmtk/config.asm",1
                        	MAX_TID		EQU		15
                        	NR_TCB		EQU		16
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	
                        	BS					equ		$08
                        	LF					equ		$0A
                        	CR					equ		$0D
                        	XON					equ		$11
                        	XOFF				equ		$13
                        	DEL					equ		$7F
                        	VIA					equ		$FFDC0600
                        	VIA_PA			equ		$04
                        	VIA_DDRA		equ		$0C
                        	VIA_T1CL		equ		$10
                        	VIA_T1CH		equ		$14
                        	VIA_ACR			equ		$2C
                        	VIA_PCR			equ		$30
                        	VIA_IFR			equ		$34
                        	VIA_PARAW		equ		$3C
                        	UART				equ		$FFDC0A00
                        	UART_TRB		equ		$00
                        	UART_STAT		equ		$04
                        	UART_CMD		equ		$08
                        			; First 16kB is for TCB's
                        	INBUF				equ		$4100
                        	switchflag	equ		$4200
                        	milliseconds	equ		$4208
                        	
                        	
                        	.file "cs01rom.asm",28
                        			code	18 bits
                        	;------------------------------------------------------------------------------
                        	; Exception vector table.
                        	;------------------------------------------------------------------------------
                        			org		$FFFC0000				; user mode exception
FFFC0000 7800006F			jmp		IRQRout
FFFC0004 00000000			org 	$FFFC00C0				; machine mode exception
FFFC0008 00000000
FFFC000C 00000000
FFFC0010 00000000
FFFC0014 00000000
FFFC0018 00000000
FFFC001C 00000000
FFFC0020 00000000
FFFC0024 00000000
FFFC0028 00000000
FFFC002C 00000000
FFFC0030 00000000
FFFC0034 00000000
FFFC0038 00000000
FFFC003C 00000000
FFFC0040 00000000
FFFC0044 00000000
FFFC0048 00000000
FFFC004C 00000000
FFFC0050 00000000
FFFC0054 00000000
FFFC0058 00000000
FFFC005C 00000000
FFFC0060 00000000
FFFC0064 00000000
FFFC0068 00000000
FFFC006C 00000000
FFFC0070 00000000
FFFC0074 00000000
FFFC0078 00000000
FFFC007C 00000000
FFFC0080 00000000
FFFC0084 00000000
FFFC0088 00000000
FFFC008C 00000000
FFFC0090 00000000
FFFC0094 00000000
FFFC0098 00000000
FFFC009C 00000000
FFFC00A0 00000000
FFFC00A4 00000000
FFFC00A8 00000000
FFFC00AC 00000000
FFFC00B0 00000000
FFFC00B4 00000000
FFFC00B8 00000000
FFFC00BC 00000000
FFFC00C0 6C00006F			jmp		IRQRout
FFFC00C4 00000000			org		$FFFC00FC				; non-maskable interrupt
FFFC00C8 00000000
FFFC00CC 00000000
FFFC00D0 00000000
FFFC00D4 00000000
FFFC00D8 00000000
FFFC00DC 00000000
FFFC00E0 00000000
FFFC00E4 00000000
FFFC00E8 00000000
FFFC00EC 00000000
FFFC00F0 00000000
FFFC00F4 00000000
FFFC00F8 00000000
FFFC00FC 0040006F			jmp		MachineStart
                        	
                        	;------------------------------------------------------------------------------
                        	; User mode code starts here
                        	;------------------------------------------------------------------------------
                        			org		$FFFC0100
                        	MachineStart:
FFFC0100 00080737			ldi		$sp,#$80000-4		; setup machine mode stack pointer
FFFC0104 FFC70713
FFFC0108 3E1000EF			call	MMUInit					; initialize MMU for address space zero.
FFFC010C 124010EF			call	FMTKInit
FFFC0110 FFFC0D37			ldi		$t0,#$FFFC0000
FFFC0114 000D0D13
FFFC0118 301D1073			csrrw $x0,#$301,$t0		; set tvec
FFFC011C FFFC0D37			ldi		$t0,#UserStart
FFFC0120 12CD0D13
FFFC0124 341D1073			csrrw	$x0,#$341,$t0		; set mepc
FFFC0128 10000073			eret									; switch to user mode
                        	UserStart:
FFFC012C 00080737			ldi		$sp,#$80000-1028		; setup user mode stack pointer
FFFC0130 BFC70713
FFFC0134 4FC000EF			call	VIAInit
FFFC0138 00806D13			ldi		$t0,#$08						; turn on the LED
FFFC013C FFDC0637			sw		$t0,VIA+VIA_PARAW
FFFC0140 63C60613
FFFC0144 00060633
FFFC0148 01A62023
FFFC014C 5F0000EF			call	SerialInit
FFFC0150 01006E13			ldi		$t2,#16							; send an XON just in case
FFFC0154 01106913			ldi		$a0,#XON
                        	.0004:
FFFC0158 574000EF			call	SerialPutChar
FFFC015C FFFE0E13			sub		$t2,$t2,#1
FFFC0160 FE0E1CE3			bne		$t2,$x0,.0004
                        	.0002:
FFFC0164 FFFC1937			ldi		$a0,#msgStart				; spit out a startup message
FFFC0168 82490913
FFFC016C 59C000EF			call	SerialPutString
FFFC0170 00106913			ldi		a0,#1
FFFC0174 000069B7			ldi		a1,#24000
FFFC0178 DC098993
FFFC017C FFFC0A37			ldi		a2,#Monitor
FFFC0180 1D8A0A13
FFFC0184 00000073			ecall
FFFC0188 04000463			bra		MonEntry
                        	
                        			; Now a loop to recieve and echo back characters
                        	.0003:
FFFC018C 50C000EF			call	SerialPeekChar
FFFC0190 FE084EE3			blt		$v0,$x0,.0003
FFFC0194 00086933			mov		$a0,$v0
FFFC0198 534000EF			call	SerialPutChar
FFFC019C FE0008E3			bra		.0003
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	Getch:
FFFC01A0 FFC70713			sub		$sp,$sp,#4
FFFC01A4 00172023			sw		$ra,[$sp]
FFFC01A8 4F0000EF			call	SerialPeekChar
FFFC01AC 00072083			lw		$ra,[$sp]
FFFC01B0 00470713			add		$sp,$sp,#4
FFFC01B4 00008067			ret
                        	
                        	Putch:
FFFC01B8 FFC70713			sub		$sp,$sp,#4
FFFC01BC 00172023			sw		$ra,[$sp]
FFFC01C0 50C000EF			call	SerialPutChar
FFFC01C4 00072083			lw		$ra,[$sp]
FFFC01C8 00470713			add		$sp,$sp,#4
FFFC01CC 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	MonEntry:
                        	;		flw			$f2,fltTen
                        	;		fsw			$f2,f2Save
                        	;		flw			$f1,fltTen
                        	;		fsw			$f1,f1Save
                        	;		fadd		$f18,$f2,$f1
                        	;		fsw			$f18,f18Save
FFFC01D0 00A06913			ldi		$a0,#10
FFFC01D4 00606A13			ldi		$a2,#6
                        	;		call	fltToString
                        	;		ldi		$a0,#STRTMP
                        	;		call	SerialPutString
                        	
                        	Monitor:
FFFC01D8 00006213			ldi		$s1,#0					; s1 = input pointer
FFFC01DC 00D06913			ldi		$a0,#CR
FFFC01E0 FD9FF0EF			call	Putch
FFFC01E4 00006913			ldi		$a0,#LF
		call	Putch
FFFC01E8 FD1FF0EF
FFFC01EC 03E06913			ldi		$a0,#'>'
FFFC01F0 FC9FF0EF			call	Putch
                        	.0001:
FFFC01F4 FADFF0EF			call	Getch						; wait until character pressed
FFFC01F8 FE084EE3			blt		$v0,$x0,.0001
FFFC01FC 00084D13			xor		$t0,$v0,#LF			; ignore line feed
		beq		$t0,$x0,.procLine
FFFC0200 0E0D0C63
FFFC0204 00D84D13			xor		$t0,$v0,#CR
FFFC0208 0E0D0863			beq		$t0,$x0,.procLine
FFFC020C 00884D13			xor		$t0,$v0,#BS
FFFC0210 080D0263			beq		$t0,$x0,.doBackspace
FFFC0214 07F84D13			xor		$t0,$v0,#DEL
FFFC0218 020D0263			beq		$t0,$x0,.doDelete
FFFC021C 00004637			sb		$v0,INBUF[$s1]
FFFC0220 10060613
FFFC0224 00460633
FFFC0228 01060023
FFFC022C 00120213			add		$s1,$s1,#1
FFFC0230 00086933			mov		$a0,$v0
FFFC0234 F85FF0EF			call	Putch
FFFC0238 FA000EE3			bra		.0001
                        	.doDelete:
FFFC023C 000262B3			mov		$s2,$s1
FFFC0240 00128293			add		$s2,$s2,#1
                        	.0002:
FFFC0244 00004637			lb		$t0,INBUF[$s2]
FFFC0248 10060613
FFFC024C 00560633
FFFC0250 00060D03
FFFC0254 00004637			sb		$t0,INBUF-1[$s2]
FFFC0258 0FF60613
FFFC025C 00560633
FFFC0260 01A60023
FFFC0264 00128293			add		$s2,$s2,#1
FFFC0268 00004637			add		$t0,$s2,#INBUF
FFFC026C 10060613
FFFC0270 00560D33
FFFC0274 00004637			slt		$t0,$t0,#INBUF+$7F
FFFC0278 17F60613
FFFC027C FC0D14E3			bne		$t0,$x0,.0002
FFFC0280 00004637			sb		$x0,INBUF[$s2]
FFFC0284 10060613
FFFC0288 00560633
FFFC028C 00060023
FFFC0290 F60002E3			bra		.0001
                        	.doBackspace:
FFFC0294 F60200E3			beq		$s1,$x0,.0001		; can't backspace anymore
FFFC0298 00086933			mov		$a0,$v0					; show the backspace
FFFC029C F1DFF0EF			call	Putch
FFFC02A0 FFF20213			sub		$s1,$s1,#1
FFFC02A4 000262B3			mov		$s2,$s1
                        	.0003:
FFFC02A8 00004637			lb		$t0,INBUF+1[$s2]
FFFC02AC 10160613
FFFC02B0 00560633
FFFC02B4 00060D03
FFFC02B8 00004637			sb		$t0,INBUF[$s2]
FFFC02BC 10060613
FFFC02C0 00560633
FFFC02C4 01A60023
FFFC02C8 00128293			add		$s2,$s2,#1
FFFC02CC 00004637			add		$t0,$s2,#INBUF
FFFC02D0 10060613
FFFC02D4 00560D33
FFFC02D8 00004637			slt		$t0,$t0,#INBUF+$7F
FFFC02DC 17F60613
FFFC02E0 FC0D14E3			bne		$t0,$x0,.0003
FFFC02E4 00004637			sb		$x0,INBUF[$s2]
FFFC02E8 10060613
FFFC02EC 00560633
FFFC02F0 00060023
FFFC02F4 F00000E3			bra		.0001
                        	.procLine:
FFFC02F8 00004637			sb		$x0,INBUF[$s1]
FFFC02FC 10060613
FFFC0300 00460633
FFFC0304 00060023
FFFC0308 00006213			ldi		$s1,#0
                        	.skip:
FFFC030C 00004637			lb		$t0,INBUF[$s1]
FFFC0310 10060613
FFFC0314 00460633
FFFC0318 00060D03
FFFC031C 0C0D0C63			beq		$t0,$x0,.0005
FFFC0320 03ED4D93			xor		$t1,$t0,#'>'
FFFC0324 000D9663			bne		$t1,$x0,.0004
                        	.skip2:
FFFC0328 00120213			add		$s1,$s1,#1
FFFC032C FE0000E3			bra		.skip
                        	.0004:
FFFC0330 020D4D93			xor		$t1,$t0,#' '
FFFC0334 FE0D8AE3			beq		$t1,$x0,.skip2
FFFC0338 009D4D93			xor		$t1,$t0,#'\t'
FFFC033C FE0D86E3			beq		$t1,$x0,.skip2
FFFC0340 04DD4D93			xor		$t1,$t0,#'M'
FFFC0344 0A0D8A63			beq		$t1,$x0,doMem
FFFC0348 04206D93			ldi		$t1,#'B'
FFFC034C 05BD1663			bne		$t0,$t1,.0006
FFFC0350 00106913			ldi		$a0,#1					; Start task
FFFC0354 000089B7			ldi		$a1,#32000			; 32 kB
FFFC0358 D0098993
FFFC035C FFFC2A37			ldi		$a2,#CSTART			; start address
FFFC0360 430A0A13
FFFC0364 00000073			ecall
FFFC0368 0008E233			mov		$s1,$v1					; save v1
FFFC036C FFFC1937			ldi		$a0,#msgCRLF
FFFC0370 8EA90913
FFFC0374 394000EF			call	SerialPutString
FFFC0378 00026933			mov		$a0,$s1					; get back v1
FFFC037C 254000EF			call	PutHexByte
FFFC0380 FFFC1937			ldi		$a0,msgTaskStart
FFFC0384 8DC90913
FFFC0388 380000EF			call	SerialPutString
FFFC038C 00D06913			ldi		$a0,#13					; Reschedule task
FFFC0390 00000073			ecall
FFFC0394 E45FF06F			jmp		Monitor
                        	.0006:
FFFC0398 04406D93			ldi		$t1,#'D'
FFFC039C 01BD1863			bne		$t0,$t1,.0007
FFFC03A0 00F06913			ldi		$a0,#15
FFFC03A4 00000073			ecall
FFFC03A8 E31FF06F			jmp		Monitor
                        	.0007:
FFFC03AC 04506D93			ldi		$t1,#'E'
FFFC03B0 01BD1463			bne		$t0,$t1,.0008
FFFC03B4 0CC0006F			jmp		EditMem
                        	.0008:
FFFC03B8 04606D93			ldi		$t1,#'F'
FFFC03BC 01BD1463			bne		$t0,$t1,.0009
FFFC03C0 0D80006F			jmp		FillMem
                        	.0009:
FFFC03C4 05306D93			ldi		$t1,#'S'
FFFC03C8 01BD1863			bne		$t0,$t1,.0010
FFFC03CC 00D06913			ldi		$a0,#13
FFFC03D0 00000073			ecall
FFFC03D4 E05FF06F			jmp		Monitor
                        	.0010:
FFFC03D8 04B06D93			ldi		$t1,#'K'
FFFC03DC 01BD1C63			bne		$t0,$t1,.0011
FFFC03E0 110000EF			call	GetHexNum
FFFC03E4 00306913			ldi		$a0,#3					; kill task
FFFC03E8 000869B3			mov		$a1,$v0					; a0 = pid
FFFC03EC 00000073			ecall
FFFC03F0 DE9FF06F			jmp		Monitor
                        	.0011:
                        	.0005:
FFFC03F4 DE0002E3			bra		Monitor
                        	
                        	doMem:
FFFC03F8 FFC70713			sub		$sp,$sp,#4
FFFC03FC 00120213			add		$s1,$s1,#1
FFFC0400 00472023			sw		$s1,[$sp]
FFFC0404 00D06913			ldi		$a0,#CR
FFFC0408 DB1FF0EF			call	Putch
FFFC040C 00004937			ldi		$a0,INBUF
FFFC0410 10090913
FFFC0414 2F4000EF			call	SerialPutString
FFFC0418 00072203			lw		$s1,[$sp]
FFFC041C 00470713			add		$sp,$sp,#4
FFFC0420 0D0000EF			call	GetHexNum
FFFC0424 00086333			mov		$s3,$v0
FFFC0428 00120213			add		$s1,$s1,#1
FFFC042C 0C4000EF			call	GetHexNum
FFFC0430 006803B3			add		$s4,$v0,$s3
                        	.loop2:
FFFC0434 D6DFF0EF			call	Getch						; check for ctrl-c
FFFC0438 00384813			xor		$v0,$v0,#3
FFFC043C D8080EE3			beq		$v0,$x0,Monitor
FFFC0440 00D06913			ldi		$a0,#CR
FFFC0444 D75FF0EF			call	Putch
FFFC0448 00036933			mov		$a0,$s3
FFFC044C 144000EF			call	PutHexWord
FFFC0450 03A06913			ldi		$a0,#':'
FFFC0454 D65FF0EF			call	Putch
FFFC0458 00706293			ldi		$s2,#7
                        	.loop:
FFFC045C 02006913			ldi		$a0,#' '
FFFC0460 D59FF0EF			call	Putch
FFFC0464 00030903			lb		$a0,[$s3]
FFFC0468 168000EF			call	PutHexByte
FFFC046C 00130313			add		$s3,$s3,#1
FFFC0470 FFF28293			sub		$s2,$s2,#1
FFFC0474 FE02D4E3			bge		$s2,$x0,.loop
FFFC0478 FA736EE3			bltu	$s3,$s4,.loop2
FFFC047C D4000EE3			bra		Monitor		
                        	
                        	EditMem:
FFFC0480 070000EF			call	GetHexNum			; get address to edit
FFFC0484 00086333			mov		$s3,$v0
FFFC0488 00120213			add		$s1,$s1,#1
FFFC048C 064000EF			call	GetHexNum			; get value to set
FFFC0490 00680023			sb		$s3,[$v0]			; update mem
FFFC0494 D45FF06F			jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	;	>F 1000 800 EE
                        	; Fills memory beginning at address $1000 for $800 bytes with the value $EE
                        	;------------------------------------------------------------------------------
                        	
                        	FillMem:
FFFC0498 058000EF			call	GetHexNum			; get address
FFFC049C 00086333			mov		$s3,$v0
FFFC04A0 00120213			add		$s1,$s1,#1
FFFC04A4 04C000EF			call	GetHexNum			; get length
FFFC04A8 000863B3			mov		$s4,$v0
FFFC04AC 00120213			add		$s1,$s1,#1
FFFC04B0 040000EF			call	GetHexNum			; get byte to use
                        	.0001:
FFFC04B4 01030023			sb		$v0,[$s3]
FFFC04B8 FFF38393			sub		$s4,$s4,#1
FFFC04BC FE704CE3			bgt		$s4,$x0,.0001
FFFC04C0 D19FF06F			jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; Skip over spaces and tabs in the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	SkipSpaces:
                        	.skip2:
FFFC04C4 00004637			lb		$t0,INBUF[$s1]
FFFC04C8 10060613
FFFC04CC 00460633
FFFC04D0 00060D03
FFFC04D4 020D4D93			xor		$t1,$t0,#' '
FFFC04D8 000D8863			beq		$t1,$x0,.skip1
FFFC04DC 009D4D93			xor		$t1,$t0,#'\t'
FFFC04E0 000D8463			beq		$t1,$x0,.skip1
FFFC04E4 00008067			ret
                        	.skip1:
FFFC04E8 00120213			add		$s1,$s1,#1
FFFC04EC FC000CE3			bra		.skip2
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a hex number from the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	GetHexNum:
FFFC04F0 00006813			ldi		$v0,#0							; v0 = num
FFFC04F4 FFC70713			sub		$sp,$sp,#4
FFFC04F8 00172023			sw		$ra,[$sp]
FFFC04FC FC9FF0EF			call	SkipSpaces
                        	.next:
FFFC0500 00004637			lb		$t0,INBUF[$s1]
FFFC0504 10060613
FFFC0508 00460633
FFFC050C 00060D03
FFFC0510 03006E13			ldi		$t2,#'0'
FFFC0514 03CD4663			blt		$t0,$t2,.0001
FFFC0518 03A06E13			ldi		$t2,#'9'+1
FFFC051C 07CD4063			blt		$t0,$t2,.isDigit
FFFC0520 04106E13			ldi		$t2,#'A'
FFFC0524 01CD4E63			blt		$t0,$t2,.0001
FFFC0528 04706E13			ldi		$t2,#'F'+1
FFFC052C 03CD4063			blt		$t0,$t2,.isHexUpper
FFFC0530 06106E13			ldi		$t2,#'a'
FFFC0534 01CD4663			blt		$t0,$t2,.0001
FFFC0538 06706E13			ldi		$t2,#'f'+1
FFFC053C 03CD4463			blt		$t0,$t2,.isHexLower
                        	.0001:
FFFC0540 00072083			lw		$ra,[$sp]
FFFC0544 00470713			add		$sp,$sp,#4
FFFC0548 00008067			ret
                        	.isHexUpper:
FFFC054C 00481813			sll		$v0,$v0,#4
FFFC0550 FBFD0D13			sub		$t0,$t0,#'A'
FFFC0554 00AD0D13			add		$t0,$t0,#10
FFFC0558 01A86833			or		$v0,$v0,$t0
FFFC055C 00120213			add		$s1,$s1,#1
FFFC0560 FA0000E3			bra		.next
                        	.isHexLower:
FFFC0564 00481813			sll		$v0,$v0,#4
FFFC0568 F9FD0D13			sub		$t0,$t0,#'a'
FFFC056C 00AD0D13			add		$t0,$t0,#10
FFFC0570 01A86833			or		$v0,$v0,$t0
FFFC0574 00120213			add		$s1,$s1,#1
FFFC0578 F80004E3			bra		.next
                        	.isDigit:
FFFC057C 00481813			sll		$v0,$v0,#4
FFFC0580 FD0D0D13			sub		$t0,$t0,#'0'
FFFC0584 01A86833			or		$v0,$v0,$t0
FFFC0588 00120213			add		$s1,$s1,#1
FFFC058C F6000AE3			bra		.next
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a word as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexWord:
FFFC0590 FF870713			sub		$sp,$sp,#8
FFFC0594 00172023			sw		$ra,[$sp]
FFFC0598 01272223			sw		$a0,4[$sp]
FFFC059C 01095913			srl		$a0,$a0,#16
FFFC05A0 010000EF			call	PutHexHalf
FFFC05A4 00072083			lw		$ra,[$sp]
FFFC05A8 00472903			lw		$a0,4[$sp]
FFFC05AC 00870713			add		$sp,$sp,#8	; fall through to PutHexHalf
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a half-word (16 bits) as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexHalf:
FFFC05B0 FF870713			sub		$sp,$sp,#8
FFFC05B4 00172023			sw		$ra,[$sp]
FFFC05B8 01272223			sw		$a0,4[$sp]
FFFC05BC 00895913			srl		$a0,$a0,#8
FFFC05C0 010000EF			call	PutHexByte
FFFC05C4 00072083			lw		$ra,[$sp]
FFFC05C8 00472903			lw		$a0,4[$sp]		
FFFC05CC 00870713			add		$sp,$sp,#8	; fall through to PutHexByte
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a byte as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexByte:
FFFC05D0 FF870713			sub		$sp,$sp,#8
FFFC05D4 00172023			sw		$ra,[$sp]
FFFC05D8 01272223			sw		$a0,4[$sp]
FFFC05DC 00495913			srl		$a0,$a0,#4		; put the high order nybble first
FFFC05E0 010000EF			call	PutHexNybble
FFFC05E4 00072083			lw		$ra,[$sp]
FFFC05E8 00472903			lw		$a0,4[$sp]
FFFC05EC 00870713			add		$sp,$sp,#8		; fall through to PutHexNybble
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a nybble as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexNybble:
FFFC05F0 FF870713			sub		$sp,$sp,#8
FFFC05F4 00172023			sw		$ra,[$sp]
FFFC05F8 01272223			sw		$a0,4[$sp]
FFFC05FC 00F97913			and		$a0,$a0,#15		; strip off high order bits
FFFC0600 00A06D13			ldi		$t0,#10
FFFC0604 01A94A63			blt		$a0,$t0,.lt10
FFFC0608 FF690913			sub		$a0,$a0,#10
FFFC060C 04190913			add		$a0,$a0,#'A'
FFFC0610 BA9FF0EF			call	Putch
FFFC0614 00000663			bra		.0001
                        	.lt10:
FFFC0618 03090913			add		$a0,$a0,#'0'
FFFC061C B9DFF0EF			call	Putch
                        	.0001:
FFFC0620 00072083			lw		$ra,[$sp]
FFFC0624 00472903			lw		$a0,4[$sp]
FFFC0628 00870713			add		$sp,$sp,#8
FFFC062C 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; VIAInit
                        	;
                        	; Initialize the versatile interface adapter.
                        	;------------------------------------------------------------------------------
                        	
                        	VIAInit:
                        			; Initialize port A low order eight bits as output, the remaining bits as
                        			; input.
FFFC0630 0FF06D13			ldi		$t0,#$000000FF
FFFC0634 FFDC0637			sw		$t0,VIA+VIA_DDRA
FFFC0638 60C60613
FFFC063C 00060633
FFFC0640 01A62023
FFFC0644 00106D13			ldi		$t0,#1							; select timer 3 access
FFFC0648 FFDC0637			sb		$t0,VIA+VIA_PCR+1
FFFC064C 63160613
FFFC0650 00060633
FFFC0654 01A60023
FFFC0658 01F06D13			ldi		$t0,#$1F
FFFC065C FFDC0637			sb		$t0,VIA+VIA_ACR+1		; set timer 3 mode, timer 1/2 = 64 bit
FFFC0660 62D60613
FFFC0664 00060633
FFFC0668 01A60023
FFFC066C 00197D37			ldi		$t0,#$00196E6B			;	divider value for 30Hz
FFFC0670 E6BD0D13
FFFC0674 FFDC0637			sw		$t0,VIA+VIA_T1CL
FFFC0678 61060613
FFFC067C 00060633
FFFC0680 01A62023
FFFC0684 FFDC0637			sw		$x0,VIA+VIA_T1CH		; trigger transfer to count registers
FFFC0688 61460613
FFFC068C 00060633
FFFC0690 00062023
FFFC0694 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPeekChar
                        	;
                        	; Check the serial port status to see if there's a char available. If there's
                        	; a char available then return it.
                        	;
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$v0 = character or -1
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPeekChar:
FFFC0698 FFDC1637			lb		$v0,UART+UART_STAT
FFFC069C A0460613
FFFC06A0 00060633
FFFC06A4 00060803
FFFC06A8 00887813			and		$v0,$v0,#8					; look for Rx not empty
FFFC06AC 00080C63			beq		$v0,$x0,.0001
FFFC06B0 FFDC1637			lb		$v0,UART+UART_TRB
FFFC06B4 A0060613
FFFC06B8 00060633
FFFC06BC 00060803
FFFC06C0 00008067			ret
                        	.0001:
FFFC06C4 FFF06813			ldi		$v0,#-1
FFFC06C8 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPutChar
                        	;    Put a character to the serial transmitter. This routine blocks until the
                        	; transmitter is empty.
                        	;
                        	; Parameters:
                        	;		$a0 = character to put
                        	; Modifies:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPutChar:
FFFC06CC FFC70713			sub		$sp,$sp,#4
FFFC06D0 01072023			sw		$v0,[$sp]
                        	.0001:
FFFC06D4 FFDC1637			lb		$v0,UART+UART_STAT	; wait until the uart indicates tx empty
FFFC06D8 A0460613
FFFC06DC 00060633
FFFC06E0 00060803
FFFC06E4 01087813			and		$v0,$v0,#16					; bit #4 of the status reg
FFFC06E8 FE0806E3			beq		$v0,$x0,.0001				; branch if transmitter is not empty
FFFC06EC FFDC1637			sb		$a0,UART+UART_TRB		; send the byte
FFFC06F0 A0060613
FFFC06F4 00060633
FFFC06F8 01260023
FFFC06FC 00072803			lw		$v0,[$sp]
FFFC0700 00470713			add		$sp,$sp,#4
FFFC0704 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPutString
                        	;    Put a string of characters to the serial transmitter. Calls the 
                        	; SerialPutChar routine, so this routine also blocks if the transmitter is not
                        	; empty.
                        	;
                        	; Parameters:
                        	;		$a0 = pointer to null terminated string to put
                        	; Modifies:
                        	;		$t0 and $t1
                        	; Stack Space:
                        	;		2 words
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPutString:
FFFC0708 FF870713			sub		$sp,$sp,#8				; save link register
FFFC070C 00172023			sw		$ra,[$sp]
FFFC0710 01272223			sw		$a0,4[$sp]				; and argument
FFFC0714 00096DB3			mov		$t1,$a0						; t1 = pointer to string
                        	.0001:
FFFC0718 000D8903			lb		$a0,[$t1]
FFFC071C 001D8D93			add		$t1,$t1,#1				; advance pointer to next byte
FFFC0720 00090663			beq		$a0,$x0,.done			; branch if done
FFFC0724 FA9FF0EF			call	SerialPutChar			; output character
FFFC0728 FE0008E3			bra		.0001
                        	.done:
FFFC072C 00072083			lw		$ra,[$sp]					; restore return address
FFFC0730 00472903			lw		$a0,4[$sp]				; and argument
FFFC0734 00870713			add		$sp,$sp,#8
FFFC0738 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Initialize serial port.
                        	;
                        	; Modifies:
                        	;		$t0
                        	;------------------------------------------------------------------------------
                        	
                        	SerialInit:
FFFC073C 00B06D13			ldi		$t0,#$0B						; dtr,rts active, rxint disabled, no parity
FFFC0740 FFDC1637			sw		$t0,UART+8
FFFC0744 A0860613
FFFC0748 00060633
FFFC074C 01A62023
FFFC0750 00060D37			ldi		$t0,#$0006001E			; reset the fifo's
FFFC0754 01ED0D13
FFFC0758 FFDC1637			sw		$t0,UART+12
FFFC075C A0C60613
FFFC0760 00060633
FFFC0764 01A62023
FFFC0768 01E06D13			ldi		$t0,#$0000001E			; baud 9600, 1 stop bit, 8 bit, internal baud gen
FFFC076C FFDC1637			sw		$t0,UART+12
FFFC0770 A0C60613
FFFC0774 00060633
FFFC0778 01A62023
FFFC077C 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Exception processing code starts here.
                        	;------------------------------------------------------------------------------
                        	.file "cs01rom.asm",541
                        			code
                        			align	4                        	
                        	IRQRout:
FFFC0780 00080737			ldi		$sp,#$80000-4		; setup machine mode stack pointer
FFFC0784 FFC70713
FFFC0788 34201D73			csrrw	$t0,#$342,$x0			; get cause code
FFFC078C 000D4663			blt		$t0,$x0,.isIRQ		; irq or ecall?
FFFC0790 1D00106F			jmp		OSCALL					; 
FFFC0794 10000073			eret										
                        	.isIRQ:
                        	 		; Was it the VIA that caused the interrupt?
FFFC0798 FFDC0637			lb		$t0,VIA+VIA_IFR
FFFC079C 63460613
FFFC07A0 00060633
FFFC07A4 00060D03
FFFC07A8 040D5663			bge		$t0,$x0,.0001			; no
FFFC07AC FFDC0637			lw		$t0,VIA+VIA_T1CL	; yes, clear interrupt
FFFC07B0 61060613
FFFC07B4 00060633
FFFC07B8 00062D03
FFFC07BC 00004637			lw		$t0,milliseconds
FFFC07C0 20860613
FFFC07C4 00060633
FFFC07C8 00062D03
FFFC07CC 01ED0D13			add		$t0,$t0,#30
FFFC07D0 00004637			sw		$t0,milliseconds
FFFC07D4 20860613
FFFC07D8 00060633
FFFC07DC 01A62023
FFFC07E0 00004637			sw		$t0,switchflag
FFFC07E4 20060613
FFFC07E8 00060633
FFFC07EC 01A62023
FFFC07F0 10000073			eret
                        			; Was it the uart that caused the interrupt?
                        	.0001:
FFFC07F4 FFDC1637			lb		$t0,UART+UART_STAT
FFFC07F8 A0460613
FFFC07FC 00060633
FFFC0800 00060D03
FFFC0804 000D4463			blt		$t0,$x0,.0002			; uart cause interrupt?
                        			; Some other interrupt
FFFC0808 10000073			eret
                        	.0002:
FFFC080C 00B06D13			ldi		$t0,#$0B						; dtr,rts active, rxint disabled, no parity
FFFC0810 FFDC1637			sw		$t0,UART+UART_CMD
FFFC0814 A0860613
FFFC0818 00060633
FFFC081C 01A62023
FFFC0820 10000073			eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Message strings
                        	;------------------------------------------------------------------------------
                        	
                        	msgStart:
FFFC0824 31305343			db		"CS01 System Starting.",13
FFFC0828 73795320
FFFC082C 206D6574
FFFC0830 72617453
FFFC0834 676E6974
FFFC0838 6F4D0D2E
                        	msgMonHelp:
FFFC083A 696E6F4D			db		"Monitor Commands",13
FFFC083E 20726F74
FFFC0842 6D6D6F43
FFFC0846 73646E61
FFFC084A 2D20420D
FFFC084B 202D2042			db		"B - start tiny basic",13
FFFC084F 72617473
FFFC0853 69742074
FFFC0857 6220796E
FFFC085B 63697361
FFFC085F 2D20440D
FFFC0860 202D2044			db		"D - dump ready que",13
FFFC0864 706D7564
FFFC0868 61657220
FFFC086C 71207964
FFFC0870 450D6575
FFFC0873 202D2045			db		"E - edit memory",13
FFFC0877 74696465
FFFC087B 6D656D20
FFFC087F 0D79726F
FFFC0883 202D2046			db		"F - fill memory",13
FFFC0887 6C6C6966
FFFC088B 6D656D20
FFFC088F 0D79726F
FFFC0893 743C204B			db		"K <tid> - kill task", 13
FFFC0897 203E6469
FFFC089B 696B202D
FFFC089F 74206C6C
FFFC08A3 0D6B7361
FFFC08A7 733C204D			db		"M <start> <length>	- dump memory",13
FFFC08AB 74726174
FFFC08AF 6C3C203E
FFFC08B3 74676E65
FFFC08B7 2D093E68
FFFC08BB 6D756420
FFFC08BF 656D2070
FFFC08C3 79726F6D
FFFC08C7 2D20530D
FFFC08C8 202D2053			db		"S - switch task",13
FFFC08CC 74697773
FFFC08D0 74206863
FFFC08D4 0D6B7361
FFFC08D8 00000000			db		0
FFFC08D9 20000000			align 
                        	
                        	msgTaskStart:
FFFC08DC 73617420			db		" task started."
FFFC08E0 7473206B
FFFC08E4 65747261
FFFC08E8 0A0D2E64
                        	msgCRLF:
FFFC08EA 00000A0D			db		13,10,0
                        	flt50:
FFFC08ED 00000000		dw	0x00000000,0x00000000,0x00000000,0x40049000
FFFC08F1 00000000
FFFC08F5 00000000
FFFC08F9 40049000
                        	flt20:
FFFC08FD 00000000		dw	0x00000000,0x00000000,0x00000000,0x40034000
FFFC0901 00000000
FFFC0905 00000000
FFFC0909 40034000
                        	flt10:
FFFC090D 00000000		dw	0x00000000,0x00000000,0x00000000,0x40024000
FFFC0911 00000000
FFFC0915 00000000
FFFC0919 40024000
                        	
                        	.file "fltToString.asm",1
                        	.file "fltToString.asm",1
                        	STRTMP		equ		$0200
                        	
                        	; -----------------------------------------------------------------------------
                        	;		$fa0 = number to convert (f18)
                        	;		$a1	= width
                        	;		$a2 = precision
                        	;		$a3 = E
                        	;		$t2 = ndx
                        	;		$s9 = exp
                        	; -----------------------------------------------------------------------------
                        	
                        	fltToString:
FFFC091D 006E1300			ldi		$t2,#0				; $t2 = 0
FFFC0921 09095300
FFFC0922 E0090953			fmv		$a0,$f18
FFFC0926 7F800637			and		$t0,$a0,#$7F800000
FFFC092A 00060613
FFFC092E 01267D33
FFFC0932 7F800DB7			ldi		$t1,#$7F800000
FFFC0936 000D8D93
FFFC093A 05BD1263			bne		$t0,$t1,.0001
FFFC093E 00800637			and		$t0,$a0,#$007FFFFF
FFFC0942 FFF60613
FFFC0946 01267D33
FFFC094A 000D0E63			beq		$t0,$x0,.inf
FFFC094E FFFC1637			ldt		$t0,msgNan
FFFC0952 CD860613
FFFC0956 00060633
FFFC095A 00062D03
FFFC095E 21A02023			stt		$t0,STRTMP
FFFC0962 2E000E63			bra		.prt
                        	.inf:
FFFC0966 FFFC1637			ldt		$t0,msgInf
FFFC096A CD460613
FFFC096E 00060633
FFFC0972 00062D03
FFFC0976 21A02023			stt		$t0,STRTMP
FFFC097A 2E000263			bra		.prt
                        	.0001:
FFFC097E 80000637			and		$t0,$a0,#$80000000
FFFC0982 00060613
FFFC0986 01267D33
FFFC098A 000D0E63			beq		$t0,$x0,.pos
FFFC098E 02D06D13			ldi		$t0,#'-'
FFFC0992 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0996 001E0E13			add		$t2,$t2,#1
FFFC099A 80000637			and		$a0,$a0,#$7FFFFFFF
FFFC099E FFF60613
FFFC09A2 01267933
                        	.pos:
FFFC09A6 00091A63			bne		$a0,$x0,.notZero
FFFC09AA 03006D13			ldi		$t0,#'0'
FFFC09AE 21AE0023			stb		$t0,STRTMP[$t2]
FFFC09B2 200E00A3			stb		$x0,STRTMP+1[$t2]
FFFC09B6 2A000463			bra		.prt		
                        	.notZero:
FFFC09BA 00006633			mov		$s9,$x0			; exp = 0.0
                        	;	// Make a small number > 0 so we can get at the digits.
                        	;	if (dbl < 1.0) {
                        	;		while (dbl < 1.0) {
                        	;			dbl *= 1000000.0;
                        	;			exp -= 6;  
                        	;		}
                        	;	}
FFFC09BE FFFC1637			flw		$f3,fltOne
FFFC09C2 CDC60613
FFFC09C6 00060633
FFFC09CA 00062187
FFFC09CE F0090053			fmv		$f0,$a0
FFFC09D2 A0391D53			flt		$t0,$f18,$f3
FFFC09D6 020D0463			beq		$t0,$x0,.0002
FFFC09DA FFFC1637			flw		$f4,fltMillion
FFFC09DE CE460613
FFFC09E2 00060633
FFFC09E6 00062207
                        	.0003:
FFFC09EA A0391D53			flt		$t0,$f18,$f3
FFFC09EE 000D0863			beq		$t0,$x0,.0002
FFFC09F2 10490953			fmul	$f18,$f18,$f4
FFFC09F6 FFA60613			sub		$s9,$s9,#6
FFFC09FA FE0008E3			bra		.0003
                        	.0002:
                        	;	// The following is similar to using log10() and pow() functions.
                        	;	// Now dbl is >= 1.0
                        	;	// Create a number dbl2 on the same order of magnitude as dbl, but
                        	;	// less than dbl.
                        	;	dbl2 = 1.0;
                        	;	dbla = dbl2;
                        	;	if (dbl > dbl2) {	// dbl > 1.0 ?
                        	;		while (dbl2 <= dbl) {
                        	;			dbla = dbl2;
                        	;			dbl2 *= 10.0;	// increase power of 10
                        	;			exp++;
                        	;		}
                        	;		// The above loop goes one too far, we want the last value less
                        	;		// than dbl.
                        	;		dbl2 = dbla;
                        	;		exp--;
                        	;	}
FFFC09FE FFFC1637			flw		$f1,fltOne				; $f1 = dbl2 = 1.0
FFFC0A02 CDC60613
FFFC0A06 00060633
FFFC0A0A 00062087
FFFC0A0E 38008153			fmov	$f2,$f1						; $f2 = dbla = dbl2
FFFC0A12 A1209D53			flt		$t0,$f1,$f18				; if (dbl2 < dbl)
FFFC0A16 020D0A63			beq		$t0,$x0,.0004
FFFC0A1A FFFC1637			flw		$f5,fltTen				; $f5 = 10.0
FFFC0A1E CE060613
FFFC0A22 00060633
FFFC0A26 00062287
                        	.0006:
FFFC0A2A A1208D53			fle		$t0,$f1,$f18				; while ($f1 <= $f18)
FFFC0A2E 000D0A63			beq		$t0,$x0,.0005
FFFC0A32 38008153			fmov	$f2,$f1						; dbla = dbl2
FFFC0A36 105080D3			fmul	$f1,$f1,$f5				; dbl2 *= 10.0
FFFC0A3A 00160613			add		$s9,$s9,#1				; exp++;
FFFC0A3E FE0006E3			bra		.0006
                        	.0005:
FFFC0A42 380100D3			fmov	$f1,$f2						; dbl2 = dbla
FFFC0A46 FFF60613			sub		$s9,$s9,#1				; exp--;
                        	.0004:
                        	;	// For small constants < 1000000 try and spit out a whole number
                        	;    if (exp >= 0 && exp < 6) {
                        	;        digits_before_decpt = exp+1;
                        	;		exp = 0;
                        	;	}
                        	;	else if (exp >= -6)
                        	;		digits_before_decpt = 1;
                        	;	else
                        	;		digits_before_decpt = -1;
FFFC0A4A 00064E63			blt		$s9,$x0,.0007
FFFC0A4E 00606413			ldi		$s5,#6
FFFC0A52 00865A63			bge		$s9,$s5,.0007
FFFC0A56 FFFFE233			mov		$s1,#s0						; s1 = digits before decpt
FFFC0A5A 00120213			add		$s1,$s1,#1
FFFC0A5E 00006613			ldi		$s9,#0						; exp = 0
FFFC0A62 00000C63			bra		.0008
                        	.0007:
FFFC0A66 FF906413			ldi		$s5,#-7
FFFC0A6A 00864663			blt		$s9,$s5,.0009
FFFC0A6E 00106213			ldi		$s1,#1
FFFC0A72 00000463			bra		.0008
                        	.0009:
FFFC0A76 FFF06213			ldi		$s1,#-1
                        	.0008:
                        	;	// Spit out a leading zero before the decimal point for a small number.
                        	;    if (exp < -6) {
                        	;		buf[ndx] = '0';
                        	;		ndx++;
                        	;        buf[ndx] = '.';
                        	;        ndx++;
                        	;    }
FFFC0A7A FFA06413			ldi		$s5,#-6
FFFC0A7E 00865E63			bge		$s9,$s5,.0010
FFFC0A82 03006D13			ldi		$t0,#'0'
FFFC0A86 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0A8A 001E0E13			add		$t2,$t2,#1
FFFC0A8E 02E06D13			ldi		$t0,#'.'
FFFC0A92 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0A96 001E0E13			add		$t2,$t2,#1
                        	.0010:
                        	;	// Now loop processing one digit at a time.
                        	;    for (nn = 0; nn < 30 && precision > 0; nn++) {
                        	;        digit = 0;
                        	;		dbla = dbl;
                        	;		// dbl is on the same order of magnitude as dbl2 so
                        	;		// a repeated subtract can be used to find the digit.
                        	;        while (dbl >= dbl2) {
                        	;            dbl -= dbl2;
                        	;            digit++;
                        	;        }
                        	;        buf[ndx] = digit + '0';
                        	;		// Now go back and perform just a single subtract and
                        	;		// a multiply to find out how much to reduce dbl by.
                        	;		// This should improve the accuracy
                        	;		if (digit > 2)
                        	;			dbl = dbla - dbl2 * digit;
                        	;        ndx++;
                        	;        digits_before_decpt--;
                        	;        if (digits_before_decpt==0) {
                        	;           buf[ndx] = '.';
                        	;           ndx++;
                        	;        }
                        	;        else if (digits_before_decpt < 0)
                        	;            precision--;
                        	;		// Shift the next digit to be tested into position.
                        	;        dbl *= 10.0;
                        	;    }
FFFC0A9A 00006313			ldi		$s3,#0						; s3 = nn = 0
FFFC0A9E 01E06413			ldi		$s5,#30
FFFC0AA2 FFFC1637			flw		$f7,fltTen				; f7 = 10.0
FFFC0AA6 CE060613
FFFC0AAA 00060633
FFFC0AAE 00062387
                        	.0016:
FFFC0AB2 00832D33			slt		$t0,$s3,$s5
FFFC0AB6 060D0863			beq		$t0,$x0,.0011
FFFC0ABA 00006413			ldi		$s5,#0
FFFC0ABE 07445463			bge		$s5,$a2,.0011			; (0 < precision)
FFFC0AC2 00006393			ldi		$s4,#0						; s4 = digit = 0
FFFC0AC6 38090153			fmov	$f2,$f18						; dbla = dbl
                        	.0013:
FFFC0ACA A1208D53			fle		$t0,$f1,$f18						; while (dbl2 <= dbl)
FFFC0ACE 000D0863			beq		$t0,$x0,.0012
FFFC0AD2 08190953			fsub	$f18,$f18,$f1						; dbl -= dbl2
FFFC0AD6 00138393			add		$s4,$s4,#1						; digit++
FFFC0ADA FE0008E3			bra		.0013
                        	.0012:
FFFC0ADE 03038413			add		$s5,$s4,#'0'			; buf[ndx] = digit + '0'
FFFC0AE2 208E0023			stb		$s5,STRTMP[$t2]
FFFC0AE6 00206413			ldi		$s5,#2						; if (2 < digit)
FFFC0AEA 00745863			bge		$s5,$s4,.0014
FFFC0AEE D00382D3			fcvt.s.w	$f5,$s4				; f5 = digit as float
FFFC0AF2 10508353			fmul	$f6,$f1,$f5				; f6 = dbl2 * digit
FFFC0AF6 08610953			fsub	$f18,$f2,$f6				; dbl = dbla - dbl2 * digit
                        	.0014:
FFFC0AFA 001E0E13			add		$t2,$t2,#1				; ndx++
FFFC0AFE FFF20213			sub		$s1,$s1,#1				; digits_before_decpt--;
FFFC0B02 00021A63			bne		$s1,$x0,.0015			; if (digits_before_decpt==0)
FFFC0B06 02E06D13			ldi		$t0,#'.'
FFFC0B0A 21AE0023			stb		$t0,STRTMP[$t2]		; buf[ndx] = '.'
FFFC0B0E 001E0E13			add		$t2,$t2,#1				; ndx++
FFFC0B12 00000663			bra		.0017
                        	.0015:
FFFC0B16 00025463			bge		$s1,$x0,.0017			; else if (digits_before_decpt < 0)
FFFC0B1A FFFA0A13			sub		$a2,$a2,#1				; 	precision--
                        	.0017:
FFFC0B1E 10790953			fmul	$f18,$f18,$f7				; dbl *= 10.0
FFFC0B22 F80008E3			bra		.0016
                        	.0011:
                        	;	// Trim trailing zeros from the number
                        	;    do {
                        	;        ndx--;
                        	;    } while(buf[ndx]=='0');
                        	;    ndx++;
                        	.0018:
FFFC0B26 FFFE0E13			sub		$t2,$t2,#1				; ndx--
FFFC0B2A 200E0D03			ldb		$t0,STRTMP[$t2]
FFFC0B2E 030D4D13			xor		$t0,$t0,#'0'
FFFC0B32 FE0D0AE3			beq		$t0,$x0,.0018
FFFC0B36 001E0E13			add		$t2,$t2,#1				; ndx++
                        	;	// Make sure we have at least one digit after the decimal point.
                        	;	if (buf[ndx]=='.') {
                        	;		ndx++;
                        	;		buf[ndx]='0';
                        	;		ndx++;
                        	;        buf[ndx]='\0';
                        	;	}
FFFC0B3A 200E0D03			ldb		$t0,STRTMP[$t2]
FFFC0B3E 02ED4D13			xor		$t0,$t0,#'.'
FFFC0B42 000D1C63			bne		$t0,$x0,.0019
FFFC0B46 001E0E13			add		$t2,$t2,#1
FFFC0B4A 03006D13			ldi		$t0,#'0'
FFFC0B4E 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0B52 001E0E13			add		$t2,$t2,#1
FFFC0B56 200E0023			stb		$x0,STRTMP[$t2]
                        	.0019:
                        	;	// If the number is times 10^0 don't output the exponent
                        	;   if (exp==0) {
                        	;        buf[ndx]='\0';
                        	;        goto prt;
                        	;    }
FFFC0B5A 00061663			bne		$s9,$x0,.0020
FFFC0B5E 200E0023			stb		$x0,STRTMP[$t2]
FFFC0B62 0E000E63			bra		.prt
                        	.0020:
                        	;	// Spit out +/-E
                        	;    buf[ndx] = E;
                        	;    ndx++;
                        	;    if (exp < 0) {
                        	;        buf[ndx]='-';
                        	;        ndx++;
                        	;        exp = -exp;
                        	;    }
                        	;    else {
                        	;         buf[ndx]='+';
                        	;         ndx++;
                        	;    }
FFFC0B66 04506D13			ldi		$t0,#'E'
FFFC0B6A 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0B6E 001E0E13			add		$t2,$t2,#1
FFFC0B72 00065C63			bge		$s9,$x0,.0021
FFFC0B76 02D06D13			ldi		$t0,#'-'
FFFC0B7A 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0B7E 001E0E13			add		$t2,$t2,#1
FFFC0B82 40C00633			sub		$s9,$x0,$s9			; exp = -exp
FFFC0B86 00000863			bra		.0022
                        	.0021:
FFFC0B8A 02B06D13			ldi		$t0,#'+'
FFFC0B8E 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0B92 001E0E13			add		$t2,$t2,#1
                        	.0022:
                        	;	// now process the exponent
                        	;    digit = 0;
                        	;    while (exp >= 1000) {
                        	;        exp -= 1000;
                        	;        digit++;
                        	;    }
FFFC0B96 00006393			ldi		$s4,#0
FFFC0B9A 3E806D13			ldi		$t0,#1000
                        	.0025:
FFFC0B9E 01A65463			bge		$s9,$t0,.0023
FFFC0BA2 00000863			bra		.0024
                        	.0023:
FFFC0BA6 41A60633			sub		$s9,$s9,$t0
FFFC0BAA 00138393			add		$s4,$s4,#1
FFFC0BAE FE0008E3			bra		.0025
                        	.0024:
                        	;	d1 = digit;
                        	;	if (digit) {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0BB2 0003E4B3			mov		$s6,$s4					; s6 = d1 = s4 = digit
FFFC0BB6 00039863			bne		$s4,$x0,.0026
FFFC0BBA 03038D13			add		$t0,$s4,#'0'
FFFC0BBE 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0BC2 001E0E13			add		$t2,$t2,#1
                        	.0026:
                        	;	digit = 0;
                        	;    while (exp >= 100) {
                        	;        exp -= 100;
                        	;        digit++;
                        	;    }
FFFC0BC6 00006393			ldi		$s4,#0
FFFC0BCA 06406D13			ldi		$t0,#100
                        	.0027:
FFFC0BCE 01A65463			bge		$s9,$t0,.0028
FFFC0BD2 00000863			bra		.0029
                        	.0028:
FFFC0BD6 41A60633			sub		$s9,$s9,$t0
FFFC0BDA 00138393			add		$s4,$s4,#1
FFFC0BDE FE0008E3			bra		.0027
                        	.0029:	
                        	;	d2 = digit;
                        	;	if (digit==0 && d1==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0BE2 0003E533			mov		$s7,$s4				; $s7 = d2
FFFC0BE6 00049463			bne		$s6,$x0,.0030
FFFC0BEA 00038863			beq		$s4,$x0,.0031
                        	.0030:
FFFC0BEE 03038D13			add		$t0,$s4,#'0'
FFFC0BF2 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0BF6 001E0E13			add		$t2,$t2,#1
                        	.0031:
                        	;	digit = 0;
                        	;    while (exp >= 10) {
                        	;        exp -= 10;
                        	;        digit++;
                        	;    }
FFFC0BFA 00006393			ldi		$s4,#0
FFFC0BFE 00A06D13			ldi		$t0,#10
                        	.0032:
FFFC0C02 01A65463			bge		$s9,$t0,.0034
FFFC0C06 00000863			bra		.0035
                        	.0034:
FFFC0C0A 41A60633			sub		$s9,$s9,$t0
FFFC0C0E 00138393			add		$s4,$s4,#1
FFFC0C12 FE0008E3			bra		.0032
                        	.0035:	
                        	;	d3 = digit;
                        	;	if (digit==0 && d1==0 && d2==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0C16 0003E5B3			mov		$s8,$s4
FFFC0C1A 00039663			bne		$s4,$x0,.0036
FFFC0C1E 00049463			bne		$s6,$x0,.0036
FFFC0C22 00050863			beq		$s7,$x0,.0037
                        	.0036:
FFFC0C26 03038D13			add		$t0,$s4,#'0'
FFFC0C2A 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0C2E 001E0E13			add		$t2,$t2,#1
                        	.0037:
                        	;	digit = 0;
                        	;    while (exp >= 1) {
                        	;        exp -= 1;
                        	;        digit++;
                        	;    }
FFFC0C32 00006393			ldi		$s4,#0
FFFC0C36 00106D13			ldi		$t0,#1
                        	.0038:
FFFC0C3A 01A65463			bge		$s9,$t0,.0040
FFFC0C3E 00000863			bra		.0039
                        	.0040:
FFFC0C42 41A60633			sub		$s9,$s9,$t0
FFFC0C46 00138393			add		$s4,$s4,#1
FFFC0C4A FE0008E3			bra		.0038
                        	.0039:	
                        	;    buf[ndx] = digit + '0';
                        	;    ndx++;
                        	;    buf[ndx] = '\0';
FFFC0C4E 03038D13			add		$t0,$s4,#'0'
FFFC0C52 21AE0023			sb		$t0,STRTMP[$t2]
FFFC0C56 001E0E13			add		$t2,$t2,#1
FFFC0C5A 200E0023			sb		$x0,STRTMP[$t2]
                        	;	// Now pad the number on the left or right as requested.
                        	.prt:
                        	;    // pad left
                        	;    if (width > 0) {
                        	;        if (ndx < width) {
                        	;            for (nn = 39; nn >= width-ndx; nn--)
                        	;                buf[nn] = buf[nn-(width-ndx)];
                        	;            for (; nn >= 0; nn--)
                        	;                buf[nn] = ' ';
                        	;        }
                        	;    }
FFFC0C5E 0409C663			blt		$a1,$x0,.0041
FFFC0C62 04098463			beq		$a1,$x0,.0041
FFFC0C66 013E4463			blt		$t2,$a1,.0042
FFFC0C6A 04000063			bra		.0041
                        	.0042:
FFFC0C6E 02706313			ldi		$s3,#39					; s3 = nn
FFFC0C72 41C98D33			sub		$t0,$a1,$t2			; width-ndx
                        	.0045:
FFFC0C76 01A35463			bge		$s3,$t0,.0043
FFFC0C7A 00000C63			bra		.0044
                        	.0043:
FFFC0C7E 41A304B3			sub		$s6,$s3,$t0			; nn-(width-ndx)
FFFC0C82 20030D83			ldb		$t1,STRTMP[$s3]
FFFC0C86 21B48023			stb		$t1,STRTMP[$s6]
FFFC0C8A FFF30313			sub		$s3,$s3,#1
FFFC0C8E FE0004E3			bra		.0045
                        	.0044:
FFFC0C92 02006D13			ldi		$t0,#' '
                        	.0048:
FFFC0C96 00035463			bge		$s3,$x0,.0046
FFFC0C9A 00000863			bra		.0047
                        	.0046:
FFFC0C9E 21A30023			stb		$t0,STRTMP[$s3]
FFFC0CA2 FFF30313			sub		$s3,$s3,#1
FFFC0CA6 FE0008E3			bra		.0048
                        	.0047:
                        	.0041:
                        	;    // pad right
                        	;    if (width < 0) {
                        	;        width = -width;
                        	;        while (ndx < width) {
                        	;            buf[ndx]=' ';
                        	;            ndx++;
                        	;        }
                        	;        buf[ndx]='\0';
                        	;    }
                        	;    return (ndx);
FFFC0CAA 0209D063			bge		$a1,$x0,.0050
FFFC0CAE 413009B3			sub		$a1,$x0,$a1
FFFC0CB2 02006D13			ldi		$t0,#' '
                        	.0052:
FFFC0CB6 013E5863			bge		$t2,$a1,.0051
FFFC0CBA 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0CBE 001E0E13			add		$t2,$t2,#1
FFFC0CC2 FE000AE3			bra		.0052
                        	.0051:
FFFC0CC6 200E0023			stb		$x0,STRTMP[$t2]
                        	.0050:
FFFC0CCA 000E6833			mov		$v0,$t2
FFFC0CCE 00008067			ret
                        	
FFFC0CD2 6E490000			align	
                        	
                        	msgInf:
FFFC0CD4 00666E49			db	"Inf",0
                        	msgNan:
FFFC0CD8 006E614E			db	"Nan",0
                        	fltOne:
FFFC0CDC 3F800000			dw		$3F800000					; 1.0
                        	fltTen:
FFFC0CE0 41200000			dw		$41200000					; 10.0
                        	fltMillion:
FFFC0CE4 49742400			dw		$49742400					; 1,000,000
                        	
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "cs01Mem.asm",1
                        	.file "cs01Mem.asm",1
                        	NPAGES	equ		$4300
                        	PAM			equ		$4800
                        	
                        	.file "cs01Mem.asm",5
                        			code	18 bits
                        			align	4                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	MMUInit:
FFFC0CE8 0F606D13			ldi		$t0,#246				; set number of available pages (10 pages already allocated)
FFFC0CEC 00004637			sw		$t0,NPAGES			
FFFC0CF0 30060613
FFFC0CF4 00060633
FFFC0CF8 01A62023
                        			; Setup PAM
FFFC0CFC 1FF06D13			ldi		$t0,#$1FF				; permanently allocate pages for OS data
FFFC0D00 00005637			sw		$t0,PAM
FFFC0D04 80060613
FFFC0D08 00060633
FFFC0D0C 01A62023
FFFC0D10 00005637			sw		$x0,PAM+4
FFFC0D14 80460613
FFFC0D18 00060633
FFFC0D1C 00062023
FFFC0D20 00005637			sw		$x0,PAM+8
FFFC0D24 80860613
FFFC0D28 00060633
FFFC0D2C 00062023
FFFC0D30 00005637			sw		$x0,PAM+12
FFFC0D34 80C60613
FFFC0D38 00060633
FFFC0D3C 00062023
FFFC0D40 00005637			sw		$x0,PAM+16
FFFC0D44 81060613
FFFC0D48 00060633
FFFC0D4C 00062023
FFFC0D50 00005637			sw		$x0,PAM+20
FFFC0D54 81460613
FFFC0D58 00060633
FFFC0D5C 00062023
FFFC0D60 00005637			sw		$x0,PAM+24
FFFC0D64 81860613
FFFC0D68 00060633
FFFC0D6C 00062023
FFFC0D70 80000D37			ldi		$t0,#$80000000	; last page is system stack
FFFC0D74 000D0D13
FFFC0D78 00005637			sw		$t0,PAM+28
FFFC0D7C 81C60613
FFFC0D80 00060633
FFFC0D84 01A62023
FFFC0D88 00006D13			ldi		$t0,#$00
FFFC0D8C 00006D93			ldi		$t1,#$000				; regno
FFFC0D90 00001E37			ldi		$t2,#4096				; number of registers to update
FFFC0D94 000E0E13
FFFC0D98 00A06E93			ldi		$t3,#10					; number of pages pre-allocated
                        	.0001:
FFFC0D9C 03BD000D			mvmap	$x0,$t0,$t1
FFFC0DA0 001D0D13			add		$t0,$t0,#$01
FFFC0DA4 001D8D93			add		$t1,$t1,#$01		; increment page number
FFFC0DA8 01DDE463			bltu	$t1,$t3,.0003
FFFC0DAC 00006D33			mov		$t0,$x0					; mark pages after 9 unallocated
                        	.0003:
FFFC0DB0 FFFE0E13			sub		$t2,$t2,#1
FFFC0DB4 FE0E14E3			bne		$t2,$x0,.0001
FFFC0DB8 0FF06D93			ldi		$t1,#$0FF				; allocate last page for stack
FFFC0DBC 0FF06D13			ldi		$t0,#$FF
FFFC0DC0 03BD000D			mvmap	$x0,$t0,$t1
                        			; Now setup segment registers
FFFC0DC4 00006D13			ldi		$t0,#$0
FFFC0DC8 00706D93			ldi		$t1,#$07				; t1 = value to load RWX=111, base = 0
                        	.0002:
FFFC0DCC 01AD800D			mvseg	$x0,$t1,$t0			; move to the segment register identifed by t0
FFFC0DD0 001D0D13			add		$t0,$t0,#1			; pick next segment register
FFFC0DD4 010D2E13			slt		$t2,$t0,#16			; 16 segment regs
FFFC0DD8 FE0E1AE3			bne		$t2,$x0,.0002
FFFC0DDC 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Allocate a single page of memory. Available memory is indicated by a bitmmap
                        	; called the PAM for page allocation map.
                        	; There's only eight words to check so an unrolled loop works here.
                        	;
                        	; Modifies:
                        	;		t0,t1,t2
                        	; Returns:
                        	;		v0 = page allocated
                        	;------------------------------------------------------------------------------
                        	;
                        	AllocPage:
FFFC0DE0 FFC70713		sub		$sp,$sp,#4
FFFC0DE4 00172023		sw		$ra,[$sp]
FFFC0DE8 00005637		lw		$t0,PAM
FFFC0DEC 80060613
FFFC0DF0 00060633
FFFC0DF4 00062D03
FFFC0DF8 00000DB7		ldi		$t1,#$FFFFFFFF
FFFC0DFC FFFD8D93
FFFC0E00 01BD0E63		beq		$t0,$t1,.chkPam4
FFFC0E04 178000EF		call	BitIndex
FFFC0E08 00005637		sw		$t0,PAM
FFFC0E0C 80060613
FFFC0E10 00060633
FFFC0E14 01A62023
FFFC0E18 14000C63		bra		.0001
                        	.chkPam4:
FFFC0E1C 00005637		lw		$t0,PAM+4
FFFC0E20 80460613
FFFC0E24 00060633
FFFC0E28 00062D03
FFFC0E2C 03BD0063		beq		$t0,$t1,.chkPam8
FFFC0E30 14C000EF		call	BitIndex
FFFC0E34 00005637		sw		$t0,PAM+4
FFFC0E38 80460613
FFFC0E3C 00060633
FFFC0E40 01A62023
FFFC0E44 02080813		add		$v0,$v0,#32
FFFC0E48 12000463		bra		.0001
                        	.chkPam8:
FFFC0E4C 00005637		lw		$t0,PAM+8
FFFC0E50 80860613
FFFC0E54 00060633
FFFC0E58 00062D03
FFFC0E5C 03BD0063		beq		$t0,$t1,.chkPam12
FFFC0E60 11C000EF		call	BitIndex
FFFC0E64 00005637		sw		$t0,PAM+8
FFFC0E68 80860613
FFFC0E6C 00060633
FFFC0E70 01A62023
FFFC0E74 04080813		add		$v0,$v0,#64
FFFC0E78 0E000C63		bra		.0001
                        	.chkPam12:
FFFC0E7C 00005637		lw		$t0,PAM+12
FFFC0E80 80C60613
FFFC0E84 00060633
FFFC0E88 00062D03
FFFC0E8C 03BD0063		beq		$t0,$t1,.chkPam16
FFFC0E90 0EC000EF		call	BitIndex
FFFC0E94 00005637		sw		$t0,PAM+12
FFFC0E98 80C60613
FFFC0E9C 00060633
FFFC0EA0 01A62023
FFFC0EA4 06080813		add		$v0,$v0,#96
FFFC0EA8 0C000463		bra		.0001
                        	.chkPam16:
FFFC0EAC 00005637		lw		$t0,PAM+16
FFFC0EB0 81060613
FFFC0EB4 00060633
FFFC0EB8 00062D03
FFFC0EBC 03BD0063		beq		$t0,$t1,.chkPam20
FFFC0EC0 0BC000EF		call	BitIndex
FFFC0EC4 00005637		sw		$t0,PAM+16
FFFC0EC8 81060613
FFFC0ECC 00060633
FFFC0ED0 01A62023
FFFC0ED4 08080813		add		$v0,$v0,#128
FFFC0ED8 08000C63		bra		.0001
                        	.chkPam20:
FFFC0EDC 00005637		lw		$t0,PAM+20
FFFC0EE0 81460613
FFFC0EE4 00060633
FFFC0EE8 00062D03
FFFC0EEC 03BD0063		beq		$t0,$t1,.chkPam24
FFFC0EF0 08C000EF		call	BitIndex
FFFC0EF4 00005637		sw		$t0,PAM+20
FFFC0EF8 81460613
FFFC0EFC 00060633
FFFC0F00 01A62023
FFFC0F04 0A080813		add		$v0,$v0,#160
FFFC0F08 06000463		bra		.0001
                        	.chkPam24:
FFFC0F0C 00005637		lw		$t0,PAM+24
FFFC0F10 81860613
FFFC0F14 00060633
FFFC0F18 00062D03
FFFC0F1C 03BD0063		beq		$t0,$t1,.chkPam28
FFFC0F20 05C000EF		call	BitIndex
FFFC0F24 00005637		sw		$t0,PAM+24
FFFC0F28 81860613
FFFC0F2C 00060633
FFFC0F30 01A62023
FFFC0F34 0C080813		add		$v0,$v0,#192
FFFC0F38 02000C63		bra		.0001
                        	.chkPam28:
FFFC0F3C 00005637		lw		$t0,PAM+28
FFFC0F40 81C60613
FFFC0F44 00060633
FFFC0F48 00062D03
FFFC0F4C 03BD0063		beq		$t0,$t1,.chkPamDone
FFFC0F50 02C000EF		call	BitIndex
FFFC0F54 00005637		sw		$t0,PAM+28
FFFC0F58 81C60613
FFFC0F5C 00060633
FFFC0F60 01A62023
FFFC0F64 0E080813		add		$v0,$v0,#224
FFFC0F68 00000463		bra		.0001
                        	.chkPamDone:
FFFC0F6C 00006813		ldi		$v0,#0						; no memory available
                        	.0001:
FFFC0F70 00072083		lw		$ra,[$sp]
FFFC0F74 00470713		add		$sp,$sp,#4
FFFC0F78 00008067		ret
                        	
                        	; Returns:
                        	;		v0 = bit index of allocated page
                        	;
                        	BitIndex:
FFFC0F7C 00006813		ldi		$v0,#0
                        	.0001:
FFFC0F80 001D7E13		and		$t2,$t0,#1
FFFC0F84 000E0E63		beq		$t2,$x0,.foundFree
FFFC0F88 001D5D13		srl		$t0,$t0,#1
FFFC0F8C 80000637		or		$t0,$t0,#$80000000	; do a rotate, we know bit = 1
FFFC0F90 00060613
FFFC0F94 01A66D33
FFFC0F98 00180813		add		$v0,$v0,#1
FFFC0F9C FE0002E3		bra		.0001
                        	.foundFree:
FFFC0FA0 001D6D13		or		$t0,$t0,#1					; mark page allocated
FFFC0FA4 00086DB3		mov		$t1,$v0
FFFC0FA8 000D8A63		beq		$t1,$x0,.0003
                        	.0004:
FFFC0FAC 001D1D13		sll		$t0,$t0,#1					; do a rotate
FFFC0FB0 001D6D13		or		$t0,$t0,#1					; we know bit = 1
FFFC0FB4 FFFD8D93		sub		$t1,$t1,#1
FFFC0FB8 FE0D9AE3		bne		$t1,$x0,.0004
                        	.0003:
FFFC0FBC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = page number to free
                        	; Modifies:
                        	;		v0,v1,t0
                        	;------------------------------------------------------------------------------
                        	
                        	FreePage:
FFFC0FC0 0FF06813		ldi		$v0,#255						; last page is permanently allocated to system stack
FFFC0FC4 05097263		bgeu	$a0,$v0,.xit
FFFC0FC8 00906813		ldi		$v0,#9
FFFC0FCC 03096E63		bltu	$a0,$v0,.xit				; first 9 pages (18kB) allocated permanently to system
FFFC0FD0 00595813		srl		$v0,$a0,#5					; v0 = word
FFFC0FD4 01F97893		and		$v1,$a0,#31					; v1 = bit no
FFFC0FD8 00106D13		ldi		$t0,#1							; make a bitmask
FFFC0FDC 011D1D13		sll		$t0,$t0,$v1
FFFC0FE0 FFFD4D13		xor		$t0,$t0,#-1					; invert mask
FFFC0FE4 00005637		lw		$v1,PAM[$v0]
FFFC0FE8 80060613
FFFC0FEC 01060633
FFFC0FF0 00062883
FFFC0FF4 01A8F8B3		and		$v1,$v1,$t0					; clear bit
FFFC0FF8 00005637		sw		$v1,PAM[$v0]				; save PAM word back
FFFC0FFC 80060613
FFFC1000 01060633
FFFC1004 01162023
                        	.xit:
FFFC1008 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Find a run of buckets available for mapping virtual to physical addresses.
                        	;
                        	; Parameters:
                        	;		a0 = pid
                        	;		a1 = number of pages required.
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		v0 = starting bucket number (includes ASID), -1 if no run found
                        	;------------------------------------------------------------------------------
                        	
                        	FindRun:
FFFC100C 00F97E93		and			$t3,$a0,#$0F			; t3 = pid
FFFC1010 008E9E93		sll			$t3,$t3,#8				; shift into usable position
FFFC1014 00006D93		ldi			$t1,#0						; t1 = count of consecutive empty buckets
FFFC1018 000EEE33		mov			$t2,$t3						; t2 = map entry number
FFFC101C 0FF06F93		ldi			$t5,#255					; max number of pages - 1
FFFC1020 01DFEFB3		or			$t5,$t5,$t3				; t5 = max in ASID
                        	.0001:
FFFC1024 03C0080D		mvmap		$v0,$x0,$t2				; get map entry into v0
FFFC1028 00080A63		beq			$v0,$x0,.empty0		; is it empty?
FFFC102C 001E0E13		add			$t2,$t2,#1
FFFC1030 FFFE6AE3		bltu		$t2,$t5,.0001
FFFC1034 FFF06813		ldi			$v0,#-1						; got here so no run was found
FFFC1038 00008067		ret
                        	.empty0:
FFFC103C 000E6EB3		mov			$t3,$t2						; save first empty bucket
                        	.empty1:
FFFC1040 001D8D93		add			$t1,$t1,#1
FFFC1044 013DFC63		bgeu		$t1,$a1,.foundEnough
FFFC1048 001E0E13		add			$t2,$t2,#1				; next bucket
FFFC104C 03C0080D		mvmap		$v0,$x0,$t2				; get map entry
FFFC1050 FE0808E3		beq			$v0,$x0,.empty1
FFFC1054 00006DB3		mov			$t1,$x0						; reset counter
FFFC1058 FC0006E3		bra			.0001							; go back and find another run
                        	.foundEnough:
FFFC105C 000EE833		mov			$v0,$t3						; v0 = start of run
FFFC1060 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = pid
                        	;		a1 = amount of memory to allocate
                        	; Modifies:
                        	;		t0
                        	; Returns:
                        	;		v1 = pointer to allocated memory in virtual address space.
                        	;		v0 = E_Ok for success, E_NotAlloc otherwise
                        	;------------------------------------------------------------------------------
                        	;
                        	Alloc:
FFFC1064 FF070713		sub			$sp,$sp,#16
FFFC1068 00172023		sw			$ra,[$sp]
FFFC106C 00472223		sw			$s1,4[$sp]				; these regs must be saved
FFFC1070 00572423		sw			$s2,8[$sp]
FFFC1074 00672623		sw			$s3,12[$sp]
                        		; First check if there are enough pages available in the system.
FFFC1078 7FF98813		add			$v0,$a1,#2047			; v0 = round memory request
FFFC107C 00B85813		srl			$v0,$v0,#11				; v0 = convert to pages required
FFFC1080 00004637		lw			$t0,NPAGES				; check number of pages available
FFFC1084 30060613
FFFC1088 00060633
FFFC108C 00062D03
FFFC1090 010D7663		bleu		$v0,$t0,.enough
                        	.noRun2:
FFFC1094 00006893		ldi			$v1,#0						; not enough, return null
FFFC1098 06000E63		bra			.noRun
                        	.enough:
FFFC109C 00096233		mov			$s1,$a0
FFFC10A0 04506913		ldi			$a0,#'E'
FFFC10A4 914FF0EF		call		Putch
FFFC10A8 00026933		mov			$a0,$s1
                        		; There are enough pages, but is there a run long enough in map space?
FFFC10AC 000862B3		mov			$s2,$v0				; save required # pages
FFFC10B0 000869B3		mov			$a1,$v0
FFFC10B4 F59FF0EF		call		FindRun						; find a run of available slots
FFFC10B8 FC084EE3		blt			$v0,$x0,.noRun2
                        		; Now there are enough pages, and a run available, so allocate
FFFC10BC 04606913		ldi			$a0,#'F'
FFFC10C0 8F8FF0EF		call		Putch
FFFC10C4 00086233		mov			$s1,$v0						; s1 = start of run
FFFC10C8 00004637		lw			$s3,NPAGES				; decrease number of pages available in system
FFFC10CC 30060613
FFFC10D0 00060633
FFFC10D4 00062303
FFFC10D8 40530333		sub			$s3,$s3,$s2
FFFC10DC 00004637		sw			$s3,NPAGES
FFFC10E0 30060613
FFFC10E4 00060633
FFFC10E8 00662023
FFFC10EC 00086333		mov			$s3,$v0						; s3 = start of run
                        	.0001:
FFFC10F0 0000180D		palloc	$v0								; allocate a page (cheat and use hardware)
                        		;call		AllocPage
FFFC10F4 02080063		beq			$v0,$x0,.noRun
FFFC10F8 0268000D		mvmap		$x0,$v0,$s3				; map the page
FFFC10FC 00130313		add			$s3,$s3,#1				; next bucket
FFFC1100 FFF28293		sub			$s2,$s2,#1
FFFC1104 FE0296E3		bne			$s2,$x0,.0001
FFFC1108 00B21893		sll			$v1,$s1,#11				; v0 = virtual address of allocated mem.
FFFC110C 00006813		ldi			$v0,#E_Ok
FFFC1110 00000463		bra			.xit
                        	.noRun:
FFFC1114 00906813		ldi			$v0,#E_NotAlloc
                        	.xit
FFFC1118 00072083		lw			$ra,[$sp]					; restore saved regs
FFFC111C 00472203		lw			s1,4[$sp]
FFFC1120 00872283		lw			s2,8[$sp]
FFFC1124 00C72303		lw			s3,12[$sp]
FFFC1128 01070713		add			$sp,$sp,#16
FFFC112C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Allocate the stack page for a task. The stack is located at the highest
                        	; virtual address ($7F800).
                        	;
                        	; Parameters:
                        	;		a0 = pid to allocate for
                        	;	Returns:
                        	;		v0 = physical address, 0 if unsuccessful
                        	;		v1 = virtual address, not valid unless successful
                        	;------------------------------------------------------------------------------
                        	;
                        	AllocStack:
                        		; need save ra here if calling AllocPage
FFFC1130 00891893		sll			$v1,$a0,#8			; 
FFFC1134 0FF8E893		or			$v1,$v1,#255		; last page of memory is for stack
FFFC1138 0310080D		mvmap		$v0,$x0,$v1			; check if stack already allocated
FFFC113C 00081863		bne			$v0,$x0,.0001
FFFC1140 0000180D		palloc	$v0							; allocate a page
                        		;call		AllocPage
FFFC1144 00080A63		beq			$v0,$x0,.xit		; success?
FFFC1148 0318000D		mvmap		$x0,$v0,$v1
                        	.0001:
FFFC114C 0FF8F893		and			$v1,$v1,#255
FFFC1150 00B81813		sll			$v0,$v0,#11			; convert pages to addresses
FFFC1154 00B89893		sll			$v1,$v1,#11
                        	.xit:
FFFC1158 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; This routine will de-allocate all the pages associated with a task including
                        	; the stack.
                        	;
                        	; Parameters:
                        	;		a0 = pid to free memory for
                        	;	Modifies:
                        	;		a0,t0,t1,t3,t4
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	FreeAll:
                        		; need save ra if calling FreePage
FFFC115C 00006E93		ldi			$t3,#0
FFFC1160 00891F13		sll			$t4,$a0,#8
                        	.nxt:
FFFC1164 100EAD93		slt			$t1,$t3,#256		; number of buckets to check
FFFC1168 040D8A63		beq			$t1,$x0,.0001
FFFC116C 00001637		and			$t4,$t4,#$F00
FFFC1170 F0060613
FFFC1174 01E67F33
FFFC1178 01DF6F33		or			$t4,$t4,$t3			; combine pid and bucket number
FFFC117C 00006D13		ldi			$t0,#0					; new page number to set (indicates free)
FFFC1180 03ED0D0D		mvmap		$t0,$t0,$t4			; get page mapping and set to zero
FFFC1184 001E8E93		add			$t3,$t3,#1			; advance to next bucket
FFFC1188 0FFD7D13		and			$t0,$t0,#255		; pages are 1-255
FFFC118C FC0D0CE3		beq			$t0,$x0,.nxt		; 0 = no map in this bucket
FFFC1190 020D100D		pfree		$t0							; free the page
                        		;mov			$a0,$t0
                        		;call		FreePage
FFFC1194 00004637		lw			$t0,NPAGES			; update the number of available pages
FFFC1198 30060613
FFFC119C 00060633
FFFC11A0 00062D03
FFFC11A4 001D0D13		add			$t0,$t0,#1
FFFC11A8 00004637		sw			$t0,NPAGES
FFFC11AC 30060613
FFFC11B0 00060633
FFFC11B4 01A62023
FFFC11B8 FA0006E3		bra			.nxt
                        	.0001:
FFFC11BC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Convert a virtual address to a physical one
                        	;
                        	; Parameters:
                        	;		a0 = virtual address to convert
                        	; Modifies:
                        	;		t0
                        	; Returns:
                        	;		v0 = physcial address
                        	;------------------------------------------------------------------------------
                        	
                        	VirtToPhys:
FFFC11C0 30001873		csrrw	$v0,#$300,$x0				; get tid
FFFC11C4 01685813		srl		$v0,$v0,#22					; extract
FFFC11C8 00F87813		and		$v0,$v0,#15
FFFC11CC 00881813		sll		$v0,$v0,#8
FFFC11D0 00B95D13		srl		$t0,$a0,#11					; convert virt to page
FFFC11D4 0FFD7D13		and		$t0,$t0,#255
FFFC11D8 01A86833		or		$v0,$v0,$t0					; and in tid
FFFC11DC 0300080D		mvmap	$v0,$x0,$v0					; get the translation
FFFC11E0 00B81813		sll		$v0,$v0,#11					; convert page to address
FFFC11E4 7FF97D13		and		$t0,$a0,#$7FF				; insert LSB's
FFFC11E8 01A86833		or		$v0,$v0,$t0
FFFC11EC 00008067		ret
                        	
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "../fmtk/task.asm",1
                        	.file "../fmtk/task.asm",1
                        	
                        	QNDX		EQU		$4304
                        	HRDY0		EQU		$4308
                        	HRDY1		EQU		$4309
                        	HRDY2		EQU		$430A
                        	HRDY3		EQU		$430B
                        	TRDY0		EQU		$430C
                        	TRDY1		EQU		$430D
                        	TRDY2		EQU		$430E
                        	TRDY3		EQU		$430F
                        	PIDMAP	EQU		$4310
                        	missed_ticks	equ		$4320
                        	TimeoutList		equ		$4328
                        	Tick		EQU		$4330
                        	RDYQ0		EQU		$4400
                        	RDYQ1		EQU		$4500
                        	RDYQ2		EQU		$4600
                        	RDYQ3		EQU		$4700
                        	msgs		EQU		$4800
                        	mbxs		EQU		$8800
                        	mbxs_end	EQU	$8A00
                        	FreeMsg	EQU		$8C00
                        	
                        		align	2                        	
                        	OSCallTbl:
FFFC11F0 1C280108		dh		FMTK_Initialize					; 0
FFFC11F2 1CE41C28		dh		FMTK_StartTask					; 1
FFFC11F4 1CF01CE4		dh		FMTK_ExitTask
FFFC11F6 010C1CF0		dh		FMTK_KillTask
FFFC11F8 1D40010C		dh		FMTK_SetTaskPriority
FFFC11FA 1D741D40		dh		FMTK_Sleep							; 5
FFFC11FC 1DDC1D74		dh		FMTK_AllocMbx
FFFC11FE 01101DDC		dh		FMTK_FreeMbx
FFFC1200 1E5C0110		dh		FMTK_PostMsg
FFFC1202 20081E5C		dh		FMTK_SendMsg
FFFC1204 1FFC2008		dh		FMTK_WaitMsg						; 10
FFFC1206 01141FFC		dh		FMTK_PeekMsg
FFFC1208 19CC0114		dh		FMTK_StartApp
FFFC120A 12F819CC		dh		FMTK_Reschedule					; 13
FFFC120C 228412F8		dh		FMTK_GetCurrentTid
FFFC120E 00002284		dh		DumpReadyQueue
                        	
                        	qToChk:
FFFC1210 01000000		db	0,0,0,1,0,0,2,1
FFFC1214 01020000
FFFC1218 01030000		db	0,0,3,1,0,0,2,1
FFFC121C 01020000
FFFC1220 01000000		db	0,0,0,1,0,0,2,1
FFFC1224 01020000
FFFC1228 01030000		db	0,0,3,1,0,0,2,1
FFFC122C 01020000
                        	
                        		align	4                        	
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FMTKInit:
FFFC1230 00004637		sw		$x0,QNDX
FFFC1234 30460613
FFFC1238 00060633
FFFC123C 00062023
FFFC1240 00004637		sw		$x0,HRDY0				; reset head and tail indexes
FFFC1244 30860613
FFFC1248 00060633
FFFC124C 00062023
FFFC1250 00004637		sw		$x0,TRDY0
FFFC1254 30C60613
FFFC1258 00060633
FFFC125C 00062023
FFFC1260 00004637		sw		$x0,PIDMAP
FFFC1264 31060613
FFFC1268 00060633
FFFC126C 00062023
FFFC1270 00004637		sw		$x0,missed_ticks
FFFC1274 32060613
FFFC1278 00060633
FFFC127C 00062023
FFFC1280 FFF06D13		ldi		$t0,#-1
FFFC1284 00004637		sw		$t0,TimeoutList
FFFC1288 32860613
FFFC128C 00060633
FFFC1290 01A62023
                        	
                        		; Initialize mailboxes
FFFC1294 00009D37		ldi		$t0,#mbxs
FFFC1298 800D0D13
FFFC129C 08006D93		ldi		$t1,#4*32
                        	.0001:
FFFC12A0 000D2023		sw		$x0,[$t0]
FFFC12A4 004D0D13		add		$t0,$t0,#4
FFFC12A8 FFFD8D93		sub		$t1,$t1,#1
FFFC12AC FFB04AE3		bgt		$t1,$x0,.0001
                        	
                        		; Initialize free message list
FFFC12B0 00005D37		ldi		$t0,#msgs
FFFC12B4 800D0D13
FFFC12B8 00009637		sw		$t0,FreeMsg
FFFC12BC C0060613
FFFC12C0 00060633
FFFC12C4 01A62023
FFFC12C8 00006D93		ldi		$t1,#0
FFFC12CC 20006E13		ldi		$t2,#512
                        	.0002:
FFFC12D0 001D8D93		add		$t1,$t1,#1
FFFC12D4 01BD2023		sw		$t1,MSG_LINK[$t0]
FFFC12D8 010D0D13		add		$t0,$t0,#16
FFFC12DC FFFE0E13		sub		$t2,$t2,#1
FFFC12E0 FFC048E3		bgt		$t2,$x0,.0002
FFFC12E4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Get the task id for the currently running task.
                        	;
                        	; Returns:
                        	;		v0 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	GetCurrentTid:
FFFC12E8 30001873		csrrw	$v0,#$300,$x0				; get current pid
FFFC12EC 01685813		srl		$v0,$v0,#22					; extract field
FFFC12F0 00F87813		and		$v0,$v0,#15					; mask off extra bits
FFFC12F4 00008067		ret
                        	
                        	FMTK_GetCurrentTid:
FFFC12F8 FF1FF0EF		call	GetCurrentTid
FFFC12FC 000868B3		mov		$v1,$v0
FFFC1300 00006813		ldi		$v0,#E_Ok
FFFC1304 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Select the next task to run. The ready queues are searched in a circular
                        	; fashion beginning with the queue identified indirectly by QNDX. There are
                        	; four ready queues to hold tasks of four different priorities. This routine
                        	; dequeues a task from the ready list, then adds it back if it is still ready.
                        	; This takes care of a lot of scenarios. Such as the task no longer being
                        	; ready, or the priority changing.
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		v1, t0, t1, t2, t3, t4
                        	;	Returns:
                        	;		v0 = task id of task to run
                        	;------------------------------------------------------------------------------
                        	
                        	SelectTaskToRun:
FFFC1308 FFC70713		sub		$sp,$sp,#4					; stack return address
FFFC130C 00172023		sw		$ra,[$sp]
                        		; Pick the first queue to check, occasionally the queue
                        		; chosen isn't the highest priority one in order to 
                        		; prevent starvation of lower priority tasks.
FFFC1310 00004637		lbu		$v1,QNDX						; get index into que check table
FFFC1314 30460613
FFFC1318 00060633
FFFC131C 00064883
FFFC1320 00188893		add		$v1,$v1,#1					; increment it, and limit
FFFC1324 01F8F893		and		$v1,$v1,#31
FFFC1328 00004637		sb		$v1,QNDX						; store back
FFFC132C 30460613
FFFC1330 00060633
FFFC1334 01160023
FFFC1338 FFFC1637		lbu		$v1,qToChk[$v1]			; assume this will be valid
FFFC133C 21060613
FFFC1340 01160633
FFFC1344 00064883
FFFC1348 00406E13		ldi		$t2,#4							; 4 queues to check
                        	.nxtQ:
FFFC134C 00004637		lbu		$t0,HRDY0[$v1]			; check queue to see if contains any
FFFC1350 30860613
FFFC1354 01160633
FFFC1358 00064D03
FFFC135C 00004637		lbu		$t1,TRDY0[$v1]			; ready tasks
FFFC1360 30C60613
FFFC1364 01160633
FFFC1368 00064D83
FFFC136C 01BD1E63		bne		$t0,$t1,.dq					; yes, go dequeue
FFFC1370 00188893		add		$v1,$v1,#1					; no, advance to next queue
FFFC1374 0038F893		and		$v1,$v1,#3					; 4 max
FFFC1378 FFFE0E13		sub		$t2,$t2,#1					;
FFFC137C FDC048E3		bgt		$t2,$x0,.nxtQ				; go back to check next queue
                        		; Here, nothing else is actually ready to run
                        		; just go back to what we were doing.
FFFC1380 F69FF0EF		call	GetCurrentTid				; tail recursion here
FFFC1384 04000063		bra		.goodTid
                        	.dq:
FFFC1388 00889E93		sll		$t3,$v1,#8					; compute t3 = readyq index
FFFC138C 00004637		add		$t3,$t3,#RDYQ0
FFFC1390 40060613
FFFC1394 01D60EB3
FFFC1398 01DD0F33		add		$t4,$t0,$t3
FFFC139C 000F4803		lbu		$v0,[$t4]						; v0 = tid of ready task
FFFC13A0 00F06E93		ldi		$t3,#MAX_TID				; ensure we have a valid tid
FFFC13A4 030EF063		bleu	$v0,$t3,.goodTid
                        		; If the tid isn't valid, remove it from the queue and go back
                        		; and check the next queue entry
FFFC13A8 001D0D13		add		$t0,$t0,#1					; advance readyq head
FFFC13AC 0FFD7D13		and		$t0,$t0,#255
FFFC13B0 00004637		sb		$t0,HRDY0[$v1]			; save head pointer
FFFC13B4 30860613
FFFC13B8 01160633
FFFC13BC 01A60023
FFFC13C0 F80006E3		bra		.nxtQ
                        	.goodTid:
FFFC13C4 001D0D13		add		$t0,$t0,#1					; advance readyq head
FFFC13C8 0FFD7D13		and		$t0,$t0,#255
FFFC13CC 00004637		sb		$t0,HRDY0[$v1]			; save head pointer
FFFC13D0 30860613
FFFC13D4 01160633
FFFC13D8 01A60023
                        		; Now filter out tasks (remove from ready list) that aren't ready to run
FFFC13DC 00A81D13		sll		$t0,$v0,#10					; tid to pointer
FFFC13E0 288D0D03		lb		$t0,TCBStatus[$t0]	; get status
FFFC13E4 001D7D13		and		$t0,$t0,#TS_READY		; is it ready?
FFFC13E8 F60D02E3		beq		$t0,$x0,.nxtQ
                        		; And re-insert task into queue for next time
FFFC13EC 00086933		mov		$a0,$v0
FFFC13F0 489000EF		call	InsertTask					; could check if insert failed
FFFC13F4 00096833		mov		$v0,$a0							; get back tid
FFFC13F8 00072083		lw		$ra,[$sp]						; restore return address
FFFC13FC 00470713		add		$sp,$sp,#4
FFFC1400 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Swap from outgoing context to incoming context.
                        	;
                        	; Parameters:
                        	;		a0 = pointer to TCB of outgoing context
                        	;		a1 = pointer to TCB of incoming context
                        	;------------------------------------------------------------------------------
                        	
                        	SwapContext:
                        		; Save outgoing register set in TCB
FFFC1404 0400810D		mfu		$x2,$x1
FFFC1408 00292223		sw		$x2,4[$a0]
FFFC140C 0401010D		mfu		$x2,$x2
FFFC1410 00292423		sw		$x2,8[$a0]
FFFC1414 0401810D		mfu		$x2,$x3
FFFC1418 00292623		sw		$x2,12[$a0]
FFFC141C 0402010D		mfu		$x2,$x4
FFFC1420 00292823		sw		$x2,16[$a0]
FFFC1424 0402810D		mfu		$x2,$x5
FFFC1428 00292A23		sw		$x2,20[$a0]
FFFC142C 0403010D		mfu		$x2,$x6
FFFC1430 00292C23		sw		$x2,24[$a0]
FFFC1434 0403810D		mfu		$x2,$x7
FFFC1438 00292E23		sw		$x2,28[$a0]
FFFC143C 0404010D		mfu		$x2,$x8
FFFC1440 02292023		sw		$x2,32[$a0]
FFFC1444 0404810D		mfu		$x2,$x9
FFFC1448 02292223		sw		$x2,36[$a0]
FFFC144C 0405010D		mfu		$x2,$x10
FFFC1450 02292423		sw		$x2,40[$a0]
FFFC1454 0405810D		mfu		$x2,$x11
FFFC1458 02292623		sw		$x2,44[$a0]
FFFC145C 0406010D		mfu		$x2,$x12
FFFC1460 02292823		sw		$x2,48[$a0]
FFFC1464 0406810D		mfu		$x2,$x13
FFFC1468 02292A23		sw		$x2,52[$a0]
FFFC146C 0407010D		mfu		$x2,$x14
FFFC1470 02292C23		sw		$x2,56[$a0]
FFFC1474 0407810D		mfu		$x2,$x15
FFFC1478 02292E23		sw		$x2,60[$a0]
FFFC147C 0408010D		mfu		$x2,$x16
FFFC1480 04292023		sw		$x2,64[$a0]
FFFC1484 0408810D		mfu		$x2,$x17
FFFC1488 04292223		sw		$x2,68[$a0]
FFFC148C 0409010D		mfu		$x2,$x18
FFFC1490 04292423		sw		$x2,72[$a0]
FFFC1494 0409810D		mfu		$x2,$x19
FFFC1498 04292623		sw		$x2,76[$a0]
FFFC149C 040A010D		mfu		$x2,$x20
FFFC14A0 04292823		sw		$x2,80[$a0]
FFFC14A4 040A810D		mfu		$x2,$x21
FFFC14A8 04292A23		sw		$x2,84[$a0]
FFFC14AC 040B010D		mfu		$x2,$x22
FFFC14B0 04292C23		sw		$x2,88[$a0]
FFFC14B4 040B810D		mfu		$x2,$x23
FFFC14B8 04292E23		sw		$x2,92[$a0]
FFFC14BC 040C010D		mfu		$x2,$x24
FFFC14C0 06292023		sw		$x2,96[$a0]
FFFC14C4 040C810D		mfu		$x2,$x25
FFFC14C8 06292223		sw		$x2,100[$a0]
FFFC14CC 040D010D		mfu		$x2,$x26
FFFC14D0 06292423		sw		$x2,104[$a0]
FFFC14D4 040D810D		mfu		$x2,$x27
FFFC14D8 06292623		sw		$x2,108[$a0]
FFFC14DC 040E010D		mfu		$x2,$x28
FFFC14E0 06292823		sw		$x2,112[$a0]
FFFC14E4 040E810D		mfu		$x2,$x29
FFFC14E8 06292A23		sw		$x2,116[$a0]
FFFC14EC 040F010D		mfu		$x2,$x30
FFFC14F0 06292C23		sw		$x2,120[$a0]
FFFC14F4 040F810D		mfu		$x2,$x31
FFFC14F8 06292E23		sw		$x2,124[$a0]
FFFC14FC 34101173		csrrw	$x2,#$341,$x0				; save off mepc
FFFC1500 28292023		sw		$x2,TCBepc[$a0]
                        		; Now save off segment registers
FFFC1504 00006D93		ldi		$t1,#0
                        	.svseg:
FFFC1508 01B00D0D		mvseg	$t0,$x0,$t1
FFFC150C 002D9113		sll		$x2,$t1,#2
FFFC1510 01210133		add		$x2,$x2,$a0
FFFC1514 21A12023		sw		$t0,TCBsegs[$x2]
FFFC1518 001D8D93		add		$t1,$t1,#1
FFFC151C 00FDFD93		and		$t1,$t1,#15
FFFC1520 FE0D94E3		bne		$t1,$x0,.svseg
                        	
                        		; Switch memory maps
FFFC1524 00A9D813		srl		$v0,$a1,#10					; convert pointer to tid
FFFC1528 00F87813		and		$v0,$v0,#$F					; mask to 16 task
FFFC152C 01681813		sll		$v0,$v0,#22					; shift into position
FFFC1530 300018F3		csrrw	$v1,#$300,$x0				; get status
FFFC1534 FC400637		and		$v1,$v1,#$FC3FFFFF	; mask off ASID/PID bits
FFFC1538 FFF60613
FFFC153C 011678B3
FFFC1540 0108E8B3		or		$v1,$v1,$v0					; set new ASID
FFFC1544 30089073		csrrw	$x0,#$300,$v1				; save status
                        		; User map has now been switched
                        	
                        		; Restore segment register set
FFFC1548 00006D93		ldi		$t1,#0
                        	.rsseg:
FFFC154C 002D9113		sll		$x2,$t1,#2
FFFC1550 01310133		add		$x2,$x2,$a1
FFFC1554 20012D03		lw		$t0,TCBsegs[$x2]
FFFC1558 01BD000D		mvseg	$x0,$t0,$t1
FFFC155C 001D8D93		add		$t1,$t1,#1
FFFC1560 00FDFD93		and		$t1,$t1,#15
FFFC1564 FE0D94E3		bne		$t1,$x0,.rsseg
                        	
FFFC1568 2809A103		lw		$x2,TCBepc[$a1]			; restore epc
FFFC156C 34111073		csrrw	$x0,#$341,$x2
                        		; Restore incoming registers
FFFC1570 0049A103		lw		$x2,4[$a1]
FFFC1574 0601008D		mtu		$x1,$x2
FFFC1578 0089A103		lw		$x2,8[$a1]
FFFC157C 0601010D		mtu		$x2,$x2
FFFC1580 00C9A103		lw		$x2,12[$a1]
FFFC1584 0601018D		mtu		$x3,$x2
FFFC1588 0109A103		lw		$x2,16[$a1]
FFFC158C 0601020D		mtu		$x4,$x2
FFFC1590 0149A103		lw		$x2,20[$a1]
FFFC1594 0601028D		mtu		$x5,$x2
FFFC1598 0189A103		lw		$x2,24[$a1]
FFFC159C 0601030D		mtu		$x6,$x2
FFFC15A0 01C9A103		lw		$x2,28[$a1]
FFFC15A4 0601038D		mtu		$x7,$x2
FFFC15A8 0209A103		lw		$x2,32[$a1]
FFFC15AC 0601040D		mtu		$x8,$x2
FFFC15B0 0249A103		lw		$x2,36[$a1]
FFFC15B4 0601048D		mtu		$x9,$x2
FFFC15B8 0289A103		lw		$x2,40[$a1]
FFFC15BC 0601050D		mtu		$x10,$x2
FFFC15C0 02C9A103		lw		$x2,44[$a1]
FFFC15C4 0601058D		mtu		$x11,$x2
FFFC15C8 0309A103		lw		$x2,48[$a1]
FFFC15CC 0601060D		mtu		$x12,$x2
FFFC15D0 0349A103		lw		$x2,52[$a1]
FFFC15D4 0601068D		mtu		$x13,$x2
FFFC15D8 0389A103		lw		$x2,56[$a1]
FFFC15DC 0601070D		mtu		$x14,$x2
FFFC15E0 03C9A103		lw		$x2,60[$a1]
FFFC15E4 0601078D		mtu		$x15,$x2
FFFC15E8 0409A103		lw		$x2,64[$a1]
FFFC15EC 0601080D		mtu		$x16,$x2
FFFC15F0 0449A103		lw		$x2,68[$a1]
FFFC15F4 0601088D		mtu		$x17,$x2
FFFC15F8 0489A103		lw		$x2,72[$a1]
FFFC15FC 0601090D		mtu		$x18,$x2
FFFC1600 04C9A103		lw		$x2,76[$a1]
FFFC1604 0601098D		mtu		$x19,$x2
FFFC1608 0509A103		lw		$x2,80[$a1]
FFFC160C 06010A0D		mtu		$x20,$x2
FFFC1610 0549A103		lw		$x2,84[$a1]
FFFC1614 06010A8D		mtu		$x21,$x2
FFFC1618 0589A103		lw		$x2,88[$a1]
FFFC161C 06010B0D		mtu		$x22,$x2
FFFC1620 05C9A103		lw		$x2,92[$a1]
FFFC1624 06010B8D		mtu		$x23,$x2
FFFC1628 0609A103		lw		$x2,96[$a1]
FFFC162C 06010C0D		mtu		$x24,$x2
FFFC1630 0649A103		lw		$x2,100[$a1]
FFFC1634 06010C8D		mtu		$x25,$x2
FFFC1638 0689A103		lw		$x2,104[$a1]
FFFC163C 06010D0D		mtu		$x26,$x2
FFFC1640 06C9A103		lw		$x2,108[$a1]
FFFC1644 06010D8D		mtu		$x27,$x2
FFFC1648 0709A103		lw		$x2,112[$a1]
FFFC164C 06010E0D		mtu		$x28,$x2
FFFC1650 0749A103		lw		$x2,116[$a1]
FFFC1654 06010E8D		mtu		$x29,$x2
FFFC1658 0789A103		lw		$x2,120[$a1]
FFFC165C 06010F0D		mtu		$x30,$x2
FFFC1660 07C9A103		lw		$x2,124[$a1]
FFFC1664 06010F8D		mtu		$x31,$x2
FFFC1668 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Switch tasks
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		v0, v1, t0, t1, x1, x2, a0, s1
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	;
                        	FMTK_SwitchTask:
                        		; Save register set in TCB
FFFC166C 300010F3		csrrw	$x1,#$300,$x0			; get process id
FFFC1670 0160D093		srl		$x1,$x1,#22
FFFC1674 00F0F093		and		$x1,$x1,#15
FFFC1678 00A09093		sll		$x1,$x1,#10				; compute TCB address
FFFC167C 0400810D		mfu		$x2,$x1
FFFC1680 0020A223		sw		$x2,4[$x1]
FFFC1684 0401010D		mfu		$x2,$x2
FFFC1688 0020A423		sw		$x2,8[$x1]				; save regs in TCB
FFFC168C 0401810D		mfu		$x2,$x3
FFFC1690 0020A623		sw		$x2,12[$x1]
FFFC1694 0402010D		mfu		$x2,$x4
FFFC1698 0020A823		sw		$x2,16[$x1]
FFFC169C 0402810D		mfu		$x2,$x5
FFFC16A0 0020AA23		sw		$x2,20[$x1]
FFFC16A4 0403010D		mfu		$x2,$x6
FFFC16A8 0020AC23		sw		$x2,24[$x1]
FFFC16AC 0403810D		mfu		$x2,$x7
FFFC16B0 0020AE23		sw		$x2,28[$x1]
FFFC16B4 0404010D		mfu		$x2,$x8
FFFC16B8 0220A023		sw		$x2,32[$x1]
FFFC16BC 0404810D		mfu		$x2,$x9
FFFC16C0 0220A223		sw		$x2,36[$x1]
FFFC16C4 0405010D		mfu		$x2,$x10
FFFC16C8 0220A423		sw		$x2,40[$x1]
FFFC16CC 0405810D		mfu		$x2,$x11
FFFC16D0 0220A623		sw		$x2,44[$x1]
FFFC16D4 0406010D		mfu		$x2,$x12
FFFC16D8 0220A823		sw		$x2,48[$x1]
FFFC16DC 0406810D		mfu		$x2,$x13
FFFC16E0 0220AA23		sw		$x2,52[$x1]
FFFC16E4 0407010D		mfu		$x2,$x14
FFFC16E8 0220AC23		sw		$x2,56[$x1]
FFFC16EC 0407810D		mfu		$x2,$x15
FFFC16F0 0220AE23		sw		$x2,60[$x1]
FFFC16F4 0408010D		mfu		$x2,$x16
FFFC16F8 0420A023		sw		$x2,64[$x1]
FFFC16FC 0408810D		mfu		$x2,$x17
FFFC1700 0420A223		sw		$x2,68[$x1]
FFFC1704 0409010D		mfu		$x2,$x18
FFFC1708 0420A423		sw		$x2,72[$x1]
FFFC170C 0409810D		mfu		$x2,$x19
FFFC1710 0420A623		sw		$x2,76[$x1]
FFFC1714 040A010D		mfu		$x2,$x20
FFFC1718 0420A823		sw		$x2,80[$x1]
FFFC171C 040A810D		mfu		$x2,$x21
FFFC1720 0420AA23		sw		$x2,84[$x1]
FFFC1724 040B010D		mfu		$x2,$x22
FFFC1728 0420AC23		sw		$x2,88[$x1]
FFFC172C 040B810D		mfu		$x2,$x23
FFFC1730 0420AE23		sw		$x2,92[$x1]
FFFC1734 040C010D		mfu		$x2,$x24
FFFC1738 0620A023		sw		$x2,96[$x1]
FFFC173C 040C810D		mfu		$x2,$x25
FFFC1740 0620A223		sw		$x2,100[$x1]
FFFC1744 040D010D		mfu		$x2,$x26
FFFC1748 0620A423		sw		$x2,104[$x1]
FFFC174C 040D810D		mfu		$x2,$x27
FFFC1750 0620A623		sw		$x2,108[$x1]
FFFC1754 040E010D		mfu		$x2,$x28
FFFC1758 0620A823		sw		$x2,112[$x1]
FFFC175C 040E810D		mfu		$x2,$x29
FFFC1760 0620AA23		sw		$x2,116[$x1]
FFFC1764 040F010D		mfu		$x2,$x30
FFFC1768 0620AC23		sw		$x2,120[$x1]
FFFC176C 040F810D		mfu		$x2,$x31
FFFC1770 0620AE23		sw		$x2,124[$x1]
FFFC1774 34101173		csrrw	$x2,#$341,$x0				; save off mepc
FFFC1778 2820A023		sw		$x2,TCBepc[$x1]
FFFC177C 00006D93		ldi		$t1,#0
                        	.svseg:
FFFC1780 01B00D0D		mvseg	$t0,$x0,$t1
FFFC1784 002D9113		sll		$x2,$t1,#2
FFFC1788 00110133		add		$x2,$x2,$x1
FFFC178C 21A12023		sw		$t0,TCBsegs[$x2]
FFFC1790 001D8D93		add		$t1,$t1,#1
FFFC1794 00FDFD93		and		$t1,$t1,#15
FFFC1798 FE0D94E3		bne		$t1,$x0,.svseg
                        	
                        	.dead:
FFFC179C B6DFF0EF		call	SelectTaskToRun			; v0 = pid
                        	
                        		; Switch memory maps
FFFC17A0 00F87813		and		$v0,$v0,#$F					; mask to 16 task
FFFC17A4 01681813		sll		$v0,$v0,#22					; shift into position
FFFC17A8 300018F3		csrrw	$v1,#$300,$x0				; get status
FFFC17AC FC400637		and		$v1,$v1,#$FC3FFFFF	; mask off ASID/PID bits
FFFC17B0 FFF60613
FFFC17B4 011678B3
FFFC17B8 0108E8B3		or		$v1,$v1,$v0					; set new ASID
FFFC17BC 30089073		csrrw	$x0,#$300,$v1				; save status
                        		; User map has now been switched
FFFC17C0 00C85093		srl		$x1,$v0,#12					; compute incoming TCB address
                        	.0001:
FFFC17C4 28808883		lb		$v1,TCBStatus[$x1]
                        	
                        		; If a message is ready, update status to ready and put
                        		; message in target memory. The task will be returning
                        		; from a WaitMsg so a return status of E_Ok is also set.
FFFC17C8 0048F113		and		$x2,$v1,#TS_MSGRDY
FFFC17CC 04010863		beq		$x2,$x0,.noMsg
FFFC17D0 00086EB3		mov		$t3,$v0							; save off v0 (tid)
FFFC17D4 00106113		ldi		$x2,#TS_READY
FFFC17D8 28208423		sb		$x2,TCBStatus[$x1]
FFFC17DC 0500A903		lw		$a0,80[$x1]					; user a2 (x20)
FFFC17E0 9E1FF0EF		call	VirtToPhys
FFFC17E4 2980A103		lw		$x2,TCBMsgD1[$x1]
FFFC17E8 00282023		sw		$x2,[$v0]
FFFC17EC 0540A903		lw		$a0,84[$x1]
FFFC17F0 9D1FF0EF		call	VirtToPhys
FFFC17F4 2A00A103		lw		$x2,TCBMsgD2[$x1]
FFFC17F8 00282023		sw		$x2,[$v0]
FFFC17FC 0580A903		lw		$a0,88[$x1]
FFFC1800 9C1FF0EF		call	VirtToPhys
FFFC1804 2A80A103		lw		$x2,TCBMsgD3[$x1]
FFFC1808 00282023		sw		$x2,[$v0]
FFFC180C 00006113		ldi		$x2,#E_Ok						; setup to return E_Ok
FFFC1810 0420A023		sw		$x2,64[$x1]					; in v0
FFFC1814 000EE833		mov		$v0,$t3
FFFC1818 00000A63		bra		.ready
                        	.noMsg:
FFFC181C 0018F113		and		$x2,$v1,#TS_READY
FFFC1820 00011663		bne		$x2,$x0,.ready
FFFC1824 0028F113		and		$x2,$v1,#TS_DEAD
FFFC1828 F6011AE3		bne		$x2,$x0,.dead
                        	
                        	.ready:
                        		; Add task back into ready queue
FFFC182C 0000E233		mov		$s1,$x1							; save off x1 (normally return address)
FFFC1830 01685913		srl		$a0,$v0,#22					; compute ASID/PID
FFFC1834 045000EF		call	InsertTask
FFFC1838 000260B3		mov		$x1,$s1							; get back x1
                        	
                        		; Restore register set
FFFC183C 00006D93		ldi		$t1,#0
                        	.rsseg:
FFFC1840 002D9113		sll		$x2,$t1,#2
FFFC1844 00110133		add		$x2,$x2,$x1
FFFC1848 20012D03		lw		$t0,TCBsegs[$x2]
FFFC184C 01BD000D		mvseg	$x0,$t0,$t1
FFFC1850 001D8D93		add		$t1,$t1,#1
FFFC1854 00FDFD93		and		$t1,$t1,#15
FFFC1858 FE0D94E3		bne		$t1,$x0,.rsseg
                        	
FFFC185C 2800A103		lw		$x2,TCBepc[$x1]			; restore epc
FFFC1860 34111073		csrrw	$x0,#$341,$x2
FFFC1864 0040A103		lw		$x2,4[$x1]
FFFC1868 0601008D		mtu		$x1,$x2
FFFC186C 0080A103		lw		$x2,8[$x1]
FFFC1870 0601010D		mtu		$x2,$x2
FFFC1874 00C0A103		lw		$x2,12[$x1]
FFFC1878 0601018D		mtu		$x3,$x2
FFFC187C 0100A103		lw		$x2,16[$x1]
FFFC1880 0601020D		mtu		$x4,$x2
FFFC1884 0140A103		lw		$x2,20[$x1]
FFFC1888 0601028D		mtu		$x5,$x2
FFFC188C 0180A103		lw		$x2,24[$x1]
FFFC1890 0601030D		mtu		$x6,$x2
FFFC1894 01C0A103		lw		$x2,28[$x1]
FFFC1898 0601038D		mtu		$x7,$x2
FFFC189C 0200A103		lw		$x2,32[$x1]
FFFC18A0 0601040D		mtu		$x8,$x2
FFFC18A4 0240A103		lw		$x2,36[$x1]
FFFC18A8 0601048D		mtu		$x9,$x2
FFFC18AC 0280A103		lw		$x2,40[$x1]
FFFC18B0 0601050D		mtu		$x10,$x2
FFFC18B4 02C0A103		lw		$x2,44[$x1]
FFFC18B8 0601058D		mtu		$x11,$x2
FFFC18BC 0300A103		lw		$x2,48[$x1]
FFFC18C0 0601060D		mtu		$x12,$x2
FFFC18C4 0340A103		lw		$x2,52[$x1]
FFFC18C8 0601068D		mtu		$x13,$x2
FFFC18CC 0380A103		lw		$x2,56[$x1]
FFFC18D0 0601070D		mtu		$x14,$x2
FFFC18D4 03C0A103		lw		$x2,60[$x1]
FFFC18D8 0601078D		mtu		$x15,$x2
FFFC18DC 0400A103		lw		$x2,64[$x1]
FFFC18E0 0601080D		mtu		$x16,$x2
FFFC18E4 0440A103		lw		$x2,68[$x1]
FFFC18E8 0601088D		mtu		$x17,$x2
FFFC18EC 0480A103		lw		$x2,72[$x1]
FFFC18F0 0601090D		mtu		$x18,$x2
FFFC18F4 04C0A103		lw		$x2,76[$x1]
FFFC18F8 0601098D		mtu		$x19,$x2
FFFC18FC 0500A103		lw		$x2,80[$x1]
FFFC1900 06010A0D		mtu		$x20,$x2
FFFC1904 0540A103		lw		$x2,84[$x1]
FFFC1908 06010A8D		mtu		$x21,$x2
FFFC190C 0580A103		lw		$x2,88[$x1]
FFFC1910 06010B0D		mtu		$x22,$x2
FFFC1914 05C0A103		lw		$x2,92[$x1]
FFFC1918 06010B8D		mtu		$x23,$x2
FFFC191C 0600A103		lw		$x2,96[$x1]
FFFC1920 06010C0D		mtu		$x24,$x2
FFFC1924 0640A103		lw		$x2,100[$x1]
FFFC1928 06010C8D		mtu		$x25,$x2
FFFC192C 0680A103		lw		$x2,104[$x1]
FFFC1930 06010D0D		mtu		$x26,$x2
FFFC1934 06C0A103		lw		$x2,108[$x1]
FFFC1938 06010D8D		mtu		$x27,$x2
FFFC193C 0700A103		lw		$x2,112[$x1]
FFFC1940 06010E0D		mtu		$x28,$x2
FFFC1944 0740A103		lw		$x2,116[$x1]
FFFC1948 06010E8D		mtu		$x29,$x2
FFFC194C 0780A103		lw		$x2,120[$x1]
FFFC1950 06010F0D		mtu		$x30,$x2
FFFC1954 07C0A103		lw		$x2,124[$x1]
FFFC1958 06010F8D		mtu		$x31,$x2
FFFC195C 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Operating system call dispatcher.
                        	;------------------------------------------------------------------------------
                        	
                        	OSCALL:
FFFC1960 0409090D		mfu		$a0,$a0
FFFC1964 0409898D		mfu		$a1,$a1
FFFC1968 040A0A0D		mfu		$a2,$a2
FFFC196C 040A8A8D		mfu		$a3,$a3
FFFC1970 040B0B0D		mfu		$a4,$a4
FFFC1974 040B8B8D		mfu		$a5,$a5
FFFC1978 00F97913		and		$a0,$a0,#15
FFFC197C 00191913		sll		$a0,$a0,#1
FFFC1980 FFFC1637		lhu		$t0,OSCallTbl[$a0]
FFFC1984 1F060613
FFFC1988 01260633
FFFC198C 00065D03
FFFC1990 FFFC0637		or		$t0,$t0,#$FFFC0000
FFFC1994 00060613
FFFC1998 01A66D33
FFFC199C 000D0067		jmp		[$t0]
                        	
                        	;------------------------------------------------------------------------------
                        	; Time accounting.
                        	; Update the length of time the task has been running.
                        	;
                        	; Parameters:
                        	;		s1 = pointer to TCB
                        	; Modifies:
                        	;		t2,t3,t4,t5
                        	;------------------------------------------------------------------------------
                        	
                        	AccountTime:
                        	.again:
                        	;	csrrw	$t3,#$741,$x0					; get high time
                        	;	csrrw	$t2,#$701,$x0					; get low time
                        	;	csrrw	$t4,#$741,$x0
                        	;	bne		$t3,$t4,.again
FFFC19A0 00004637		lw		$t2,Tick
FFFC19A4 33060613
FFFC19A8 00060633
FFFC19AC 00062E03
FFFC19B0 2BC22C23		sw		$t2,TCBEndTick[$s1]
FFFC19B4 2B022E83		lw		$t3,TCBStartTick[$s1]
FFFC19B8 41DE0F33		sub		$t4,$t2,$t3						; end - start
FFFC19BC 2C022F83		lw		$t5,TCBTicks[$s1]
FFFC19C0 01EF8FB3		add		$t5,$t5,$t4						; ticks + (end - start)
FFFC19C4 2DF22023		sw		$t5,TCBTicks[$s1]
FFFC19C8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Reschedule tasks.
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_Reschedule:
FFFC19CC 91DFF0EF		call	GetCurrentTid
FFFC19D0 00A81213		sll		$s1,$v0,#10						; compute pointer to TCB
FFFC19D4 28824803		lbu		$v0,TCBStatus[$s1]		; flag task as no longer running
FFFC19D8 F7F87813		and		$v0,$v0,#~TS_RUNNING
FFFC19DC 29020423		sb		$v0,TCBStatus[$s1]
                        	
FFFC19E0 FC1FF0EF		call	AccountTime						; uses s1
FFFC19E4 925FF0EF		call	SelectTaskToRun
                        	
FFFC19E8 00A81293		sll		$s2,$v0,#10						; s2 = pointer to incoming TCB
FFFC19EC 2882C103		lbu		$x2,TCBStatus[$s2]		; x2 = incoming status
FFFC19F0 08116E13		or		$t2,$x2,#TS_RUNNING|TS_READY	; set status = running
FFFC19F4 2C82A103		lw		$x2,TCBException[$s2]	;
FFFC19F8 00010A63		beq		$x2,$x0,.noException
                        		; set link register to catch handler address
                        		;{
                        		;	t->regs[29] = t->regs[28];   // set link register to catch handler
                        		;	t->epc = t->regs[28];        // and the PC register
                        		;	t->regs[1] = t->exception;    // r1 = exception value
                        		;	t->exception = 0;
                        		;	t->regs[2] = 45;              // r2 = exception type
                        		;}
FFFC19FC 0022A223		sw		$x2,4[$s2]						; r1 = exception
FFFC1A00 2C02A423		sw		$x0,TCBException[$s2]	; tcb->exception = 0
FFFC1A04 02D06113		ldi		$x2,#45
FFFC1A08 0022A423		sw		$x2,8[$s2]						; r2 = 45
                        	.noException:
                        	
                        		; If a message is ready, update status to ready and put
                        		; message in target memory. The task will be returning
                        		; from a WaitMsg so a return status of E_Ok is also set.
FFFC1A0C 004E7113		and		$x2,$t2,#TS_MSGRDY
FFFC1A10 02010E63		beq		$x2,$x0,.noMsg
FFFC1A14 0502A903		lw		$a0,80[$s2]					; user a2 (x20)
FFFC1A18 FA8FF0EF		call	VirtToPhys
FFFC1A1C 2982A103		lw		$x2,TCBMsgD1[$s2]
FFFC1A20 00282023		sw		$x2,[$v0]
FFFC1A24 0542A903		lw		$a0,84[$s2]
FFFC1A28 F98FF0EF		call	VirtToPhys
FFFC1A2C 2A02A103		lw		$x2,TCBMsgD2[$s2]
FFFC1A30 00282023		sw		$x2,[$v0]
FFFC1A34 0582A903		lw		$a0,88[$s2]
FFFC1A38 F88FF0EF		call	VirtToPhys
FFFC1A3C 2A82A103		lw		$x2,TCBMsgD3[$s2]
FFFC1A40 00282023		sw		$x2,[$v0]
FFFC1A44 00006113		ldi		$x2,#E_Ok						; setup to return E_Ok
FFFC1A48 0422A023		sw		$x2,64[$s2]					; in v0
                        	
                        	.noMsg:
FFFC1A4C FFBE7E13		and		$t2,$t2,#~TS_MSGRDY		; mask out message ready status
FFFC1A50 29C28423		sb		$t2,TCBStatus[$s2]
                        	;	beq		$s1,$s2,.noCtxSwitch	; incoming and outgoing contexts the same?
FFFC1A54 00026933		mov		$a0,$s1
FFFC1A58 0002E9B3		mov		$a1,$s2
FFFC1A5C 9A9FF0EF		call	SwapContext
                        	.noCtxSwitch:
FFFC1A60 00004637		lw		$t2,Tick						; get tick
FFFC1A64 33060613
FFFC1A68 00060633
FFFC1A6C 00062E03
FFFC1A70 2BC22823		sw		$t2,TCBStartTick[$s1]
FFFC1A74 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; SchedulerIRQ meant to be called from the timer ISR.
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_SchedulerIRQ:
FFFC1A78 FFC70713		sub		$sp,$sp,#4
FFFC1A7C 00172023		sw		$ra,[$sp]
FFFC1A80 00004637		lw		$t5,Tick							; update tick count
FFFC1A84 33060613
FFFC1A88 00060633
FFFC1A8C 00062F83
FFFC1A90 001F8F93		add		$t5,$t5,#1
FFFC1A94 00004637		sw		$t5,Tick
FFFC1A98 33060613
FFFC1A9C 00060633
FFFC1AA0 01F62023
FFFC1AA4 845FF0EF		call	GetCurrentTid
FFFC1AA8 00A81213		sll		$s1,$v0,#10						; compute pointer to TCB
FFFC1AAC EF5FF0EF		call	AccountTime
FFFC1AB0 28824F83		lbu		$t5,TCBStatus[$s1]
FFFC1AB4 020FEF93		or		$t5,$t5,#TS_PREEMPT
FFFC1AB8 F7FFFF93		and		$t5,$t5,#~TS_RUNNING	; no longer running, but may still be ready
FFFC1ABC 29F20423		sb		$t5,TCBStatus[$s1]
                        		; Keep popping the timeout list as long as there are tasks on it with
                        		; expired timeouts.
                        	.0001:
FFFC1AC0 00004637		lhu		$t5,TimeoutList
FFFC1AC4 32860613
FFFC1AC8 00060633
FFFC1ACC 00065F83
FFFC1AD0 040FCA63		blt		$t5,$x0,.noTimeouts
FFFC1AD4 01006F13		ldi		$t4,#NR_TCB
FFFC1AD8 05EFD663		bge		$t5,$t4,.noTimeouts
FFFC1ADC 00AF9F13		sll		$t4,$t5,#10					; index to pointer
FFFC1AE0 2E0F2E83		lw		$t3,TCBTimeout[$t4]
FFFC1AE4 01D04A63		bgt		$t3,$x0,.timeoutNotDone
FFFC1AE8 744000EF		call	PopTimeoutList
FFFC1AEC 00086933		mov		$a0,$v0
FFFC1AF0 588000EF		call	InsertTask
FFFC1AF4 FC0006E3		bra		.0001
                        	.timeoutNotDone:
FFFC1AF8 FFFE8E93		sub		$t3,$t3,#1
FFFC1AFC 00004637		lw		$t2,missed_ticks
FFFC1B00 32060613
FFFC1B04 00060633
FFFC1B08 00062E03
FFFC1B0C 41CE8EB3		sub		$t3,$t3,$t2
FFFC1B10 2FDF2023		sw		$t3,TCBTimeout[$t4]
FFFC1B14 00004637		sw		$x0,missed_ticks
FFFC1B18 32060613
FFFC1B1C 00060633
FFFC1B20 00062023
                        	.noTimeouts:
                        		; The ready queue was just updated, there could be new tasks
                        		; ready to run.
FFFC1B24 FE4FF0EF		call	SelectTaskToRun
                        	
FFFC1B28 01685293		srl		$s2,$v0,#22					; s2 = pointer to incoming TCB
FFFC1B2C 2882C103		lbu		$x2,TCBStatus[$s2]	; x2 = incoming status
FFFC1B30 08116E13		or		$t2,$x2,#TS_RUNNING|TS_READY	; status = running
FFFC1B34 2C82A103		lw		$x2,TCBException[$s2]	;
FFFC1B38 00010263		beq		$x2,$x0,.noException
                        		; set link register to catch handler address
                        		;{
                        		;	t->regs[29] = t->regs[28];   // set link register to catch handler
                        		;	t->epc = t->regs[28];        // and the PC register
                        		;	t->regs[1] = t->exception;    // r1 = exception value
                        		;	t->exception = 0;
                        		;	t->regs[2] = 45;              // r2 = exception type
                        		;}
                        	.noException:
                        	
                        		; If a message is ready, update status to ready and put
                        		; message in target memory. The task will be returning
                        		; from a WaitMsg so a return status of E_Ok is also set.
FFFC1B3C 004E7113		and		$x2,$t2,#TS_MSGRDY
FFFC1B40 02010E63		beq		$x2,$x0,.noMsg
FFFC1B44 0502A903		lw		$a0,80[$s2]					; user a2 (x20)
FFFC1B48 E78FF0EF		call	VirtToPhys
FFFC1B4C 2982A103		lw		$x2,TCBMsgD1[$s2]
FFFC1B50 00282023		sw		$x2,[$v0]
FFFC1B54 0542A903		lw		$a0,84[$s2]
FFFC1B58 E68FF0EF		call	VirtToPhys
FFFC1B5C 2A02A103		lw		$x2,TCBMsgD2[$s2]
FFFC1B60 00282023		sw		$x2,[$v0]
FFFC1B64 0582A903		lw		$a0,88[$s2]
FFFC1B68 E58FF0EF		call	VirtToPhys
FFFC1B6C 2A82A103		lw		$x2,TCBMsgD3[$s2]
FFFC1B70 00282023		sw		$x2,[$v0]
FFFC1B74 00006113		ldi		$x2,#E_Ok						; setup to return E_Ok
FFFC1B78 0422A023		sw		$x2,64[$s2]					; in v0
                        	
                        	.noMsg:
FFFC1B7C FFBE7E13		and		$t2,$t2,#~TS_MSGRDY		; mask out message ready status
FFFC1B80 29C28423		sb		$t2,TCBStatus[$s2]
                        	;	beq		$s1,$s2,.noCtxSwitch
FFFC1B84 00026933		mov		$a0,$s1
FFFC1B88 0002E9B3		mov		$a1,$s2
FFFC1B8C 879FF0EF		call	SwapContext
                        	.noCtxSwitch:
FFFC1B90 00072083		lw		$ra,[$sp]
FFFC1B94 00470713		add		$sp,$sp,#4
FFFC1B98 00004637		lw		$t2,Tick					; get tick
FFFC1B9C 33060613
FFFC1BA0 00060633
FFFC1BA4 00062E03
FFFC1BA8 2BC22823		sw		$t2,TCBStartTick[$s1]
FFFC1BAC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Returns:
                        	;		v1 = process id
                        	;------------------------------------------------------------------------------
                        	
                        	AllocTCB:
FFFC1BB0 00006D93		ldi		$t1,#0
FFFC1BB4 00004637		lhu		$v1,PIDMAP
FFFC1BB8 31060613
FFFC1BBC 00060633
FFFC1BC0 00065883
                        	.0001:
FFFC1BC4 0018FD13		and		$t0,$v1,#1
FFFC1BC8 020D0463		beq		$t0,$x0,.allocTid
FFFC1BCC 0018D893		srl		$v1,$v1,#1
FFFC1BD0 00008637		or		$v1,$v1,#$8000
FFFC1BD4 00060613
FFFC1BD8 011668B3
FFFC1BDC 001D8D93		add		$t1,$t1,#1
FFFC1BE0 00FDFD93		and		$t1,$t1,#15
FFFC1BE4 FE0D90E3		bne		$t1,$x0,.0001
                        	; here no tcbs available
FFFC1BE8 04506813		ldi		$v0,#E_NoMoreTCBs
FFFC1BEC 00008067		ret
                        	.allocTid:
FFFC1BF0 000DE833		mov		$v0,$t1
FFFC1BF4 0018E893		or		$v1,$v1,#1
FFFC1BF8 000D8A63		beq		$t1,$x0,.0003
                        	.0002:
FFFC1BFC 00189893		sll		$v1,$v1,#1
FFFC1C00 0018E893		or		$v1,$v1,#1
FFFC1C04 FFFD8D93		sub		$t1,$t1,#1
FFFC1C08 FE0D9AE3		bne		$t1,$x0,.0002
                        	.0003:
FFFC1C0C 00004637		sh		$v1,PIDMAP
FFFC1C10 31060613
FFFC1C14 00060633
FFFC1C18 01161023
FFFC1C1C 000868B3		mov		$v1,$v0
FFFC1C20 00006813		ldi		$v0,#E_Ok
FFFC1C24 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Start a task.
                        	;	Task status is set to ready, priority normal, and the task is inserted into
                        	; the ready queue. Segment registers are setup for a flat memory model.
                        	; 
                        	;	Parameters:
                        	;		a1 = memory required
                        	;		a2 = start pc (usually $100)
                        	;	Modifies:
                        	;		a0 = tid
                        	;	Returns:
                        	;		v0 = E_Ok if successful
                        	;		v1 = tid of started task if successful
                        	;------------------------------------------------------------------------------
                        	;
                        	FMTK_StartTask:
FFFC1C28 FFC70713		sub		$sp,$sp,#4
FFFC1C2C 00172023		sw		$ra,[$sp]
FFFC1C30 F81FF0EF		call	AllocTCB
FFFC1C34 0A081063		bne		$v0,$x0,.err
FFFC1C38 0008E933		mov		$a0,$v1
FFFC1C3C 00A89213		sll		$s1,$v1,#10			; compute TCB address
FFFC1C40 CF0FF0EF		call	AllocStack
FFFC1C44 00080D37		ldi		$t0,#$7F800			; set stack pointer
FFFC1C48 800D0D13
FFFC1C4C 03A22C23		sw		$t0,56[$s1]
FFFC1C50 29422023		sw		$a2,TCBepc[$s1]	; address task will begin at
FFFC1C54 C10FF0EF		call	Alloc
FFFC1C58 06081E63		bne		$v0,$x0,.err
FFFC1C5C 00106D13		ldi		$t0,#TS_READY
FFFC1C60 29A20423		sb		$t0,TCBStatus[$s1]
FFFC1C64 00206D13		ldi		$t0,#2					; normal execution priority
FFFC1C68 29A204A3		sb		$t0,TCBPriority[$s1]
                        		; leave segment base at $0, flat memory model
FFFC1C6C 00606D13		ldi		$t0,#6							; read,write
FFFC1C70 21A22023		sw		$t0,TCBsegs[$s1]			; segs 0 to 11
FFFC1C74 21A22223		sw		$t0,TCBsegs+4[$s1]
FFFC1C78 21A22423		sw		$t0,TCBsegs+8[$s1]
FFFC1C7C 21A22623		sw		$t0,TCBsegs+12[$s1]
FFFC1C80 21A22823		sw		$t0,TCBsegs+16[$s1]
FFFC1C84 21A22A23		sw		$t0,TCBsegs+20[$s1]
FFFC1C88 21A22C23		sw		$t0,TCBsegs+24[$s1]
FFFC1C8C 21A22E23		sw		$t0,TCBsegs+28[$s1]
FFFC1C90 23A22023		sw		$t0,TCBsegs+32[$s1]
FFFC1C94 23A22223		sw		$t0,TCBsegs+36[$s1]
FFFC1C98 23A22423		sw		$t0,TCBsegs+40[$s1]
FFFC1C9C 23A22623		sw		$t0,TCBsegs+44[$s1]
FFFC1CA0 00506D13		ldi		$t0,#5							; read,execute
FFFC1CA4 23A22823		sw		$t0,TCBsegs+48[$s1]	; segs 12 to 15
FFFC1CA8 23A22A23		sw		$t0,TCBsegs+52[$s1]
FFFC1CAC 23A22C23		sw		$t0,TCBsegs+56[$s1]
FFFC1CB0 23A22E23		sw		$t0,TCBsegs+60[$s1]
FFFC1CB4 00A25913		srl		$a0,$s1,#10					; need the tid again
FFFC1CB8 3C0000EF		call	InsertTask
FFFC1CBC 000968B3		mov		v1,a0
FFFC1CC0 00072083		lw		$ra,[$sp]
FFFC1CC4 00470713		add		$sp,$sp,#4
FFFC1CC8 0608080D		mtu		$v0,$v0
FFFC1CCC 0608888D		mtu		$v1,$v1
FFFC1CD0 10000073		eret
                        	.err:
                        	;	mov		$a0,$v0
                        	;	call	PutHexByte
FFFC1CD4 00072083		lw		$ra,[$sp]
FFFC1CD8 00470713		add		$sp,$sp,#4
FFFC1CDC 0608080D		mtu		$v0,$v0
FFFC1CE0 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Exit the current task.
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		a1 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_ExitTask:
FFFC1CE4 300019F3		csrrw	$a1,#$300,$x0				; get tid
FFFC1CE8 0169D993		srl		$a1,$a1,#22
FFFC1CEC 00F9F993		and		$a1,$a1,#15
                        		; fall through to KillTask
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = tid of task to kill
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_KillTask:
FFFC1CF0 04098663		beq		$a1,$x0,.immortal		; tid #0 is immortal (the system)
FFFC1CF4 00206D13		ldi		$t0,#TS_DEAD				; flag task as dead (prevents it from being re-queued)
FFFC1CF8 00F9FD93		and		$t1,$a1,#15					; limit pid
FFFC1CFC 00AD9D93		sll		$t1,$t1,#10					; convert to TCB address
FFFC1D00 29AD8423		sb		$t0,TCBStatus[$t1]
FFFC1D04 0009E933		mov		a0,a1								; a0 = pid
FFFC1D08 C54FF0EF		call	FreeAll							; free all the memory associated with the task
                        		; Now make process ID available for reuse
FFFC1D0C 00004637		lhu		$t1,PIDMAP
FFFC1D10 31060613
FFFC1D14 00060633
FFFC1D18 00065D83
FFFC1D1C 00106D13		ldi		$t0,#1							; generate bit "off" mask
FFFC1D20 013D1D13		sll		$t0,$t0,$a1
FFFC1D24 FFFD4D13		xor		$t0,$t0,#-1					; complment for inverted mask
FFFC1D28 01ADFDB3		and		$t1,$t1,$t0
FFFC1D2C 00004637		sh		$t1,PIDMAP
FFFC1D30 31060613
FFFC1D34 00060633
FFFC1D38 01B61023
                        	.immortal:
FFFC1D3C 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Sleep for a length of time. Time determined by the resolution of wall clock 
                        	; time. Passing a time of zero causes the function to return right away with
                        	; and E_Ok status.
                        	;
                        	; Parameters:
                        	;		a1 = length of time to sleep
                        	; Returns:
                        	;		v0 = E_Ok if successful
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_Sleep:
FFFC1D40 03305463		ble		$a1,$x0,.xit
FFFC1D44 70101D73		csrrw	$t0,#$701,$x0
FFFC1D48 DA0FF0EF		call	GetCurrentTid
FFFC1D4C 00A81213		sll		$s1,$v0,#10
FFFC1D50 28824D83		lbu		$t1,TCBStatus[$s1]		; changing status will remove from ready queue
FFFC1D54 FFEDFD93		and		$t1,$t1,#~TS_READY		; on next dequeue
FFFC1D58 29B20423		sb		$t1,TCBStatus[$s1]
FFFC1D5C 00086933		mov		$a0,$v0								; a0 = current tid
FFFC1D60 3B8000EF		call	InsertIntoTimeoutList	; a1 = timeout
FFFC1D64 C69FF06F		jmp		FMTK_Reschedule
                        	.xit:
FFFC1D68 00006813		ldi		$v0,#E_Ok
FFFC1D6C 0608080D		mtu		$v0,$v0
FFFC1D70 10000073		eret
                        	
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "../fmtk/msg.asm",1
                        	.file "../fmtk/msg.asm",1
                        	MBX_OWNER			equ		0		; tid of owning task
                        	MBX_WTIDS			equ		4		; tasks waiting at mailbox
                        	MBX_MQHEAD		equ		8		
                        	MBX_MQTAIL		equ		12
                        	MBX_SIZE			equ		16
                        	
                        	MSG_LINK	equ		0
                        	MSG_D1		equ		4
                        	MSG_D2		equ		8
                        	MSG_D3		equ		12
                        	MSG_SIZE	equ		16
                        	
                        	;	bss
                        	;	align 4
                        	;FreeMsg	dw	0
                        	;msgs:
                        	;	fill.b	MSG_SIZE*1024,0
                        	;mbxs:
                        	;	fill.b	MBX_SIZE*32,0
                        	;mbxs_end:
                        	
                        	.file "../fmtk/msg.asm",23
                        		code
                        		align	4                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = task id of owner
                        	;		a2 = pointer where to store handle
                        	; Returns:
                        	;		v0 = E_Ok
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_AllocMbx:
FFFC1D74 040A0E63		beq		$a2,$x0,.badArg
FFFC1D78 00009D37		ldi		$t0,#mbxs
FFFC1D7C 800D0D13
                        	.nxt:
FFFC1D80 000D4D83		lbu		$t1,MBX_OWNER[$t0]
FFFC1D84 020D8063		beq		$t1,$x0,.noOwner
FFFC1D88 010D0D13		add		$t0,$t0,#MBX_SIZE
FFFC1D8C 00009637		slt		$t1,$t0,#mbxs_end
FFFC1D90 A0060613
FFFC1D94 FE0D96E3		bne		$t1,$x0,.nxt
FFFC1D98 04006813		ldi		$v0,#E_NoMoreMbx
FFFC1D9C 0608080D		mtu		$v0,$v0
FFFC1DA0 10000073		eret
                        	.noOwner:
FFFC1DA4 013D0023		sb		$a1,MBX_OWNER[$t0]
FFFC1DA8 FFFF8637		sub		$t5,$t0,#mbxs				; convert pointer to handle
FFFC1DAC 80060613
FFFC1DB0 41A60FB3
FFFC1DB4 004FDF93		srl		$t5,$t5,#4
FFFC1DB8 000A6933		mov		$a0,$a2
FFFC1DBC C04FF0EF		call	VirtToPhys
FFFC1DC0 01F82023		sw		$t5,[$v0]
FFFC1DC4 00006813		ldi		$v0,#E_Ok
FFFC1DC8 0608080D		mtu		$v0,$v0
FFFC1DCC 10000073		eret
                        	.badArg:
FFFC1DD0 00106813		ldi		$v0,#E_Arg
FFFC1DD4 0608080D		mtu		$v0,$v0
FFFC1DD8 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_FreeMbx:
FFFC1DDC 0209A213		slt		$s1,$a1,#32
FFFC1DE0 06020863		beq		$s1,$x0,.badMbx
FFFC1DE4 00499213		sll		$s1,$a1,#4					; convert handle to pointer
FFFC1DE8 00009637		add		$s1,$s1,#mbxs
FFFC1DEC 80060613
FFFC1DF0 00460233
FFFC1DF4 00006293		ldi		$s2,#0
FFFC1DF8 01006393		ldi		$s4,#16							; possibly 16 tasks
FFFC1DFC 00422483		lw		$s6,MBX_WTIDS[$s1]
                        	.0002:
FFFC1E00 0014F313		and		$s3,$s6,#1
FFFC1E04 02030A63		beq		$s3,$x0,.0001
FFFC1E08 00A29413		sll		$s5,$s2,#10						; tid to pointer
FFFC1E0C 28844803		lbu		$v0,TCBStatus[$s5]
FFFC1E10 FF787813		and		$v0,$v0,#~TS_WAITMSG	; no longer waiting
FFFC1E14 29040423		sb		$v0,TCBStatus[$s5]
FFFC1E18 01087813		and		$v0,$v0,#TS_TIMEOUT
FFFC1E1C 00080663		beq		$v0,$x0,.0003
FFFC1E20 0002E933		mov		$a0,$s2
FFFC1E24 3B8000EF		call	RemoveFromTimeoutList
                        	.0003:
FFFC1E28 0002E933		mov		$a0,$s2
FFFC1E2C 24C000EF		call	InsertTask
FFFC1E30 00B06813		ldi		$v0,#E_NoMsg					; but no message
FFFC1E34 05042023		sw		$v0,64[$s5]						; v0 = E_NoMsg
                        	.0001:
FFFC1E38 0014D493		srl		$s6,$s6,#1
FFFC1E3C 00128293		add		$s2,$s2,#1
FFFC1E40 FC72E0E3		bltu	$s2,$s4,.0002
FFFC1E44 00006813		ldi		$v0,#E_Ok
FFFC1E48 0608080D		mtu		$v0,$v0
FFFC1E4C 10000073		eret
                        	.badMbx:
FFFC1E50 00406813		ldi		$v0,#E_BadMbx				; return null pointer if bad mailbox
FFFC1E54 0608080D		mtu		$v0,$v0
FFFC1E58 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Send a message to a mailbox.
                        	; The message will be broadcast to any waiting tasks. Waiting tasks will then
                        	; be moved to the ready list. If there are no waiting tasks then the message
                        	; is queued at the mailbox.
                        	;
                        	; Register Usage:
                        	;		t0 = mailbox pointer
                        	;		t1 = message pointer
                        	;		s1 = task id of waiting task
                        	; Modifies:
                        	;		a0
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = message d1
                        	;		a3 = message d2
                        	;		a4 = message d3
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_SendMsg:
FFFC1E5C 0209AD13		slt		$t0,$a1,#32
FFFC1E60 0C0D0E63		beq		$t0,$x0,.badMbx
FFFC1E64 00499D13		sll		$t0,$a1,#4					; convert handle to pointer
FFFC1E68 00009637		add		$t0,$t0,#mbxs
FFFC1E6C 80060613
FFFC1E70 01A60D33
FFFC1E74 004D2F83		lw		$t5,MBX_WTIDS[$t0]
FFFC1E78 060F8063		beq		$t5,$x0,.noWaiters
FFFC1E7C 00006213		ldi		$s1,#0
                        	.0001:
FFFC1E80 001FF313		and		$s3,$t5,#1					; is tid waiting?
FFFC1E84 02030C63		beq		$s3,$x0,.nxtTid
FFFC1E88 00A21313		sll		$s3,$s1,#10					; convert tid to TCB pointer
FFFC1E8C 29432C23		sw		$a2,TCBMsgD1[$s3]		; copy message to TCB
FFFC1E90 2B532023		sw		$a3,TCBMsgD2[$s3]
FFFC1E94 2B632423		sw		$a4,TCBMsgD3[$s3]
FFFC1E98 28834E03		lbu		$t2,TCBStatus[$s3]
FFFC1E9C 004E6E13		or		$t2,$t2,#TS_MSGRDY
FFFC1EA0 29C30423		sb		$t2,TCBStatus[$s3]
FFFC1EA4 00026933		mov		$a0,$s1
FFFC1EA8 FFC70713		sub		$sp,$sp,#4
FFFC1EAC 01A72023		sw		$t0,[$sp]						; push t0
FFFC1EB0 1C8000EF		call	InsertTask
FFFC1EB4 00072D03		lw		$t0,[$sp]						; pop t0
FFFC1EB8 00470713		add		$sp,$sp,#4
                        	.nxtTid:
FFFC1EBC 001FDF93		srl		$t5,$t5,#1					; check next task
FFFC1EC0 00120213		add		$s1,$s1,#1
FFFC1EC4 00F27213		and		$s1,$s1,#15
FFFC1EC8 FA021CE3		bne		$s1,$x0,.0001
FFFC1ECC 000D2223		sw		$x0,MBX_WTIDS[$t0]	; clear waiters
FFFC1ED0 00006813		ldi		$v0,#E_Ok
FFFC1ED4 06000663		bra		.xit
                        	.noWaiters:
FFFC1ED8 00009637		lw		$t1,FreeMsg
FFFC1EDC C0060613
FFFC1EE0 00060633
FFFC1EE4 00062D83
FFFC1EE8 040D8663		beq		$t1,$x0,.noMsg			; message available?
FFFC1EEC 000DAE03		lw		$t2,MSG_LINK[$t1]
FFFC1EF0 00009637		sw		$t2,FreeMsg
FFFC1EF4 C0060613
FFFC1EF8 00060633
FFFC1EFC 01C62023
FFFC1F00 014DA223		sw		$a2,MSG_D1[$t1]
FFFC1F04 015DA423		sw		$a3,MSG_D2[$t1]
FFFC1F08 016DA623		sw		$a4,MSG_D3[$t1]
FFFC1F0C 00CD2E83		lw		$t3,MBX_MQTAIL[$t0]
FFFC1F10 000E8A63		beq		$t3,$x0,.mbxEmpty
FFFC1F14 01BEA023		sw		$t1,MSG_LINK[$t3]
FFFC1F18 01BD2623		sw		$t1,MBX_MQTAIL[$t0]
FFFC1F1C 00006813		ldi		$v0,#E_Ok
FFFC1F20 02000063		bra		.xit
                        	.mbxEmpty:
FFFC1F24 01BD2423		sw		$t1,MBX_MQHEAD[$t0]
FFFC1F28 01BD2623		sw		$t1,MBX_MQTAIL[$t0]
FFFC1F2C 00006813		ldi		$v0,#E_Ok
FFFC1F30 00000863		bra		.xit
                        	.noMsg:
FFFC1F34 00B06813		ldi		$v0,#E_NoMsg
FFFC1F38 00000463		bra		.xit
                        	.badMbx:
FFFC1F3C 00406813		ldi		$v0,#E_BadMbx				; return null pointer if bad mailbox
                        	.xit:
FFFC1F40 0608080D		mtu		$v0,$v0
FFFC1F44 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = pointer where to put message D1
                        	;		a3 = pointer where to put message D2
                        	;		a4 = pointer where to put message D3
                        	;		a5 = 1 = remove from queue
                        	;------------------------------------------------------------------------------
                        	
                        	PeekMsg:
FFFC1F48 FFC70713		sub		$sp,$sp,#4
FFFC1F4C 00172023		sw		$ra,[$sp]
FFFC1F50 0209AD13		slt		$t0,$a1,#32
FFFC1F54 080D0C63		beq		$t0,$x0,.badMbx
FFFC1F58 00499E13		sll		$t2,$a1,#4					; convert handle to pointer
FFFC1F5C 00009637		add		$t2,$t2,#mbxs
FFFC1F60 80060613
FFFC1F64 01C60E33
FFFC1F68 008E2D83		lw		$t1,MBX_MQHEAD[$t2]
FFFC1F6C 060D8C63		beq		$t1,$x0,.noMsg
FFFC1F70 020B8863		beq		$a5,$x0,.nodq
FFFC1F74 000DAE83		lw		$t3,MSG_LINK[$t1]
FFFC1F78 01DE2423		sw		$t3,MBX_MQHEAD[$t2]
                        		; This is done here only because interrupts are disabled
FFFC1F7C 00009637		lw		$t3,FreeMsg
FFFC1F80 C0060613
FFFC1F84 00060633
FFFC1F88 00062E83
FFFC1F8C 01DDA023		sw		$t3,MSG_LINK[$t1]
FFFC1F90 00009637		sw		$t1,FreeMsg
FFFC1F94 C0060613
FFFC1F98 00060633
FFFC1F9C 01B62023
                        	.nodq:
FFFC1FA0 000A0A63		beq		$a2,$x0,.nod1
FFFC1FA4 000A6933		mov		$a0,$a2
FFFC1FA8 A18FF0EF		call	VirtToPhys
FFFC1FAC 004DAE83		lw		$t3,MSG_D1[$t1]
FFFC1FB0 01D82023		sw		$t3,[$v0]
                        	.nod1:
FFFC1FB4 000A8A63		beq		$a3,$x0,.nod2
FFFC1FB8 000AE933		mov		$a0,$a3
FFFC1FBC A04FF0EF		call	VirtToPhys
FFFC1FC0 008DAE83		lw		$t3,MSG_D2[$t1]
FFFC1FC4 01D82023		sw		$t3,[$v0]
                        	.nod2:
FFFC1FC8 000B0A63		beq		$a4,$x0,.nod3
FFFC1FCC 000B6933		mov		$a0,$a4
FFFC1FD0 9F0FF0EF		call	VirtToPhys
FFFC1FD4 00CDAE83		lw		$t3,MSG_D3[$t1]
FFFC1FD8 01D82023		sw		$t3,[$v0]
                        	.nod3:
FFFC1FDC 00006813		ldi		$v0,#E_Ok
FFFC1FE0 00000863		bra		.ret
                        	.noMsg:
FFFC1FE4 00B06813		ldi		$v0,#E_NoMsg
FFFC1FE8 00000463		bra		.ret
                        	.badMbx:
FFFC1FEC 00406813		ldi		$v0,#E_BadMbx				; return null pointer if bad mailbox
                        	.ret:
FFFC1FF0 00072083		lw		$ra,[$sp]
FFFC1FF4 00470713		add		$sp,$sp,#4
FFFC1FF8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; PeekMsg will check for a message at a mailbox optionally dequeuing it.
                        	; If no message is available PeekMsg returns to the caller with a E_NoMsg
                        	; status.
                        	;
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = pointer where to put message D1
                        	;		a3 = pointer where to put message D2
                        	;		a4 = pointer where to put message D3
                        	;		a5 = 1 = remove from queue
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_PeekMsg:
FFFC1FFC F4DFF0EF		call	PeekMsg
FFFC2000 0608080D		mtu		$v0,$v0
FFFC2004 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Calling WaitMsg will cause the task to be queued at the mailbox and a task
                        	; switch to occur if there are no messages at the mailbox.
                        	;
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = pointer where to put message D1
                        	;		a3 = pointer where to put message D2
                        	;		a4 = pointer where to put message D3
                        	;		a5 = time limit
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_WaitMsg:
FFFC2008 000BE433		mov		s5,a5
FFFC200C 00106B93		ldi		a5,#1
FFFC2010 F39FF0EF		call	PeekMsg							; check for a message, return if available
FFFC2014 00B06D93		ldi		$t1,#E_NoMsg
FFFC2018 01B80663		beq		$v0,$t1,.qt					; no message? Then go queue task
FFFC201C 0608080D		mtu		$v0,$v0
FFFC2020 10000073		eret
                        	.qt:
FFFC2024 AC4FF0EF		call	GetCurrentTid
FFFC2028 00106E13		ldi		$t2,#1
FFFC202C 010E1E13		sll		$t2,$t2,$v0
FFFC2030 00491E93		sll		$t3,$a0,#4					; convert handle to pointer
FFFC2034 00009637		add		$t3,$t3,#mbxs
FFFC2038 80060613
FFFC203C 01D60EB3
FFFC2040 004EAF03		lw		$t4,MBX_WTIDS[$t3]	; get waiting task list
FFFC2044 01CF6F33		or		$t4,$t4,$t2					; set bit for tid
FFFC2048 01EEA223		sw		$t4,MBX_WTIDS[$t3]	; save task list
FFFC204C 00A81F13		sll		$t4,$v0,#10					; convert tid to TCB pointer
FFFC2050 288F4E83		lbu		$t3,TCBStatus[$t4]
FFFC2054 008EEE93		or		$t3,$t3,#TS_WAITMSG	; set waiting for message status
FFFC2058 FFEEFE93		and		$t3,$t3,#~TS_READY	; not ready
FFFC205C 29DF0423		sb		$t3,TCBStatus[$t4]
FFFC2060 293F0523		sb		$a1,TCBWaitMbx[$t4]	; set mailbox task is waiting for
FFFC2064 000B8863		beq		$a5,$x0,.noTimelimit
FFFC2068 00086933		mov		$a0,$v0							; a0 = tid
FFFC206C 000BE9B3		mov		$a1,$a5
FFFC2070 0A8000EF		call	InsertIntoTimeoutList
                        	.noTimelimit:
                        		; Continue by switching tasks
FFFC2074 959FF06F		jmp		FMTK_Reschedule
                        	
                        	
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "../fmtk/tcb.asm",1
                        	.file "../fmtk/tcb.asm",1
                        	.file "../fmtk/tcb.asm",2
                        		code
                        		align	4                        	
                        	;------------------------------------------------------------------------------
                        	; Insert task into ready queue
                        	;
                        	; Parameters:
                        	;		a0 = tid to insert
                        	; Modifies:
                        	;		v1,t0,t1
                        	; Returns:
                        	;		v0 = 1 for success, 0 if failed
                        	;------------------------------------------------------------------------------
                        	
                        	InsertTask:
FFFC2078 FFC70713		sub		$sp,$sp,#4
FFFC207C 00172023		sw		$ra,[$sp]
FFFC2080 00F06893		ldi		$v1,#MAX_TID
FFFC2084 0728EE63		bgtu	$a0,$v1,.badTid
FFFC2088 00A91D13		sll		$t0,$a0,#10					; compute TCB address
FFFC208C 288D4883		lbu		$v1,TCBStatus[$t0]	; mark task as ready
FFFC2090 0018E893		or		$v1,$v1,#TS_READY
FFFC2094 291D0423		sb		$v1,TCBStatus[$t0]
FFFC2098 289D4883		lbu		$v1,TCBPriority[$t0]
FFFC209C 0038F893		and		$v1,$v1,#3
FFFC20A0 00004637		lbu		$t0,HRDY0[$v1]
FFFC20A4 30860613
FFFC20A8 01160633
FFFC20AC 00064D03
FFFC20B0 00004637		lbu		$t1,TRDY0[$v1]			; increment tail pointer
FFFC20B4 30C60613
FFFC20B8 01160633
FFFC20BC 00064D83
FFFC20C0 001D8D93		add		$t1,$t1,#1
FFFC20C4 05BD0263		beq		$t0,$t1,.qfull			; test queue full?
FFFC20C8 00004637		sb		$t1,TRDY0[$v1]			; store it back
FFFC20CC 30C60613
FFFC20D0 01160633
FFFC20D4 01B60023
FFFC20D8 00889E93		sll		$t3,$v1,#8					; compute t3 = readyq index
FFFC20DC 00004637		add		$t3,$t3,#RDYQ0
FFFC20E0 40060613
FFFC20E4 01D60EB3
FFFC20E8 FFFD8D93		sub		$t1,$t1,#1					; back for store
FFFC20EC 0FFDFD93		and		$t1,$t1,#255
FFFC20F0 01DD8E33		add		$t2,$t1,$t3
FFFC20F4 012E0023		sb		$a0,[$t2]						; store tid of task
FFFC20F8 00006813		ldi		$v0,#E_Ok
FFFC20FC 00000863		bra		.xit
                        	.badTid:
FFFC2100 00106813		ldi		$v0,#E_Arg
FFFC2104 00000463		bra		.xit
                        	.qfull:
FFFC2108 00506813		ldi		$v0,#E_QueFull
                        	.xit:
FFFC210C 00072083		lw		$ra,[$sp]
FFFC2110 00470713		add		$sp,$sp,#4
FFFC2114 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = task id to insert
                        	;		a1 = timeout value
                        	;------------------------------------------------------------------------------
                        	
                        	InsertIntoTimeoutList:
FFFC2118 00A91213		sll		$s1,$a0,#10				; tid to pointer
FFFC211C 00004637		lw		$t0,TimeoutList
FFFC2120 32860613
FFFC2124 00060633
FFFC2128 00062D03
FFFC212C 020D5663		bge		$t0,$x0,.0001
FFFC2130 2F322023		sw		$a1,TCBTimeout[$s1]
FFFC2134 00004637		sh		$a0,TimeoutList
FFFC2138 32860613
FFFC213C 00060633
FFFC2140 01261023
FFFC2144 FFF06D13		ldi		$t0,#-1
FFFC2148 2DA21823		sh		$t0,TCBNext[$s1]
FFFC214C 2DA21C23		sh		$t0,TCBPrev[$s1]
FFFC2150 00006813		ldi		$v0,#E_Ok
FFFC2154 00008067		ret
                        	.0001:
FFFC2158 00006DB3		mov		$t1,$x0
FFFC215C 00004637		lhu		$t2,TimeoutList
FFFC2160 32860613
FFFC2164 00060633
FFFC2168 00065E03
FFFC216C 00AE1E93		sll		$t3,$t2,#10
                        	.beginWhile:
FFFC2170 2E0EAF03		lw		$t4,TCBTimeout[$t3]
FFFC2174 013F5C63		ble		$a1,$t4,.endWhile
FFFC2178 41E989B3		sub		$a1,$a1,$t4
FFFC217C 000EEDB3		mov		$t1,$t3
FFFC2180 2D0EDE83		lhu		$t3,TCBNext[$t3]
FFFC2184 00AE9E93		sll		$t3,$t3,#10
FFFC2188 FE0004E3		bra		.beginWhile
                        	.endWhile
FFFC218C 00AEDE13		srl		$t2,$t3,#10
FFFC2190 2DC21823		sh		$t2,TCBNext[$s1]
FFFC2194 00ADDE13		srl		$t2,$t1,#10
FFFC2198 2DC21C23		sh		$t2,TCBPrev[$s1]
FFFC219C 2E0EAE03		lw		$t2,TCBTimeout[$t3]
FFFC21A0 413E0E33		sub		$t2,$t2,$a1
FFFC21A4 2FCEA023		sw		$t2,TCBTimeout[$t3]
FFFC21A8 2D2E9C23		sh		$a0,TCBPrev[$t3]
FFFC21AC 000D8663		beq		$t1,$x0,.0002
FFFC21B0 2D2D9823		sh		$a0,TCBNext[$t1]
FFFC21B4 00000A63		bra		.0003
                        	.0002:
FFFC21B8 00004637		sh		$a0,TimeoutList
FFFC21BC 32860613
FFFC21C0 00060633
FFFC21C4 01261023
                        	.0003:
FFFC21C8 28824E03		lbu		$t2,TCBStatus[$s1]
FFFC21CC 010E6E13		or		$t2,$t2,#TS_TIMEOUT
FFFC21D0 29C20423		sb		$t2,TCBStatus[$s1]
FFFC21D4 00006813		ldi		$v0,#E_Ok
FFFC21D8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	RemoveFromTimeoutList:
FFFC21DC 00A91213		sll		$s1,$a0,#10					; tid to pointer
FFFC21E0 2D025D03		lhu		$t0,TCBNext[$s1]
FFFC21E4 020D4063		blt		$t0,$x0,.0001
FFFC21E8 00AD1293		sll		$s2,$t0,#10
FFFC21EC 2D825D83		lhu		$t1,TCBPrev[$s1]
FFFC21F0 2DB29C23		sh		$t1,TCBPrev[$s2]
FFFC21F4 2E02AD83		lw		$t1,TCBTimeout[$s2]
FFFC21F8 2E022E03		lw		$t2,TCBTimeout[$s1]
FFFC21FC 01CD8DB3		add		$t1,$t1,$t2
FFFC2200 2FB2A023		sw		$t1,TCBTimeout[$s2]
                        	.0001:
FFFC2204 2D825D03		lhu		$t0,TCBPrev[$s1]
FFFC2208 000D4863		blt		$t0,$x0,.0002
FFFC220C 00AD1293		sll		$s2,$t0,#10
FFFC2210 2D025D03		lhu		$t0,TCBNext[$s1]
FFFC2214 2DA29823		sh		$t0,TCBNext[$s2]
                        	.0002:
FFFC2218 28020423		sb		$x0,TCBStatus[$s1]	; status = TS_NONE
FFFC221C FFF06D13		ldi		$t0,#-1
FFFC2220 2DA21823		sh		$t0,TCBNext[$s1]
FFFC2224 2DA21C23		sh		$t0,TCBPrev[$s1]
FFFC2228 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Pop an entry off the timeout list.
                        	;
                        	; Modifies:
                        	;		v1,t0
                        	;	Returns:
                        			v0 = timeout list entry tid
                        	;------------------------------------------------------------------------------
                        	
                        	PopTimeoutList:
FFFC222C 00004637		lhu		$v0,TimeoutList
FFFC2230 32860613
FFFC2234 00060633
FFFC2238 00065803
FFFC223C 04084263		blt		$v0,$x0,.done
FFFC2240 01006893		ldi		$v1,#NR_TCB
FFFC2244 03187E63		bgeu	$v0,$v1,.done
FFFC2248 00A81D13		sll		$t0,$v0,#10						; tid to pointer
FFFC224C 288D4883		lbu		$v1,TCBStatus[$t0]		; no longer a waiting status
FFFC2250 FE78F893		and		$v1,$v1,#~(TS_WAITMSG|TS_TIMEOUT)
	sb		$v1,TCBStatus[$t0]
FFFC2254 291D0423
FFFC2258 2D0D5883		lhu		$v1,TCBNext[$t0]
FFFC225C 00004637		sh		$v1,TimeoutList
FFFC2260 32860613
FFFC2264 00060633
FFFC2268 01161023
FFFC226C 00084A63		blt		$v0,$x0,.done
FFFC2270 01006893		ldi		$v1,#NR_TCB
FFFC2274 01187663		bgeu	$v0,$v1,.done
FFFC2278 FFF06893		ldi		$v1,#-1
FFFC227C 2D1D1C23		sh		$v1,TCBPrev[$t0]
                        	.done:	
FFFC2280 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Diagnostics
                        	;------------------------------------------------------------------------------
                        	
                        	DumpReadyQueue:
FFFC2284 FE470713		sub		$sp,$sp,#28
FFFC2288 00172023		sw		$ra,[$sp]
FFFC228C 01272223		sw		$a0,4[$sp]
FFFC2290 01472423		sw		$a2,8[$sp]
FFFC2294 01572623		sw		$a3,12[$sp]
FFFC2298 01B72823		sw		$t1,16[$sp]
FFFC229C 01C72A23		sw		$t2,20[$sp]
FFFC22A0 01D72C23		sw		$t3,24[$sp]
FFFC22A4 00006D93		ldi		$t1,#0
                        	.0002:
FFFC22A8 00D06913		ldi		$a0,#CR
FFFC22AC F0DFD0EF		call	Putch
FFFC22B0 05106913		ldi		$a0,#'Q'
FFFC22B4 F05FD0EF		call	Putch
FFFC22B8 000DE933		mov		$a0,$t1
FFFC22BC B34FE0EF		call	PutHexNybble
FFFC22C0 03A06913		ldi		$a0,#':'
FFFC22C4 EF5FD0EF		call	Putch
FFFC22C8 00004637		lbu		$a2,HRDY0[$t1]
FFFC22CC 30860613
FFFC22D0 01B60633
FFFC22D4 00064A03
FFFC22D8 00004637		lbu		$a3,TRDY0[$t1]
FFFC22DC 30C60613
FFFC22E0 01B60633
FFFC22E4 00064A83
FFFC22E8 035A0863		beq		$a2,$a3,.nxt
FFFC22EC 008D9E13		sll		$t2,$t1,#8
FFFC22F0 00004637		add		$t2,$t2,#RDYQ0
FFFC22F4 40060613
FFFC22F8 01C60E33
                        	.0001:
FFFC22FC 014E0EB3		add		$t3,$t2,$a2
FFFC2300 000EC903		lbu		$a0,[$t3]
FFFC2304 ACCFE0EF		call	PutHexByte
FFFC2308 02006913		ldi		$a0,#' '
FFFC230C EADFD0EF		call	Putch
FFFC2310 001A0A13		add		$a2,$a2,#1
FFFC2314 FF5A14E3		bne		$a2,$a3,.0001
                        	.nxt:
FFFC2318 001D8D93		add		$t1,$t1,#1
FFFC231C 004DAE13		slt		$t2,$t1,#4
FFFC2320 F80E14E3		bne		$t2,$x0,.0002
FFFC2324 00072083		lw		$ra,[$sp]
FFFC2328 00472903		lw		$a0,4[$sp]
FFFC232C 00872A03		lw		$a2,8[$sp]
FFFC2330 00C72A83		lw		$a3,12[$sp]
FFFC2334 01072D83		lw		$t1,16[$sp]
FFFC2338 01472E03		lw		$t2,20[$sp]
FFFC233C 01872E83		lw		$t3,24[$sp]
FFFC2340 01C70713		add		$sp,$sp,#28
FFFC2344 10000073		eret
                        	
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "TinyBasic.asm",1
                        	.file "TinyBasic.asm",1
                        	;****************************************************************;
                        	;                                                                ;
                        	;		Tiny BASIC for the CS01                                      ;
                        	;                                                                ;
                        	; Derived from a 68000 derivative of Palo Alto Tiny BASIC as     ;
                        	; published in the May 1976 issue of Dr. Dobb's Journal.         ;
                        	; Adapted to the 68000 by:                                       ;
                        	;	Gordon brndly						                         ;
                        	;	12147 - 51 Street					                         ;
                        	;	Edmonton AB  T5W 3G8					                     ;
                        	;	Canada							                             ;
                        	;	(updated mailing address for 1996)			                 ;
                        	;                                                                ;
                        	; Adapted to the CS01 by:                                        ;
                        	;    Robert Finch                                                ;
                        	;    Ontario, Canada                                             ;
                        	;	 robfinch<remove>@finitron.ca    	                             ;  
                        	;****************************************************************;
                        	;  Copyright (C) 2016-2020 by Robert Finch. This program may be	 ;
                        	;    freely distributed for personal use only. All commercial	 ;
                        	;		       rights are reserved.			                     ;
                        	;****************************************************************;
                        	;
                        	; Register Usage
                        	; $t2 = text pointer (global usage)
                        	; r3,r4 = inputs parameters to subroutines
                        	; a1 = return value
                        	;
                        	;* Vers. 1.0  1984/7/17	- Original version by Gordon brndly
                        	;*	1.1  1984/12/9	- Addition of '0x' print term by Marvin Lipford
                        	;*	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                        	
                        	CR		EQU	0x0D		;ASCII equates
                        	LINEFD	EQU	0x0A		; Don't use LF (same as load float instruction)
                        	TAB		EQU	0x09
                        	CTRLC	EQU	0x03
                        	CTRLH	EQU	0x08
                        	CTRLI	EQU	0x09
                        	CTRLJ	EQU	0x0A
                        	CTRLK	EQU	0x0B
                        	CTRLM   EQU 0x0D
                        	CTRLS	EQU	0x13
                        	CTRLX	EQU	0x18
                        	XON		EQU	0x11
                        	XOFF	EQU	0x13
                        	
                        	FILENAME	EQU		0x6C0
                        	FILEBUF		EQU		0x07F600
                        	OSSP		EQU		0x700
                        	TXTUNF		EQU		OSSP+4
                        	VARBGN		EQU		TXTUNF+4
                        	VAREND		EQU		VARBGN+4
                        	LOPVAR		EQU		VAREND+4
                        	STKGOS		EQU		LOPVAR+4
                        	CURRNT		EQU		STKGOS+4
                        	BUFFER		EQU		CURRNT+4
                        	BUFLEN		EQU		84
                        	LOPPT		EQU		BUFFER+84
                        	LOPLN		EQU		LOPPT+4
                        	LOPINC		EQU		LOPLN+4
                        	LOPLMT		EQU		LOPINC+4
                        	NUMWKA		EQU		LOPLMT+24
                        	STKINP		EQU		NUMWKA+4
                        	STKBOT		EQU		STKINP+4
                        	usrJmp		EQU		STKBOT+4
                        	IRQROUT		EQU		usrJmp+4
                        	
                        	OUTPTR		EQU		IRQROUT+4
                        	INPPTR		EQU		OUTPTR+4
                        	CursorFlash	EQU		INPPTR+4
                        	IRQFlag		EQU		CursorFlash+4
                        	
                        	;
                        	; Modifiable system constants:
                        	;
                        	;THRD_AREA	dw	0x04000000	; threading switch area 0x04000000-0x40FFFFF
                        	;bitmap dw	0x00100000	; bitmap graphics memory 0x04100000-0x417FFFF
                        	TXTBGN		EQU		0x001800	;TXT ;beginning of program memory
                        	ENDMEM		EQU		0x008000	; end of available memory
                        	STACKOFFS	EQU		0x07FFFC	; stack offset
                        	
                        	
                        	.file "TinyBasic.asm",84
                        			code
FFFC2348 00000000			align	25
FFFC234C 00000000
FFFC2350 00000000
FFFC2354 00000000
FFFC2358 00000000
FFFC235C 00000000
FFFC2360 00000000
FFFC2364 00000000
FFFC2368 00000000
FFFC236C 00000000
FFFC2370 00000000
FFFC2374 00000000
FFFC2378 00000000
FFFC237C 00000000
FFFC2380 00000000
FFFC2384 00000000
FFFC2388 00000000
FFFC238C 00000000
FFFC2390 00000000
FFFC2394 00000000
FFFC2398 00000000
FFFC239C 00000000
FFFC23A0 00000000
FFFC23A4 00000000
FFFC23A8 00000000
FFFC23AC 00000000
FFFC23B0 00000000
FFFC23B4 00000000
FFFC23B8 00000000
FFFC23BC 00000000
FFFC23C0 00000000
FFFC23C4 00000000
FFFC23C8 00000000
FFFC23CC 00000000
FFFC23D0 00000000
FFFC23D4 00000000
FFFC23D8 00000000
FFFC23DC 00000000
FFFC23E0 00000000
FFFC23E4 00000000
FFFC23E8 00000000
FFFC23EC 00000000
FFFC23F0 00000000
FFFC23F4 00000000
FFFC23F8 00000000
FFFC23FC 00000000
                        	
                        	;
                        	; Standard jump table. You can change these addresses if you are
                        	; customizing this interpreter for a different environment.
                        	;
                        	TinyBasic:
                        	GOSTART:	
FFFC2400 0300006F			jmp	CSTART	;	Cold Start entry point
                        	GOWARM:	
FFFC2404 0A80006F			jmp	WSTART	;	Warm Start entry point
                        	GOOUT:	
FFFC2408 5390106F			jmp	OUTC	;	Jump to character-out routine
                        	GOIN:	
FFFC240C 5390106F			jmp	INCH	;Jump to character-in routine
                        	GOAUXO:	
FFFC2410 00000637			jmp	AUXOUT	;	Jump to auxiliary-out routine
FFFC2414 1A460067
                        	GOAUXI:	
FFFC2418 00000637			jmp	AUXIN	;	Jump to auxiliary-in routine
FFFC241C 1A660067
                        	GOBYE:	
FFFC2420 5550106F			jmp	BYEBYE	;	Jump to monitor, DOS, etc.
                        	
FFFC2424 00000000		align	1
FFFC2428 00000000
FFFC242C 00000000
                        	
                        	//message "CSTART"
                        	public CSTART:
	; First save off the link register and OS sp value
FFFC2430 70E02023		sw		$sp,OSSP
FFFC2434 00080737		ldi		$sp,#STACKOFFS	; initialize stack pointer
FFFC2438 FFC70713
                        	//	call	_RequestIOFocus
                        	;	call	_DBGHomeCursor[pc]
FFFC243C 00006933		mov		a0,r0			; turn off keyboard echoing
                        	//	call	SetKeyboardEcho
                        	//	stz		CursorFlash
                        	//	ldx		#0x10000020	; black chars, yellow background
                        	;	stx		charToPrint
                        	;	call	_DBGClearScreen[pc]
FFFC2440 FFFC4937		ldi		a0,#msgInit	;	tell who we are
FFFC2444 17C90913
FFFC2448 2FD010EF		call	PRMESG
FFFC244C 00002937		ldi		a0,#TXTBGN	;	init. end-of-program pointer
FFFC2450 80090913
FFFC2454 71202223		sw		a0,TXTUNF
FFFC2458 00008937		ldi		a0,#ENDMEM	;	get address of end of memory
FFFC245C 00090913
FFFC2460 00080937		ldi		a0,#$7F800
FFFC2464 80090913
FFFC2468 79202E23		sw		a0,STKBOT
FFFC246C 00008937		ldi		a0,#ENDMEM
FFFC2470 00090913
FFFC2474 71202623		sw		a0,VAREND
FFFC2478 CE090913		sub		a0,a0,#800 	;   100 vars
FFFC247C 71202423		sw    a0,VARBGN
FFFC2480 470000EF		call  clearVars   ; clear the variable area
FFFC2484 7A002223		sw		r0,IRQROUT
FFFC2488 70802903		lw    a0,VARBGN   ; calculate number of bytes free
FFFC248C 70402983		lw		a1,TXTUNF
FFFC2490 41390933		sub   a0,a0,a1
FFFC2494 00606993		ldi		a1,#6		; max 6 digits
FFFC2498 00A06A13		ldi		a2,#10	; base 10
FFFC249C 7D8010EF		call  PRTNUM
FFFC24A0 FFFC4937		ldi		a0,#msgBytesFree
FFFC24A4 21D90913
FFFC24A8 29D010EF		call	PRMESG
                        	WSTART:
FFFC24AC 70002823		sw		x0,LOPVAR   ; initialize internal variables
FFFC24B0 70002A23		sw		x0,STKGOS
FFFC24B4 70002C23		sw		x0,CURRNT	;	current line number pointer = 0
FFFC24B8 00080737		ldi		$sp,#STACKOFFS	;	init S.P. again, just in case
FFFC24BC FFC70713
FFFC24C0 FFFC4937		ldi		a0,#msgReady	;	display "Ready"
FFFC24C4 22A90913
FFFC24C8 27D010EF		call	PRMESG
                        	BASPRMPT:
FFFC24CC 00E06913		ldi		a0,#14		; get current tid
FFFC24D0 00000073		ecall
FFFC24D4 0008E933		mov		a0,v1
FFFC24D8 8F8FE0EF		call	PutHexByte
FFFC24DC 03E06913		ldi		a0,#'>'		; Prompt with a '>' and
FFFC24E0 464010EF		call	GETLN		; read a line.
FFFC24E4 1B1010EF		call	TOUPBUF 	; convert to upper case
FFFC24E8 000E64B3		mov		$s6,$t2		; save pointer to end of line
FFFC24EC 71C06E13		ldi		$t2,#BUFFER	; point to the beginning of line
FFFC24F0 101010EF		call	TSTNUM		; is there a number there?
FFFC24F4 171010EF		call	IGNBLK		; skip trailing blanks
FFFC24F8 000E4483		lbu		$s6,[$t2]
FFFC24FC 00D4C493		xor		$s6,$s6,#CR	; s6 = flag empty line
                        	; does line no. exist? (or nonzero?)
FFFC2500 28088063		beq		v1,x0,DIRECT		; if not, it's a direct statement
FFFC2504 00100DB7		ldi		$t1,#$FFFFF
FFFC2508 FFFD8D93
FFFC250C 010DD863		ble		v0,$t1,ST2	; see if line no. is <= 16 bits
FFFC2510 FFFC4937		ldi		a0,#msgLineRange	; if not, we've overflowed
FFFC2514 24590913
FFFC2518 3E80106F		jmp		ERROR
                        	ST2:
FFFC251C 00086933	  mov		$a0,$v0		; a0 = line number
FFFC2520 000E6433	  mov		$s5,$t2			; save line buffer pointer
FFFC2524 FFCE0E13		sub		$t2,$t2,#4
FFFC2528 012E2023	  sw		$a0,[$t2]		;	This will end up in buffer
FFFC252C 50C010EF		call	FNDLN		; find this line in save area
FFFC2530 000EE533		mov		$s7,$t3		; save possible line pointer
FFFC2534 00080663		beq		$v0,$x0,INSLINE	; if not found, insert
FFFC2538 000EE933		mov		$a0,$t3
FFFC253C 044000EF		call	DeleteLine
                        	INSLINE:
FFFC2540 F80486E3		beq		$s6,$x0,BASPRMPT	; line was empty
FFFC2544 00046933		mov		$a0,$s5			; a0 = buffer pointer	
                        		; GetBuflen just get the length of the text.
                        		; A line number is stuffed just before the text
                        		; so length needs to be adjusted by 4.
FFFC2548 0A0000EF		call	GetBuflen
FFFC254C 00480393		add		$s4,$v0,#4
FFFC2550 00056933		mov		$a0,$s7
FFFC2554 0003E9B3		mov		$a1,$s4
FFFC2558 0BC000EF		call	OpenSpace
FFFC255C 00081863		bne		$v0,$x0,.0001	; space available?
FFFC2560 FFFC4937		ldi		a0,#msgTooBig	; no space available
FFFC2564 31790913
FFFC2568 3980106F		jmp		ERROR
                        	.0001:
FFFC256C 00056933		mov		$a0,$s7			; target
FFFC2570 FFC40993		sub		$a1,$s5,#4	; source (incl lineno)
FFFC2574 0003EA33		mov		$a2,$s4			; length
FFFC2578 050000EF		call	InsertLine
FFFC257C F40008E3		bra		BASPRMPT
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = pointer to line to delete
                        	; Modifies:
                        	;		t0,t1,t2,t3
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	DeleteLine:
                        		; Find the end of the line to delete
FFFC2580 00490D13		add		$t0,$a0,#4		; t0 = pointer to line past line number
FFFC2584 00D06E13		ldi		$t2,#CR
FFFC2588 70402E83		lw		$t3,TXTUNF		; last text address
                        	.0002:
FFFC258C 000D4D83		lbu		$t1,[$t0]
FFFC2590 000D8A63		beq		$t1,$x0,.0003	; might be null
FFFC2594 01CD8663		beq		$t1,$t2,.0001	; lines end with CR
FFFC2598 001D0D13		add		$t0,$t0,#1
FFFC259C FFDD68E3		bltu	$t0,$t3,.0002	; end of program?
                        	.0001:
FFFC25A0 001D0D13		add		$t0,$t0,#1
                        	.0003:
                        		; pull text after eol overtop
FFFC25A4 000D4F03		lbu		$t4,[$t0]			; copy from next line
FFFC25A8 01E90023		sb		$t4,[$a0]			; overtop deleted line
FFFC25AC 001D0D13		add		$t0,$t0,#1		; increment pointers
FFFC25B0 00190913		add		$a0,$a0,#1
FFFC25B4 FFAEF8E3		bleu	$t0,$t3,.0003	; to end of program
                        		; update end of text
FFFC25B8 412D0933		sub		$a0,$t0,$a0		; difference of pointers = length
FFFC25BC 412E8EB3		sub		$t3,$t3,$a0		
FFFC25C0 71D02223		sw		$t3,TXTUNF
FFFC25C4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = insertion point
                        	; 	a1 = source buffer
                        	; 	a2 = length
                        	; Modifies:
                        	;		a0,a1,a2,t1
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	InsertLine:
FFFC25C8 000A0E63		beq		$a2,$x0,.done		; zero length? Probably a SW error
                        	.0001:
FFFC25CC 0009CD83		lbu		$t1,[$a1]				; get from source text
FFFC25D0 01B90023		sb		$t1,[$a0]				; store to insertion point
FFFC25D4 00198993		add		$a1,$a1,#1			; increment pointers
FFFC25D8 00190913		add		$a0,$a0,#1
FFFC25DC FFFA0A13		sub		$a2,$a2,#1			; decrement length
FFFC25E0 FF4066E3		bgtu	$a2,$x0,.0001
                        	.done:
FFFC25E4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; GetBuflen - get the length of text in a buffer. The length is taken up to
                        	; the first null character or carriage return character encountered.
                        	;
                        	; Parameters:
                        	;		a0 = pointer to buffer
                        	; Modifies:
                        	;		t2,t3,t5
                        	; Returns:
                        	;		v0 = length of data in buffer
                        	;------------------------------------------------------------------------------
                        	
                        	GetBuflen:
FFFC25E8 00006813		ldi		$v0,#0
FFFC25EC 00D06E93		ldi		$t3,#CR
FFFC25F0 00096FB3		mov		$t5,$a0
                        	.0002:
FFFC25F4 000FCE03		lbu		$t2,[$t5]
FFFC25F8 001F8F93		add		$t5,$t5,#1
FFFC25FC 000E0A63		beq		$t2,$x0,.0001
FFFC2600 01DE0663		beq		$t2,$t3,.0004
FFFC2604 00180813		add		$v0,$v0,#1
FFFC2608 FE0006E3		bra		.0002
                        	.0004:
FFFC260C 00180813		add		$v0,$v0,#1
                        	.0001:
FFFC2610 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = place to insert line
                        	; 	a1 = buffer length
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		v0 = 1 if successful, 0 if not enough room available
                        	;------------------------------------------------------------------------------
                        	
                        	OpenSpace:
FFFC2614 70402E03		lw		$t2,TXTUNF
FFFC2618 000E6EB3		mov		$t3,$t2				; t3 = old end of text
FFFC261C 013E0E33		add		$t2,$t2,$a1		; increment end of text by buffer length
FFFC2620 70802D83		lw		$t1,VARBGN		; compare to start of variables
FFFC2624 03BE7263		bgeu	$t2,$t1,.noSpace	; enough room?
FFFC2628 71C02223		sw		$t2,TXTUNF		; yes, set new end of text
                        	.0003:
FFFC262C 000ECF83		lbu		$t5,[$t3]			; copy old text
FFFC2630 01FE0023		sb		$t5,[$t2]			; to new text loc
FFFC2634 FFFE8E93		sub		$t3,$t3,#1		; decrement pointers
FFFC2638 FFFE0E13		sub		$t2,$t2,#1
FFFC263C FF2EF8E3		bgeu	$t3,$a0,.0003	; until insert point reached
FFFC2640 00106813		ldi		$v0,#1				; return success
FFFC2644 00008067		ret
                        	.noSpace:
FFFC2648 00006813		ldi		$v0,#0
FFFC264C 00008067		ret	
                        	
                        	;******************************************************************
                        	;
                        	; *** Tables *** DIRECT *** EXEC ***
                        	;
                        	; This section of the code tests a string against a table. When
                        	; a match is found, control is transferred to the section of
                        	; code according to the table.
                        	;
                        	; At 'EXEC', r8 should point to the string, r9 should point to
                        	; the character table, and r10 should point to the execution
                        	; table. At 'DIRECT', r8 should point to the string, r9 and
                        	; r10 will be set up to point to TAB1 and TAB1_1, which are
                        	; the tables of all direct and statement commands.
                        	;
                        	; A '.' in the string will terminate the test and the partial
                        	; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                        	; 'PRIN.', or 'PRINT' will all match 'PRINT'.
                        	;
                        	; There are two tables: the character table and the execution
                        	; table. The character table consists of any number of text items.
                        	; Each item is a string of characters with the last character's
                        	; high bit set to one. The execution table holds a 32-bit
                        	; execution addresses that correspond to each entry in the
                        	; character table.
                        	;
                        	; The end of the character table is a 0 byte which corresponds
                        	; to the default routine in the execution table, which is
                        	; executed if none of the other table items are matched.
                        	;
                        	; Character-matching tables:
                        	TAB1:
FFFC2650 D453494C		db	"LIS",'T'+0x80        ; Direct commands
FFFC2654 C4414F4C		db	"LOA",'D'+0x80
FFFC2658 52D7454E		db	"NE",'W'+0x80
FFFC265B 53CE5552		db	"RU",'N'+0x80
FFFC265E C5564153		db	"SAV",'E'+0x80
                        	TAB2:
FFFC2662 D458454E		db	"NEX",'T'+0x80         ; Direct / statement
FFFC2666 49D4454C		db	"LE",'T'+0x80
FFFC2669 4F47C649		db	"I",'F'+0x80
FFFC266B CF544F47		db	"GOT",'O'+0x80
FFFC266F 55534F47		db	"GOSU",'B'+0x80
FFFC2673 544552C2
FFFC2674 55544552		db	"RETUR",'N'+0x80
FFFC2678 4552CE52
FFFC267A 46CD4552		db	"RE",'M'+0x80
FFFC267D 49D24F46		db	"FO",'R'+0x80
FFFC2680 55504E49		db	"INPU",'T'+0x80
FFFC2684 495250D4
FFFC2685 4E495250		db	"PRIN",'T'+0x80
FFFC2689 4B4F50D4
FFFC268A C54B4F50		db	"POK",'E'+0x80
FFFC268E 454B4F50		db	"POKE",'W'+0x80
FFFC2692 4B4F50D7
FFFC2693 454B4F50		db	"POKE",'H'+0x80
FFFC2697 454959C8
FFFC2698 4C454959		db	"YIEL",'D'+0x80
FFFC269C 4F5453C4
FFFC269D D04F5453		db	"STO",'P'+0x80
FFFC26A1 53C55942		db	"BY",'E'+0x80
FFFC26A4 43D35953		db	"SY",'S'+0x80
FFFC26A7 43D34C43		db	"CL",'S'+0x80
FFFC26AA 52D24C43	    db  "CL",'R'+0x80
FFFC26AD C6434452	    db	"RDC",'F'+0x80
FFFC26B1 52494E4F	    db	"ONIR",'Q'+0x80
FFFC26B5 494157D1
FFFC26B6 D4494157	    db	"WAI",'T'+0x80
FFFC26BA 45455000		db	0
                        	TAB4:
FFFC26BB CB454550		db	"PEE",'K'+0x80         ;Functions
FFFC26BF 4B454550		db	"PEEK",'W'+0x80
FFFC26C3 454550D7
FFFC26C4 4B454550		db	"PEEK",'H'+0x80
FFFC26C8 C44E52C8
FFFC26C9 41C44E52		db	"RN",'D'+0x80
FFFC26CC 53D34241		db	"AB",'S'+0x80
FFFC26CF 54CE4753		db  "SG",'N'+0x80
FFFC26D2 CB434954		db	"TIC",'K'+0x80
FFFC26D6 C55A4953		db	"SIZ",'E'+0x80
FFFC26DA 41D25355		db  "US",'R'+0x80
FFFC26DD 4F4C4C41	  db	"ALLOCMB",'X'+0x80
FFFC26E1 D8424D43
FFFC26E5 444E4553	  db	"SENDMS",'G'+0x80
FFFC26E9 57C7534D
FFFC26EC 54494157	  db	"WAITMS",'G'+0x80
FFFC26F0 00C7534D
FFFC26F3 00CF5400		db	0
                        	TAB5:
FFFC26F4 5300CF54		db	"T",'O'+0x80           ;"TO" in "FOR"
FFFC26F6 45545300		db	0
                        	TAB6:
FFFC26F7 D0455453		db	"STE",'P'+0x80         ;"STEP" in "FOR"
FFFC26FB 3CBD3E00		db	0
                        	TAB8:
FFFC26FC BE3CBD3E		db	'>','='+0x80           ;Relational operators
FFFC26FE BDBEBE3C		db	'<','>'+0x80
FFFC2700 BD3CBDBE		db	'>'+0x80
FFFC2701 BCBD3CBD		db	'='+0x80
FFFC2702 00BCBD3C		db	'<','='+0x80
FFFC2704 4E4100BC		db	'<'+0x80
FFFC2705 C44E4100		db	0
                        	TAB9:
FFFC2706 00C44E41	    db  "AN",'D'+0x80
FFFC2709 00D24F00	    db  0
                        	TAB10:
FFFC270A 0000D24F	    db  "O",'R'+0x80
FFFC270C 29600000	    db  0
                        	
                        	;* Execution address tables:
                        	; We save some bytes by specifiying only the low order 16 bits of the address
                        	;
FFFC270D 28296000		align	
                        	
                        	TAB1_1:
FFFC270E 2E282960		dh	LISTX			;Direct commands
FFFC2710 28082E28		dh	LOAD3
FFFC2712 28302808		dh	NEW
FFFC2714 2E902830		dh	RUN
FFFC2716 2B5C2E90		dh	SAVE3
                        	TAB2_1:
FFFC2718 2CE02B5C		dh	NEXT		;	Direct / statement
FFFC271A 2BD42CE0		dh	LET
FFFC271C 28C42BD4		dh	IF0
FFFC271E 2A4828C4		dh	GOTO
FFFC2720 2A8C2A48		dh	GOSUB
FFFC2722 2BE02A8C		dh	RETURN
FFFC2724 2AD02BE0		dh	IF2			; REM
FFFC2726 2C142AD0		dh	FOR
FFFC2728 29A82C14		dh	INPUT
FFFC272A 2FEC29A8		dh	PRINT
FFFC272C 30182FEC		dh	POKE
FFFC272E 30443018		dh	POKEW
FFFC2730 28243044		dh	POKEH
FFFC2732 281C2824		dh	YIELD0
FFFC2734 2420281C		dh	STOP
FFFC2736 307C2420		dh	GOBYE
FFFC2738 01E9307C		dh	SYSX
FFFC273A 28E801E9		dh	_cls
FFFC273C 01EB28E8		dh  _clr
FFFC273E 292801EB		dh	_rdcf
FFFC2740 29502928		dh  ONIRQ
FFFC2742 2CD42950		dh	WAITIRQ
FFFC2744 36982CD4		dh	DEFLT
                        	TAB4_1:
FFFC2746 36B03698		dh	PEEK			;Functions
FFFC2748 36C836B0		dh	PEEKW
FFFC274A 372036C8		dh	PEEKH
FFFC274C 00003720		dh	RND
FFFC274E 37B40000		dh	ABS
FFFC2750 37A037B4		dh  SGN
FFFC2752 37F037A0		dh	TICKX
FFFC2754 36E037F0		dh	SIZEX
FFFC2756 3F5C36E0		dh  USRX
FFFC2758 3FCC3F5C		dh	ALLOCMBX
FFFC275A 40683FCC		dh	SENDMSG
FFFC275C 34744068		dh	WAITMSG
FFFC275E 2AF03474		dh	XP40
                        	TAB5_1
FFFC2760 38F82AF0		dh	FR1			;"TO" in "FOR"
FFFC2762 2B0C38F8		dh	QWHAT
                        	TAB6_1
FFFC2764 2B142B0C		dh	FR2			;"STEP" in "FOR"
FFFC2766 322C2B14		dh	FR3
                        	TAB8_1
FFFC2768 3244322C		dh	XP11	;>=		Relational operators
FFFC276A 325C3244		dh	XP12	;<>
FFFC276C 328C325C		dh	XP13	;>
FFFC276E 3274328C		dh	XP15	;=
FFFC2770 32A43274		dh	XP14	;<=
FFFC2772 32E432A4		dh	XP16	;<
FFFC2774 313C32E4		dh	XP17
                        	TAB9_1
FFFC2776 3150313C	    dh  XP_AND
FFFC2778 30DC3150	    dh  XP_ANDX
                        	TAB10_1
FFFC277A 30F030DC	    dh  XP_OR
FFFC277C 000030F0	    dh  XP_ORX
                        	
                        	;*
                        	; r3 = match flag (trashed)
                        	; r9 = text table
                        	; r10 = exec table
                        	; r11 = trashed
FFFC277E 2EB70000		align	1
                        	
                        	//message "DIRECT"
                        	DIRECT:
FFFC2780 FFFC2EB7		ldi		$t3,#TAB1
FFFC2784 650E8E93
FFFC2788 FFFC2F37		ldi		$t4,#TAB1_1
FFFC278C 70EF0F13
                        	EXEC:
FFFC2790 6D4010EF		call	IGNBLK		; ignore leading blanks
FFFC2794 000E6FB3		mov		$t5,$t2		; save the pointer
FFFC2798 000061B3		mov		r3,r0		; clear match flag
                        	EXLP:
FFFC279C 000E4903		lbu		a0,[$t2]		; get the program character
FFFC27A0 001E0E13		add		$t2,$t2,#1
FFFC27A4 000EC983		lbu		a1,[$t3]		; get the table character
FFFC27A8 00099663		bne		a1,x0,EXNGO		; If end of table,
FFFC27AC 000FEE33		mov		$t2,$t5		;	restore the text pointer and...
FFFC27B0 04000263		bra		EXGO		;   execute the default.
                        	EXNGO:
FFFC27B4 04390063		beq		a0,r3,EXGO	; Else check for period... if so, execute
FFFC27B8 07F9F993		and		a1,a1,#0x7f	; ignore the table's high bit
FFFC27BC 03298263		beq		a1,a0,EXMAT	;		is there a match?
FFFC27C0 002F0F13		add		$t4,$t4,#2	;if not, try the next entry
FFFC27C4 000FEE33		mov		$t2,$t5		; reset the program pointer
FFFC27C8 000061B3		mov		r3,x0		; sorry, no match
                        	EX1:
FFFC27CC 000EC903		lbu		a0,[$t3]		; get to the end of the entry
FFFC27D0 001E8E93		add		$t3,$t3,#1
FFFC27D4 08097D93		and		$t1,$a0,#$80
FFFC27D8 FE0D8AE3		beq		$t1,$r0,EX1	; test for bit 7 set
FFFC27DC FC0000E3		bra		EXLP		; back for more matching
                        	EXMAT:
FFFC27E0 02E06193		ldi		r3,#'.'		; we've got a match so far
FFFC27E4 000EC903		lbu		a0,[$t3]		; end of table entry?
FFFC27E8 001E8E93		add		$t3,$t3,#1
FFFC27EC 08097D93		and		$t1,$a0,#$80
FFFC27F0 FA0D86E3		beq		$t1,$r0,EXLP		; test for bit 7 set, if not, go back for more
                        	EXGO:
                        		; execute the appropriate routine
FFFC27F4 000F5903		lhu		a0,[$t4]	; get the low mid order byte
FFFC27F8 FFFC0637		or		a0,a0,#$FFFC0000	; add in ROM base
FFFC27FC 00060613
FFFC2800 01266933
FFFC2804 00090067		jmp		[a0]
                        	
                        	    
                        	;******************************************************************
                        	;
                        	; What follows is the code to execute direct and statement
                        	; commands. Control is transferred to these points via the command
                        	; table lookup code of 'DIRECT' and 'EXEC' in the last section.
                        	; After the command is executed, control is transferred to other
                        	; sections as follows:
                        	;
                        	; For 'LISTX', 'NEW', and 'STOP': go back to the warm start point.
                        	; For 'RUN': go execute the first stored line if any; else go
                        	; back to the warm start point.
                        	; For 'GOTO' and 'GOSUB': go execute the target line.
                        	; For 'RETURN' and 'NEXT'; go back to saved return line.
                        	; For all others: if 'CURRNT' is 0, go to warm start; else go
                        	; execute next command. (This is done in 'FINISH'.)
                        	;
                        	;******************************************************************
                        	;
                        	; *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                        	;
                        	; 'NEW<CR>' sets TXTUNF to point to TXTBGN
                        	;
                        	
                        	NEW:
FFFC2808 0A8010EF		call	ENDCHK
FFFC280C 00002837		ldi		v0,#TXTBGN
FFFC2810 80080813
FFFC2814 71002223		sw		v0,TXTUNF	;	set the end pointer
FFFC2818 0D8000EF		call  clearVars
                        	
                        	; 'STOP<CR>' goes back to WSTART
                        	;
                        	STOP:
FFFC281C 094010EF		call	ENDCHK
FFFC2820 C8DFF06F		jmp		WSTART		; WSTART will reset the stack
                        	
                        	;------------------------------------------------------------------------------
                        	; YIELD suspends execution of TinyBasic by switching to the next ready task.
                        	;------------------------------------------------------------------------------
                        	
                        	YIELD0:
FFFC2824 00D06913		ldi		a0,#13
FFFC2828 00000073		ecall
FFFC282C 2140006F		jmp		FINISH
                        	
                        	;------------------------------------------------------------------------------
                        	; 'RUN<CR>' finds the first stored line, stores its address
                        	; in CURRNT, and starts executing it. Note that only those
                        	; commands in TAB2 are legal for a stored program.
                        	;
                        	; There are 3 more entries in 'RUN':
                        	; 'RUNNXL' finds next line, stores it's address and executes it.
                        	; 'RUNTSL' stores the address of this line and executes it.
                        	; 'RUNSML' continues the execution on same line.
                        	;
                        	RUN:
FFFC2830 080010EF		call	ENDCHK
FFFC2834 00002E37		ldi		$t2,#TXTBGN	;	set pointer to beginning
FFFC2838 800E0E13
FFFC283C 71C02C23		sw		$t2,CURRNT
FFFC2840 0B0000EF		call  clearVars
                        	
                        	RUNNXL:					; RUN <next line>
FFFC2844 71802E03		lw		$t2,CURRNT	; executing a program?
FFFC2848 000E1463		bne		$t2,x0,RUN3	; if not, we've finished a direct stat.
                        	RUN2:
FFFC284C C61FF06F		jmp		WSTART
                        	RUN3:
FFFC2850 7A402903		lw		a0,IRQROUT		; are we handling IRQ's ?
FFFC2854 02090E63		beq		a0,x0,RUN1
FFFC2858 7B402D83		lw		$t1,IRQFlag		; was there an IRQ ?
FFFC285C 020D8A63		beq		$t1,x0,RUN1
FFFC2860 7A002A23		sw		x0,IRQFlag
FFFC2864 2D0010EF		call	PUSHA_		; the same code as a GOSUB
FFFC2868 FF470713		sub		$sp,$sp,#12
FFFC286C 71402903		lw		a0,STKGOS
FFFC2870 01272023		sw		a0,[$sp]
FFFC2874 71802903		lw		a0,CURRNT
FFFC2878 01272223		sw		a0,4[$sp]
FFFC287C 01C72423		sw		$t2,8[$sp]
FFFC2880 70002823		sw		x0,LOPVAR		; load new values
FFFC2884 70E02A23		sw		$sp,STKGOS
FFFC2888 7A402E83		lw		$t3,IRQROUT
FFFC288C 00000C63		bra		RUNTSL
                        	RUN1:
FFFC2890 000E6EB3		mov		$t3,$t2
FFFC2894 00006933		mov		a0,x0
FFFC2898 1C0010EF		call	FNDLNP		; else find the next line number
FFFC289C 70402D83		lw		$t1,TXTUNF	; if we've fallen off the end, stop
FFFC28A0 FBBEF6E3		bgeu	$t3,$t1,RUN2
                        	
                        	RUNTSL:					; RUN <this line>
FFFC28A4 71D02C23		sw		$t3,CURRNT	; set CURRNT to point to the line no.
FFFC28A8 004E8E13		add		$t2,$t3,#4	; set the text pointer to
                        	
                        	RUNSML:                 ; RUN <same line>
FFFC28AC 668010EF		call	CHKIO		; see if a control-C was pressed
FFFC28B0 FFFC2EB7		ldi		$t3,#TAB2		; find command in TAB2
FFFC28B4 662E8E93
FFFC28B8 FFFC2F37		ldi		$t4,#TAB2_1
FFFC28BC 718F0F13
FFFC28C0 ED1FF06F		jmp		EXEC		; and execute it
                        	
                        	
                        	;******************************************************************
                        	; 'GOTO expr<CR>' evaluates the expression, finds the target
                        	; line, and jumps to 'RUNTSL' to do it.
                        	;******************************************************************
                        	;
                        	GOTO:
FFFC28C4 7E4000EF		call	OREXPR		;evaluate the following expression
FFFC28C8 000862B3		mov   r5,v0
FFFC28CC 7E5000EF		call 	ENDCHK		;must find end of line
FFFC28D0 0002E933		mov   a0,r5
FFFC28D4 164010EF		call 	FNDLN		; find the target line
FFFC28D8 FC0816E3		bne		v0,x0,RUNTSL; go do it
FFFC28DC FFFC4937		ldi		a0,#msgBadGotoGosub
FFFC28E0 2E590913
FFFC28E4 01C0106F		jmp		ERROR		; no such line no.
                        	
                        	_clr:
FFFC28E8 008000EF	    call    clearVars
FFFC28EC 1540006F	    jmp     FINISH
                        	
                        	; Clear the variable area of memory
                        	clearVars:
FFFC28F0 FF870713		sub		$sp,$sp,#8
FFFC28F4 00672023		sw		r6,[$sp]
FFFC28F8 00172223		sw		$ra,4[$sp]
FFFC28FC 06406313	  ldi   r6,#100    	; number of word pairs to clear
FFFC2900 70802803	  lw    v0,VARBGN
                        	.cv1:
FFFC2904 00082023	  sw		x0,[$v0]		; variable name
FFFC2908 00082223	  sw		x0,4[$v0]		; and value
FFFC290C 00880813	  add		v0,v0,#8
FFFC2910 FFF30313	  sub		r6,r6,#1
FFFC2914 FE6048E3		bgt		r6,x0,.cv1
FFFC2918 00072303	  lw		r6,[$sp]
FFFC291C 00472083	  lw		$ra,4[$sp]
FFFC2920 00870713	  add		$sp,$sp,#8
FFFC2924 00008067	  ret
                        	
                        	;******************************************************************
                        	; ONIRQ <line number>
                        	; ONIRQ sets up an interrupt handler which acts like a specialized
                        	; subroutine call. ONIRQ is coded like a GOTO that never executes.
                        	;******************************************************************
                        	;
                        	ONIRQ:
FFFC2928 780000EF		call	OREXPR		;evaluate the following expression
FFFC292C 000862B3		mov   r5,v0
FFFC2930 781000EF		call 	ENDCHK		;must find end of line
FFFC2934 0002E933		mov   a0,r5
FFFC2938 100010EF		call 	FNDLN		; find the target line
FFFC293C 00081663		bne		v0,r0,ONIRQ1
FFFC2940 7A002223		sw		x0,IRQROUT
FFFC2944 0FC0006F		jmp		FINISH
                        	ONIRQ1:
FFFC2948 7BD02223		sw		$t3,IRQROUT
FFFC294C 0F40006F		jmp		FINISH
                        	
                        	WAITIRQ:
FFFC2950 5C4010EF		call	CHKIO		; see if a control-C was pressed
FFFC2954 7B402D83		lw		$t1,IRQFlag
FFFC2958 FE0D8CE3		beq		$t1,x0,WAITIRQ
FFFC295C 0E40006F		jmp		FINISH
                        	
                        	
                        	;******************************************************************
                        	; LIST
                        	;
                        	; LISTX has two forms:
                        	; 'LIST<CR>' lists all saved lines
                        	; 'LIST #<CR>' starts listing at the line #
                        	; Control-S pauses the listing, control-C stops it.
                        	;******************************************************************
                        	;
                        	LISTX:
FFFC2960 490010EF		call		TSTNUM		; see if there's a line no.
FFFC2964 000862B3		mov      r5,v0
FFFC2968 749000EF		call		ENDCHK		; if not, we get a zero
FFFC296C 0002E933		mov      a0,r5
FFFC2970 0C8010EF		call		FNDLN		; find this or next line
                        	LS1:
FFFC2974 00081663		bne		v0,r0,LS4
                        	LS5:
FFFC2978 70402D83		lw		$t1,TXTUNF
FFFC297C B3BEF8E3		bgeu	$t3,$t1,WSTART	; warm start if we passed the end
                        	LS4:
FFFC2980 000EE933		mov		a0,$t3
FFFC2984 3C4010EF		call	PRTLN		; print the line
FFFC2988 00086EB3		mov		$t3,$v0		; set pointer for next
FFFC298C 588010EF		call	CHKIO		; check for listing halt request
FFFC2990 00080A63		beq		v0,x0,LS3
FFFC2994 01306D93		ldi		$t1,#CTRLS
FFFC2998 01B81663		bne		v0,$t1,LS3; pause the listing?
                        	LS2:
FFFC299C 578010EF		call 	CHKIO		; if so, wait for another keypress
FFFC29A0 FE080EE3		beq		v0,r0,LS2
                        	LS3:
                        	;	mov		$v0,$x0
FFFC29A4 FC000AE3		bra		LS5
                        	;	mov		a0,r0
                        	;	call	FNDSKP	;FNDLNP		; find the next line
                        	;	bra		LS1
                        	
                        	
                        	;******************************************************************
                        	; PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                        	; where '....' is a list of expressions, formats, back-arrows,
                        	; and strings.	These items a separated by commas.
                        	;
                        	; A format is a pound sign followed by a number.  It controls
                        	; the number of spaces the value of an expression is going to
                        	; be printed in.  It stays effective for the rest of the print
                        	; command unless changed by another format.  If no format is
                        	; specified, 11 positions will be used.
                        	;
                        	; A string is quoted in a pair of single- or double-quotes.
                        	;
                        	; An underline (back-arrow) means generate a <CR> without a <LF>
                        	;
                        	; A <CR LF> is generated after the entire list has been printed
                        	; or if the list is empty.  If the list ends with a semicolon,
                        	; however, no <CR LF> is generated.
                        	;******************************************************************
                        	;
                        	PRINT:
FFFC29A8 00B06293		ldi		r5,#11		; D4 = number of print spaces
FFFC29AC 3F8010EF		call	TSTC		; if null list and ":"
FFFC29B0 0000003A		dw		':'
FFFC29B4 00000663		bra		PR2
FFFC29B8 584010EF		call	CRLF		; give CR-LF and continue
FFFC29BC EF1FF06F		jmp		RUNSML		;		execution on the same line
                        	PR2:
FFFC29C0 3E4010EF		call	TSTC		;if null list and <CR>
FFFC29C4 0000000D		dw		CR
FFFC29C8 00000663		bra		PR0
FFFC29CC 570010EF		call	CRLF		;also give CR-LF and
FFFC29D0 E75FF06F		jmp		RUNNXL		;execute the next line
                        	PR0:
FFFC29D4 3D0010EF		call	TSTC		;else is it a format?
FFFC29D8 00000023		dw		'#'
FFFC29DC 00000863		bra		PR1
FFFC29E0 6C8000EF		call	OREXPR		; yes, evaluate expression
FFFC29E4 000862B3		mov		r5,v0	; and save it as print width
FFFC29E8 02000263		bra		PR3		; look for more to print
                        	PR1:
FFFC29EC 3B8010EF		call	TSTC	;	is character expression? (MRL)
FFFC29F0 00000024		dw		'$'
FFFC29F4 00000863		bra		PR4
FFFC29F8 6B0000EF		call	OREXPR	;	yep. Evaluate expression (MRL)
FFFC29FC A0DFF0EF		call	GOOUT	;	print low byte (MRL)
FFFC2A00 00000663		bra		PR3		;look for more. (MRL)
                        	PR4:
FFFC2A04 1DC010EF		call	QTSTG	;	is it a string?
                        		; the following branch must occupy only 1 word!
FFFC2A08 02000063		bra		PR8		;	if not, must be an expression
                        	PR3:
FFFC2A0C 398010EF		call		TSTC	;	if ",", go find next
FFFC2A10 0000002C		dw		','
FFFC2A14 00000663		bra		PR6
FFFC2A18 65D000EF		call		FIN		;in the list.
FFFC2A1C FA000CE3		bra		PR0
                        	PR6:
FFFC2A20 51C010EF		call		CRLF		;list ends here
FFFC2A24 01C0006F		jmp		FINISH
                        	PR8:
FFFC2A28 680000EF		call	OREXPR		; evaluate the expression
FFFC2A2C 00086933		mov		a0,v0
FFFC2A30 00506993		ldi		a1,#5		; set the width
FFFC2A34 00A06A13		ldi		a2,#10
FFFC2A38 23C010EF		call	PRTNUM		; print its value
FFFC2A3C FC0008E3		bra		PR3			; more to print?
                        	
                        	
                        	FINISH:
FFFC2A40 635000EF		call	FIN		; Check end of command
FFFC2A44 6B50006F		jmp		QWHAT	; print "What?" if wrong
                        	
                        	
                        	;*******************************************************************
                        	;
                        	; *** GOSUB *** & RETURN ***
                        	;
                        	; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                        	; except that the current text pointer, stack pointer, etc. are
                        	; saved so that execution can be continued after the subroutine
                        	; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                        	; recursive), the save area must be stacked.  The stack pointer
                        	; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                        	; If we are in the main routine, 'STKGOS' is zero (this was done
                        	; in the initialization section of the interpreter), but we still
                        	; save it as a flag for no further 'RETURN's.
                        	;******************************************************************
                        	;
                        	GOSUB:
FFFC2A48 0EC010EF		call	PUSHA_		; save the current 'FOR' parameters
FFFC2A4C 65C000EF		call	OREXPR		; get line number
FFFC2A50 00086933		mov		$a0,$v0
FFFC2A54 7E5000EF		call	FNDLN		; find the target line
FFFC2A58 00081863		bne		v0,r0,gosub1
FFFC2A5C FFFC4937		ldi		a0,#msgBadGotoGosub
FFFC2A60 2E590913
FFFC2A64 69D0006F		jmp		ERROR		; if not there, say "How?"
                        	gosub1:
FFFC2A68 FF470713		sub		$sp,$sp,#12
FFFC2A6C 71402903		lw		a0,STKGOS	; 'STKGOS'
FFFC2A70 01272023		sw		a0,[$sp]
FFFC2A74 71802903		lw		a0,CURRNT	; found it, save old 'CURRNT'...
FFFC2A78 01272223		sw		a0,4[$sp]
FFFC2A7C 01C72423		sw		$t2,8[$sp]
FFFC2A80 70002823		sw		$x0,LOPVAR		; load new values
FFFC2A84 70E02A23		sw		$sp,STKGOS
FFFC2A88 E1DFF06F		jmp		RUNTSL
                        	
                        	
                        	;******************************************************************
                        	; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                        	; returns the execution to the command after the most recent
                        	; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                        	; a 'GOSUB' and is thus an error.
                        	;******************************************************************
                        	;
                        	RETURN:
FFFC2A8C 625000EF		call	ENDCHK		; there should be just a <CR>
FFFC2A90 71402983		lw		a1,STKGOS		; get old stack pointer
FFFC2A94 00099863		bne		a1,x0,return1
FFFC2A98 FFFC4937		ldi		a0,#msgRetWoGosub
FFFC2A9C 30190913
FFFC2AA0 6610006F		jmp		ERROR		; if zero, it doesn't exist
                        	return1:
FFFC2AA4 0009E733		mov		$sp,a1		; else restore it
FFFC2AA8 00072903		lw		a0,[$sp]
FFFC2AAC 00470713		add		$sp,$sp,#4
FFFC2AB0 71202A23		sw		a0,STKGOS	; and the old 'STKGOS'
FFFC2AB4 00072903		lw		a0,[$sp]
FFFC2AB8 00470713		add		$sp,$sp,#4
FFFC2ABC 71202C23		sw		a0,CURRNT	; and the old 'CURRNT'
FFFC2AC0 00072E03		lw		$t2,[$sp]	; and the old text pointer
FFFC2AC4 00470713		add		$sp,$sp,#4
FFFC2AC8 034010EF		call	POPA_		;and the old 'FOR' parameters
FFFC2ACC F75FF06F		jmp		FINISH		;and we are back home
                        	
                        	;******************************************************************
                        	; *** FOR *** & NEXT ***
                        	;
                        	; 'FOR' has two forms:
                        	; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                        	; The second form means the same thing as the first form with a
                        	; STEP of positive 1.  The interpreter will find the variable 'var'
                        	; and set its value to the current value of 'exp1'.  It also
                        	; evaluates 'exp2' and 'exp1' and saves all these together with
                        	; the text pointer, etc. in the 'FOR' save area, which consists of
                        	; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                        	; already something in the save area (indicated by a non-zero
                        	; 'LOPVAR'), then the old save area is saved on the stack before
                        	; the new values are stored.  The interpreter will then dig in the
                        	; stack and find out if this same variable was used in another
                        	; currently active 'FOR' loop.  If that is the case, then the old
                        	; 'FOR' loop is deactivated. (i.e. purged from the stack)
                        	;******************************************************************
                        	;
                        	FOR:
FFFC2AD0 064010EF		call	PUSHA_		; save the old 'FOR' save area
FFFC2AD4 539000EF		call	SETVAL		; set the control variable
FFFC2AD8 71002823		sw		v0,LOPVAR		; save its address
FFFC2ADC FFFC2EB7		ldi		$t3,#TAB5
FFFC2AE0 6F4E8E93
FFFC2AE4 FFFC2F37		ldi		$t4,#TAB5_1	; use 'EXEC' to test for 'TO'
FFFC2AE8 760F0F13
FFFC2AEC CA5FF06F		jmp		EXEC
                        	FR1:
FFFC2AF0 5B8000EF		call	OREXPR		; evaluate the limit
FFFC2AF4 77002E23		sw		v0,LOPLMT	; save that
FFFC2AF8 FFFC2EB7		ldi		$t3,#TAB6
FFFC2AFC 6F7E8E93
FFFC2B00 FFFC2F37		ldi		$t4,#TAB6_1	; use 'EXEC' to test for the word 'STEP
FFFC2B04 764F0F13
FFFC2B08 C89FF06F		jmp		EXEC
                        	FR2:
FFFC2B0C 59C000EF		call	OREXPR		; found it, get the step value
FFFC2B10 00000463		bra		FR4
                        	FR3:
FFFC2B14 00106813		ldi		v0,#1		; not found, step defaults to 1
                        	FR4:
FFFC2B18 77002C23		sw		v0,LOPINC	; save that too
                        	FR5:
FFFC2B1C 71802983		lw		a1,CURRNT
FFFC2B20 77302A23		sw		a1,LOPLN	; save address of current line number
FFFC2B24 77C02823		sw		$t2,LOPPT	; and text pointer
FFFC2B28 000761B3		mov		r3,$sp		; dig into the stack to find 'LOPVAR'
FFFC2B2C 71002303		lw		r6,LOPVAR
FFFC2B30 00000463		bra		FR7
                        	FR6:
FFFC2B34 01418193		add		r3,r3,#20	; look at next stack frame
                        	FR7:
FFFC2B38 0001A983		lw		a1,[r3]		; is it zero?
FFFC2B3C 00098E63		beq		a1,x0,FR8	; if so, we're done
FFFC2B40 FE699AE3		bne		a1,r6,FR6	; same as current LOPVAR? nope, look some more
                        	
FFFC2B44 0001E933	  mov		a0,r3	   ; Else remove 5 words from...
FFFC2B48 000769B3		mov		a1,$sp
FFFC2B4C 01418A13		add		a2,r3,#20  ; inside the stack.
FFFC2B50 7A5000EF		call	MVDOWN
FFFC2B54 01470713		add		$sp,$sp,#20	; set the SP 5 long words up
                        	;	lw		a0,[$sp]		; ???
                        	;	add		$sp,$sp,#4
                        	FR8:
FFFC2B58 EE9FF06F	  jmp	    FINISH		; and continue execution
                        	
                        	
                        	;******************************************************************
                        	; 'NEXT var' serves as the logical (not necessarily physical) end
                        	; of the 'FOR' loop.  The control variable 'var' is checked with
                        	; the 'LOPVAR'.  If they are not the same, the interpreter digs in
                        	; the stack to find the right one and purges all those that didn't
                        	; match.  Either way, it then adds the 'STEP' to that variable and
                        	; checks the result with against the limit value.  If it is within
                        	; the limit, control loops back to the command following the
                        	; 'FOR'.  If it's outside the limit, the save area is purged and
                        	; execution continues.
                        	;******************************************************************
                        	;
                        	NEXT:
FFFC2B5C 00006933		mov		a0,x0		; don't allocate it
FFFC2B60 189000EF		call	TSTV		; get address of variable
FFFC2B64 00081863		bne		v0,x0,NX4
FFFC2B68 FFFC4937		ldi		a0,#msgNextVar
FFFC2B6C 2C290913
FFFC2B70 580008E3		bra		ERROR		; if no variable, say "What?"
                        	NX4:
FFFC2B74 00086EB3		mov		$t3,v0	; save variable's address
                        	NX0:
FFFC2B78 71002903		lw		a0,LOPVAR	; If 'LOPVAR' is zero, we never...
FFFC2B7C 00091863		bne		a0,x0,NX5	; had a FOR loop
FFFC2B80 FFFC4937		ldi		a0,#msgNextFor
FFFC2B84 2B090913
FFFC2B88 56000CE3		bra		ERROR
                        	NX5:
FFFC2B8C 01D90663		beq		a0,$t3,NX2	; else we check them OK, they agree
FFFC2B90 76D000EF		call	POPA_		; nope, let's see the next frame
FFFC2B94 FE0002E3		bra		NX0
                        	NX2:
FFFC2B98 000EA903		lw		a0,[$t3]		; get control variable's value
FFFC2B9C 77802983		lw		a1,LOPINC
FFFC2BA0 01390933		add		a0,a0,a1	; add in loop increment
                        	;	BVS.L	QHOW		say "How?" for 32-bit overflow
FFFC2BA4 012EA023		sw		a0,[$t3]		; save control variable's new value
FFFC2BA8 77C02183		lw		r3,LOPLMT	; get loop's limit value
FFFC2BAC 0009D663		bge		a1,x0,NX1	; check loop increment, branch if loop increment is positive
FFFC2BB0 00394E63		blt		a0,r3,NXPurge	; test against limit
FFFC2BB4 00000463		bra     NX3
                        	NX1:
FFFC2BB8 0121CA63		bgt		a0,r3,NXPurge
                        	NX3:
FFFC2BBC 77402E03		lw		$t2,LOPLN	; Within limit, go back to the...
FFFC2BC0 71C02C23		sw		$t2,CURRNT
FFFC2BC4 77002E03		lw		$t2,LOPPT	; saved 'CURRNT' and text pointer.
FFFC2BC8 E79FF06F		jmp		FINISH
                        	NXPurge:
FFFC2BCC 731000EF	  call    POPA_        ; purge this loop
FFFC2BD0 E71FF06F	  jmp     FINISH
                        	
                        	
                        	;******************************************************************
                        	; *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                        	;
                        	; 'REM' can be followed by anything and is ignored by the
                        	; interpreter.
                        	;
                        	;REM
                        	;    br	    IF2		    ; skip the rest of the line
                        	; 'IF' is followed by an expression, as a condition and one or
                        	; more commands (including other 'IF's) separated by colons.
                        	; Note that the word 'THEN' is not used.  The interpreter evaluates
                        	; the expression.  If it is non-zero, execution continues.  If it
                        	; is zero, the commands that follow are ignored and execution
                        	; continues on the next line.
                        	;******************************************************************
                        	;
                        	IF0:
FFFC2BD4 4D4000EF	  call	OREXPR		; evaluate the expression
                        	IF1:
FFFC2BD8 00080463	  beq	  v0,x0,IF2	; is it zero? if not, continue
FFFC2BDC CD1FF06F	  jmp		RUNSML
                        	IF2:
FFFC2BE0 000E6EB3	  mov		$t3,$t2	; set lookup pointer
FFFC2BE4 00006933		mov		a0,x0		; find line #0 (impossible)
FFFC2BE8 6D1000EF		call	FNDSKP		; if so, skip the rest of the line
FFFC2BEC 00081463		bne		v0,x0,IF3; if no next line, do a warm start
FFFC2BF0 8BDFF06F		jmp		WSTART
                        	IF3:
FFFC2BF4 CB1FF06F		jmp		RUNTSL		; run the next line
                        	
                        	
                        	;******************************************************************
                        	; INPUT is called first and establishes a stack frame
                        	INPERR:
FFFC2BF8 79802703		lw		$sp,STKINP		; restore the old stack pointer
FFFC2BFC 00072903		lw		a0,[$sp]
FFFC2C00 00470713		add		$sp,$sp,#4
FFFC2C04 71202C23		sw		a0,CURRNT		; and old 'CURRNT'
FFFC2C08 00072E03		lw		$t2,[$sp]		; and old text pointer
FFFC2C0C 00470713		add		$sp,$sp,#4
FFFC2C10 01470713		add		$sp,$sp,#20	; fall through will subtract 20
                        	
                        	; 'INPUT' is like the 'PRINT' command, and is followed by a list
                        	; of items.  If the item is a string in single or double quotes,
                        	; or is an underline (back arrow), it has the same effect as in
                        	; 'PRINT'.  If an item is a variable, this variable name is
                        	; printed out followed by a colon, then the interpreter waits for
                        	; an expression to be typed in.  The variable is then set to the
                        	; value of this expression.  If the variable is preceeded by a
                        	; string (again in single or double quotes), the string will be
                        	; displayed followed by a colon.  The interpreter the waits for an
                        	; expression to be entered and sets the variable equal to the
                        	; expression's value.  If the input expression is invalid, the
                        	; interpreter will print "What?", "How?", or "Sorry" and reprint
                        	; the prompt and redo the input.  The execution will not terminate
                        	; unless you press control-C.  This is handled in 'INPERR'.
                        	;
                        	INPUT:
FFFC2C14 FEC70713		sub		$sp,$sp,#20	; allocate five words on stack
FFFC2C18 00572823		sw		r5,16[$sp]	; save off r5 into stack var
                        	IP6:
FFFC2C1C 01C72023		sw		$t2,[$sp]	; save in case of error
FFFC2C20 7C1000EF		call	QTSTG		; is next item a string?
FFFC2C24 00000C63		bra		IP2			; nope - this branch must take only 1 word
FFFC2C28 00106913		ldi		a0,#1		; allocate var
FFFC2C2C 0BD000EF		call	TSTV		; yes, but is it followed by a variable?
FFFC2C30 08090463		beq    a0,r0,IP4   ; if not, brnch
FFFC2C34 00096F33		mov		$t4,a0		; put away the variable's address
FFFC2C38 04000063		bra		IP3			; if so, input to variable
                        	IP2:
FFFC2C3C 01C72223		sw		$t2,4[$sp]	; save off in stack var for 'PRTSTG'
FFFC2C40 00106913		ldi		a0,#1
FFFC2C44 0A5000EF		call	TSTV		; must be a variable now
FFFC2C48 00091A63		bne		a0,r0,IP7
FFFC2C4C FFFC4937		ldi		a0,#msgInputVar
FFFC2C50 29490913
FFFC2C54 01470713		add		$sp,$sp,#20	; cleanup stack
FFFC2C58 4A0004E3		bra		ERROR		; "What?" it isn't?
                        	IP7:
FFFC2C5C 00096F33		mov		$t4,a0		; put away the variable's address
FFFC2C60 000E4283		lbu		r5,[$t2]		; get ready for 'PRTSTG' by null terminating
FFFC2C64 000E0023		sb		x0,[$t2]
FFFC2C68 000069B3		mov		a1,x0
FFFC2C6C 00472903		lw		a0,4[$sp]	; get back text pointer
FFFC2C70 709000EF		call	PRTSTG		; print string as prompt
FFFC2C74 005E0023		sb		r5,[$t2]		; un-null terminate
                        	IP3
FFFC2C78 01C72223		sw		$t2,4[$sp]	; save in case of error
FFFC2C7C 71802903		lw		a0,CURRNT
FFFC2C80 01272423		sw		a0,8[$sp]	; also save 'CURRNT'
FFFC2C84 FFF06913		ldi		a0,#-1
FFFC2C88 71202C23		sw		a0,CURRNT	; flag that we are in INPUT
FFFC2C8C 78E02C23		sw		$sp,STKINP	; save the stack pointer too
FFFC2C90 01E72623		sw		$t4,12[$sp]	; save the variable address
FFFC2C94 03A06913		ldi		a0,#':'		; print a colon first
FFFC2C98 4AD000EF		call	GETLN		; then get an input line
FFFC2C9C 71C06E13		ldi		$t2,#BUFFER	; point to the buffer
FFFC2CA0 408000EF		call	OREXPR		; evaluate the input
FFFC2CA4 00C72F03		lw		$t4,12[$sp]	; restore the variable address
FFFC2CA8 012F2023		sw		a0,[$t4]	; save value in variable
FFFC2CAC 00872903		lw		a0,8[$sp]	; restore old 'CURRNT'
FFFC2CB0 71202C23		sw		a0,CURRNT
FFFC2CB4 00472E03		lw		$t2,4[$sp]	; and the old text pointer
                        	IP4:
FFFC2CB8 0EC010EF		call	TSTC
FFFC2CBC 0000002C		dw		','
FFFC2CC0 00000463		bra		IP5
FFFC2CC4 F4000CE3		bra		IP6			; yes, more items
                        	IP5:
FFFC2CC8 01072283		lw		r5,16[$sp]
FFFC2CCC 01470713		add		$sp,$sp,#20	; cleanup stack
FFFC2CD0 D71FF06F	 	jmp		FINISH
                        	
                        	
                        	DEFLT:
FFFC2CD4 000E4903	  lbu    	a0,[$t2]
FFFC2CD8 00D06D93	  ldi			$t1,#CR
FFFC2CDC D7B902E3		beq	    a0,$t1,FINISH	    ; empty line is OK else it is 'LET'
                        	
                        	
                        	;******************************************************************
                        	; 'LET' is followed by a list of items separated by commas.
                        	; Each item consists of a variable, an equals sign, and an
                        	; expression.  The interpreter evaluates the expression and sets
                        	; the variable to that value.  The interpreter will also handle
                        	; 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                        	;******************************************************************
                        	;
                        	LET:
FFFC2CE0 32D000EF	  call	SETVAL		; do the assignment
FFFC2CE4 0C0010EF		call	TSTC		; check for more 'LET' items
FFFC2CE8 0000002C		dw		','
FFFC2CEC D55FF06F		jmp		FINISH
FFFC2CF0 FE0008E3		bra	    LET
                        	LT1:
FFFC2CF4 D4DFF06F	  jmp	    FINISH		; until we are finished.
                        	
                        	
                        	;******************************************************************
                        	; *** LOAD *** & SAVE ***
                        	;
                        	; These two commands transfer a program to/from an auxiliary
                        	; device such as a cassette, another computer, etc.  The program
                        	; is converted to an easily-stored format: each line starts with
                        	; a colon, the line no. as 4 hex digits, and the rest of the line.
                        	; At the end, a line starting with an '@' sign is sent.  This
                        	; format can be read back with a minimum of processing time by
                        	; the RTF65002
                        	;******************************************************************
                        	;
                        	LOAD
FFFC2CF8 00002E37		ldi		$t2,#TXTBGN	; set pointer to start of prog. area
FFFC2CFC 800E0E13
FFFC2D00 00D06913		ldi		a0,#CR		; For a CP/M host, tell it we're ready...
FFFC2D04 F0CFF0EF		call	GOAUXO		; by sending a CR to finish PIP command.
                        	LOD1:
FFFC2D08 F10FF0EF		call	GOAUXI		; look for start of line
FFFC2D0C FF205EE3		ble		a0,r0,LOD1
FFFC2D10 04006D93		ldi		$t1,#'@'
FFFC2D14 03B90E63		beq		a0,$t1,LODEND	; end of program?
FFFC2D18 01A06D93		ldi		$t1,#$1A
FFFC2D1C 03B90A63		beq		a0,$t1,LODEND	; or EOF marker
FFFC2D20 03A06D93		ldi		$t1,#':'
FFFC2D24 FFB912E3		bne		a0,$t1,LOD1	; if not, is it start of line? if not, wait for it
FFFC2D28 030000EF		call	GCHAR		; get line number
FFFC2D2C 012E2023		sw		a0,[$t2]		; store it
FFFC2D30 004E0E13		add		$t2,$t2,#4
                        	LOD2:
FFFC2D34 EE4FF0EF		call	GOAUXI		; get another text char.
FFFC2D38 FF205EE3		ble		a0,r0,LOD2
FFFC2D3C 012E0023		sb		a0,[$t2]		; store it
FFFC2D40 001E0E13		add		$t2,$t2,#1
FFFC2D44 00D06D93		ldi		$t1,#CR
FFFC2D48 FFB916E3		bne		a0,$t1,LOD2		; is it the end of the line? if not, go back for more
FFFC2D4C FA000EE3		bra		LOD1		; if so, start a new line
                        	LODEND:
FFFC2D50 71C02223		sw		$t2,TXTUNF	; set end-of program pointer
FFFC2D54 F58FF06F		jmp		WSTART		; back to direct mode
                        	
                        	
                        	; get character from input (32 bit value)
                        	GCHAR:
FFFC2D58 FF470713		sub		$sp,$sp,#12
FFFC2D5C 00572023		sw		r5,[$sp]
FFFC2D60 00672223		sw		r6,4[$sp]
FFFC2D64 00172423		sw		$ra,8[$sp]
FFFC2D68 00806313		ldi		r6,#8       ; repeat ten times
FFFC2D6C 00006293		ldi		r5,#0
                        	GCHAR1:
FFFC2D70 EA8FF0EF		call	GOAUXI		; get a char
FFFC2D74 FF205EE3		ble		a0,r0,GCHAR1
FFFC2D78 02C000EF		call	asciiToHex
FFFC2D7C 00429293		sll		r5,r5,#4
FFFC2D80 0122E2B3		or		r5,r5,a0
FFFC2D84 FFF30313		sub		r6,r6,#1
FFFC2D88 FE6064E3		bgtu	r6,r0,GCHAR1
FFFC2D8C 0002E933		mov		a0,r5
FFFC2D90 00072283		lw		r5,[$sp]
FFFC2D94 00472303		lw		r6,4[$sp]
FFFC2D98 00872083		lw		$ra,8[$sp]
FFFC2D9C 00C70713		add		$sp,$sp,#12
FFFC2DA0 00008067		ret
                        	
                        	; convert an ascii char to hex code
                        	; input
                        	;	a0 = char to convert
                        	
                        	asciiToHex:
FFFC2DA4 03906D93		ldi		$t1,#'9'
FFFC2DA8 012DF463		bleu	a0,$t1,a2h1; less than '9'
FFFC2DAC FF990913		sub		a0,a0,#7	; shift 'A' to '9'+1
                        	a2h1:
FFFC2DB0 FD090913		sub		a0,a0,#'0'
FFFC2DB4 00F97913		and		a0,a0,#15	; make sure a nybble
FFFC2DB8 00008067		ret
                        	
                        	GetFilename:
FFFC2DBC FFC70713		sub		$sp,$sp,#4
FFFC2DC0 00172023		sw		$ra,[$sp]
FFFC2DC4 7E1000EF		call	TSTC
FFFC2DC8 00000022		dw		'"'
FFFC2DCC 04000C63		bra		gfn1
FFFC2DD0 000061B3		mov		r3,r0
                        	gfn2:
FFFC2DD4 000E4903		lbu		a0,[$t2]		; get text character
FFFC2DD8 001E0E13		add		$t2,$t2,#1
FFFC2DDC 02206D93		ldi		$t1,#'"'
FFFC2DE0 03B90263		beq		a0,$t1,gfn3
FFFC2DE4 02090063		beq		a0,r0,gfn3
FFFC2DE8 6D218023		sb		a0,FILENAME[r3]
FFFC2DEC 00118193		add		r3,r3,#1
FFFC2DF0 04006D93		ldi		$t1,#64
FFFC2DF4 FFB1E0E3		bltu	r3,$t1,gfn2
FFFC2DF8 00072083		lw		$ra,[$sp]
FFFC2DFC 00470713		add		$sp,$sp,#4
FFFC2E00 00008067		ret
                        	gfn3:
FFFC2E04 02006913		ldi		a0,#' '
FFFC2E08 6D218023		sb		a0,FILENAME[r3]
FFFC2E0C 00118193		add		r3,r3,#1
FFFC2E10 04006D93		ldi		$t1,#64
FFFC2E14 FFB1E8E3		bltu	r3,$t1,gfn3
FFFC2E18 00072083		lw		$ra,[$sp]
FFFC2E1C 00470713		add		$sp,$sp,#4
FFFC2E20 00008067		ret
                        	gfn1:
FFFC2E24 E88FF06F		jmp		WSTART
                        	
                        	LOAD3:
FFFC2E28 F95FF0EF		call	GetFilename
FFFC2E2C 00000637		call	AUXIN_INIT
FFFC2E30 264600E7
FFFC2E34 EC5FF06F		jmp		LOAD
                        	
                        	;	call		OREXPR		;evaluate the following expression
                        	;	ld		a0,#5000
FFFC2E38 000019B7		ld		a1,#$E00
FFFC2E3C E0098993
FFFC2E40 00000637		call	SDReadSector
FFFC2E44 265600E7
FFFC2E48 00190913		add		a0,a0,#1
FFFC2E4C 000029B7		ldi		a1,#TXTBGN
FFFC2E50 80098993
                        	LOAD4:
FFFC2E54 FFC70713		sub		$sp,$sp,#4
FFFC2E58 01272023		sw		a0,[$sp]
FFFC2E5C 00000637		call	SDReadSector
FFFC2E60 265600E7
FFFC2E64 20098993		add		a1,a1,#512
FFFC2E68 00072903		lw		a0,[$sp]
FFFC2E6C 00470713		add		$sp,$sp,#4
FFFC2E70 00190913		add		a0,a0,#1
FFFC2E74 00002237		ldi		r4,#TXTBGN
FFFC2E78 80020213
FFFC2E7C 00010637		add		r4,r4,#65536
FFFC2E80 00060613
FFFC2E84 00460233
FFFC2E88 FC49C6E3		blt		a1,r4,LOAD4
                        	LOAD5:
FFFC2E8C E2000063		bra		WSTART
                        	
                        	
                        	SAVE3:
FFFC2E90 F2DFF0EF		call	GetFilename
FFFC2E94 00000637		call	AUXOUT_INIT
FFFC2E98 268600E7
FFFC2E9C 0600006F		jmp		SAVE
                        	
FFFC2EA0 208000EF		call	OREXPR		;evaluate the following expression
                        	;	lda		#5000		; starting sector
FFFC2EA4 000019B7		ldi		a1,#$E00	; starting address to write
FFFC2EA8 E0098993
FFFC2EAC 00000637		call	SDWriteSector
FFFC2EB0 26A600E7
FFFC2EB4 00190913		add		a0,a0,#1
FFFC2EB8 000029B7		ldi		a1,#TXTBGN
FFFC2EBC 80098993
                        	SAVE4:
FFFC2EC0 FFC70713		sub		$sp,$sp,#4
FFFC2EC4 01272023		sw		a0,[$sp]
FFFC2EC8 00000637		call	SDWriteSector
FFFC2ECC 26A600E7
FFFC2ED0 20098993		add		a1,a1,#512
FFFC2ED4 00072903		lw		a0,[$sp]
FFFC2ED8 00470713		add		$sp,$sp,#4
FFFC2EDC 00190913		add		a0,a0,#1
FFFC2EE0 00002237		ldi		r4,#TXTBGN
FFFC2EE4 80020213
FFFC2EE8 00010637		add		r4,r4,#65536
FFFC2EEC 00060613
FFFC2EF0 00460233
FFFC2EF4 FC49C6E3		blt		a1,r4,SAVE4
FFFC2EF8 DA000A63		bra		WSTART
                        	
                        	SAVE:
FFFC2EFC 00002E37		ldi		$t2,#TXTBGN	;set pointer to start of prog. area
FFFC2F00 800E0E13
FFFC2F04 70402E83		lw		$t3,TXTUNF	;set pointer to end of prog. area
                        	SAVE1:
FFFC2F08 054000EF		call	AUXOCRLF    ; send out a CR & LF (CP/M likes this)
FFFC2F0C 03CEC863		bgt		$t2,$t3,SAVEND; are we finished?
FFFC2F10 03A06913		ldi		a0,#':'		; if not, start a line
FFFC2F14 CFCFF0EF		call	GOAUXO
FFFC2F18 000E2903		lw		a0,[$t2]		; get line number
FFFC2F1C 004E0E13		add		$t2,$t2,#4
FFFC2F20 060000EF		call	PWORD       ; output line number as 5-digit hex
                        	SAVE2:
FFFC2F24 000E4903		lbu		a0,[$t2]		; get a text char.
FFFC2F28 001E0E13		add		$t2,$t2,#1
FFFC2F2C 00D06D93		ldi		$t1,#CR
FFFC2F30 FDB90CE3		beq		a0,$t1,SAVE1	; is it the end of the line? if so, send CR & LF and start new line
FFFC2F34 CDCFF0EF		call	GOAUXO		; send it out
FFFC2F38 FE0006E3		bra		SAVE2		; go back for more text
                        	SAVEND:
FFFC2F3C 04006913		ldi		a0,#'@'		; send end-of-program indicator
FFFC2F40 CD0FF0EF		call	GOAUXO
FFFC2F44 018000EF		call	AUXOCRLF    ; followed by a CR & LF
FFFC2F48 01A06913		ldi		a0,#$1A		; and a control-Z to end the CP/M file
FFFC2F4C CC4FF0EF		call	GOAUXO
FFFC2F50 00000637		call	AUXOUT_FLUSH
FFFC2F54 271600E7
FFFC2F58 D4000A63		bra		WSTART		; then go do a warm start
                        	
                        	; output a CR LF sequence to auxillary output
                        	; Registers Affected
                        	;   r3 = LF
                        	AUXOCRLF:
FFFC2F5C FFC70713		sub		$sp,$sp,#4
FFFC2F60 00172023		sw		$ra,[$sp]
FFFC2F64 00D06913	  ldi		a0,#CR
FFFC2F68 CA8FF0EF	  call	GOAUXO
FFFC2F6C 00A06913	  ldi		a0,#LINEFD
FFFC2F70 CA0FF0EF	  call	GOAUXO
FFFC2F74 00072083	  lw		$ra,[$sp]
FFFC2F78 00470713	  add		$sp,$sp,#4
FFFC2F7C 00008067	  ret
                        	
                        	
                        	; output a word in hex format
                        	; tricky because of the need to reverse the order of the chars
                        	PWORD:
FFFC2F80 FF870713		sub		$sp,$sp,#8
FFFC2F84 00572023		sw		r5,[$sp]
FFFC2F88 00172223		sw		$ra,4[$sp]
FFFC2F8C 7A206293		ldi		r5,#NUMWKA+14
FFFC2F90 00096233		mov		r4,a0		; r4 = value
                        	pword1:
FFFC2F94 00026933	  mov   a0,r4	    ; a0 = value
FFFC2F98 00425213	  srl		r4,r4,#4	; shift over to next nybble
FFFC2F9C 038000EF	  call	toAsciiHex  ; convert LS nybble to ascii hex
FFFC2FA0 01228023	  sb    a0,[r5]		; save in work area
FFFC2FA4 FFF28293	  sub		r5,r5,#1
FFFC2FA8 79406D93	  ldi		$t1,#NUMWKA
FFFC2FAC FFB2D4E3		bge		r5,$t1,pword1
                        	pword2:
FFFC2FB0 00128293	  add		r5,r5,#1
FFFC2FB4 0002C903	  lbu   a0,[r5]     ; get char to output
FFFC2FB8 C58FF0EF		call	GOAUXO		; send it
FFFC2FBC 7A206D93		ldi		$t1,#NUMWKA+14
FFFC2FC0 FFB2C8E3		blt		r5,$t1,pword2
FFFC2FC4 00072283		lw		r5,[$sp]
FFFC2FC8 00472083		lw		$ra,4[$sp]
FFFC2FCC 00870713		add		$sp,$sp,#8
FFFC2FD0 00008067		ret
                        	
                        	; convert nybble in a1 to ascii hex chaa1
                        	; a1 = character to convert
                        	
                        	toAsciiHex:
FFFC2FD4 00F97913		and		a0,a0,#15	; make sure it's a nybble
FFFC2FD8 00A06D93		ldi		$t1,#10
FFFC2FDC 01B94463		blt		a0,$t1,tah1	; > 10 ?
FFFC2FE0 00790913		add		a0,a0,#7	; bump it up to the letter 'A'
                        	tah1:
FFFC2FE4 03090913		add		a0,a0,#'0'	; bump up to ascii '0'
FFFC2FE8 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	; *** POKE ***
                        	;
                        	; 'POKE expr1,expa1' stores the byte from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEW expr1,expa1' stores the word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEH expr1,expa1' stores the half-word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	;******************************************************************
                        	;
                        	POKE:
FFFC2FEC 0BC000EF		call	OREXPR		; get the memory address
FFFC2FF0 5B5000EF		call	TSTC		; it must be followed by a comma
FFFC2FF4 0000002C		dw		','
FFFC2FF8 06000C63		bra		PKER
FFFC2FFC FFC70713		sub		$sp,$sp,#4
FFFC3000 01272023		sw		a0,[$sp]	; save the address
FFFC3004 0A4000EF		call	OREXPR		; get the byte to be POKE'd
FFFC3008 00072983		lw		a1,[$sp]	; get the address back
FFFC300C 00470713		add		$sp,$sp,#4
FFFC3010 01298023		sb		a0,[a1]		; store the byte in memory
FFFC3014 A2DFF06F		jmp		FINISH
                        	
                        	POKEW:
FFFC3018 090000EF		call	OREXPR		; get the memory address
FFFC301C 589000EF		call	TSTC		; it must be followed by a comma
FFFC3020 0000002C		dw		','
FFFC3024 04000663		bra		PKER
FFFC3028 FFC70713		sub		$sp,$sp,#4
FFFC302C 01272023		sw		a0,[$sp]	; save the address
FFFC3030 078000EF		call	OREXPR		; get the byte to be POKE'd
FFFC3034 00072983		lw		a1,[$sp]	; get the address back
FFFC3038 00470713		add		$sp,$sp,#4
FFFC303C 0129A023		sw		a0,[a1]		; store the byte in memory
FFFC3040 A01FF06F		jmp		FINISH
                        	
                        	POKEH:
FFFC3044 064000EF		call	OREXPR		; get the memory address
FFFC3048 55D000EF		call	TSTC		; it must be followed by a comma
FFFC304C 0000002C		dw		','
FFFC3050 02000063		bra		PKER
FFFC3054 FFC70713		sub		$sp,$sp,#4
FFFC3058 01272023		sw		a0,[$sp]	; save the address
FFFC305C 04C000EF		call	OREXPR		; get the byte to be POKE'd
FFFC3060 00072983		lw		a1,[$sp]	; get the address back
FFFC3064 00470713		add		$sp,$sp,#4
FFFC3068 01299023		sh		a0,[a1]		; store the byte in memory
FFFC306C 9D5FF06F		jmp		FINISH
                        	
                        	PKER:
FFFC3070 FFFC4937		ldi		a0,#msgComma
FFFC3074 23290913
FFFC3078 0890006F		jmp		ERROR		; if no comma, say "What?"
                        	
                        	;******************************************************************
                        	; 'SYSX expr' jumps to the machine language subroutine whose
                        	; starting address is specified by 'expr'.  The subroutine can use
                        	; all registers but must leave the stack the way it found it.
                        	; The subroutine returns to the interpreter by executing an RTS.
                        	;******************************************************************
                        	
                        	SYSX:
FFFC307C 02C000EF		call	OREXPR		; get the subroutine's address
FFFC3080 00081863		bne		v0,r0,sysx1; make sure we got a valid address
FFFC3084 FFFC4937		ld		a0,#msgSYSBad
FFFC3088 28390913
FFFC308C 0750006F		jmp		ERROR
                        	sysx1:
FFFC3090 FFC70713		sub		$sp,$sp,#4
FFFC3094 01C72023		sw		$t2,[$sp]	; save the text pointer
FFFC3098 000800E7		call	[v0]			; jump to the subroutine
FFFC309C 00072E03		lw		$t2,[$sp]	; restore the text pointer
FFFC30A0 00470713		add		$sp,$sp,#4
FFFC30A4 99DFF06F		jmp		FINISH
                        	
                        	;******************************************************************
                        	; *** EXPR ***
                        	;
                        	; 'EXPR' evaluates arithmetical or logical expressions.
                        	; <OREXPR>::= <ANDEXPR> OR <ANDEXPR> ...
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	; <EXPR>::=<ADDEXPR>
                        	;	   <ADDEXPR><rel.op.><ADDEXPR>
                        	; where <rel.op.> is one of the operators in TAB8 and the result
                        	; of these operations is 1 if true and 0 if false.
                        	; <ADDEXPR>::=(+ or -)<MULEXPR>(+ or -)<MULEXPR>(...
                        	; where () are optional and (... are optional repeats.
                        	; <MULEXPR>::=<FUNCEXPR>( <* or /><FUNCEXPR> )(...
                        	; <FUNCEXPR>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                        	; as an index, functions can have an <EXPR> as arguments, and
                        	; <FUNCEXPR> can be an <EXPR> in parenthesis.
                        	;
                        	
                        	; <OREXPR>::=<ANDEXPR> OR <ANDEXPR> ...
                        	;
                        	OREXPR:
FFFC30A8 FF470713		sub		$sp,$sp,#12
FFFC30AC 00172023		sw		$ra,[$sp]
FFFC30B0 00372223		sw		r3,4[$sp]
FFFC30B4 00472423		sw		r4,8[$sp]
FFFC30B8 058000EF		call	ANDEXPR		; get first <ANDEXPR>
                        	XP_OR1:
FFFC30BC FF870713		sub		$sp,$sp,#8
FFFC30C0 01072023		sw		$v0,[$sp]		; save <ANDEXPR> value
FFFC30C4 01172223		sw		$v1,4[$sp]	; save type
FFFC30C8 FFFC2EB7		ldi		$t3,#TAB10	; look up a logical operator
FFFC30CC 70AE8E93
FFFC30D0 FFFC2F37		ldi		$t4,#TAB10_1
FFFC30D4 77AF0F13
FFFC30D8 EB8FF06F		jmp		EXEC		; go do it
                        	XP_OR:
FFFC30DC 034000EF	  call	ANDEXPR
FFFC30E0 00072903	  lw		$a0,[$sp]
FFFC30E4 00870713	  add		$sp,$sp,#8
FFFC30E8 01286833	  or    v0,v0,a0
FFFC30EC FC0008E3	  bra   XP_OR1
                        	XP_ORX:
FFFC30F0 00072803	  lw		$v0,[$sp]
FFFC30F4 00472883	  lw		$v1,4[$sp]
FFFC30F8 00870713	  add		$sp,$sp,#8
FFFC30FC 00072083		lw		$ra,[$sp]
FFFC3100 00472183		lw		r3,4[$sp]
FFFC3104 00872203		lw		r4,8[$sp]
FFFC3108 00C70713		add		$sp,$sp,#12
FFFC310C 00008067	  ret
                        	
                        	
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	;
                        	ANDEXPR:
FFFC3110 FFC70713		sub		$sp,$sp,#4
FFFC3114 00172023		sw		$ra,[$sp]
FFFC3118 0E8000EF		call	EXPR		; get first <EXPR>
                        	XP_AND1:
FFFC311C FF870713		sub		$sp,$sp,#8
FFFC3120 01072023		sw		$v0,[$sp]		; save <EXPR> value
FFFC3124 01172223		sw		$v1,4[$sp]	; save type
FFFC3128 FFFC2EB7		ldi		$t3,#TAB9		; look up a logical operator
FFFC312C 706E8E93
FFFC3130 FFFC2F37		ldi		$t4,#TAB9_1
FFFC3134 776F0F13
FFFC3138 E58FF06F		jmp		EXEC		; go do it
                        	XP_AND:
FFFC313C 0C4000EF	  call	EXPR
FFFC3140 00072903	  lw		$a0,[$sp]
FFFC3144 00870713	  add		$sp,$sp,#8
FFFC3148 01287833	  and   v0,v0,a0
FFFC314C FC0008E3	  bra   XP_AND1
                        	XP_ANDX:
FFFC3150 00072803	  lw		$v0,[$sp]
FFFC3154 00472883	  lw		$v1,4[$sp]
FFFC3158 00870713	  add		$sp,$sp,#8
FFFC315C 00072083		lw		$ra,[$sp]
FFFC3160 00470713		add		$sp,$sp,#4
FFFC3164 00008067	  ret
                        	
                        	
                        	; Determine if the character is a digit
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if digit, otherwise 0
                        	;
                        	isDigit:
FFFC3168 03006D93		ldi		$t1,#'0'
FFFC316C 01B94A63		blt		a0,$t1,isDigitFalse
FFFC3170 03906D93		ldi		$t1,#'9'
FFFC3174 012DC663		bgt		a0,$t1,isDigitFalse
FFFC3178 00106813		ldi		v0,#1
FFFC317C 00008067	  ret
                        	isDigitFalse:
FFFC3180 00006833	  mov		v0,r0
FFFC3184 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphabetic
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlpha:
FFFC3188 04106D93		ldi		$t1,#'A'
FFFC318C 03B94263		blt		a0,$t1,isAlphaFalse
FFFC3190 05A06D93		ldi		$t1,#'Z'
FFFC3194 012DDA63		ble		a0,$t1,isAlphaTrue
FFFC3198 06106D93		ldi		$t1,#'a'
FFFC319C 01B94A63		blt		a0,$t1,isAlphaFalse
FFFC31A0 07A06D93		ldi		$t1,#'z'
FFFC31A4 012DC663		bgt		a0,$t1,isAlphaFalse
                        	isAlphaTrue:
FFFC31A8 00106813	  ldi		v0,#1
FFFC31AC 00008067	  ret
                        	isAlphaFalse:
FFFC31B0 00006833	  mov		v0,r0
FFFC31B4 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphanumeric
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlnum:
FFFC31B8 FFC70713		sub		$sp,$sp,#4
FFFC31BC 00172023		sw		$ra,[$sp]
FFFC31C0 FA9FF0EF	  call	isDigit
FFFC31C4 00081463		bne		v0,r0,isDigitx	; if it is a digit
FFFC31C8 FC1FF0EF	  call  isAlpha
                        	isDigitx:
FFFC31CC 00072083		lw		$ra,[$sp]
FFFC31D0 00470713		add		$sp,$sp,#4
FFFC31D4 00008067	  ret
                        	
                        	FORCEFIT:
FFFC31D8 03198263		beq		a1,v1,.0001				; types match
FFFC31DC 00006D13		ldi		$t0,#0
FFFC31E0 01A98663		beq		a1,$t0,.intAnd
                        	;	itof	$f1,$v0
FFFC31E4 00106913		ldi		a0,#1
FFFC31E8 00008067		ret
                        	.intAnd:
FFFC31EC 00106D13		ldi		$t0,#1
FFFC31F0 01A89663		bne		$v1,$t0,.0001
                        	;	itof	$f2,$a1
FFFC31F4 00106993		ldi		$a1,#1
FFFC31F8 00008067		ret
                        	.0001:
FFFC31FC 00008067		ret
                        	
                        	EXPR:
FFFC3200 FFC70713		sub		$sp,$sp,#4
FFFC3204 00172023		sw		$ra,[$sp]
FFFC3208 11C000EF		call	ADDEXPR
FFFC320C FF870713		sub		$sp,$sp,#8				; save <ADDEXPR> value
FFFC3210 01072023		sw		v0,[$sp]
FFFC3214 01172223		sw		v1,4[$sp]					; save type
FFFC3218 FFFC2EB7		ldi		$t3,#TAB8		; look up a relational operator
FFFC321C 6FCE8E93
FFFC3220 FFFC2F37		ldi		$t4,#TAB8_1
FFFC3224 768F0F13
FFFC3228 D68FF06F		jmp		EXEC		; go do it
                        	XP11:
FFFC322C 00072903		lw		a0,[$sp]
FFFC3230 00472983		lw		a1,4[$sp]
FFFC3234 00870713		add		$sp,$sp,#8
FFFC3238 0C4000EF		call	XP18	; is it ">="?
FFFC323C 09095A63		bge		a0,v0,XPRT1	; no, return v0=1
FFFC3240 06000E63		bra		XPRT0	; else return v0=0
                        	XP12:
FFFC3244 00072903		lw		a0,[$sp]
FFFC3248 00472983		lw		a1,4[$sp]
FFFC324C 00870713		add		$sp,$sp,#8
FFFC3250 0AC000EF		call	XP18	; is it "<>"?
FFFC3254 07091E63		bne		a0,v0,XPRT1	; no, return a1=1
FFFC3258 06000263		bra		XPRT0	; else return a1=0
                        	XP13:
FFFC325C 00072903		lw		a0,[$sp]
FFFC3260 00472983		lw		a1,4[$sp]
FFFC3264 00870713		add		$sp,$sp,#8
FFFC3268 094000EF		call	XP18	; is it ">"?
FFFC326C 07284263		bgt		a0,v0,XPRT1	; no, return a1=1
FFFC3270 04000663		bra		XPRT0	; else return a1=0
                        	XP14:
FFFC3274 00072903		lw		a0,[$sp]
FFFC3278 00472983		lw		a1,4[$sp]
FFFC327C 00870713		add		$sp,$sp,#8
FFFC3280 07C000EF		call	XP18	; is it "<="?
FFFC3284 05285663		ble		a0,v0,XPRT1	; no, return a1=1
FFFC3288 02000A63		bra		XPRT0	; else return a1=0
                        	XP15:
FFFC328C 00072903		lw		a0,[$sp]
FFFC3290 00472983		lw		a1,4[$sp]
FFFC3294 00870713		add		$sp,$sp,#8
FFFC3298 064000EF		call	XP18	; is it "="?
FFFC329C 03090A63		beq		a0,v0,XPRT1	; if not, return a1=1
FFFC32A0 00000E63		bra		XPRT0	; else return a1=0
                        	XP16:
FFFC32A4 00072903		lw		a0,[$sp]
FFFC32A8 00472983		lw		a1,4[$sp]
FFFC32AC 00870713		add		$sp,$sp,#8
FFFC32B0 04C000EF		call	XP18	; is it "<"?
FFFC32B4 01094E63		blt		a0,v0,XPRT1	; if not, return a1=1
FFFC32B8 00000263		bra		XPRT0	; else return a1=0
                        	XPRT0:
FFFC32BC 00006833		mov		v0,x0   ; return a0=0 (false)
FFFC32C0 000068B3		mov		v1,x0		; type = int
FFFC32C4 00072083		lw		$ra,[$sp]
FFFC32C8 00470713		add		$sp,$sp,#4
FFFC32CC 00008067		ret
                        	XPRT1:
FFFC32D0 00106813		ldi		v0,#1	; return a0=1 (true)
FFFC32D4 00006893		ldi		v1,#0	; type = int
FFFC32D8 00072083		lw		$ra,[$sp]
FFFC32DC 00470713		add		$sp,$sp,#4
FFFC32E0 00008067		ret
                        	
                        	XP17:				; it's not a rel. operator
FFFC32E4 00072803		lw		v0,[$sp]; return a1=<ADDEXPR>
FFFC32E8 00472883		lw		v1,4[$sp]
FFFC32EC 00870713		add		$sp,$sp,#8
FFFC32F0 00072083		lw		$ra,[$sp]
FFFC32F4 00470713		add		$sp,$sp,#4
FFFC32F8 00008067		ret
                        	
                        	XP18:
FFFC32FC FF470713		sub		$sp,$sp,#12
FFFC3300 00172023		sw		$ra,[$sp]
FFFC3304 01072223		sw		v0,4[$sp]
FFFC3308 01172423		sw		v1,8[$sp]
FFFC330C 018000EF		call	ADDEXPR		; do a second <ADDEXPR>
FFFC3310 00472903		lw		a0,4[$sp]
FFFC3314 00872983		lw		a1,8[$sp]
FFFC3318 00072083		lw		$ra,[$sp]
FFFC331C 00C70713		add		$sp,$sp,#12
FFFC3320 00008067		ret
                        	
                        	; <ADDEXPR>::=(+ or -)<MULEXPR>(+ or -)<MULEXPR>(...
                        	//message "ADDEXPR"
                        	ADDEXPR:
FFFC3324 FFC70713		sub		$sp,$sp,#4
FFFC3328 00172023		sw		$ra,[$sp]
FFFC332C 279000EF		call	TSTC		; negative sign?
FFFC3330 0000002D		dw		'-'
FFFC3334 00000C63		bra		XP21
FFFC3338 00006833		mov		v0,r0		; yes, fake '0-'
FFFC333C FF870713		sub		$sp,$sp,#8
FFFC3340 01072023		sw		v0,[$sp]
FFFC3344 01172223		sw		v1,4[$sp]
FFFC3348 04000863		bra		XP26
                        	XP21:
FFFC334C 259000EF		call	TSTC		; positive sign? ignore it
FFFC3350 0000002B		dw		'+'
FFFC3354 00000263		bra		XP22
                        	XP22:
FFFC3358 064000EF		call	MULEXPR		; first <MULEXPR>
                        	XP23:
FFFC335C FF870713		sub		$sp,$sp,#8; yes, save the value
FFFC3360 01072023		sw		v0,[$sp]
FFFC3364 01172223		sw		v1,4[$sp]	; and type
FFFC3368 23D000EF		call	TSTC		; add?
FFFC336C 0000002B		dw		'+'
FFFC3370 00000E63		bra		XP25
FFFC3374 048000EF		call	MULEXPR		; get the second <MULEXPR>
                        	XP24:
FFFC3378 00072903		lw		a0,[$sp]
FFFC337C 00472983		lw		a1,4[$sp]
FFFC3380 00870713		add		$sp,$sp,#8
FFFC3384 01280833		add		v0,v0,a0	; add it to the first <MULEXPR>
                        	;	BVS.L	QHOW		brnch if there's an overflow
FFFC3388 FC000AE3		bra		XP23		; else go back for more operations
                        	XP25:
FFFC338C 219000EF		call	TSTC		; subtract?
FFFC3390 0000002D		dw		'-'
FFFC3394 00000863		bra		XP45
                        	XP26:
FFFC3398 024000EF		call	MULEXPR		; get second <MULEXPR>
FFFC339C 41000833		sub		v0,r0,v0	; change its sign
FFFC33A0 FC000CE3		bra		XP24		; and do an addition
                        	XP45:
FFFC33A4 00072803		lw		v0,[$sp]
FFFC33A8 00472883		lw		v1,4[$sp]
FFFC33AC 00870713		add		$sp,$sp,#8
FFFC33B0 00072083		lw		$ra,[$sp]
FFFC33B4 00470713		add		$sp,$sp,#4
FFFC33B8 00008067		ret
                        	
                        	
                        	; <MULEXPR>::=<FUNCEXPR>( <* or /><FUNCEXPR> )(...
                        	
                        	MULEXPR:
FFFC33BC FFC70713		sub		$sp,$sp,#4
FFFC33C0 00172023		sw		$ra,[$sp]
FFFC33C4 094000EF		call	FUNCEXPR		; get first <FUNCEXPR>
                        	XP31:
FFFC33C8 FF870713		sub		$sp,$sp,#8
FFFC33CC 01072023		sw		v0,[$sp]; yes, save that first result
FFFC33D0 01172223		sw		v1,4[$sp]
FFFC33D4 1D1000EF		call	TSTC		; multiply?
FFFC33D8 0000002A		dw		'*'
FFFC33DC 00000E63		bra		XP34
FFFC33E0 078000EF		call	FUNCEXPR		; get second <FUNCEXPR>
FFFC33E4 00072903		lw		a0,[$sp]
FFFC33E8 00472983		lw		a1,4[$sp]
FFFC33EC 00870713		add		$sp,$sp,#8
FFFC33F0 03280833		mul		v0,v0,a0	; multiply the two
FFFC33F4 FC000AE3		bra		XP31        ; then look for more terms
                        	XP34:
FFFC33F8 1AD000EF		call	TSTC		; divide?
FFFC33FC 0000002F		dw		'/'
FFFC3400 00000E63		bra		XP35
FFFC3404 054000EF		call	FUNCEXPR		; get second <FUNCEXPR>
FFFC3408 00072903		lw		a0,[$sp]
FFFC340C 00472983		lw		a1,4[$sp]
FFFC3410 00870713		add		$sp,$sp,#8
FFFC3414 03284833		div		v0,v0,a0	; do the division
FFFC3418 FA0008E3		bra		XP31		; go back for any more terms
                        	XP35:
FFFC341C 189000EF		call	TSTC
FFFC3420 00000025		dw		'%'
FFFC3424 00000E63		bra		XP47
FFFC3428 030000EF		call	FUNCEXPR
FFFC342C 00072903		lw		a0,[$sp]
FFFC3430 00472983		lw		a1,4[$sp]
FFFC3434 00870713		add		$sp,$sp,#8
FFFC3438 03286833		rem		v0,v0,a0
FFFC343C F80006E3		bra		XP31
                        	XP47:
FFFC3440 00072803		lw		v0,[$sp]
FFFC3444 00472883		lw		v1,4[$sp]
FFFC3448 00870713		add		$sp,$sp,#8
FFFC344C 00072083		lw		$ra,[$sp]
FFFC3450 00470713		add		$sp,$sp,#4
FFFC3454 00008067		ret
                        	
                        	
                        	; Functions are called through FUNCEXPR
                        	; <FUNCEXPR>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	
                        	FUNCEXPR:
FFFC3458 FFC70713		sub		$sp,$sp,#4
FFFC345C 00172023		sw		$ra,[$sp]
FFFC3460 FFFC2EB7	  ldi		$t3,#TAB4		; find possible function
FFFC3464 6BBE8E93
FFFC3468 FFFC2F37	  ldi		$t4,#TAB4_1
FFFC346C 746F0F13
FFFC3470 B20FF06F		jmp		EXEC        ; branch to function which does subsequent ret for FUNCEXPR
                        	XP40:                   ; we get here if it wasn't a function
FFFC3474 00006933		mov		a0,x0
FFFC3478 070000EF		call	TSTV
FFFC347C 00080A63		beq   v0,x0,XP41	; not a variable
FFFC3480 00082803		lw		$v0,[$v0]		; if a variable, return its value in v0
FFFC3484 00072083		lw		$ra,[$sp]
FFFC3488 00470713		add		$sp,$sp,#4
FFFC348C 00008067		ret
                        	XP41:
FFFC3490 161000EF		call	TSTNUM		; or is it a number?
FFFC3494 00089463		bne		v1,x0,XP46	; (if not, # of digits will be zero) if so, return it in v0
FFFC3498 010000EF		call	PARN        ; check for (EXPR)
                        	XP46:
FFFC349C 00072083		lw		$ra,[$sp]
FFFC34A0 00470713		add		$sp,$sp,#4
FFFC34A4 00008067		ret
                        	
                        	
                        	; Check for a parenthesized expression
                        	PARN:
FFFC34A8 FFC70713		sub		$sp,$sp,#4
FFFC34AC 00172023		sw		$ra,[$sp]	
FFFC34B0 0F5000EF		call	TSTC		; else look for ( OREXPR )
FFFC34B4 00000028		dw		'('
FFFC34B8 02000063		bra		XP43
FFFC34BC BEDFF0EF		call	OREXPR
FFFC34C0 0E5000EF		call	TSTC
FFFC34C4 00000029		dw		')'
FFFC34C8 00000863		bra		XP43
                        	XP42:
FFFC34CC 00072083		lw		$ra,[$sp]
FFFC34D0 00470713		add		$sp,$sp,#4
FFFC34D4 00008067		ret
                        	XP43:
FFFC34D8 00470713		add		$sp,$sp,#4		; get rid of return address
FFFC34DC FFFC4937		ldi		a0,#msgWhat
FFFC34E0 1B890913
FFFC34E4 41C0006F		jmp		ERROR
                        	
                        	
                        	; ===== Test for a valid variable name.  Returns Z=1 if not
                        	;	found, else returns Z=0 and the address of the
                        	;	variable in a0.
                        	; Parameters
                        	;		a0 = 1 = allocate if not found
                        	; Returns
                        	;		v0 = address of variable, zero if not found
                        	
                        	TSTV:
FFFC34E8 FF870713		sub		$sp,$sp,#8
FFFC34EC 00572023		sw		r5,[$sp]
FFFC34F0 00172223		sw		$ra,4[$sp]
FFFC34F4 000962B3		mov		r5,a0		; r5=allocate flag
FFFC34F8 16D000EF		call	IGNBLK
FFFC34FC 000E4903		lbu		a0,[$t2]		; look at the program text
FFFC3500 04006D93		ldi		$t1,#'@'
FFFC3504 07B94263		blt		a0,$t1,tstv_notfound	; C=1: not a variable
FFFC3508 03B91E63		bne		a0,$t1,TV1				; brnch if not "@" array
FFFC350C 001E0E13		add		$t2,$t2,#1	; If it is, it should be
FFFC3510 F99FF0EF		call	PARN		; followed by (EXPR) as its index.
                        	;	BCS.L	QHOW		say "How?" if index is too big
FFFC3514 00000263		bra		TV3
                        	TV3:
FFFC3518 FFC70713		sub		$sp,$sp,#4	; save the index
FFFC351C 01072023		sw		v0,[$sp]
FFFC3520 2D0000EF		call	SIZEX		; get amount of free memory
FFFC3524 00072983		lw		a1,[$sp]
FFFC3528 00470713		add		$sp,$sp,#4	; get back the index
FFFC352C 0109C663		blt		a1,v0,TV2		; see if there's enough memory
FFFC3530 00870713		add		$sp,$sp,#8
FFFC3534 3B80006F		jmp   QSORRY		; if not, say "Sorry"
                        	TV2:
FFFC3538 70802903		lw		a0,VARBGN	; put address of array element...
FFFC353C 41390833		sub   v0,a0,a1    ; into a0 (neg. offset is used)
FFFC3540 00000C63		bra   TSTVRT
                        	TV1:	
FFFC3544 038000EF	  call	getVarName      ; get variable name
FFFC3548 00080863	  beq   v0,x0,TSTVRT    ; if not, return v0=0
FFFC354C 00086933	  mov		a0,v0
FFFC3550 0002E9B3	  mov		a1,r5
FFFC3554 0D4000EF	  call	findVar     ; find or allocate
                        	TSTVRT:
FFFC3558 00072283		lw		r5,[$sp]
FFFC355C 00472083		lw		$ra,4[$sp]
FFFC3560 00870713		add		$sp,$sp,#8
FFFC3564 00008067		ret								; v0<>0 (if found)
                        	tstv_notfound:
FFFC3568 00072283		lw		r5,[$sp]
FFFC356C 00472083		lw		$ra,4[$sp]
FFFC3570 00870713		add		$sp,$sp,#8
FFFC3574 00006833		mov		v0,x0				; v0=0 if not found
FFFC3578 00008067	  ret
                        	
                        	; Get a variable name. Called after blanks have been ignored.
                        	;
                        	; Returns
                        	;   v0 = 3 character variable name + type
                        	;
                        	getVarName:
FFFC357C FF470713		sub		$sp,$sp,#12
FFFC3580 00572023		sw		r5,[$sp]
FFFC3584 00172223		sw		$ra,4[$sp]
FFFC3588 000E4903	  lbu   a0,[$t2]		; get first character
FFFC358C 01272423	  sw		a0,8[$sp]		; save off current name
FFFC3590 BF9FF0EF	  call	isAlpha
FFFC3594 08080063	  beq   v0,r0,gvn1
FFFC3598 00206293	  ldi	  r5,#2       ; loop two more times
                        	
                        		; check for second/third character
                        	gvn4:
FFFC359C 001E0E13		add		$t2,$t2,#1
FFFC35A0 000E4903		lbu   a0,[$t2]		; do we have another char ?
FFFC35A4 C15FF0EF		call	isAlnum
FFFC35A8 02080863		beq   v0,x0,gvn2	; nope
FFFC35AC 00872903		lw		a0,8[$sp]		; get varname
FFFC35B0 00891913		sll		a0,a0,#8
FFFC35B4 000E4983		lbu   a1,[$t2]
FFFC35B8 01396933		or    a0,a0,a1   	; add in new char
FFFC35BC 01272423	  sw		a0,8[$sp]		; save off current name again
FFFC35C0 FFF28293	  sub		r5,r5,#1
FFFC35C4 FC504CE3	  bgt		r5,x0,gvn4
                        	
                        	 	; now ignore extra variable name characters
                        	gvn6:
FFFC35C8 001E0E13		add		$t2,$t2,#1
FFFC35CC 000E4903		lbu   a0,[$t2]		; do we have another char ?
FFFC35D0 BE9FF0EF	  call  isAlnum
FFFC35D4 FE081AE3	  bne   v0,x0,gvn6	; keep looping as long as we have identifier chars
                        	
                        	  ; check for a variable type
                        	gvn2:
FFFC35D8 000E4983		lbu   a1,[$t2]
FFFC35DC 02506D93		ldi		$t1,#'%'
FFFC35E0 01B98A63		beq		a1,$t1,gvn3
FFFC35E4 02406D93		ldi		$t1,#'$'
FFFC35E8 01B98663		beq		a1,$t1,gvn3
FFFC35EC FFFE0E13	  sub		$t2,$t2,#1
FFFC35F0 02E06993	  ldi		$a1,#'.'		; if no variable type assume float
                        	
                        	  ; insert variable type indicator and return
                        	gvn3:
FFFC35F4 001E0E13		add		$t2,$t2,#1
FFFC35F8 00872903		lw		a0,8[$sp]		; get varname
FFFC35FC 00891913		sll		a0,a0,#8
FFFC3600 01396833	  or    v0,a0,a1    ; add in variable type
FFFC3604 00072283	  lw		r5,[$sp]
FFFC3608 00472083	  lw		$ra,4[$sp]
FFFC360C 00C70713	  add		$sp,$sp,#12
FFFC3610 00008067	  ret								; return a0 = varname
                        	
                        	  ; not a variable name
                        	gvn1:
FFFC3614 00072283		lw		r5,[$sp]
FFFC3618 00472083	  lw		$ra,4[$sp]
FFFC361C 00C70713		add		$sp,$sp,#12
FFFC3620 00006833	  mov		v0,x0       ; return v0 = 0 if not a varname
FFFC3624 00008067	  ret
                        	
                        	
                        	; Find variable
                        	;   a0 = varname
                        	;		a1 = allocate flag
                        	; Returns
                        	;   v0 = variable address, Z =0 if found / allocated, Z=1 if not found
                        	
                        	findVar:
FFFC3628 FF870713		sub		$sp,$sp,#8
FFFC362C 00772023		sw		x7,[$sp]
FFFC3630 00372223		sw		x3,4[$sp]
FFFC3634 70802183	  lw    x3,VARBGN
                        	fv4:
FFFC3638 0001A383	  lw    x7,[x3]     ; get varname / type
FFFC363C 02038663	  beq   x7,x0,fv3		; no more vars ?
FFFC3640 02790863	  beq   a0,x7,fv1		; match ?
FFFC3644 00818193		add		x3,x3,#8		; move to next var
FFFC3648 70C02383	  lw    x7,VAREND		; 
FFFC364C FE71C6E3	  blt   x3,x7,fv4		; loop back to look at next var
                        	
                        	  ; variable not found
                        	  ; no more memory
FFFC3650 00072383	  lw		x7,[$sp]
FFFC3654 00472183	  lw		x3,4[$sp]
FFFC3658 00870713	  add		$sp,$sp,#8
FFFC365C FFFC4937	  ldi		a0,#msgVarSpace
FFFC3660 20690913
FFFC3664 29C0006F	  jmp   ERROR
                        	
                        	  ; variable not found
                        	  ; allocate new ?
                        	fv3:
FFFC3668 00098E63		beq		a1,x0,fv2
FFFC366C 0121A023	  sw    a0,[x3]     ; save varname / type
                        	  ; found variable
                        	  ; return address
                        	fv1:
FFFC3670 00418813	  add		v0,x3,#4
FFFC3674 00072383	  lw		x7,[$sp]
FFFC3678 00472183	  lw		x3,4[$sp]
FFFC367C 00870713	  add		$sp,$sp,#8
FFFC3680 00008067	  ret			    			; v0 = address
                        	
                        	  ; didn't find var and not allocating
                        	fv2:
FFFC3684 00072383	  lw		x7,[$sp]
FFFC3688 00472183	  lw		x3,4[$sp]
FFFC368C 00870713	  add		$sp,$sp,#8
FFFC3690 00006833		mov		v0,x0				; v0 = nullptr
FFFC3694 00008067	  ret
                        	
                        	; The following functions are entered via a jump instruction with
                        	; the return address already saved.
                        	
                        	; ===== The PEEK function returns the byte stored at the address
                        	;	contained in the following expression.
                        	;
                        	PEEK:
FFFC3698 E11FF0EF		call	PARN		; get the memory address
FFFC369C 00080803		lb		v0,[v0]		; get the addressed byte
FFFC36A0 000068B3		mov		v1,x0			; type = int
FFFC36A4 00072083		lw		$ra,[$sp]
FFFC36A8 00470713		add		$sp,$sp,#4
FFFC36AC 00008067		ret
                        	PEEKW:
FFFC36B0 DF9FF0EF		call	PARN		; get the memory address
FFFC36B4 00082803		lw		v0,[v0]		; get the addressed word
FFFC36B8 000068B3		mov		v1,x0			; type = int
FFFC36BC 00072083		lw		$ra,[$sp]
FFFC36C0 00470713		add		$sp,$sp,#4
FFFC36C4 00008067		ret
                        	PEEKH:
FFFC36C8 DE1FF0EF		call	PARN		; get the memory address
FFFC36CC 00081803		lh		v0,[v0]		; get the addressed byte
FFFC36D0 000068B3		mov		v1,x0			; type = int
FFFC36D4 00072083		lw		$ra,[$sp]
FFFC36D8 00470713		add		$sp,$sp,#4
FFFC36DC 00008067		ret
                        	
                        	
                        	; user function call
                        	; call the user function with argument in a0, type in a1
                        	USRX:
FFFC36E0 FFC70713		sub		$sp,$sp,#4
FFFC36E4 01A72023		sw		$t0,[$sp]
FFFC36E8 DC1FF0EF		call	PARN		; get expression value
FFFC36EC 00086933		mov		a0,v0
FFFC36F0 0008E9B3		mov		a1,v1
FFFC36F4 FFC70713		sub		$sp,$sp,#4	; save the text pointer
FFFC36F8 01C72023		sw		$t2,[$sp]
FFFC36FC 7A002D03		lw		$t0,usrJmp
FFFC3700 000D00E7		call	[$t0]			; get usr vector, jump to the subroutine
FFFC3704 00072E03		lw		$t2,[$sp]	; restore the text pointer
FFFC3708 00470713		add		$sp,$sp,#4
FFFC370C 00072D03		lw		$t0,[$sp]
FFFC3710 00470713		add		$sp,$sp,#4
FFFC3714 00072083		lw		$ra,[$sp]
FFFC3718 00470713		add		$sp,$sp,#4
FFFC371C 00008067		ret
                        	
                        	
                        	; ===== The RND function returns a random number from 1 to
                        	;	the value of the following expression in D0.
                        	;
                        	RND:
FFFC3720 D89FF0EF		call	PARN		; get the upper limit
FFFC3724 04080063		beq		v0,r0,rnd2	; it must be positive and non-zero
FFFC3728 02084663		blt		v0,r0,rnd1
FFFC372C 000869B3		mov		a1,v0
FFFC3730 000868B3		mov		v1,v0
FFFC3734 00000637		call	gen_rand	; generate a random number
FFFC3738 2B3600E7
FFFC373C 03186833		rem		v0,v0,v1
FFFC3740 00180813		add		v0,v0,#1
FFFC3744 000068B3		mov		v1,x0
FFFC3748 00072083		lw		$ra,[$sp]
FFFC374C 00470713		add		$sp,$sp,#4
FFFC3750 00008067		ret
                        	rnd1:
FFFC3754 FFFC4937		ldi		a0,#msgRNDBad
FFFC3758 27090913
FFFC375C 00470713		add		$sp,$sp,#4
FFFC3760 1A00006F		jmp		ERROR
                        	rnd2:
FFFC3764 00000637		call	gen_rand	; generate a random number
FFFC3768 2B3600E7
FFFC376C 000068B3		mov		v1,x0
FFFC3770 00072083		lw		$ra,[$sp]
FFFC3774 00470713		add		$sp,$sp,#4
FFFC3778 00008067		ret
                        	
                        	; ===== The ABS function returns an absolute value in a1.
                        	;
                        	ABS:
FFFC377C D2DFF0EF		call	PARN		; get the following expr.'s value
FFFC3780 00084863		blt		v0,r0,ABS1
FFFC3784 00072083		lw		$ra,[$sp]
FFFC3788 00470713		add		$sp,$sp,#4
FFFC378C 00008067		ret
                        	ABS1:
FFFC3790 41000833		sub		v0,x0,v0
FFFC3794 00072083		lw		$ra,[$sp]
FFFC3798 00470713		add		$sp,$sp,#4
FFFC379C 00008067		ret
                        	
                        	
                        	;==== The TICK function returns the cpu tick value in a0.
                        	;
                        	TICKX:
FFFC37A0 C0001873		csrrw	v0,#$C00,x0
FFFC37A4 000068B3		mov		v1,x0
FFFC37A8 00072083		lw		$ra,[$sp]
FFFC37AC 00470713		add		$sp,$sp,#4
FFFC37B0 00008067		ret
                        	
                        	; ===== The SGN function returns the sign in a0. +1,0, or -1
                        	;
                        	SGN:
FFFC37B4 CF5FF0EF		call	PARN		; get the following expr.'s value
FFFC37B8 000068B3		mov		v1,x0
FFFC37BC 02080463		beq		v0,r0,SGN1
FFFC37C0 00084A63		blt		v0,r0,SGN2
FFFC37C4 00106813		ldi		v0,#1
FFFC37C8 00072083		lw		$ra,[$sp]
FFFC37CC 00470713		add		$sp,$sp,#4
FFFC37D0 00008067		ret
                        	SGN2:
FFFC37D4 FFF06813		ldi		v0,#-1
FFFC37D8 00072083		lw		$ra,[$sp]
FFFC37DC 00470713		add		$sp,$sp,#4
FFFC37E0 00008067		ret
                        	SGN1:
FFFC37E4 00072083		lw		$ra,[$sp]
FFFC37E8 00470713		add		$sp,$sp,#4
FFFC37EC 00008067		ret	
                        	
                        	; ===== The SIZE function returns the size of free memory in v0.
                        	; does not consider memory used by @()
                        	;
                        	SIZEX:
FFFC37F0 70802803		lw		v0,VARBGN	; get the number of free bytes...
FFFC37F4 70402883		lw		v1,TXTUNF	; between 'TXTUNF' and 'VARBGN'
FFFC37F8 41180833		sub		v0,v0,v1
FFFC37FC 000068B3		mov		v1,x0			; type = int
FFFC3800 00072083		lw		$ra,[$sp]
FFFC3804 00470713		add		$sp,$sp,#4
FFFC3808 00008067		ret					; return the number in v0
                        	
                        	
                        	;******************************************************************
                        	;
                        	; *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                        	;
                        	; 'SETVAL' expects a variable, followed by an equal sign and then
                        	; an expression.  It evaluates the expression and sets the variable
                        	; to that value.
                        	;
                        	; returns
                        	; a1 = variable's address
                        	;
                        	SETVAL:
FFFC380C FFC70713		sub		$sp,$sp,#4
FFFC3810 00172023		sw		$ra,[$sp]
FFFC3814 00106913	  ldi		a0,#1		; allocate var
FFFC3818 CD1FF0EF	  call	TSTV		; variable name?
FFFC381C 00081A63	  bne		v0,x0,.sv2
FFFC3820 FFFC4937	 	ldi		a0,#msgVar
FFFC3824 25A90913
FFFC3828 00470713		add		$sp,$sp,#4
FFFC382C 0D40006F	 	jmp		ERROR 
                        	.sv2:
FFFC3830 FFC70713		sub		$sp,$sp,#4
FFFC3834 01072023		sw		v0,[$sp]	; save the variable's address
FFFC3838 56C000EF		call	TSTC			; get past the "=" sign
FFFC383C 0000003D		dw		'='
FFFC3840 02000663		bra		SV1
FFFC3844 865FF0EF		call	OREXPR		; evaluate the expression
FFFC3848 00072983		lw		a1,[$sp]	; get back the variable's address
FFFC384C 00470713		add		$sp,$sp,#4
FFFC3850 0109A023		sw    v0,[a1]   ; and save value in the variable
FFFC3854 0009E833		mov		v0,a1			; return v0 = variable address
FFFC3858 FFC9A883		lw		v1,-4[a1]
FFFC385C 0FF8F893		and		v1,v1,#$FF
FFFC3860 00072083		lw		$ra,[$sp]
FFFC3864 00470713		add		$sp,$sp,#4
FFFC3868 00008067		ret
                        	SV1:
FFFC386C 00470713		add		$sp,$sp,#4
FFFC3870 0880006F	  jmp	  QWHAT		; if no "=" sign
                        	
                        	
                        	; 'FIN' checks the end of a command.  If it ended with ":",
                        	; execution continues.	If it ended with a CR, it finds the
                        	; the next line and continues from there.
                        	;
                        	FIN:
FFFC3874 FFC70713		sub		$sp,$sp,#4
FFFC3878 00172023		sw		$ra,[$sp]
FFFC387C 528000EF		call	TSTC		; *** FIN ***
FFFC3880 0000003A		dw		':'
FFFC3884 00000663		bra		FI1
FFFC3888 00470713		add		$sp,$sp,#4	; if ":", discard return address
FFFC388C 820FF06F		jmp		RUNSML		; continue on the same line
                        	FI1:
FFFC3890 514000EF		call	TSTC		; not ":", is it a CR?
FFFC3894 0000000D		dw		CR
FFFC3898 00000663		bra		FI2
                        							; else return to the caller
FFFC389C 00470713		add		$sp,$sp,#4	; yes, purge return address
FFFC38A0 FA5FE06F		jmp		RUNNXL		; execute the next line
                        	FI2:
FFFC38A4 00072083		lw		$ra,[$sp]
FFFC38A8 00470713		add		$sp,$sp,#4
FFFC38AC 00008067		ret					; else return to the caller
                        	
                        	
                        	; 'ENDCHK' checks if a command is ended with a CR. This is
                        	; required in certain commands, such as GOTO, RETURN, STOP, etc.
                        	;
                        	; Check that there is nothing else on the line
                        	; Registers Affected
                        	;   a0
                        	;
                        	ENDCHK:
FFFC38B0 FFC70713		sub		$sp,$sp,#4
FFFC38B4 00172023		sw		$ra,[$sp]
FFFC38B8 5AC000EF		call	IGNBLK
FFFC38BC 000E4903		lbu		a0,[$t2]
FFFC38C0 00D06D93		ldi		$t1,#CR
FFFC38C4 01B90863		beq		a0,$t1,ec1	; does it end with a CR?
FFFC38C8 FFFC4937		ldi		a0,#msgExtraChars
FFFC38CC 32B90913
FFFC38D0 0300006F		jmp		ERROR
                        	ec1:
FFFC38D4 00072083		lw		$ra,[$sp]
FFFC38D8 00470713		add		$sp,$sp,#4
FFFC38DC 00008067		ret
                        	
                        	; 'ERROR' prints the string pointed to by a0. It then prints the
                        	; line pointed to by CURRNT with a "?" inserted at where the
                        	; old text pointer (should be on top of the stack) points to.
                        	; Execution of Tiny BASIC is stopped and a warm start is done.
                        	; If CURRNT is zero (indicating a direct command), the direct
                        	; command is not printed. If CURRNT is -1 (indicating
                        	; 'INPUT' command in progress), the input line is not printed
                        	; and execution is not terminated but continues at 'INPERR'.
                        	;
                        	; Related to 'ERROR' are the following:
                        	; 'QWHAT' saves text pointer on stack and gets "What?" message.
                        	; 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                        	; 'QSORRY' and 'ASORRY' do the same kind of thing.
                        	; 'QHOW' and 'AHOW' also do this for "How?".
                        	;
                        	TOOBIG:
FFFC38E0 FFFC4937		ldi		a0,#msgTooBig
FFFC38E4 31790913
FFFC38E8 00000C63		bra		ERROR
                        	QSORRY:
FFFC38EC FFFC4937	  ldi		a0,#SRYMSG
FFFC38F0 1BF90913
FFFC38F4 00000663		bra	    ERROR
                        	QWHAT:
FFFC38F8 FFFC4937		ldi		a0,#msgWhat
FFFC38FC 1B890913
                        	ERROR:
FFFC3900 644000EF		call	PRMESG		; display the error message
FFFC3904 71802903		lw		a0,CURRNT	; get the current line pointer
FFFC3908 02090C63		beq		a0,r0,ERROR1	; if zero, do a warm start
FFFC390C FFF06D93		ldi		$t1,#-1
FFFC3910 AFB90463		beq		a0,$t1,INPERR	; is the line no. pointer = -1? if so, redo input
FFFC3914 000E4283		lbu		r5,[$t2]		; save the char. pointed to
FFFC3918 000E0023		sb		x0,[$t2]		; put a zero where the error is
FFFC391C 71802903		lw		a0,CURRNT	; point to start of current line
FFFC3920 428000EF		call	PRTLN		; display the line in error up to the 0
FFFC3924 00096333		mov     r6,a0	    ; save off end pointer
FFFC3928 005E0023		sb		r5,[$t2]		; restore the character
FFFC392C 03F06913		ldi		a0,#'?'		; display a "?"
FFFC3930 AD9FE0EF		call	GOOUT
FFFC3934 000069B3		mov		a1,r0		; stop char = 0
FFFC3938 FFF30913		sub		a0,r6,#1	; point back to the error char.
FFFC393C 23C000EF		call	PRTSTG		; display the rest of the line
                        	ERROR1:
FFFC3940 B6DFE06F		jmp	    WSTART		; and do a warm start
                        	
                        	;******************************************************************
                        	;
                        	; *** GETLN *** FNDLN (& friends) ***
                        	;
                        	; 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                        	; the character in r3 (given by the caller), then it fills the
                        	; buffer and echos. It ignores LF's but still echos
                        	; them back. Control-H is used to delete the last character
                        	; entered (if there is one), and control-X is used to delete the
                        	; whole line and start over again. CR signals the end of a line,
                        	; and causes 'GETLN' to return.
                        	;
                        	;
                        	GETLN:
FFFC3944 FF870713		sub		$sp,$sp,#8
FFFC3948 00572023		sw		r5,[$sp]
FFFC394C 00172223		sw		$ra,4[$sp]
FFFC3950 AB9FE0EF		call	GOOUT		; display the prompt
FFFC3954 00106913		ldi		a0,#1
                        	;	sw		a0,CursorFlash	; turn on cursor flash
FFFC3958 02006913		ldi		a0,#' '		; and a space
FFFC395C AADFE0EF		call	GOOUT
FFFC3960 71C06E13		ldi		$t2,#BUFFER	; $t2 is the buffer pointer
                        	.GL1:
FFFC3964 5B0000EF		call	CHKIO		; check keyboard
FFFC3968 FE080EE3		beq		v0,x0,.GL1	; wait for a char. to come in
FFFC396C 00806D93		ldi		$t1,#CTRLH
FFFC3970 05B80663		beq		v0,$t1,.GL3	; delete last character? if so
FFFC3974 01806D93		ldi		$t1,#CTRLX
FFFC3978 07B80663		beq		v0,$t1,.GL4	; delete the whole line?
FFFC397C 00D06D93		ldi		$t1,#CR
FFFC3980 01B80663		beq		v0,$t1,.GL2		; accept a CR
FFFC3984 02006D93		ldi		$t1,#' '
FFFC3988 FDB84EE3		blt		v0,$t1,.GL1	; if other control char., discard it
                        	.GL2:
FFFC398C 010E0023		sb		v0,[$t2]		; save the char.
FFFC3990 001E0E13		add		$t2,$t2,#1
FFFC3994 FFC70713		sub		$sp,$sp,#4
FFFC3998 01072023		sw		v0,[$sp]
FFFC399C 00086933		mov		$a0,$v0
FFFC39A0 A69FE0EF		call	GOOUT		; echo the char back out
FFFC39A4 00072803		lw		v0,[$sp]; get char back (GOOUT destroys a0)
FFFC39A8 00470713		add		$sp,$sp,#4
FFFC39AC 00D06D93		ldi		$t1,#CR
FFFC39B0 07B80663		beq		v0,$t1,.GL7			; if it's a CR, end the line
FFFC39B4 76F06D93		ldi		$t1,#BUFFER+BUFLEN-1
FFFC39B8 FBBE46E3		blt		$t2,$t1,.GL1		; any more room? ; yes: get some more, else delete last char.
                        	.GL3:
FFFC39BC 00806913		ldi		a0,#CTRLH	; delete a char. if possible
FFFC39C0 A49FE0EF		call	GOOUT
FFFC39C4 02006913		ldi		a0,#' '
FFFC39C8 A41FE0EF		call	GOOUT
FFFC39CC 71C06D93		ldi		$t1,#BUFFER
FFFC39D0 F9CDDAE3		ble		$t2,$t1,.GL1	; any char.'s left?	; if not
FFFC39D4 00806913		ldi		a0,#CTRLH		; if so, finish the BS-space-BS sequence
FFFC39D8 A31FE0EF		call	GOOUT
FFFC39DC FFFE0E13		sub		$t2,$t2,#1	; decrement the text pointer
FFFC39E0 F80002E3		bra		.GL1		; back for more
                        	.GL4:
FFFC39E4 000E6933		mov		a0,$t2		; delete the whole line
FFFC39E8 8E490293		sub		r5,a0,#BUFFER   ; figure out how many backspaces we need
FFFC39EC 02028463		beq		r5,r0,.GL6		; if none needed, brnch
FFFC39F0 FFF28293		sub		r5,r5,#1		; loop count is one less
                        	.GL5:
FFFC39F4 00806913		ldi		a0,#CTRLH		; and display BS-space-BS sequences
FFFC39F8 A11FE0EF		call	GOOUT
FFFC39FC 02006913		ldi		a0,#' '
FFFC3A00 A09FE0EF		call	GOOUT
FFFC3A04 00806913		ldi		a0,#CTRLH
FFFC3A08 A01FE0EF		call	GOOUT
FFFC3A0C FFF28293		sub		r5,r5,#1
FFFC3A10 FE0292E3		bne		r5,r0,.GL5
                        	.GL6:
FFFC3A14 71C06E13		ldi		$t2,#BUFFER	; reinitialize the text pointer
FFFC3A18 F40006E3		bra		.GL1		; and go back for more
                        	.GL7:
FFFC3A1C 000E0023		sb		x0,[$t2]		; null terminate line
                        	;	sw		x0,CursorFlash	; turn off cursor flash
FFFC3A20 00A06913		ldi		a0,#LINEFD	; echo a LF for the CR
FFFC3A24 9E5FE0EF		call	GOOUT
FFFC3A28 00072283		lw		r5,[$sp]
FFFC3A2C 00472083		lw		$ra,4[$sp]
FFFC3A30 00870713		add		$sp,$sp,#8
FFFC3A34 00008067		ret
                        	
                        	
                        	; 'FNDLN' finds a line with a given line no. (in a0) in the
                        	; text save area.  $t3 is used as the text pointer. If the line
                        	; is found, $t3 will point to the beginning of that line
                        	; (i.e. the high byte of the line no.), and $v0 = 1.
                        	; If that line is not there and a line with a higher line no.
                        	; is found, $t3 points there and $v0 = 0. If we reached
                        	; the end of the text save area and cannot find the line, flags
                        	; $t3 = 0, $v0 = 0.
                        	; $v0=1 if line found
                        	; r0 = 1	<= line is found
                        	;	$t3 = pointer to line
                        	; r0 = 0    <= line is not found
                        	;	r9 = zero, if end of text area
                        	;	r9 = otherwise higher line number
                        	;
                        	; 'FNDLN' will initialize $t3 to the beginning of the text save
                        	; area to start the search. Some other entries of this routine
                        	; will not initialize $t3 and do the search.
                        	; 'FNDLNP' will start with $t3 and search for the line no.
                        	; 'FNDNXT' will bump $t3 by 4, find a CR and then start search.
                        	; 'FNDSKP' uses $t3 to find a CR, and then starts the search.
                        	; return Z=1 if line is found, r9 = pointer to line
                        	;
                        	; Parameters
                        	;	a0 = line number to find
                        	;
                        	FNDLN:
FFFC3A38 00100DB7		ldi		$t1,#$FFFFF
FFFC3A3C FFFD8D93
FFFC3A40 01B94863		blt		a0,$t1,fl1	; line no. must be < 65535
FFFC3A44 FFFC4937		ld		a0,#msgLineRange
FFFC3A48 24590913
FFFC3A4C EB5FF06F		jmp		ERROR
                        	fl1:
FFFC3A50 00002EB7		ldi		$t3,#TXTBGN	; init. the text save pointer
FFFC3A54 800E8E93
                        	
                        	FNDLNP:
FFFC3A58 70402F03		lw		$t4,TXTUNF	; check if we passed the end
FFFC3A5C 05EEF463		bgeu	$t3,$t4,FNDRET1; if so, return with r9=0,a0=0
FFFC3A60 FF870713		sub		$sp,$sp,#8	; push a0
FFFC3A64 01272023		sw		a0,[$sp]
FFFC3A68 00172223		sw		ra,4[$sp]
FFFC3A6C 000EE933		mov		a0,t3
FFFC3A70 2AC000EF		call	LoadWord		; get line number
FFFC3A74 00072903		lw		a0,[$sp]		; pop a0
FFFC3A78 00472083		lw		ra,4[$sp]
FFFC3A7C 00870713		add		$sp,$sp,#8
FFFC3A80 03280663		beq		v0,a0,FNDRET2
FFFC3A84 03286863		bltu	v0,a0,FNDNXT	; is this the line we want? no, not there yet
                        	FNDRET:
FFFC3A88 004E8E93		add		$t3,$t3,#4	; find the next line, skip over line number
                        	.0001:
FFFC3A8C 000EC883		lbu		v1,[$t3]
FFFC3A90 001E8E93		add		$t3,$t3,#1
FFFC3A94 00D06D93		ldi		$t1,#CR
FFFC3A98 FFB89AE3		bne		v1,$t1,.0001	; try to find a CR, keep looking
FFFC3A9C 00006833		mov		v0,x0	; line not found, but $t3=next line pointer
FFFC3AA0 00008067		ret
                        	FNDRET1:
                        	;	eor		r9,r9,r9	; no higher line
FFFC3AA4 00006833		mov		v0,x0	; line not found
FFFC3AA8 00008067		ret
                        	FNDRET2:
FFFC3AAC 00106813		ldi		v0,#1	; line found
FFFC3AB0 00008067		ret
                        	
                        	FNDNXT:
FFFC3AB4 004E8E93		add		$t3,$t3,#4	; find the next line
                        	
                        	FNDSKP:
FFFC3AB8 000EC883		lbu		v1,[$t3]
FFFC3ABC 001E8E93		add		$t3,$t3,#1
FFFC3AC0 00D06D93		ldi		$t1,#CR
FFFC3AC4 FFB89AE3		bne		v1,$t1,FNDSKP	; try to find a CR, keep looking
FFFC3AC8 F80008E3		bra		FNDLNP		; check if end of text
                        	
                        	
                        	;******************************************************************
                        	; 'MVUP' moves a block up from where a0 points to where a1 points
                        	; until a0=a2
                        	;
                        	MVUP1:
FFFC3ACC 00090203		lb		r4,[a0]
FFFC3AD0 00498023		sb		r4,[a1]
FFFC3AD4 00190913		add		a0,a0,#1
FFFC3AD8 00198993		add		a1,a1,#1
                        	MVUP:
FFFC3ADC FF4918E3		bne		a0,a2,MVUP1
FFFC3AE0 00008067		ret
                        	
                        	
                        	; 'MVDOWN' moves a block down from where a0 points to where a1
                        	; points until a0=a2
                        	;
                        	MVDOWN1:
FFFC3AE4 FFF90913		sub		a0,a0,#1
FFFC3AE8 FFF98993		sub		a1,a1,#1
FFFC3AEC 00090203		lb		r4,[a0]
FFFC3AF0 00498023		sb		r4,[a1]
                        	MVDOWN:
FFFC3AF4 FF4918E3		bne		a0,a2,MVDOWN1
FFFC3AF8 00008067		ret
                        	
                        	
                        	; 'POPA_' restores the 'FOR' loop variable save area from the stack
                        	;
                        	; 'PUSHA_' stacks for 'FOR' loop variable save area onto the stack
                        	;
                        	; Note: a single zero word is stored on the stack in the
                        	; case that no FOR loops need to be saved. This needs to be
                        	; done because PUSHA_ / POPA_ is called all the time.
                        	//message "POPA_"
                        	POPA_:
FFFC3AFC 00072903		lw		a0,[$sp]
FFFC3B00 00470713		add		$sp,$sp,#4
FFFC3B04 71202823		sw		a0,LOPVAR	; restore LOPVAR, but zero means no more
FFFC3B08 02090463		beq		a0,x0,PP1
FFFC3B0C 00072903		lw		a0,[$sp]
FFFC3B10 77202823		sw		a0,LOPPT
FFFC3B14 00472903		lw		a0,4[$sp]
FFFC3B18 77202A23		sw		a0,LOPLN
FFFC3B1C 00872903		lw		a0,8[$sp]
FFFC3B20 77202E23		sw		a0,LOPLMT
FFFC3B24 00C72903		lw		a0,12[$sp]
FFFC3B28 77202C23		sw		a0,LOPINC
FFFC3B2C 01070713		add		$sp,$sp,#16
                        	PP1:
FFFC3B30 00008067		ret
                        	
                        	
                        	PUSHA_:
FFFC3B34 79C02903		lw		a0,STKBOT	; Are we running out of stack room?
FFFC3B38 01490913		add		a0,a0,#20	; we might need this many bytes
FFFC3B3C DB2748E3		blt		$sp,a0,QSORRY	; out of stack space
FFFC3B40 71002983		lw		a1,LOPVAR		; save loop variables
FFFC3B44 02098463		beq		a1,x0,PU1		; if LOPVAR is zero, that's all
FFFC3B48 FF070713		sub		$sp,$sp,#16
FFFC3B4C 77002903		lw		a0,LOPPT
FFFC3B50 01272023		sw		a0,[$sp]
FFFC3B54 77402903		lw		a0,LOPLN
FFFC3B58 01272223		sw		a0,4[$sp]
FFFC3B5C 77C02903		lw		a0,LOPLMT
FFFC3B60 01272423		sw		a0,8[$sp]
FFFC3B64 77802903		lw		a0,LOPINC
FFFC3B68 01272623		sw		a0,12[$sp]
                        	PU1:
FFFC3B6C FFC70713		sub		$sp,$sp,#4
FFFC3B70 01372023		sw		a1,[$sp]
FFFC3B74 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	;
                        	; 'PRTSTG' prints a string pointed to by a0. It stops printing
                        	; and returns to the caller when either a CR is printed or when
                        	; the next byte is the same as what was passed in a1 by the
                        	; caller.
                        	;
                        	; 'PRTLN' prints the saved text line pointed to by r3
                        	; with line no. and all.
                        	;
                        	
                        	; a0 = pointer to string
                        	; a1 = stop character
                        	; return v0 = pointer to end of line + 1
                        	
                        	PRTSTG:
FFFC3B78 FEC70713		sub		$sp,$sp,#20
FFFC3B7C 00572023		sw		r5,[$sp]
FFFC3B80 00672223		sw		r6,4[$sp]
FFFC3B84 00772423		sw		r7,8[$sp]
FFFC3B88 00172623		sw		$ra,12[$sp]
FFFC3B8C 01272823		sw		$a0,16[$sp]
FFFC3B90 000962B3		mov   r5,a0	    ; r5 = pointer
FFFC3B94 0009E333		mov   r6,a1	    ; r6 = stop char
                        	.PS1:
FFFC3B98 0002C383	  lbu   r7,[r5]     ; get a text character
FFFC3B9C 00128293		add		r5,r5,#1
FFFC3BA0 00638E63		beq	  r7,r6,.PRTRET	; same as stop character? if so, return
FFFC3BA4 0003E933		mov   a0,r7
FFFC3BA8 861FE0EF		call	GOOUT		; display the char.
FFFC3BAC 00D06D93		ldi		$t1,#CR
FFFC3BB0 FFB394E3		bne   r7,$t1,.PS1	; is it a C.R.? no, go back for more
FFFC3BB4 00A06913		ldi		a0,#LINEFD  ; yes, add a L.F.
FFFC3BB8 851FE0EF		call	GOOUT
                        	.PRTRET:
FFFC3BBC 0003E8B3	  mov   v1,r7	    ; return a1 = stop char
FFFC3BC0 0002E833		mov		v0,r5		; return a0 = line pointer
FFFC3BC4 00072283		lw		$r5,[$sp]
FFFC3BC8 00472303		lw		$r6,4[$sp]
FFFC3BCC 00872383		lw		$r7,8[$sp]
FFFC3BD0 00C72083		lw		$ra,12[$sp]
FFFC3BD4 01072903		lw		$a0,16[$sp]
FFFC3BD8 01470713		add		$sp,$sp,#20
FFFC3BDC 00008067	  ret					; then return
                        	
                        	
                        	; 'QTSTG' looks for an underline (back-arrow on some systems),
                        	; single-quote, or double-quote.  If none of these are found, returns
                        	; to the caller.  If underline, outputs a CR without a LF.  If single
                        	; or double quote, prints the quoted string and demands a matching
                        	; end quote.  After the printing, the next i-word of the caller is
                        	; skipped over (usually a branch instruction).
                        	;
                        	QTSTG:
FFFC3BE0 FFC70713		sub		$sp,$sp,#4
FFFC3BE4 00172023		sw		$ra,[$sp]
FFFC3BE8 1BC000EF		call	TSTC		; *** QTSTG ***
FFFC3BEC 00000022		dw		'"'
FFFC3BF0 02000063		bra		QT3
FFFC3BF4 02206993		ldi		a1,#'"'		; it is a "
                        	QT1:
FFFC3BF8 000E6933		mov		a0,$t2
FFFC3BFC F7DFF0EF		call	PRTSTG		; print until another
FFFC3C00 00086E33		mov		$t2,v0
FFFC3C04 00D06D93		ldi		$t1,#CR
FFFC3C08 03B89863		bne		v1,$t1,QT2	; was last one a CR?
FFFC3C0C C39FE06F		jmp		RUNNXL		; if so run next line
                        	QT3:
FFFC3C10 194000EF		call	TSTC		; is it a single quote?
FFFC3C14 0000005C		dw		'\''
FFFC3C18 00000663		bra		QT4
FFFC3C1C 02706993		ldi		a1,#'\''	; if so, do same as above
FFFC3C20 FC000CE3		bra		QT1
                        	QT4:
FFFC3C24 180000EF		call	TSTC		; is it an underline?
FFFC3C28 0000005F		dw		'_'
FFFC3C2C 00000C63		bra		QT5
FFFC3C30 00D06913		ldi		a0,#CR		; if so, output a CR without LF
FFFC3C34 FD4FE0EF		call	GOOUT
                        	QT2:
FFFC3C38 00072083		lw		$ra,[$sp]		; get return address
FFFC3C3C 00470713		add		$sp,$sp,#4
FFFC3C40 00408067		jmp		4[$ra]		; skip following branch
                        	QT5:					; not " ' or _
FFFC3C44 00072083		lw		$ra,[$sp]		; get return address
FFFC3C48 00470713		add		$sp,$sp,#4
FFFC3C4C 00008067		ret
                        	
                        	; Output a CR LF sequence
                        	;
                        	prCRLF:
FFFC3C50 FFC70713		sub		$sp,$sp,#4
FFFC3C54 00172023		sw		$ra,[$sp]
FFFC3C58 00D06913		ldi		a0,#CR
FFFC3C5C FACFE0EF		call	GOOUT
FFFC3C60 00A06913		ldi		a0,#LINEFD
FFFC3C64 FA4FE0EF		call	GOOUT
FFFC3C68 00072083		lw		$ra,[$sp]
FFFC3C6C 00470713		add		$sp,$sp,#4
FFFC3C70 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; 'PRTNUM' prints the 32 bit number in a0, leading blanks are added if
                        	; needed to pad the number of spaces to the number in a1.
                        	; However, if the number of digits is larger than the no. in
                        	; a1, all digits are printed anyway. Negative sign is also
                        	; printed and counted in, positive sign is not.
                        	;
                        	; Parameters
                        	; 	a0 = number to print
                        	; 	a1 = number of digits
                        	;		a2 = base (eg 10, 16)
                        	; Register Usage
                        	;		s2 = number of padding spaces
                        	; Modifies:
                        	;		a0,a1,t1
                        	; Returns:
                        	;		none
                        	;-------------------------------------------------------------------------------
                        	
FFFC3C74 FEC70713	public PRTNUM:
	sub		$sp,$sp,#20
FFFC3C78 00472023		sw		$s1,[$sp]
FFFC3C7C 00572223		sw		$s2,4[$sp]
FFFC3C80 00672423		sw		$s3,8[$sp]
FFFC3C84 00772623		sw		$s4,12[$sp]
FFFC3C88 00172823		sw		$ra,16[$sp]
FFFC3C8C 79406393		ldi		s4,#NUMWKA	; r7 = pointer to numeric work area
FFFC3C90 00096333		mov		s3,a0		; save number for later
FFFC3C94 0009E2B3		mov		s2,a1		; s2 = min number of chars
FFFC3C98 00095663		bge		a0,x0,.PN2	; is it negative? if not
FFFC3C9C 41200933		sub		a0,x0,a0	; else make it positive
FFFC3CA0 FFF28293		sub		s2,s2,#1	; one less for width count
                        	.PN2:
FFFC3CA4 00A06D93		ldi		$t1,#10
                        	.PN1:
FFFC3CA8 034969B3		rem		a1,a0,a2	; a1 = a0 mod 10
FFFC3CAC 03494933		div		a0,a0,a2	; a0 /= 10 divide by 10
FFFC3CB0 013A7463		bleu	a1,a2,.PN7
FFFC3CB4 00798993		add		a1,a1,#'A'-10-'0'
                        	.PN7:
FFFC3CB8 03098993		add		a1,a1,#'0'	; convert remainder to ascii
FFFC3CBC 01338023		sb		a1,[$s4]		; and store in buffer
FFFC3CC0 00138393		add		s4,s4,#1
FFFC3CC4 FFF28293		sub		s2,s2,#1	; decrement width
FFFC3CC8 FE0910E3		bne		a0,x0,.PN1
FFFC3CCC 00505A63		ble		$s2,$x0,.PN4	; test pad count, skip padding if not needed
                        	.PN3:
FFFC3CD0 02006913		ldi		$a0,#' '		; display the required leading spaces
FFFC3CD4 F34FE0EF		call	GOOUT
FFFC3CD8 FFF28293		sub		$s2,$s2,#1
FFFC3CDC FE504AE3		bgt		$s2,$x0,.PN3
                        	.PN4:
FFFC3CE0 00035663		bge		$s3,$x0,.PN5	; is number negative?
FFFC3CE4 02D06913		ldi		$a0,#'-'		; if so, display the sign
FFFC3CE8 F20FE0EF		call	GOOUT
                        	.PN5:
FFFC3CEC 79406D93		ldi		$t1,#NUMWKA
                        	.PN6:
FFFC3CF0 FFF38393		sub		$s4,$s4,#1
FFFC3CF4 0003C903		lbu		$a0,[$s4]		; now unstack the digits and display
FFFC3CF8 F10FE0EF		call	GOOUT
FFFC3CFC FE7DEAE3		bgtu	$s4,$t1,.PN6
                        	
FFFC3D00 00072203		lw		$s1,[$sp]
FFFC3D04 00472283		lw		$s2,4[$sp]
FFFC3D08 00872303		lw		$s3,8[$sp]
FFFC3D0C 00C72383		lw		$s4,12[$sp]
FFFC3D10 01072083		lw		$ra,16[$sp]
FFFC3D14 01470713		add		$sp,$sp,#20
FFFC3D18 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; Load a word from memory using unaligned access.
                        	; Moves forwards through memory
                        	;
                        	; Parameters:
                        	;		a0 = pointer to word
                        	; Returns:
                        	;		v0 = word loaded
                        	;-------------------------------------------------------------------------------
                        	LoadWord:
FFFC3D1C 00094803	  lbu		$v0,[$a0]	
FFFC3D20 00194883	  lbu		$v1,1[$a0]
FFFC3D24 00889893	  sll		$v1,$v1,#8
FFFC3D28 01186833	  or		$v0,$v0,$v1
FFFC3D2C 00294883	  lbu		$v1,2[$a0]
FFFC3D30 01089893	  sll		$v1,$v1,#16
FFFC3D34 01186833	  or		$v0,$v0,$v1
FFFC3D38 00394883	  lbu		$v1,3[$a0]
FFFC3D3C 01889893	  sll		$v1,$v1,#24
FFFC3D40 01186833	  or		$v0,$v0,$v1
FFFC3D44 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = pointer to line
                        	; Returns:
                        	;		v0 = pointer to end of line + 1
                        	;-------------------------------------------------------------------------------
                        	
                        	PRTLN:
FFFC3D48 FF070713		sub		$sp,$sp,#16
FFFC3D4C 00572023		sw		$r5,[$sp]
FFFC3D50 00172223		sw		$ra,4[$sp]
FFFC3D54 01272423		sw		$a0,8[$sp]
FFFC3D58 01372623		sw		$a1,12[$sp]
FFFC3D5C 000962B3	  mov		$r5,$a0		; r5 = pointer
                        	  ; get the line number stored as binary
                        	  ; assume unaligned loads not allowed
FFFC3D60 FBDFF0EF	  call	LoadWord
FFFC3D64 00086933	  mov		a0,v0
                        	
FFFC3D68 00428293		add		r5,r5,#4
FFFC3D6C 00506993	  ldi		a1,#5       ; display a 0 or more digit line no.
FFFC3D70 00A06A13	  ldi		a2,#10
FFFC3D74 F01FF0EF		call	PRTNUM
FFFC3D78 02006913		ldi		a0,#' '     ; followed by a blank
FFFC3D7C E8CFE0EF		call	GOOUT
FFFC3D80 000069B3		mov		a1,r0       ; stop char. is a zero
FFFC3D84 0002E933		mov		a0,r5
FFFC3D88 DF1FF0EF		call  PRTSTG		; display the rest of the line
FFFC3D8C 00072283		lw		$r5,[$sp]
FFFC3D90 00472083		lw		$ra,4[$sp]
FFFC3D94 00872903		lw		$a0,8[$sp]
FFFC3D98 00C72983		lw		$a1,12[$sp]
FFFC3D9C 01070713		add		$sp,$sp,#16
FFFC3DA0 00008067		ret
                        	
                        	
                        	; ===== Test text byte following the call to this subroutine. If it
                        	;	equals the byte pointed to by t2, return to the code following
                        	;	the call. 
                        	;
                        	; Parameters:
                        	;		<static> word byte to look for
                        	;		<static> branch if not found
                        	; Registers Affected
                        	;   none
                        	; Returns
                        	;		t2 = updated text pointer
                        	;
                        	TSTC:
FFFC3DA4 FF470713		sub		$sp,$sp,#12
FFFC3DA8 01272023		sw		$a0,[$sp]
FFFC3DAC 00172223		sw		$ra,4[$sp]
FFFC3DB0 01372423		sw		$a1,8[$sp]
FFFC3DB4 0B0000EF		call	IGNBLK		; ignore leading blanks
FFFC3DB8 00472083		lw		$ra,4[$sp]	; get return address, it's needed for a reference
FFFC3DBC 000E4903		lbu		$a0,[$t2]
FFFC3DC0 0000C983		lbu		$a1,[$ra]
FFFC3DC4 01298A63		beq		$a1,$a0,TC1	; is it = to what t2 points to? if so
FFFC3DC8 00072903		lw		$a0,[$sp]		; restore a0
FFFC3DCC 00872983		lw		$a1,8[$sp]
FFFC3DD0 00C70713		add		$sp,$sp,#12	;
FFFC3DD4 00408067		jmp		4[$ra]			; jump to the routine skip param
                        	TC1:
FFFC3DD8 001E0E13		add		$t2,$t2,#1	; if equal, bump text pointer
FFFC3DDC 00072903		lw		$a0,[$sp]
FFFC3DE0 00472083		lw		$ra,4[$sp]
FFFC3DE4 00872983		lw		$a1,8[$sp]
FFFC3DE8 00C70713		add		$sp,$sp,#12
FFFC3DEC 00808067		jmp		8[$ra]			; jump back, skip parm and branch
                        	
                        	
                        	; ===== See if the text pointed to by $t2 is a number. If so,
                        	;	return the number in $v0 and the number of digits in $v1,
                        	;	else return zero in $v0 and $v1.
                        	; Registers Affected
                        	;   a0,a1,r3,r4
                        	; Returns
                        	; 	v0 = number
                        	;		v1 = number of digits in number
                        	;	t2 = updated text pointer
                        	;
                        	TSTNUM:
FFFC3DF0 FF870713		sub		$sp,$sp,#8
FFFC3DF4 00172223		sw		$ra,4[$sp]
FFFC3DF8 00372023		sw		r3,[$sp]
FFFC3DFC 068000EF		call	IGNBLK		; skip over blanks
FFFC3E00 00006833		mov		$v0,$x0		; initialize return parameters
FFFC3E04 000068B3		mov		$v1,$x0
                        	TN1:
FFFC3E08 000E4183		lbu		r3,[$t2]
FFFC3E0C 03006D93		ldi		$t1,#'0'
FFFC3E10 05B1C263		blt		r3,$t1,TSNMRET; is it less than zero?
FFFC3E14 03906D93		ldi		$t1,#'9'
FFFC3E18 023DCE63		bgt		r3,$t1,TSNMRET; is it greater than nine?
FFFC3E1C 00000DB7		ldi		$t1,#$7FFFFFFFFFFFFFF
FFFC3E20 FFFD8D93
FFFC3E24 010DF863		bleu	$v0,$t1,TN2; see if there's room for new digit
FFFC3E28 FFFC4937		ldi		$a0,#msgNumTooBig
FFFC3E2C 1E190913
FFFC3E30 AD1FF06F		jmp		ERROR		; if not, we've overflowd
                        	TN2:
FFFC3E34 001E0E13		add		$t2,$t2,#1	; adjust text pointer
FFFC3E38 00181E93		sll		$t3,$v0,#1	; quickly multiply result by 10
FFFC3E3C 00381813		sll		$v0,$v0,#3	; *8
FFFC3E40 01D80833		add		$v0,$v0,$t3	; *8 + *2
FFFC3E44 00F1F193		and		r3,r3,#$0F	; add in the new digit
FFFC3E48 00380833		add		$v0,$v0,r3
FFFC3E4C 00188893		add		$v1,$v1,#1	; increment the no. of digits
FFFC3E50 FA000CE3		bra		TN1
                        	TSNMRET:
FFFC3E54 00072183		lw		r3,[$sp]
FFFC3E58 00472083		lw		$ra,4[$sp]
FFFC3E5C 00870713		add		$sp,$sp,#8
FFFC3E60 00008067		ret
                        	
                        	
                        	;===== Skip over blanks in the text pointed to by $t2.
                        	;
                        	; Registers Affected:
                        	;	$t2
                        	; Returns
                        	;	$t2 = pointer updateded past any spaces or tabs
                        	;
                        	IGNBLK:
FFFC3E64 FFC70713		sub		$sp,$sp,#4
FFFC3E68 01272023		sw		$a0,[$sp]
                        	IGB2:
FFFC3E6C 000E4903		lbu		a0,[$t2]			; get char
FFFC3E70 02006D93		ldi		$t1,#' '
FFFC3E74 01B90663		beq		$a0,$t1,IGB1	; see if it's a space
FFFC3E78 00906D93		ldi		$t1,#'\t'
FFFC3E7C 01B91663		bne		a0,$t1,IGBRET	; or a tab
                        	IGB1:
FFFC3E80 001E0E13		add		$t2,$t2,#1		; increment the text pointer
FFFC3E84 FE0004E3		bra		IGB2
                        	IGBRET:
FFFC3E88 00072903		lw		$a0,[$sp]
FFFC3E8C 00470713		add		$sp,$sp,#4
FFFC3E90 00008067		ret
                        	
                        	; ===== Convert the line of text in the input buffer to upper
                        	;	case (except for stuff between quotes).
                        	;
                        	; Registers Affected
                        	;   a0,r3
                        	; Returns
                        	;	r8 = pointing to end of text in buffer
                        	;
                        	TOUPBUF:
FFFC3E94 FFC70713		sub		$sp,$sp,#4
FFFC3E98 00172023		sw		$ra,[$sp]
FFFC3E9C 71C06E13		ldi		$t2,#BUFFER	; set up text pointer
FFFC3EA0 000061B3		mov		r3,x0		; clear quote flag
                        	TOUPB1:
FFFC3EA4 000E4903		lbu		a0,[$t2]		; get the next text char.
FFFC3EA8 001E0E13		add		$t2,$t2,#1
FFFC3EAC 00D06D93		ldi		$t1,#CR
FFFC3EB0 03B90E63		beq		a0,$t1,TOUPBRT		; is it end of line?
FFFC3EB4 02206D93		ldi		$t1,#'"'
FFFC3EB8 01B90E63		beq		a0,$t1,DOQUO	; a double quote?
FFFC3EBC 02706D93		ldi		$t1,#'\''
FFFC3EC0 01B90A63		beq		a0,$t1,DOQUO	; or a single quote?
FFFC3EC4 FE0190E3		bne		r3,x0,TOUPB1	; inside quotes?
FFFC3EC8 030000EF		call	toUpper 	; convert to upper case
FFFC3ECC FF0E0FA3		sb		v0,-1[$t2]	; store it
FFFC3ED0 FC000AE3		bra		TOUPB1		; and go back for more
                        	DOQUO:
FFFC3ED4 00019663		bne		r3,x0,DOQUO1; are we inside quotes?
FFFC3ED8 000961B3		mov		r3,a0		; if not, toggle inside-quotes flag
FFFC3EDC FC0004E3		bra		TOUPB1
                        	DOQUO1:
FFFC3EE0 FD2192E3		bne		r3,a0,TOUPB1; make sure we're ending proper quote
FFFC3EE4 000061B3		mov		r3,r0		; else clear quote flag
FFFC3EE8 FA000EE3		bra		TOUPB1
                        	TOUPBRT:
FFFC3EEC 00072083		lw		$ra,[$sp]
FFFC3EF0 00470713		add		$sp,$sp,#4
FFFC3EF4 00008067		ret
                        	
                        	
                        	; ===== Convert the character in a0 to upper case
                        	;
                        	toUpper:
FFFC3EF8 00096833		mov		$v0,$a0
FFFC3EFC 06182D93		slt		$t1,$v0,#'a'
FFFC3F00 000D9863		bne   $t1,$x0,TOUPRET	; is it < 'a'?
FFFC3F04 07A06D93		ldi		$t1,#'z'
FFFC3F08 010DC463		bgt		$v0,$t1,TOUPRET	; or > 'z'?
FFFC3F0C FE080813		sub		$v0,$v0,#32	  ; if not, make it upper case
                        	TOUPRET:
FFFC3F10 00008067		ret
                        	
                        	; 'CHKIO' checks the input. If there's no input, it will return
                        	; to the caller with the a0=0. If there is input, the input byte is in a0.
                        	; However, if a control-C is read, 'CHKIO' will warm-start BASIC and will
                        	; not return to the caller.
                        	;
                        	//message "CHKIO"
                        	CHKIO:
FFFC3F14 FFC70713		sub		$sp,$sp,#4
FFFC3F18 00172023		sw		$ra,[$sp]
FFFC3F1C 228000EF		call	INCH		; get input if possible
FFFC3F20 00080863		beq		$v0,$x0,CHKRET	; if Zero, no input
FFFC3F24 00384893		xor		$v1,$v0,#CTRLC
FFFC3F28 00089463		bne		$v1,$x0,CHKRET; is it control-C?
FFFC3F2C D80FE06F		jmp		WSTART		; if so, do a warm start
                        	CHKRET:
FFFC3F30 00072083		lw		$ra,[$sp]
FFFC3F34 00470713		add		$sp,$sp,#4
FFFC3F38 00008067		ret
                        	
                        	; ===== Display a CR-LF sequence
                        	;
                        	CRLF:
FFFC3F3C FFFC4937		ldi		a0,#CLMSG
FFFC3F40 1C590913
                        	
                        	; ===== Display a zero-ended string pointed to by register a0
                        	; Registers Affected
                        	;   a0,a1,r4
                        	;
                        	PRMESG:
FFFC3F44 FFC70713		sub		$sp,$sp,#4
FFFC3F48 00172023		sw		$ra,[$sp]
FFFC3F4C FBCFC0EF		call	SerialPutString
FFFC3F50 00072083		lw		$ra,[$sp]
FFFC3F54 00470713		add		$sp,$sp,#4
FFFC3F58 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;	erc = ALLOCMBX (<handle var>)
                        	;------------------------------------------------------------------------------
                        	
                        	ALLOCMBX:
FFFC3F5C E49FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC3F60 00000028		dw		'('
FFFC3F64 04000E63		bra		.paren
FFFC3F68 00106913		ldi		a0,#1
FFFC3F6C D7CFF0EF		call	TSTV
FFFC3F70 00081863		bne		v0,x0,.0001
FFFC3F74 FFFC4937		ldi		a0,#msgVar
FFFC3F78 25A90913
FFFC3F7C 985FF06F		jmp		ERROR
                        	.0001:
FFFC3F80 E25FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC3F84 00000029		dw		')'
FFFC3F88 02000C63		bra		.paren
FFFC3F8C 00086233		mov		s1,v0
FFFC3F90 00E06913		ldi		a0,#14			; get current tid
FFFC3F94 00000073		ecall
FFFC3F98 0008E9B3		mov		a1,v1
FFFC3F9C 00026A33		mov		a2,s1
FFFC3FA0 00606913		ldi		a0,#6
FFFC3FA4 00000073		ecall
FFFC3FA8 00081463		bne		v0,x0,.0002
FFFC3FAC 01122023		sw		v1,[s1]				; save handle in variable
                        	.0002:
FFFC3FB0 000068B3		mov		v1,x0
FFFC3FB4 00072083		lw		$ra,[$sp]
FFFC3FB8 00470713		add		$sp,$sp,#4
FFFC3FBC 00008067		ret
                        	.paren:
FFFC3FC0 FFFC4937		ldi		a0,#msgParen
FFFC3FC4 36790913
FFFC3FC8 939FF06F		jmp		ERROR
                        	
                        	;------------------------------------------------------------------------------
                        	; erc = SENDMSG (<handle var>, <msg data 1>, <msg data 2>, <msg data 3>)
                        	;------------------------------------------------------------------------------
                        	
                        	SENDMSG:
FFFC3FCC DD9FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC3FD0 00000028		dw		'('
FFFC3FD4 08000463		bra		.paren
FFFC3FD8 8D0FF0EF		call	OREXPR	; get the mailbox handle
FFFC3FDC 00086233		mov		s1,v0
FFFC3FE0 DC5FF0EF		call	TSTC		; it must be followed by a comma
FFFC3FE4 0000002C		dw		','
FFFC3FE8 06000463		bra		.err
FFFC3FEC 8BCFF0EF		call	OREXPR	; get the memory address
FFFC3FF0 000862B3		mov		s2,v0
FFFC3FF4 DB1FF0EF		call	TSTC		; it must be followed by a comma
FFFC3FF8 0000002C		dw		','
FFFC3FFC 04000A63		bra		.err
FFFC4000 8A8FF0EF		call	OREXPR	; get the memory address
FFFC4004 00086333		mov		s3,v0
FFFC4008 D9DFF0EF		call	TSTC		; it must be followed by a comma
FFFC400C 0000002C		dw		','
FFFC4010 04000063		bra		.err
FFFC4014 894FF0EF		call	OREXPR	; get the memory address
FFFC4018 000863B3		mov		s4,v0
FFFC401C D89FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC4020 00000029		dw		')'
FFFC4024 02000C63		bra		.paren
FFFC4028 00906913		ldi		a0,#9		; SendMsg
FFFC402C 000269B3		mov		a1,s1
FFFC4030 0002EA33		mov		a2,s2
FFFC4034 00036AB3		mov		a3,s3
FFFC4038 0003EB33		mov		a4,s4
FFFC403C 00000073		ecall
FFFC4040 000068B3		mov		v1,x0
FFFC4044 00072083		lw		$ra,[$sp]
FFFC4048 00470713		add		$sp,$sp,#4
FFFC404C 00008067		ret
                        	.err:
FFFC4050 FFFC4937		ldi		a0,#msgComma
FFFC4054 23290913
FFFC4058 8A9FF06F		jmp		ERROR
                        	.paren:
FFFC405C FFFC4937		ldi		a0,#msgParen
FFFC4060 36790913
FFFC4064 89DFF06F		jmp		ERROR
                        	
                        	;------------------------------------------------------------------------------
                        	; WAITMSG <handle var>, <var for data 1>, <var for data 2>, <var for data 3>,
                        	;		<expr>
                        	;------------------------------------------------------------------------------
                        	
                        	WAITMSG:
FFFC4068 D3DFF0EF		call	TSTC		; else look for ( OREXPR )
FFFC406C 00000028		dw		'('
FFFC4070 0C000263		bra		.paren
FFFC4074 834FF0EF		call	OREXPR	; get the mailbox handle
FFFC4078 00086233		mov		s1,v0
FFFC407C D29FF0EF		call	TSTC		; it must be followed by a comma
FFFC4080 0000002C		dw		','
FFFC4084 0A000263		bra		.err
FFFC4088 00106913		ldi		a0,#1
FFFC408C C5CFF0EF		call	TSTV
FFFC4090 00081863		bne		v0,x0,.0001
                        	.0002:
FFFC4094 FFFC4937		ldi		a0,#msgVar
FFFC4098 25A90913
FFFC409C 865FF06F		jmp		ERROR
                        	.0001:
FFFC40A0 D05FF0EF		call	TSTC		; it must be followed by a comma
FFFC40A4 0000002C		dw		','
FFFC40A8 08000063		bra		.err
FFFC40AC 000862B3		mov		s2,v0
FFFC40B0 00106913		ldi		a0,#1
FFFC40B4 C34FF0EF		call	TSTV
FFFC40B8 FC080EE3		beq		v0,x0,.0002
FFFC40BC CE9FF0EF		call	TSTC		; it must be followed by a comma
FFFC40C0 0000002C		dw		','
FFFC40C4 06000263		bra		.err
FFFC40C8 00086333		mov		s3,v0
FFFC40CC 00106913		ldi		a0,#1
FFFC40D0 C18FF0EF		call	TSTV
FFFC40D4 FC0800E3		beq		v0,x0,.0002
FFFC40D8 000863B3		mov		s4,v0
FFFC40DC CC9FF0EF		call	TSTC		; it must be followed by a comma
FFFC40E0 0000002C		dw		','
FFFC40E4 04000263		bra		.err
FFFC40E8 FC1FE0EF		call	OREXPR	; get queue remove flag
FFFC40EC 00086BB3		mov		a5,v0
FFFC40F0 000863B3		mov		s4,v0
FFFC40F4 CB1FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC40F8 00000029		dw		')'
FFFC40FC 02000C63		bra		.paren
FFFC4100 00A06913		ldi		a0,#10		; WaitMsg
FFFC4104 000269B3		mov		a1,s1
FFFC4108 0002EA33		mov		a2,s2
FFFC410C 00036AB3		mov		a3,s3
FFFC4110 0003EB33		mov		a4,s4
FFFC4114 00000073		ecall
FFFC4118 000068B3		mov		v1,x0
FFFC411C 00072083		lw		$ra,[$sp]
FFFC4120 00470713		add		$sp,$sp,#4
FFFC4124 00008067		ret
                        	.err:
FFFC4128 FFFC4937		ldi		a0,#msgComma
FFFC412C 23290913
FFFC4130 FD0FF06F		jmp		ERROR
                        	.paren:
FFFC4134 FFFC4937		ldi		a0,#msgParen
FFFC4138 36790913
FFFC413C FC4FF06F		jmp		ERROR
                        	
                        	;*****************************************************
                        	; The following routines are the only ones that need *
                        	; to be changed for a different I/O environment.     *
                        	;*****************************************************
                        	
                        	; ===== Output character to the console (Port 1) from register a0
                        	;	(Preserves all registers.)
                        	;
                        	OUTC:
FFFC4140 D8CFC06F		jmp		SerialPutChar
                        	
                        	; ===== Input a character from the console into register v0 (or
                        	;	return Zero status if there's no character available).
                        	;
                        	INCH:
FFFC4144 FFC70713		sub 	$sp,$sp,#4
FFFC4148 00172023		sw		$ra,[$sp]
FFFC414C D4CFC0EF		call	SerialPeekChar
FFFC4150 00180813		add		$v0,$v0,#1				; prepare test -1
FFFC4154 00080A63		beq		$v0,$x0,INCH1			; was = -1
FFFC4158 FFF80813		sub		$v0,$v0,#1				; get char back
FFFC415C 00072083		lw		$ra,[$sp]
FFFC4160 00470713		add		$sp,$sp,#4
FFFC4164 00008067		ret
                        	INCH1:
FFFC4168 00072083		lw		$ra,[$sp]		; return a zero for no-char
FFFC416C 00470713		add		$sp,$sp,#4
FFFC4170 00008067		ret
                        	
                        	; ===== Return to the resident monitor, operating system, etc.
                        	;
                        	//message "BYEBYE"
                        	BYEBYE:
                        	//	call	ReleaseIOFocus
FFFC4174 70002703		lw		$sp,OSSP
FFFC4178 860FC06F		jmp		Monitor
                        	 
                        	
FFFC417C 53430A0D	msgInit	db	CR,LINEFD,"CS01 Tiny BASIC v1.0",CR,LINEFD,"(C) 2017-2020  Robert Finch",CR,CR,0
FFFC4180 54203130
FFFC4184 20796E69
FFFC4188 49534142
FFFC418C 31762043
FFFC4190 0A0D302E
FFFC4194 20294328
FFFC4198 37313032
FFFC419C 3230322D
FFFC41A0 52202030
FFFC41A4 7265626F
FFFC41A8 69462074
FFFC41AC 0D68636E
FFFC41B0 0A0D000D
FFFC41B2 4B4F0A0D	OKMSG	db	CR,LINEFD,"OK",CR,0
FFFC41B6 6857000D
FFFC41B8 74616857	msgWhat	db	"What?",CR,0
FFFC41BC 53000D3F
FFFC41BF 72726F53	SRYMSG	db	"Sorry."
FFFC41C3 000D2E79
FFFC41C5 6F43000D	CLMSG	db	CR,0
FFFC41C7 706D6F43	msgReadError	db	"Compact FLASH read error",CR,0
FFFC41CB 20746361
FFFC41CF 53414C46
FFFC41D3 65722048
FFFC41D7 65206461
FFFC41DB 726F7272
FFFC41DF 754E000D
FFFC41E1 626D754E	msgNumTooBig	db	"Number is too big",CR,0
FFFC41E5 69207265
FFFC41E9 6F742073
FFFC41ED 6962206F
FFFC41F1 44000D67
FFFC41F4 69766944	msgDivZero		db	"Division by zero",CR,0
FFFC41F8 6E6F6973
FFFC41FC 20796220
FFFC4200 6F72657A
FFFC4204 754F000D
FFFC4206 2074754F	msgVarSpace     db  "Out of variable space",CR,0
FFFC420A 7620666F
FFFC420E 61697261
FFFC4212 20656C62
FFFC4216 63617073
FFFC421A 20000D65
FFFC421D 74796220	msgBytesFree	db	" bytes free",CR,0
FFFC4221 66207365
FFFC4225 0D656572
FFFC4229 65520D00
FFFC422A 6165520D	msgReady		db	CR,"Ready",CR,0
FFFC422E 000D7964
FFFC4232 65707845	msgComma		db	"Expecting a comma",CR,0
FFFC4236 6E697463
FFFC423A 20612067
FFFC423E 6D6D6F63
FFFC4242 4C000D61
FFFC4245 656E694C	msgLineRange	db	"Line number too big",CR,0
FFFC4249 6D756E20
FFFC424D 20726562
FFFC4251 206F6F74
FFFC4255 0D676962
FFFC4259 70784500
FFFC425A 65707845	msgVar			db "Expecting a variable",CR,0
FFFC425E 6E697463
FFFC4262 20612067
FFFC4266 69726176
FFFC426A 656C6261
FFFC426E 4E52000D
FFFC4270 20444E52	msgRNDBad		db	"RND bad parameter",CR,0
FFFC4274 20646162
FFFC4278 61726170
FFFC427C 6574656D
FFFC4280 53000D72
FFFC4283 20535953	msgSYSBad		db	"SYS bad address",CR,0
FFFC4287 20646162
FFFC428B 72646461
FFFC428F 0D737365
FFFC4293 504E4900
FFFC4294 55504E49	msgInputVar		db	"INPUT expecting a variable",CR,0
FFFC4298 78652054
FFFC429C 74636570
FFFC42A0 20676E69
FFFC42A4 61762061
FFFC42A8 62616972
FFFC42AC 000D656C
FFFC42B0 5458454E	msgNextFor		db	"NEXT without FOR",CR,0
FFFC42B4 74697720
FFFC42B8 74756F68
FFFC42BC 524F4620
FFFC42C0 454E000D
FFFC42C2 5458454E	msgNextVar		db	"NEXT expecting a defined variable",CR,0
FFFC42C6 70786520
FFFC42CA 69746365
FFFC42CE 6120676E
FFFC42D2 66656420
FFFC42D6 64656E69
FFFC42DA 72617620
FFFC42DE 6C626169
FFFC42E2 47000D65
FFFC42E5 4F544F47	msgBadGotoGosub	db	"GOTO/GOSUB bad line number",CR,0
FFFC42E9 534F472F
FFFC42ED 62204255
FFFC42F1 6C206461
FFFC42F5 20656E69
FFFC42F9 626D756E
FFFC42FD 000D7265
FFFC4301 55544552	msgRetWoGosub   db	"RETURN without GOSUB",CR,0
FFFC4305 77204E52
FFFC4309 6F687469
FFFC430D 47207475
FFFC4311 4255534F
FFFC4315 7250000D
FFFC4317 676F7250	msgTooBig		db	"Program is too big",CR,0
FFFC431B 206D6172
FFFC431F 74207369
FFFC4323 62206F6F
FFFC4327 000D6769
FFFC432B 72747845	msgExtraChars	db	"Extra characters on line ignored",CR,0
FFFC432F 68632061
FFFC4333 63617261
FFFC4337 73726574
FFFC433B 206E6F20
FFFC433F 656E696C
FFFC4343 6E676920
FFFC4347 6465726F
FFFC434B 4520000D
FFFC434D 766E4520	msgEnvFail		db	" Environment call failed",CR,0
FFFC4351 6E6F7269
FFFC4355 746E656D
FFFC4359 6C616320
FFFC435D 6166206C
FFFC4361 64656C69
FFFC4365 7845000D
FFFC4367 65707845	msgParen		db	"Expecting parenthesis",CR,0
FFFC436B 6E697463
FFFC436F 61702067
FFFC4373 746E6572
FFFC4377 69736568
FFFC437B 00000D73
                        	
                        	LSTROM	equ	*		; end of possible ROM area
;	END
                        	
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	
                        		rodata
                        		align 8                        	
                        	begin_init_data:
                        	_begin_init_data:
                        	
                        		rodata
                        		align 8                        	
                        	end_init_data:
                        	_end_init_data:
776 symbols
  Symbol Name                              seg     address bits
  ABS                                        code  fffc377c 18
  ABS1                                       code  fffc3790 18
  ADDEXPR                                    code  fffc3324 18
  ALLOCMBX                                   code  fffc3f5c 18
  ALLOCMBX.0001                              code  fffc3f80 18
  ALLOCMBX.0002                              code  fffc3fb0 18
  ALLOCMBX.paren                             code  fffc3fc0 18
  ANDEXPR                                    code  fffc3110 18
  AUXIN                                      code  80000000000001a6 32
  AUXIN_INIT                                 code  8000000000000264 32
  AUXOCRLF                                   code  fffc2f5c 18
  AUXOUT                                     code  80000000000001a4 32
  AUXOUT_FLUSH                               code  8000000000000271 32
  AUXOUT_INIT                                code  8000000000000268 32
  AccountTime                                code  fffc19a0 18
  AccountTime.again                          code  fffc19a0 18
  Alloc                                      code  fffc1064 18
  Alloc.0001                                 code  fffc10f0 18
  Alloc.enough                               code  fffc109c 18
  Alloc.noRun                                code  fffc1114 18
  Alloc.noRun2                               code  fffc1094 18
  Alloc.xit                                  code  fffc1118 18
  AllocPage                                  code  fffc0de0 18
  AllocPage.0001                             code  fffc0f70 18
  AllocPage.chkPam12                         code  fffc0e7c 18
  AllocPage.chkPam16                         code  fffc0eac 18
  AllocPage.chkPam20                         code  fffc0edc 18
  AllocPage.chkPam24                         code  fffc0f0c 18
  AllocPage.chkPam28                         code  fffc0f3c 18
  AllocPage.chkPam4                          code  fffc0e1c 18
  AllocPage.chkPam8                          code  fffc0e4c 18
  AllocPage.chkPamDone                       code  fffc0f6c 18
  AllocStack                                 code  fffc1130 18
  AllocStack.0001                            code  fffc114c 18
  AllocStack.xit                             code  fffc1158 18
  AllocTCB                                   code  fffc1bb0 18
  AllocTCB.0001                              code  fffc1bc4 18
  AllocTCB.0002                              code  fffc1bfc 18
  AllocTCB.0003                              code  fffc1c0c 18
  AllocTCB.allocTid                          code  fffc1bf0 18
  BASPRMPT                                   code  fffc24cc 18
  BS                                        const  000008 5
  BUFFER                                    const  00071c 12
  BUFLEN                                    const  000054 8
  BYEBYE                                     code  fffc4174 18
  BitIndex                                   code  fffc0f7c 18
  BitIndex.0001                              code  fffc0f80 18
  BitIndex.0003                              code  fffc0fbc 18
  BitIndex.0004                              code  fffc0fac 18
  BitIndex.foundFree                         code  fffc0fa0 18
  CHKIO                                      code  fffc3f14 18
  CHKRET                                     code  fffc3f30 18
  CLMSG                                      code  fffc41c5 18
  CR                                        const  00000d 5
  CRLF                                       code  fffc3f3c 18
  CSTART                                     code  fffc2430 32
  CTRLC                                     const  000003 3
  CTRLH                                     const  000008 5
  CTRLI                                     const  000009 5
  CTRLJ                                     const  00000a 5
  CTRLK                                     const  00000b 5
  CTRLM                                     const  00000d 5
  CTRLS                                     const  000013 6
  CTRLX                                     const  000018 6
  CURRNT                                    const  000718 12
  CursorFlash                               const  0007b0 12
  DEFLT                                      code  fffc2cd4 18
  DEL                                       const  00007f 8
  DIRECT                                     code  fffc2780 18
  DOQUO                                      code  fffc3ed4 18
  DOQUO1                                     code  fffc3ee0 18
  DeleteLine                                 code  fffc2580 18
  DeleteLine.0001                            code  fffc25a0 18
  DeleteLine.0002                            code  fffc258c 18
  DeleteLine.0003                            code  fffc25a4 18
  DumpReadyQueue                             code  fffc2284 18
  DumpReadyQueue.0001                        code  fffc22fc 18
  DumpReadyQueue.0002                        code  fffc22a8 18
  DumpReadyQueue.nxt                         code  fffc2318 18
  ENDCHK                                     code  fffc38b0 18
  ENDMEM                                    const  008000 17
  ERROR                                      code  fffc3900 18
  ERROR1                                     code  fffc3940 18
  EX1                                        code  fffc27cc 18
  EXEC                                       code  fffc2790 18
  EXGO                                       code  fffc27f4 18
  EXLP                                       code  fffc279c 18
  EXMAT                                      code  fffc27e0 18
  EXNGO                                      code  fffc27b4 18
  EXPR                                       code  fffc3200 18
  E_Arg                                     const  000001 2
  E_BadAlarm                                const  000011 6
  E_BadBlockNum                             const  000025 7
  E_BadDevNum                               const  000020 7
  E_BadDevOp                                const  000022 7
  E_BadMbx                                  const  000004 4
  E_DCBInUse                                const  000019 6
  E_NoDev                                   const  000021 7
  E_NoMem                                   const  00000c 5
  E_NoMoreAlarmBlks                         const  000044 8
  E_NoMoreMbx                               const  000040 8
  E_NoMoreMsgBlks                           const  000041 8
  E_NoMoreTCBs                              const  000045 8
  E_NoMsg                                   const  00000b 5
  E_NoThread                                const  000006 4
  E_NotAlloc                                const  000009 5
  E_NotOwner                                const  000012 6
  E_Ok                                      const  000000 1
  E_QueFull                                 const  000005 4
  E_QueStrategy                             const  000013 6
  E_ReadError                               const  000023 7
  E_Timeout                                 const  000010 6
  E_TooManyBlocks                           const  000026 7
  E_WriteError                              const  000024 7
  EditMem                                    code  fffc0480 18
  FI1                                        code  fffc3890 18
  FI2                                        code  fffc38a4 18
  FILEBUF                                   const  07f600 20
  FILENAME                                  const  0006c0 12
  FIN                                        code  fffc3874 18
  FINISH                                     code  fffc2a40 18
  FMTKInit                                   code  fffc1230 18
  FMTKInit.0001                              code  fffc12a0 18
  FMTKInit.0002                              code  fffc12d0 18
  FMTK_AllocMbx                              code  fffc1d74 18
  FMTK_AllocMbx.badArg                       code  fffc1dd0 18
  FMTK_AllocMbx.noOwner                      code  fffc1da4 18
  FMTK_AllocMbx.nxt                          code  fffc1d80 18
  FMTK_ExitTask                              code  fffc1ce4 18
  FMTK_FreeMbx                               code  fffc1ddc 18
  FMTK_FreeMbx.0001                          code  fffc1e38 18
  FMTK_FreeMbx.0002                          code  fffc1e00 18
  FMTK_FreeMbx.0003                          code  fffc1e28 18
  FMTK_FreeMbx.badMbx                        code  fffc1e50 18
  FMTK_GetCurrentTid                         code  fffc12f8 18
  FMTK_Initialize                            code  8000000000000108 32
  FMTK_KillTask                              code  fffc1cf0 18
  FMTK_KillTask.immortal                     code  fffc1d3c 18
  FMTK_PeekMsg                               code  fffc1ffc 18
  FMTK_PostMsg                               code  8000000000000110 32
  FMTK_Reschedule                            code  fffc19cc 18
  FMTK_Reschedule.noCtxSwitch                code  fffc1a60 18
  FMTK_Reschedule.noException                code  fffc1a0c 18
  FMTK_Reschedule.noMsg                      code  fffc1a4c 18
  FMTK_SchedulerIRQ                          code  fffc1a78 18
  FMTK_SchedulerIRQ.0001                     code  fffc1ac0 18
  FMTK_SchedulerIRQ.noCtxSwitch              code  fffc1b90 18
  FMTK_SchedulerIRQ.noException              code  fffc1b3c 18
  FMTK_SchedulerIRQ.noMsg                    code  fffc1b7c 18
  FMTK_SchedulerIRQ.noTimeouts               code  fffc1b24 18
  FMTK_SchedulerIRQ.timeoutNotDone           code  fffc1af8 18
  FMTK_SendMsg                               code  fffc1e5c 18
  FMTK_SendMsg.0001                          code  fffc1e80 18
  FMTK_SendMsg.badMbx                        code  fffc1f3c 18
  FMTK_SendMsg.mbxEmpty                      code  fffc1f24 18
  FMTK_SendMsg.noMsg                         code  fffc1f34 18
  FMTK_SendMsg.noWaiters                     code  fffc1ed8 18
  FMTK_SendMsg.nxtTid                        code  fffc1ebc 18
  FMTK_SendMsg.xit                           code  fffc1f40 18
  FMTK_SetTaskPriority                       code  800000000000010c 32
  FMTK_Sleep                                 code  fffc1d40 18
  FMTK_Sleep.xit                             code  fffc1d68 18
  FMTK_StartApp                              code  8000000000000114 32
  FMTK_StartTask                             code  fffc1c28 18
  FMTK_StartTask.err                         code  fffc1cd4 18
  FMTK_SwitchTask                            code  fffc166c 18
  FMTK_SwitchTask.0001                       code  fffc17c4 18
  FMTK_SwitchTask.dead                       code  fffc179c 18
  FMTK_SwitchTask.noMsg                      code  fffc181c 18
  FMTK_SwitchTask.ready                      code  fffc182c 18
  FMTK_SwitchTask.rsseg                      code  fffc1840 18
  FMTK_SwitchTask.svseg                      code  fffc1780 18
  FMTK_WaitMsg                               code  fffc2008 18
  FMTK_WaitMsg.noTimelimit                   code  fffc2074 18
  FMTK_WaitMsg.qt                            code  fffc2024 18
  FNDLN                                      code  fffc3a38 18
  FNDLNP                                     code  fffc3a58 18
  FNDNXT                                     code  fffc3ab4 18
  FNDRET                                     code  fffc3a88 18
  FNDRET.0001                                code  fffc3a8c 18
  FNDRET1                                    code  fffc3aa4 18
  FNDRET2                                    code  fffc3aac 18
  FNDSKP                                     code  fffc3ab8 18
  FOR                                        code  fffc2ad0 18
  FORCEFIT                                   code  fffc31d8 18
  FORCEFIT.0001                              code  fffc31fc 18
  FORCEFIT.intAnd                            code  fffc31ec 18
  FR1                                        code  fffc2af0 18
  FR2                                        code  fffc2b0c 18
  FR3                                        code  fffc2b14 18
  FR4                                        code  fffc2b18 18
  FR5                                        code  fffc2b1c 18
  FR6                                        code  fffc2b34 18
  FR7                                        code  fffc2b38 18
  FR8                                        code  fffc2b58 18
  FUNCEXPR                                   code  fffc3458 18
  FillMem                                    code  fffc0498 18
  FillMem.0001                               code  fffc04b4 18
  FindRun                                    code  fffc100c 18
  FindRun.0001                               code  fffc1024 18
  FindRun.empty0                             code  fffc103c 18
  FindRun.empty1                             code  fffc1040 18
  FindRun.foundEnough                        code  fffc105c 18
  FreeAll                                    code  fffc115c 18
  FreeAll.0001                               code  fffc11bc 18
  FreeAll.nxt                                code  fffc1164 18
  FreeMsg                                   const  008c00 17
  FreePage                                   code  fffc0fc0 18
  FreePage.xit                               code  fffc1008 18
  GCHAR                                      code  fffc2d58 18
  GCHAR1                                     code  fffc2d70 18
  GETLN                                      code  fffc3944 18
  GETLN.GL1                                  code  fffc3964 18
  GETLN.GL2                                  code  fffc398c 18
  GETLN.GL3                                  code  fffc39bc 18
  GETLN.GL4                                  code  fffc39e4 18
  GETLN.GL5                                  code  fffc39f4 18
  GETLN.GL6                                  code  fffc3a14 18
  GETLN.GL7                                  code  fffc3a1c 18
  GOAUXI                                     code  fffc2418 18
  GOAUXO                                     code  fffc2410 18
  GOBYE                                      code  fffc2420 18
  GOIN                                       code  fffc240c 18
  GOOUT                                      code  fffc2408 18
  GOSTART                                    code  fffc2400 18
  GOSUB                                      code  fffc2a48 18
  GOTO                                       code  fffc28c4 18
  GOWARM                                     code  fffc2404 18
  GetBuflen                                  code  fffc25e8 18
  GetBuflen.0001                             code  fffc2610 18
  GetBuflen.0002                             code  fffc25f4 18
  GetBuflen.0004                             code  fffc260c 18
  GetCurrentTid                              code  fffc12e8 18
  GetFilename                                code  fffc2dbc 18
  GetHexNum                                  code  fffc04f0 18
  GetHexNum.0001                             code  fffc0540 18
  GetHexNum.isDigit                          code  fffc057c 18
  GetHexNum.isHexLower                       code  fffc0564 18
  GetHexNum.isHexUpper                       code  fffc054c 18
  GetHexNum.next                             code  fffc0500 18
  Getch                                      code  fffc01a0 18
  HRDY0                                     const  004308 16
  HRDY1                                     const  004309 16
  HRDY2                                     const  00430a 16
  HRDY3                                     const  00430b 16
  IF0                                        code  fffc2bd4 18
  IF1                                        code  fffc2bd8 18
  IF2                                        code  fffc2be0 18
  IF3                                        code  fffc2bf4 18
  IGB1                                       code  fffc3e80 18
  IGB2                                       code  fffc3e6c 18
  IGBRET                                     code  fffc3e88 18
  IGNBLK                                     code  fffc3e64 18
  INBUF                                     const  004100 16
  INCH                                       code  fffc4144 18
  INCH1                                      code  fffc4168 18
  INPERR                                     code  fffc2bf8 18
  INPPTR                                    const  0007ac 12
  INPUT                                      code  fffc2c14 18
  INSLINE                                    code  fffc2540 18
  INSLINE.0001                               code  fffc256c 18
  IP2                                        code  fffc2c3c 18
  IP3                                        code  fffc2c78 18
  IP4                                        code  fffc2cb8 18
  IP5                                        code  fffc2cc8 18
  IP6                                        code  fffc2c1c 18
  IP7                                        code  fffc2c5c 18
  IRQFlag                                   const  0007b4 12
  IRQROUT                                   const  0007a4 12
  IRQRout                                    code  fffc0780 18
  IRQRout.0001                               code  fffc07f4 18
  IRQRout.0002                               code  fffc080c 18
  IRQRout.isIRQ                              code  fffc0798 18
  InsertIntoTimeoutList                      code  fffc2118 18
  InsertIntoTimeoutList.0001                 code  fffc2158 18
  InsertIntoTimeoutList.0002                 code  fffc21b8 18
  InsertIntoTimeoutList.0003                 code  fffc21c8 18
  InsertIntoTimeoutList.beginWhile           code  fffc2170 18
  InsertIntoTimeoutList.endWhile             code  fffc218c 18
  InsertLine                                 code  fffc25c8 18
  InsertLine.0001                            code  fffc25cc 18
  InsertLine.done                            code  fffc25e4 18
  InsertTask                                 code  fffc2078 18
  InsertTask.badTid                          code  fffc2100 18
  InsertTask.qfull                           code  fffc2108 18
  InsertTask.xit                             code  fffc210c 18
  LET                                        code  fffc2ce0 18
  LINEFD                                    const  00000a 5
  LISTX                                      code  fffc2960 18
  LOAD                                       code  fffc2cf8 18
  LOAD3                                      code  fffc2e28 18
  LOAD4                                      code  fffc2e54 18
  LOAD5                                      code  fffc2e8c 18
  LOD1                                       code  fffc2d08 18
  LOD2                                       code  fffc2d34 18
  LODEND                                     code  fffc2d50 18
  LOPINC                                    const  000778 12
  LOPLMT                                    const  00077c 12
  LOPLN                                     const  000774 12
  LOPPT                                     const  000770 12
  LOPVAR                                    const  000710 12
  LS1                                        code  fffc2974 18
  LS2                                        code  fffc299c 18
  LS3                                        code  fffc29a4 18
  LS4                                        code  fffc2980 18
  LS5                                        code  fffc2978 18
  LSTROM                                    const  000000 1
  LT1                                        code  fffc2cf4 18
  LoadWord                                   code  fffc3d1c 18
  MAX_TID                                   const  00000f 5
  MBX_MQHEAD                                const  000008 5
  MBX_MQTAIL                                const  00000c 5
  MBX_OWNER                                 const  000000 1
  MBX_SIZE                                  const  000010 6
  MBX_WTIDS                                 const  000004 4
  MMUInit                                    code  fffc0ce8 18
  MMUInit.0001                               code  fffc0d9c 18
  MMUInit.0002                               code  fffc0dcc 18
  MMUInit.0003                               code  fffc0db0 18
  MSG_D1                                    const  000004 4
  MSG_D2                                    const  000008 5
  MSG_D3                                    const  00000c 5
  MSG_LINK                                  const  000000 1
  MSG_SIZE                                  const  000010 6
  MULEXPR                                    code  fffc33bc 18
  MVDOWN                                     code  fffc3af4 18
  MVDOWN1                                    code  fffc3ae4 18
  MVUP                                       code  fffc3adc 18
  MVUP1                                      code  fffc3acc 18
  MachineStart                               code  fffc0100 18
  MonEntry                                   code  fffc01d0 18
  Monitor                                    code  fffc01d8 18
  Monitor.0001                               code  fffc01f4 18
  Monitor.0002                               code  fffc0244 18
  Monitor.0003                               code  fffc02a8 18
  Monitor.0004                               code  fffc0330 18
  Monitor.0005                               code  fffc03f4 18
  Monitor.0006                               code  fffc0398 18
  Monitor.0007                               code  fffc03ac 18
  Monitor.0008                               code  fffc03b8 18
  Monitor.0009                               code  fffc03c4 18
  Monitor.0010                               code  fffc03d8 18
  Monitor.0011                               code  fffc03f4 18
  Monitor.doBackspace                        code  fffc0294 18
  Monitor.doDelete                           code  fffc023c 18
  Monitor.procLine                           code  fffc02f8 18
  Monitor.skip                               code  fffc030c 18
  Monitor.skip2                              code  fffc0328 18
  NEW                                        code  fffc2808 18
  NEXT                                       code  fffc2b5c 18
  NPAGES                                    const  004300 16
  NR_TCB                                    const  000010 6
  NUMWKA                                    const  000794 12
  NX0                                        code  fffc2b78 18
  NX1                                        code  fffc2bb8 18
  NX2                                        code  fffc2b98 18
  NX3                                        code  fffc2bbc 18
  NX4                                        code  fffc2b74 18
  NX5                                        code  fffc2b8c 18
  NXPurge                                    code  fffc2bcc 18
  OKMSG                                      code  fffc41b2 18
  ONIRQ                                      code  fffc2928 18
  ONIRQ1                                     code  fffc2948 18
  OREXPR                                     code  fffc30a8 18
  OSCALL                                     code  fffc1960 18
  OSCallTbl                                  code  fffc11f0 18
  OSSP                                      const  000700 12
  OUTC                                       code  fffc4140 18
  OUTPTR                                    const  0007a8 12
  OpenSpace                                  code  fffc2614 18
  OpenSpace.0003                             code  fffc262c 18
  OpenSpace.noSpace                          code  fffc2648 18
  PAM                                       const  004800 16
  PARN                                       code  fffc34a8 18
  PEEK                                       code  fffc3698 18
  PEEKH                                      code  fffc36c8 18
  PEEKW                                      code  fffc36b0 18
  PIDMAP                                    const  004310 16
  PKER                                       code  fffc3070 18
  POKE                                       code  fffc2fec 18
  POKEH                                      code  fffc3044 18
  POKEW                                      code  fffc3018 18
  POPA_                                      code  fffc3afc 18
  PP1                                        code  fffc3b30 18
  PR0                                        code  fffc29d4 18
  PR1                                        code  fffc29ec 18
  PR2                                        code  fffc29c0 18
  PR3                                        code  fffc2a0c 18
  PR4                                        code  fffc2a04 18
  PR6                                        code  fffc2a20 18
  PR8                                        code  fffc2a28 18
  PRINT                                      code  fffc29a8 18
  PRMESG                                     code  fffc3f44 18
  PRTLN                                      code  fffc3d48 18
  PRTNUM                                     code  fffc3c74 32
  PRTNUM.PN1                                 code  fffc3ca8 18
  PRTNUM.PN2                                 code  fffc3ca4 18
  PRTNUM.PN3                                 code  fffc3cd0 18
  PRTNUM.PN4                                 code  fffc3ce0 18
  PRTNUM.PN5                                 code  fffc3cec 18
  PRTNUM.PN6                                 code  fffc3cf0 18
  PRTNUM.PN7                                 code  fffc3cb8 18
  PRTSTG                                     code  fffc3b78 18
  PRTSTG.PRTRET                              code  fffc3bbc 18
  PRTSTG.PS1                                 code  fffc3b98 18
  PU1                                        code  fffc3b6c 18
  PUSHA_                                     code  fffc3b34 18
  PWORD                                      code  fffc2f80 18
  PeekMsg                                    code  fffc1f48 18
  PeekMsg.badMbx                             code  fffc1fec 18
  PeekMsg.noMsg                              code  fffc1fe4 18
  PeekMsg.nod1                               code  fffc1fb4 18
  PeekMsg.nod2                               code  fffc1fc8 18
  PeekMsg.nod3                               code  fffc1fdc 18
  PeekMsg.nodq                               code  fffc1fa0 18
  PeekMsg.ret                                code  fffc1ff0 18
  PopTimeoutList                             code  fffc222c 18
  PopTimeoutList.done                        code  fffc2280 18
  PutHexByte                                 code  fffc05d0 18
  PutHexHalf                                 code  fffc05b0 18
  PutHexNybble                               code  fffc05f0 18
  PutHexNybble.0001                          code  fffc0620 18
  PutHexNybble.lt10                          code  fffc0618 18
  PutHexWord                                 code  fffc0590 18
  Putch                                      code  fffc01b8 18
  QNDX                                      const  004304 16
  QSORRY                                     code  fffc38ec 18
  QT1                                        code  fffc3bf8 18
  QT2                                        code  fffc3c38 18
  QT3                                        code  fffc3c10 18
  QT4                                        code  fffc3c24 18
  QT5                                        code  fffc3c44 18
  QTSTG                                      code  fffc3be0 18
  QWHAT                                      code  fffc38f8 18
  RDYQ0                                     const  004400 16
  RDYQ1                                     const  004500 16
  RDYQ2                                     const  004600 16
  RDYQ3                                     const  004700 16
  RETURN                                     code  fffc2a8c 18
  RND                                        code  fffc3720 18
  RUN                                        code  fffc2830 18
  RUN1                                       code  fffc2890 18
  RUN2                                       code  fffc284c 18
  RUN3                                       code  fffc2850 18
  RUNNXL                                     code  fffc2844 18
  RUNSML                                     code  fffc28ac 18
  RUNTSL                                     code  fffc28a4 18
  RemoveFromTimeoutList                      code  fffc21dc 18
  RemoveFromTimeoutList.0001                 code  fffc2204 18
  RemoveFromTimeoutList.0002                 code  fffc2218 18
  SAVE                                       code  fffc2efc 18
  SAVE1                                      code  fffc2f08 18
  SAVE2                                      code  fffc2f24 18
  SAVE3                                      code  fffc2e90 18
  SAVE4                                      code  fffc2ec0 18
  SAVEND                                     code  fffc2f3c 18
  SDReadSector                               code  8000000000000265 32
  SDWriteSector                              code  800000000000026a 32
  SENDMSG                                    code  fffc3fcc 18
  SENDMSG.err                                code  fffc4050 18
  SENDMSG.paren                              code  fffc405c 18
  SETVAL                                     code  fffc380c 18
  SETVAL.sv2                                 code  fffc3830 18
  SGN                                        code  fffc37b4 18
  SGN1                                       code  fffc37e4 18
  SGN2                                       code  fffc37d4 18
  SIZEX                                      code  fffc37f0 18
  SRYMSG                                     code  fffc41bf 18
  ST2                                        code  fffc251c 18
  STACKOFFS                                 const  07fffc 20
  STKBOT                                    const  00079c 12
  STKGOS                                    const  000714 12
  STKINP                                    const  000798 12
  STOP                                       code  fffc281c 18
  STRTMP                                    const  000200 11
  SV1                                        code  fffc386c 18
  SYSX                                       code  fffc307c 18
  SelectTaskToRun                            code  fffc1308 18
  SelectTaskToRun.dq                         code  fffc1388 18
  SelectTaskToRun.goodTid                    code  fffc13c4 18
  SelectTaskToRun.nxtQ                       code  fffc134c 18
  SerialInit                                 code  fffc073c 18
  SerialPeekChar                             code  fffc0698 18
  SerialPeekChar.0001                        code  fffc06c4 18
  SerialPutChar                              code  fffc06cc 18
  SerialPutChar.0001                         code  fffc06d4 18
  SerialPutString                            code  fffc0708 18
  SerialPutString.0001                       code  fffc0718 18
  SerialPutString.done                       code  fffc072c 18
  SkipSpaces                                 code  fffc04c4 18
  SkipSpaces.skip1                           code  fffc04e8 18
  SkipSpaces.skip2                           code  fffc04c4 18
  SwapContext                                code  fffc1404 18
  SwapContext.rsseg                          code  fffc154c 18
  SwapContext.svseg                          code  fffc1508 18
  TAB                                       const  000009 5
  TAB1                                       code  fffc2650 18
  TAB10                                      code  fffc270a 18
  TAB10_1                                    code  fffc277a 18
  TAB1_1                                     code  fffc270e 18
  TAB2                                       code  fffc2662 18
  TAB2_1                                     code  fffc2718 18
  TAB4                                       code  fffc26bb 18
  TAB4_1                                     code  fffc2746 18
  TAB5                                       code  fffc26f4 18
  TAB5_1                                     code  fffc2760 18
  TAB6                                       code  fffc26f7 18
  TAB6_1                                     code  fffc2764 18
  TAB8                                       code  fffc26fc 18
  TAB8_1                                     code  fffc2768 18
  TAB9                                       code  fffc2706 18
  TAB9_1                                     code  fffc2776 18
  TC1                                        code  fffc3dd8 18
  TCBEndTick                                const  0002b8 11
  TCBException                              const  0002c8 11
  TCBMsgD1                                  const  000298 11
  TCBMsgD2                                  const  0002a0 11
  TCBMsgD3                                  const  0002a8 11
  TCBNext                                   const  0002d0 11
  TCBPrev                                   const  0002d8 11
  TCBPriority                               const  000289 11
  TCBStackBot                               const  000290 11
  TCBStartTick                              const  0002b0 11
  TCBStatus                                 const  000288 11
  TCBTicks                                  const  0002c0 11
  TCBTimeout                                const  0002e0 11
  TCBWaitMbx                                const  00028a 11
  TCBepc                                    const  000280 11
  TCBsegs                                   const  000200 11
  TICKX                                      code  fffc37a0 18
  TN1                                        code  fffc3e08 18
  TN2                                        code  fffc3e34 18
  TOOBIG                                     code  fffc38e0 18
  TOUPB1                                     code  fffc3ea4 18
  TOUPBRT                                    code  fffc3eec 18
  TOUPBUF                                    code  fffc3e94 18
  TOUPRET                                    code  fffc3f10 18
  TRDY0                                     const  00430c 16
  TRDY1                                     const  00430d 16
  TRDY2                                     const  00430e 16
  TRDY3                                     const  00430f 16
  TSNMRET                                    code  fffc3e54 18
  TSTC                                       code  fffc3da4 18
  TSTNUM                                     code  fffc3df0 18
  TSTV                                       code  fffc34e8 18
  TSTVRT                                     code  fffc3558 18
  TS_DEAD                                   const  000002 3
  TS_MSGRDY                                 const  000004 4
  TS_NONE                                   const  000000 1
  TS_PREEMPT                                const  000020 7
  TS_READY                                  const  000001 2
  TS_RUNNING                                const  000080 9
  TS_TIMEOUT                                const  000010 6
  TS_WAITMSG                                const  000008 5
  TV1                                        code  fffc3544 18
  TV2                                        code  fffc3538 18
  TV3                                        code  fffc3518 18
  TXTBGN                                    const  001800 14
  TXTUNF                                    const  000704 12
  Tick                                      const  004330 16
  TimeoutList                               const  004328 16
  TinyBasic                                  code  fffc2400 18
  UART                                      const  ffdc0a00 33
  UART_CMD                                  const  000008 5
  UART_STAT                                 const  000004 4
  UART_TRB                                  const  000000 1
  USRX                                       code  fffc36e0 18
  UserStart                                  code  fffc012c 18
  UserStart.0002                             code  fffc0164 18
  UserStart.0003                             code  fffc018c 18
  UserStart.0004                             code  fffc0158 18
  VARBGN                                    const  000708 12
  VAREND                                    const  00070c 12
  VIA                                       const  ffdc0600 33
  VIAInit                                    code  fffc0630 18
  VIA_ACR                                   const  00002c 7
  VIA_DDRA                                  const  00000c 5
  VIA_IFR                                   const  000034 7
  VIA_PA                                    const  000004 4
  VIA_PARAW                                 const  00003c 7
  VIA_PCR                                   const  000030 7
  VIA_T1CH                                  const  000014 6
  VIA_T1CL                                  const  000010 6
  VirtToPhys                                 code  fffc11c0 18
  WAITIRQ                                    code  fffc2950 18
  WAITMSG                                    code  fffc4068 18
  WAITMSG.0001                               code  fffc40a0 18
  WAITMSG.0002                               code  fffc4094 18
  WAITMSG.err                                code  fffc4128 18
  WAITMSG.paren                              code  fffc4134 18
  WSTART                                     code  fffc24ac 18
  XOFF                                      const  000013 6
  XON                                       const  000011 6
  XP11                                       code  fffc322c 18
  XP12                                       code  fffc3244 18
  XP13                                       code  fffc325c 18
  XP14                                       code  fffc3274 18
  XP15                                       code  fffc328c 18
  XP16                                       code  fffc32a4 18
  XP17                                       code  fffc32e4 18
  XP18                                       code  fffc32fc 18
  XP21                                       code  fffc334c 18
  XP22                                       code  fffc3358 18
  XP23                                       code  fffc335c 18
  XP24                                       code  fffc3378 18
  XP25                                       code  fffc338c 18
  XP26                                       code  fffc3398 18
  XP31                                       code  fffc33c8 18
  XP34                                       code  fffc33f8 18
  XP35                                       code  fffc341c 18
  XP40                                       code  fffc3474 18
  XP41                                       code  fffc3490 18
  XP42                                       code  fffc34cc 18
  XP43                                       code  fffc34d8 18
  XP45                                       code  fffc33a4 18
  XP46                                       code  fffc349c 18
  XP47                                       code  fffc3440 18
  XPRT0                                      code  fffc32bc 18
  XPRT1                                      code  fffc32d0 18
  XP_AND                                     code  fffc313c 18
  XP_AND1                                    code  fffc311c 18
  XP_ANDX                                    code  fffc3150 18
  XP_OR                                      code  fffc30dc 18
  XP_OR1                                     code  fffc30bc 18
  XP_ORX                                     code  fffc30f0 18
  YIELD0                                     code  fffc2824 18
  _clr                                       code  fffc28e8 18
  _cls                                       code  80000000000001e9 32
  _end_init_data                           rodata  fffc5000 32
  _rdcf                                      code  80000000000001eb 32
  a2h1                                       code  fffc2db0 18
  asciiToHex                                 code  fffc2da4 18
  begin_init_data                          rodata  fffc5000 32
  clearVars                                  code  fffc28f0 18
  clearVars.cv1                              code  fffc2904 18
  doMem                                      code  fffc03f8 18
  doMem.loop                                 code  fffc045c 18
  doMem.loop2                                code  fffc0434 18
  ec1                                        code  fffc38d4 18
  end_init_data                            rodata  fffc5000 32
  entry                                      code  fffc222c 18
  findVar                                    code  fffc3628 18
  fl1                                        code  fffc3a50 18
  flt10                                      code  fffc090d 18
  flt20                                      code  fffc08fd 18
  flt50                                      code  fffc08ed 18
  fltMillion                                 code  fffc0ce4 18
  fltOne                                     code  fffc0cdc 18
  fltTen                                     code  fffc0ce0 18
  fltToString                                code  fffc091d 18
  fltToString.0001                           code  fffc097e 18
  fltToString.0002                           code  fffc09fe 18
  fltToString.0003                           code  fffc09ea 18
  fltToString.0004                           code  fffc0a4a 18
  fltToString.0005                           code  fffc0a42 18
  fltToString.0006                           code  fffc0a2a 18
  fltToString.0007                           code  fffc0a66 18
  fltToString.0008                           code  fffc0a7a 18
  fltToString.0009                           code  fffc0a76 18
  fltToString.0010                           code  fffc0a9a 18
  fltToString.0011                           code  fffc0b26 18
  fltToString.0012                           code  fffc0ade 18
  fltToString.0013                           code  fffc0aca 18
  fltToString.0014                           code  fffc0afa 18
  fltToString.0015                           code  fffc0b16 18
  fltToString.0016                           code  fffc0ab2 18
  fltToString.0017                           code  fffc0b1e 18
  fltToString.0018                           code  fffc0b26 18
  fltToString.0019                           code  fffc0b5a 18
  fltToString.0020                           code  fffc0b66 18
  fltToString.0021                           code  fffc0b8a 18
  fltToString.0022                           code  fffc0b96 18
  fltToString.0023                           code  fffc0ba6 18
  fltToString.0024                           code  fffc0bb2 18
  fltToString.0025                           code  fffc0b9e 18
  fltToString.0026                           code  fffc0bc6 18
  fltToString.0027                           code  fffc0bce 18
  fltToString.0028                           code  fffc0bd6 18
  fltToString.0029                           code  fffc0be2 18
  fltToString.0030                           code  fffc0bee 18
  fltToString.0031                           code  fffc0bfa 18
  fltToString.0032                           code  fffc0c02 18
  fltToString.0034                           code  fffc0c0a 18
  fltToString.0035                           code  fffc0c16 18
  fltToString.0036                           code  fffc0c26 18
  fltToString.0037                           code  fffc0c32 18
  fltToString.0038                           code  fffc0c3a 18
  fltToString.0039                           code  fffc0c4e 18
  fltToString.0040                           code  fffc0c42 18
  fltToString.0041                           code  fffc0caa 18
  fltToString.0042                           code  fffc0c6e 18
  fltToString.0043                           code  fffc0c7e 18
  fltToString.0044                           code  fffc0c92 18
  fltToString.0045                           code  fffc0c76 18
  fltToString.0046                           code  fffc0c9e 18
  fltToString.0047                           code  fffc0caa 18
  fltToString.0048                           code  fffc0c96 18
  fltToString.0050                           code  fffc0cca 18
  fltToString.0051                           code  fffc0cc6 18
  fltToString.0052                           code  fffc0cb6 18
  fltToString.inf                            code  fffc0966 18
  fltToString.notZero                        code  fffc09ba 18
  fltToString.pos                            code  fffc09a6 18
  fltToString.prt                            code  fffc0c5e 18
  fv1                                        code  fffc3670 18
  fv2                                        code  fffc3684 18
  fv3                                        code  fffc3668 18
  fv4                                        code  fffc3638 18
  gen_rand                                   code  80000000000002b3 32
  getVarName                                 code  fffc357c 18
  gfn1                                       code  fffc2e24 18
  gfn2                                       code  fffc2dd4 18
  gfn3                                       code  fffc2e04 18
  gosub1                                     code  fffc2a68 18
  gvn1                                       code  fffc3614 18
  gvn2                                       code  fffc35d8 18
  gvn3                                       code  fffc35f4 18
  gvn4                                       code  fffc359c 18
  gvn6                                       code  fffc35c8 18
  isAlnum                                    code  fffc31b8 18
  isAlpha                                    code  fffc3188 18
  isAlphaFalse                               code  fffc31b0 18
  isAlphaTrue                                code  fffc31a8 18
  isDigit                                    code  fffc3168 18
  isDigitFalse                               code  fffc3180 18
  isDigitx                                   code  fffc31cc 18
  mbxs                                      const  008800 17
  mbxs_end                                  const  008a00 17
  milliseconds                              const  004208 16
  missed_ticks                              const  004320 16
  msgBadGotoGosub                            code  fffc42e5 18
  msgBytesFree                               code  fffc421d 18
  msgCRLF                                    code  fffc08ea 18
  msgComma                                   code  fffc4232 18
  msgDivZero                                 code  fffc41f4 18
  msgEnvFail                                 code  fffc434d 18
  msgExtraChars                              code  fffc432b 18
  msgInf                                     code  fffc0cd4 18
  msgInit                                    code  fffc417c 18
  msgInputVar                                code  fffc4294 18
  msgLineRange                               code  fffc4245 18
  msgMonHelp                                 code  fffc083a 18
  msgNan                                     code  fffc0cd8 18
  msgNextFor                                 code  fffc42b0 18
  msgNextVar                                 code  fffc42c2 18
  msgNumTooBig                               code  fffc41e1 18
  msgParen                                   code  fffc4367 18
  msgRNDBad                                  code  fffc4270 18
  msgReadError                               code  fffc41c7 18
  msgReady                                   code  fffc422a 18
  msgRetWoGosub                              code  fffc4301 18
  msgSYSBad                                  code  fffc4283 18
  msgStart                                   code  fffc0824 18
  msgTaskStart                               code  fffc08dc 18
  msgTooBig                                  code  fffc4317 18
  msgVar                                     code  fffc425a 18
  msgVarSpace                                code  fffc4206 18
  msgWhat                                    code  fffc41b8 18
  msgs                                      const  004800 16
  prCRLF                                     code  fffc3c50 18
  pword1                                     code  fffc2f94 18
  pword2                                     code  fffc2fb0 18
  qToChk                                     code  fffc1210 18
  return1                                    code  fffc2aa4 18
  rnd1                                       code  fffc3754 18
  rnd2                                       code  fffc3764 18
  switchflag                                const  004200 16
  sysx1                                      code  fffc3090 18
  tah1                                       code  fffc2fe4 18
  tid                                        code  fffc222c 18
  timeout                                    code  800000000000016e 32
  toAsciiHex                                 code  fffc2fd4 18
  toUpper                                    code  fffc3ef8 18
  tstv_notfound                              code  fffc3568 18
  usrJmp                                    const  0007a0 12
  v0                                        const  800000000000016e 64

Undefined Symbols
  AUXIN                                      code  80000000000001a6 32
  AUXIN_INIT                                 code  8000000000000264 32
  AUXOUT                                     code  80000000000001a4 32
  AUXOUT_FLUSH                               code  8000000000000271 32
  AUXOUT_INIT                                code  8000000000000268 32
  FMTK_Initialize                            code  8000000000000108 32
  FMTK_PostMsg                               code  8000000000000110 32
  FMTK_SetTaskPriority                       code  800000000000010c 32
  FMTK_StartApp                              code  8000000000000114 32
  SDReadSector                               code  8000000000000265 32
  SDWriteSector                              code  800000000000026a 32
  _cls                                       code  80000000000001e9 32
  _rdcf                                      code  80000000000001eb 32
  gen_rand                                   code  80000000000002b3 32
  timeout                                    code  800000000000016e 32

  Macro Name
0 compressable instructions
The top 1024 are:
Comp  Opcode  Count
