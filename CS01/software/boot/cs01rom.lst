                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "../fmtk/const.asm",1
                        	.file "../fmtk/const.asm",1
                        	; First 128 bytes are for integer register set
                        	; Second 128 bytes are for float register set
                        	; Leave some room for 64-bit regs
                        	TCBsegs			EQU		$200		; segment register storage
                        	TCBepc			EQU		$280
                        	TCBStatus		EQU		$288
                        	TCBPriority	EQU		$289
                        	TCBStackBot	EQU		$290
                        	TCBMsgD1		EQU		$298
                        	TCBMsgD2		EQU		$2A0
                        	TCBMsgD3		EQU		$2A8
                        	TCBStartTick	EQU	$2B0
                        	TCBEndTick	EQU		$2B8
                        	TCBTicks		EQU		$2C0
                        	TCBException	EQU	$2C8
                        	
                        	TS_NONE			EQU		0
                        	TS_READY		EQU		1
                        	TS_DEAD			EQU		2
                        	TS_MSGRDY		EQU		4
                        	TS_WAITMSG	EQU		8
                        	TS_RUNNING	EQU		128
                        	
                        	; error codes
                        	E_Ok		=		0x00
                        	E_Arg		=		0x01
                        	E_BadMbx	=		0x04
                        	E_QueFull	=		0x05
                        	E_NoThread	=		0x06
                        	E_NotAlloc	=		0x09
                        	E_NoMsg		=		0x0b
                        	E_Timeout	=		0x10
                        	E_BadAlarm	=		0x11
                        	E_NotOwner	=		0x12
                        	E_QueStrategy =		0x13
                        	E_BadDevNum	=		0x18
                        	E_DCBInUse	=		0x19
                        	; Device driver errors
                        	E_BadDevNum	=		0x20
                        	E_NoDev		=		0x21
                        	E_BadDevOp	=		0x22
                        	E_ReadError	=		0x23
                        	E_WriteError =		0x24
                        	E_BadBlockNum	=	0x25
                        	E_TooManyBlocks	=	0x26
                        	
                        	; resource errors
                        	E_NoMoreMbx	=		0x40
                        	E_NoMoreMsgBlks	=	0x41
                        	E_NoMoreAlarmBlks	=0x44
                        	E_NoMoreTCBs	=	0x45
                        	E_NoMem		= 12
                        	
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "../fmtk/config.asm",1
                        	.file "../fmtk/config.asm",1
                        	MAX_TID		EQU		15
                        	NR_TCB		EQU		16
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	
                        	BS					equ		$08
                        	LF					equ		$0A
                        	CR					equ		$0D
                        	XON					equ		$11
                        	XOFF				equ		$13
                        	DEL					equ		$7F
                        	VIA					equ		$FFDC0600
                        	VIA_PA			equ		$04
                        	VIA_DDRA		equ		$0C
                        	VIA_T1CL		equ		$10
                        	VIA_T1CH		equ		$14
                        	VIA_ACR			equ		$2C
                        	VIA_PCR			equ		$30
                        	VIA_IFR			equ		$34
                        	VIA_PARAW		equ		$3C
                        	UART				equ		$FFDC0A00
                        	UART_TRB		equ		$00
                        	UART_STAT		equ		$04
                        	UART_CMD		equ		$08
                        			; First 16kB is for TCB's
                        	INBUF				equ		$4100
                        	switchflag	equ		$4200
                        	milliseconds	equ		$4208
                        	
                        	
                        	.file "cs01rom.asm",28
                        			code	18 bits
                        	;------------------------------------------------------------------------------
                        	; Exception vector table.
                        	;------------------------------------------------------------------------------
                        			org		$FFFC0000				; user mode exception
FFFC0000 7680006F			jmp		IRQRout
FFFC0004 00000000			org 	$FFFC00C0				; machine mode exception
FFFC0008 00000000
FFFC000C 00000000
FFFC0010 00000000
FFFC0014 00000000
FFFC0018 00000000
FFFC001C 00000000
FFFC0020 00000000
FFFC0024 00000000
FFFC0028 00000000
FFFC002C 00000000
FFFC0030 00000000
FFFC0034 00000000
FFFC0038 00000000
FFFC003C 00000000
FFFC0040 00000000
FFFC0044 00000000
FFFC0048 00000000
FFFC004C 00000000
FFFC0050 00000000
FFFC0054 00000000
FFFC0058 00000000
FFFC005C 00000000
FFFC0060 00000000
FFFC0064 00000000
FFFC0068 00000000
FFFC006C 00000000
FFFC0070 00000000
FFFC0074 00000000
FFFC0078 00000000
FFFC007C 00000000
FFFC0080 00000000
FFFC0084 00000000
FFFC0088 00000000
FFFC008C 00000000
FFFC0090 00000000
FFFC0094 00000000
FFFC0098 00000000
FFFC009C 00000000
FFFC00A0 00000000
FFFC00A4 00000000
FFFC00A8 00000000
FFFC00AC 00000000
FFFC00B0 00000000
FFFC00B4 00000000
FFFC00B8 00000000
FFFC00BC 00000000
FFFC00C0 6A80006F			jmp		IRQRout
FFFC00C4 00000000			org		$FFFC00FC				; non-maskable interrupt
FFFC00C8 00000000
FFFC00CC 00000000
FFFC00D0 00000000
FFFC00D4 00000000
FFFC00D8 00000000
FFFC00DC 00000000
FFFC00E0 00000000
FFFC00E4 00000000
FFFC00E8 00000000
FFFC00EC 00000000
FFFC00F0 00000000
FFFC00F4 00000000
FFFC00F8 00000000
FFFC00FC 0040006F			jmp		MachineStart
                        	
                        	;------------------------------------------------------------------------------
                        	; User mode code starts here
                        	;------------------------------------------------------------------------------
                        			org		$FFFC0100
                        	MachineStart:
FFFC0100 00080737			ldi		$sp,#$80000-4		; setup machine mode stack pointer
FFFC0104 FFC70713
FFFC0108 3B9000EF			call	MMUInit					; initialize MMU for address space zero.
FFFC010C 609000EF			call	FMTKInit
FFFC0110 FFFC0D37			ldi		$t0,#$FFFC0000
FFFC0114 000D0D13
FFFC0118 301D1073			csrrw $x0,#$301,$t0		; set tvec
FFFC011C FFFC0D37			ldi		$t0,#UserStart
FFFC0120 12CD0D13
FFFC0124 341D1073			csrrw	$x0,#$341,$t0		; set mepc
FFFC0128 10000073			eret									; switch to user mode
                        	UserStart:
FFFC012C 00080737			ldi		$sp,#$80000-1028		; setup user mode stack pointer
FFFC0130 BFC70713
FFFC0134 4E4000EF			call	VIAInit
FFFC0138 00806D13			ldi		$t0,#$08						; turn on the LED
FFFC013C FFDC0637			sw		$t0,VIA+VIA_PARAW
FFFC0140 63C60613
FFFC0144 00060633
FFFC0148 01A62023
FFFC014C 5D8000EF			call	SerialInit
FFFC0150 01006E13			ldi		$t2,#16							; send an XON just in case
FFFC0154 01106913			ldi		$a0,#XON
                        	.0004:
FFFC0158 55C000EF			call	SerialPutChar
FFFC015C FFFE0E13			sub		$t2,$t2,#1
FFFC0160 FE0E1CE3			bne		$t2,$x0,.0004
                        	.0002:
FFFC0164 FFFC1937			ldi		$a0,#msgStart				; spit out a startup message
FFFC0168 80C90913
FFFC016C 584000EF			call	SerialPutString
FFFC0170 00106913			ldi		a0,#1
FFFC0174 00C06993			ldi		a1,#12
FFFC0178 FFFC0A37			ldi		a2,#Monitor
FFFC017C 1D4A0A13
FFFC0180 00000073			ecall
FFFC0184 04000463			bra		MonEntry
                        	
                        			; Now a loop to recieve and echo back characters
                        	.0003:
FFFC0188 4F8000EF			call	SerialPeekChar
FFFC018C FE084EE3			blt		$v0,$x0,.0003
FFFC0190 00086933			mov		$a0,$v0
FFFC0194 520000EF			call	SerialPutChar
FFFC0198 FE0008E3			bra		.0003
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	Getch:
FFFC019C FFC70713			sub		$sp,$sp,#4
FFFC01A0 00172023			sw		$ra,[$sp]
FFFC01A4 4DC000EF			call	SerialPeekChar
FFFC01A8 00072083			lw		$ra,[$sp]
FFFC01AC 00470713			add		$sp,$sp,#4
FFFC01B0 00008067			ret
                        	
                        	Putch:
FFFC01B4 FFC70713			sub		$sp,$sp,#4
FFFC01B8 00172023			sw		$ra,[$sp]
FFFC01BC 4F8000EF			call	SerialPutChar
FFFC01C0 00072083			lw		$ra,[$sp]
FFFC01C4 00470713			add		$sp,$sp,#4
FFFC01C8 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	MonEntry:
                        	;		flw			$f2,fltTen
                        	;		fsw			$f2,f2Save
                        	;		flw			$f1,fltTen
                        	;		fsw			$f1,f1Save
                        	;		fadd		$f18,$f2,$f1
                        	;		fsw			$f18,f18Save
FFFC01CC 00A06913			ldi		$a0,#10
FFFC01D0 00606A13			ldi		$a2,#6
                        	;		call	fltToString
                        	;		ldi		$a0,#STRTMP
                        	;		call	SerialPutString
                        	
                        	Monitor:
FFFC01D4 00006213			ldi		$s1,#0					; s1 = input pointer
FFFC01D8 00D06913			ldi		$a0,#CR
FFFC01DC FD9FF0EF			call	Putch
FFFC01E0 00006913			ldi		$a0,#LF
		call	Putch
FFFC01E4 FD1FF0EF
FFFC01E8 03E06913			ldi		$a0,#'>'
FFFC01EC FC9FF0EF			call	Putch
                        	.0001:
FFFC01F0 FADFF0EF			call	Getch						; wait until character pressed
FFFC01F4 FE084EE3			blt		$v0,$x0,.0001
FFFC01F8 00084D13			xor		$t0,$v0,#LF			; ignore line feed
		beq		$t0,$x0,.procLine
FFFC01FC 0E0D0463
FFFC0200 00D84D13			xor		$t0,$v0,#CR
FFFC0204 0E0D0063			beq		$t0,$x0,.procLine
FFFC0208 00884D13			xor		$t0,$v0,#BS
FFFC020C 060D0E63			beq		$t0,$x0,.doBackspace
FFFC0210 07F84D13			xor		$t0,$v0,#DEL
FFFC0214 020D0263			beq		$t0,$x0,.doDelete
FFFC0218 00004637			sb		$v0,INBUF[$s1]
FFFC021C 10060613
FFFC0220 00460633
FFFC0224 01060023
FFFC0228 00120213			add		$s1,$s1,#1
FFFC022C 00086933			mov		$a0,$v0
FFFC0230 F85FF0EF			call	Putch
FFFC0234 FA000EE3			bra		.0001
                        	.doDelete:
FFFC0238 000262B3			mov		$s2,$s1
FFFC023C 00128293			add		$s2,$s2,#1
                        	.0002:
FFFC0240 00004637			lb		$t0,INBUF[$s2]
FFFC0244 10060613
FFFC0248 00560633
FFFC024C 00060D03
FFFC0250 00004637			sb		$t0,INBUF-1[$s2]
FFFC0254 0FF60613
FFFC0258 00560633
FFFC025C 01A60023
FFFC0260 00128293			add		$s2,$s2,#1
FFFC0264 00004637			add		$t0,$s2,#INBUF
FFFC0268 00560D33
FFFC026C 00004637			slt		$t0,$t0,#INBUF+$7F
FFFC0270 FC0D18E3			bne		$t0,$x0,.0002
FFFC0274 00004637			sb		$x0,INBUF[$s2]
FFFC0278 10060613
FFFC027C 00560633
FFFC0280 00060023
FFFC0284 F60006E3			bra		.0001
                        	.doBackspace:
FFFC0288 F60204E3			beq		$s1,$x0,.0001		; can't backspace anymore
FFFC028C 00086933			mov		$a0,$v0					; show the backspace
FFFC0290 F25FF0EF			call	Putch
FFFC0294 FFF20213			sub		$s1,$s1,#1
FFFC0298 000262B3			mov		$s2,$s1
                        	.0003:
FFFC029C 00004637			lb		$t0,INBUF+1[$s2]
FFFC02A0 10160613
FFFC02A4 00560633
FFFC02A8 00060D03
FFFC02AC 00004637			sb		$t0,INBUF[$s2]
FFFC02B0 10060613
FFFC02B4 00560633
FFFC02B8 01A60023
FFFC02BC 00128293			add		$s2,$s2,#1
FFFC02C0 00004637			add		$t0,$s2,#INBUF
FFFC02C4 00560D33
FFFC02C8 00004637			slt		$t0,$t0,#INBUF+$7F
FFFC02CC FC0D18E3			bne		$t0,$x0,.0003
FFFC02D0 00004637			sb		$x0,INBUF[$s2]
FFFC02D4 10060613
FFFC02D8 00560633
FFFC02DC 00060023
FFFC02E0 F00008E3			bra		.0001
                        	.procLine:
FFFC02E4 00004637			sb		$x0,INBUF[$s1]
FFFC02E8 10060613
FFFC02EC 00460633
FFFC02F0 00060023
FFFC02F4 00006213			ldi		$s1,#0
                        	.skip:
FFFC02F8 00004637			lb		$t0,INBUF[$s1]
FFFC02FC 10060613
FFFC0300 00460633
FFFC0304 00060D03
FFFC0308 0C0D0A63			beq		$t0,$x0,.0005
FFFC030C 03ED4D93			xor		$t1,$t0,#'>'
FFFC0310 000D9663			bne		$t1,$x0,.0004
                        	.skip2:
FFFC0314 00120213			add		$s1,$s1,#1
FFFC0318 FE0000E3			bra		.skip
                        	.0004:
FFFC031C 020D4D93			xor		$t1,$t0,#' '
FFFC0320 FE0D8AE3			beq		$t1,$x0,.skip2
FFFC0324 009D4D93			xor		$t1,$t0,#'\t'
FFFC0328 FE0D86E3			beq		$t1,$x0,.skip2
FFFC032C 04DD4D93			xor		$t1,$t0,#'M'
FFFC0330 0A0D8863			beq		$t1,$x0,doMem
FFFC0334 04206D93			ldi		$t1,#'B'
FFFC0338 05BD1463			bne		$t0,$t1,.0006
FFFC033C 00106913			ldi		$a0,#1					; Start task
FFFC0340 01006993			ldi		$a1,#16					; 32 kB (16 pages)
FFFC0344 FFFC2A37			ldi		$a2,#CSTART			; start address
FFFC0348 030A0A13
FFFC034C 00000073			ecall
FFFC0350 00096233			mov		$s1,$a0					; save a0
FFFC0354 FFFC1937			ldi		$a0,#msgCRLF
FFFC0358 8D290913
FFFC035C 394000EF			call	SerialPutString
FFFC0360 00026933			mov		$a0,$s1					; get back a0
FFFC0364 254000EF			call	PutHexByte
FFFC0368 FFFC1937			ldi		$a0,msgTaskStart
FFFC036C 8C490913
FFFC0370 380000EF			call	SerialPutString
FFFC0374 00D06913			ldi		$a0,#13					; Reschedule task
FFFC0378 00000073			ecall
FFFC037C E59FF06F			jmp		Monitor
                        	.0006:
FFFC0380 04406D93			ldi		$t1,#'D'
FFFC0384 01BD1863			bne		$t0,$t1,.0007
FFFC0388 00E06913			ldi		$a0,#14
FFFC038C 00000073			ecall
FFFC0390 E45FF06F			jmp		Monitor
                        	.0007:
FFFC0394 04506D93			ldi		$t1,#'E'
FFFC0398 01BD1463			bne		$t0,$t1,.0008
FFFC039C 0CC0006F			jmp		EditMem
                        	.0008:
FFFC03A0 04606D93			ldi		$t1,#'F'
FFFC03A4 01BD1463			bne		$t0,$t1,.0009
FFFC03A8 0D80006F			jmp		FillMem
                        	.0009:
FFFC03AC 05306D93			ldi		$t1,#'S'
FFFC03B0 01BD1863			bne		$t0,$t1,.0010
FFFC03B4 00D06913			ldi		$a0,#13
FFFC03B8 00000073			ecall
FFFC03BC E19FF06F			jmp		Monitor
                        	.0010:
FFFC03C0 04B06D93			ldi		$t1,#'K'
FFFC03C4 01BD1C63			bne		$t0,$t1,.0011
FFFC03C8 110000EF			call	GetHexNum
FFFC03CC 00306913			ldi		$a0,#3					; kill task
FFFC03D0 000869B3			mov		$a1,$v0					; a0 = pid
FFFC03D4 00000073			ecall
FFFC03D8 DFDFF06F			jmp		Monitor
                        	.0011:
                        	.0005:
FFFC03DC DE000CE3			bra		Monitor
                        	
                        	doMem:
FFFC03E0 FFC70713			sub		$sp,$sp,#4
FFFC03E4 00120213			add		$s1,$s1,#1
FFFC03E8 00472023			sw		$s1,[$sp]
FFFC03EC 00D06913			ldi		$a0,#CR
FFFC03F0 DC5FF0EF			call	Putch
FFFC03F4 00004937			ldi		$a0,INBUF
FFFC03F8 10090913
FFFC03FC 2F4000EF			call	SerialPutString
FFFC0400 00072203			lw		$s1,[$sp]
FFFC0404 00470713			add		$sp,$sp,#4
FFFC0408 0D0000EF			call	GetHexNum
FFFC040C 00086333			mov		$s3,$v0
FFFC0410 00120213			add		$s1,$s1,#1
FFFC0414 0C4000EF			call	GetHexNum
FFFC0418 006803B3			add		$s4,$v0,$s3
                        	.loop2:
FFFC041C D81FF0EF			call	Getch						; check for ctrl-c
FFFC0420 00384813			xor		$v0,$v0,#3
FFFC0424 DA0808E3			beq		$v0,$x0,Monitor
FFFC0428 00D06913			ldi		$a0,#CR
FFFC042C D89FF0EF			call	Putch
FFFC0430 00036933			mov		$a0,$s3
FFFC0434 144000EF			call	PutHexWord
FFFC0438 03A06913			ldi		$a0,#':'
FFFC043C D79FF0EF			call	Putch
FFFC0440 00706293			ldi		$s2,#7
                        	.loop:
FFFC0444 02006913			ldi		$a0,#' '
FFFC0448 D6DFF0EF			call	Putch
FFFC044C 00030903			lb		$a0,[$s3]
FFFC0450 168000EF			call	PutHexByte
FFFC0454 00130313			add		$s3,$s3,#1
FFFC0458 FFF28293			sub		$s2,$s2,#1
FFFC045C FE02D4E3			bge		$s2,$x0,.loop
FFFC0460 FA736EE3			bltu	$s3,$s4,.loop2
FFFC0464 D60008E3			bra		Monitor		
                        	
                        	EditMem:
FFFC0468 070000EF			call	GetHexNum			; get address to edit
FFFC046C 00086333			mov		$s3,$v0
FFFC0470 00120213			add		$s1,$s1,#1
FFFC0474 064000EF			call	GetHexNum			; get value to set
FFFC0478 00680023			sb		$s3,[$v0]			; update mem
FFFC047C D59FF06F			jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	;	>F 1000 800 EE
                        	; Fills memory beginning at address $1000 for $800 bytes with the value $EE
                        	;------------------------------------------------------------------------------
                        	
                        	FillMem:
FFFC0480 058000EF			call	GetHexNum			; get address
FFFC0484 00086333			mov		$s3,$v0
FFFC0488 00120213			add		$s1,$s1,#1
FFFC048C 04C000EF			call	GetHexNum			; get length
FFFC0490 000863B3			mov		$s4,$v0
FFFC0494 00120213			add		$s1,$s1,#1
FFFC0498 040000EF			call	GetHexNum			; get byte to use
                        	.0001:
FFFC049C 01030023			sb		$v0,[$s3]
FFFC04A0 FFF38393			sub		$s4,$s4,#1
FFFC04A4 FE704CE3			bgt		$s4,$x0,.0001
FFFC04A8 D2DFF06F			jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; Skip over spaces and tabs in the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	SkipSpaces:
                        	.skip2:
FFFC04AC 00004637			lb		$t0,INBUF[$s1]
FFFC04B0 10060613
FFFC04B4 00460633
FFFC04B8 00060D03
FFFC04BC 020D4D93			xor		$t1,$t0,#' '
FFFC04C0 000D8863			beq		$t1,$x0,.skip1
FFFC04C4 009D4D93			xor		$t1,$t0,#'\t'
FFFC04C8 000D8463			beq		$t1,$x0,.skip1
FFFC04CC 00008067			ret
                        	.skip1:
FFFC04D0 00120213			add		$s1,$s1,#1
FFFC04D4 FC000CE3			bra		.skip2
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a hex number from the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	GetHexNum:
FFFC04D8 00006813			ldi		$v0,#0							; v0 = num
FFFC04DC FFC70713			sub		$sp,$sp,#4
FFFC04E0 00172023			sw		$ra,[$sp]
FFFC04E4 FC9FF0EF			call	SkipSpaces
                        	.next:
FFFC04E8 00004637			lb		$t0,INBUF[$s1]
FFFC04EC 10060613
FFFC04F0 00460633
FFFC04F4 00060D03
FFFC04F8 03006E13			ldi		$t2,#'0'
FFFC04FC 03CD4663			blt		$t0,$t2,.0001
FFFC0500 03A06E13			ldi		$t2,#'9'+1
FFFC0504 07CD4063			blt		$t0,$t2,.isDigit
FFFC0508 04106E13			ldi		$t2,#'A'
FFFC050C 01CD4E63			blt		$t0,$t2,.0001
FFFC0510 04706E13			ldi		$t2,#'F'+1
FFFC0514 03CD4063			blt		$t0,$t2,.isHexUpper
FFFC0518 06106E13			ldi		$t2,#'a'
FFFC051C 01CD4663			blt		$t0,$t2,.0001
FFFC0520 06706E13			ldi		$t2,#'f'+1
FFFC0524 03CD4463			blt		$t0,$t2,.isHexLower
                        	.0001:
FFFC0528 00072083			lw		$ra,[$sp]
FFFC052C 00470713			add		$sp,$sp,#4
FFFC0530 00008067			ret
                        	.isHexUpper:
FFFC0534 00481813			sll		$v0,$v0,#4
FFFC0538 FBFD0D13			sub		$t0,$t0,#'A'
FFFC053C 00AD0D13			add		$t0,$t0,#10
FFFC0540 01A86833			or		$v0,$v0,$t0
FFFC0544 00120213			add		$s1,$s1,#1
FFFC0548 FA0000E3			bra		.next
                        	.isHexLower:
FFFC054C 00481813			sll		$v0,$v0,#4
FFFC0550 F9FD0D13			sub		$t0,$t0,#'a'
FFFC0554 00AD0D13			add		$t0,$t0,#10
FFFC0558 01A86833			or		$v0,$v0,$t0
FFFC055C 00120213			add		$s1,$s1,#1
FFFC0560 F80004E3			bra		.next
                        	.isDigit:
FFFC0564 00481813			sll		$v0,$v0,#4
FFFC0568 FD0D0D13			sub		$t0,$t0,#'0'
FFFC056C 01A86833			or		$v0,$v0,$t0
FFFC0570 00120213			add		$s1,$s1,#1
FFFC0574 F6000AE3			bra		.next
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a word as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexWord:
FFFC0578 FF870713			sub		$sp,$sp,#8
FFFC057C 00172023			sw		$ra,[$sp]
FFFC0580 01272223			sw		$a0,4[$sp]
FFFC0584 01095913			srl		$a0,$a0,#16
FFFC0588 010000EF			call	PutHexHalf
FFFC058C 00072083			lw		$ra,[$sp]
FFFC0590 00472903			lw		$a0,4[$sp]
FFFC0594 00870713			add		$sp,$sp,#8	; fall through to PutHexHalf
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a half-word (16 bits) as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexHalf:
FFFC0598 FF870713			sub		$sp,$sp,#8
FFFC059C 00172023			sw		$ra,[$sp]
FFFC05A0 01272223			sw		$a0,4[$sp]
FFFC05A4 00895913			srl		$a0,$a0,#8
FFFC05A8 010000EF			call	PutHexByte
FFFC05AC 00072083			lw		$ra,[$sp]
FFFC05B0 00472903			lw		$a0,4[$sp]		
FFFC05B4 00870713			add		$sp,$sp,#8	; fall through to PutHexByte
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a byte as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexByte:
FFFC05B8 FF870713			sub		$sp,$sp,#8
FFFC05BC 00172023			sw		$ra,[$sp]
FFFC05C0 01272223			sw		$a0,4[$sp]
FFFC05C4 00495913			srl		$a0,$a0,#4		; put the high order nybble first
FFFC05C8 010000EF			call	PutHexNybble
FFFC05CC 00072083			lw		$ra,[$sp]
FFFC05D0 00472903			lw		$a0,4[$sp]
FFFC05D4 00870713			add		$sp,$sp,#8		; fall through to PutHexNybble
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a nybble as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexNybble:
FFFC05D8 FF870713			sub		$sp,$sp,#8
FFFC05DC 00172023			sw		$ra,[$sp]
FFFC05E0 01272223			sw		$a0,4[$sp]
FFFC05E4 00F97913			and		$a0,$a0,#15		; strip off high order bits
FFFC05E8 00A06D13			ldi		$t0,#10
FFFC05EC 01A94A63			blt		$a0,$t0,.lt10
FFFC05F0 FF690913			sub		$a0,$a0,#10
FFFC05F4 04190913			add		$a0,$a0,#'A'
FFFC05F8 BBDFF0EF			call	Putch
FFFC05FC 00000663			bra		.0001
                        	.lt10:
FFFC0600 03090913			add		$a0,$a0,#'0'
FFFC0604 BB1FF0EF			call	Putch
                        	.0001:
FFFC0608 00072083			lw		$ra,[$sp]
FFFC060C 00472903			lw		$a0,4[$sp]
FFFC0610 00870713			add		$sp,$sp,#8
FFFC0614 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; VIAInit
                        	;
                        	; Initialize the versatile interface adapter.
                        	;------------------------------------------------------------------------------
                        	
                        	VIAInit:
                        			; Initialize port A low order eight bits as output, the remaining bits as
                        			; input.
FFFC0618 0FF06D13			ldi		$t0,#$000000FF
FFFC061C FFDC0637			sw		$t0,VIA+VIA_DDRA
FFFC0620 60C60613
FFFC0624 00060633
FFFC0628 01A62023
FFFC062C 00106D13			ldi		$t0,#1							; select timer 3 access
FFFC0630 FFDC0637			sb		$t0,VIA+VIA_PCR+1
FFFC0634 63160613
FFFC0638 00060633
FFFC063C 01A60023
FFFC0640 01F06D13			ldi		$t0,#$1F
FFFC0644 FFDC0637			sb		$t0,VIA+VIA_ACR+1		; set timer 3 mode, timer 1/2 = 64 bit
FFFC0648 62D60613
FFFC064C 00060633
FFFC0650 01A60023
FFFC0654 00197D37			ldi		$t0,#$00196E6B			;	divider value for 30Hz
FFFC0658 E6BD0D13
FFFC065C FFDC0637			sw		$t0,VIA+VIA_T1CL
FFFC0660 61060613
FFFC0664 00060633
FFFC0668 01A62023
FFFC066C FFDC0637			sw		$x0,VIA+VIA_T1CH		; trigger transfer to count registers
FFFC0670 61460613
FFFC0674 00060633
FFFC0678 00062023
FFFC067C 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPeekChar
                        	;
                        	; Check the serial port status to see if there's a char available. If there's
                        	; a char available then return it.
                        	;
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$v0 = character or -1
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPeekChar:
FFFC0680 FFDC1637			lb		$v0,UART+UART_STAT
FFFC0684 A0460613
FFFC0688 00060633
FFFC068C 00060803
FFFC0690 00887813			and		$v0,$v0,#8					; look for Rx not empty
FFFC0694 00080C63			beq		$v0,$x0,.0001
FFFC0698 FFDC1637			lb		$v0,UART+UART_TRB
FFFC069C A0060613
FFFC06A0 00060633
FFFC06A4 00060803
FFFC06A8 00008067			ret
                        	.0001:
FFFC06AC FFF06813			ldi		$v0,#-1
FFFC06B0 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPutChar
                        	;    Put a character to the serial transmitter. This routine blocks until the
                        	; transmitter is empty.
                        	;
                        	; Parameters:
                        	;		$a0 = character to put
                        	; Modifies:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPutChar:
FFFC06B4 FFC70713			sub		$sp,$sp,#4
FFFC06B8 01072023			sw		$v0,[$sp]
                        	.0001:
FFFC06BC FFDC1637			lb		$v0,UART+UART_STAT	; wait until the uart indicates tx empty
FFFC06C0 A0460613
FFFC06C4 00060633
FFFC06C8 00060803
FFFC06CC 01087813			and		$v0,$v0,#16					; bit #4 of the status reg
FFFC06D0 FE0806E3			beq		$v0,$x0,.0001				; branch if transmitter is not empty
FFFC06D4 FFDC1637			sb		$a0,UART+UART_TRB		; send the byte
FFFC06D8 A0060613
FFFC06DC 00060633
FFFC06E0 01260023
FFFC06E4 00072803			lw		$v0,[$sp]
FFFC06E8 00470713			add		$sp,$sp,#4
FFFC06EC 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPutString
                        	;    Put a string of characters to the serial transmitter. Calls the 
                        	; SerialPutChar routine, so this routine also blocks if the transmitter is not
                        	; empty.
                        	;
                        	; Parameters:
                        	;		$a0 = pointer to null terminated string to put
                        	; Modifies:
                        	;		$t0 and $t1
                        	; Stack Space:
                        	;		2 words
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPutString:
FFFC06F0 FF870713			sub		$sp,$sp,#8				; save link register
FFFC06F4 00172023			sw		$ra,[$sp]
FFFC06F8 01272223			sw		$a0,4[$sp]				; and argument
FFFC06FC 00096DB3			mov		$t1,$a0						; t1 = pointer to string
                        	.0001:
FFFC0700 000D8903			lb		$a0,[$t1]
FFFC0704 001D8D93			add		$t1,$t1,#1				; advance pointer to next byte
FFFC0708 00090663			beq		$a0,$x0,.done			; branch if done
FFFC070C FA9FF0EF			call	SerialPutChar			; output character
FFFC0710 FE0008E3			bra		.0001
                        	.done:
FFFC0714 00072083			lw		$ra,[$sp]					; restore return address
FFFC0718 00472903			lw		$a0,4[$sp]				; and argument
FFFC071C 00870713			add		$sp,$sp,#8
FFFC0720 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Initialize serial port.
                        	;
                        	; Modifies:
                        	;		$t0
                        	;------------------------------------------------------------------------------
                        	
                        	SerialInit:
FFFC0724 00B06D13			ldi		$t0,#$0B						; dtr,rts active, rxint disabled, no parity
FFFC0728 FFDC1637			sw		$t0,UART+8
FFFC072C A0860613
FFFC0730 00060633
FFFC0734 01A62023
FFFC0738 00060D37			ldi		$t0,#$0006001E			; reset the fifo's
FFFC073C 01ED0D13
FFFC0740 FFDC1637			sw		$t0,UART+12
FFFC0744 A0C60613
FFFC0748 00060633
FFFC074C 01A62023
FFFC0750 01E06D13			ldi		$t0,#$0000001E			; baud 9600, 1 stop bit, 8 bit, internal baud gen
FFFC0754 FFDC1637			sw		$t0,UART+12
FFFC0758 A0C60613
FFFC075C 00060633
FFFC0760 01A62023
FFFC0764 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Exception processing code starts here.
                        	;------------------------------------------------------------------------------
                        	.file "cs01rom.asm",541
                        			code
                        			align	4                        	
                        	IRQRout:
FFFC0768 00080737			ldi		$sp,#$80000-4		; setup machine mode stack pointer
FFFC076C FFC70713
FFFC0770 34201D73			csrrw	$t0,#$342,$x0			; get cause code
FFFC0774 000D4663			blt		$t0,$x0,.isIRQ		; irq or ecall?
FFFC0778 7090006F			jmp		OSCALL					; 
FFFC077C 10000073			eret										
                        	.isIRQ:
                        	 		; Was it the VIA that caused the interrupt?
FFFC0780 FFDC0637			lb		$t0,VIA+VIA_IFR
FFFC0784 63460613
FFFC0788 00060633
FFFC078C 00060D03
FFFC0790 040D5663			bge		$t0,$x0,.0001			; no
FFFC0794 FFDC0637			lw		$t0,VIA+VIA_T1CL	; yes, clear interrupt
FFFC0798 61060613
FFFC079C 00060633
FFFC07A0 00062D03
FFFC07A4 00004637			lw		$t0,milliseconds
FFFC07A8 20860613
FFFC07AC 00060633
FFFC07B0 00062D03
FFFC07B4 01ED0D13			add		$t0,$t0,#30
FFFC07B8 00004637			sw		$t0,milliseconds
FFFC07BC 20860613
FFFC07C0 00060633
FFFC07C4 01A62023
FFFC07C8 00004637			sw		$t0,switchflag
FFFC07CC 20060613
FFFC07D0 00060633
FFFC07D4 01A62023
FFFC07D8 10000073			eret
                        			; Was it the uart that caused the interrupt?
                        	.0001:
FFFC07DC FFDC1637			lb		$t0,UART+UART_STAT
FFFC07E0 A0460613
FFFC07E4 00060633
FFFC07E8 00060D03
FFFC07EC 000D4463			blt		$t0,$x0,.0002			; uart cause interrupt?
                        			; Some other interrupt
FFFC07F0 10000073			eret
                        	.0002:
FFFC07F4 00B06D13			ldi		$t0,#$0B						; dtr,rts active, rxint disabled, no parity
FFFC07F8 FFDC1637			sw		$t0,UART+UART_CMD
FFFC07FC A0860613
FFFC0800 00060633
FFFC0804 01A62023
FFFC0808 10000073			eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Message strings
                        	;------------------------------------------------------------------------------
                        	
                        	msgStart:
FFFC080C 31305343			db		"CS01 System Starting.",13
FFFC0810 73795320
FFFC0814 206D6574
FFFC0818 72617453
FFFC081C 676E6974
FFFC0820 6F4D0D2E
                        	msgMonHelp:
FFFC0822 696E6F4D			db		"Monitor Commands",13
FFFC0826 20726F74
FFFC082A 6D6D6F43
FFFC082E 73646E61
FFFC0832 2D20420D
FFFC0833 202D2042			db		"B - start tiny basic",13
FFFC0837 72617473
FFFC083B 69742074
FFFC083F 6220796E
FFFC0843 63697361
FFFC0847 2D20440D
FFFC0848 202D2044			db		"D - dump ready que",13
FFFC084C 706D7564
FFFC0850 61657220
FFFC0854 71207964
FFFC0858 450D6575
FFFC085B 202D2045			db		"E - edit memory",13
FFFC085F 74696465
FFFC0863 6D656D20
FFFC0867 0D79726F
FFFC086B 202D2046			db		"F - fill memory",13
FFFC086F 6C6C6966
FFFC0873 6D656D20
FFFC0877 0D79726F
FFFC087B 743C204B			db		"K <tid> - kill task", 13
FFFC087F 203E6469
FFFC0883 696B202D
FFFC0887 74206C6C
FFFC088B 0D6B7361
FFFC088F 733C204D			db		"M <start> <length>	- dump memory",13
FFFC0893 74726174
FFFC0897 6C3C203E
FFFC089B 74676E65
FFFC089F 2D093E68
FFFC08A3 6D756420
FFFC08A7 656D2070
FFFC08AB 79726F6D
FFFC08AF 2D20530D
FFFC08B0 202D2053			db		"S - switch task",13
FFFC08B4 74697773
FFFC08B8 74206863
FFFC08BC 0D6B7361
FFFC08C0 00000000			db		0
FFFC08C1 20000000			align 
                        	
                        	msgTaskStart:
FFFC08C4 73617420			db		" task started."
FFFC08C8 7473206B
FFFC08CC 65747261
FFFC08D0 0A0D2E64
                        	msgCRLF:
FFFC08D2 00000A0D			db		13,10,0
                        	flt50:
FFFC08D5 00000000		dw	0x00000000,0x00000000,0x00000000,0x40049000
FFFC08D9 00000000
FFFC08DD 00000000
FFFC08E1 40049000
                        	flt20:
FFFC08E5 00000000		dw	0x00000000,0x00000000,0x00000000,0x40034000
FFFC08E9 00000000
FFFC08ED 00000000
FFFC08F1 40034000
                        	flt10:
FFFC08F5 00000000		dw	0x00000000,0x00000000,0x00000000,0x40024000
FFFC08F9 00000000
FFFC08FD 00000000
FFFC0901 40024000
                        	
                        	.file "fltToString.asm",1
                        	.file "fltToString.asm",1
                        	STRTMP		equ		$0200
                        	
                        	; -----------------------------------------------------------------------------
                        	;		$fa0 = number to convert (f18)
                        	;		$a1	= width
                        	;		$a2 = precision
                        	;		$a3 = E
                        	;		$t2 = ndx
                        	;		$s9 = exp
                        	; -----------------------------------------------------------------------------
                        	
                        	fltToString:
FFFC0905 006E1300			ldi		$t2,#0				; $t2 = 0
FFFC0909 09095300
FFFC090A E0090953			fmv		$a0,$f18
FFFC090E 7F800637			and		$t0,$a0,#$7F800000
FFFC0912 01267D33
FFFC0916 7F800DB7			ldi		$t1,#$7F800000
FFFC091A 000D8D93
FFFC091E 05BD1063			bne		$t0,$t1,.0001
FFFC0922 00800637			and		$t0,$a0,#$007FFFFF
FFFC0926 01267D33
FFFC092A 000D0E63			beq		$t0,$x0,.inf
FFFC092E FFFC1637			ldt		$t0,msgNan
FFFC0932 CB060613
FFFC0936 00060633
FFFC093A 00062D03
FFFC093E 21A02023			stt		$t0,STRTMP
FFFC0942 2E000A63			bra		.prt
                        	.inf:
FFFC0946 FFFC1637			ldt		$t0,msgInf
FFFC094A CAC60613
FFFC094E 00060633
FFFC0952 00062D03
FFFC0956 21A02023			stt		$t0,STRTMP
FFFC095A 2C000E63			bra		.prt
                        	.0001:
FFFC095E 80000637			and		$t0,$a0,#$80000000
FFFC0962 01267D33
FFFC0966 000D0C63			beq		$t0,$x0,.pos
FFFC096A 02D06D13			ldi		$t0,#'-'
FFFC096E 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0972 001E0E13			add		$t2,$t2,#1
FFFC0976 80000637			and		$a0,$a0,#$7FFFFFFF
FFFC097A 01267933
                        	.pos:
FFFC097E 00091A63			bne		$a0,$x0,.notZero
FFFC0982 03006D13			ldi		$t0,#'0'
FFFC0986 21AE0023			stb		$t0,STRTMP[$t2]
FFFC098A 200E00A3			stb		$x0,STRTMP+1[$t2]
FFFC098E 2A000463			bra		.prt		
                        	.notZero:
FFFC0992 00006633			mov		$s9,$x0			; exp = 0.0
                        	;	// Make a small number > 0 so we can get at the digits.
                        	;	if (dbl < 1.0) {
                        	;		while (dbl < 1.0) {
                        	;			dbl *= 1000000.0;
                        	;			exp -= 6;  
                        	;		}
                        	;	}
FFFC0996 FFFC1637			flw		$f3,fltOne
FFFC099A CB460613
FFFC099E 00060633
FFFC09A2 00062187
FFFC09A6 F0090053			fmv		$f0,$a0
FFFC09AA A0391D53			flt		$t0,$f18,$f3
FFFC09AE 020D0463			beq		$t0,$x0,.0002
FFFC09B2 FFFC1637			flw		$f4,fltMillion
FFFC09B6 CBC60613
FFFC09BA 00060633
FFFC09BE 00062207
                        	.0003:
FFFC09C2 A0391D53			flt		$t0,$f18,$f3
FFFC09C6 000D0863			beq		$t0,$x0,.0002
FFFC09CA 10490953			fmul	$f18,$f18,$f4
FFFC09CE FFA60613			sub		$s9,$s9,#6
FFFC09D2 FE0008E3			bra		.0003
                        	.0002:
                        	;	// The following is similar to using log10() and pow() functions.
                        	;	// Now dbl is >= 1.0
                        	;	// Create a number dbl2 on the same order of magnitude as dbl, but
                        	;	// less than dbl.
                        	;	dbl2 = 1.0;
                        	;	dbla = dbl2;
                        	;	if (dbl > dbl2) {	// dbl > 1.0 ?
                        	;		while (dbl2 <= dbl) {
                        	;			dbla = dbl2;
                        	;			dbl2 *= 10.0;	// increase power of 10
                        	;			exp++;
                        	;		}
                        	;		// The above loop goes one too far, we want the last value less
                        	;		// than dbl.
                        	;		dbl2 = dbla;
                        	;		exp--;
                        	;	}
FFFC09D6 FFFC1637			flw		$f1,fltOne				; $f1 = dbl2 = 1.0
FFFC09DA CB460613
FFFC09DE 00060633
FFFC09E2 00062087
FFFC09E6 38008153			fmov	$f2,$f1						; $f2 = dbla = dbl2
FFFC09EA A1209D53			flt		$t0,$f1,$f18				; if (dbl2 < dbl)
FFFC09EE 020D0A63			beq		$t0,$x0,.0004
FFFC09F2 FFFC1637			flw		$f5,fltTen				; $f5 = 10.0
FFFC09F6 CB860613
FFFC09FA 00060633
FFFC09FE 00062287
                        	.0006:
FFFC0A02 A1208D53			fle		$t0,$f1,$f18				; while ($f1 <= $f18)
FFFC0A06 000D0A63			beq		$t0,$x0,.0005
FFFC0A0A 38008153			fmov	$f2,$f1						; dbla = dbl2
FFFC0A0E 105080D3			fmul	$f1,$f1,$f5				; dbl2 *= 10.0
FFFC0A12 00160613			add		$s9,$s9,#1				; exp++;
FFFC0A16 FE0006E3			bra		.0006
                        	.0005:
FFFC0A1A 380100D3			fmov	$f1,$f2						; dbl2 = dbla
FFFC0A1E FFF60613			sub		$s9,$s9,#1				; exp--;
                        	.0004:
                        	;	// For small constants < 1000000 try and spit out a whole number
                        	;    if (exp >= 0 && exp < 6) {
                        	;        digits_before_decpt = exp+1;
                        	;		exp = 0;
                        	;	}
                        	;	else if (exp >= -6)
                        	;		digits_before_decpt = 1;
                        	;	else
                        	;		digits_before_decpt = -1;
FFFC0A22 00064E63			blt		$s9,$x0,.0007
FFFC0A26 00606413			ldi		$s5,#6
FFFC0A2A 00865A63			bge		$s9,$s5,.0007
FFFC0A2E FFFFE233			mov		$s1,#s0						; s1 = digits before decpt
FFFC0A32 00120213			add		$s1,$s1,#1
FFFC0A36 00006613			ldi		$s9,#0						; exp = 0
FFFC0A3A 00000C63			bra		.0008
                        	.0007:
FFFC0A3E FF906413			ldi		$s5,#-7
FFFC0A42 00864663			blt		$s9,$s5,.0009
FFFC0A46 00106213			ldi		$s1,#1
FFFC0A4A 00000463			bra		.0008
                        	.0009:
FFFC0A4E FFF06213			ldi		$s1,#-1
                        	.0008:
                        	;	// Spit out a leading zero before the decimal point for a small number.
                        	;    if (exp < -6) {
                        	;		buf[ndx] = '0';
                        	;		ndx++;
                        	;        buf[ndx] = '.';
                        	;        ndx++;
                        	;    }
FFFC0A52 FFA06413			ldi		$s5,#-6
FFFC0A56 00865E63			bge		$s9,$s5,.0010
FFFC0A5A 03006D13			ldi		$t0,#'0'
FFFC0A5E 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0A62 001E0E13			add		$t2,$t2,#1
FFFC0A66 02E06D13			ldi		$t0,#'.'
FFFC0A6A 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0A6E 001E0E13			add		$t2,$t2,#1
                        	.0010:
                        	;	// Now loop processing one digit at a time.
                        	;    for (nn = 0; nn < 30 && precision > 0; nn++) {
                        	;        digit = 0;
                        	;		dbla = dbl;
                        	;		// dbl is on the same order of magnitude as dbl2 so
                        	;		// a repeated subtract can be used to find the digit.
                        	;        while (dbl >= dbl2) {
                        	;            dbl -= dbl2;
                        	;            digit++;
                        	;        }
                        	;        buf[ndx] = digit + '0';
                        	;		// Now go back and perform just a single subtract and
                        	;		// a multiply to find out how much to reduce dbl by.
                        	;		// This should improve the accuracy
                        	;		if (digit > 2)
                        	;			dbl = dbla - dbl2 * digit;
                        	;        ndx++;
                        	;        digits_before_decpt--;
                        	;        if (digits_before_decpt==0) {
                        	;           buf[ndx] = '.';
                        	;           ndx++;
                        	;        }
                        	;        else if (digits_before_decpt < 0)
                        	;            precision--;
                        	;		// Shift the next digit to be tested into position.
                        	;        dbl *= 10.0;
                        	;    }
FFFC0A72 00006313			ldi		$s3,#0						; s3 = nn = 0
FFFC0A76 01E06413			ldi		$s5,#30
FFFC0A7A FFFC1637			flw		$f7,fltTen				; f7 = 10.0
FFFC0A7E CB860613
FFFC0A82 00060633
FFFC0A86 00062387
                        	.0016:
FFFC0A8A 00832D33			slt		$t0,$s3,$s5
FFFC0A8E 060D0863			beq		$t0,$x0,.0011
FFFC0A92 00006413			ldi		$s5,#0
FFFC0A96 07445463			bge		$s5,$a2,.0011			; (0 < precision)
FFFC0A9A 00006393			ldi		$s4,#0						; s4 = digit = 0
FFFC0A9E 38090153			fmov	$f2,$f18						; dbla = dbl
                        	.0013:
FFFC0AA2 A1208D53			fle		$t0,$f1,$f18						; while (dbl2 <= dbl)
FFFC0AA6 000D0863			beq		$t0,$x0,.0012
FFFC0AAA 08190953			fsub	$f18,$f18,$f1						; dbl -= dbl2
FFFC0AAE 00138393			add		$s4,$s4,#1						; digit++
FFFC0AB2 FE0008E3			bra		.0013
                        	.0012:
FFFC0AB6 03038413			add		$s5,$s4,#'0'			; buf[ndx] = digit + '0'
FFFC0ABA 208E0023			stb		$s5,STRTMP[$t2]
FFFC0ABE 00206413			ldi		$s5,#2						; if (2 < digit)
FFFC0AC2 00745863			bge		$s5,$s4,.0014
FFFC0AC6 D00382D3			fcvt.s.w	$f5,$s4				; f5 = digit as float
FFFC0ACA 10508353			fmul	$f6,$f1,$f5				; f6 = dbl2 * digit
FFFC0ACE 08610953			fsub	$f18,$f2,$f6				; dbl = dbla - dbl2 * digit
                        	.0014:
FFFC0AD2 001E0E13			add		$t2,$t2,#1				; ndx++
FFFC0AD6 FFF20213			sub		$s1,$s1,#1				; digits_before_decpt--;
FFFC0ADA 00021A63			bne		$s1,$x0,.0015			; if (digits_before_decpt==0)
FFFC0ADE 02E06D13			ldi		$t0,#'.'
FFFC0AE2 21AE0023			stb		$t0,STRTMP[$t2]		; buf[ndx] = '.'
FFFC0AE6 001E0E13			add		$t2,$t2,#1				; ndx++
FFFC0AEA 00000663			bra		.0017
                        	.0015:
FFFC0AEE 00025463			bge		$s1,$x0,.0017			; else if (digits_before_decpt < 0)
FFFC0AF2 FFFA0A13			sub		$a2,$a2,#1				; 	precision--
                        	.0017:
FFFC0AF6 10790953			fmul	$f18,$f18,$f7				; dbl *= 10.0
FFFC0AFA F80008E3			bra		.0016
                        	.0011:
                        	;	// Trim trailing zeros from the number
                        	;    do {
                        	;        ndx--;
                        	;    } while(buf[ndx]=='0');
                        	;    ndx++;
                        	.0018:
FFFC0AFE FFFE0E13			sub		$t2,$t2,#1				; ndx--
FFFC0B02 200E0D03			ldb		$t0,STRTMP[$t2]
FFFC0B06 030D4D13			xor		$t0,$t0,#'0'
FFFC0B0A FE0D0AE3			beq		$t0,$x0,.0018
FFFC0B0E 001E0E13			add		$t2,$t2,#1				; ndx++
                        	;	// Make sure we have at least one digit after the decimal point.
                        	;	if (buf[ndx]=='.') {
                        	;		ndx++;
                        	;		buf[ndx]='0';
                        	;		ndx++;
                        	;        buf[ndx]='\0';
                        	;	}
FFFC0B12 200E0D03			ldb		$t0,STRTMP[$t2]
FFFC0B16 02ED4D13			xor		$t0,$t0,#'.'
FFFC0B1A 000D1C63			bne		$t0,$x0,.0019
FFFC0B1E 001E0E13			add		$t2,$t2,#1
FFFC0B22 03006D13			ldi		$t0,#'0'
FFFC0B26 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0B2A 001E0E13			add		$t2,$t2,#1
FFFC0B2E 200E0023			stb		$x0,STRTMP[$t2]
                        	.0019:
                        	;	// If the number is times 10^0 don't output the exponent
                        	;   if (exp==0) {
                        	;        buf[ndx]='\0';
                        	;        goto prt;
                        	;    }
FFFC0B32 00061663			bne		$s9,$x0,.0020
FFFC0B36 200E0023			stb		$x0,STRTMP[$t2]
FFFC0B3A 0E000E63			bra		.prt
                        	.0020:
                        	;	// Spit out +/-E
                        	;    buf[ndx] = E;
                        	;    ndx++;
                        	;    if (exp < 0) {
                        	;        buf[ndx]='-';
                        	;        ndx++;
                        	;        exp = -exp;
                        	;    }
                        	;    else {
                        	;         buf[ndx]='+';
                        	;         ndx++;
                        	;    }
FFFC0B3E 04506D13			ldi		$t0,#'E'
FFFC0B42 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0B46 001E0E13			add		$t2,$t2,#1
FFFC0B4A 00065C63			bge		$s9,$x0,.0021
FFFC0B4E 02D06D13			ldi		$t0,#'-'
FFFC0B52 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0B56 001E0E13			add		$t2,$t2,#1
FFFC0B5A 40C00633			sub		$s9,$x0,$s9			; exp = -exp
FFFC0B5E 00000863			bra		.0022
                        	.0021:
FFFC0B62 02B06D13			ldi		$t0,#'+'
FFFC0B66 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0B6A 001E0E13			add		$t2,$t2,#1
                        	.0022:
                        	;	// now process the exponent
                        	;    digit = 0;
                        	;    while (exp >= 1000) {
                        	;        exp -= 1000;
                        	;        digit++;
                        	;    }
FFFC0B6E 00006393			ldi		$s4,#0
FFFC0B72 3E806D13			ldi		$t0,#1000
                        	.0025:
FFFC0B76 01A65463			bge		$s9,$t0,.0023
FFFC0B7A 00000863			bra		.0024
                        	.0023:
FFFC0B7E 41A60633			sub		$s9,$s9,$t0
FFFC0B82 00138393			add		$s4,$s4,#1
FFFC0B86 FE0008E3			bra		.0025
                        	.0024:
                        	;	d1 = digit;
                        	;	if (digit) {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0B8A 0003E4B3			mov		$s6,$s4					; s6 = d1 = s4 = digit
FFFC0B8E 00039863			bne		$s4,$x0,.0026
FFFC0B92 03038D13			add		$t0,$s4,#'0'
FFFC0B96 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0B9A 001E0E13			add		$t2,$t2,#1
                        	.0026:
                        	;	digit = 0;
                        	;    while (exp >= 100) {
                        	;        exp -= 100;
                        	;        digit++;
                        	;    }
FFFC0B9E 00006393			ldi		$s4,#0
FFFC0BA2 06406D13			ldi		$t0,#100
                        	.0027:
FFFC0BA6 01A65463			bge		$s9,$t0,.0028
FFFC0BAA 00000863			bra		.0029
                        	.0028:
FFFC0BAE 41A60633			sub		$s9,$s9,$t0
FFFC0BB2 00138393			add		$s4,$s4,#1
FFFC0BB6 FE0008E3			bra		.0027
                        	.0029:	
                        	;	d2 = digit;
                        	;	if (digit==0 && d1==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0BBA 0003E533			mov		$s7,$s4				; $s7 = d2
FFFC0BBE 00049463			bne		$s6,$x0,.0030
FFFC0BC2 00038863			beq		$s4,$x0,.0031
                        	.0030:
FFFC0BC6 03038D13			add		$t0,$s4,#'0'
FFFC0BCA 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0BCE 001E0E13			add		$t2,$t2,#1
                        	.0031:
                        	;	digit = 0;
                        	;    while (exp >= 10) {
                        	;        exp -= 10;
                        	;        digit++;
                        	;    }
FFFC0BD2 00006393			ldi		$s4,#0
FFFC0BD6 00A06D13			ldi		$t0,#10
                        	.0032:
FFFC0BDA 01A65463			bge		$s9,$t0,.0034
FFFC0BDE 00000863			bra		.0035
                        	.0034:
FFFC0BE2 41A60633			sub		$s9,$s9,$t0
FFFC0BE6 00138393			add		$s4,$s4,#1
FFFC0BEA FE0008E3			bra		.0032
                        	.0035:	
                        	;	d3 = digit;
                        	;	if (digit==0 && d1==0 && d2==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0BEE 0003E5B3			mov		$s8,$s4
FFFC0BF2 00039663			bne		$s4,$x0,.0036
FFFC0BF6 00049463			bne		$s6,$x0,.0036
FFFC0BFA 00050863			beq		$s7,$x0,.0037
                        	.0036:
FFFC0BFE 03038D13			add		$t0,$s4,#'0'
FFFC0C02 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0C06 001E0E13			add		$t2,$t2,#1
                        	.0037:
                        	;	digit = 0;
                        	;    while (exp >= 1) {
                        	;        exp -= 1;
                        	;        digit++;
                        	;    }
FFFC0C0A 00006393			ldi		$s4,#0
FFFC0C0E 00106D13			ldi		$t0,#1
                        	.0038:
FFFC0C12 01A65463			bge		$s9,$t0,.0040
FFFC0C16 00000863			bra		.0039
                        	.0040:
FFFC0C1A 41A60633			sub		$s9,$s9,$t0
FFFC0C1E 00138393			add		$s4,$s4,#1
FFFC0C22 FE0008E3			bra		.0038
                        	.0039:	
                        	;    buf[ndx] = digit + '0';
                        	;    ndx++;
                        	;    buf[ndx] = '\0';
FFFC0C26 03038D13			add		$t0,$s4,#'0'
FFFC0C2A 21AE0023			sb		$t0,STRTMP[$t2]
FFFC0C2E 001E0E13			add		$t2,$t2,#1
FFFC0C32 200E0023			sb		$x0,STRTMP[$t2]
                        	;	// Now pad the number on the left or right as requested.
                        	.prt:
                        	;    // pad left
                        	;    if (width > 0) {
                        	;        if (ndx < width) {
                        	;            for (nn = 39; nn >= width-ndx; nn--)
                        	;                buf[nn] = buf[nn-(width-ndx)];
                        	;            for (; nn >= 0; nn--)
                        	;                buf[nn] = ' ';
                        	;        }
                        	;    }
FFFC0C36 0409C663			blt		$a1,$x0,.0041
FFFC0C3A 04098463			beq		$a1,$x0,.0041
FFFC0C3E 013E4463			blt		$t2,$a1,.0042
FFFC0C42 04000063			bra		.0041
                        	.0042:
FFFC0C46 02706313			ldi		$s3,#39					; s3 = nn
FFFC0C4A 41C98D33			sub		$t0,$a1,$t2			; width-ndx
                        	.0045:
FFFC0C4E 01A35463			bge		$s3,$t0,.0043
FFFC0C52 00000C63			bra		.0044
                        	.0043:
FFFC0C56 41A304B3			sub		$s6,$s3,$t0			; nn-(width-ndx)
FFFC0C5A 20030D83			ldb		$t1,STRTMP[$s3]
FFFC0C5E 21B48023			stb		$t1,STRTMP[$s6]
FFFC0C62 FFF30313			sub		$s3,$s3,#1
FFFC0C66 FE0004E3			bra		.0045
                        	.0044:
FFFC0C6A 02006D13			ldi		$t0,#' '
                        	.0048:
FFFC0C6E 00035463			bge		$s3,$x0,.0046
FFFC0C72 00000863			bra		.0047
                        	.0046:
FFFC0C76 21A30023			stb		$t0,STRTMP[$s3]
FFFC0C7A FFF30313			sub		$s3,$s3,#1
FFFC0C7E FE0008E3			bra		.0048
                        	.0047:
                        	.0041:
                        	;    // pad right
                        	;    if (width < 0) {
                        	;        width = -width;
                        	;        while (ndx < width) {
                        	;            buf[ndx]=' ';
                        	;            ndx++;
                        	;        }
                        	;        buf[ndx]='\0';
                        	;    }
                        	;    return (ndx);
FFFC0C82 0209D063			bge		$a1,$x0,.0050
FFFC0C86 413009B3			sub		$a1,$x0,$a1
FFFC0C8A 02006D13			ldi		$t0,#' '
                        	.0052:
FFFC0C8E 013E5863			bge		$t2,$a1,.0051
FFFC0C92 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0C96 001E0E13			add		$t2,$t2,#1
FFFC0C9A FE000AE3			bra		.0052
                        	.0051:
FFFC0C9E 200E0023			stb		$x0,STRTMP[$t2]
                        	.0050:
FFFC0CA2 000E6833			mov		$v0,$t2
FFFC0CA6 00008067			ret
                        	
FFFC0CAA 6E490000			align	
                        	
                        	msgInf:
FFFC0CAC 00666E49			db	"Inf",0
                        	msgNan:
FFFC0CB0 006E614E			db	"Nan",0
                        	fltOne:
FFFC0CB4 3F800000			dw		$3F800000					; 1.0
                        	fltTen:
FFFC0CB8 41200000			dw		$41200000					; 10.0
                        	fltMillion:
FFFC0CBC 49742400			dw		$49742400					; 1,000,000
                        	
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "cs01Mem.asm",1
                        	.file "cs01Mem.asm",1
                        	NPAGES	equ		$4300
                        	
                        	.file "cs01Mem.asm",4
                        			code	18 bits
                        			align	4                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	MMUInit:
FFFC0CC0 0F606D13			ldi		$t0,#246				; set number of available pages (10 pages already allocated)
FFFC0CC4 00004637			sw		$t0,NPAGES			
FFFC0CC8 30060613
FFFC0CCC 00060633
FFFC0CD0 01A62023
FFFC0CD4 00001E37			ldi		$t2,#4096				; number of registers to update
FFFC0CD8 000E0E13
FFFC0CDC 00006D13			ldi		$t0,#$00
FFFC0CE0 00006D93			ldi		$t1,#$000				; regno
                        	.0001:
FFFC0CE4 03BD000D			mvmap	$x0,$t0,$t1
FFFC0CE8 001D0D13			add		$t0,$t0,#$01		; increment page numbers
FFFC0CEC 001D8D93			add		$t1,$t1,#$01
FFFC0CF0 FFFE0E13			sub		$t2,$t2,#1
FFFC0CF4 FE0E18E3			bne		$t2,$x0,.0001
                        			; Now setup segment registers
FFFC0CF8 00006D13			ldi		$t0,#$0
FFFC0CFC 00706D93			ldi		$t1,#$07				; t1 = value to load RWX=111, base = 0
                        	.0002:
FFFC0D00 01AD800D			mvseg	$x0,$t1,$t0			; move to the segment register identifed by t0
FFFC0D04 001D0D13			add		$t0,$t0,#1			; pick next segment register
FFFC0D08 010D2E13			slt		$t2,$t0,#16			; 16 segment regs
FFFC0D0C FE0E1AE3			bne		$t2,$x0,.0002
FFFC0D10 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Find a run of buckets available for mapping virtual to physical addresses.
                        	; The buckets searched are for the current address space, identified by the
                        	; ASID.
                        	;
                        	; Parameters:
                        	;		a0 = pid
                        	;		a1 = number of pages required.
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		v0 = starting bucket number (includes ASID)
                        	;------------------------------------------------------------------------------
                        	
                        	FindRun:
FFFC0D14 00F97E93		and			$t3,$a0,#$0F			; t3 = pid
FFFC0D18 008E9E93		sll			$t3,$t3,#8				; shift into usable position
FFFC0D1C 00006D93		ldi			$t1,#0						; t1 = count of consecutive empty buckets
FFFC0D20 000EEE33		mov			$t2,$t3						; t2 = map entry number
FFFC0D24 0FF06F93		ldi			$t5,#255					; max number of pages - 1
FFFC0D28 01DFEFB3		or			$t5,$t5,$t3				; t5 = max in ASID
                        	.0001:
FFFC0D2C 03C0080D		mvmap		$v0,$x0,$t2				; get map entry into v0
FFFC0D30 00080A63		beq			$v0,$x0,.empty0		; is it empty?
FFFC0D34 001E0E13		add			$t2,$t2,#1
FFFC0D38 FFFE6AE3		bltu		$t2,$t5,.0001
FFFC0D3C 00006833		mov			$v0,$x0						; got here so no run was found
FFFC0D40 00008067		ret
                        	.empty0:
FFFC0D44 000E6EB3		mov			$t3,$t2						; save first empty bucket
                        	.empty1:
FFFC0D48 001D8D93		add			$t1,$t1,#1
FFFC0D4C 013DFC63		bgeu		$t1,$a1,.foundEnough
FFFC0D50 001E0E13		add			$t2,$t2,#1				; next bucket
FFFC0D54 03C0080D		mvmap		$v0,$x0,$t2				; get map entry
FFFC0D58 FE0808E3		beq			$v0,$x0,.empty1
FFFC0D5C 00006DB3		mov			$t1,$x0						; reset counter
FFFC0D60 FC0006E3		bra			.0001							; go back and find another run
                        	.foundEnough:
FFFC0D64 000EE833		mov			$v0,$t3						; v0 = start of run
FFFC0D68 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = pid
                        	;		a1 = amount of memory to allocate
                        	; Modifies:
                        	;		t0
                        	; Returns:
                        	;		v0 = pointer to allocated memory in virtual address space.
                        	;		v1 = 1 for success, 0 otherwise
                        	;------------------------------------------------------------------------------
                        	;
                        	Alloc:
FFFC0D6C FF070713		sub			$sp,$sp,#16
FFFC0D70 00172023		sw			$ra,[$sp]
FFFC0D74 00472223		sw			$s1,4[$sp]				; these regs must be saved
FFFC0D78 00572423		sw			$s2,8[$sp]
FFFC0D7C 00672623		sw			$s3,12[$sp]
                        		; First check if there are enough pages available in the system.
FFFC0D80 7FF98813		add			$v0,$a1,#2047			; v0 = round memory request
FFFC0D84 00B85813		srl			$v0,$v0,#11				; v0 = convert to pages required
FFFC0D88 00004637		lw			$t0,NPAGES				; check number of pages available
FFFC0D8C 30060613
FFFC0D90 00060633
FFFC0D94 00062D03
FFFC0D98 010D7663		bleu		$v0,$t0,.enough
                        	.noRun2:
FFFC0D9C 00006893		ldi			$v1,#0						; not enough, return null
FFFC0DA0 06000063		bra			.noRun
                        	.enough:
                        		; There are enough pages, but is there a run long enough in map space?
FFFC0DA4 00502023		sw			$s2,$v0				; save required # pages
FFFC0DA8 000869B3		mov			$a1,$v0
FFFC0DAC F69FF0EF		call		FindRun						; find a run of available slots
FFFC0DB0 FE0806E3		beq			$v0,$x0,.noRun2
                        		; Now there are enough pages, and a run available, so allocate
FFFC0DB4 00086233		mov			$s1,$v0						; s1 = start of run
FFFC0DB8 00004637		lw			$s3,NPAGES				; decrease number of pages available in system
FFFC0DBC 30060613
FFFC0DC0 00060633
FFFC0DC4 00062303
FFFC0DC8 40530333		sub			$s3,$s3,$s2
FFFC0DCC 00004637		sw			$s3,NPAGES
FFFC0DD0 30060613
FFFC0DD4 00060633
FFFC0DD8 00662023
FFFC0DDC 00086333		mov			$s3,$v0						; s3 = start of run
                        	.0001:
FFFC0DE0 0000180D		palloc	$v0								; allocate a page (cheat and use hardware)
FFFC0DE4 00080E63		beq			$v0,$x0,.noRun
FFFC0DE8 0268000D		mvmap		$x0,$v0,$s3				; map the page
FFFC0DEC 00130313		add			$s3,$s3,#1				; next bucket
FFFC0DF0 FFF28293		sub			$s2,$s2,#1
FFFC0DF4 FE0296E3		bne			$s2,$x0,.0001
FFFC0DF8 00B21813		sll			$v0,$s1,#11				; v0 = virtual address of allocated mem.
FFFC0DFC 00106893		ldi			$v1,#1
                        	.noRun:
FFFC0E00 00072083		lw			$ra,[$sp]					; restore saved regs
FFFC0E04 00472203		lw			s1,4[$sp]
FFFC0E08 00872283		lw			s2,8[$sp]
FFFC0E0C 00C72303		lw			s3,12[$sp]
FFFC0E10 01070713		add			$sp,$sp,#16
FFFC0E14 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Allocate the stack page for a task. The stack is located at the highest
                        	; virtual address ($7F800).
                        	;
                        	; Parameters:
                        	;		a0 = pid to allocate for
                        	;	Returns:
                        	;		v0 = physical address, 0 if unsuccessful
                        	;		v1 = virtual address, not valid unless successful
                        	;------------------------------------------------------------------------------
                        	;
                        	AllocStack:
FFFC0E18 00891893		sll			$v1,$a0,#8			; 
FFFC0E1C 0FF8E893		or			$v1,$v1,#255		; last page of memory is for stack
FFFC0E20 0310080D		mvmap		$v0,$x0,$v1			; check if stack already allocated
FFFC0E24 00081863		bne			$v0,$x0,.0001
FFFC0E28 0000180D		palloc	$v0							; allocate a page
FFFC0E2C 00080A63		beq			$v0,$x0,.xit		; success?
FFFC0E30 0318000D		mvmap		$x0,$v0,$v1
                        	.0001:
FFFC0E34 0FF8F893		and			$v1,$v1,#255
FFFC0E38 00B81813		sll			$v0,$v0,#11			; convert pages to addresses
FFFC0E3C 00B89893		sll			$v1,$v1,#11
                        	.xit:
FFFC0E40 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; This routine will de-allocate all the pages associated with a task including
                        	; the stack.
                        	;
                        	; Parameters:
                        	;		a0 = pid to free memory for
                        	;	Modifies:
                        	;		t0,t1,t3,t4
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	FreeAll:
FFFC0E44 00006E93		ldi			$t3,#0
FFFC0E48 00891F13		sll			$t4,$a0,#8
                        	.nxt:
FFFC0E4C 100EAD93		slt			$t1,$t3,#256		; number of buckets to check
FFFC0E50 040D8863		beq			$t1,$x0,.0001
FFFC0E54 00001637		and			$t4,$t4,#$F00
FFFC0E58 01E67F33
FFFC0E5C 01DF6F33		or			$t4,$t4,$t3			; combine pid and bucket number
FFFC0E60 00006D13		ldi			$t0,#0					; new page number to set (indicates free)
FFFC0E64 03ED0D0D		mvmap		$t0,$t0,$t4			; get page mapping and set to zero
FFFC0E68 001E8E93		add			$t3,$t3,#1			; advance to next bucket
FFFC0E6C 0FFD7D13		and			$t0,$t0,#255		; pages are 1-255
FFFC0E70 FC0D0EE3		beq			$t0,$x0,.nxt		; 0 = no map in this bucket
FFFC0E74 020D100D		pfree		$t0							; free the page
FFFC0E78 00004637		lw			$t0,NPAGES			; update the number of available pages
FFFC0E7C 30060613
FFFC0E80 00060633
FFFC0E84 00062D03
FFFC0E88 001D0D13		add			$t0,$t0,#1
FFFC0E8C 00004637		sw			$t0,NPAGES
FFFC0E90 30060613
FFFC0E94 00060633
FFFC0E98 01A62023
FFFC0E9C FA0008E3		bra			.nxt
                        	.0001:
FFFC0EA0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Convert a virtual address to a physical one
                        	;
                        	; Parameters:
                        	;		a0 = virtual address to convert
                        	; Modifies:
                        	;		t0
                        	; Returns:
                        	;		v0 = physcial address
                        	;------------------------------------------------------------------------------
                        	
                        	VirtToPhys:
FFFC0EA4 30001873		csrrw	$v0,#$300,$x0				; get tid
FFFC0EA8 01685813		srl		$v0,$v0,#22					; extract
FFFC0EAC 00F87813		and		$v0,$v0,#15
FFFC0EB0 00881813		sll		$v0,$v0,#8
FFFC0EB4 00B95D13		srl		$t0,$a0,#11					; convert virt to page
FFFC0EB8 0FFD7D13		and		$t0,$t0,#255
FFFC0EBC 01A86833		or		$v0,$v0,$t0					; and in tid
FFFC0EC0 0300080D		mvmap	$v0,$x0,$v0					; get the translation
FFFC0EC4 00B81813		sll		$v0,$v0,#11					; convert page to address
FFFC0EC8 7FF97D13		and		$t0,$a0,#$7FF				; insert LSB's
FFFC0ECC 01A86833		or		$v0,$v0,$t0
FFFC0ED0 00008067		ret
                        	
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "../fmtk/task.asm",1
                        	.file "../fmtk/task.asm",1
                        	
                        	QNDX		EQU		$4304
                        	HRDY0		EQU		$4308
                        	HRDY1		EQU		$4309
                        	HRDY2		EQU		$430A
                        	HRDY3		EQU		$430B
                        	TRDY0		EQU		$430C
                        	TRDY1		EQU		$430D
                        	TRDY2		EQU		$430E
                        	TRDY3		EQU		$430F
                        	PIDMAP	EQU		$4310
                        	missed_ticks	equ		$4320
                        	TimeoutList		equ		$4328
                        	Tick		EQU		$4330
                        	RDYQ0		EQU		$4400
                        	RDYQ1		EQU		$4500
                        	RDYQ2		EQU		$4600
                        	RDYQ3		EQU		$4700
                        	
                        		align	2                        	
                        	OSCallTbl:
FFFC0ED4 19A000EA		dh		FMTK_Initialize					; 0
FFFC0ED6 1A5419A0		dh		FMTK_StartTask					; 1
FFFC0ED8 1A601A54		dh		FMTK_ExitTask
FFFC0EDA 00EE1A60		dh		FMTK_KillTask
FFFC0EDC 1D3800EE		dh		FMTK_SetTaskPriority
FFFC0EDE 00F01D38		dh		FMTK_Sleep							; 5
FFFC0EE0 00F100F0		dh		FMTK_AllocMbx
FFFC0EE2 00F200F1		dh		FMTK_FreeMbx
FFFC0EE4 00F300F2		dh		FMTK_PostMsg
FFFC0EE6 00F400F3		dh		FMTK_SendMsg
FFFC0EE8 00F500F4		dh		FMTK_WaitMsg						; 10
FFFC0EEA 00F600F5		dh		FMTK_PeekMsg
FFFC0EEC 16E800F6		dh		FMTK_StartApp
FFFC0EEE 1D6C16E8		dh		FMTK_Reschedule					; 13
FFFC0EF0 00001D6C		dh		DumpReadyQueue
                        	
                        	qToChk:
FFFC0EF2 01000000		db	0,0,0,1,0,0,2,1
FFFC0EF6 01020000
FFFC0EFA 01030000		db	0,0,3,1,0,0,2,1
FFFC0EFE 01020000
FFFC0F02 01000000		db	0,0,0,1,0,0,2,1
FFFC0F06 01020000
FFFC0F0A 01030000		db	0,0,3,1,0,0,2,1
FFFC0F0E 01020000
                        	
FFFC0F12 46370000		align	
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FMTKInit:
FFFC0F14 00004637		sw		$x0,QNDX
FFFC0F18 30460613
FFFC0F1C 00060633
FFFC0F20 00062023
FFFC0F24 00004637		sw		$x0,HRDY0				; reset head and tail indexes
FFFC0F28 30860613
FFFC0F2C 00060633
FFFC0F30 00062023
FFFC0F34 00004637		sw		$x0,TRDY0
FFFC0F38 30C60613
FFFC0F3C 00060633
FFFC0F40 00062023
FFFC0F44 00004637		sw		$x0,PIDMAP
FFFC0F48 31060613
FFFC0F4C 00060633
FFFC0F50 00062023
FFFC0F54 00004637		sw		$x0,missed_ticks
FFFC0F58 32060613
FFFC0F5C 00060633
FFFC0F60 00062023
FFFC0F64 FFF06D13		ldi		$t0,#-1
FFFC0F68 00004637		sw		$t0,TimeoutList
FFFC0F6C 32860613
FFFC0F70 00060633
FFFC0F74 01A62023
FFFC0F78 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Get the task id for the currently running task.
                        	;
                        	; Returns:
                        	;		v0 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	GetCurrentTid:
FFFC0F7C 30001873		csrrw	$v0,#$300,$x0				; get current pid
FFFC0F80 01685813		srl		$v0,$v0,#22					; extract field
FFFC0F84 00F87813		and		$v0,$v0,#15					; mask off extra bits
FFFC0F88 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Insert task into ready queue
                        	;
                        	; Parameters:
                        	;		a0 = tid to insert
                        	; Modifies:
                        	;		v1,t0,t1
                        	; Returns:
                        	;		v0 = 1 for success, 0 if failed
                        	;------------------------------------------------------------------------------
                        	
                        	InsertTask:
FFFC0F8C 00F06893		ldi		$v1,#MAX_TID
FFFC0F90 0728E863		bgtu	$a0,$v1,.badTid
FFFC0F94 00A91D13		sll		$t0,$a0,#10					; compute TCB address
FFFC0F98 288D4883		lbu		$v1,TCBStatus[$t0]	; mark task as ready
FFFC0F9C 0018E893		or		$v1,$v1,#TS_READY
FFFC0FA0 291D0423		sb		$v1,TCBStatus[$t0]
FFFC0FA4 289D4883		lbu		$v1,TCBPriority[$t0]
FFFC0FA8 0038F893		and		$v1,$v1,#3
FFFC0FAC 00004637		lbu		$t0,HRDY0[$v1]
FFFC0FB0 30860613
FFFC0FB4 01160633
FFFC0FB8 00064D03
FFFC0FBC 00004637		lbu		$t1,TRDY0[$v1]			; increment tail pointer
FFFC0FC0 30C60613
FFFC0FC4 01160633
FFFC0FC8 00064D83
FFFC0FCC 001D8D93		add		$t1,$t1,#1
FFFC0FD0 03BD0863		beq		$t0,$t1,.qfull			; test queue full?
FFFC0FD4 00004637		sb		$t1,TRDY0[$v1]			; store it back
FFFC0FD8 30C60613
FFFC0FDC 01160633
FFFC0FE0 01B60023
FFFC0FE4 00889E93		sll		$t3,$v1,#8					; compute t3 = readyq index
FFFC0FE8 00004637		add		$t3,$t3,#RDYQ0
FFFC0FEC 01D60EB3
FFFC0FF0 01DD8E33		add		$t2,$t1,$t3
FFFC0FF4 012E0023		sb		$a0,[$t2]						; store tid of task
FFFC0FF8 00106813		ldi		$v0,#1							; return non-zero
FFFC0FFC 00008067		ret
                        	.badTid:
                        	.qfull:
FFFC1000 00006833		mov		$v0,$x0
FFFC1004 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Select the next task to run. The ready queues are searched in a circular
                        	; fashion beginning with the queue identified indirectly by QNDX. There are
                        	; four ready queues to hold tasks of four different priorities. This routine
                        	; dequeues a task from the ready list, then adds it back if it is still ready.
                        	; This takes care of a lot of scenarios. Such as the task no longer being
                        	; ready, or the priority changing.
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		v1, t0, t1, t2, t3
                        	;	Returns:
                        	;		v0 = task id of task to run
                        	;------------------------------------------------------------------------------
                        	
                        	SelectTaskToRun:
FFFC1008 FFC70713		sub		$sp,$sp,#4					; stack return address
FFFC100C 00172023		sw		$ra,[$sp]
                        		; Pick the first queue to check, occasionally the queue
                        		; chosen isn't the highest priority one in order to 
                        		; prevent starvation of lower priority tasks.
FFFC1010 00004637		lbu		$v1,QNDX						; get index into que check table
FFFC1014 30460613
FFFC1018 00060633
FFFC101C 00064883
FFFC1020 00188893		add		$v1,$v1,#1					; increment it, and limit
FFFC1024 01F8F893		and		$v1,$v1,#31
FFFC1028 00004637		sb		$v1,QNDX						; store back
FFFC102C 30460613
FFFC1030 00060633
FFFC1034 01160023
FFFC1038 FFFC1637		lbu		$v1,qToChk[$v1]			; assume this will be valid
FFFC103C EF260613
FFFC1040 01160633
FFFC1044 00064883
FFFC1048 00406E13		ldi		$t2,#4							; 4 queues to check
                        	.nxtQ:
FFFC104C 00004637		lbu		$t0,HRDY0[$v1]			; check queue to see if contains any
FFFC1050 30860613
FFFC1054 01160633
FFFC1058 00064D03
FFFC105C 00004637		lbu		$t1,TRDY0[$v1]			; ready tasks
FFFC1060 30C60613
FFFC1064 01160633
FFFC1068 00064D83
FFFC106C 01BD1C63		bne		$t0,$t1,.dq					; yes, go dequeue
FFFC1070 00188893		add		$v1,$v1,#1					; no, advance to next queue
FFFC1074 0038F893		and		$v1,$v1,#3					; 4 max
FFFC1078 FFFE0E13		sub		$t2,$t2,#1					;
FFFC107C FDC048E3		bgt		$t2,$x0,.nxtQ				; go back to check next queue
                        		; Here, nothing else is actually ready to run
                        		; just go back to what we were doing.
FFFC1080 EFDFF06F		jmp		GetCurrentTid				; tail recursion here
                        	.dq:
FFFC1084 00889E93		sll		$t3,$v1,#8					; compute t3 = readyq index
FFFC1088 00004637		add		$t3,$t3,#RDYQ0
FFFC108C 01D60EB3
FFFC1090 01DD0E33		add		$t2,$t0,$t3
FFFC1094 000E4803		lbu		$v0,[$t2]						; v0 = pid of ready task
FFFC1098 00F06D13		ldi		$t0,#MAX_TID				; ensure we have a valid tid
FFFC109C 870D7263		bleu	$v0,$t0,.goodTid
                        		; If the tid isn't valid, remove it from the queue and go back
                        		; and check the next queue entry
FFFC10A0 001D0D13		add		$t0,$t0,#1					; advance readyq head
FFFC10A4 0FFD7D13		and		$t0,$t0,#255
FFFC10A8 00004637		sb		$t0,HRDY0[$v1]			; save head pointer
FFFC10AC 30860613
FFFC10B0 01160633
FFFC10B4 01A60023
FFFC10B8 F8000AE3		bra		.nxtQ
                        	.goodtid:
FFFC10BC 001D0D13		add		$t0,$t0,#1					; advance readyq head
FFFC10C0 0FFD7D13		and		$t0,$t0,#255
FFFC10C4 00004637		sb		$t0,HRDY0[$v1]			; save head pointer
FFFC10C8 30860613
FFFC10CC 01160633
FFFC10D0 01A60023
                        		; Now filter out tasks (remove from ready list) that aren't ready to run
FFFC10D4 00A81D13		sll		$t0,$v0,#10					; tid to pointer
FFFC10D8 288D0D03		lb		$t0,TCBStatus[$t0]	; get status
FFFC10DC 001D7D13		and		$t0,$t0,#TS_READY		; is it ready?
FFFC10E0 F60D06E3		beq		$t0,$x0,.nxtQ
                        		; And re-insert task into queue for next time
FFFC10E4 00086933		mov		$a0,$v0
FFFC10E8 EA5FF0EF		call	InsertTask					; could check if insert failed
FFFC10EC 00096833		mov		$v0,$a0							; get back tid
FFFC10F0 00072083		lw		$ra,[$sp]						; restore return address
FFFC10F4 00470713		add		$sp,$sp,#4
FFFC10F8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Swap from outgoing context to incoming context.
                        	;
                        	; Parameters:
                        	;		a0 = pointer to TCB of outgoing context
                        	;		a1 = pointer to TCB of incoming context
                        	;------------------------------------------------------------------------------
                        	
                        	SwapContext:
                        		; Save outgoing register set in TCB
FFFC10FC 0400810D		mfu		$x2,$x1
FFFC1100 00292223		sw		$x2,4[$a0]
FFFC1104 0401010D		mfu		$x2,$x2
FFFC1108 00292423		sw		$x2,8[$a0]
FFFC110C 0401810D		mfu		$x2,$x3
FFFC1110 00292623		sw		$x2,12[$a0]
FFFC1114 0402010D		mfu		$x2,$x4
FFFC1118 00292823		sw		$x2,16[$a0]
FFFC111C 0402810D		mfu		$x2,$x5
FFFC1120 00292A23		sw		$x2,20[$a0]
FFFC1124 0403010D		mfu		$x2,$x6
FFFC1128 00292C23		sw		$x2,24[$a0]
FFFC112C 0403810D		mfu		$x2,$x7
FFFC1130 00292E23		sw		$x2,28[$a0]
FFFC1134 0404010D		mfu		$x2,$x8
FFFC1138 02292023		sw		$x2,32[$a0]
FFFC113C 0404810D		mfu		$x2,$x9
FFFC1140 02292223		sw		$x2,36[$a0]
FFFC1144 0405010D		mfu		$x2,$x10
FFFC1148 02292423		sw		$x2,40[$a0]
FFFC114C 0405810D		mfu		$x2,$x11
FFFC1150 02292623		sw		$x2,44[$a0]
FFFC1154 0406010D		mfu		$x2,$x12
FFFC1158 02292823		sw		$x2,48[$a0]
FFFC115C 0406810D		mfu		$x2,$x13
FFFC1160 02292A23		sw		$x2,52[$a0]
FFFC1164 0407010D		mfu		$x2,$x14
FFFC1168 02292C23		sw		$x2,56[$a0]
FFFC116C 0407810D		mfu		$x2,$x15
FFFC1170 02292E23		sw		$x2,60[$a0]
FFFC1174 0408010D		mfu		$x2,$x16
FFFC1178 04292023		sw		$x2,64[$a0]
FFFC117C 0408810D		mfu		$x2,$x17
FFFC1180 04292223		sw		$x2,68[$a0]
FFFC1184 0409010D		mfu		$x2,$x18
FFFC1188 04292423		sw		$x2,72[$a0]
FFFC118C 0409810D		mfu		$x2,$x19
FFFC1190 04292623		sw		$x2,76[$a0]
FFFC1194 040A010D		mfu		$x2,$x20
FFFC1198 04292823		sw		$x2,80[$a0]
FFFC119C 040A810D		mfu		$x2,$x21
FFFC11A0 04292A23		sw		$x2,84[$a0]
FFFC11A4 040B010D		mfu		$x2,$x22
FFFC11A8 04292C23		sw		$x2,88[$a0]
FFFC11AC 040B810D		mfu		$x2,$x23
FFFC11B0 04292E23		sw		$x2,92[$a0]
FFFC11B4 040C010D		mfu		$x2,$x24
FFFC11B8 06292023		sw		$x2,96[$a0]
FFFC11BC 040C810D		mfu		$x2,$x25
FFFC11C0 06292223		sw		$x2,100[$a0]
FFFC11C4 040D010D		mfu		$x2,$x26
FFFC11C8 06292423		sw		$x2,104[$a0]
FFFC11CC 040D810D		mfu		$x2,$x27
FFFC11D0 06292623		sw		$x2,108[$a0]
FFFC11D4 040E010D		mfu		$x2,$x28
FFFC11D8 06292823		sw		$x2,112[$a0]
FFFC11DC 040E810D		mfu		$x2,$x29
FFFC11E0 06292A23		sw		$x2,116[$a0]
FFFC11E4 040F010D		mfu		$x2,$x30
FFFC11E8 06292C23		sw		$x2,120[$a0]
FFFC11EC 040F810D		mfu		$x2,$x31
FFFC11F0 06292E23		sw		$x2,124[$a0]
FFFC11F4 34101173		csrrw	$x2,#$341,$x0				; save off mepc
FFFC11F8 28292023		sw		$x2,TCBepc[$a0]
                        		; Now save off segment registers
FFFC11FC 00006D93		ldi		$t1,#0
                        	.svseg:
FFFC1200 01B00D0D		mvseg	$t0,$x0,$t1
FFFC1204 002D9113		sll		$x2,$t1,#2
FFFC1208 01210133		add		$x2,$x2,$a0
FFFC120C 21A12023		sw		$t0,TCBsegs[$x2]
FFFC1210 001D8D93		add		$t1,$t1,#1
FFFC1214 00FDFD93		and		$t1,$t1,#15
FFFC1218 FE0D94E3		bne		$t1,$x0,.svseg
                        	
                        		; Switch memory maps
FFFC121C 00A9D813		srl		$v0,$a1,#10					; convert pointer to tid
FFFC1220 00F87813		and		$v0,$v0,#$F					; mask to 16 task
FFFC1224 01681813		sll		$v0,$v0,#22					; shift into position
FFFC1228 300018F3		csrrw	$v1,#$300,$x0				; get status
FFFC122C FC400637		and		$v1,$v1,#$FC3FFFFF	; mask off ASID/PID bits
FFFC1230 011678B3
FFFC1234 0108E8B3		or		$v1,$v1,$v0					; set new ASID
FFFC1238 30089073		csrrw	$x0,#$300,$v1				; save status
                        		; User map has now been switched
                        	
                        		; Restore segment register set
FFFC123C 00006D93		ldi		$t1,#0
                        	.rsseg:
FFFC1240 002D9113		sll		$x2,$t1,#2
FFFC1244 01310133		add		$x2,$x2,$a1
FFFC1248 20012D03		lw		$t0,TCBsegs[$x2]
FFFC124C 01BD000D		mvseg	$x0,$t0,$t1
FFFC1250 001D8D93		add		$t1,$t1,#1
FFFC1254 00FDFD93		and		$t1,$t1,#15
FFFC1258 FE0D94E3		bne		$t1,$x0,.rsseg
                        	
FFFC125C 2809A103		lw		$x2,TCBepc[$a1]			; restore epc
FFFC1260 34111073		csrrw	$x0,#$341,$x2
                        		; Restore incoming registers
FFFC1264 0049A103		lw		$x2,4[$a1]
FFFC1268 0601008D		mtu		$x1,$x2
FFFC126C 0089A103		lw		$x2,8[$a1]
FFFC1270 0601010D		mtu		$x2,$x2
FFFC1274 00C9A103		lw		$x2,12[$a1]
FFFC1278 0601018D		mtu		$x3,$x2
FFFC127C 0109A103		lw		$x2,16[$a1]
FFFC1280 0601020D		mtu		$x4,$x2
FFFC1284 0149A103		lw		$x2,20[$a1]
FFFC1288 0601028D		mtu		$x5,$x2
FFFC128C 0189A103		lw		$x2,24[$a1]
FFFC1290 0601030D		mtu		$x6,$x2
FFFC1294 01C9A103		lw		$x2,28[$a1]
FFFC1298 0601038D		mtu		$x7,$x2
FFFC129C 0209A103		lw		$x2,32[$a1]
FFFC12A0 0601040D		mtu		$x8,$x2
FFFC12A4 0249A103		lw		$x2,36[$a1]
FFFC12A8 0601048D		mtu		$x9,$x2
FFFC12AC 0289A103		lw		$x2,40[$a1]
FFFC12B0 0601050D		mtu		$x10,$x2
FFFC12B4 02C9A103		lw		$x2,44[$a1]
FFFC12B8 0601058D		mtu		$x11,$x2
FFFC12BC 0309A103		lw		$x2,48[$a1]
FFFC12C0 0601060D		mtu		$x12,$x2
FFFC12C4 0349A103		lw		$x2,52[$a1]
FFFC12C8 0601068D		mtu		$x13,$x2
FFFC12CC 0389A103		lw		$x2,56[$a1]
FFFC12D0 0601070D		mtu		$x14,$x2
FFFC12D4 03C9A103		lw		$x2,60[$a1]
FFFC12D8 0601078D		mtu		$x15,$x2
FFFC12DC 0409A103		lw		$x2,64[$a1]
FFFC12E0 0601080D		mtu		$x16,$x2
FFFC12E4 0449A103		lw		$x2,68[$a1]
FFFC12E8 0601088D		mtu		$x17,$x2
FFFC12EC 0489A103		lw		$x2,72[$a1]
FFFC12F0 0601090D		mtu		$x18,$x2
FFFC12F4 04C9A103		lw		$x2,76[$a1]
FFFC12F8 0601098D		mtu		$x19,$x2
FFFC12FC 0509A103		lw		$x2,80[$a1]
FFFC1300 06010A0D		mtu		$x20,$x2
FFFC1304 0549A103		lw		$x2,84[$a1]
FFFC1308 06010A8D		mtu		$x21,$x2
FFFC130C 0589A103		lw		$x2,88[$a1]
FFFC1310 06010B0D		mtu		$x22,$x2
FFFC1314 05C9A103		lw		$x2,92[$a1]
FFFC1318 06010B8D		mtu		$x23,$x2
FFFC131C 0609A103		lw		$x2,96[$a1]
FFFC1320 06010C0D		mtu		$x24,$x2
FFFC1324 0649A103		lw		$x2,100[$a1]
FFFC1328 06010C8D		mtu		$x25,$x2
FFFC132C 0689A103		lw		$x2,104[$a1]
FFFC1330 06010D0D		mtu		$x26,$x2
FFFC1334 06C9A103		lw		$x2,108[$a1]
FFFC1338 06010D8D		mtu		$x27,$x2
FFFC133C 0709A103		lw		$x2,112[$a1]
FFFC1340 06010E0D		mtu		$x28,$x2
FFFC1344 0749A103		lw		$x2,116[$a1]
FFFC1348 06010E8D		mtu		$x29,$x2
FFFC134C 0789A103		lw		$x2,120[$a1]
FFFC1350 06010F0D		mtu		$x30,$x2
FFFC1354 07C9A103		lw		$x2,124[$a1]
FFFC1358 06010F8D		mtu		$x31,$x2
FFFC135C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Switch tasks
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		v0, v1, t0, t1, x1, x2, a0, s1
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	;
                        	FMTK_SwitchTask:
                        		; Save register set in TCB
FFFC1360 300010F3		csrrw	$x1,#$300,$x0			; get process id
FFFC1364 0160D093		srl		$x1,$x1,#22
FFFC1368 00F0F093		and		$x1,$x1,#15
FFFC136C 00A09093		sll		$x1,$x1,#10				; compute TCB address
FFFC1370 0400810D		mfu		$x2,$x1
FFFC1374 0020A223		sw		$x2,4[$x1]
FFFC1378 0401010D		mfu		$x2,$x2
FFFC137C 0020A423		sw		$x2,8[$x1]				; save regs in TCB
FFFC1380 0401810D		mfu		$x2,$x3
FFFC1384 0020A623		sw		$x2,12[$x1]
FFFC1388 0402010D		mfu		$x2,$x4
FFFC138C 0020A823		sw		$x2,16[$x1]
FFFC1390 0402810D		mfu		$x2,$x5
FFFC1394 0020AA23		sw		$x2,20[$x1]
FFFC1398 0403010D		mfu		$x2,$x6
FFFC139C 0020AC23		sw		$x2,24[$x1]
FFFC13A0 0403810D		mfu		$x2,$x7
FFFC13A4 0020AE23		sw		$x2,28[$x1]
FFFC13A8 0404010D		mfu		$x2,$x8
FFFC13AC 0220A023		sw		$x2,32[$x1]
FFFC13B0 0404810D		mfu		$x2,$x9
FFFC13B4 0220A223		sw		$x2,36[$x1]
FFFC13B8 0405010D		mfu		$x2,$x10
FFFC13BC 0220A423		sw		$x2,40[$x1]
FFFC13C0 0405810D		mfu		$x2,$x11
FFFC13C4 0220A623		sw		$x2,44[$x1]
FFFC13C8 0406010D		mfu		$x2,$x12
FFFC13CC 0220A823		sw		$x2,48[$x1]
FFFC13D0 0406810D		mfu		$x2,$x13
FFFC13D4 0220AA23		sw		$x2,52[$x1]
FFFC13D8 0407010D		mfu		$x2,$x14
FFFC13DC 0220AC23		sw		$x2,56[$x1]
FFFC13E0 0407810D		mfu		$x2,$x15
FFFC13E4 0220AE23		sw		$x2,60[$x1]
FFFC13E8 0408010D		mfu		$x2,$x16
FFFC13EC 0420A023		sw		$x2,64[$x1]
FFFC13F0 0408810D		mfu		$x2,$x17
FFFC13F4 0420A223		sw		$x2,68[$x1]
FFFC13F8 0409010D		mfu		$x2,$x18
FFFC13FC 0420A423		sw		$x2,72[$x1]
FFFC1400 0409810D		mfu		$x2,$x19
FFFC1404 0420A623		sw		$x2,76[$x1]
FFFC1408 040A010D		mfu		$x2,$x20
FFFC140C 0420A823		sw		$x2,80[$x1]
FFFC1410 040A810D		mfu		$x2,$x21
FFFC1414 0420AA23		sw		$x2,84[$x1]
FFFC1418 040B010D		mfu		$x2,$x22
FFFC141C 0420AC23		sw		$x2,88[$x1]
FFFC1420 040B810D		mfu		$x2,$x23
FFFC1424 0420AE23		sw		$x2,92[$x1]
FFFC1428 040C010D		mfu		$x2,$x24
FFFC142C 0620A023		sw		$x2,96[$x1]
FFFC1430 040C810D		mfu		$x2,$x25
FFFC1434 0620A223		sw		$x2,100[$x1]
FFFC1438 040D010D		mfu		$x2,$x26
FFFC143C 0620A423		sw		$x2,104[$x1]
FFFC1440 040D810D		mfu		$x2,$x27
FFFC1444 0620A623		sw		$x2,108[$x1]
FFFC1448 040E010D		mfu		$x2,$x28
FFFC144C 0620A823		sw		$x2,112[$x1]
FFFC1450 040E810D		mfu		$x2,$x29
FFFC1454 0620AA23		sw		$x2,116[$x1]
FFFC1458 040F010D		mfu		$x2,$x30
FFFC145C 0620AC23		sw		$x2,120[$x1]
FFFC1460 040F810D		mfu		$x2,$x31
FFFC1464 0620AE23		sw		$x2,124[$x1]
FFFC1468 34101173		csrrw	$x2,#$341,$x0				; save off mepc
FFFC146C 2820A023		sw		$x2,TCBepc[$x1]
FFFC1470 00006D93		ldi		$t1,#0
                        	.svseg:
FFFC1474 01B00D0D		mvseg	$t0,$x0,$t1
FFFC1478 002D9113		sll		$x2,$t1,#2
FFFC147C 00110133		add		$x2,$x2,$x1
FFFC1480 21A12023		sw		$t0,TCBsegs[$x2]
FFFC1484 001D8D93		add		$t1,$t1,#1
FFFC1488 00FDFD93		and		$t1,$t1,#15
FFFC148C FE0D94E3		bne		$t1,$x0,.svseg
                        	
                        	.dead:
FFFC1490 B79FF0EF		call	SelectTaskToRun			; v0 = pid
                        	
                        		; Switch memory maps
FFFC1494 00F87813		and		$v0,$v0,#$F					; mask to 16 task
FFFC1498 01681813		sll		$v0,$v0,#22					; shift into position
FFFC149C 300018F3		csrrw	$v1,#$300,$x0				; get status
FFFC14A0 FC400637		and		$v1,$v1,#$FC3FFFFF	; mask off ASID/PID bits
FFFC14A4 011678B3
FFFC14A8 0108E8B3		or		$v1,$v1,$v0					; set new ASID
FFFC14AC 30089073		csrrw	$x0,#$300,$v1				; save status
                        		; User map has now been switched
FFFC14B0 00C85093		srl		$x1,$v0,#12					; compute incoming TCB address
                        	.0001:
FFFC14B4 28808883		lb		$v1,TCBStatus[$x1]
                        	
                        		; If a message is ready, update status to ready and put
                        		; message in target memory. The task will be returning
                        		; from a WaitMsg so a return status of E_Ok is also set.
FFFC14B8 0048F113		and		$x2,$v1,#TS_MSGRDY
FFFC14BC 08010063		beq		$x2,$x0,.noMsg
FFFC14C0 00086EB3		mov		$t3,$v0							; save off v0 (tid)
FFFC14C4 00106113		ldi		$x2,#TS_READY
FFFC14C8 00000637		sb		$x2,TCB_Status[$x1]
FFFC14CC 10B60613
FFFC14D0 00160633
FFFC14D4 00260023
FFFC14D8 0500A903		lw		$a0,80[$x1]					; user a2 (x20)
FFFC14DC 9C9FF0EF		call	VirtToPhys
FFFC14E0 00000637		lw		$x2,TCB_MsgD1[$x1]
FFFC14E4 10C60613
FFFC14E8 00160633
FFFC14EC 00062103
FFFC14F0 00282023		sw		$x2,[$v0]
FFFC14F4 0540A903		lw		$a0,84[$x1]
FFFC14F8 9ADFF0EF		call	VirtToPhys
FFFC14FC 00000637		lw		$x2,TCB_MsgD2[$x1]
FFFC1500 10D60613
FFFC1504 00160633
FFFC1508 00062103
FFFC150C 00282023		sw		$x2,[$v0]
FFFC1510 0580A903		lw		$a0,88[$x1]
FFFC1514 991FF0EF		call	VirtToPhys
FFFC1518 00000637		lw		$x2,TCB_MsgD3[$x1]
FFFC151C 10E60613
FFFC1520 00160633
FFFC1524 00062103
FFFC1528 00282023		sw		$x2,[$v0]
FFFC152C 00006113		ldi		$x2,#E_Ok						; setup to return E_Ok
FFFC1530 0420A023		sw		$x2,64[$x1]					; in v0
FFFC1534 000EE833		mov		$v0,$t3
FFFC1538 00000A63		bra		.ready
                        	.noMsg:
FFFC153C 0018F113		and		$x2,$v1,#TS_READY
FFFC1540 00011663		bne		$x2,$x0,.ready
FFFC1544 0028F113		and		$x2,$v1,#TS_DEAD
FFFC1548 F40114E3		bne		$x2,$x0,.dead
                        	
                        	.ready:
                        		; Add task back into ready queue
FFFC154C 0000E233		mov		$s1,$x1							; save off x1 (normally return address)
FFFC1550 01685913		srl		$a0,$v0,#22					; compute ASID/PID
FFFC1554 A39FF0EF		call	InsertTask
FFFC1558 000260B3		mov		$x1,$s1							; get back x1
                        	
                        		; Restore register set
FFFC155C 00006D93		ldi		$t1,#0
                        	.rsseg:
FFFC1560 002D9113		sll		$x2,$t1,#2
FFFC1564 00110133		add		$x2,$x2,$x1
FFFC1568 20012D03		lw		$t0,TCBsegs[$x2]
FFFC156C 01BD000D		mvseg	$x0,$t0,$t1
FFFC1570 001D8D93		add		$t1,$t1,#1
FFFC1574 00FDFD93		and		$t1,$t1,#15
FFFC1578 FE0D94E3		bne		$t1,$x0,.rsseg
                        	
FFFC157C 2800A103		lw		$x2,TCBepc[$x1]			; restore epc
FFFC1580 34111073		csrrw	$x0,#$341,$x2
FFFC1584 0040A103		lw		$x2,4[$x1]
FFFC1588 0601008D		mtu		$x1,$x2
FFFC158C 0080A103		lw		$x2,8[$x1]
FFFC1590 0601010D		mtu		$x2,$x2
FFFC1594 00C0A103		lw		$x2,12[$x1]
FFFC1598 0601018D		mtu		$x3,$x2
FFFC159C 0100A103		lw		$x2,16[$x1]
FFFC15A0 0601020D		mtu		$x4,$x2
FFFC15A4 0140A103		lw		$x2,20[$x1]
FFFC15A8 0601028D		mtu		$x5,$x2
FFFC15AC 0180A103		lw		$x2,24[$x1]
FFFC15B0 0601030D		mtu		$x6,$x2
FFFC15B4 01C0A103		lw		$x2,28[$x1]
FFFC15B8 0601038D		mtu		$x7,$x2
FFFC15BC 0200A103		lw		$x2,32[$x1]
FFFC15C0 0601040D		mtu		$x8,$x2
FFFC15C4 0240A103		lw		$x2,36[$x1]
FFFC15C8 0601048D		mtu		$x9,$x2
FFFC15CC 0280A103		lw		$x2,40[$x1]
FFFC15D0 0601050D		mtu		$x10,$x2
FFFC15D4 02C0A103		lw		$x2,44[$x1]
FFFC15D8 0601058D		mtu		$x11,$x2
FFFC15DC 0300A103		lw		$x2,48[$x1]
FFFC15E0 0601060D		mtu		$x12,$x2
FFFC15E4 0340A103		lw		$x2,52[$x1]
FFFC15E8 0601068D		mtu		$x13,$x2
FFFC15EC 0380A103		lw		$x2,56[$x1]
FFFC15F0 0601070D		mtu		$x14,$x2
FFFC15F4 03C0A103		lw		$x2,60[$x1]
FFFC15F8 0601078D		mtu		$x15,$x2
FFFC15FC 0400A103		lw		$x2,64[$x1]
FFFC1600 0601080D		mtu		$x16,$x2
FFFC1604 0440A103		lw		$x2,68[$x1]
FFFC1608 0601088D		mtu		$x17,$x2
FFFC160C 0480A103		lw		$x2,72[$x1]
FFFC1610 0601090D		mtu		$x18,$x2
FFFC1614 04C0A103		lw		$x2,76[$x1]
FFFC1618 0601098D		mtu		$x19,$x2
FFFC161C 0500A103		lw		$x2,80[$x1]
FFFC1620 06010A0D		mtu		$x20,$x2
FFFC1624 0540A103		lw		$x2,84[$x1]
FFFC1628 06010A8D		mtu		$x21,$x2
FFFC162C 0580A103		lw		$x2,88[$x1]
FFFC1630 06010B0D		mtu		$x22,$x2
FFFC1634 05C0A103		lw		$x2,92[$x1]
FFFC1638 06010B8D		mtu		$x23,$x2
FFFC163C 0600A103		lw		$x2,96[$x1]
FFFC1640 06010C0D		mtu		$x24,$x2
FFFC1644 0640A103		lw		$x2,100[$x1]
FFFC1648 06010C8D		mtu		$x25,$x2
FFFC164C 0680A103		lw		$x2,104[$x1]
FFFC1650 06010D0D		mtu		$x26,$x2
FFFC1654 06C0A103		lw		$x2,108[$x1]
FFFC1658 06010D8D		mtu		$x27,$x2
FFFC165C 0700A103		lw		$x2,112[$x1]
FFFC1660 06010E0D		mtu		$x28,$x2
FFFC1664 0740A103		lw		$x2,116[$x1]
FFFC1668 06010E8D		mtu		$x29,$x2
FFFC166C 0780A103		lw		$x2,120[$x1]
FFFC1670 06010F0D		mtu		$x30,$x2
FFFC1674 07C0A103		lw		$x2,124[$x1]
FFFC1678 06010F8D		mtu		$x31,$x2
FFFC167C 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Operating system call dispatcher.
                        	;------------------------------------------------------------------------------
                        	
                        	OSCALL:
FFFC1680 0409090D		mfu		$a0,$a0
FFFC1684 0409898D		mfu		$a1,$a1
FFFC1688 040A0A0D		mfu		$a2,$a2
FFFC168C 040A8A8D		mfu		$a3,$a3
FFFC1690 040B0B0D		mfu		$a4,$a4
FFFC1694 040B8B8D		mfu		$a5,$a5
FFFC1698 00F97913		and		$a0,$a0,#15
FFFC169C 00191913		sll		$a0,$a0,#1
FFFC16A0 FFFC1637		lhu		$t0,OSCallTbl[$a0]
FFFC16A4 ED460613
FFFC16A8 01260633
FFFC16AC 00065D03
FFFC16B0 FFFC0637		or		$t0,$t0,#$FFFC0000
FFFC16B4 01A66D33
FFFC16B8 000D0067		jmp		[$t0]
                        	
                        	;------------------------------------------------------------------------------
                        	; Time accounting.
                        	; Update the length of time the task has been running.
                        	;
                        	; Parameters:
                        	;		s1 = pointer to TCB
                        	; Modifies:
                        	;		t2,t3,t4,t5
                        	;------------------------------------------------------------------------------
                        	
                        	AccountTime:
                        	.again:
                        	;	csrrw	$t3,#$741,$x0					; get high time
                        	;	csrrw	$t2,#$701,$x0					; get low time
                        	;	csrrw	$t4,#$741,$x0
                        	;	bne		$t3,$t4,.again
FFFC16BC 00004637		lw		$t2,Tick
FFFC16C0 33060613
FFFC16C4 00060633
FFFC16C8 00062E03
FFFC16CC 2BC22C23		sw		$t2,TCBEndTick[$s1]
FFFC16D0 2B022E83		lw		$t3,TCBStartTick[$s1]
FFFC16D4 41DE0F33		sub		$t4,$t2,$t3						; end - start
FFFC16D8 2C022F83		lw		$t5,TCBTicks[$s1]
FFFC16DC 01EF8FB3		add		$t5,$t5,$t4						; ticks + (end - start)
FFFC16E0 2DF22023		sw		$t5,TCBTicks[$s1]
FFFC16E4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Reschedule tasks.
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_Reschedule:
FFFC16E8 895FF0EF		call	GetCurrentTid
FFFC16EC 00A81213		sll		$s1,$v0,#10						; compute pointer to TCB
FFFC16F0 28824803		lbu		$v0,TCBStatus[$s1]		; flag task as no longer running
FFFC16F4 F7F87813		and		$v0,$v0,#~TS_RUNNING
FFFC16F8 29020423		sb		$v0,TCBStatus[$s1]
                        	
FFFC16FC FC1FF0EF		call	AccountTime						; uses s1
FFFC1700 909FF0EF		call	SelectTaskToRun
                        	
FFFC1704 00A85293		srl		$s2,$v0,#10						; s2 = pointer to incoming TCB
FFFC1708 2882C103		lbu		$x2,TCBStatus[$s2]		; x2 = incoming status
FFFC170C 08116E13		or		$t2,$x2,#TS_RUNNING|TS_READY	; set status = running
FFFC1710 2C82A103		lw		$x2,TCBException[$s2]	;
FFFC1714 00010A63		beq		$x2,$x0,.noException
                        		; set link register to catch handler address
                        		;{
                        		;	t->regs[29] = t->regs[28];   // set link register to catch handler
                        		;	t->epc = t->regs[28];        // and the PC register
                        		;	t->regs[1] = t->exception;    // r1 = exception value
                        		;	t->exception = 0;
                        		;	t->regs[2] = 45;              // r2 = exception type
                        		;}
FFFC1718 0022A223		sw		$x2,4[$s2]						; r1 = exception
FFFC171C 2C02A423		sw		$x0,TCBException[$s2]	; tcb->exception = 0
FFFC1720 02D06113		ldi		$x2,#45
FFFC1724 0022A423		sw		$x2,8[$s2]						; r2 = 45
                        	.noException:
                        	
                        		; If a message is ready, update status to ready and put
                        		; message in target memory. The task will be returning
                        		; from a WaitMsg so a return status of E_Ok is also set.
FFFC1728 004E7113		and		$x2,$t2,#TS_MSGRDY
FFFC172C 06010063		beq		$x2,$x0,.noMsg
FFFC1730 0502A903		lw		$a0,80[$s2]					; user a2 (x20)
FFFC1734 F70FF0EF		call	VirtToPhys
FFFC1738 00000637		lw		$x2,TCB_MsgD1[$s2]
FFFC173C 10C60613
FFFC1740 00560633
FFFC1744 00062103
FFFC1748 00282023		sw		$x2,[$v0]
FFFC174C 0542A903		lw		$a0,84[$s2]
FFFC1750 F54FF0EF		call	VirtToPhys
FFFC1754 00000637		lw		$x2,TCB_MsgD2[$s2]
FFFC1758 10D60613
FFFC175C 00560633
FFFC1760 00062103
FFFC1764 00282023		sw		$x2,[$v0]
FFFC1768 0582A903		lw		$a0,88[$s2]
FFFC176C F38FF0EF		call	VirtToPhys
FFFC1770 00000637		lw		$x2,TCB_MsgD3[$s2]
FFFC1774 10E60613
FFFC1778 00560633
FFFC177C 00062103
FFFC1780 00282023		sw		$x2,[$v0]
FFFC1784 00006113		ldi		$x2,#E_Ok						; setup to return E_Ok
FFFC1788 0422A023		sw		$x2,64[$s2]					; in v0
                        	
                        	.noMsg:
FFFC178C FFBE7E13		and		$t2,$t2,#~TS_MSGRDY		; mask out message ready status
FFFC1790 29C28423		sb		$t2,TCBStatus[$s2]
FFFC1794 00520863		beq		$s1,$s2,.noCtxSwitch	; incoming and outgoing contexts the same?
FFFC1798 00026933		mov		$a0,$s1
FFFC179C 0002E9B3		mov		$a1,$s2
FFFC17A0 95DFF0EF		call	SwapContext
                        	.noCtxSwitch:
FFFC17A4 00004637		lw		$t2,Tick						; get tick
FFFC17A8 33060613
FFFC17AC 00060633
FFFC17B0 00062E03
FFFC17B4 2BC22823		sw		$t2,TCBStartTick[$s1]
FFFC17B8 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; SchedulerIRQ meant to be called from the timer ISR.
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_SchedulerIRQ:
FFFC17BC FFC70713		sub		$sp,$sp,#4
FFFC17C0 00172023		sw		$ra,[$sp]
FFFC17C4 00004637		lw		$t5,Tick							; update tick count
FFFC17C8 33060613
FFFC17CC 00060633
FFFC17D0 00062F83
FFFC17D4 001F8F93		add		$t5,$t5,#1
FFFC17D8 00004637		sw		$t5,Tick
FFFC17DC 33060613
FFFC17E0 00060633
FFFC17E4 01F62023
FFFC17E8 F94FF0EF		call	GetCurrentTid
FFFC17EC 00A81213		sll		$s1,$v0,#10						; compute pointer to TCB
FFFC17F0 ECDFF0EF		call	AccountTime
FFFC17F4 28824F83		lbu		$t5,TCBStatus[$s1]
FFFC17F8 117FEF93		or		$t5,$t5,#TS_PREMPT
FFFC17FC F7FFFF93		and		$t5,$t5,#~TS_RUNNING	; no longer running, but may still be ready
FFFC1800 29F20423		sb		$t5,TCBStatus[$s1]
                        		; Keep popping the timeout list as long as there are tasks on it with
                        		; expired timeouts.
                        	.0001:
FFFC1804 00004637		lhu		$t5,TimeoutList
FFFC1808 32860613
FFFC180C 00060633
FFFC1810 00065F83
FFFC1814 060FC663		blt		$t5,$x0,.noTimeouts
FFFC1818 01006F13		ldi		$t4,#NR_TCB
FFFC181C 07EFD263		bge		$t5,$t4,.noTimeouts
FFFC1820 00AF9F13		sll		$t4,$t5,#10					; index to pointer
FFFC1824 00000637		lw		$t3,TCBTimeout[$t4]
FFFC1828 11A60613
FFFC182C 01E60633
FFFC1830 00062E83
FFFC1834 01D04A63		bgt		$t3,$x0,.timeoutNotDone
FFFC1838 490000EF		call	PopTimeoutList
FFFC183C 00086933		mov		$a0,$v0
FFFC1840 F4CFF0EF		call	InsertTask
FFFC1844 FC0000E3		bra		.0001
                        	.timeoutNotDone:
FFFC1848 FFFE8E93		sub		$t3,$t3,#1
FFFC184C 00004637		lw		$t2,missed_ticks
FFFC1850 32060613
FFFC1854 00060633
FFFC1858 00062E03
FFFC185C 41CE8EB3		sub		$t3,$t3,$t2
FFFC1860 00000637		sw		$t3,TCBTimeout[$t4]
FFFC1864 11A60613
FFFC1868 01E60633
FFFC186C 01D62023
FFFC1870 00004637		sw		$x0,missed_ticks
FFFC1874 32060613
FFFC1878 00060633
FFFC187C 00062023
                        	.noTimeouts:
                        		; The ready queue was just updated, there could be new tasks
                        		; ready to run.
FFFC1880 F88FF0EF		call	SelectTaskToRun
                        	
FFFC1884 01685293		srl		$s2,$v0,#22					; s2 = pointer to incoming TCB
FFFC1888 2882C103		lbu		$x2,TCBStatus[$s2]	; x2 = incoming status
FFFC188C 08116E13		or		$t2,$x2,#TS_RUNNING|TS_READY	; status = running
FFFC1890 2C82A103		lw		$x2,TCBException[$s2]	;
FFFC1894 00010263		beq		$x2,$x0,.noException
                        		; set link register to catch handler address
                        		;{
                        		;	t->regs[29] = t->regs[28];   // set link register to catch handler
                        		;	t->epc = t->regs[28];        // and the PC register
                        		;	t->regs[1] = t->exception;    // r1 = exception value
                        		;	t->exception = 0;
                        		;	t->regs[2] = 45;              // r2 = exception type
                        		;}
                        	.noException:
                        	
                        		; If a message is ready, update status to ready and put
                        		; message in target memory. The task will be returning
                        		; from a WaitMsg so a return status of E_Ok is also set.
FFFC1898 004E7113		and		$x2,$t2,#TS_MSGRDY
FFFC189C 06010063		beq		$x2,$x0,.noMsg
FFFC18A0 0502A903		lw		$a0,80[$s2]					; user a2 (x20)
FFFC18A4 E00FF0EF		call	VirtToPhys
FFFC18A8 00000637		lw		$x2,TCB_MsgD1[$s2]
FFFC18AC 10C60613
FFFC18B0 00560633
FFFC18B4 00062103
FFFC18B8 00282023		sw		$x2,[$v0]
FFFC18BC 0542A903		lw		$a0,84[$s2]
FFFC18C0 DE4FF0EF		call	VirtToPhys
FFFC18C4 00000637		lw		$x2,TCB_MsgD2[$s2]
FFFC18C8 10D60613
FFFC18CC 00560633
FFFC18D0 00062103
FFFC18D4 00282023		sw		$x2,[$v0]
FFFC18D8 0582A903		lw		$a0,88[$s2]
FFFC18DC DC8FF0EF		call	VirtToPhys
FFFC18E0 00000637		lw		$x2,TCB_MsgD3[$s2]
FFFC18E4 10E60613
FFFC18E8 00560633
FFFC18EC 00062103
FFFC18F0 00282023		sw		$x2,[$v0]
FFFC18F4 00006113		ldi		$x2,#E_Ok						; setup to return E_Ok
FFFC18F8 0422A023		sw		$x2,64[$s2]					; in v0
                        	
                        	.noMsg:
FFFC18FC FFBE7E13		and		$t2,$t2,#~TS_MSGRDY		; mask out message ready status
FFFC1900 29C28423		sb		$t2,TCBStatus[$s2]
FFFC1904 00520863		beq		$s1,$s2,.noCtxSwitch
FFFC1908 00026933		mov		$a0,$s1
FFFC190C 0002E9B3		mov		$a1,$s2
FFFC1910 FECFF0EF		call	SwapContext
                        	.noCtxSwitch:
FFFC1914 00072083		lw		$ra,[$sp]
FFFC1918 00470713		add		$sp,$sp,#4
FFFC191C 00004637		lw		$t2,Tick					; get tick
FFFC1920 33060613
FFFC1924 00060633
FFFC1928 00062E03
FFFC192C 2BC22823		sw		$t2,TCBStartTick[$s1]
FFFC1930 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Returns:
                        	;		v0 = process id
                        	;------------------------------------------------------------------------------
                        	
                        	GetFreePid:
FFFC1934 00006D93		ldi		$t1,#0
FFFC1938 00004637		lhu		$v1,PIDMAP
FFFC193C 31060613
FFFC1940 00060633
FFFC1944 00065883
                        	.0001:
FFFC1948 0018FD13		and		$t0,$v1,#1
FFFC194C 020D0263		beq		$t0,$x0,.allocPid
FFFC1950 0018D893		srl		$v1,$v1,#1
FFFC1954 00008637		or		$v1,$v1,#$8000
FFFC1958 011668B3
FFFC195C 001D8D93		add		$t1,$t1,#1
FFFC1960 00FDFD93		and		$t1,$t1,#15
FFFC1964 FE0D92E3		bne		$t1,$x0,.0001
                        	; here no pids available
FFFC1968 00006833		mov		$v0,$x0
FFFC196C 00008067		ret
                        	.allocPid:
FFFC1970 000DE833		mov		$v0,$t1
FFFC1974 0018E893		or		$v1,$v1,#1
FFFC1978 000D8A63		beq		$t1,$x0,.0003
                        	.0002:
FFFC197C 00189893		sll		$v1,$v1,#1
FFFC1980 0018E893		or		$v1,$v1,#1
FFFC1984 FFFD8D93		sub		$t1,$t1,#1
FFFC1988 FFAD9AE3		bne		$t1,$t0,.0002
                        	.0003:
FFFC198C 00004637		sh		$v1,PIDMAP
FFFC1990 31060613
FFFC1994 00060633
FFFC1998 01161023
FFFC199C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Start a task.
                        	;	Task status is set to ready, priority normal, and the task is inserted into
                        	; the ready queue. Segment registers are setup for a flat memory model.
                        	; 
                        	;	Parameters:
                        	;		a1 = memory pages required
                        	;		a2 = start pc (usually $100)
                        	;	Modifies:
                        	;		a0 = tid
                        	;	Returns:
                        	;		v0 = tid of started task if successful, otherwise zero
                        	;------------------------------------------------------------------------------
                        	;
                        	FMTK_StartTask:
FFFC19A0 FFC70713		sub		$sp,$sp,#4
FFFC19A4 00172023		sw		$ra,[$sp]
FFFC19A8 F8DFF0EF		call	GetFreePid
FFFC19AC 08080C63		beq		$v0,$x0,.err
FFFC19B0 00086933		mov		$a0,$v0
FFFC19B4 00A81213		sll		$s1,$v0,#10			; compute TCB address
FFFC19B8 C60FF0EF		call	AllocStack
FFFC19BC 00080D37		ldi		$t0,#$7F800			; set stack pointer
FFFC19C0 800D0D13
FFFC19C4 03A22C23		sw		$t0,56[$s1]
FFFC19C8 29422023		sw		$a2,TCBepc[$s1]	; address task will begin at
FFFC19CC BA0FF0EF		call	Alloc
FFFC19D0 06088A63		beq		$v1,$x0,.err
FFFC19D4 00106D13		ldi		$t0,#TS_READY
FFFC19D8 29A20423		sb		$t0,TCBStatus[$s1]
FFFC19DC 00206D13		ldi		$t0,#2					; normal execution priority
FFFC19E0 29A204A3		sb		$t0,TCBPriority[$s1]
                        		; leave segment base at $0, flat memory model
FFFC19E4 00606D13		ldi		$t0,#6							; read,write
FFFC19E8 21A22023		sw		$t0,TCBsegs[$s1]			; segs 0 to 11
FFFC19EC 21A22223		sw		$t0,TCBsegs+4[$s1]
FFFC19F0 21A22423		sw		$t0,TCBsegs+8[$s1]
FFFC19F4 21A22623		sw		$t0,TCBsegs+12[$s1]
FFFC19F8 21A22823		sw		$t0,TCBsegs+16[$s1]
FFFC19FC 21A22A23		sw		$t0,TCBsegs+20[$s1]
FFFC1A00 21A22C23		sw		$t0,TCBsegs+24[$s1]
FFFC1A04 21A22E23		sw		$t0,TCBsegs+28[$s1]
FFFC1A08 23A22023		sw		$t0,TCBsegs+32[$s1]
FFFC1A0C 23A22223		sw		$t0,TCBsegs+36[$s1]
FFFC1A10 23A22423		sw		$t0,TCBsegs+40[$s1]
FFFC1A14 23A22623		sw		$t0,TCBsegs+44[$s1]
FFFC1A18 00506D13		ldi		$t0,#5							; read,execute
FFFC1A1C 23A22823		sw		$t0,TCBsegs+48[$s1]	; segs 12 to 15
FFFC1A20 23A22A23		sw		$t0,TCBsegs+52[$s1]
FFFC1A24 23A22C23		sw		$t0,TCBsegs+56[$s1]
FFFC1A28 23A22E23		sw		$t0,TCBsegs+60[$s1]
FFFC1A2C 00A25913		srl		$a0,$s1,#10					; need the tid again
FFFC1A30 D5CFF0EF		call	InsertTask
FFFC1A34 00072083		lw		$ra,[$sp]
FFFC1A38 00470713		add		$sp,$sp,#4
FFFC1A3C 0609080D		mtu		$v0,$a0
FFFC1A40 10000073		eret
                        	.err:
FFFC1A44 00072083		lw		$ra,[$sp]
FFFC1A48 00470713		add		$sp,$sp,#4
FFFC1A4C 0600080D		mtu		$v0,$x0
FFFC1A50 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Exit the current task.
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		a1 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_ExitTask:
FFFC1A54 300019F3		csrrw	$a1,#$300,$x0				; get tid
FFFC1A58 0169D993		srl		$a1,$a1,#22
FFFC1A5C 00F9F993		and		$a1,$a1,#15
                        		; fall through to KillTask
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = tid of task to kill
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_KillTask:
FFFC1A60 00206D13		ldi		$t0,#TS_DEAD				; flag task as dead (prevents it from being re-queued)
FFFC1A64 00F9FD93		and		$t1,$a1,#15					; limit pid
FFFC1A68 00AD9D93		sll		$t1,$t1,#10					; convert to TCB address
FFFC1A6C 29AD8423		sb		$t0,TCBStatus[$t1]
FFFC1A70 0009E933		mov		a0,a1								; a0 = pid
FFFC1A74 BD0FF0EF		call	FreeAll							; free all the memory associated with the task
                        		; Now make process ID available for reuse
FFFC1A78 00004637		lhu		$t1,PIDMAP
FFFC1A7C 31060613
FFFC1A80 00060633
FFFC1A84 00065D83
FFFC1A88 00106D13		ldi		$t0,#1							; generate bit "off" mask
FFFC1A8C 013D1D13		sll		$t0,$t0,$a1
FFFC1A90 FFFD4D13		xor		$t0,$t0,#-1					; complment for inverted mask
FFFC1A94 01ADFDB3		and		$t1,$t1,$t0
FFFC1A98 00004637		sh		$t1,PIDMAP
FFFC1A9C 31060613
FFFC1AA0 00060633
FFFC1AA4 01B61023
FFFC1AA8 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = task id to insert
                        	;		a1 = timeout value
                        	;------------------------------------------------------------------------------
                        	
                        	InsertIntoTimeoutList:
FFFC1AAC 00A91213		sll		$s1,$a0,#10				; tid to pointer
FFFC1AB0 00004637		lw		$t0,TimeoutList
FFFC1AB4 32860613
FFFC1AB8 00060633
FFFC1ABC 00062D03
FFFC1AC0 040D5863		bge		$t0,$x0,.0001
FFFC1AC4 00000637		sw		$a1,TCBTimeout[$s1]
FFFC1AC8 11A60613
FFFC1ACC 00460633
FFFC1AD0 01362023
FFFC1AD4 00004637		sh		$a0,TimeoutList
FFFC1AD8 32860613
FFFC1ADC 00060633
FFFC1AE0 01261023
FFFC1AE4 FFF06D13		ldi		$t0,#-1
FFFC1AE8 00000637		sh		$t0,TCBNext[$s1]
FFFC1AEC 12860613
FFFC1AF0 00460633
FFFC1AF4 01A61023
FFFC1AF8 00000637		sh		$t0,TCBPrev[$s1]
FFFC1AFC 12960613
FFFC1B00 00460633
FFFC1B04 01A61023
FFFC1B08 00006813		ldi		$v0,#E_Ok
FFFC1B0C 00008067		ret
                        	.0001:
FFFC1B10 00006DB3		mov		$t1,$x0
FFFC1B14 00004637		lhu		$t2,TimeoutList
FFFC1B18 32860613
FFFC1B1C 00060633
FFFC1B20 00065E03
FFFC1B24 00AE1E93		sll		$t3,$t2,#10
                        	.beginWhile:
FFFC1B28 00000637		lw		$t4,TCBTimeout[$t3]
FFFC1B2C 11A60613
FFFC1B30 01D60633
FFFC1B34 00062F03
FFFC1B38 033F5263		ble		$a1,$t4,.endWhile
FFFC1B3C 41E989B3		sub		$a1,$a1,$t4
FFFC1B40 000EEDB3		mov		$t1,$t3
FFFC1B44 00000637		lhu		$t3,TCBNext[$t3]
FFFC1B48 12860613
FFFC1B4C 01D60633
FFFC1B50 00065E83
FFFC1B54 00AE9E93		sll		$t3,$t3,#10
FFFC1B58 FC0008E3		bra		.beginWhile
                        	.endWhile
FFFC1B5C 00AEDE13		srl		$t2,$t3,#10
FFFC1B60 00000637		sh		$t2,TCBNext[$s1]
FFFC1B64 12860613
FFFC1B68 00460633
FFFC1B6C 01C61023
FFFC1B70 00ADDE13		srl		$t2,$t1,#10
FFFC1B74 00000637		sh		$t2,TCBPrev[$s1]
FFFC1B78 12960613
FFFC1B7C 00460633
FFFC1B80 01C61023
FFFC1B84 00000637		lw		$t2,TCBTimeout[$t3]
FFFC1B88 11A60613
FFFC1B8C 01D60633
FFFC1B90 00062E03
FFFC1B94 413E0E33		sub		$t2,$t2,$a1
FFFC1B98 00000637		sw		$t2,TCBTimeout[$t3]
FFFC1B9C 11A60613
FFFC1BA0 01D60633
FFFC1BA4 01C62023
FFFC1BA8 00000637		sh		$a0,TCBPrev[$t3]
FFFC1BAC 12960613
FFFC1BB0 01D60633
FFFC1BB4 01261023
FFFC1BB8 000D8C63		beq		$t1,$x0,.0002
FFFC1BBC 00000637		sh		$a0,TCBNext[$t1]
FFFC1BC0 12860613
FFFC1BC4 01B60633
FFFC1BC8 01261023
FFFC1BCC 00000A63		bra		.0003
                        	.0002:
FFFC1BD0 00004637		sh		$a0,TimeoutList
FFFC1BD4 32860613
FFFC1BD8 00060633
FFFC1BDC 01261023
                        	.0003:
FFFC1BE0 28824E03		lbu		$t2,TCBStatus[$s1]
FFFC1BE4 12EE6E13		or		$t2,$t2,#TS_TIMEOUT
FFFC1BE8 29C20423		sb		$t2,TCBStatus[$s1]
FFFC1BEC 00006813		ldi		$v0,#E_Ok
FFFC1BF0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	RemoveFromTimeoutList:
FFFC1BF4 00A91213		sll		$s1,$a0,#10					; tid to pointer
FFFC1BF8 00000637		lhu		$t0,TCBNext[$s1]
FFFC1BFC 12860613
FFFC1C00 00460633
FFFC1C04 00065D03
FFFC1C08 040D4E63		blt		$t0,$x0,.0001
FFFC1C0C 00AD1293		sll		$s2,$t0,#10
FFFC1C10 00000637		lhu		$t1,TCBPrev[$s1]
FFFC1C14 12960613
FFFC1C18 00460633
FFFC1C1C 00065D83
FFFC1C20 00000637		sh		$t1,TCBPrev[$s2]
FFFC1C24 12960613
FFFC1C28 00560633
FFFC1C2C 01B61023
FFFC1C30 00000637		lw		$t1,TCBTimeout[$s2]
FFFC1C34 11A60613
FFFC1C38 00560633
FFFC1C3C 00062D83
FFFC1C40 00000637		lw		$t2,TCBTimeout[$s1]
FFFC1C44 11A60613
FFFC1C48 00460633
FFFC1C4C 00062E03
FFFC1C50 01CD8DB3		add		$t1,$t1,$t2
FFFC1C54 00000637		sw		$t1,TCBTimeout[$s2]
FFFC1C58 11A60613
FFFC1C5C 00560633
FFFC1C60 01B62023
                        	.0001:
FFFC1C64 00000637		lhu		$t0,TCBPrev[$s1]
FFFC1C68 12960613
FFFC1C6C 00460633
FFFC1C70 00065D03
FFFC1C74 020D4463		blt		$t0,$x0,.0002
FFFC1C78 00AD1293		sll		$s2,$t0,#10
FFFC1C7C 00000637		lhu		$t0,TCBNext[$s1]
FFFC1C80 12860613
FFFC1C84 00460633
FFFC1C88 00065D03
FFFC1C8C 00000637		sh		$t0,TCBNext[$s2]
FFFC1C90 12860613
FFFC1C94 00560633
FFFC1C98 01A61023
                        	.0002:
FFFC1C9C 28020423		sb		$x0,TCBStatus[$s1]	; status = TS_NONE
FFFC1CA0 FFF06D13		ldi		$t0,#-1
FFFC1CA4 00000637		sh		$t0,TCBNext[$s1]
FFFC1CA8 12860613
FFFC1CAC 00460633
FFFC1CB0 01A61023
FFFC1CB4 00000637		sh		$t0,TCBPrev[$s1]
FFFC1CB8 12960613
FFFC1CBC 00460633
FFFC1CC0 01A61023
FFFC1CC4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Pop an entry off the timeout list.
                        	;
                        	; Modifies:
                        	;		v1,t0
                        	;	Returns:
                        			v0 = timeout list entry tid
                        	;------------------------------------------------------------------------------
                        	
                        	PopTimeoutList:
FFFC1CC8 00004637		lhu		$v0,TimeoutList
FFFC1CCC 32860613
FFFC1CD0 00060633
FFFC1CD4 00065803
FFFC1CD8 04084E63		blt		$v0,$x0,.done
FFFC1CDC 01006893		ldi		$v1,#NR_TCB
FFFC1CE0 05187A63		bgeu	$v0,$v1,.done
FFFC1CE4 00A81D13		sll		$t0,$v0,#10						; tid to pointer
FFFC1CE8 288D4883		lbu		$v1,TCBStatus[$t0]		; no longer a waiting status
FFFC1CEC ED18F893		and		$v1,$v1,#~(TS_WAITMSG|TS_TIMEOUT)
	sb		$v1,TCBStatus[$t0]
FFFC1CF0 291D0423
FFFC1CF4 00000637		lhu		$v1,TCBNext[$t0]
FFFC1CF8 12860613
FFFC1CFC 01A60633
FFFC1D00 00065883
FFFC1D04 00004637		sh		$v1,TimeoutList
FFFC1D08 32860613
FFFC1D0C 00060633
FFFC1D10 01161023
FFFC1D14 02084063		blt		$v0,$x0,.done
FFFC1D18 01006893		ldi		$v1,#NR_TCB
FFFC1D1C 01187C63		bgeu	$v0,$v1,.done
FFFC1D20 FFF06893		ldi		$v1,#-1
FFFC1D24 00000637		sh		$v1,TCBPrev[$t0]
FFFC1D28 12960613
FFFC1D2C 01A60633
FFFC1D30 01161023
                        	.done:	
FFFC1D34 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Sleep for a length of time. Time determined by the resolution of wall clock 
                        	; time. Passing a time of zero causes the function to return right away with
                        	; and E_Ok status.
                        	;
                        	; Parameters:
                        	;		a1 = length of time to sleep
                        	; Returns:
                        	;		v0 = E_Ok if successful
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_Sleep:
FFFC1D38 03305463		ble		$a1,$x0,.xit
FFFC1D3C 70101D73		csrrw	$t0,#$701,$x0
FFFC1D40 A3CFF0EF		call	GetCurrentTid
FFFC1D44 00A81213		sll		$s1,$v0,#10
FFFC1D48 28824D83		lbu		$t1,TCBStatus[$s1]		; changing status will remove from ready queue
FFFC1D4C FFEDFD93		and		$t1,$t1,#~TS_READY		; on next dequeue
FFFC1D50 29B20423		sb		$t1,TCBStatus[$s1]
FFFC1D54 00086933		mov		$a0,$v0								; a0 = current tid
FFFC1D58 D55FF0EF		call	InsertIntoTimeoutList	; a1 = timeout
FFFC1D5C 98DFF06F		jmp		FMTK_Reschedule
                        	.xit:
FFFC1D60 00006813		ldi		$v0,#E_Ok
FFFC1D64 0608080D		mtu		$v0,$v0
FFFC1D68 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Diagnostics
                        	;------------------------------------------------------------------------------
                        	
                        	DumpReadyQueue:
FFFC1D6C FFC70713		sub		$sp,$sp,#4
FFFC1D70 00172023		sw		$ra,[$sp]
FFFC1D74 00006D93		ldi		$t1,#0
                        	.0002:
FFFC1D78 00D06913		ldi		$a0,#CR
FFFC1D7C C38FE0EF		call	Putch
FFFC1D80 05106913		ldi		$a0,#'Q'
FFFC1D84 C30FE0EF		call	Putch
FFFC1D88 000DE933		mov		$a0,$t1
FFFC1D8C 84DFE0EF		call	PutHexNybble
FFFC1D90 03A06913		ldi		$a0,#':'
FFFC1D94 C20FE0EF		call	Putch
FFFC1D98 00004637		lbu		$a2,HRDY0[$t1]
FFFC1D9C 30860613
FFFC1DA0 01B60633
FFFC1DA4 00064A03
FFFC1DA8 00004637		lbu		$a3,TRDY0[$t1]
FFFC1DAC 30C60613
FFFC1DB0 01B60633
FFFC1DB4 00064A83
FFFC1DB8 035A0663		beq		$a2,$a3,.nxt
FFFC1DBC 008D9E13		sll		$t2,$t1,#8
FFFC1DC0 00004637		add		$t2,$t2,#RDYQ0
FFFC1DC4 01C60E33
                        	.0001:
FFFC1DC8 014E0EB3		add		$t3,$t2,$a2
FFFC1DCC 000EC903		lbu		$a0,[$t3]
FFFC1DD0 FE8FE0EF		call	PutHexByte
FFFC1DD4 02006913		ldi		$a0,#' '
FFFC1DD8 BDCFE0EF		call	Putch
FFFC1DDC 001A0A13		add		$a2,$a2,#1
FFFC1DE0 FF5A14E3		bne		$a2,$a3,.0001
                        	.nxt:
FFFC1DE4 001D8D93		add		$t1,$t1,#1
FFFC1DE8 004DAE13		slt		$t2,$t1,#4
FFFC1DEC F80E16E3		bne		$t2,$x0,.0002
FFFC1DF0 00072083		lw		$ra,[$sp]
FFFC1DF4 00470713		add		$sp,$sp,#4
FFFC1DF8 10000073		eret
                        	
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "TinyBasic.asm",1
                        	.file "TinyBasic.asm",1
                        	;****************************************************************;
                        	;                                                                ;
                        	;		Tiny BASIC for the CS01                                      ;
                        	;                                                                ;
                        	; Derived from a 68000 derivative of Palo Alto Tiny BASIC as     ;
                        	; published in the May 1976 issue of Dr. Dobb's Journal.         ;
                        	; Adapted to the 68000 by:                                       ;
                        	;	Gordon brndly						                         ;
                        	;	12147 - 51 Street					                         ;
                        	;	Edmonton AB  T5W 3G8					                     ;
                        	;	Canada							                             ;
                        	;	(updated mailing address for 1996)			                 ;
                        	;                                                                ;
                        	; Adapted to the CS01 by:                                        ;
                        	;    Robert Finch                                                ;
                        	;    Ontario, Canada                                             ;
                        	;	 robfinch<remove>@finitron.ca    	                             ;  
                        	;****************************************************************;
                        	;  Copyright (C) 2016-2020 by Robert Finch. This program may be	 ;
                        	;    freely distributed for personal use only. All commercial	 ;
                        	;		       rights are reserved.			                     ;
                        	;****************************************************************;
                        	;
                        	; Register Usage
                        	; $t2 = text pointer (global usage)
                        	; r3,r4 = inputs parameters to subroutines
                        	; a1 = return value
                        	;
                        	;* Vers. 1.0  1984/7/17	- Original version by Gordon brndly
                        	;*	1.1  1984/12/9	- Addition of '0x' print term by Marvin Lipford
                        	;*	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                        	
                        	CR		EQU	0x0D		;ASCII equates
                        	LINEFD	EQU	0x0A		; Don't use LF (same as load float instruction)
                        	TAB		EQU	0x09
                        	CTRLC	EQU	0x03
                        	CTRLH	EQU	0x08
                        	CTRLI	EQU	0x09
                        	CTRLJ	EQU	0x0A
                        	CTRLK	EQU	0x0B
                        	CTRLM   EQU 0x0D
                        	CTRLS	EQU	0x13
                        	CTRLX	EQU	0x18
                        	XON		EQU	0x11
                        	XOFF	EQU	0x13
                        	
                        	FILENAME	EQU		0x6C0
                        	FILEBUF		EQU		0x07F600
                        	OSSP		EQU		0x700
                        	TXTUNF		EQU		OSSP+4
                        	VARBGN		EQU		TXTUNF+4
                        	VAREND		EQU		VARBGN+4
                        	LOPVAR		EQU		VAREND+4
                        	STKGOS		EQU		LOPVAR+4
                        	CURRNT		EQU		STKGOS+4
                        	BUFFER		EQU		CURRNT+4
                        	BUFLEN		EQU		84
                        	LOPPT		EQU		BUFFER+84
                        	LOPLN		EQU		LOPPT+4
                        	LOPINC		EQU		LOPLN+4
                        	LOPLMT		EQU		LOPINC+4
                        	NUMWKA		EQU		LOPLMT+24
                        	STKINP		EQU		NUMWKA+4
                        	STKBOT		EQU		STKINP+4
                        	usrJmp		EQU		STKBOT+4
                        	IRQROUT		EQU		usrJmp+4
                        	
                        	OUTPTR		EQU		IRQROUT+4
                        	INPPTR		EQU		OUTPTR+4
                        	CursorFlash	EQU		INPPTR+4
                        	IRQFlag		EQU		CursorFlash+4
                        	
                        	;
                        	; Modifiable system constants:
                        	;
                        	;THRD_AREA	dw	0x04000000	; threading switch area 0x04000000-0x40FFFFF
                        	;bitmap dw	0x00100000	; bitmap graphics memory 0x04100000-0x417FFFF
                        	TXTBGN		EQU		0x001800	;TXT ;beginning of program memory
                        	ENDMEM		EQU		0x008000	; end of available memory
                        	STACKOFFS	EQU		0x07FFFC	; stack offset
                        	
                        	
                        	.file "TinyBasic.asm",84
                        			code
FFFC1DFC 00000000			align	409
FFFC1E00 00000000
FFFC1E04 00000000
FFFC1E08 00000000
FFFC1E0C 00000000
FFFC1E10 00000000
FFFC1E14 00000000
FFFC1E18 00000000
FFFC1E1C 00000000
FFFC1E20 00000000
FFFC1E24 00000000
FFFC1E28 00000000
FFFC1E2C 00000000
FFFC1E30 00000000
FFFC1E34 00000000
FFFC1E38 00000000
FFFC1E3C 00000000
FFFC1E40 00000000
FFFC1E44 00000000
FFFC1E48 00000000
FFFC1E4C 00000000
FFFC1E50 00000000
FFFC1E54 00000000
FFFC1E58 00000000
FFFC1E5C 00000000
FFFC1E60 00000000
FFFC1E64 00000000
FFFC1E68 00000000
FFFC1E6C 00000000
FFFC1E70 00000000
FFFC1E74 00000000
FFFC1E78 00000000
FFFC1E7C 00000000
FFFC1E80 00000000
FFFC1E84 00000000
FFFC1E88 00000000
FFFC1E8C 00000000
FFFC1E90 00000000
FFFC1E94 00000000
FFFC1E98 00000000
FFFC1E9C 00000000
FFFC1EA0 00000000
FFFC1EA4 00000000
FFFC1EA8 00000000
FFFC1EAC 00000000
FFFC1EB0 00000000
FFFC1EB4 00000000
FFFC1EB8 00000000
FFFC1EBC 00000000
FFFC1EC0 00000000
FFFC1EC4 00000000
FFFC1EC8 00000000
FFFC1ECC 00000000
FFFC1ED0 00000000
FFFC1ED4 00000000
FFFC1ED8 00000000
FFFC1EDC 00000000
FFFC1EE0 00000000
FFFC1EE4 00000000
FFFC1EE8 00000000
FFFC1EEC 00000000
FFFC1EF0 00000000
FFFC1EF4 00000000
FFFC1EF8 00000000
FFFC1EFC 00000000
FFFC1F00 00000000
FFFC1F04 00000000
FFFC1F08 00000000
FFFC1F0C 00000000
FFFC1F10 00000000
FFFC1F14 00000000
FFFC1F18 00000000
FFFC1F1C 00000000
FFFC1F20 00000000
FFFC1F24 00000000
FFFC1F28 00000000
FFFC1F2C 00000000
FFFC1F30 00000000
FFFC1F34 00000000
FFFC1F38 00000000
FFFC1F3C 00000000
FFFC1F40 00000000
FFFC1F44 00000000
FFFC1F48 00000000
FFFC1F4C 00000000
FFFC1F50 00000000
FFFC1F54 00000000
FFFC1F58 00000000
FFFC1F5C 00000000
FFFC1F60 00000000
FFFC1F64 00000000
FFFC1F68 00000000
FFFC1F6C 00000000
FFFC1F70 00000000
FFFC1F74 00000000
FFFC1F78 00000000
FFFC1F7C 00000000
FFFC1F80 00000000
FFFC1F84 00000000
FFFC1F88 00000000
FFFC1F8C 00000000
FFFC1F90 00000000
FFFC1F94 00000000
FFFC1F98 00000000
FFFC1F9C 00000000
FFFC1FA0 00000000
FFFC1FA4 00000000
FFFC1FA8 00000000
FFFC1FAC 00000000
FFFC1FB0 00000000
FFFC1FB4 00000000
FFFC1FB8 00000000
FFFC1FBC 00000000
FFFC1FC0 00000000
FFFC1FC4 00000000
FFFC1FC8 00000000
FFFC1FCC 00000000
FFFC1FD0 00000000
FFFC1FD4 00000000
FFFC1FD8 00000000
FFFC1FDC 00000000
FFFC1FE0 00000000
FFFC1FE4 00000000
FFFC1FE8 00000000
FFFC1FEC 00000000
FFFC1FF0 00000000
FFFC1FF4 00000000
FFFC1FF8 00000000
FFFC1FFC 00000000
                        	
                        	;
                        	; Standard jump table. You can change these addresses if you are
                        	; customizing this interpreter for a different environment.
                        	;
                        	TinyBasic:
                        	GOSTART:	
FFFC2000 0300006F			jmp	CSTART	;	Cold Start entry point
                        	GOWARM:	
FFFC2004 0A80006F			jmp	WSTART	;	Warm Start entry point
                        	GOOUT:	
FFFC2008 3290106F			jmp	OUTC	;	Jump to character-out routine
                        	GOIN:	
FFFC200C 3290106F			jmp	INCH	;Jump to character-in routine
                        	GOAUXO:	
FFFC2010 00000637			jmp	AUXOUT	;	Jump to auxiliary-out routine
FFFC2014 16960067
                        	GOAUXI:	
FFFC2018 00000637			jmp	AUXIN	;	Jump to auxiliary-in routine
FFFC201C 16B60067
                        	GOBYE:	
FFFC2020 3450106F			jmp	BYEBYE	;	Jump to monitor, DOS, etc.
                        	
FFFC2024 00000000		align	1
FFFC2028 00000000
FFFC202C 00000000
                        	
                        	//message "CSTART"
                        	public CSTART:
	; First save off the link register and OS sp value
FFFC2030 70E02023		sw		$sp,OSSP
FFFC2034 00080737		ldi		$sp,#STACKOFFS	; initialize stack pointer
FFFC2038 FFC70713
                        	//	call	_RequestIOFocus
                        	;	call	_DBGHomeCursor[pc]
FFFC203C 00006933		mov		a0,r0			; turn off keyboard echoing
                        	//	call	SetKeyboardEcho
                        	//	stz		CursorFlash
                        	//	ldx		#0x10000020	; black chars, yellow background
                        	;	stx		charToPrint
                        	;	call	_DBGClearScreen[pc]
FFFC2040 FFFC4937		ldi		a0,#msgInit	;	tell who we are
FFFC2044 B6C90913
FFFC2048 2D1010EF		call	PRMESG
FFFC204C 00002937		ldi		a0,#TXTBGN	;	init. end-of-program pointer
FFFC2050 80090913
FFFC2054 71202223		sw		a0,TXTUNF
FFFC2058 00008937		ldi		a0,#ENDMEM	;	get address of end of memory
FFFC205C 00090913
FFFC2060 00080937		ldi		a0,#$7F800
FFFC2064 80090913
FFFC2068 79202E23		sw		a0,STKBOT
FFFC206C 00008937		ldi		a0,#ENDMEM
FFFC2070 00090913
FFFC2074 71202623		sw		a0,VAREND
FFFC2078 CE090913		sub		a0,a0,#800 	;   100 vars
FFFC207C 71202423		sw    a0,VARBGN
FFFC2080 44C000EF		call  clearVars   ; clear the variable area
FFFC2084 7A002223		sw		r0,IRQROUT
FFFC2088 70802903		lw    a0,VARBGN   ; calculate number of bytes free
FFFC208C 70402983		lw		a1,TXTUNF
FFFC2090 41390933		sub   a0,a0,a1
FFFC2094 00606993		ldi		a1,#6		; max 6 digits
FFFC2098 00A06A13		ldi		a2,#10	; base 10
FFFC209C 7AC010EF		call  PRTNUM
FFFC20A0 FFFC4937		ldi		a0,#msgBytesFree
FFFC20A4 C0D90913
FFFC20A8 271010EF		call	PRMESG
                        	WSTART:
FFFC20AC 70002823		sw		x0,LOPVAR   ; initialize internal variables
FFFC20B0 70002A23		sw		x0,STKGOS
FFFC20B4 70002C23		sw		x0,CURRNT	;	current line number pointer = 0
FFFC20B8 00080737		ldi		$sp,#STACKOFFS	;	init S.P. again, just in case
FFFC20BC FFC70713
FFFC20C0 FFFC4937		ldi		a0,#msgReady	;	display "Ready"
FFFC20C4 C1A90913
FFFC20C8 251010EF		call	PRMESG
                        	BASPRMPT:
FFFC20CC 03E06913		ldi		a0,#'>'		; Prompt with a '>' and
FFFC20D0 45C010EF		call	GETLN		; read a line.
FFFC20D4 195010EF		call	TOUPBUF 	; convert to upper case
FFFC20D8 000E64B3		mov		$s6,$t2		; save pointer to end of line
FFFC20DC 71C06E13		ldi		$t2,#BUFFER	; point to the beginning of line
FFFC20E0 0E5010EF		call	TSTNUM		; is there a number there?
FFFC20E4 155010EF		call	IGNBLK		; skip trailing blanks
FFFC20E8 000E4483		lbu		$s6,[$t2]
FFFC20EC 00D4C493		xor		$s6,$s6,#CR	; s6 = flag empty line
                        	; does line no. exist? (or nonzero?)
FFFC20F0 26088863		beq		v1,x0,DIRECT		; if not, it's a direct statement
FFFC20F4 00100DB7		ldi		$t1,#$FFFFF
FFFC20F8 FFFD8D93
FFFC20FC 010DD863		ble		v0,$t1,ST2	; see if line no. is <= 16 bits
FFFC2100 FFFC4937		ldi		a0,#msgLineRange	; if not, we've overflowed
FFFC2104 C3590913
FFFC2108 3E00106F		jmp		ERROR
                        	ST2:
FFFC210C 00086933	  mov		$a0,$v0		; a0 = line number
FFFC2110 000E6433	  mov		$s5,$t2			; save line buffer pointer
FFFC2114 FFCE0E13		sub		$t2,$t2,#4
FFFC2118 012E2023	  sw		$a0,[$t2]		;	This will end up in buffer
FFFC211C 504010EF		call	FNDLN		; find this line in save area
FFFC2120 000EE533		mov		$s7,$t3		; save possible line pointer
FFFC2124 00080663		beq		$v0,$x0,INSLINE	; if not found, insert
FFFC2128 000EE933		mov		$a0,$t3
FFFC212C 044000EF		call	DeleteLine
                        	INSLINE:
FFFC2130 F8048EE3		beq		$s6,$x0,BASPRMPT	; line was empty
FFFC2134 00046933		mov		$a0,$s5			; a0 = buffer pointer	
                        		; GetBuflen just get the length of the text.
                        		; A line number is stuffed just before the text
                        		; so length needs to be adjusted by 4.
FFFC2138 0A0000EF		call	GetBuflen
FFFC213C 00480393		add		$s4,$v0,#4
FFFC2140 00056933		mov		$a0,$s7
FFFC2144 0003E9B3		mov		$a1,$s4
FFFC2148 0BC000EF		call	OpenSpace
FFFC214C 00081863		bne		$v0,$x0,.0001	; space available?
FFFC2150 FFFC4937		ldi		a0,#msgTooBig	; no space available
FFFC2154 D0790913
FFFC2158 3900106F		jmp		ERROR
                        	.0001:
FFFC215C 00056933		mov		$a0,$s7			; target
FFFC2160 FFC40993		sub		$a1,$s5,#4	; source (incl lineno)
FFFC2164 0003EA33		mov		$a2,$s4			; length
FFFC2168 050000EF		call	InsertLine
FFFC216C F60000E3		bra		BASPRMPT
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = pointer to line to delete
                        	; Modifies:
                        	;		t0,t1,t2,t3
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	DeleteLine:
                        		; Find the end of the line to delete
FFFC2170 00490D13		add		$t0,$a0,#4		; t0 = pointer to line past line number
FFFC2174 00D06E13		ldi		$t2,#CR
FFFC2178 70402E83		lw		$t3,TXTUNF		; last text address
                        	.0002:
FFFC217C 000D4D83		lbu		$t1,[$t0]
FFFC2180 000D8A63		beq		$t1,$x0,.0003	; might be null
FFFC2184 01CD8663		beq		$t1,$t2,.0001	; lines end with CR
FFFC2188 001D0D13		add		$t0,$t0,#1
FFFC218C FFDD68E3		bltu	$t0,$t3,.0002	; end of program?
                        	.0001:
FFFC2190 001D0D13		add		$t0,$t0,#1
                        	.0003:
                        		; pull text after eol overtop
FFFC2194 000D4F03		lbu		$t4,[$t0]			; copy from next line
FFFC2198 01E90023		sb		$t4,[$a0]			; overtop deleted line
FFFC219C 001D0D13		add		$t0,$t0,#1		; increment pointers
FFFC21A0 00190913		add		$a0,$a0,#1
FFFC21A4 FFAEF8E3		bleu	$t0,$t3,.0003	; to end of program
                        		; update end of text
FFFC21A8 412D0933		sub		$a0,$t0,$a0		; difference of pointers = length
FFFC21AC 412E8EB3		sub		$t3,$t3,$a0		
FFFC21B0 71D02223		sw		$t3,TXTUNF
FFFC21B4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = insertion point
                        	; 	a1 = source buffer
                        	; 	a2 = length
                        	; Modifies:
                        	;		a0,a1,a2,t1
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	InsertLine:
FFFC21B8 000A0E63		beq		$a2,$x0,.done		; zero length? Probably a SW error
                        	.0001:
FFFC21BC 0009CD83		lbu		$t1,[$a1]				; get from source text
FFFC21C0 01B90023		sb		$t1,[$a0]				; store to insertion point
FFFC21C4 00198993		add		$a1,$a1,#1			; increment pointers
FFFC21C8 00190913		add		$a0,$a0,#1
FFFC21CC FFFA0A13		sub		$a2,$a2,#1			; decrement length
FFFC21D0 FF4066E3		bgtu	$a2,$x0,.0001
                        	.done:
FFFC21D4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; GetBuflen - get the length of text in a buffer. The length is taken up to
                        	; the first null character or carriage return character encountered.
                        	;
                        	; Parameters:
                        	;		a0 = pointer to buffer
                        	; Modifies:
                        	;		t2,t3,t5
                        	; Returns:
                        	;		v0 = length of data in buffer
                        	;------------------------------------------------------------------------------
                        	
                        	GetBuflen:
FFFC21D8 00006813		ldi		$v0,#0
FFFC21DC 00D06E93		ldi		$t3,#CR
FFFC21E0 00096FB3		mov		$t5,$a0
                        	.0002:
FFFC21E4 000FCE03		lbu		$t2,[$t5]
FFFC21E8 001F8F93		add		$t5,$t5,#1
FFFC21EC 000E0A63		beq		$t2,$x0,.0001
FFFC21F0 01DE0663		beq		$t2,$t3,.0004
FFFC21F4 00180813		add		$v0,$v0,#1
FFFC21F8 FE0006E3		bra		.0002
                        	.0004:
FFFC21FC 00180813		add		$v0,$v0,#1
                        	.0001:
FFFC2200 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = place to insert line
                        	; 	a1 = buffer length
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		v0 = 1 if successful, 0 if not enough room available
                        	;------------------------------------------------------------------------------
                        	
                        	OpenSpace:
FFFC2204 70402E03		lw		$t2,TXTUNF
FFFC2208 000E6EB3		mov		$t3,$t2				; t3 = old end of text
FFFC220C 013E0E33		add		$t2,$t2,$a1		; increment end of text by buffer length
FFFC2210 70802D83		lw		$t1,VARBGN		; compare to start of variables
FFFC2214 03BE7263		bgeu	$t2,$t1,.noSpace	; enough room?
FFFC2218 71C02223		sw		$t2,TXTUNF		; yes, set new end of text
                        	.0003:
FFFC221C 000ECF83		lbu		$t5,[$t3]			; copy old text
FFFC2220 01FE0023		sb		$t5,[$t2]			; to new text loc
FFFC2224 FFFE8E93		sub		$t3,$t3,#1		; decrement pointers
FFFC2228 FFFE0E13		sub		$t2,$t2,#1
FFFC222C FF2EF8E3		bgeu	$t3,$a0,.0003	; until insert point reached
FFFC2230 00106813		ldi		$v0,#1				; return success
FFFC2234 00008067		ret
                        	.noSpace:
FFFC2238 00006813		ldi		$v0,#0
FFFC223C 00008067		ret	
                        	
                        	;******************************************************************
                        	;
                        	; *** Tables *** DIRECT *** EXEC ***
                        	;
                        	; This section of the code tests a string against a table. When
                        	; a match is found, control is transferred to the section of
                        	; code according to the table.
                        	;
                        	; At 'EXEC', r8 should point to the string, r9 should point to
                        	; the character table, and r10 should point to the execution
                        	; table. At 'DIRECT', r8 should point to the string, r9 and
                        	; r10 will be set up to point to TAB1 and TAB1_1, which are
                        	; the tables of all direct and statement commands.
                        	;
                        	; A '.' in the string will terminate the test and the partial
                        	; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                        	; 'PRIN.', or 'PRINT' will all match 'PRINT'.
                        	;
                        	; There are two tables: the character table and the execution
                        	; table. The character table consists of any number of text items.
                        	; Each item is a string of characters with the last character's
                        	; high bit set to one. The execution table holds a 32-bit
                        	; execution addresses that correspond to each entry in the
                        	; character table.
                        	;
                        	; The end of the character table is a 0 byte which corresponds
                        	; to the default routine in the execution table, which is
                        	; executed if none of the other table items are matched.
                        	;
                        	; Character-matching tables:
                        	TAB1:
FFFC2240 D453494C		db	"LIS",'T'+0x80        ; Direct commands
FFFC2244 C4414F4C		db	"LOA",'D'+0x80
FFFC2248 52D7454E		db	"NE",'W'+0x80
FFFC224B 53CE5552		db	"RU",'N'+0x80
FFFC224E C5564153		db	"SAV",'E'+0x80
                        	TAB2:
FFFC2252 D458454E		db	"NEX",'T'+0x80         ; Direct / statement
FFFC2256 49D4454C		db	"LE",'T'+0x80
FFFC2259 4F47C649		db	"I",'F'+0x80
FFFC225B CF544F47		db	"GOT",'O'+0x80
FFFC225F 55534F47		db	"GOSU",'B'+0x80
FFFC2263 544552C2
FFFC2264 55544552		db	"RETUR",'N'+0x80
FFFC2268 4552CE52
FFFC226A 46CD4552		db	"RE",'M'+0x80
FFFC226D 49D24F46		db	"FO",'R'+0x80
FFFC2270 55504E49		db	"INPU",'T'+0x80
FFFC2274 495250D4
FFFC2275 4E495250		db	"PRIN",'T'+0x80
FFFC2279 4B4F50D4
FFFC227A C54B4F50		db	"POK",'E'+0x80
FFFC227E 454B4F50		db	"POKE",'W'+0x80
FFFC2282 4B4F50D7
FFFC2283 454B4F50		db	"POKE",'H'+0x80
FFFC2287 454959C8
FFFC2288 4C454959		db	"YIEL",'D'+0x80
FFFC228C 4F5453C4
FFFC228D D04F5453		db	"STO",'P'+0x80
FFFC2291 53C55942		db	"BY",'E'+0x80
FFFC2294 43D35953		db	"SY",'S'+0x80
FFFC2297 43D34C43		db	"CL",'S'+0x80
FFFC229A 52D24C43	    db  "CL",'R'+0x80
FFFC229D C6434452	    db	"RDC",'F'+0x80
FFFC22A1 52494E4F	    db	"ONIR",'Q'+0x80
FFFC22A5 494157D1
FFFC22A6 D4494157	    db	"WAI",'T'+0x80
FFFC22AA 45455000		db	0
                        	TAB4:
FFFC22AB CB454550		db	"PEE",'K'+0x80         ;Functions
FFFC22AF 4B454550		db	"PEEK",'W'+0x80
FFFC22B3 454550D7
FFFC22B4 4B454550		db	"PEEK",'H'+0x80
FFFC22B8 C44E52C8
FFFC22B9 41C44E52		db	"RN",'D'+0x80
FFFC22BC 53D34241		db	"AB",'S'+0x80
FFFC22BF 54CE4753		db  "SG",'N'+0x80
FFFC22C2 CB434954		db	"TIC",'K'+0x80
FFFC22C6 C55A4953		db	"SIZ",'E'+0x80
FFFC22CA 00D25355		db  "US",'R'+0x80
FFFC22CD 00CF5400		db	0
                        	TAB5:
FFFC22CE 5300CF54		db	"T",'O'+0x80           ;"TO" in "FOR"
FFFC22D0 45545300		db	0
                        	TAB6:
FFFC22D1 D0455453		db	"STE",'P'+0x80         ;"STEP" in "FOR"
FFFC22D5 3CBD3E00		db	0
                        	TAB8:
FFFC22D6 BE3CBD3E		db	'>','='+0x80           ;Relational operators
FFFC22D8 BDBEBE3C		db	'<','>'+0x80
FFFC22DA BD3CBDBE		db	'>'+0x80
FFFC22DB BCBD3CBD		db	'='+0x80
FFFC22DC 00BCBD3C		db	'<','='+0x80
FFFC22DE 4E4100BC		db	'<'+0x80
FFFC22DF C44E4100		db	0
                        	TAB9:
FFFC22E0 00C44E41	    db  "AN",'D'+0x80
FFFC22E3 00D24F00	    db  0
                        	TAB10:
FFFC22E4 0000D24F	    db  "O",'R'+0x80
FFFC22E6 253C0000	    db  0
                        	
                        	;* Execution address tables:
                        	; We save some bytes by specifiying only the low order 16 bits of the address
                        	;
FFFC22E7 04253C00		align	
                        	
                        	TAB1_1:
FFFC22E8 2A04253C		dh	LISTX			;Direct commands
FFFC22EA 23E42A04		dh	LOAD3
FFFC22EC 240C23E4		dh	NEW
FFFC22EE 2A68240C		dh	RUN
FFFC22F0 27382A68		dh	SAVE3
                        	TAB2_1:
FFFC22F2 28BC2738		dh	NEXT		;	Direct / statement
FFFC22F4 27B028BC		dh	LET
FFFC22F6 24A027B0		dh	IF0
FFFC22F8 262424A0		dh	GOTO
FFFC22FA 26682624		dh	GOSUB
FFFC22FC 27BC2668		dh	RETURN
FFFC22FE 26AC27BC		dh	IF2			; REM
FFFC2300 27F026AC		dh	FOR
FFFC2302 258427F0		dh	INPUT
FFFC2304 2BC02584		dh	PRINT
FFFC2306 2BEC2BC0		dh	POKE
FFFC2308 2C182BEC		dh	POKEW
FFFC230A 24002C18		dh	POKEH
FFFC230C 23F82400		dh	YIELD0
FFFC230E 202023F8		dh	STOP
FFFC2310 2C502020		dh	GOBYE
FFFC2312 01AE2C50		dh	SYSX
FFFC2314 24C401AE		dh	_cls
FFFC2316 01B024C4		dh  _clr
FFFC2318 250401B0		dh	_rdcf
FFFC231A 252C2504		dh  ONIRQ
FFFC231C 28B0252C		dh	WAITIRQ
FFFC231E 328028B0		dh	DEFLT
                        	TAB4_1:
FFFC2320 32983280		dh	PEEK			;Functions
FFFC2322 32B03298		dh	PEEKW
FFFC2324 330832B0		dh	PEEKH
FFFC2326 00003308		dh	RND
FFFC2328 339C0000		dh	ABS
FFFC232A 3388339C		dh  SGN
FFFC232C 33D83388		dh	TICKX
FFFC232E 32C833D8		dh	SIZEX
FFFC2330 304832C8		dh  USRX
FFFC2332 26CC3048		dh	XP40
                        	TAB5_1
FFFC2334 34E026CC		dh	FR1			;"TO" in "FOR"
FFFC2336 26E834E0		dh	QWHAT
                        	TAB6_1
FFFC2338 26F026E8		dh	FR2			;"STEP" in "FOR"
FFFC233A 2E0026F0		dh	FR3
                        	TAB8_1
FFFC233C 2E182E00		dh	XP11	;>=		Relational operators
FFFC233E 2E302E18		dh	XP12	;<>
FFFC2340 2E602E30		dh	XP13	;>
FFFC2342 2E482E60		dh	XP15	;=
FFFC2344 2E782E48		dh	XP14	;<=
FFFC2346 2EB82E78		dh	XP16	;<
FFFC2348 2D102EB8		dh	XP17
                        	TAB9_1
FFFC234A 2D242D10	    dh  XP_AND
FFFC234C 2CB02D24	    dh  XP_ANDX
                        	TAB10_1
FFFC234E 2CC42CB0	    dh  XP_OR
FFFC2350 00002CC4	    dh  XP_ORX
                        	
                        	;*
                        	; r3 = match flag (trashed)
                        	; r9 = text table
                        	; r10 = exec table
                        	; r11 = trashed
FFFC2352 00000000		align	1
FFFC2356 00000000
FFFC235A 00000000
FFFC235E 2EB70000
                        	
                        	//message "DIRECT"
                        	DIRECT:
FFFC2360 FFFC2EB7		ldi		$t3,#TAB1
FFFC2364 240E8E93
FFFC2368 FFFC2F37		ldi		$t4,#TAB1_1
FFFC236C 2E8F0F13
                        	EXEC:
FFFC2370 6C8010EF		call	IGNBLK		; ignore leading blanks
FFFC2374 000E6FB3		mov		$t5,$t2		; save the pointer
FFFC2378 000061B3		mov		r3,r0		; clear match flag
                        	EXLP:
FFFC237C 000E4903		lbu		a0,[$t2]		; get the program character
FFFC2380 001E0E13		add		$t2,$t2,#1
FFFC2384 000EC983		lbu		a1,[$t3]		; get the table character
FFFC2388 00099663		bne		a1,x0,EXNGO		; If end of table,
FFFC238C 000FEE33		mov		$t2,$t5		;	restore the text pointer and...
FFFC2390 04000263		bra		EXGO		;   execute the default.
                        	EXNGO:
FFFC2394 04390063		beq		a0,r3,EXGO	; Else check for period... if so, execute
FFFC2398 07F9F993		and		a1,a1,#0x7f	; ignore the table's high bit
FFFC239C 03298263		beq		a1,a0,EXMAT	;		is there a match?
FFFC23A0 002F0F13		add		$t4,$t4,#2	;if not, try the next entry
FFFC23A4 000FEE33		mov		$t2,$t5		; reset the program pointer
FFFC23A8 000061B3		mov		r3,x0		; sorry, no match
                        	EX1:
FFFC23AC 000EC903		lbu		a0,[$t3]		; get to the end of the entry
FFFC23B0 001E8E93		add		$t3,$t3,#1
FFFC23B4 08097D93		and		$t1,$a0,#$80
FFFC23B8 FE0D8AE3		beq		$t1,$r0,EX1	; test for bit 7 set
FFFC23BC FC0000E3		bra		EXLP		; back for more matching
                        	EXMAT:
FFFC23C0 02E06193		ldi		r3,#'.'		; we've got a match so far
FFFC23C4 000EC903		lbu		a0,[$t3]		; end of table entry?
FFFC23C8 001E8E93		add		$t3,$t3,#1
FFFC23CC 08097D93		and		$t1,$a0,#$80
FFFC23D0 FA0D86E3		beq		$t1,$r0,EXLP		; test for bit 7 set, if not, go back for more
                        	EXGO:
                        		; execute the appropriate routine
FFFC23D4 000F5903		lhu		a0,[$t4]	; get the low mid order byte
FFFC23D8 FFFC0637		or		a0,a0,#$FFFC0000	; add in ROM base
FFFC23DC 01266933
FFFC23E0 00090067		jmp		[a0]
                        	
                        	    
                        	;******************************************************************
                        	;
                        	; What follows is the code to execute direct and statement
                        	; commands. Control is transferred to these points via the command
                        	; table lookup code of 'DIRECT' and 'EXEC' in the last section.
                        	; After the command is executed, control is transferred to other
                        	; sections as follows:
                        	;
                        	; For 'LISTX', 'NEW', and 'STOP': go back to the warm start point.
                        	; For 'RUN': go execute the first stored line if any; else go
                        	; back to the warm start point.
                        	; For 'GOTO' and 'GOSUB': go execute the target line.
                        	; For 'RETURN' and 'NEXT'; go back to saved return line.
                        	; For all others: if 'CURRNT' is 0, go to warm start; else go
                        	; execute next command. (This is done in 'FINISH'.)
                        	;
                        	;******************************************************************
                        	;
                        	; *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                        	;
                        	; 'NEW<CR>' sets TXTUNF to point to TXTBGN
                        	;
                        	
                        	NEW:
FFFC23E4 0B4010EF		call	ENDCHK
FFFC23E8 00002837		ldi		v0,#TXTBGN
FFFC23EC 80080813
FFFC23F0 71002223		sw		v0,TXTUNF	;	set the end pointer
FFFC23F4 0D8000EF		call  clearVars
                        	
                        	; 'STOP<CR>' goes back to WSTART
                        	;
                        	STOP:
FFFC23F8 0A0010EF		call	ENDCHK
FFFC23FC CB1FF06F		jmp		WSTART		; WSTART will reset the stack
                        	
                        	;------------------------------------------------------------------------------
                        	; YIELD suspends execution of TinyBasic by switching to the next ready task.
                        	;------------------------------------------------------------------------------
                        	
                        	YIELD0:
FFFC2400 00D06913		ldi		a0,#13
FFFC2404 00000073		ecall
FFFC2408 2140006F		jmp		FINISH
                        	
                        	;------------------------------------------------------------------------------
                        	; 'RUN<CR>' finds the first stored line, stores its address
                        	; in CURRNT, and starts executing it. Note that only those
                        	; commands in TAB2 are legal for a stored program.
                        	;
                        	; There are 3 more entries in 'RUN':
                        	; 'RUNNXL' finds next line, stores it's address and executes it.
                        	; 'RUNTSL' stores the address of this line and executes it.
                        	; 'RUNSML' continues the execution on same line.
                        	;
                        	RUN:
FFFC240C 08C010EF		call	ENDCHK
FFFC2410 00002E37		ldi		$t2,#TXTBGN	;	set pointer to beginning
FFFC2414 800E0E13
FFFC2418 71C02C23		sw		$t2,CURRNT
FFFC241C 0B0000EF		call  clearVars
                        	
                        	RUNNXL:					; RUN <next line>
FFFC2420 71802E03		lw		$t2,CURRNT	; executing a program?
FFFC2424 DA0E1BE3		bne		$t2,x0,.0001	; if not, we've finished a direct stat.
                        	RUN2:
FFFC2428 C85FF06F		jmp		WSTART
                        	.0001:
FFFC242C 7A402903		lw		a0,IRQROUT		; are we handling IRQ's ?
FFFC2430 02090E63		beq		a0,x0,RUN1
FFFC2434 7B402D83		lw		$t1,IRQFlag		; was there an IRQ ?
FFFC2438 020D8A63		beq		$t1,x0,RUN1
FFFC243C 7A002A23		sw		x0,IRQFlag
FFFC2440 2C8010EF		call	PUSHA_		; the same code as a GOSUB
FFFC2444 FF470713		sub		$sp,$sp,#12
FFFC2448 71402903		lw		a0,STKGOS
FFFC244C 01272023		sw		a0,[$sp]
FFFC2450 71802903		lw		a0,CURRNT
FFFC2454 01272223		sw		a0,4[$sp]
FFFC2458 01C72423		sw		$t2,8[$sp]
FFFC245C 70002823		sw		x0,LOPVAR		; load new values
FFFC2460 70E02A23		sw		$sp,STKGOS
FFFC2464 7A402E83		lw		$t3,IRQROUT
FFFC2468 00000C63		bra		RUNTSL
                        	RUN1:
FFFC246C 00002E83		lw		$t3,$t2
FFFC2470 00006933		mov		a0,x0
FFFC2474 1CC010EF		call	FNDLNP		; else find the next line number
FFFC2478 70402D83		lw		$t1,TXTUNF	; if we've fallen off the end, stop
FFFC247C FBBEF6E3		bgeu	$t3,$t1,RUN2
                        	
                        	RUNTSL					; RUN <this line>
FFFC2480 71D02C23		sw		$t3,CURRNT	; set CURRNT to point to the line no.
FFFC2484 004E8E13		add		$t2,$t3,#4	; set the text pointer to
                        	
                        	RUNSML                 ; RUN <same line>
FFFC2488 660010EF		call	CHKIO		; see if a control-C was pressed
FFFC248C FFFC2EB7		ldi		$t3,#TAB2		; find command in TAB2
FFFC2490 252E8E93
FFFC2494 FFFC2F37		ldi		$t4,#TAB2_1
FFFC2498 2F2F0F13
FFFC249C ED5FF06F		jmp		EXEC		; and execute it
                        	
                        	
                        	;******************************************************************
                        	; 'GOTO expr<CR>' evaluates the expression, finds the target
                        	; line, and jumps to 'RUNTSL' to do it.
                        	;******************************************************************
                        	;
                        	GOTO:
FFFC24A0 7DC000EF		call	OREXPR		;evaluate the following expression
FFFC24A4 000862B3		mov   r5,v0
FFFC24A8 7F1000EF		call 	ENDCHK		;must find end of line
FFFC24AC 0002E933		mov   a0,r5
FFFC24B0 170010EF		call 	FNDLN		; find the target line
FFFC24B4 FC0816E3		bne		v0,x0,RUNTSL; go do it
FFFC24B8 FFFC4937		ldi		a0,#msgBadGotoGosub
FFFC24BC CD590913
FFFC24C0 0280106F		jmp		ERROR		; no such line no.
                        	
                        	_clr:
FFFC24C4 008000EF	    call    clearVars
FFFC24C8 1540006F	    jmp     FINISH
                        	
                        	; Clear the variable area of memory
                        	clearVars:
FFFC24CC FF870713		sub		$sp,$sp,#8
FFFC24D0 00672023		sw		r6,[$sp]
FFFC24D4 00172223		sw		$ra,4[$sp]
FFFC24D8 06406313	  ldi   r6,#100    	; number of word pairs to clear
FFFC24DC 70802803	  lw    v0,VARBGN
                        	.cv1:
FFFC24E0 00082023	  sw		x0,[$v0]		; variable name
FFFC24E4 00082223	  sw		x0,4[$v0]		; and value
FFFC24E8 00880813	  add		v0,v0,#8
FFFC24EC FFF30313	  sub		r6,r6,#1
FFFC24F0 FE6048E3		bgt		r6,x0,.cv1
FFFC24F4 00072303	  lw		r6,[$sp]
FFFC24F8 00472083	  lw		$ra,4[$sp]
FFFC24FC 00870713	  add		$sp,$sp,#8
FFFC2500 00008067	  ret
                        	
                        	;******************************************************************
                        	; ONIRQ <line number>
                        	; ONIRQ sets up an interrupt handler which acts like a specialized
                        	; subroutine call. ONIRQ is coded like a GOTO that never executes.
                        	;******************************************************************
                        	;
                        	ONIRQ:
FFFC2504 778000EF		call	OREXPR		;evaluate the following expression
FFFC2508 000862B3		mov   r5,v0
FFFC250C 78D000EF		call 	ENDCHK		;must find end of line
FFFC2510 0002E933		mov   a0,r5
FFFC2514 10C010EF		call 	FNDLN		; find the target line
FFFC2518 00081663		bne		v0,r0,ONIRQ1
FFFC251C 7A002223		sw		x0,IRQROUT
FFFC2520 0FC0006F		jmp		FINISH
                        	ONIRQ1:
FFFC2524 7BD02223		sw		$t3,IRQROUT
FFFC2528 0F40006F		jmp		FINISH
                        	
                        	WAITIRQ:
FFFC252C 5BC010EF		call	CHKIO		; see if a control-C was pressed
FFFC2530 7B402D83		lw		$t1,IRQFlag
FFFC2534 FE0D8CE3		beq		$t1,x0,WAITIRQ
FFFC2538 0E40006F		jmp		FINISH
                        	
                        	
                        	;******************************************************************
                        	; LIST
                        	;
                        	; LISTX has two forms:
                        	; 'LIST<CR>' lists all saved lines
                        	; 'LIST #<CR>' starts listing at the line #
                        	; Control-S pauses the listing, control-C stops it.
                        	;******************************************************************
                        	;
                        	LISTX:
FFFC253C 488010EF		call		TSTNUM		; see if there's a line no.
FFFC2540 000862B3		mov      r5,v0
FFFC2544 755000EF		call		ENDCHK		; if not, we get a zero
FFFC2548 0002E933		mov      a0,r5
FFFC254C 0D4010EF		call		FNDLN		; find this or next line
                        	LS1:
FFFC2550 00081663		bne		v0,r0,LS4
                        	LS5:
FFFC2554 70402D83		lw		$t1,TXTUNF
FFFC2558 B5BEFAE3		bgeu	$t3,$t1,WSTART	; warm start if we passed the end
                        	LS4:
FFFC255C 000EE933		mov		a0,$t3
FFFC2560 3BC010EF		call	PRTLN		; print the line
FFFC2564 00086EB3		mov		$t3,$v0		; set pointer for next
FFFC2568 580010EF		call	CHKIO		; check for listing halt request
FFFC256C 00080A63		beq		v0,x0,LS3
FFFC2570 01306D93		ldi		$t1,#CTRLS
FFFC2574 01B81663		bne		v0,$t1,LS3; pause the listing?
                        	LS2:
FFFC2578 570010EF		call 	CHKIO		; if so, wait for another keypress
FFFC257C FE080EE3		beq		v0,r0,LS2
                        	LS3:
                        	;	mov		$v0,$x0
FFFC2580 FC000AE3		bra		LS5
                        	;	mov		a0,r0
                        	;	call	FNDSKP	;FNDLNP		; find the next line
                        	;	bra		LS1
                        	
                        	
                        	;******************************************************************
                        	; PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                        	; where '....' is a list of expressions, formats, back-arrows,
                        	; and strings.	These items a separated by commas.
                        	;
                        	; A format is a pound sign followed by a number.  It controls
                        	; the number of spaces the value of an expression is going to
                        	; be printed in.  It stays effective for the rest of the print
                        	; command unless changed by another format.  If no format is
                        	; specified, 11 positions will be used.
                        	;
                        	; A string is quoted in a pair of single- or double-quotes.
                        	;
                        	; An underline (back-arrow) means generate a <CR> without a <LF>
                        	;
                        	; A <CR LF> is generated after the entire list has been printed
                        	; or if the list is empty.  If the list ends with a semicolon,
                        	; however, no <CR LF> is generated.
                        	;******************************************************************
                        	;
                        	PRINT:
FFFC2584 00B06293		ldi		r5,#11		; D4 = number of print spaces
FFFC2588 3F0010EF		call	TSTC		; if null list and ":"
FFFC258C 0000003A		dw		':'
FFFC2590 00000663		bra		PR2
FFFC2594 57C010EF		call	CRLF		; give CR-LF and continue
FFFC2598 EF1FF06F		jmp		RUNSML		;		execution on the same line
                        	PR2:
FFFC259C 3DC010EF		call	TSTC		;if null list and <CR>
FFFC25A0 0000000D		dw		CR
FFFC25A4 00000663		bra		PR0
FFFC25A8 568010EF		call	CRLF		;also give CR-LF and
FFFC25AC E75FF06F		jmp		RUNNXL		;execute the next line
                        	PR0:
FFFC25B0 3C8010EF		call	TSTC		;else is it a format?
FFFC25B4 00000023		dw		'#'
FFFC25B8 00000863		bra		PR1
FFFC25BC 6C0000EF		call	OREXPR		; yes, evaluate expression
FFFC25C0 000862B3		mov		r5,v0	; and save it as print width
FFFC25C4 02000263		bra		PR3		; look for more to print
                        	PR1:
FFFC25C8 3B0010EF		call	TSTC	;	is character expression? (MRL)
FFFC25CC 00000024		dw		'$'
FFFC25D0 00000863		bra		PR4
FFFC25D4 6A8000EF		call	OREXPR	;	yep. Evaluate expression (MRL)
FFFC25D8 A31FF0EF		call	GOOUT	;	print low byte (MRL)
FFFC25DC 00000663		bra		PR3		;look for more. (MRL)
                        	PR4:
FFFC25E0 1D4010EF		call	QTSTG	;	is it a string?
                        		; the following branch must occupy only 1 word!
FFFC25E4 02000063		bra		PR8		;	if not, must be an expression
                        	PR3:
FFFC25E8 390010EF		call		TSTC	;	if ",", go find next
FFFC25EC 0000002C		dw		','
FFFC25F0 00000663		bra		PR6
FFFC25F4 669000EF		call		FIN		;in the list.
FFFC25F8 FA000CE3		bra		PR0
                        	PR6:
FFFC25FC 514010EF		call		CRLF		;list ends here
FFFC2600 01C0006F		jmp		FINISH
                        	PR8:
FFFC2604 678000EF		call	OREXPR		; evaluate the expression
FFFC2608 00086933		mov		a0,v0
FFFC260C 00506993		ldi		a1,#5		; set the width
FFFC2610 00A06A13		ldi		a2,#10
FFFC2614 234010EF		call	PRTNUM		; print its value
FFFC2618 FC0008E3		bra		PR3			; more to print?
                        	
                        	
                        	FINISH:
FFFC261C 641000EF		call	FIN		; Check end of command
FFFC2620 6C10006F		jmp		QWHAT	; print "What?" if wrong
                        	
                        	
                        	;*******************************************************************
                        	;
                        	; *** GOSUB *** & RETURN ***
                        	;
                        	; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                        	; except that the current text pointer, stack pointer, etc. are
                        	; saved so that execution can be continued after the subroutine
                        	; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                        	; recursive), the save area must be stacked.  The stack pointer
                        	; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                        	; If we are in the main routine, 'STKGOS' is zero (this was done
                        	; in the initialization section of the interpreter), but we still
                        	; save it as a flag for no further 'RETURN's.
                        	;******************************************************************
                        	;
                        	GOSUB:
FFFC2624 0E4010EF		call	PUSHA_		; save the current 'FOR' parameters
FFFC2628 654000EF		call	OREXPR		; get line number
FFFC262C 00086933		mov		$a0,$v0
FFFC2630 7F1000EF		call	FNDLN		; find the target line
FFFC2634 00081863		bne		v0,r0,gosub1
FFFC2638 FFFC4937		ldi		a0,#msgBadGotoGosub
FFFC263C CD590913
FFFC2640 6A90006F		jmp		ERROR		; if not there, say "How?"
                        	gosub1:
FFFC2644 FF470713		sub		$sp,$sp,#12
FFFC2648 71402903		lw		a0,STKGOS	; 'STKGOS'
FFFC264C 01272023		sw		a0,[$sp]
FFFC2650 71802903		lw		a0,CURRNT	; found it, save old 'CURRNT'...
FFFC2654 01272223		sw		a0,4[$sp]
FFFC2658 01C72423		sw		$t2,8[$sp]
FFFC265C 70002823		sw		$x0,LOPVAR		; load new values
FFFC2660 70E02A23		sw		$sp,STKGOS
FFFC2664 E1DFF06F		jmp		RUNTSL
                        	
                        	
                        	;******************************************************************
                        	; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                        	; returns the execution to the command after the most recent
                        	; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                        	; a 'GOSUB' and is thus an error.
                        	;******************************************************************
                        	;
                        	RETURN:
FFFC2668 631000EF		call	ENDCHK		; there should be just a <CR>
FFFC266C 71402983		lw		a1,STKGOS		; get old stack pointer
FFFC2670 00099863		bne		a1,x0,return1
FFFC2674 FFFC4937		ldi		a0,#msgRetWoGosub
FFFC2678 CF190913
FFFC267C 66D0006F		jmp		ERROR		; if zero, it doesn't exist
                        	return1:
FFFC2680 0009E733		mov		$sp,a1		; else restore it
FFFC2684 00072903		lw		a0,[$sp]
FFFC2688 00470713		add		$sp,$sp,#4
FFFC268C 71202A23		sw		a0,STKGOS	; and the old 'STKGOS'
FFFC2690 00072903		lw		a0,[$sp]
FFFC2694 00470713		add		$sp,$sp,#4
FFFC2698 71202C23		sw		a0,CURRNT	; and the old 'CURRNT'
FFFC269C 00072E03		lw		$t2,[$sp]	; and the old text pointer
FFFC26A0 00470713		add		$sp,$sp,#4
FFFC26A4 02C010EF		call	POPA_		;and the old 'FOR' parameters
FFFC26A8 F75FF06F		jmp		FINISH		;and we are back home
                        	
                        	;******************************************************************
                        	; *** FOR *** & NEXT ***
                        	;
                        	; 'FOR' has two forms:
                        	; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                        	; The second form means the same thing as the first form with a
                        	; STEP of positive 1.  The interpreter will find the variable 'var'
                        	; and set its value to the current value of 'exp1'.  It also
                        	; evaluates 'exp2' and 'exp1' and saves all these together with
                        	; the text pointer, etc. in the 'FOR' save area, which consists of
                        	; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                        	; already something in the save area (indicated by a non-zero
                        	; 'LOPVAR'), then the old save area is saved on the stack before
                        	; the new values are stored.  The interpreter will then dig in the
                        	; stack and find out if this same variable was used in another
                        	; currently active 'FOR' loop.  If that is the case, then the old
                        	; 'FOR' loop is deactivated. (i.e. purged from the stack)
                        	;******************************************************************
                        	;
                        	FOR:
FFFC26AC 05C010EF		call	PUSHA_		; save the old 'FOR' save area
FFFC26B0 545000EF		call	SETVAL		; set the control variable
FFFC26B4 71002823		sw		v0,LOPVAR		; save its address
FFFC26B8 FFFC2EB7		ldi		$t3,#TAB5
FFFC26BC 2CEE8E93
FFFC26C0 FFFC2F37		ldi		$t4,#TAB5_1	; use 'EXEC' to test for 'TO'
FFFC26C4 334F0F13
FFFC26C8 CA9FF06F		jmp		EXEC
                        	FR1:
FFFC26CC 5B0000EF		call	OREXPR		; evaluate the limit
FFFC26D0 77002E23		sw		v0,LOPLMT	; save that
FFFC26D4 FFFC2EB7		ldi		$t3,#TAB6
FFFC26D8 2D1E8E93
FFFC26DC FFFC2F37		ldi		$t4,#TAB6_1	; use 'EXEC' to test for the word 'STEP
FFFC26E0 338F0F13
FFFC26E4 C8DFF06F		jmp		EXEC
                        	FR2:
FFFC26E8 594000EF		call	OREXPR		; found it, get the step value
FFFC26EC 00000463		bra		FR4
                        	FR3:
FFFC26F0 00106813		ldi		v0,#1		; not found, step defaults to 1
                        	FR4:
FFFC26F4 77002C23		sw		v0,LOPINC	; save that too
                        	FR5:
FFFC26F8 71802983		lw		a1,CURRNT
FFFC26FC 77302A23		sw		a1,LOPLN	; save address of current line number
FFFC2700 77C02823		sw		$t2,LOPPT	; and text pointer
FFFC2704 000761B3		mov		r3,$sp		; dig into the stack to find 'LOPVAR'
FFFC2708 71002303		lw		r6,LOPVAR
FFFC270C 00000463		bra		FR7
                        	FR6:
FFFC2710 01418193		add		r3,r3,#20	; look at next stack frame
                        	FR7:
FFFC2714 0001A983		lw		a1,[r3]		; is it zero?
FFFC2718 00098E63		beq		a1,x0,FR8	; if so, we're done
FFFC271C FE699AE3		bne		a1,r6,FR6	; same as current LOPVAR? nope, look some more
                        	
FFFC2720 0001E933	  mov		a0,r3	   ; Else remove 5 words from...
FFFC2724 000769B3		mov		a1,$sp
FFFC2728 01418A13		add		a2,r3,#20  ; inside the stack.
FFFC272C 79D000EF		call	MVDOWN
FFFC2730 01470713		add		$sp,$sp,#20	; set the SP 5 long words up
                        	;	lw		a0,[$sp]		; ???
                        	;	add		$sp,$sp,#4
                        	FR8:
FFFC2734 EE9FF06F	  jmp	    FINISH		; and continue execution
                        	
                        	
                        	;******************************************************************
                        	; 'NEXT var' serves as the logical (not necessarily physical) end
                        	; of the 'FOR' loop.  The control variable 'var' is checked with
                        	; the 'LOPVAR'.  If they are not the same, the interpreter digs in
                        	; the stack to find the right one and purges all those that didn't
                        	; match.  Either way, it then adds the 'STEP' to that variable and
                        	; checks the result with against the limit value.  If it is within
                        	; the limit, control loops back to the command following the
                        	; 'FOR'.  If it's outside the limit, the save area is purged and
                        	; execution continues.
                        	;******************************************************************
                        	;
                        	NEXT:
FFFC2738 00006933		mov		a0,x0		; don't allocate it
FFFC273C 181000EF		call	TSTV		; get address of variable
FFFC2740 00081863		bne		v0,x0,NX4
FFFC2744 FFFC4937		ldi		a0,#msgNextVar
FFFC2748 CB290913
FFFC274C 58000EE3		bra		ERROR		; if no variable, say "What?"
                        	NX4:
FFFC2750 00086EB3		mov		$t3,v0	; save variable's address
                        	NX0:
FFFC2754 71002903		lw		a0,LOPVAR	; If 'LOPVAR' is zero, we never...
FFFC2758 00091863		bne		a0,x0,NX5	; had a FOR loop
FFFC275C FFFC4937		ldi		a0,#msgNextFor
FFFC2760 CA090913
FFFC2764 580002E3		bra		ERROR
                        	NX5:
FFFC2768 01D90663		beq		a0,$t3,NX2	; else we check them OK, they agree
FFFC276C 765000EF		call	POPA_		; nope, let's see the next frame
FFFC2770 FE0002E3		bra		NX0
                        	NX2:
FFFC2774 000EA903		lw		a0,[$t3]		; get control variable's value
FFFC2778 77802983		lw		a1,LOPINC
FFFC277C 01390933		add		a0,a0,a1	; add in loop increment
                        	;	BVS.L	QHOW		say "How?" for 32-bit overflow
FFFC2780 012EA023		sw		a0,[$t3]		; save control variable's new value
FFFC2784 77C02183		lw		r3,LOPLMT	; get loop's limit value
FFFC2788 0009D663		bge		a1,x0,NX1	; check loop increment, branch if loop increment is positive
FFFC278C 00394E63		blt		a0,r3,NXPurge	; test against limit
FFFC2790 00000463		bra     NX3
                        	NX1:
FFFC2794 0121CA63		bgt		a0,r3,NXPurge
                        	NX3:
FFFC2798 77402E03		lw		$t2,LOPLN	; Within limit, go back to the...
FFFC279C 71C02C23		sw		$t2,CURRNT
FFFC27A0 77002E03		lw		$t2,LOPPT	; saved 'CURRNT' and text pointer.
FFFC27A4 E79FF06F		jmp		FINISH
                        	NXPurge:
FFFC27A8 729000EF	  call    POPA_        ; purge this loop
FFFC27AC E71FF06F	  jmp     FINISH
                        	
                        	
                        	;******************************************************************
                        	; *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                        	;
                        	; 'REM' can be followed by anything and is ignored by the
                        	; interpreter.
                        	;
                        	;REM
                        	;    br	    IF2		    ; skip the rest of the line
                        	; 'IF' is followed by an expression, as a condition and one or
                        	; more commands (including other 'IF's) separated by colons.
                        	; Note that the word 'THEN' is not used.  The interpreter evaluates
                        	; the expression.  If it is non-zero, execution continues.  If it
                        	; is zero, the commands that follow are ignored and execution
                        	; continues on the next line.
                        	;******************************************************************
                        	;
                        	IF0:
FFFC27B0 4CC000EF	  call	OREXPR		; evaluate the expression
                        	IF1:
FFFC27B4 00080463	  beq	  v0,x0,IF2	; is it zero? if not, continue
FFFC27B8 CD1FF06F	  jmp		RUNSML
                        	IF2:
FFFC27BC 000E6EB3	  mov		$t3,$t2	; set lookup pointer
FFFC27C0 00006933		mov		a0,x0		; find line #0 (impossible)
FFFC27C4 6C9000EF		call	FNDSKP		; if so, skip the rest of the line
FFFC27C8 00081463		bne		v0,x0,IF3; if no next line, do a warm start
FFFC27CC 8E1FF06F		jmp		WSTART
                        	IF3:
FFFC27D0 CB1FF06F		jmp		RUNTSL		; run the next line
                        	
                        	
                        	;******************************************************************
                        	; INPUT is called first and establishes a stack frame
                        	INPERR:
FFFC27D4 79802703		lw		$sp,STKINP		; restore the old stack pointer
FFFC27D8 00072903		lw		a0,[$sp]
FFFC27DC 00470713		add		$sp,$sp,#4
FFFC27E0 71202C23		sw		a0,CURRNT		; and old 'CURRNT'
FFFC27E4 00072E03		lw		$t2,[$sp]		; and old text pointer
FFFC27E8 00470713		add		$sp,$sp,#4
FFFC27EC 01470713		add		$sp,$sp,#20	; fall through will subtract 20
                        	
                        	; 'INPUT' is like the 'PRINT' command, and is followed by a list
                        	; of items.  If the item is a string in single or double quotes,
                        	; or is an underline (back arrow), it has the same effect as in
                        	; 'PRINT'.  If an item is a variable, this variable name is
                        	; printed out followed by a colon, then the interpreter waits for
                        	; an expression to be typed in.  The variable is then set to the
                        	; value of this expression.  If the variable is preceeded by a
                        	; string (again in single or double quotes), the string will be
                        	; displayed followed by a colon.  The interpreter the waits for an
                        	; expression to be entered and sets the variable equal to the
                        	; expression's value.  If the input expression is invalid, the
                        	; interpreter will print "What?", "How?", or "Sorry" and reprint
                        	; the prompt and redo the input.  The execution will not terminate
                        	; unless you press control-C.  This is handled in 'INPERR'.
                        	;
                        	INPUT:
FFFC27F0 FEC70713		sub		$sp,$sp,#20	; allocate five words on stack
FFFC27F4 00572823		sw		r5,16[$sp]	; save off r5 into stack var
                        	IP6:
FFFC27F8 01C72023		sw		$t2,[$sp]	; save in case of error
FFFC27FC 7B9000EF		call	QTSTG		; is next item a string?
FFFC2800 00000C63		bra		IP2			; nope - this branch must take only 1 word
FFFC2804 00106913		ldi		a0,#1		; allocate var
FFFC2808 0B5000EF		call	TSTV		; yes, but is it followed by a variable?
FFFC280C 08090463		beq    a0,r0,IP4   ; if not, brnch
FFFC2810 00096F33		mov		$t4,a0		; put away the variable's address
FFFC2814 04000063		bra		IP3			; if so, input to variable
                        	IP2:
FFFC2818 01C72223		sw		$t2,4[$sp]	; save off in stack var for 'PRTSTG'
FFFC281C 00106913		ldi		a0,#1
FFFC2820 09D000EF		call	TSTV		; must be a variable now
FFFC2824 00091A63		bne		a0,r0,IP7
FFFC2828 FFFC4937		ldi		a0,#msgInputVar
FFFC282C C8490913
FFFC2830 01470713		add		$sp,$sp,#20	; cleanup stack
FFFC2834 4A000AE3		bra		ERROR		; "What?" it isn't?
                        	IP7:
FFFC2838 00096F33		mov		$t4,a0		; put away the variable's address
FFFC283C 000E4283		lbu		r5,[$t2]		; get ready for 'PRTSTG' by null terminating
FFFC2840 000E0023		sb		x0,[$t2]
FFFC2844 000069B3		mov		a1,x0
FFFC2848 00472903		lw		a0,4[$sp]	; get back text pointer
FFFC284C 701000EF		call	PRTSTG		; print string as prompt
FFFC2850 005E0023		sb		r5,[$t2]		; un-null terminate
                        	IP3
FFFC2854 01C72223		sw		$t2,4[$sp]	; save in case of error
FFFC2858 71802903		lw		a0,CURRNT
FFFC285C 01272423		sw		a0,8[$sp]	; also save 'CURRNT'
FFFC2860 FFF06913		ldi		a0,#-1
FFFC2864 71202C23		sw		a0,CURRNT	; flag that we are in INPUT
FFFC2868 78E02C23		sw		$sp,STKINP	; save the stack pointer too
FFFC286C 01E72623		sw		$t4,12[$sp]	; save the variable address
FFFC2870 03A06913		ldi		a0,#':'		; print a colon first
FFFC2874 4B9000EF		call	GETLN		; then get an input line
FFFC2878 71C06E13		ldi		$t2,#BUFFER	; point to the buffer
FFFC287C 400000EF		call	OREXPR		; evaluate the input
FFFC2880 00C72F03		lw		$t4,12[$sp]	; restore the variable address
FFFC2884 012F2023		sw		a0,[$t4]	; save value in variable
FFFC2888 00872903		lw		a0,8[$sp]	; restore old 'CURRNT'
FFFC288C 71202C23		sw		a0,CURRNT
FFFC2890 00472E03		lw		$t2,4[$sp]	; and the old text pointer
                        	IP4:
FFFC2894 0E4010EF		call	TSTC
FFFC2898 0000002C		dw		','
FFFC289C 00000463		bra		IP5
FFFC28A0 F4000CE3		bra		IP6			; yes, more items
                        	IP5:
FFFC28A4 01072283		lw		r5,16[$sp]
FFFC28A8 01470713		add		$sp,$sp,#20	; cleanup stack
FFFC28AC D71FF06F	 	jmp		FINISH
                        	
                        	
                        	DEFLT:
FFFC28B0 000E4903	  lbu    	a0,[$t2]
FFFC28B4 00D06D93	  ldi			$t1,#CR
FFFC28B8 D7B902E3		beq	    a0,$t1,FINISH	    ; empty line is OK else it is 'LET'
                        	
                        	
                        	;******************************************************************
                        	; 'LET' is followed by a list of items separated by commas.
                        	; Each item consists of a variable, an equals sign, and an
                        	; expression.  The interpreter evaluates the expression and sets
                        	; the variable to that value.  The interpreter will also handle
                        	; 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                        	;******************************************************************
                        	;
                        	LET:
FFFC28BC 339000EF	  call	SETVAL		; do the assignment
FFFC28C0 0B8010EF		call	TSTC		; check for more 'LET' items
FFFC28C4 0000002C		dw		','
FFFC28C8 D55FF06F		jmp		FINISH
FFFC28CC FE0008E3		bra	    LET
                        	LT1:
FFFC28D0 D4DFF06F	  jmp	    FINISH		; until we are finished.
                        	
                        	
                        	;******************************************************************
                        	; *** LOAD *** & SAVE ***
                        	;
                        	; These two commands transfer a program to/from an auxiliary
                        	; device such as a cassette, another computer, etc.  The program
                        	; is converted to an easily-stored format: each line starts with
                        	; a colon, the line no. as 4 hex digits, and the rest of the line.
                        	; At the end, a line starting with an '@' sign is sent.  This
                        	; format can be read back with a minimum of processing time by
                        	; the RTF65002
                        	;******************************************************************
                        	;
                        	LOAD
FFFC28D4 00002E37		ldi		$t2,#TXTBGN	; set pointer to start of prog. area
FFFC28D8 800E0E13
FFFC28DC 00D06913		ldi		a0,#CR		; For a CP/M host, tell it we're ready...
FFFC28E0 F30FF0EF		call	GOAUXO		; by sending a CR to finish PIP command.
                        	LOD1:
FFFC28E4 F34FF0EF		call	GOAUXI		; look for start of line
FFFC28E8 FF205EE3		ble		a0,r0,LOD1
FFFC28EC 04006D93		ldi		$t1,#'@'
FFFC28F0 03B90E63		beq		a0,$t1,LODEND	; end of program?
FFFC28F4 01A06D93		ldi		$t1,#$1A
FFFC28F8 03B90A63		beq		a0,$t1,LODEND	; or EOF marker
FFFC28FC 03A06D93		ldi		$t1,#':'
FFFC2900 FFB912E3		bne		a0,$t1,LOD1	; if not, is it start of line? if not, wait for it
FFFC2904 030000EF		call	GCHAR		; get line number
FFFC2908 012E2023		sw		a0,[$t2]		; store it
FFFC290C 004E0E13		add		$t2,$t2,#4
                        	LOD2:
FFFC2910 F08FF0EF		call	GOAUXI		; get another text char.
FFFC2914 FF205EE3		ble		a0,r0,LOD2
FFFC2918 012E0023		sb		a0,[$t2]		; store it
FFFC291C 001E0E13		add		$t2,$t2,#1
FFFC2920 00D06D93		ldi		$t1,#CR
FFFC2924 FFB916E3		bne		a0,$t1,LOD2		; is it the end of the line? if not, go back for more
FFFC2928 FA000EE3		bra		LOD1		; if so, start a new line
                        	LODEND:
FFFC292C 71C02223		sw		$t2,TXTUNF	; set end-of program pointer
FFFC2930 F7CFF06F		jmp		WSTART		; back to direct mode
                        	
                        	
                        	; get character from input (32 bit value)
                        	GCHAR:
FFFC2934 FF470713		sub		$sp,$sp,#12
FFFC2938 00572023		sw		r5,[$sp]
FFFC293C 00672223		sw		r6,4[$sp]
FFFC2940 00172423		sw		$ra,8[$sp]
FFFC2944 00806313		ldi		r6,#8       ; repeat ten times
FFFC2948 00006293		ldi		r5,#0
                        	GCHAR1:
FFFC294C ECCFF0EF		call	GOAUXI		; get a char
FFFC2950 FF205EE3		ble		a0,r0,GCHAR1
FFFC2954 02C000EF		call	asciiToHex
FFFC2958 00429293		sll		r5,r5,#4
FFFC295C 0122E2B3		or		r5,r5,a0
FFFC2960 FFF30313		sub		r6,r6,#1
FFFC2964 FE6064E3		bgtu	r6,r0,GCHAR1
FFFC2968 0002E933		mov		a0,r5
FFFC296C 00072283		lw		r5,[$sp]
FFFC2970 00472303		lw		r6,4[$sp]
FFFC2974 00872083		lw		$ra,8[$sp]
FFFC2978 00C70713		add		$sp,$sp,#12
FFFC297C 00008067		ret
                        	
                        	; convert an ascii char to hex code
                        	; input
                        	;	a0 = char to convert
                        	
                        	asciiToHex:
FFFC2980 03906D93		ldi		$t1,#'9'
FFFC2984 012DF463		bleu	a0,$t1,a2h1; less than '9'
FFFC2988 FF990913		sub		a0,a0,#7	; shift 'A' to '9'+1
                        	a2h1:
FFFC298C FD090913		sub		a0,a0,#'0'
FFFC2990 00F97913		and		a0,a0,#15	; make sure a nybble
FFFC2994 00008067		ret
                        	
                        	GetFilename:
FFFC2998 FFC70713		sub		$sp,$sp,#4
FFFC299C 00172023		sw		$ra,[$sp]
FFFC29A0 7D9000EF		call	TSTC
FFFC29A4 00000022		dw		'"'
FFFC29A8 04000C63		bra		gfn1
FFFC29AC 000061B3		mov		r3,r0
                        	gfn2:
FFFC29B0 000E4903		lbu		a0,[$t2]		; get text character
FFFC29B4 001E0E13		add		$t2,$t2,#1
FFFC29B8 02206D93		ldi		$t1,#'"'
FFFC29BC 03B90263		beq		a0,$t1,gfn3
FFFC29C0 02090063		beq		a0,r0,gfn3
FFFC29C4 6D218023		sb		a0,FILENAME[r3]
FFFC29C8 00118193		add		r3,r3,#1
FFFC29CC 04006D93		ldi		$t1,#64
FFFC29D0 FFB1E0E3		bltu	r3,$t1,gfn2
FFFC29D4 00072083		lw		$ra,[$sp]
FFFC29D8 00470713		add		$sp,$sp,#4
FFFC29DC 00008067		ret
                        	gfn3:
FFFC29E0 02006913		ldi		a0,#' '
FFFC29E4 6D218023		sb		a0,FILENAME[r3]
FFFC29E8 00118193		add		r3,r3,#1
FFFC29EC 04006D93		ldi		$t1,#64
FFFC29F0 FFB1E8E3		bltu	r3,$t1,gfn3
FFFC29F4 00072083		lw		$ra,[$sp]
FFFC29F8 00470713		add		$sp,$sp,#4
FFFC29FC 00008067		ret
                        	gfn1:
FFFC2A00 EACFF06F		jmp		WSTART
                        	
                        	LOAD3:
FFFC2A04 F95FF0EF		call	GetFilename
FFFC2A08 00000637		call	AUXIN_INIT
FFFC2A0C 227600E7
FFFC2A10 EC5FF06F		jmp		LOAD
                        	
                        	;	call		OREXPR		;evaluate the following expression
                        	;	ld		a0,#5000
FFFC2A14 000019B7		ld		a1,#$E00
FFFC2A18 E0098993
FFFC2A1C 00000637		call	SDReadSector
FFFC2A20 228600E7
FFFC2A24 00190913		add		a0,a0,#1
FFFC2A28 000029B7		ldi		a1,#TXTBGN
FFFC2A2C 80098993
                        	LOAD4:
FFFC2A30 FFC70713		sub		$sp,$sp,#4
FFFC2A34 01272023		sw		a0,[$sp]
FFFC2A38 00000637		call	SDReadSector
FFFC2A3C 228600E7
FFFC2A40 20098993		add		a1,a1,#512
FFFC2A44 00072903		lw		a0,[$sp]
FFFC2A48 00470713		add		$sp,$sp,#4
FFFC2A4C 00190913		add		a0,a0,#1
FFFC2A50 00002237		ldi		r4,#TXTBGN
FFFC2A54 80020213
FFFC2A58 00010637		add		r4,r4,#65536
FFFC2A5C 00460233
FFFC2A60 FC49C8E3		blt		a1,r4,LOAD4
                        	LOAD5:
FFFC2A64 E4000463		bra		WSTART
                        	
                        	
                        	SAVE3:
FFFC2A68 F31FF0EF		call	GetFilename
FFFC2A6C 00000637		call	AUXOUT_INIT
FFFC2A70 22B600E7
FFFC2A74 05C0006F		jmp		SAVE
                        	
FFFC2A78 204000EF		call	OREXPR		;evaluate the following expression
                        	;	lda		#5000		; starting sector
FFFC2A7C 000019B7		ldi		a1,#$E00	; starting address to write
FFFC2A80 E0098993
FFFC2A84 00000637		call	SDWriteSector
FFFC2A88 22D600E7
FFFC2A8C 00190913		add		a0,a0,#1
FFFC2A90 000029B7		ldi		a1,#TXTBGN
FFFC2A94 80098993
                        	SAVE4:
FFFC2A98 FFC70713		sub		$sp,$sp,#4
FFFC2A9C 01272023		sw		a0,[$sp]
FFFC2AA0 00000637		call	SDWriteSector
FFFC2AA4 22D600E7
FFFC2AA8 20098993		add		a1,a1,#512
FFFC2AAC 00072903		lw		a0,[$sp]
FFFC2AB0 00470713		add		$sp,$sp,#4
FFFC2AB4 00190913		add		a0,a0,#1
FFFC2AB8 00002237		ldi		r4,#TXTBGN
FFFC2ABC 80020213
FFFC2AC0 00010637		add		r4,r4,#65536
FFFC2AC4 00460233
FFFC2AC8 FC49C8E3		blt		a1,r4,SAVE4
FFFC2ACC DE000063		bra		WSTART
                        	
                        	SAVE:
FFFC2AD0 00002E37		ldi		$t2,#TXTBGN	;set pointer to start of prog. area
FFFC2AD4 800E0E13
FFFC2AD8 70402E83		lw		$t3,TXTUNF	;set pointer to end of prog. area
                        	SAVE1:
FFFC2ADC 054000EF		call	AUXOCRLF    ; send out a CR & LF (CP/M likes this)
FFFC2AE0 03CEC863		bgt		$t2,$t3,SAVEND; are we finished?
FFFC2AE4 03A06913		ldi		a0,#':'		; if not, start a line
FFFC2AE8 D28FF0EF		call	GOAUXO
FFFC2AEC 000E2903		lw		a0,[$t2]		; get line number
FFFC2AF0 004E0E13		add		$t2,$t2,#4
FFFC2AF4 060000EF		call	PWORD       ; output line number as 5-digit hex
                        	SAVE2:
FFFC2AF8 000E4903		lbu		a0,[$t2]		; get a text char.
FFFC2AFC 001E0E13		add		$t2,$t2,#1
FFFC2B00 00D06D93		ldi		$t1,#CR
FFFC2B04 FDB90CE3		beq		a0,$t1,SAVE1	; is it the end of the line? if so, send CR & LF and start new line
FFFC2B08 D08FF0EF		call	GOAUXO		; send it out
FFFC2B0C FE0006E3		bra		SAVE2		; go back for more text
                        	SAVEND:
FFFC2B10 04006913		ldi		a0,#'@'		; send end-of-program indicator
FFFC2B14 CFCFF0EF		call	GOAUXO
FFFC2B18 018000EF		call	AUXOCRLF    ; followed by a CR & LF
FFFC2B1C 01A06913		ldi		a0,#$1A		; and a control-Z to end the CP/M file
FFFC2B20 CF0FF0EF		call	GOAUXO
FFFC2B24 00000637		call	AUXOUT_FLUSH
FFFC2B28 234600E7
FFFC2B2C D8000063		bra		WSTART		; then go do a warm start
                        	
                        	; output a CR LF sequence to auxillary output
                        	; Registers Affected
                        	;   r3 = LF
                        	AUXOCRLF:
FFFC2B30 FFC70713		sub		$sp,$sp,#4
FFFC2B34 00172023		sw		$ra,[$sp]
FFFC2B38 00D06913	  ldi		a0,#CR
FFFC2B3C CD4FF0EF	  call	GOAUXO
FFFC2B40 00A06913	  ldi		a0,#LINEFD
FFFC2B44 CCCFF0EF	  call	GOAUXO
FFFC2B48 00072083	  lw		$ra,[$sp]
FFFC2B4C 00470713	  add		$sp,$sp,#4
FFFC2B50 00008067	  ret
                        	
                        	
                        	; output a word in hex format
                        	; tricky because of the need to reverse the order of the chars
                        	PWORD:
FFFC2B54 FF870713		sub		$sp,$sp,#8
FFFC2B58 00572023		sw		r5,[$sp]
FFFC2B5C 00172223		sw		$ra,4[$sp]
FFFC2B60 7A206293		ldi		r5,#NUMWKA+14
FFFC2B64 00096233		mov		r4,a0		; r4 = value
                        	pword1:
FFFC2B68 00026933	  mov   a0,r4	    ; a0 = value
FFFC2B6C 00425213	  srl		r4,r4,#4	; shift over to next nybble
FFFC2B70 038000EF	  call	toAsciiHex  ; convert LS nybble to ascii hex
FFFC2B74 01228023	  sb    a0,[r5]		; save in work area
FFFC2B78 FFF28293	  sub		r5,r5,#1
FFFC2B7C 79406D93	  ldi		$t1,#NUMWKA
FFFC2B80 FFB2D4E3		bge		r5,$t1,pword1
                        	pword2:
FFFC2B84 00128293	  add		r5,r5,#1
FFFC2B88 0002C903	  lbu   a0,[r5]     ; get char to output
FFFC2B8C C84FF0EF		call	GOAUXO		; send it
FFFC2B90 7A206D93		ldi		$t1,#NUMWKA+14
FFFC2B94 FFB2C8E3		blt		r5,$t1,pword2
FFFC2B98 00072283		lw		r5,[$sp]
FFFC2B9C 00472083		lw		$ra,4[$sp]
FFFC2BA0 00870713		add		$sp,$sp,#8
FFFC2BA4 00008067		ret
                        	
                        	; convert nybble in a1 to ascii hex chaa1
                        	; a1 = character to convert
                        	
                        	toAsciiHex:
FFFC2BA8 00F97913		and		a0,a0,#15	; make sure it's a nybble
FFFC2BAC 00A06D93		ldi		$t1,#10
FFFC2BB0 01B94463		blt		a0,$t1,tah1	; > 10 ?
FFFC2BB4 00790913		add		a0,a0,#7	; bump it up to the letter 'A'
                        	tah1:
FFFC2BB8 03090913		add		a0,a0,#'0'	; bump up to ascii '0'
FFFC2BBC 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	; *** POKE ***
                        	;
                        	; 'POKE expr1,expa1' stores the byte from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEW expr1,expa1' stores the word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEH expr1,expa1' stores the half-word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	;******************************************************************
                        	;
                        	POKE:
FFFC2BC0 0BC000EF		call	OREXPR		; get the memory address
FFFC2BC4 5B5000EF		call	TSTC		; it must be followed by a comma
FFFC2BC8 0000002C		dw		','
FFFC2BCC 06000C63		bra		PKER
FFFC2BD0 FFC70713		sub		$sp,$sp,#4
FFFC2BD4 01272023		sw		a0,[$sp]	; save the address
FFFC2BD8 0A4000EF		call	OREXPR		; get the byte to be POKE'd
FFFC2BDC 00072983		lw		a1,[$sp]	; get the address back
FFFC2BE0 00470713		add		$sp,$sp,#4
FFFC2BE4 01298023		sb		a0,[a1]		; store the byte in memory
FFFC2BE8 A35FF06F		jmp		FINISH
                        	
                        	POKEW:
FFFC2BEC 090000EF		call	OREXPR		; get the memory address
FFFC2BF0 589000EF		call	TSTC		; it must be followed by a comma
FFFC2BF4 0000002C		dw		','
FFFC2BF8 04000663		bra		PKER
FFFC2BFC FFC70713		sub		$sp,$sp,#4
FFFC2C00 01272023		sw		a0,[$sp]	; save the address
FFFC2C04 078000EF		call	OREXPR		; get the byte to be POKE'd
FFFC2C08 00072983		lw		a1,[$sp]	; get the address back
FFFC2C0C 00470713		add		$sp,$sp,#4
FFFC2C10 0129A023		sw		a0,[a1]		; store the byte in memory
FFFC2C14 A09FF06F		jmp		FINISH
                        	
                        	POKEH:
FFFC2C18 064000EF		call	OREXPR		; get the memory address
FFFC2C1C 55D000EF		call	TSTC		; it must be followed by a comma
FFFC2C20 0000002C		dw		','
FFFC2C24 02000063		bra		PKER
FFFC2C28 FFC70713		sub		$sp,$sp,#4
FFFC2C2C 01272023		sw		a0,[$sp]	; save the address
FFFC2C30 04C000EF		call	OREXPR		; get the byte to be POKE'd
FFFC2C34 00072983		lw		a1,[$sp]	; get the address back
FFFC2C38 00470713		add		$sp,$sp,#4
FFFC2C3C 01299023		sh		a0,[a1]		; store the byte in memory
FFFC2C40 9DDFF06F		jmp		FINISH
                        	
                        	PKER:
FFFC2C44 FFFC4937		ldi		a0,#msgComma
FFFC2C48 C2290913
FFFC2C4C 09D0006F		jmp		ERROR		; if no comma, say "What?"
                        	
                        	;******************************************************************
                        	; 'SYSX expr' jumps to the machine language subroutine whose
                        	; starting address is specified by 'expr'.  The subroutine can use
                        	; all registers but must leave the stack the way it found it.
                        	; The subroutine returns to the interpreter by executing an RTS.
                        	;******************************************************************
                        	
                        	SYSX:
FFFC2C50 02C000EF		call	OREXPR		; get the subroutine's address
FFFC2C54 00081863		bne		v0,r0,sysx1; make sure we got a valid address
FFFC2C58 FFFC4937		ld		a0,#msgSYSBad
FFFC2C5C C7390913
FFFC2C60 0890006F		jmp		ERROR
                        	sysx1:
FFFC2C64 FFC70713		sub		$sp,$sp,#4
FFFC2C68 01C72023		sw		$t2,[$sp]	; save the text pointer
FFFC2C6C 000800E7		call	[v0]			; jump to the subroutine
FFFC2C70 00072E03		lw		$t2,[$sp]	; restore the text pointer
FFFC2C74 00470713		add		$sp,$sp,#4
FFFC2C78 9A5FF06F		jmp		FINISH
                        	
                        	;******************************************************************
                        	; *** EXPR ***
                        	;
                        	; 'EXPR' evaluates arithmetical or logical expressions.
                        	; <OREXPR>::= <ANDEXPR> OR <ANDEXPR> ...
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	; <EXPR>::=<ADDEXPR>
                        	;	   <ADDEXPR><rel.op.><ADDEXPR>
                        	; where <rel.op.> is one of the operators in TAB8 and the result
                        	; of these operations is 1 if true and 0 if false.
                        	; <ADDEXPR>::=(+ or -)<MULEXPR>(+ or -)<MULEXPR>(...
                        	; where () are optional and (... are optional repeats.
                        	; <MULEXPR>::=<FUNCEXPR>( <* or /><FUNCEXPR> )(...
                        	; <FUNCEXPR>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                        	; as an index, functions can have an <EXPR> as arguments, and
                        	; <FUNCEXPR> can be an <EXPR> in parenthesis.
                        	;
                        	
                        	; <OREXPR>::=<ANDEXPR> OR <ANDEXPR> ...
                        	;
                        	OREXPR:
FFFC2C7C FF470713		sub		$sp,$sp,#12
FFFC2C80 00172023		sw		$ra,[$sp]
FFFC2C84 00372223		sw		r3,4[$sp]
FFFC2C88 00472423		sw		r4,8[$sp]
FFFC2C8C 058000EF		call	ANDEXPR		; get first <ANDEXPR>
                        	XP_OR1:
FFFC2C90 FF870713		sub		$sp,$sp,#8
FFFC2C94 01072023		sw		$v0,[$sp]		; save <ANDEXPR> value
FFFC2C98 01172223		sw		$v1,4[$sp]	; save type
FFFC2C9C FFFC2EB7		ldi		$t3,#TAB10	; look up a logical operator
FFFC2CA0 2E4E8E93
FFFC2CA4 FFFC2F37		ldi		$t4,#TAB10_1
FFFC2CA8 34EF0F13
FFFC2CAC EC4FF06F		jmp		EXEC		; go do it
                        	XP_OR:
FFFC2CB0 034000EF	  call	ANDEXPR
FFFC2CB4 00072903	  lw		$a0,[$sp]
FFFC2CB8 00870713	  add		$sp,$sp,#8
FFFC2CBC 01286833	  or    v0,v0,a0
FFFC2CC0 FC0008E3	  bra   XP_OR1
                        	XP_ORX:
FFFC2CC4 00072803	  lw		$v0,[$sp]
FFFC2CC8 00472883	  lw		$v1,4[$sp]
FFFC2CCC 00870713	  add		$sp,$sp,#8
FFFC2CD0 00072083		lw		$ra,[$sp]
FFFC2CD4 00472183		lw		r3,4[$sp]
FFFC2CD8 00872203		lw		r4,8[$sp]
FFFC2CDC 00C70713		add		$sp,$sp,#12
FFFC2CE0 00008067	  ret
                        	
                        	
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	;
                        	ANDEXPR:
FFFC2CE4 FFC70713		sub		$sp,$sp,#4
FFFC2CE8 00172023		sw		$ra,[$sp]
FFFC2CEC 0E8000EF		call	EXPR		; get first <EXPR>
                        	XP_AND1:
FFFC2CF0 FF870713		sub		$sp,$sp,#8
FFFC2CF4 01072023		sw		$v0,[$sp]		; save <EXPR> value
FFFC2CF8 01172223		sw		$v1,4[$sp]	; save type
FFFC2CFC FFFC2EB7		ldi		$t3,#TAB9		; look up a logical operator
FFFC2D00 2E0E8E93
FFFC2D04 FFFC2F37		ldi		$t4,#TAB9_1
FFFC2D08 34AF0F13
FFFC2D0C E64FF06F		jmp		EXEC		; go do it
                        	XP_AND:
FFFC2D10 0C4000EF	  call	EXPR
FFFC2D14 00072903	  lw		$a0,[$sp]
FFFC2D18 00870713	  add		$sp,$sp,#8
FFFC2D1C 01287833	  and   v0,v0,a0
FFFC2D20 FC0008E3	  bra   XP_AND1
                        	XP_ANDX:
FFFC2D24 00072803	  lw		$v0,[$sp]
FFFC2D28 00472883	  lw		$v1,4[$sp]
FFFC2D2C 00870713	  add		$sp,$sp,#8
FFFC2D30 00072083		lw		$ra,[$sp]
FFFC2D34 00470713		add		$sp,$sp,#4
FFFC2D38 00008067	  ret
                        	
                        	
                        	; Determine if the character is a digit
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if digit, otherwise 0
                        	;
                        	isDigit:
FFFC2D3C 03006D93		ldi		$t1,#'0'
FFFC2D40 01B94A63		blt		a0,$t1,isDigitFalse
FFFC2D44 03906D93		ldi		$t1,#'9'
FFFC2D48 012DC663		bgt		a0,$t1,isDigitFalse
FFFC2D4C 00106813		ldi		v0,#1
FFFC2D50 00008067	  ret
                        	isDigitFalse:
FFFC2D54 00006833	  mov		v0,r0
FFFC2D58 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphabetic
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlpha:
FFFC2D5C 04106D93		ldi		$t1,#'A'
FFFC2D60 03B94263		blt		a0,$t1,isAlphaFalse
FFFC2D64 05A06D93		ldi		$t1,#'Z'
FFFC2D68 012DDA63		ble		a0,$t1,isAlphaTrue
FFFC2D6C 06106D93		ldi		$t1,#'a'
FFFC2D70 01B94A63		blt		a0,$t1,isAlphaFalse
FFFC2D74 07A06D93		ldi		$t1,#'z'
FFFC2D78 012DC663		bgt		a0,$t1,isAlphaFalse
                        	isAlphaTrue:
FFFC2D7C 00106813	  ldi		v0,#1
FFFC2D80 00008067	  ret
                        	isAlphaFalse:
FFFC2D84 00006833	  mov		v0,r0
FFFC2D88 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphanumeric
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlnum:
FFFC2D8C FFC70713		sub		$sp,$sp,#4
FFFC2D90 00172023		sw		$ra,[$sp]
FFFC2D94 FA9FF0EF	  call	isDigit
FFFC2D98 00081463		bne		v0,r0,isDigitx	; if it is a digit
FFFC2D9C FC1FF0EF	  call  isAlpha
                        	isDigitx:
FFFC2DA0 00072083		lw		$ra,[$sp]
FFFC2DA4 00470713		add		$sp,$sp,#4
FFFC2DA8 00008067	  ret
                        	
                        	FORCEFIT:
FFFC2DAC 03198263		beq		a1,v1,.0001				; types match
FFFC2DB0 00006D13		ldi		$t0,#0
FFFC2DB4 01A98663		beq		a1,$t0,.intAnd
                        	;	itof	$f1,$v0
FFFC2DB8 00106913		ldi		a0,#1
FFFC2DBC 00008067		ret
                        	.intAnd:
FFFC2DC0 00106D13		ldi		$t0,#1
FFFC2DC4 01A89663		bne		$v1,$t0,.0001
                        	;	itof	$f2,$a1
FFFC2DC8 00106993		ldi		$a1,#1
FFFC2DCC 00008067		ret
                        	.0001:
FFFC2DD0 00008067		ret
                        	
                        	EXPR:
FFFC2DD4 FFC70713		sub		$sp,$sp,#4
FFFC2DD8 00172023		sw		$ra,[$sp]
FFFC2DDC 11C000EF		call	ADDEXPR
FFFC2DE0 FF870713		sub		$sp,$sp,#8				; save <ADDEXPR> value
FFFC2DE4 01072023		sw		v0,[$sp]
FFFC2DE8 01172223		sw		v1,4[$sp]					; save type
FFFC2DEC FFFC2EB7		ldi		$t3,#TAB8		; look up a relational operator
FFFC2DF0 2D6E8E93
FFFC2DF4 FFFC2F37		ldi		$t4,#TAB8_1
FFFC2DF8 33CF0F13
FFFC2DFC D74FF06F		jmp		EXEC		; go do it
                        	XP11:
FFFC2E00 00072903		lw		a0,[$sp]
FFFC2E04 00472983		lw		a1,4[$sp]
FFFC2E08 00870713		add		$sp,$sp,#8
FFFC2E0C 0C4000EF		call	XP18	; is it ">="?
FFFC2E10 09095A63		bge		a0,v0,XPRT1	; no, return v0=1
FFFC2E14 06000E63		bra		XPRT0	; else return v0=0
                        	XP12:
FFFC2E18 00072903		lw		a0,[$sp]
FFFC2E1C 00472983		lw		a1,4[$sp]
FFFC2E20 00870713		add		$sp,$sp,#8
FFFC2E24 0AC000EF		call	XP18	; is it "<>"?
FFFC2E28 07091E63		bne		a0,v0,XPRT1	; no, return a1=1
FFFC2E2C 06000263		bra		XPRT0	; else return a1=0
                        	XP13:
FFFC2E30 00072903		lw		a0,[$sp]
FFFC2E34 00472983		lw		a1,4[$sp]
FFFC2E38 00870713		add		$sp,$sp,#8
FFFC2E3C 094000EF		call	XP18	; is it ">"?
FFFC2E40 07284263		bgt		a0,v0,XPRT1	; no, return a1=1
FFFC2E44 04000663		bra		XPRT0	; else return a1=0
                        	XP14:
FFFC2E48 00072903		lw		a0,[$sp]
FFFC2E4C 00472983		lw		a1,4[$sp]
FFFC2E50 00870713		add		$sp,$sp,#8
FFFC2E54 07C000EF		call	XP18	; is it "<="?
FFFC2E58 05285663		ble		a0,v0,XPRT1	; no, return a1=1
FFFC2E5C 02000A63		bra		XPRT0	; else return a1=0
                        	XP15:
FFFC2E60 00072903		lw		a0,[$sp]
FFFC2E64 00472983		lw		a1,4[$sp]
FFFC2E68 00870713		add		$sp,$sp,#8
FFFC2E6C 064000EF		call	XP18	; is it "="?
FFFC2E70 03090A63		beq		a0,v0,XPRT1	; if not, return a1=1
FFFC2E74 00000E63		bra		XPRT0	; else return a1=0
                        	XP16:
FFFC2E78 00072903		lw		a0,[$sp]
FFFC2E7C 00472983		lw		a1,4[$sp]
FFFC2E80 00870713		add		$sp,$sp,#8
FFFC2E84 04C000EF		call	XP18	; is it "<"?
FFFC2E88 01094E63		blt		a0,v0,XPRT1	; if not, return a1=1
FFFC2E8C 00000263		bra		XPRT0	; else return a1=0
                        	XPRT0:
FFFC2E90 00006833		mov		v0,x0   ; return a0=0 (false)
FFFC2E94 000068B3		mov		v1,x0		; type = int
FFFC2E98 00072083		lw		$ra,[$sp]
FFFC2E9C 00470713		add		$sp,$sp,#4
FFFC2EA0 00008067		ret
                        	XPRT1:
FFFC2EA4 00106813		ldi		v0,#1	; return a0=1 (true)
FFFC2EA8 00006893		ldi		v1,#0	; type = int
FFFC2EAC 00072083		lw		$ra,[$sp]
FFFC2EB0 00470713		add		$sp,$sp,#4
FFFC2EB4 00008067		ret
                        	
                        	XP17:				; it's not a rel. operator
FFFC2EB8 00072803		lw		v0,[$sp]; return a1=<ADDEXPR>
FFFC2EBC 00472883		lw		v1,4[$sp]
FFFC2EC0 00870713		add		$sp,$sp,#8
FFFC2EC4 00072083		lw		$ra,[$sp]
FFFC2EC8 00470713		add		$sp,$sp,#4
FFFC2ECC 00008067		ret
                        	
                        	XP18:
FFFC2ED0 FF470713		sub		$sp,$sp,#12
FFFC2ED4 00172023		sw		$ra,[$sp]
FFFC2ED8 01072223		sw		v0,4[$sp]
FFFC2EDC 01172423		sw		v1,8[$sp]
FFFC2EE0 018000EF		call	ADDEXPR		; do a second <ADDEXPR>
FFFC2EE4 00472903		lw		a0,4[$sp]
FFFC2EE8 00872983		lw		a1,8[$sp]
FFFC2EEC 00072083		lw		$ra,[$sp]
FFFC2EF0 00C70713		add		$sp,$sp,#12
FFFC2EF4 00008067		ret
                        	
                        	; <ADDEXPR>::=(+ or -)<MULEXPR>(+ or -)<MULEXPR>(...
                        	//message "ADDEXPR"
                        	ADDEXPR:
FFFC2EF8 FFC70713		sub		$sp,$sp,#4
FFFC2EFC 00172023		sw		$ra,[$sp]
FFFC2F00 279000EF		call	TSTC		; negative sign?
FFFC2F04 0000002D		dw		'-'
FFFC2F08 00000C63		bra		XP21
FFFC2F0C 00006833		mov		v0,r0		; yes, fake '0-'
FFFC2F10 FF870713		sub		$sp,$sp,#8
FFFC2F14 01072023		sw		v0,[$sp]
FFFC2F18 01172223		sw		v1,4[$sp]
FFFC2F1C 04000863		bra		XP26
                        	XP21:
FFFC2F20 259000EF		call	TSTC		; positive sign? ignore it
FFFC2F24 0000002B		dw		'+'
FFFC2F28 00000263		bra		XP22
                        	XP22:
FFFC2F2C 064000EF		call	MULEXPR		; first <MULEXPR>
                        	XP23:
FFFC2F30 FF870713		sub		$sp,$sp,#8; yes, save the value
FFFC2F34 01072023		sw		v0,[$sp]
FFFC2F38 01172223		sw		v1,4[$sp]	; and type
FFFC2F3C 23D000EF		call	TSTC		; add?
FFFC2F40 0000002B		dw		'+'
FFFC2F44 00000E63		bra		XP25
FFFC2F48 048000EF		call	MULEXPR		; get the second <MULEXPR>
                        	XP24:
FFFC2F4C 00072903		lw		a0,[$sp]
FFFC2F50 00472983		lw		a1,4[$sp]
FFFC2F54 00870713		add		$sp,$sp,#8
FFFC2F58 01280833		add		v0,v0,a0	; add it to the first <MULEXPR>
                        	;	BVS.L	QHOW		brnch if there's an overflow
FFFC2F5C FC000AE3		bra		XP23		; else go back for more operations
                        	XP25:
FFFC2F60 219000EF		call	TSTC		; subtract?
FFFC2F64 0000002D		dw		'-'
FFFC2F68 00000863		bra		XP45
                        	XP26:
FFFC2F6C 024000EF		call	MULEXPR		; get second <MULEXPR>
FFFC2F70 41000833		sub		v0,r0,v0	; change its sign
FFFC2F74 FC000CE3		bra		XP24		; and do an addition
                        	XP45:
FFFC2F78 00072803		lw		v0,[$sp]
FFFC2F7C 00472883		lw		v1,4[$sp]
FFFC2F80 00870713		add		$sp,$sp,#8
FFFC2F84 00072083		lw		$ra,[$sp]
FFFC2F88 00470713		add		$sp,$sp,#4
FFFC2F8C 00008067		ret
                        	
                        	
                        	; <MULEXPR>::=<FUNCEXPR>( <* or /><FUNCEXPR> )(...
                        	
                        	MULEXPR:
FFFC2F90 FFC70713		sub		$sp,$sp,#4
FFFC2F94 00172023		sw		$ra,[$sp]
FFFC2F98 094000EF		call	FUNCEXPR		; get first <FUNCEXPR>
                        	XP31:
FFFC2F9C FF870713		sub		$sp,$sp,#8
FFFC2FA0 01072023		sw		v0,[$sp]; yes, save that first result
FFFC2FA4 01172223		sw		v1,4[$sp]
FFFC2FA8 1D1000EF		call	TSTC		; multiply?
FFFC2FAC 0000002A		dw		'*'
FFFC2FB0 00000E63		bra		XP34
FFFC2FB4 078000EF		call	FUNCEXPR		; get second <FUNCEXPR>
FFFC2FB8 00072903		lw		a0,[$sp]
FFFC2FBC 00472983		lw		a1,4[$sp]
FFFC2FC0 00870713		add		$sp,$sp,#8
FFFC2FC4 03280833		mul		v0,v0,a0	; multiply the two
FFFC2FC8 FC000AE3		bra		XP31        ; then look for more terms
                        	XP34:
FFFC2FCC 1AD000EF		call	TSTC		; divide?
FFFC2FD0 0000002F		dw		'/'
FFFC2FD4 00000E63		bra		XP35
FFFC2FD8 054000EF		call	FUNCEXPR		; get second <FUNCEXPR>
FFFC2FDC 00072903		lw		a0,[$sp]
FFFC2FE0 00472983		lw		a1,4[$sp]
FFFC2FE4 00870713		add		$sp,$sp,#8
FFFC2FE8 03284833		div		v0,v0,a0	; do the division
FFFC2FEC FA0008E3		bra		XP31		; go back for any more terms
                        	XP35:
FFFC2FF0 189000EF		call	TSTC
FFFC2FF4 00000025		dw		'%'
FFFC2FF8 00000E63		bra		XP47
FFFC2FFC 030000EF		call	FUNCEXPR
FFFC3000 00072903		lw		a0,[$sp]
FFFC3004 00472983		lw		a1,4[$sp]
FFFC3008 00870713		add		$sp,$sp,#8
FFFC300C 03286833		rem		v0,v0,a0
FFFC3010 F80006E3		bra		XP31
                        	XP47:
FFFC3014 00072803		lw		v0,[$sp]
FFFC3018 00472883		lw		v1,4[$sp]
FFFC301C 00870713		add		$sp,$sp,#8
FFFC3020 00072083		lw		$ra,[$sp]
FFFC3024 00470713		add		$sp,$sp,#4
FFFC3028 00008067		ret
                        	
                        	
                        	; Functions are called through FUNCEXPR
                        	; <FUNCEXPR>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	
                        	FUNCEXPR:
FFFC302C FFC70713		sub		$sp,$sp,#4
FFFC3030 00172023		sw		$ra,[$sp]
FFFC3034 FFFC2EB7	  ldi		$t3,#TAB4		; find possible function
FFFC3038 2ABE8E93
FFFC303C FFFC2F37	  ldi		$t4,#TAB4_1
FFFC3040 320F0F13
FFFC3044 B2CFF06F		jmp		EXEC        ; branch to function which does subsequent ret for FUNCEXPR
                        	XP40:                   ; we get here if it wasn't a function
FFFC3048 00006933		mov		a0,x0
FFFC304C 070000EF		call	TSTV
FFFC3050 00080A63		beq   v0,x0,XP41	; not a variable
FFFC3054 00082803		lw		$v0,[$v0]		; if a variable, return its value in v0
FFFC3058 00072083		lw		$ra,[$sp]
FFFC305C 00470713		add		$sp,$sp,#4
FFFC3060 00008067		ret
                        	XP41:
FFFC3064 161000EF		call	TSTNUM		; or is it a number?
FFFC3068 00089463		bne		v1,x0,XP46	; (if not, # of digits will be zero) if so, return it in v0
FFFC306C 010000EF		call	PARN        ; check for (EXPR)
                        	XP46:
FFFC3070 00072083		lw		$ra,[$sp]
FFFC3074 00470713		add		$sp,$sp,#4
FFFC3078 00008067		ret
                        	
                        	
                        	; Check for a parenthesized expression
                        	PARN:
FFFC307C FFC70713		sub		$sp,$sp,#4
FFFC3080 00172023		sw		$ra,[$sp]	
FFFC3084 0F5000EF		call	TSTC		; else look for ( OREXPR )
FFFC3088 00000028		dw		'('
FFFC308C 02000063		bra		XP43
FFFC3090 BEDFF0EF		call	OREXPR
FFFC3094 0E5000EF		call	TSTC
FFFC3098 00000029		dw		')'
FFFC309C 00000863		bra		XP43
                        	XP42:
FFFC30A0 00072083		lw		$ra,[$sp]
FFFC30A4 00470713		add		$sp,$sp,#4
FFFC30A8 00008067		ret
                        	XP43:
FFFC30AC 00470713		add		$sp,$sp,#4		; get rid of return address
FFFC30B0 FFFC4937		ldi		a0,#msgWhat
FFFC30B4 BA890913
FFFC30B8 4300006F		jmp		ERROR
                        	
                        	
                        	; ===== Test for a valid variable name.  Returns Z=1 if not
                        	;	found, else returns Z=0 and the address of the
                        	;	variable in a0.
                        	; Parameters
                        	;		a0 = 1 = allocate if not found
                        	; Returns
                        	;		v0 = address of variable, zero if not found
                        	
                        	TSTV:
FFFC30BC FF870713		sub		$sp,$sp,#8
FFFC30C0 00572023		sw		r5,[$sp]
FFFC30C4 00172223		sw		$ra,4[$sp]
FFFC30C8 000962B3		mov		r5,a0		; r5=allocate flag
FFFC30CC 16D000EF		call	IGNBLK
FFFC30D0 000E4903		lbu		a0,[$t2]		; look at the program text
FFFC30D4 04006D93		ldi		$t1,#'@'
FFFC30D8 07B94263		blt		a0,$t1,tstv_notfound	; C=1: not a variable
FFFC30DC 03B91E63		bne		a0,$t1,TV1				; brnch if not "@" array
FFFC30E0 001E0E13		add		$t2,$t2,#1	; If it is, it should be
FFFC30E4 F99FF0EF		call	PARN		; followed by (EXPR) as its index.
                        	;	BCS.L	QHOW		say "How?" if index is too big
FFFC30E8 00000263		bra		TV3
                        	TV3:
FFFC30EC FFC70713		sub		$sp,$sp,#4	; save the index
FFFC30F0 01072023		sw		v0,[$sp]
FFFC30F4 2E4000EF		call	SIZEX		; get amount of free memory
FFFC30F8 00072983		lw		a1,[$sp]
FFFC30FC 00470713		add		$sp,$sp,#4	; get back the index
FFFC3100 0109C663		blt		a1,v0,TV2		; see if there's enough memory
FFFC3104 00870713		add		$sp,$sp,#8
FFFC3108 3CC0006F		jmp   QSORRY		; if not, say "Sorry"
                        	TV2:
FFFC310C 70802903		lw		a0,VARBGN	; put address of array element...
FFFC3110 41390833		sub   v0,a0,a1    ; into a0 (neg. offset is used)
FFFC3114 00000C63		bra   TSTVRT
                        	TV1:	
FFFC3118 038000EF	  call	getVarName      ; get variable name
FFFC311C 00080863	  beq   v0,x0,TSTVRT    ; if not, return v0=0
FFFC3120 00086933	  mov		a0,v0
FFFC3124 0002E9B3	  mov		a1,r5
FFFC3128 0E8000EF	  call	findVar     ; find or allocate
                        	TSTVRT:
FFFC312C 00072283		lw		r5,[$sp]
FFFC3130 00472083		lw		$ra,4[$sp]
FFFC3134 00870713		add		$sp,$sp,#8
FFFC3138 00008067		ret								; v0<>0 (if found)
                        	tstv_notfound:
FFFC313C 00072283		lw		r5,[$sp]
FFFC3140 00472083		lw		$ra,4[$sp]
FFFC3144 00870713		add		$sp,$sp,#8
FFFC3148 00006833		mov		v0,x0				; v0=0 if not found
FFFC314C 00008067	  ret
                        	
                        	; Get a variable name. Called after blanks have been ignored.
                        	;
                        	; Returns
                        	;   v0 = 3 character variable name + type
                        	;
                        	getVarName:
FFFC3150 FF870713		sub		$sp,$sp,#8
FFFC3154 00572023		sw		r5,[$sp]
FFFC3158 00172223		sw		$ra,4[$sp]
FFFC315C 000E4903	  lbu   a0,[$t2]		; get first character
FFFC3160 FFC70713	  sub		$sp,$sp,#4	; save off current name
FFFC3164 01272023	  sw		a0,[$sp]
FFFC3168 BF5FF0EF	  call	isAlpha
FFFC316C 08080663	  beq   v0,r0,gvn1
FFFC3170 00206293	  ldi	  r5,#2       ; loop two more times
                        	
                        		; check for second/third character
                        	gvn4:
FFFC3174 001E0E13		add		$t2,$t2,#1
FFFC3178 000E4903		lbu   a0,[$t2]		; do we have another char ?
FFFC317C C11FF0EF		call	isAlnum
FFFC3180 02080C63		beq   v0,x0,gvn2	; nope
FFFC3184 00072903		lw		a0,[$sp]
FFFC3188 00470713		add		$sp,$sp,#4	; get varname
FFFC318C 00891913		sll		a0,a0,#8
FFFC3190 000E4983		lbu   a1,[$t2]
FFFC3194 01396933		or    a0,a0,a1   ; add in new char
FFFC3198 FFC70713	  sub		$sp,$sp,#4	; save off current name again
FFFC319C 01272023	  sw		a0,[$sp]
FFFC31A0 FFF28293	  sub		r5,r5,#1
FFFC31A4 FC5048E3	  bgt		r5,x0,gvn4
                        	
                        	 	; now ignore extra variable name characters
                        	gvn6:
FFFC31A8 001E0E13		add		$t2,$t2,#1
FFFC31AC 000E4903		lbu   a0,[$t2]		; do we have another char ?
FFFC31B0 BDDFF0EF	  call  isAlnum
FFFC31B4 FE081AE3	  bne   v0,x0,gvn6	; keep looping as long as we have identifier chars
                        	
                        	  ; check for a variable type
                        	gvn2:
FFFC31B8 000E4983		lbu   a1,[$t2]
FFFC31BC 02506D93		ldi		$t1,#'%'
FFFC31C0 01B98A63		beq		a1,$t1,gvn3
FFFC31C4 02406D93		ldi		$t1,#'$'
FFFC31C8 01B98663		beq		a1,$t1,gvn3
FFFC31CC FFFE0E13	  sub		$t2,$t2,#1
FFFC31D0 02E06993	  ldi		$a1,#'.'		; if no variable type assume float
                        	
                        	  ; insert variable type indicator and return
                        	gvn3:
FFFC31D4 001E0E13		add		$t2,$t2,#1
FFFC31D8 00072903		lw		a0,[$sp]
FFFC31DC 00470713		add		$sp,$sp,#4	; get varname
FFFC31E0 00891913		sll		a0,a0,#8
FFFC31E4 01396833	  or    v0,a0,a1    ; add in variable type
FFFC31E8 00072283	  lw		r5,[$sp]
FFFC31EC 00472083	  lw		$ra,4[$sp]
FFFC31F0 00870713	  add		$sp,$sp,#8
FFFC31F4 00008067	  ret								; return a0 = varname
                        	
                        	  ; not a variable name
                        	gvn1:
FFFC31F8 00470713		add		$sp,$sp,#4	; pop a0 (varname)
FFFC31FC 00072283		lw		r5,[$sp]
FFFC3200 00472083	  lw		$ra,4[$sp]
FFFC3204 00870713		add		$sp,$sp,#8
FFFC3208 00006833	  mov		v0,x0       ; return v0 = 0 if not a varname
FFFC320C 00008067	  ret
                        	
                        	
                        	; Find variable
                        	;   a0 = varname
                        	;		a1 = allocate flag
                        	; Returns
                        	;   v0 = variable address, Z =0 if found / allocated, Z=1 if not found
                        	
                        	findVar:
FFFC3210 FF870713		sub		$sp,$sp,#8
FFFC3214 00772023		sw		x7,[$sp]
FFFC3218 00372223		sw		x3,4[$sp]
FFFC321C 70802183	  lw    x3,VARBGN
                        	fv4:
FFFC3220 0001A383	  lw    x7,[x3]     ; get varname / type
FFFC3224 02038663	  beq   x7,x0,fv3		; no more vars ?
FFFC3228 02790863	  beq   a0,x7,fv1		; match ?
FFFC322C 00818193		add		x3,x3,#8		; move to next var
FFFC3230 70C02383	  lw    x7,VAREND		; 
FFFC3234 FE71C6E3	  blt   x3,x7,fv4		; loop back to look at next var
                        	
                        	  ; variable not found
                        	  ; no more memory
FFFC3238 00072383	  lw		x7,[$sp]
FFFC323C 00472183	  lw		x3,4[$sp]
FFFC3240 00870713	  add		$sp,$sp,#8
FFFC3244 FFFC4937	  ldi		a0,#msgVarSpace
FFFC3248 BF690913
FFFC324C 29C0006F	  jmp   ERROR
                        	
                        	  ; variable not found
                        	  ; allocate new ?
                        	fv3:
FFFC3250 00098E63		beq		a1,x0,fv2
FFFC3254 0121A023	  sw    a0,[x3]     ; save varname / type
                        	  ; found variable
                        	  ; return address
                        	fv1:
FFFC3258 00418813	  add		v0,x3,#4
FFFC325C 00072383	  lw		x7,[$sp]
FFFC3260 00472183	  lw		x3,4[$sp]
FFFC3264 00870713	  add		$sp,$sp,#8
FFFC3268 00008067	  ret			    			; v0 = address
                        	
                        	  ; didn't find var and not allocating
                        	fv2:
FFFC326C 00072383	  lw		x7,[$sp]
FFFC3270 00472183	  lw		x3,4[$sp]
FFFC3274 00870713	  add		$sp,$sp,#8
FFFC3278 00006833		mov		v0,x0				; v0 = nullptr
FFFC327C 00008067	  ret
                        	
                        	; The following functions are entered via a jump instruction with
                        	; the return address already saved.
                        	
                        	; ===== The PEEK function returns the byte stored at the address
                        	;	contained in the following expression.
                        	;
                        	PEEK:
FFFC3280 DFDFF0EF		call	PARN		; get the memory address
FFFC3284 00080803		lb		v0,[v0]		; get the addressed byte
FFFC3288 000068B3		mov		v1,x0			; type = int
FFFC328C 00072083		lw		$ra,[$sp]
FFFC3290 00470713		add		$sp,$sp,#4
FFFC3294 00008067		ret
                        	PEEKW:
FFFC3298 DE5FF0EF		call	PARN		; get the memory address
FFFC329C 00082803		lw		v0,[v0]		; get the addressed word
FFFC32A0 000068B3		mov		v1,x0			; type = int
FFFC32A4 00072083		lw		$ra,[$sp]
FFFC32A8 00470713		add		$sp,$sp,#4
FFFC32AC 00008067		ret
                        	PEEKH:
FFFC32B0 DCDFF0EF		call	PARN		; get the memory address
FFFC32B4 00081803		lh		v0,[v0]		; get the addressed byte
FFFC32B8 000068B3		mov		v1,x0			; type = int
FFFC32BC 00072083		lw		$ra,[$sp]
FFFC32C0 00470713		add		$sp,$sp,#4
FFFC32C4 00008067		ret
                        	
                        	
                        	; user function call
                        	; call the user function with argument in a0, type in a1
                        	USRX:
FFFC32C8 FFC70713		sub		$sp,$sp,#4
FFFC32CC 01A72023		sw		$t0,[$sp]
FFFC32D0 DADFF0EF		call	PARN		; get expression value
FFFC32D4 00086933		mov		a0,v0
FFFC32D8 0008E9B3		mov		a1,v1
FFFC32DC FFC70713		sub		$sp,$sp,#4	; save the text pointer
FFFC32E0 01C72023		sw		$t2,[$sp]
FFFC32E4 7A002D03		lw		$t0,usrJmp
FFFC32E8 000D00E7		call	[$t0]			; get usr vector, jump to the subroutine
FFFC32EC 00072E03		lw		$t2,[$sp]	; restore the text pointer
FFFC32F0 00470713		add		$sp,$sp,#4
FFFC32F4 00072D03		lw		$t0,[$sp]
FFFC32F8 00470713		add		$sp,$sp,#4
FFFC32FC 00072083		lw		$ra,[$sp]
FFFC3300 00470713		add		$sp,$sp,#4
FFFC3304 00008067		ret
                        	
                        	
                        	; ===== The RND function returns a random number from 1 to
                        	;	the value of the following expression in D0.
                        	;
                        	RND:
FFFC3308 D75FF0EF		call	PARN		; get the upper limit
FFFC330C 04080063		beq		v0,r0,rnd2	; it must be positive and non-zero
FFFC3310 02084663		blt		v0,r0,rnd1
FFFC3314 000869B3		mov		a1,v0
FFFC3318 000868B3		mov		v1,v0
FFFC331C 00000637		call	gen_rand	; generate a random number
FFFC3320 276600E7
FFFC3324 03186833		rem		v0,v0,v1
FFFC3328 00180813		add		v0,v0,#1
FFFC332C 000068B3		mov		v1,x0
FFFC3330 00072083		lw		$ra,[$sp]
FFFC3334 00470713		add		$sp,$sp,#4
FFFC3338 00008067		ret
                        	rnd1:
FFFC333C FFFC4937		ldi		a0,#msgRNDBad
FFFC3340 C6090913
FFFC3344 00470713		add		$sp,$sp,#4
FFFC3348 1A00006F		jmp		ERROR
                        	rnd2:
FFFC334C 00000637		call	gen_rand	; generate a random number
FFFC3350 276600E7
FFFC3354 000068B3		mov		v1,x0
FFFC3358 00072083		lw		$ra,[$sp]
FFFC335C 00470713		add		$sp,$sp,#4
FFFC3360 00008067		ret
                        	
                        	; ===== The ABS function returns an absolute value in a1.
                        	;
                        	ABS:
FFFC3364 D19FF0EF		call	PARN		; get the following expr.'s value
FFFC3368 00084863		blt		v0,r0,ABS1
FFFC336C 00072083		lw		$ra,[$sp]
FFFC3370 00470713		add		$sp,$sp,#4
FFFC3374 00008067		ret
                        	ABS1:
FFFC3378 41000833		sub		v0,x0,v0
FFFC337C 00072083		lw		$ra,[$sp]
FFFC3380 00470713		add		$sp,$sp,#4
FFFC3384 00008067		ret
                        	
                        	
                        	;==== The TICK function returns the cpu tick value in a0.
                        	;
                        	TICKX:
FFFC3388 C0001873		csrrw	v0,#$C00,x0
FFFC338C 000068B3		mov		v1,x0
FFFC3390 00072083		lw		$ra,[$sp]
FFFC3394 00470713		add		$sp,$sp,#4
FFFC3398 00008067		ret
                        	
                        	; ===== The SGN function returns the sign in a0. +1,0, or -1
                        	;
                        	SGN:
FFFC339C CE1FF0EF		call	PARN		; get the following expr.'s value
FFFC33A0 000068B3		mov		v1,x0
FFFC33A4 02080463		beq		v0,r0,SGN1
FFFC33A8 00084A63		blt		v0,r0,SGN2
FFFC33AC 00106813		ldi		v0,#1
FFFC33B0 00072083		lw		$ra,[$sp]
FFFC33B4 00470713		add		$sp,$sp,#4
FFFC33B8 00008067		ret
                        	SGN2:
FFFC33BC FFF06813		ldi		v0,#-1
FFFC33C0 00072083		lw		$ra,[$sp]
FFFC33C4 00470713		add		$sp,$sp,#4
FFFC33C8 00008067		ret
                        	SGN1:
FFFC33CC 00072083		lw		$ra,[$sp]
FFFC33D0 00470713		add		$sp,$sp,#4
FFFC33D4 00008067		ret	
                        	
                        	; ===== The SIZE function returns the size of free memory in v0.
                        	; does not consider memory used by @()
                        	;
                        	SIZEX:
FFFC33D8 70802803		lw		v0,VARBGN	; get the number of free bytes...
FFFC33DC 70402883		lw		v1,TXTUNF	; between 'TXTUNF' and 'VARBGN'
FFFC33E0 41180833		sub		v0,v0,v1
FFFC33E4 000068B3		mov		v1,x0			; type = int
FFFC33E8 00072083		lw		$ra,[$sp]
FFFC33EC 00470713		add		$sp,$sp,#4
FFFC33F0 00008067		ret					; return the number in v0
                        	
                        	
                        	;******************************************************************
                        	;
                        	; *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                        	;
                        	; 'SETVAL' expects a variable, followed by an equal sign and then
                        	; an expression.  It evaluates the expression and sets the variable
                        	; to that value.
                        	;
                        	; returns
                        	; a1 = variable's address
                        	;
                        	SETVAL:
FFFC33F4 FFC70713		sub		$sp,$sp,#4
FFFC33F8 00172023		sw		$ra,[$sp]
FFFC33FC 00106913	  ldi		a0,#1		; allocate var
FFFC3400 CBDFF0EF	  call	TSTV		; variable name?
FFFC3404 00081A63	  bne		v0,x0,.sv2
FFFC3408 FFFC4937	 	ldi		a0,#msgVar
FFFC340C C4A90913
FFFC3410 00470713		add		$sp,$sp,#4
FFFC3414 0D40006F	 	jmp		ERROR 
                        	.sv2:
FFFC3418 FFC70713		sub		$sp,$sp,#4
FFFC341C 01072023		sw		v0,[$sp]	; save the variable's address
FFFC3420 558000EF		call	TSTC			; get past the "=" sign
FFFC3424 0000003D		dw		'='
FFFC3428 02000663		bra		SV1
FFFC342C 851FF0EF		call	OREXPR		; evaluate the expression
FFFC3430 00072983		lw		a1,[$sp]	; get back the variable's address
FFFC3434 00470713		add		$sp,$sp,#4
FFFC3438 0109A023		sw    v0,[a1]   ; and save value in the variable
FFFC343C 0009E833		mov		v0,a1			; return v0 = variable address
FFFC3440 FFC9A883		lw		v1,-4[a1]
FFFC3444 0FF8F893		and		v1,v1,#$FF
FFFC3448 00072083		lw		$ra,[$sp]
FFFC344C 00470713		add		$sp,$sp,#4
FFFC3450 00008067		ret
                        	SV1:
FFFC3454 00470713		add		$sp,$sp,#4
FFFC3458 0880006F	  jmp	  QWHAT		; if no "=" sign
                        	
                        	
                        	; 'FIN' checks the end of a command.  If it ended with ":",
                        	; execution continues.	If it ended with a CR, it finds the
                        	; the next line and continues from there.
                        	;
                        	FIN:
FFFC345C FFC70713		sub		$sp,$sp,#4
FFFC3460 00172023		sw		$ra,[$sp]
FFFC3464 514000EF		call	TSTC		; *** FIN ***
FFFC3468 0000003A		dw		':'
FFFC346C 00000663		bra		FI1
FFFC3470 00470713		add		$sp,$sp,#4	; if ":", discard return address
FFFC3474 814FF06F		jmp		RUNSML		; continue on the same line
                        	FI1:
FFFC3478 500000EF		call	TSTC		; not ":", is it a CR?
FFFC347C 0000000D		dw		CR
FFFC3480 00000663		bra		FI2
                        							; else return to the caller
FFFC3484 00470713		add		$sp,$sp,#4	; yes, purge return address
FFFC3488 F99FE06F		jmp		RUNNXL		; execute the next line
                        	FI2:
FFFC348C 00072083		lw		$ra,[$sp]
FFFC3490 00470713		add		$sp,$sp,#4
FFFC3494 00008067		ret					; else return to the caller
                        	
                        	
                        	; 'ENDCHK' checks if a command is ended with a CR. This is
                        	; required in certain commands, such as GOTO, RETURN, STOP, etc.
                        	;
                        	; Check that there is nothing else on the line
                        	; Registers Affected
                        	;   a0
                        	;
                        	ENDCHK:
FFFC3498 FFC70713		sub		$sp,$sp,#4
FFFC349C 00172023		sw		$ra,[$sp]
FFFC34A0 598000EF		call	IGNBLK
FFFC34A4 000E4903		lbu		a0,[$t2]
FFFC34A8 00D06D93		ldi		$t1,#CR
FFFC34AC 01B90863		beq		a0,$t1,ec1	; does it end with a CR?
FFFC34B0 FFFC4937		ldi		a0,#msgExtraChars
FFFC34B4 D1B90913
FFFC34B8 0300006F		jmp		ERROR
                        	ec1:
FFFC34BC 00072083		lw		$ra,[$sp]
FFFC34C0 00470713		add		$sp,$sp,#4
FFFC34C4 00008067		ret
                        	
                        	; 'ERROR' prints the string pointed to by a0. It then prints the
                        	; line pointed to by CURRNT with a "?" inserted at where the
                        	; old text pointer (should be on top of the stack) points to.
                        	; Execution of Tiny BASIC is stopped and a warm start is done.
                        	; If CURRNT is zero (indicating a direct command), the direct
                        	; command is not printed. If CURRNT is -1 (indicating
                        	; 'INPUT' command in progress), the input line is not printed
                        	; and execution is not terminated but continues at 'INPERR'.
                        	;
                        	; Related to 'ERROR' are the following:
                        	; 'QWHAT' saves text pointer on stack and gets "What?" message.
                        	; 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                        	; 'QSORRY' and 'ASORRY' do the same kind of thing.
                        	; 'QHOW' and 'AHOW' also do this for "How?".
                        	;
                        	TOOBIG:
FFFC34C8 FFFC4937		ldi		a0,#msgTooBig
FFFC34CC D0790913
FFFC34D0 00000C63		bra		ERROR
                        	QSORRY:
FFFC34D4 FFFC4937	  ldi		a0,#SRYMSG
FFFC34D8 BAF90913
FFFC34DC 00000663		bra	    ERROR
                        	QWHAT:
FFFC34E0 FFFC4937		ldi		a0,#msgWhat
FFFC34E4 BA890913
                        	ERROR:
FFFC34E8 630000EF		call	PRMESG		; display the error message
FFFC34EC 71802903		lw		a0,CURRNT	; get the current line pointer
FFFC34F0 02090C63		beq		a0,r0,ERROR1	; if zero, do a warm start
FFFC34F4 FFF06D93		ldi		$t1,#-1
FFFC34F8 ADB90E63		beq		a0,$t1,INPERR	; is the line no. pointer = -1? if so, redo input
FFFC34FC 000E4283		lbu		r5,[$t2]		; save the char. pointed to
FFFC3500 000E0023		sb		x0,[$t2]		; put a zero where the error is
FFFC3504 71802903		lw		a0,CURRNT	; point to start of current line
FFFC3508 414000EF		call	PRTLN		; display the line in error up to the 0
FFFC350C 00096333		mov     r6,a0	    ; save off end pointer
FFFC3510 005E0023		sb		r5,[$t2]		; restore the character
FFFC3514 03F06913		ldi		a0,#'?'		; display a "?"
FFFC3518 AF1FE0EF		call	GOOUT
FFFC351C 000069B3		mov		a1,r0		; stop char = 0
FFFC3520 FFF30913		sub		a0,r6,#1	; point back to the error char.
FFFC3524 228000EF		call	PRTSTG		; display the rest of the line
                        	ERROR1:
FFFC3528 B85FE06F		jmp	    WSTART		; and do a warm start
                        	
                        	;******************************************************************
                        	;
                        	; *** GETLN *** FNDLN (& friends) ***
                        	;
                        	; 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                        	; the character in r3 (given by the caller), then it fills the
                        	; buffer and echos. It ignores LF's but still echos
                        	; them back. Control-H is used to delete the last character
                        	; entered (if there is one), and control-X is used to delete the
                        	; whole line and start over again. CR signals the end of a line,
                        	; and causes 'GETLN' to return.
                        	;
                        	;
                        	GETLN:
FFFC352C FF870713		sub		$sp,$sp,#8
FFFC3530 00572023		sw		r5,[$sp]
FFFC3534 00172223		sw		$ra,4[$sp]
FFFC3538 AD1FE0EF		call	GOOUT		; display the prompt
FFFC353C 00106913		ldi		a0,#1
                        	;	sw		a0,CursorFlash	; turn on cursor flash
FFFC3540 02006913		ldi		a0,#' '		; and a space
FFFC3544 AC5FE0EF		call	GOOUT
FFFC3548 71C06E13		ldi		$t2,#BUFFER	; $t2 is the buffer pointer
                        	.GL1:
FFFC354C 59C000EF		call	CHKIO		; check keyboard
FFFC3550 FE080EE3		beq		v0,x0,.GL1	; wait for a char. to come in
FFFC3554 00806D93		ldi		$t1,#CTRLH
FFFC3558 05B80663		beq		v0,$t1,.GL3	; delete last character? if so
FFFC355C 01806D93		ldi		$t1,#CTRLX
FFFC3560 07B80663		beq		v0,$t1,.GL4	; delete the whole line?
FFFC3564 00D06D93		ldi		$t1,#CR
FFFC3568 01B80663		beq		v0,$t1,.GL2		; accept a CR
FFFC356C 02006D93		ldi		$t1,#' '
FFFC3570 FDB84EE3		blt		v0,$t1,.GL1	; if other control char., discard it
                        	.GL2:
FFFC3574 010E0023		sb		v0,[$t2]		; save the char.
FFFC3578 001E0E13		add		$t2,$t2,#1
FFFC357C FFC70713		sub		$sp,$sp,#4
FFFC3580 01072023		sw		v0,[$sp]
FFFC3584 00086933		mov		$a0,$v0
FFFC3588 A81FE0EF		call	GOOUT		; echo the char back out
FFFC358C 00072803		lw		v0,[$sp]; get char back (GOOUT destroys a0)
FFFC3590 00470713		add		$sp,$sp,#4
FFFC3594 00D06D93		ldi		$t1,#CR
FFFC3598 07B80663		beq		v0,$t1,.GL7			; if it's a CR, end the line
FFFC359C 76F06D93		ldi		$t1,#BUFFER+BUFLEN-1
FFFC35A0 FBBE46E3		blt		$t2,$t1,.GL1		; any more room? ; yes: get some more, else delete last char.
                        	.GL3:
FFFC35A4 00806913		ldi		a0,#CTRLH	; delete a char. if possible
FFFC35A8 A61FE0EF		call	GOOUT
FFFC35AC 02006913		ldi		a0,#' '
FFFC35B0 A59FE0EF		call	GOOUT
FFFC35B4 71C06D93		ldi		$t1,#BUFFER
FFFC35B8 F9CDDAE3		ble		$t2,$t1,.GL1	; any char.'s left?	; if not
FFFC35BC 00806913		ldi		a0,#CTRLH		; if so, finish the BS-space-BS sequence
FFFC35C0 A49FE0EF		call	GOOUT
FFFC35C4 FFFE0E13		sub		$t2,$t2,#1	; decrement the text pointer
FFFC35C8 F80002E3		bra		.GL1		; back for more
                        	.GL4:
FFFC35CC 000E6933		mov		a0,$t2		; delete the whole line
FFFC35D0 8E490293		sub		r5,a0,#BUFFER   ; figure out how many backspaces we need
FFFC35D4 02028463		beq		r5,r0,.GL6		; if none needed, brnch
FFFC35D8 FFF28293		sub		r5,r5,#1		; loop count is one less
                        	.GL5:
FFFC35DC 00806913		ldi		a0,#CTRLH		; and display BS-space-BS sequences
FFFC35E0 A29FE0EF		call	GOOUT
FFFC35E4 02006913		ldi		a0,#' '
FFFC35E8 A21FE0EF		call	GOOUT
FFFC35EC 00806913		ldi		a0,#CTRLH
FFFC35F0 A19FE0EF		call	GOOUT
FFFC35F4 FFF28293		sub		r5,r5,#1
FFFC35F8 FE0292E3		bne		r5,r0,.GL5
                        	.GL6:
FFFC35FC 71C06E13		ldi		$t2,#BUFFER	; reinitialize the text pointer
FFFC3600 F40006E3		bra		.GL1		; and go back for more
                        	.GL7:
FFFC3604 000E0023		sb		x0,[$t2]		; null terminate line
                        	;	sw		x0,CursorFlash	; turn off cursor flash
FFFC3608 00A06913		ldi		a0,#LINEFD	; echo a LF for the CR
FFFC360C 9FDFE0EF		call	GOOUT
FFFC3610 00072283		lw		r5,[$sp]
FFFC3614 00472083		lw		$ra,4[$sp]
FFFC3618 00870713		add		$sp,$sp,#8
FFFC361C 00008067		ret
                        	
                        	
                        	; 'FNDLN' finds a line with a given line no. (in a0) in the
                        	; text save area.  $t3 is used as the text pointer. If the line
                        	; is found, $t3 will point to the beginning of that line
                        	; (i.e. the high byte of the line no.), and $v0 = 1.
                        	; If that line is not there and a line with a higher line no.
                        	; is found, $t3 points there and $v0 = 0. If we reached
                        	; the end of the text save area and cannot find the line, flags
                        	; $t3 = 0, $v0 = 0.
                        	; $v0=1 if line found
                        	; r0 = 1	<= line is found
                        	;	$t3 = pointer to line
                        	; r0 = 0    <= line is not found
                        	;	r9 = zero, if end of text area
                        	;	r9 = otherwise higher line number
                        	;
                        	; 'FNDLN' will initialize $t3 to the beginning of the text save
                        	; area to start the search. Some other entries of this routine
                        	; will not initialize $t3 and do the search.
                        	; 'FNDLNP' will start with $t3 and search for the line no.
                        	; 'FNDNXT' will bump $t3 by 4, find a CR and then start search.
                        	; 'FNDSKP' uses $t3 to find a CR, and then starts the search.
                        	; return Z=1 if line is found, r9 = pointer to line
                        	;
                        	; Parameters
                        	;	a0 = line number to find
                        	;
                        	FNDLN:
FFFC3620 00100DB7		ldi		$t1,#$FFFFF
FFFC3624 FFFD8D93
FFFC3628 01B94863		blt		a0,$t1,fl1	; line no. must be < 65535
FFFC362C FFFC4937		ld		a0,#msgLineRange
FFFC3630 C3590913
FFFC3634 EB5FF06F		jmp		ERROR
                        	fl1:
FFFC3638 00002EB7		ldi		$t3,#TXTBGN	; init. the text save pointer
FFFC363C 800E8E93
                        	
                        	FNDLNP:
FFFC3640 70402F03		lw		$t4,TXTUNF	; check if we passed the end
FFFC3644 03EEFA63		bgeu	$t3,$t4,FNDRET1; if so, return with r9=0,a0=0
FFFC3648 FF870713		sub		$sp,$sp,#8	; push a0
FFFC364C 01272023		sw		a0,[$sp]
FFFC3650 00172223		sw		ra,4[$sp]
FFFC3654 000EE933		mov		a0,t3
FFFC3658 298000EF		call	LoadWord		; get line number
FFFC365C 00072903		lw		a0,[$sp]		; pop a0
FFFC3660 00472083		lw		ra,4[$sp]
FFFC3664 00870713		add		$sp,$sp,#8
FFFC3668 01280C63		beq		v0,a0,FNDRET2
FFFC366C 01286E63		bltu	v0,a0,FNDNXT	; is this the line we want? no, not there yet
                        	FNDRET:
FFFC3670 00006833		mov		v0,x0	; line not found, but $t3=next line pointer
FFFC3674 00008067		ret
                        	FNDRET1:
                        	;	eor		r9,r9,r9	; no higher line
FFFC3678 00006833		mov		v0,x0	; line not found
FFFC367C 00008067		ret
                        	FNDRET2:
FFFC3680 00106813		ldi		v0,#1	; line found
FFFC3684 00008067		ret
                        	
                        	FNDNXT:
FFFC3688 004E8E93		add		$t3,$t3,#4	; find the next line
                        	
                        	FNDSKP:
FFFC368C 000EC883		lbu		v1,[$t3]
FFFC3690 001E8E93		add		$t3,$t3,#1
FFFC3694 00D06D93		ldi		$t1,#CR
FFFC3698 FFB89AE3		bne		v1,$t1,FNDSKP	; try to find a CR, keep looking
FFFC369C FA0002E3		bra		FNDLNP		; check if end of text
                        	
                        	
                        	;******************************************************************
                        	; 'MVUP' moves a block up from where a0 points to where a1 points
                        	; until a0=a2
                        	;
                        	MVUP1:
FFFC36A0 00090203		lb		r4,[a0]
FFFC36A4 00498023		sb		r4,[a1]
FFFC36A8 00190913		add		a0,a0,#1
FFFC36AC 00198993		add		a1,a1,#1
                        	MVUP:
FFFC36B0 FF4918E3		bne		a0,a2,MVUP1
FFFC36B4 00008067		ret
                        	
                        	
                        	; 'MVDOWN' moves a block down from where a0 points to where a1
                        	; points until a0=a2
                        	;
                        	MVDOWN1:
FFFC36B8 FFF90913		sub		a0,a0,#1
FFFC36BC FFF98993		sub		a1,a1,#1
FFFC36C0 00090203		lb		r4,[a0]
FFFC36C4 00498023		sb		r4,[a1]
                        	MVDOWN:
FFFC36C8 FF4918E3		bne		a0,a2,MVDOWN1
FFFC36CC 00008067		ret
                        	
                        	
                        	; 'POPA_' restores the 'FOR' loop variable save area from the stack
                        	;
                        	; 'PUSHA_' stacks for 'FOR' loop variable save area onto the stack
                        	;
                        	; Note: a single zero word is stored on the stack in the
                        	; case that no FOR loops need to be saved. This needs to be
                        	; done because PUSHA_ / POPA_ is called all the time.
                        	//message "POPA_"
                        	POPA_:
FFFC36D0 00072903		lw		a0,[$sp]
FFFC36D4 00470713		add		$sp,$sp,#4
FFFC36D8 71202823		sw		a0,LOPVAR	; restore LOPVAR, but zero means no more
FFFC36DC 02090463		beq		a0,x0,PP1
FFFC36E0 00072903		lw		a0,[$sp]
FFFC36E4 77202823		sw		a0,LOPPT
FFFC36E8 00472903		lw		a0,4[$sp]
FFFC36EC 77202A23		sw		a0,LOPLN
FFFC36F0 00872903		lw		a0,8[$sp]
FFFC36F4 77202E23		sw		a0,LOPLMT
FFFC36F8 00C72903		lw		a0,12[$sp]
FFFC36FC 77202C23		sw		a0,LOPINC
FFFC3700 01070713		add		$sp,$sp,#16
                        	PP1:
FFFC3704 00008067		ret
                        	
                        	
                        	PUSHA_:
FFFC3708 79C02903		lw		a0,STKBOT	; Are we running out of stack room?
FFFC370C 01490913		add		a0,a0,#20	; we might need this many bytes
FFFC3710 DD2742E3		blt		$sp,a0,QSORRY	; out of stack space
FFFC3714 71002983		lw		a1,LOPVAR		; save loop variables
FFFC3718 02098463		beq		a1,x0,PU1		; if LOPVAR is zero, that's all
FFFC371C FF070713		sub		$sp,$sp,#16
FFFC3720 77002903		lw		a0,LOPPT
FFFC3724 01272023		sw		a0,[$sp]
FFFC3728 77402903		lw		a0,LOPLN
FFFC372C 01272223		sw		a0,4[$sp]
FFFC3730 77C02903		lw		a0,LOPLMT
FFFC3734 01272423		sw		a0,8[$sp]
FFFC3738 77802903		lw		a0,LOPINC
FFFC373C 01272623		sw		a0,12[$sp]
                        	PU1:
FFFC3740 FFC70713		sub		$sp,$sp,#4
FFFC3744 01372023		sw		a1,[$sp]
FFFC3748 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	;
                        	; 'PRTSTG' prints a string pointed to by a0. It stops printing
                        	; and returns to the caller when either a CR is printed or when
                        	; the next byte is the same as what was passed in a1 by the
                        	; caller.
                        	;
                        	; 'PRTLN' prints the saved text line pointed to by r3
                        	; with line no. and all.
                        	;
                        	
                        	; a0 = pointer to string
                        	; a1 = stop character
                        	; return v0 = pointer to end of line + 1
                        	
                        	PRTSTG:
FFFC374C FEC70713		sub		$sp,$sp,#20
FFFC3750 00572023		sw		r5,[$sp]
FFFC3754 00672223		sw		r6,4[$sp]
FFFC3758 00772423		sw		r7,8[$sp]
FFFC375C 00172623		sw		$ra,12[$sp]
FFFC3760 01272823		sw		$a0,16[$sp]
FFFC3764 000962B3		mov   r5,a0	    ; r5 = pointer
FFFC3768 0009E333		mov   r6,a1	    ; r6 = stop char
                        	.PS1:
FFFC376C 0002C383	  lbu   r7,[r5]     ; get a text character
FFFC3770 00128293		add		r5,r5,#1
FFFC3774 00638E63		beq	  r7,r6,.PRTRET	; same as stop character? if so, return
FFFC3778 0003E933		mov   a0,r7
FFFC377C 88DFE0EF		call	GOOUT		; display the char.
FFFC3780 00D06D93		ldi		$t1,#CR
FFFC3784 FFB394E3		bne   r7,$t1,.PS1	; is it a C.R.? no, go back for more
FFFC3788 00A06913		ldi		a0,#LINEFD  ; yes, add a L.F.
FFFC378C 87DFE0EF		call	GOOUT
                        	.PRTRET:
FFFC3790 0003E8B3	  mov   v1,r7	    ; return a1 = stop char
FFFC3794 0002E833		mov		v0,r5		; return a0 = line pointer
FFFC3798 00072283		lw		$r5,[$sp]
FFFC379C 00472303		lw		$r6,4[$sp]
FFFC37A0 00872383		lw		$r7,8[$sp]
FFFC37A4 00C72083		lw		$ra,12[$sp]
FFFC37A8 01072903		lw		$a0,16[$sp]
FFFC37AC 01470713		add		$sp,$sp,#20
FFFC37B0 00008067	  ret					; then return
                        	
                        	
                        	; 'QTSTG' looks for an underline (back-arrow on some systems),
                        	; single-quote, or double-quote.  If none of these are found, returns
                        	; to the caller.  If underline, outputs a CR without a LF.  If single
                        	; or double quote, prints the quoted string and demands a matching
                        	; end quote.  After the printing, the next i-word of the caller is
                        	; skipped over (usually a branch instruction).
                        	;
                        	QTSTG:
FFFC37B4 FFC70713		sub		$sp,$sp,#4
FFFC37B8 00172023		sw		$ra,[$sp]
FFFC37BC 1BC000EF		call	TSTC		; *** QTSTG ***
FFFC37C0 00000022		dw		'"'
FFFC37C4 02000063		bra		QT3
FFFC37C8 02206993		ldi		a1,#'"'		; it is a "
                        	QT1:
FFFC37CC 000E6933		mov		a0,$t2
FFFC37D0 F7DFF0EF		call	PRTSTG		; print until another
FFFC37D4 00086E33		mov		$t2,v0
FFFC37D8 00D06D93		ldi		$t1,#CR
FFFC37DC 03B89863		bne		v1,$t1,QT2	; was last one a CR?
FFFC37E0 C41FE06F		jmp		RUNNXL		; if so run next line
                        	QT3:
FFFC37E4 194000EF		call	TSTC		; is it a single quote?
FFFC37E8 0000005C		dw		'\''
FFFC37EC 00000663		bra		QT4
FFFC37F0 02706993		ldi		a1,#'\''	; if so, do same as above
FFFC37F4 FC000CE3		bra		QT1
                        	QT4:
FFFC37F8 180000EF		call	TSTC		; is it an underline?
FFFC37FC 0000005F		dw		'_'
FFFC3800 00000C63		bra		QT5
FFFC3804 00D06913		ldi		a0,#CR		; if so, output a CR without LF
FFFC3808 801FE0EF		call	GOOUT
                        	QT2:
FFFC380C 00072083		lw		$ra,[$sp]		; get return address
FFFC3810 00470713		add		$sp,$sp,#4
FFFC3814 00408067		jmp		4[$ra]		; skip following branch
                        	QT5:					; not " ' or _
FFFC3818 00072083		lw		$ra,[$sp]		; get return address
FFFC381C 00470713		add		$sp,$sp,#4
FFFC3820 00008067		ret
                        	
                        	; Output a CR LF sequence
                        	;
                        	prCRLF:
FFFC3824 FFC70713		sub		$sp,$sp,#4
FFFC3828 00172023		sw		$ra,[$sp]
FFFC382C 00D06913		ldi		a0,#CR
FFFC3830 FD8FE0EF		call	GOOUT
FFFC3834 00A06913		ldi		a0,#LINEFD
FFFC3838 FD0FE0EF		call	GOOUT
FFFC383C 00072083		lw		$ra,[$sp]
FFFC3840 00470713		add		$sp,$sp,#4
FFFC3844 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; 'PRTNUM' prints the 32 bit number in a0, leading blanks are added if
                        	; needed to pad the number of spaces to the number in a1.
                        	; However, if the number of digits is larger than the no. in
                        	; a1, all digits are printed anyway. Negative sign is also
                        	; printed and counted in, positive sign is not.
                        	;
                        	; Parameters
                        	; 	a0 = number to print
                        	; 	a1 = number of digits
                        	;		a2 = base (eg 10, 16)
                        	; Register Usage
                        	;		s2 = number of padding spaces
                        	; Modifies:
                        	;		a0,a1,t1
                        	; Returns:
                        	;		none
                        	;-------------------------------------------------------------------------------
                        	
FFFC3848 FEC70713	public PRTNUM:
	sub		$sp,$sp,#20
FFFC384C 00472023		sw		$s1,[$sp]
FFFC3850 00572223		sw		$s2,4[$sp]
FFFC3854 00672423		sw		$s3,8[$sp]
FFFC3858 00772623		sw		$s4,12[$sp]
FFFC385C 00172823		sw		$ra,16[$sp]
FFFC3860 79406393		ldi		s4,#NUMWKA	; r7 = pointer to numeric work area
FFFC3864 00096333		mov		s3,a0		; save number for later
FFFC3868 0009E2B3		mov		s2,a1		; s2 = min number of chars
FFFC386C 00095663		bge		a0,x0,.PN2	; is it negative? if not
FFFC3870 41200933		sub		a0,x0,a0	; else make it positive
FFFC3874 FFF28293		sub		s2,s2,#1	; one less for width count
                        	.PN2:
FFFC3878 00A06D93		ldi		$t1,#10
                        	.PN1:
FFFC387C 034969B3		rem		a1,a0,a2	; a1 = a0 mod 10
FFFC3880 03494933		div		a0,a0,a2	; a0 /= 10 divide by 10
FFFC3884 013A7463		bleu	a1,a2,.PN7
FFFC3888 00798993		add		a1,a1,#'A'-10-'0'
                        	.PN7:
FFFC388C 03098993		add		a1,a1,#'0'	; convert remainder to ascii
FFFC3890 01338023		sb		a1,[$s4]		; and store in buffer
FFFC3894 00138393		add		s4,s4,#1
FFFC3898 FFF28293		sub		s2,s2,#1	; decrement width
FFFC389C FE0910E3		bne		a0,x0,.PN1
FFFC38A0 00505A63		ble		$s2,$x0,.PN4	; test pad count, skip padding if not needed
                        	.PN3:
FFFC38A4 02006913		ldi		$a0,#' '		; display the required leading spaces
FFFC38A8 F60FE0EF		call	GOOUT
FFFC38AC FFF28293		sub		$s2,$s2,#1
FFFC38B0 FE504AE3		bgt		$s2,$x0,.PN3
                        	.PN4:
FFFC38B4 00035663		bge		$s3,$x0,.PN5	; is number negative?
FFFC38B8 02D06913		ldi		$a0,#'-'		; if so, display the sign
FFFC38BC F4CFE0EF		call	GOOUT
                        	.PN5:
FFFC38C0 79406D93		ldi		$t1,#NUMWKA
                        	.PN6:
FFFC38C4 FFF38393		sub		$s4,$s4,#1
FFFC38C8 0003C903		lbu		$a0,[$s4]		; now unstack the digits and display
FFFC38CC F3CFE0EF		call	GOOUT
FFFC38D0 FE7DEAE3		bgtu	$s4,$t1,.PN6
                        	
FFFC38D4 00072203		lw		$s1,[$sp]
FFFC38D8 00472283		lw		$s2,4[$sp]
FFFC38DC 00872303		lw		$s3,8[$sp]
FFFC38E0 00C72383		lw		$s4,12[$sp]
FFFC38E4 01072083		lw		$ra,16[$sp]
FFFC38E8 01470713		add		$sp,$sp,#20
FFFC38EC 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; Load a word from memory using unaligned access.
                        	; Moves forwards through memory
                        	;
                        	; Parameters:
                        	;		a0 = pointer to word
                        	; Returns:
                        	;		v0 = word loaded
                        	;-------------------------------------------------------------------------------
                        	LoadWord:
FFFC38F0 00094803	  lbu		$v0,[$a0]	
FFFC38F4 00194883	  lbu		$v1,1[$a0]
FFFC38F8 00889893	  sll		$v1,$v1,#8
FFFC38FC 01186833	  or		$v0,$v0,$v1
FFFC3900 00294883	  lbu		$v1,2[$a0]
FFFC3904 01089893	  sll		$v1,$v1,#16
FFFC3908 01186833	  or		$v0,$v0,$v1
FFFC390C 00394883	  lbu		$v1,3[$a0]
FFFC3910 01889893	  sll		$v1,$v1,#24
FFFC3914 01186833	  or		$v0,$v0,$v1
FFFC3918 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = pointer to line
                        	; Returns:
                        	;		v0 = pointer to end of line + 1
                        	;-------------------------------------------------------------------------------
                        	
                        	PRTLN:
FFFC391C FF070713		sub		$sp,$sp,#16
FFFC3920 00572023		sw		$r5,[$sp]
FFFC3924 00172223		sw		$ra,4[$sp]
FFFC3928 01272423		sw		$a0,8[$sp]
FFFC392C 01372623		sw		$a1,12[$sp]
FFFC3930 000962B3	  mov		$r5,$a0		; r5 = pointer
                        	  ; get the line number stored as binary
                        	  ; assume unaligned loads not allowed
FFFC3934 FBDFF0EF	  call	LoadWord
FFFC3938 00086933	  mov		a0,v0
                        	
FFFC393C 00428293		add		r5,r5,#4
FFFC3940 00506993	  ldi		a1,#5       ; display a 0 or more digit line no.
FFFC3944 00A06A13	  ldi		a2,#10
FFFC3948 F01FF0EF		call	PRTNUM
FFFC394C 02006913		ldi		a0,#' '     ; followed by a blank
FFFC3950 EB8FE0EF		call	GOOUT
FFFC3954 000069B3		mov		a1,r0       ; stop char. is a zero
FFFC3958 0002E933		mov		a0,r5
FFFC395C DF1FF0EF		call  PRTSTG		; display the rest of the line
FFFC3960 00072283		lw		$r5,[$sp]
FFFC3964 00472083		lw		$ra,4[$sp]
FFFC3968 00872903		lw		$a0,8[$sp]
FFFC396C 00C72983		lw		$a1,12[$sp]
FFFC3970 01070713		add		$sp,$sp,#16
FFFC3974 00008067		ret
                        	
                        	
                        	; ===== Test text byte following the call to this subroutine. If it
                        	;	equals the byte pointed to by t2, return to the code following
                        	;	the call. 
                        	;
                        	; Parameters:
                        	;		<static> word byte to look for
                        	;		<static> branch if not found
                        	; Registers Affected
                        	;   none
                        	; Returns
                        	;		t2 = updated text pointer
                        	;
                        	TSTC:
FFFC3978 FF470713		sub		$sp,$sp,#12
FFFC397C 01272023		sw		$a0,[$sp]
FFFC3980 00172223		sw		$ra,4[$sp]
FFFC3984 01372423		sw		$a1,8[$sp]
FFFC3988 0B0000EF		call	IGNBLK		; ignore leading blanks
FFFC398C 00472083		lw		$ra,4[$sp]	; get return address, it's needed for a reference
FFFC3990 000E4903		lbu		$a0,[$t2]
FFFC3994 0000C983		lbu		$a1,[$ra]
FFFC3998 01298A63		beq		$a1,$a0,TC1	; is it = to what t2 points to? if so
FFFC399C 00072903		lw		$a0,[$sp]		; restore a0
FFFC39A0 00872983		lw		$a1,8[$sp]
FFFC39A4 00C70713		add		$sp,$sp,#12	;
FFFC39A8 00408067		jmp		4[$ra]			; jump to the routine skip param
                        	TC1:
FFFC39AC 001E0E13		add		$t2,$t2,#1	; if equal, bump text pointer
FFFC39B0 00072903		lw		$a0,[$sp]
FFFC39B4 00472083		lw		$ra,4[$sp]
FFFC39B8 00872983		lw		$a1,8[$sp]
FFFC39BC 00C70713		add		$sp,$sp,#12
FFFC39C0 00808067		jmp		8[$ra]			; jump back, skip parm and branch
                        	
                        	
                        	; ===== See if the text pointed to by $t2 is a number. If so,
                        	;	return the number in $v0 and the number of digits in $v1,
                        	;	else return zero in $v0 and $v1.
                        	; Registers Affected
                        	;   a0,a1,r3,r4
                        	; Returns
                        	; 	v0 = number
                        	;		v1 = number of digits in number
                        	;	t2 = updated text pointer
                        	;
                        	TSTNUM:
FFFC39C4 FF870713		sub		$sp,$sp,#8
FFFC39C8 00172223		sw		$ra,4[$sp]
FFFC39CC 00372023		sw		r3,[$sp]
FFFC39D0 068000EF		call	IGNBLK		; skip over blanks
FFFC39D4 00006833		mov		$v0,$x0		; initialize return parameters
FFFC39D8 000068B3		mov		$v1,$x0
                        	TN1:
FFFC39DC 000E4183		lbu		r3,[$t2]
FFFC39E0 03006D93		ldi		$t1,#'0'
FFFC39E4 05B1C263		blt		r3,$t1,TSNMRET; is it less than zero?
FFFC39E8 03906D93		ldi		$t1,#'9'
FFFC39EC 023DCE63		bgt		r3,$t1,TSNMRET; is it greater than nine?
FFFC39F0 00000DB7		ldi		$t1,#$7FFFFFFFFFFFFFF
FFFC39F4 FFFD8D93
FFFC39F8 010DF863		bleu	$v0,$t1,TN2; see if there's room for new digit
FFFC39FC FFFC4937		ldi		$a0,#msgNumTooBig
FFFC3A00 BD190913
FFFC3A04 AE5FF06F		jmp		ERROR		; if not, we've overflowd
                        	TN2:
FFFC3A08 001E0E13		add		$t2,$t2,#1	; adjust text pointer
FFFC3A0C 00181E93		sll		$t3,$v0,#1	; quickly multiply result by 10
FFFC3A10 00381813		sll		$v0,$v0,#3	; *8
FFFC3A14 01D80833		add		$v0,$v0,$t3	; *8 + *2
FFFC3A18 00F1F193		and		r3,r3,#$0F	; add in the new digit
FFFC3A1C 00380833		add		$v0,$v0,r3
FFFC3A20 00188893		add		$v1,$v1,#1	; increment the no. of digits
FFFC3A24 FA000CE3		bra		TN1
                        	TSNMRET:
FFFC3A28 00072183		lw		r3,[$sp]
FFFC3A2C 00472083		lw		$ra,4[$sp]
FFFC3A30 00870713		add		$sp,$sp,#8
FFFC3A34 00008067		ret
                        	
                        	
                        	;===== Skip over blanks in the text pointed to by $t2.
                        	;
                        	; Registers Affected:
                        	;	$t2
                        	; Returns
                        	;	$t2 = pointer updateded past any spaces or tabs
                        	;
                        	IGNBLK:
FFFC3A38 FFC70713		sub		$sp,$sp,#4
FFFC3A3C 01272023		sw		$a0,[$sp]
                        	IGB2:
FFFC3A40 000E4903		lbu		a0,[$t2]			; get char
FFFC3A44 02006D93		ldi		$t1,#' '
FFFC3A48 01B90663		beq		$a0,$t1,IGB1	; see if it's a space
FFFC3A4C 00906D93		ldi		$t1,#'\t'
FFFC3A50 01B91663		bne		a0,$t1,IGBRET	; or a tab
                        	IGB1:
FFFC3A54 001E0E13		add		$t2,$t2,#1		; increment the text pointer
FFFC3A58 FE0004E3		bra		IGB2
                        	IGBRET:
FFFC3A5C 00072903		lw		$a0,[$sp]
FFFC3A60 00470713		add		$sp,$sp,#4
FFFC3A64 00008067		ret
                        	
                        	; ===== Convert the line of text in the input buffer to upper
                        	;	case (except for stuff between quotes).
                        	;
                        	; Registers Affected
                        	;   a0,r3
                        	; Returns
                        	;	r8 = pointing to end of text in buffer
                        	;
                        	TOUPBUF:
FFFC3A68 FFC70713		sub		$sp,$sp,#4
FFFC3A6C 00172023		sw		$ra,[$sp]
FFFC3A70 71C06E13		ldi		$t2,#BUFFER	; set up text pointer
FFFC3A74 000061B3		mov		r3,x0		; clear quote flag
                        	TOUPB1:
FFFC3A78 000E4903		lbu		a0,[$t2]		; get the next text char.
FFFC3A7C 001E0E13		add		$t2,$t2,#1
FFFC3A80 00D06D93		ldi		$t1,#CR
FFFC3A84 03B90E63		beq		a0,$t1,TOUPBRT		; is it end of line?
FFFC3A88 02206D93		ldi		$t1,#'"'
FFFC3A8C 01B90E63		beq		a0,$t1,DOQUO	; a double quote?
FFFC3A90 02706D93		ldi		$t1,#'\''
FFFC3A94 01B90A63		beq		a0,$t1,DOQUO	; or a single quote?
FFFC3A98 FE0190E3		bne		r3,x0,TOUPB1	; inside quotes?
FFFC3A9C 030000EF		call	toUpper 	; convert to upper case
FFFC3AA0 FF0E0FA3		sb		v0,-1[$t2]	; store it
FFFC3AA4 FC000AE3		bra		TOUPB1		; and go back for more
                        	DOQUO:
FFFC3AA8 00019663		bne		r3,x0,DOQUO1; are we inside quotes?
FFFC3AAC 000961B3		mov		r3,a0		; if not, toggle inside-quotes flag
FFFC3AB0 FC0004E3		bra		TOUPB1
                        	DOQUO1:
FFFC3AB4 FD2192E3		bne		r3,a0,TOUPB1; make sure we're ending proper quote
FFFC3AB8 000061B3		mov		r3,r0		; else clear quote flag
FFFC3ABC FA000EE3		bra		TOUPB1
                        	TOUPBRT:
FFFC3AC0 00072083		lw		$ra,[$sp]
FFFC3AC4 00470713		add		$sp,$sp,#4
FFFC3AC8 00008067		ret
                        	
                        	
                        	; ===== Convert the character in a0 to upper case
                        	;
                        	toUpper:
FFFC3ACC 00096833		mov		$v0,$a0
FFFC3AD0 06182D93		slt		$t1,$v0,#'a'
FFFC3AD4 000D9863		bne   $t1,$x0,TOUPRET	; is it < 'a'?
FFFC3AD8 07A06D93		ldi		$t1,#'z'
FFFC3ADC 010DC463		bgt		$v0,$t1,TOUPRET	; or > 'z'?
FFFC3AE0 FE080813		sub		$v0,$v0,#32	  ; if not, make it upper case
                        	TOUPRET:
FFFC3AE4 00008067		ret
                        	
                        	; 'CHKIO' checks the input. If there's no input, it will return
                        	; to the caller with the a0=0. If there is input, the input byte is in a0.
                        	; However, if a control-C is read, 'CHKIO' will warm-start BASIC and will
                        	; not return to the caller.
                        	;
                        	//message "CHKIO"
                        	CHKIO:
FFFC3AE8 FFC70713		sub		$sp,$sp,#4
FFFC3AEC 00172023		sw		$ra,[$sp]
FFFC3AF0 044000EF		call	INCH		; get input if possible
FFFC3AF4 00080863		beq		$v0,$x0,CHKRET	; if Zero, no input
FFFC3AF8 00384893		xor		$v1,$v0,#CTRLC
FFFC3AFC 00089463		bne		$v1,$x0,CHKRET; is it control-C?
FFFC3B00 DACFE06F		jmp		WSTART		; if so, do a warm start
                        	CHKRET:
FFFC3B04 00072083		lw		$ra,[$sp]
FFFC3B08 00470713		add		$sp,$sp,#4
FFFC3B0C 00008067		ret
                        	
                        	; ===== Display a CR-LF sequence
                        	;
                        	CRLF:
FFFC3B10 FFFC4937		ldi		a0,#CLMSG
FFFC3B14 BB590913
                        	
                        	; ===== Display a zero-ended string pointed to by register a0
                        	; Registers Affected
                        	;   a0,a1,r4
                        	;
                        	PRMESG:
FFFC3B18 FFC70713		sub		$sp,$sp,#4
FFFC3B1C 00172023		sw		$ra,[$sp]
FFFC3B20 BD1FC0EF		call	SerialPutString
FFFC3B24 00072083		lw		$ra,[$sp]
FFFC3B28 00470713		add		$sp,$sp,#4
FFFC3B2C 00008067		ret
                        	
                        	;*****************************************************
                        	; The following routines are the only ones that need *
                        	; to be changed for a different I/O environment.     *
                        	;*****************************************************
                        	
                        	; ===== Output character to the console (Port 1) from register a0
                        	;	(Preserves all registers.)
                        	;
                        	OUTC:
FFFC3B30 B85FC06F		jmp		SerialPutChar
                        	
                        	; ===== Input a character from the console into register v0 (or
                        	;	return Zero status if there's no character available).
                        	;
                        	INCH:
FFFC3B34 FFC70713		sub 	$sp,$sp,#4
FFFC3B38 00172023		sw		$ra,[$sp]
FFFC3B3C B45FC0EF		call	SerialPeekChar
FFFC3B40 00180813		add		$v0,$v0,#1				; prepare test -1
FFFC3B44 00080A63		beq		$v0,$x0,INCH1			; was = -1
FFFC3B48 FFF80813		sub		$v0,$v0,#1				; get char back
FFFC3B4C 00072083		lw		$ra,[$sp]
FFFC3B50 00470713		add		$sp,$sp,#4
FFFC3B54 00008067		ret
                        	INCH1:
FFFC3B58 00072083		lw		$ra,[$sp]		; return a zero for no-char
FFFC3B5C 00470713		add		$sp,$sp,#4
FFFC3B60 00008067		ret
                        	
                        	; ===== Return to the resident monitor, operating system, etc.
                        	;
                        	//message "BYEBYE"
                        	BYEBYE:
                        	//	call	ReleaseIOFocus
FFFC3B64 70002703		lw		$sp,OSSP
FFFC3B68 E6CFC06F		jmp		Monitor
                        	 
                        	
FFFC3B6C 53430A0D	msgInit	db	CR,LINEFD,"CS01 Tiny BASIC v1.0",CR,LINEFD,"(C) 2017-2020  Robert Finch",CR,CR,0
FFFC3B70 54203130
FFFC3B74 20796E69
FFFC3B78 49534142
FFFC3B7C 31762043
FFFC3B80 0A0D302E
FFFC3B84 20294328
FFFC3B88 37313032
FFFC3B8C 3230322D
FFFC3B90 52202030
FFFC3B94 7265626F
FFFC3B98 69462074
FFFC3B9C 0D68636E
FFFC3BA0 0A0D000D
FFFC3BA2 4B4F0A0D	OKMSG	db	CR,LINEFD,"OK",CR,0
FFFC3BA6 6857000D
FFFC3BA8 74616857	msgWhat	db	"What?",CR,0
FFFC3BAC 53000D3F
FFFC3BAF 72726F53	SRYMSG	db	"Sorry."
FFFC3BB3 000D2E79
FFFC3BB5 6F43000D	CLMSG	db	CR,0
FFFC3BB7 706D6F43	msgReadError	db	"Compact FLASH read error",CR,0
FFFC3BBB 20746361
FFFC3BBF 53414C46
FFFC3BC3 65722048
FFFC3BC7 65206461
FFFC3BCB 726F7272
FFFC3BCF 754E000D
FFFC3BD1 626D754E	msgNumTooBig	db	"Number is too big",CR,0
FFFC3BD5 69207265
FFFC3BD9 6F742073
FFFC3BDD 6962206F
FFFC3BE1 44000D67
FFFC3BE4 69766944	msgDivZero		db	"Division by zero",CR,0
FFFC3BE8 6E6F6973
FFFC3BEC 20796220
FFFC3BF0 6F72657A
FFFC3BF4 754F000D
FFFC3BF6 2074754F	msgVarSpace     db  "Out of variable space",CR,0
FFFC3BFA 7620666F
FFFC3BFE 61697261
FFFC3C02 20656C62
FFFC3C06 63617073
FFFC3C0A 20000D65
FFFC3C0D 74796220	msgBytesFree	db	" bytes free",CR,0
FFFC3C11 66207365
FFFC3C15 0D656572
FFFC3C19 65520D00
FFFC3C1A 6165520D	msgReady		db	CR,"Ready",CR,0
FFFC3C1E 000D7964
FFFC3C22 65707845	msgComma		db	"Expecting a comma",CR,0
FFFC3C26 6E697463
FFFC3C2A 20612067
FFFC3C2E 6D6D6F63
FFFC3C32 4C000D61
FFFC3C35 656E694C	msgLineRange	db	"Line number too big",CR,0
FFFC3C39 6D756E20
FFFC3C3D 20726562
FFFC3C41 206F6F74
FFFC3C45 0D676962
FFFC3C49 70784500
FFFC3C4A 65707845	msgVar			db "Expecting a variable",CR,0
FFFC3C4E 6E697463
FFFC3C52 20612067
FFFC3C56 69726176
FFFC3C5A 656C6261
FFFC3C5E 4E52000D
FFFC3C60 20444E52	msgRNDBad		db	"RND bad parameter",CR,0
FFFC3C64 20646162
FFFC3C68 61726170
FFFC3C6C 6574656D
FFFC3C70 53000D72
FFFC3C73 20535953	msgSYSBad		db	"SYS bad address",CR,0
FFFC3C77 20646162
FFFC3C7B 72646461
FFFC3C7F 0D737365
FFFC3C83 504E4900
FFFC3C84 55504E49	msgInputVar		db	"INPUT expecting a variable",CR,0
FFFC3C88 78652054
FFFC3C8C 74636570
FFFC3C90 20676E69
FFFC3C94 61762061
FFFC3C98 62616972
FFFC3C9C 000D656C
FFFC3CA0 5458454E	msgNextFor		db	"NEXT without FOR",CR,0
FFFC3CA4 74697720
FFFC3CA8 74756F68
FFFC3CAC 524F4620
FFFC3CB0 454E000D
FFFC3CB2 5458454E	msgNextVar		db	"NEXT expecting a defined variable",CR,0
FFFC3CB6 70786520
FFFC3CBA 69746365
FFFC3CBE 6120676E
FFFC3CC2 66656420
FFFC3CC6 64656E69
FFFC3CCA 72617620
FFFC3CCE 6C626169
FFFC3CD2 47000D65
FFFC3CD5 4F544F47	msgBadGotoGosub	db	"GOTO/GOSUB bad line number",CR,0
FFFC3CD9 534F472F
FFFC3CDD 62204255
FFFC3CE1 6C206461
FFFC3CE5 20656E69
FFFC3CE9 626D756E
FFFC3CED 000D7265
FFFC3CF1 55544552	msgRetWoGosub   db	"RETURN without GOSUB",CR,0
FFFC3CF5 77204E52
FFFC3CF9 6F687469
FFFC3CFD 47207475
FFFC3D01 4255534F
FFFC3D05 7250000D
FFFC3D07 676F7250	msgTooBig		db	"Program is too big",CR,0
FFFC3D0B 206D6172
FFFC3D0F 74207369
FFFC3D13 62206F6F
FFFC3D17 000D6769
FFFC3D1B 72747845	msgExtraChars	db	"Extra characters on line ignored",CR,0
FFFC3D1F 68632061
FFFC3D23 63617261
FFFC3D27 73726574
FFFC3D2B 206E6F20
FFFC3D2F 656E696C
FFFC3D33 6E676920
FFFC3D37 6465726F
FFFC3D3B 0000000D
                        	
                        	LSTROM	equ	*		; end of possible ROM area
;	END
                        	
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	
                        		rodata
                        		align 8                        	
                        	begin_init_data:
                        	_begin_init_data:
                        	
                        		rodata
                        		align 8                        	
                        	end_init_data:
                        	_end_init_data:
703 symbols
  Symbol Name                              seg     address bits
  ABS                                        code  fffc3364 18
  ABS1                                       code  fffc3378 18
  ADDEXPR                                    code  fffc2ef8 18
  ANDEXPR                                    code  fffc2ce4 18
  AUXIN                                      code  800000000000016b 32
  AUXIN_INIT                                 code  8000000000000227 32
  AUXOCRLF                                   code  fffc2b30 18
  AUXOUT                                     code  8000000000000169 32
  AUXOUT_FLUSH                               code  8000000000000234 32
  AUXOUT_INIT                                code  800000000000022b 32
  AccountTime                                code  fffc16bc 18
  AccountTime.again                          code  fffc16bc 18
  Alloc                                      code  fffc0d6c 18
  Alloc.0001                                 code  fffc0de0 18
  Alloc.enough                               code  fffc0da4 18
  Alloc.noRun                                code  fffc0e00 18
  Alloc.noRun2                               code  fffc0d9c 18
  AllocStack                                 code  fffc0e18 18
  AllocStack.0001                            code  fffc0e34 18
  AllocStack.xit                             code  fffc0e40 18
  BASPRMPT                                   code  fffc20cc 18
  BS                                        const  000008 5
  BUFFER                                    const  00071c 12
  BUFLEN                                    const  000054 8
  BYEBYE                                     code  fffc3b64 18
  CHKIO                                      code  fffc3ae8 18
  CHKRET                                     code  fffc3b04 18
  CLMSG                                      code  fffc3bb5 18
  CR                                        const  00000d 5
  CRLF                                       code  fffc3b10 18
  CSTART                                     code  fffc2030 32
  CTRLC                                     const  000003 3
  CTRLH                                     const  000008 5
  CTRLI                                     const  000009 5
  CTRLJ                                     const  00000a 5
  CTRLK                                     const  00000b 5
  CTRLM                                     const  00000d 5
  CTRLS                                     const  000013 6
  CTRLX                                     const  000018 6
  CURRNT                                    const  000718 12
  CursorFlash                               const  0007b0 12
  DEFLT                                      code  fffc28b0 18
  DEL                                       const  00007f 8
  DIRECT                                     code  fffc2360 18
  DOQUO                                      code  fffc3aa8 18
  DOQUO1                                     code  fffc3ab4 18
  DeleteLine                                 code  fffc2170 18
  DeleteLine.0001                            code  fffc2190 18
  DeleteLine.0002                            code  fffc217c 18
  DeleteLine.0003                            code  fffc2194 18
  DumpReadyQueue                             code  fffc1d6c 18
  DumpReadyQueue.0001                        code  fffc1dc8 18
  DumpReadyQueue.0002                        code  fffc1d78 18
  DumpReadyQueue.nxt                         code  fffc1de4 18
  ENDCHK                                     code  fffc3498 18
  ENDMEM                                    const  008000 17
  ERROR                                      code  fffc34e8 18
  ERROR1                                     code  fffc3528 18
  EX1                                        code  fffc23ac 18
  EXEC                                       code  fffc2370 18
  EXGO                                       code  fffc23d4 18
  EXLP                                       code  fffc237c 18
  EXMAT                                      code  fffc23c0 18
  EXNGO                                      code  fffc2394 18
  EXPR                                       code  fffc2dd4 18
  E_Arg                                     const  000001 2
  E_BadAlarm                                const  000011 6
  E_BadBlockNum                             const  000025 7
  E_BadDevNum                               const  000020 7
  E_BadDevOp                                const  000022 7
  E_BadMbx                                  const  000004 4
  E_DCBInUse                                const  000019 6
  E_NoDev                                   const  000021 7
  E_NoMem                                   const  00000c 5
  E_NoMoreAlarmBlks                         const  000044 8
  E_NoMoreMbx                               const  000040 8
  E_NoMoreMsgBlks                           const  000041 8
  E_NoMoreTCBs                              const  000045 8
  E_NoMsg                                   const  00000b 5
  E_NoThread                                const  000006 4
  E_NotAlloc                                const  000009 5
  E_NotOwner                                const  000012 6
  E_Ok                                      const  000000 1
  E_QueFull                                 const  000005 4
  E_QueStrategy                             const  000013 6
  E_ReadError                               const  000023 7
  E_Timeout                                 const  000010 6
  E_TooManyBlocks                           const  000026 7
  E_WriteError                              const  000024 7
  EditMem                                    code  fffc0468 18
  FI1                                        code  fffc3478 18
  FI2                                        code  fffc348c 18
  FILEBUF                                   const  07f600 20
  FILENAME                                  const  0006c0 12
  FIN                                        code  fffc345c 18
  FINISH                                     code  fffc261c 18
  FMTKInit                                   code  fffc0f14 18
  FMTK_AllocMbx                              code  80000000000000f0 32
  FMTK_ExitTask                              code  fffc1a54 18
  FMTK_FreeMbx                               code  80000000000000f1 32
  FMTK_Initialize                            code  80000000000000ea 32
  FMTK_KillTask                              code  fffc1a60 18
  FMTK_PeekMsg                               code  80000000000000f5 32
  FMTK_PostMsg                               code  80000000000000f2 32
  FMTK_Reschedule                            code  fffc16e8 18
  FMTK_Reschedule.noCtxSwitch                code  fffc17a4 18
  FMTK_Reschedule.noException                code  fffc1728 18
  FMTK_Reschedule.noMsg                      code  fffc178c 18
  FMTK_SchedulerIRQ                          code  fffc17bc 18
  FMTK_SchedulerIRQ.0001                     code  fffc1804 18
  FMTK_SchedulerIRQ.noCtxSwitch              code  fffc1914 18
  FMTK_SchedulerIRQ.noException              code  fffc1898 18
  FMTK_SchedulerIRQ.noMsg                    code  fffc18fc 18
  FMTK_SchedulerIRQ.noTimeouts               code  fffc1880 18
  FMTK_SchedulerIRQ.timeoutNotDone           code  fffc1848 18
  FMTK_SendMsg                               code  80000000000000f3 32
  FMTK_SetTaskPriority                       code  80000000000000ee 32
  FMTK_Sleep                                 code  fffc1d38 18
  FMTK_Sleep.xit                             code  fffc1d60 18
  FMTK_StartApp                              code  80000000000000f6 32
  FMTK_StartTask                             code  fffc19a0 18
  FMTK_StartTask.err                         code  fffc1a44 18
  FMTK_SwitchTask                            code  fffc1360 18
  FMTK_SwitchTask.0001                       code  fffc14b4 18
  FMTK_SwitchTask.dead                       code  fffc1490 18
  FMTK_SwitchTask.noMsg                      code  fffc153c 18
  FMTK_SwitchTask.ready                      code  fffc154c 18
  FMTK_SwitchTask.rsseg                      code  fffc1560 18
  FMTK_SwitchTask.svseg                      code  fffc1474 18
  FMTK_WaitMsg                               code  80000000000000f4 32
  FNDLN                                      code  fffc3620 18
  FNDLNP                                     code  fffc3640 18
  FNDNXT                                     code  fffc3688 18
  FNDRET                                     code  fffc3670 18
  FNDRET1                                    code  fffc3678 18
  FNDRET2                                    code  fffc3680 18
  FNDSKP                                     code  fffc368c 18
  FOR                                        code  fffc26ac 18
  FORCEFIT                                   code  fffc2dac 18
  FORCEFIT.0001                              code  fffc2dd0 18
  FORCEFIT.intAnd                            code  fffc2dc0 18
  FR1                                        code  fffc26cc 18
  FR2                                        code  fffc26e8 18
  FR3                                        code  fffc26f0 18
  FR4                                        code  fffc26f4 18
  FR5                                        code  fffc26f8 18
  FR6                                        code  fffc2710 18
  FR7                                        code  fffc2714 18
  FR8                                        code  fffc2734 18
  FUNCEXPR                                   code  fffc302c 18
  FillMem                                    code  fffc0480 18
  FillMem.0001                               code  fffc049c 18
  FindRun                                    code  fffc0d14 18
  FindRun.0001                               code  fffc0d2c 18
  FindRun.empty0                             code  fffc0d44 18
  FindRun.empty1                             code  fffc0d48 18
  FindRun.foundEnough                        code  fffc0d64 18
  FreeAll                                    code  fffc0e44 18
  FreeAll.0001                               code  fffc0ea0 18
  FreeAll.nxt                                code  fffc0e4c 18
  GCHAR                                      code  fffc2934 18
  GCHAR1                                     code  fffc294c 18
  GETLN                                      code  fffc352c 18
  GETLN.GL1                                  code  fffc354c 18
  GETLN.GL2                                  code  fffc3574 18
  GETLN.GL3                                  code  fffc35a4 18
  GETLN.GL4                                  code  fffc35cc 18
  GETLN.GL5                                  code  fffc35dc 18
  GETLN.GL6                                  code  fffc35fc 18
  GETLN.GL7                                  code  fffc3604 18
  GOAUXI                                     code  fffc2018 18
  GOAUXO                                     code  fffc2010 18
  GOBYE                                      code  fffc2020 18
  GOIN                                       code  fffc200c 18
  GOOUT                                      code  fffc2008 18
  GOSTART                                    code  fffc2000 18
  GOSUB                                      code  fffc2624 18
  GOTO                                       code  fffc24a0 18
  GOWARM                                     code  fffc2004 18
  GetBuflen                                  code  fffc21d8 18
  GetBuflen.0001                             code  fffc2200 18
  GetBuflen.0002                             code  fffc21e4 18
  GetBuflen.0004                             code  fffc21fc 18
  GetCurrentTid                              code  fffc0f7c 18
  GetFilename                                code  fffc2998 18
  GetFreePid                                 code  fffc1934 18
  GetFreePid.0001                            code  fffc1948 18
  GetFreePid.0002                            code  fffc197c 18
  GetFreePid.0003                            code  fffc198c 18
  GetFreePid.allocPid                        code  fffc1970 18
  GetHexNum                                  code  fffc04d8 18
  GetHexNum.0001                             code  fffc0528 18
  GetHexNum.isDigit                          code  fffc0564 18
  GetHexNum.isHexLower                       code  fffc054c 18
  GetHexNum.isHexUpper                       code  fffc0534 18
  GetHexNum.next                             code  fffc04e8 18
  Getch                                      code  fffc019c 18
  HRDY0                                     const  004308 16
  HRDY1                                     const  004309 16
  HRDY2                                     const  00430a 16
  HRDY3                                     const  00430b 16
  IF0                                        code  fffc27b0 18
  IF1                                        code  fffc27b4 18
  IF2                                        code  fffc27bc 18
  IF3                                        code  fffc27d0 18
  IGB1                                       code  fffc3a54 18
  IGB2                                       code  fffc3a40 18
  IGBRET                                     code  fffc3a5c 18
  IGNBLK                                     code  fffc3a38 18
  INBUF                                     const  004100 16
  INCH                                       code  fffc3b34 18
  INCH1                                      code  fffc3b58 18
  INPERR                                     code  fffc27d4 18
  INPPTR                                    const  0007ac 12
  INPUT                                      code  fffc27f0 18
  INSLINE                                    code  fffc2130 18
  INSLINE.0001                               code  fffc215c 18
  IP2                                        code  fffc2818 18
  IP3                                        code  fffc2854 18
  IP4                                        code  fffc2894 18
  IP5                                        code  fffc28a4 18
  IP6                                        code  fffc27f8 18
  IP7                                        code  fffc2838 18
  IRQFlag                                   const  0007b4 12
  IRQROUT                                   const  0007a4 12
  IRQRout                                    code  fffc0768 18
  IRQRout.0001                               code  fffc07dc 18
  IRQRout.0002                               code  fffc07f4 18
  IRQRout.isIRQ                              code  fffc0780 18
  InsertIntoTimeoutList                      code  fffc1aac 18
  InsertIntoTimeoutList.0001                 code  fffc1b10 18
  InsertIntoTimeoutList.0002                 code  fffc1bd0 18
  InsertIntoTimeoutList.0003                 code  fffc1be0 18
  InsertIntoTimeoutList.beginWhile           code  fffc1b28 18
  InsertIntoTimeoutList.endWhile             code  fffc1b5c 18
  InsertLine                                 code  fffc21b8 18
  InsertLine.0001                            code  fffc21bc 18
  InsertLine.done                            code  fffc21d4 18
  InsertTask                                 code  fffc0f8c 18
  InsertTask.badTid                          code  fffc1000 18
  InsertTask.qfull                           code  fffc1000 18
  LET                                        code  fffc28bc 18
  LINEFD                                    const  00000a 5
  LISTX                                      code  fffc253c 18
  LOAD                                       code  fffc28d4 18
  LOAD3                                      code  fffc2a04 18
  LOAD4                                      code  fffc2a30 18
  LOAD5                                      code  fffc2a64 18
  LOD1                                       code  fffc28e4 18
  LOD2                                       code  fffc2910 18
  LODEND                                     code  fffc292c 18
  LOPINC                                    const  000778 12
  LOPLMT                                    const  00077c 12
  LOPLN                                     const  000774 12
  LOPPT                                     const  000770 12
  LOPVAR                                    const  000710 12
  LS1                                        code  fffc2550 18
  LS2                                        code  fffc2578 18
  LS3                                        code  fffc2580 18
  LS4                                        code  fffc255c 18
  LS5                                        code  fffc2554 18
  LSTROM                                    const  000000 1
  LT1                                        code  fffc28d0 18
  LoadWord                                   code  fffc38f0 18
  MAX_TID                                   const  00000f 5
  MMUInit                                    code  fffc0cc0 18
  MMUInit.0001                               code  fffc0ce4 18
  MMUInit.0002                               code  fffc0d00 18
  MULEXPR                                    code  fffc2f90 18
  MVDOWN                                     code  fffc36c8 18
  MVDOWN1                                    code  fffc36b8 18
  MVUP                                       code  fffc36b0 18
  MVUP1                                      code  fffc36a0 18
  MachineStart                               code  fffc0100 18
  MonEntry                                   code  fffc01cc 18
  Monitor                                    code  fffc01d4 18
  Monitor.0001                               code  fffc01f0 18
  Monitor.0002                               code  fffc0240 18
  Monitor.0003                               code  fffc029c 18
  Monitor.0004                               code  fffc031c 18
  Monitor.0005                               code  fffc03dc 18
  Monitor.0006                               code  fffc0380 18
  Monitor.0007                               code  fffc0394 18
  Monitor.0008                               code  fffc03a0 18
  Monitor.0009                               code  fffc03ac 18
  Monitor.0010                               code  fffc03c0 18
  Monitor.0011                               code  fffc03dc 18
  Monitor.doBackspace                        code  fffc0288 18
  Monitor.doDelete                           code  fffc0238 18
  Monitor.procLine                           code  fffc02e4 18
  Monitor.skip                               code  fffc02f8 18
  Monitor.skip2                              code  fffc0314 18
  NEW                                        code  fffc23e4 18
  NEXT                                       code  fffc2738 18
  NPAGES                                    const  004300 16
  NR_TCB                                    const  000010 6
  NUMWKA                                    const  000794 12
  NX0                                        code  fffc2754 18
  NX1                                        code  fffc2794 18
  NX2                                        code  fffc2774 18
  NX3                                        code  fffc2798 18
  NX4                                        code  fffc2750 18
  NX5                                        code  fffc2768 18
  NXPurge                                    code  fffc27a8 18
  OKMSG                                      code  fffc3ba2 18
  ONIRQ                                      code  fffc2504 18
  ONIRQ1                                     code  fffc2524 18
  OREXPR                                     code  fffc2c7c 18
  OSCALL                                     code  fffc1680 18
  OSCallTbl                                  code  fffc0ed4 18
  OSSP                                      const  000700 12
  OUTC                                       code  fffc3b30 18
  OUTPTR                                    const  0007a8 12
  OpenSpace                                  code  fffc2204 18
  OpenSpace.0003                             code  fffc221c 18
  OpenSpace.noSpace                          code  fffc2238 18
  PARN                                       code  fffc307c 18
  PEEK                                       code  fffc3280 18
  PEEKH                                      code  fffc32b0 18
  PEEKW                                      code  fffc3298 18
  PIDMAP                                    const  004310 16
  PKER                                       code  fffc2c44 18
  POKE                                       code  fffc2bc0 18
  POKEH                                      code  fffc2c18 18
  POKEW                                      code  fffc2bec 18
  POPA_                                      code  fffc36d0 18
  PP1                                        code  fffc3704 18
  PR0                                        code  fffc25b0 18
  PR1                                        code  fffc25c8 18
  PR2                                        code  fffc259c 18
  PR3                                        code  fffc25e8 18
  PR4                                        code  fffc25e0 18
  PR6                                        code  fffc25fc 18
  PR8                                        code  fffc2604 18
  PRINT                                      code  fffc2584 18
  PRMESG                                     code  fffc3b18 18
  PRTLN                                      code  fffc391c 18
  PRTNUM                                     code  fffc3848 32
  PRTNUM.PN1                                 code  fffc387c 18
  PRTNUM.PN2                                 code  fffc3878 18
  PRTNUM.PN3                                 code  fffc38a4 18
  PRTNUM.PN4                                 code  fffc38b4 18
  PRTNUM.PN5                                 code  fffc38c0 18
  PRTNUM.PN6                                 code  fffc38c4 18
  PRTNUM.PN7                                 code  fffc388c 18
  PRTSTG                                     code  fffc374c 18
  PRTSTG.PRTRET                              code  fffc3790 18
  PRTSTG.PS1                                 code  fffc376c 18
  PU1                                        code  fffc3740 18
  PUSHA_                                     code  fffc3708 18
  PWORD                                      code  fffc2b54 18
  PopTimeoutList                             code  fffc1cc8 18
  PopTimeoutList.done                        code  fffc1d34 18
  PutHexByte                                 code  fffc05b8 18
  PutHexHalf                                 code  fffc0598 18
  PutHexNybble                               code  fffc05d8 18
  PutHexNybble.0001                          code  fffc0608 18
  PutHexNybble.lt10                          code  fffc0600 18
  PutHexWord                                 code  fffc0578 18
  Putch                                      code  fffc01b4 18
  QNDX                                      const  004304 16
  QSORRY                                     code  fffc34d4 18
  QT1                                        code  fffc37cc 18
  QT2                                        code  fffc380c 18
  QT3                                        code  fffc37e4 18
  QT4                                        code  fffc37f8 18
  QT5                                        code  fffc3818 18
  QTSTG                                      code  fffc37b4 18
  QWHAT                                      code  fffc34e0 18
  RDYQ0                                     const  004400 16
  RDYQ1                                     const  004500 16
  RDYQ2                                     const  004600 16
  RDYQ3                                     const  004700 16
  RETURN                                     code  fffc2668 18
  RND                                        code  fffc3308 18
  RUN                                        code  fffc240c 18
  RUN1                                       code  fffc246c 18
  RUN2                                       code  fffc2428 18
  RUN2.0001                                  code  fffc242c 18
  RUNNXL                                     code  fffc2420 18
  RUNNXL.0001                                code  80000000000001db 32
  RUNSML                                     code  fffc2488 18
  RUNTSL                                     code  fffc2480 18
  RemoveFromTimeoutList                      code  fffc1bf4 18
  RemoveFromTimeoutList.0001                 code  fffc1c64 18
  RemoveFromTimeoutList.0002                 code  fffc1c9c 18
  SAVE                                       code  fffc2ad0 18
  SAVE1                                      code  fffc2adc 18
  SAVE2                                      code  fffc2af8 18
  SAVE3                                      code  fffc2a68 18
  SAVE4                                      code  fffc2a98 18
  SAVEND                                     code  fffc2b10 18
  SDReadSector                               code  8000000000000228 32
  SDWriteSector                              code  800000000000022d 32
  SETVAL                                     code  fffc33f4 18
  SETVAL.sv2                                 code  fffc3418 18
  SGN                                        code  fffc339c 18
  SGN1                                       code  fffc33cc 18
  SGN2                                       code  fffc33bc 18
  SIZEX                                      code  fffc33d8 18
  SRYMSG                                     code  fffc3baf 18
  ST2                                        code  fffc210c 18
  STACKOFFS                                 const  07fffc 20
  STKBOT                                    const  00079c 12
  STKGOS                                    const  000714 12
  STKINP                                    const  000798 12
  STOP                                       code  fffc23f8 18
  STRTMP                                    const  000200 11
  SV1                                        code  fffc3454 18
  SYSX                                       code  fffc2c50 18
  SelectTaskToRun                            code  fffc1008 18
  SelectTaskToRun.dq                         code  fffc1084 18
  SelectTaskToRun.goodTid                    code  8000000000000101 32
  SelectTaskToRun.goodtid                    code  fffc10bc 18
  SelectTaskToRun.nxtQ                       code  fffc104c 18
  SerialInit                                 code  fffc0724 18
  SerialPeekChar                             code  fffc0680 18
  SerialPeekChar.0001                        code  fffc06ac 18
  SerialPutChar                              code  fffc06b4 18
  SerialPutChar.0001                         code  fffc06bc 18
  SerialPutString                            code  fffc06f0 18
  SerialPutString.0001                       code  fffc0700 18
  SerialPutString.done                       code  fffc0714 18
  SkipSpaces                                 code  fffc04ac 18
  SkipSpaces.skip1                           code  fffc04d0 18
  SkipSpaces.skip2                           code  fffc04ac 18
  SwapContext                                code  fffc10fc 18
  SwapContext.rsseg                          code  fffc1240 18
  SwapContext.svseg                          code  fffc1200 18
  TAB                                       const  000009 5
  TAB1                                       code  fffc2240 18
  TAB10                                      code  fffc22e4 18
  TAB10_1                                    code  fffc234e 18
  TAB1_1                                     code  fffc22e8 18
  TAB2                                       code  fffc2252 18
  TAB2_1                                     code  fffc22f2 18
  TAB4                                       code  fffc22ab 18
  TAB4_1                                     code  fffc2320 18
  TAB5                                       code  fffc22ce 18
  TAB5_1                                     code  fffc2334 18
  TAB6                                       code  fffc22d1 18
  TAB6_1                                     code  fffc2338 18
  TAB8                                       code  fffc22d6 18
  TAB8_1                                     code  fffc233c 18
  TAB9                                       code  fffc22e0 18
  TAB9_1                                     code  fffc234a 18
  TC1                                        code  fffc39ac 18
  TCBEndTick                                const  0002b8 11
  TCBException                              const  0002c8 11
  TCBMsgD1                                  const  000298 11
  TCBMsgD2                                  const  0002a0 11
  TCBMsgD3                                  const  0002a8 11
  TCBNext                                    code  8000000000000128 32
  TCBPrev                                    code  8000000000000129 32
  TCBPriority                               const  000289 11
  TCBStackBot                               const  000290 11
  TCBStartTick                              const  0002b0 11
  TCBStatus                                 const  000288 11
  TCBTicks                                  const  0002c0 11
  TCBTimeout                                 code  800000000000011a 32
  TCB_MsgD1                                  code  800000000000010c 32
  TCB_MsgD2                                  code  800000000000010d 32
  TCB_MsgD3                                  code  800000000000010e 32
  TCB_Status                                 code  800000000000010b 32
  TCBepc                                    const  000280 11
  TCBsegs                                   const  000200 11
  TICKX                                      code  fffc3388 18
  TN1                                        code  fffc39dc 18
  TN2                                        code  fffc3a08 18
  TOOBIG                                     code  fffc34c8 18
  TOUPB1                                     code  fffc3a78 18
  TOUPBRT                                    code  fffc3ac0 18
  TOUPBUF                                    code  fffc3a68 18
  TOUPRET                                    code  fffc3ae4 18
  TRDY0                                     const  00430c 16
  TRDY1                                     const  00430d 16
  TRDY2                                     const  00430e 16
  TRDY3                                     const  00430f 16
  TSNMRET                                    code  fffc3a28 18
  TSTC                                       code  fffc3978 18
  TSTNUM                                     code  fffc39c4 18
  TSTV                                       code  fffc30bc 18
  TSTVRT                                     code  fffc312c 18
  TS_DEAD                                   const  000002 3
  TS_MSGRDY                                 const  000004 4
  TS_NONE                                   const  000000 1
  TS_PREMPT                                  code  8000000000000117 32
  TS_READY                                  const  000001 2
  TS_RUNNING                                const  000080 9
  TS_TIMEOUT                                 code  800000000000012e 32
  TS_WAITMSG                                const  000008 5
  TV1                                        code  fffc3118 18
  TV2                                        code  fffc310c 18
  TV3                                        code  fffc30ec 18
  TXTBGN                                    const  001800 14
  TXTUNF                                    const  000704 12
  Tick                                      const  004330 16
  TimeoutList                               const  004328 16
  TinyBasic                                  code  fffc2000 18
  UART                                      const  ffdc0a00 33
  UART_CMD                                  const  000008 5
  UART_STAT                                 const  000004 4
  UART_TRB                                  const  000000 1
  USRX                                       code  fffc32c8 18
  UserStart                                  code  fffc012c 18
  UserStart.0002                             code  fffc0164 18
  UserStart.0003                             code  fffc0188 18
  UserStart.0004                             code  fffc0158 18
  VARBGN                                    const  000708 12
  VAREND                                    const  00070c 12
  VIA                                       const  ffdc0600 33
  VIAInit                                    code  fffc0618 18
  VIA_ACR                                   const  00002c 7
  VIA_DDRA                                  const  00000c 5
  VIA_IFR                                   const  000034 7
  VIA_PA                                    const  000004 4
  VIA_PARAW                                 const  00003c 7
  VIA_PCR                                   const  000030 7
  VIA_T1CH                                  const  000014 6
  VIA_T1CL                                  const  000010 6
  VirtToPhys                                 code  fffc0ea4 18
  WAITIRQ                                    code  fffc252c 18
  WSTART                                     code  fffc20ac 18
  XOFF                                      const  000013 6
  XON                                       const  000011 6
  XP11                                       code  fffc2e00 18
  XP12                                       code  fffc2e18 18
  XP13                                       code  fffc2e30 18
  XP14                                       code  fffc2e48 18
  XP15                                       code  fffc2e60 18
  XP16                                       code  fffc2e78 18
  XP17                                       code  fffc2eb8 18
  XP18                                       code  fffc2ed0 18
  XP21                                       code  fffc2f20 18
  XP22                                       code  fffc2f2c 18
  XP23                                       code  fffc2f30 18
  XP24                                       code  fffc2f4c 18
  XP25                                       code  fffc2f60 18
  XP26                                       code  fffc2f6c 18
  XP31                                       code  fffc2f9c 18
  XP34                                       code  fffc2fcc 18
  XP35                                       code  fffc2ff0 18
  XP40                                       code  fffc3048 18
  XP41                                       code  fffc3064 18
  XP42                                       code  fffc30a0 18
  XP43                                       code  fffc30ac 18
  XP45                                       code  fffc2f78 18
  XP46                                       code  fffc3070 18
  XP47                                       code  fffc3014 18
  XPRT0                                      code  fffc2e90 18
  XPRT1                                      code  fffc2ea4 18
  XP_AND                                     code  fffc2d10 18
  XP_AND1                                    code  fffc2cf0 18
  XP_ANDX                                    code  fffc2d24 18
  XP_OR                                      code  fffc2cb0 18
  XP_OR1                                     code  fffc2c90 18
  XP_ORX                                     code  fffc2cc4 18
  YIELD0                                     code  fffc2400 18
  _clr                                       code  fffc24c4 18
  _cls                                       code  80000000000001ae 32
  _end_init_data                           rodata  fffc4000 32
  _rdcf                                      code  80000000000001b0 32
  a2h1                                       code  fffc298c 18
  asciiToHex                                 code  fffc2980 18
  begin_init_data                          rodata  fffc4000 32
  clearVars                                  code  fffc24cc 18
  clearVars.cv1                              code  fffc24e0 18
  doMem                                      code  fffc03e0 18
  doMem.loop                                 code  fffc0444 18
  doMem.loop2                                code  fffc041c 18
  ec1                                        code  fffc34bc 18
  end_init_data                            rodata  fffc4000 32
  entry                                      code  fffc1cc8 18
  findVar                                    code  fffc3210 18
  fl1                                        code  fffc3638 18
  flt10                                      code  fffc08f5 18
  flt20                                      code  fffc08e5 18
  flt50                                      code  fffc08d5 18
  fltMillion                                 code  fffc0cbc 18
  fltOne                                     code  fffc0cb4 18
  fltTen                                     code  fffc0cb8 18
  fltToString                                code  fffc0905 18
  fltToString.0001                           code  fffc095e 18
  fltToString.0002                           code  fffc09d6 18
  fltToString.0003                           code  fffc09c2 18
  fltToString.0004                           code  fffc0a22 18
  fltToString.0005                           code  fffc0a1a 18
  fltToString.0006                           code  fffc0a02 18
  fltToString.0007                           code  fffc0a3e 18
  fltToString.0008                           code  fffc0a52 18
  fltToString.0009                           code  fffc0a4e 18
  fltToString.0010                           code  fffc0a72 18
  fltToString.0011                           code  fffc0afe 18
  fltToString.0012                           code  fffc0ab6 18
  fltToString.0013                           code  fffc0aa2 18
  fltToString.0014                           code  fffc0ad2 18
  fltToString.0015                           code  fffc0aee 18
  fltToString.0016                           code  fffc0a8a 18
  fltToString.0017                           code  fffc0af6 18
  fltToString.0018                           code  fffc0afe 18
  fltToString.0019                           code  fffc0b32 18
  fltToString.0020                           code  fffc0b3e 18
  fltToString.0021                           code  fffc0b62 18
  fltToString.0022                           code  fffc0b6e 18
  fltToString.0023                           code  fffc0b7e 18
  fltToString.0024                           code  fffc0b8a 18
  fltToString.0025                           code  fffc0b76 18
  fltToString.0026                           code  fffc0b9e 18
  fltToString.0027                           code  fffc0ba6 18
  fltToString.0028                           code  fffc0bae 18
  fltToString.0029                           code  fffc0bba 18
  fltToString.0030                           code  fffc0bc6 18
  fltToString.0031                           code  fffc0bd2 18
  fltToString.0032                           code  fffc0bda 18
  fltToString.0034                           code  fffc0be2 18
  fltToString.0035                           code  fffc0bee 18
  fltToString.0036                           code  fffc0bfe 18
  fltToString.0037                           code  fffc0c0a 18
  fltToString.0038                           code  fffc0c12 18
  fltToString.0039                           code  fffc0c26 18
  fltToString.0040                           code  fffc0c1a 18
  fltToString.0041                           code  fffc0c82 18
  fltToString.0042                           code  fffc0c46 18
  fltToString.0043                           code  fffc0c56 18
  fltToString.0044                           code  fffc0c6a 18
  fltToString.0045                           code  fffc0c4e 18
  fltToString.0046                           code  fffc0c76 18
  fltToString.0047                           code  fffc0c82 18
  fltToString.0048                           code  fffc0c6e 18
  fltToString.0050                           code  fffc0ca2 18
  fltToString.0051                           code  fffc0c9e 18
  fltToString.0052                           code  fffc0c8e 18
  fltToString.inf                            code  fffc0946 18
  fltToString.notZero                        code  fffc0992 18
  fltToString.pos                            code  fffc097e 18
  fltToString.prt                            code  fffc0c36 18
  fv1                                        code  fffc3258 18
  fv2                                        code  fffc326c 18
  fv3                                        code  fffc3250 18
  fv4                                        code  fffc3220 18
  gen_rand                                   code  8000000000000276 32
  getVarName                                 code  fffc3150 18
  gfn1                                       code  fffc2a00 18
  gfn2                                       code  fffc29b0 18
  gfn3                                       code  fffc29e0 18
  gosub1                                     code  fffc2644 18
  gvn1                                       code  fffc31f8 18
  gvn2                                       code  fffc31b8 18
  gvn3                                       code  fffc31d4 18
  gvn4                                       code  fffc3174 18
  gvn6                                       code  fffc31a8 18
  isAlnum                                    code  fffc2d8c 18
  isAlpha                                    code  fffc2d5c 18
  isAlphaFalse                               code  fffc2d84 18
  isAlphaTrue                                code  fffc2d7c 18
  isDigit                                    code  fffc2d3c 18
  isDigitFalse                               code  fffc2d54 18
  isDigitx                                   code  fffc2da0 18
  milliseconds                              const  004208 16
  missed_ticks                              const  004320 16
  msgBadGotoGosub                            code  fffc3cd5 18
  msgBytesFree                               code  fffc3c0d 18
  msgCRLF                                    code  fffc08d2 18
  msgComma                                   code  fffc3c22 18
  msgDivZero                                 code  fffc3be4 18
  msgExtraChars                              code  fffc3d1b 18
  msgInf                                     code  fffc0cac 18
  msgInit                                    code  fffc3b6c 18
  msgInputVar                                code  fffc3c84 18
  msgLineRange                               code  fffc3c35 18
  msgMonHelp                                 code  fffc0822 18
  msgNan                                     code  fffc0cb0 18
  msgNextFor                                 code  fffc3ca0 18
  msgNextVar                                 code  fffc3cb2 18
  msgNumTooBig                               code  fffc3bd1 18
  msgRNDBad                                  code  fffc3c60 18
  msgReadError                               code  fffc3bb7 18
  msgReady                                   code  fffc3c1a 18
  msgRetWoGosub                              code  fffc3cf1 18
  msgSYSBad                                  code  fffc3c73 18
  msgStart                                   code  fffc080c 18
  msgTaskStart                               code  fffc08c4 18
  msgTooBig                                  code  fffc3d07 18
  msgVar                                     code  fffc3c4a 18
  msgVarSpace                                code  fffc3bf6 18
  msgWhat                                    code  fffc3ba8 18
  prCRLF                                     code  fffc3824 18
  pword1                                     code  fffc2b68 18
  pword2                                     code  fffc2b84 18
  qToChk                                     code  fffc0ef2 18
  return1                                    code  fffc2680 18
  rnd1                                       code  fffc333c 18
  rnd2                                       code  fffc334c 18
  switchflag                                const  004200 16
  sysx1                                      code  fffc2c64 18
  tah1                                       code  fffc2bb8 18
  tid                                        code  fffc1cc8 18
  timeout                                    code  8000000000000132 32
  toAsciiHex                                 code  fffc2ba8 18
  toUpper                                    code  fffc3acc 18
  tstv_notfound                              code  fffc313c 18
  usrJmp                                    const  0007a0 12
  v0                                        const  8000000000000132 64

Undefined Symbols
  AUXIN                                      code  800000000000016b 32
  AUXIN_INIT                                 code  8000000000000227 32
  AUXOUT                                     code  8000000000000169 32
  AUXOUT_FLUSH                               code  8000000000000234 32
  AUXOUT_INIT                                code  800000000000022b 32
  FMTK_AllocMbx                              code  80000000000000f0 32
  FMTK_FreeMbx                               code  80000000000000f1 32
  FMTK_Initialize                            code  80000000000000ea 32
  FMTK_PeekMsg                               code  80000000000000f5 32
  FMTK_PostMsg                               code  80000000000000f2 32
  FMTK_SendMsg                               code  80000000000000f3 32
  FMTK_SetTaskPriority                       code  80000000000000ee 32
  FMTK_StartApp                              code  80000000000000f6 32
  FMTK_WaitMsg                               code  80000000000000f4 32
  RUNNXL.0001                                code  80000000000001db 32
  SDReadSector                               code  8000000000000228 32
  SDWriteSector                              code  800000000000022d 32
  SelectTaskToRun.goodTid                    code  8000000000000101 32
  TCBNext                                    code  8000000000000128 32
  TCBPrev                                    code  8000000000000129 32
  TCBTimeout                                 code  800000000000011a 32
  TCB_MsgD1                                  code  800000000000010c 32
  TCB_MsgD2                                  code  800000000000010d 32
  TCB_MsgD3                                  code  800000000000010e 32
  TCB_Status                                 code  800000000000010b 32
  TS_PREMPT                                  code  8000000000000117 32
  TS_TIMEOUT                                 code  800000000000012e 32
  _cls                                       code  80000000000001ae 32
  _rdcf                                      code  80000000000001b0 32
  gen_rand                                   code  8000000000000276 32
  timeout                                    code  8000000000000132 32

  Macro Name
0 compressable instructions
The top 1024 are:
Comp  Opcode  Count
