                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/const.r5a",1
                        	.file "../fmtk/const.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	; First 128 bytes are for integer register set
                        	; Second 128 bytes are for float register set
                        	; Leave some room for 64-bit regs
                        	TCBsegs			EQU		$200		; segment register storage
                        	TCBepc			EQU		$280
                        	TCBStatus		EQU		$288
                        	TCBPriority	EQU		$289
                        	TCBWaitMbx	EQU		$28A
                        	TCBStackBot	EQU		$290
                        	TCBMsgD1		EQU		$298
                        	TCBMsgD2		EQU		$2A0
                        	TCBMsgD3		EQU		$2A8
                        	TCBStartTick	EQU	$2B0
                        	TCBEndTick	EQU		$2B8
                        	TCBTicks		EQU		$2C0
                        	TCBException	EQU	$2C8
                        	TCBNext			EQU		$2D0
                        	TCBPrev			EQU		$2D8
                        	TCBTimeout	EQU		$2E0
                        	IOF_NEXT		EQU		$2E8
                        	IOF_PREV		EQU		$2F0
                        	TCBName			EQU		$2F8
                        	
                        	TS_NONE			EQU		0
                        	TS_READY		EQU		1
                        	TS_DEAD			EQU		2
                        	TS_MSGRDY		EQU		4
                        	TS_WAITMSG	EQU		8
                        	TS_TIMEOUT	EQU		16
                        	TS_PREEMPT	EQU		32
                        	TS_RUNNING	EQU		128
                        	
                        	; error codes
                        	E_Ok		=		0x00
                        	E_Arg		=		0x01
                        	E_BadMbx	=		0x04
                        	E_QueFull	=		0x05
                        	E_NoThread	=		0x06
                        	E_NotAlloc	=		0x09
                        	E_NoMsg		=		0x0b
                        	E_Timeout	=		0x10
                        	E_BadAlarm	=		0x11
                        	E_NotOwner	=		0x12
                        	E_QueStrategy =		0x13
                        	E_BadDevNum	=		0x18
                        	E_DCBInUse	=		0x19
                        	; Device driver errors
                        	E_BadDevNum	=		0x20
                        	E_NoDev		=		0x21
                        	E_BadDevOp	=		0x22
                        	E_ReadError	=		0x23
                        	E_WriteError =		0x24
                        	E_BadBlockNum	=	0x25
                        	E_TooManyBlocks	=	0x26
                        	
                        	; resource errors
                        	E_NoMoreMbx	=		0x40
                        	E_NoMoreMsgBlks	=	0x41
                        	E_NoMoreAlarmBlks	=0x44
                        	E_NoMoreTCBs	=	0x45
                        	E_NoMem		= 12
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/config.r5a",1
                        	.file "../fmtk/config.r5a",1
                        	MAX_TID		EQU		15
                        	NR_TCB		EQU		16
                        	OSPAGES		EQU		32		; pages of memory dedicated to OS
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/device.r5a",1
                        	.file "../fmtk/device.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2014-2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; DeviceDriver.inc
                        	; - Device driver structures and constants                                                                         
                        	; ============================================================================
                        	
                        	;	.global			; global constants
                        	
                        	; Device Control Block
                        	;
                        	DCB_Name			EQU		0		; string: first byte is length, 11 chars max
                        	DCB_Type			EQU		0x0C
                        	DCB_nBPB			EQU		0x10
                        	DCB_LastErc			EQU		0x18		; last error code
                        	DCB_StartBlock		EQU		0x20		; starting block number (partitioned devices)
                        	DCB_nBlocks			EQU		0x28		; number of blocks on device
                        	DCB_pCmdProc		EQU		0x30		; pointer to command processor routine
                        	DCB_ReentCount		EQU		0x38		; re-entrancy count (1 to 255)
                        	DCB_fSingleUser		EQU		0x39
                        	DCB_hJob			EQU		0x40		; handle to associated job
                        	DCB_Mbx				EQU		0x48
                        	DCB_pSema			EQU		0x50		; pointer to device semaphore
                        	DCB_Resv1			EQU		0x58		; reserved
                        	DCB_Resv2			EQU		0x60		; reserved
                        	DCB_Size			EQU		0x68
                        	
                        	; Device command opcodes
                        	;
                        	DVC_Nop				EQU		0
                        	DVC_Setup			EQU		1
                        	DVC_Initialize		EQU		2
                        	DVC_Status			EQU		3
                        	DVC_MediaCheck		EQU		4
                        	DVC_BuildBPB		EQU		5
                        	DVC_Open			EQU		6
                        	DVC_Close			EQU		7
                        	DVC_GetChar			EQU		8
                        	DVC_PeekChar		EQU		9
                        	DVC_GetCharDirect	EQU		10
                        	DVC_PeekCharDirect	EQU		11
                        	DVC_InputStatus		EQU		12
                        	DVC_PutChar			EQU		13
                        	DVC_SetPosition		EQU		15
                        	DVC_ReadBlock		EQU		16
                        	DVC_WriteBlock		EQU		17
                        	DVC_VerifyBlock		EQU		18
                        	DVC_OutputStatus	EQU		19
                        	DVC_FlushInput		EQU		20
                        	DVC_FlushOutput		EQU		21
                        	DVC_IRQ				EQU		22
                        	DVC_IsRemoveable	EQU		23
                        	DVC_IOCTRL_READ		EQU		24
                        	DVC_IOCTRL_WRITE	EQU		25
                        	DVC_OutputUntilBusy	EQU		26
                        	
                        	MAX_DEV_OP			EQU		31
                        	
                        	
                        	DRSP_DONE			EQU		1
                        	
                        	;Standard Devices are:
                        	
                        	;#		Device					Standard name
                        	
                        	;0		NULL device 			NUL		(OS built-in)
                        	;1		Keyboard (sequential)	KBD		(OS built-in)
                        	;2		Video (sequential)		VID		(OS built-in)
                        	;3		Printer (parallel 1)	LPT
                        	;4		Printer (parallel 2)	LPT2
                        	;5		RS-232 1				COM1	(OS built-in)
                        	;6		RS-232 2				COM2
                        	;7		RS-232 3				COM3
                        	;8		RS-232 4				COM4
                        	;9		Parallel xfer	  PTI
                        	;10		Floppy					FD0
                        	;11		Floppy					FD1
                        	;12		Hard disk				HD0
                        	;13		Hard disk				HD1
                        	;14
                        	;15
                        	;16		SDCard					CARD1 	(OS built-in)
                        	;17
                        	;18
                        	;19
                        	;20
                        	;21
                        	;22
                        	;23
                        	;24
                        	;25
                        	;26
                        	;27
                        	;28		Audio						PSG1	(OS built-in)
                        	;29
                        	;30   Random Number		PRNG
                        	;31		Debug						DBG
                        	
                        	NR_DCB			EQU		32
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/macro.r5a",1
                        	.file "../fmtk/macro.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	; macros have to be defined before they are encountered.
                        	
                        	; unlock the a semaphore	
                        	macro mUnlockSemaphore (adr)
	ldi		v0,#-1
	sw		v0,adr
endm
                        	
                        	; Look at the asid register for task id
                        	macro mGetCurrentTid
	csrrw	v0,#$181,x0
	and		v0,v0,#15
endm
                        	
                        	macro	mHasFocus
	ldi		a0,#20
	ecall
endm
                        	
                        	macro mSleep(tm)
	ldi		a0,#5
	ldi		a1,#tm
	ecall
endm
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	macro mWaitForFocus
.WFF1@:
	
	ldi		a0,#20
	ecall
bne		v1,x0,.HasFocus@
	call	SerialPeekChar	;Direct
	ldi		a0,#$14							; CTRL-T
	bne		$v0,$a0,.WFF2@
	call	SerialGetChar
	ldi		$a0,#21							; switch IO Focus
	ecall
	bra		.WFF1@
.WFF2@:
	
	ldi		a0,#5
	ldi		a1,#1
	ecall

	bra		.WFF1@
.HasFocus@:
endm
                        	
                        	;------------------------------------------------------------------------------
                        	; Remove the task from the list of tasks waiting at the mailbox.
                        	; This routine is only called from a couple of places and it is convenient
                        	; not to stack the return address. So, it is implemented as a macro.
                        	;
                        	; Parameters:
                        	;		a0 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	macro mMbxRemoveTask
	sub		$sp,$sp,#16
	sw		$s1,[$sp]
	sw		$t0,4[$sp]
	sw		$t1,8[$sp]
	sw		$t2,12[$sp]
	sll		$s1,$a0,#10						; tid to pointer
	lh		$t0,TCBWaitMbx[$s1]		; get mailbox handle
	blt		$t0,$x0,.xit@					; handle good?
	sll		$t0,$t0,#4						; convert to pointer
	add		$t0,$t0,#mbxs					; by adding base address
	lhu		$t1,MBX_WTIDS[$t0]		; get waiting task list
	ldi		$t2,#1								; create a mask for given task id
	sll		$t2,$t2,$a0
	xor		$t2,$t2,#-1
	and		$t1,$t1,$t2						; clear bit
	sh		$t1,MBX_WTIDS[$t0]		; update waiting task list
.xit@:
	lw		$s1,[$sp]
	lw		$t0,4[$sp]
	lw		$t1,8[$sp]
	lw		$t2,12[$sp]
	add		$sp,$sp,#16
endm
                        	
                        	;------------------------------------------------------------------------------
                        	; Pop an entry off the timeout list. It is assumed the entry is popped when
                        	; its timeout reached zero. Hence there is no adjustment of the following
                        	; timeout made. Routine used only in the schedulerIRQ, so written as a macro.
                        	;
                        	; Modifies:
                        	;		v1,t0,t1,t2,t3
                        	;	Returns:
                        	;		v0 = timeout list entry tid
                        	;------------------------------------------------------------------------------
                        	
                        	macro mPopTimeoutList
	lh		$v0,TimeoutList				; anything on timeout list?
	blt		$v0,$x0,.done@
	ldi		$v1,#NR_TCB
	bgeu	$v0,$v1,.done@
	sll		$t0,$v0,#10						; tid to pointer
	lbu		$v1,TCBStatus[$t0]		; no longer a waiting status
	and		$t1,$v1,#TS_WAITMSG
	beq		$t1,$x0,.noWait@
	
	sub		$sp,$sp,#16
	sw		$s1,[$sp]
	sw		$t0,4[$sp]
	sw		$t1,8[$sp]
	sw		$t2,12[$sp]
	sll		$s1,$a0,#10						; tid to pointer
	lh		$t0,TCBWaitMbx[$s1]		; get mailbox handle
	blt		$t0,$x0,.xit2					; handle good?
	sll		$t0,$t0,#4						; convert to pointer
	add		$t0,$t0,#mbxs					; by adding base address
	lhu		$t1,MBX_WTIDS[$t0]		; get waiting task list
	ldi		$t2,#1								; create a mask for given task id
	sll		$t2,$t2,$a0
	xor		$t2,$t2,#-1
	and		$t1,$t1,$t2						; clear bit
	sh		$t1,MBX_WTIDS[$t0]		; update waiting task list
.xit2:
	lw		$s1,[$sp]
	lw		$t0,4[$sp]
	lw		$t1,8[$sp]
	lw		$t2,12[$sp]
	add		$sp,$sp,#16
.noWait@:
	and		$v1,$v1,#~(TS_WAITMSG|TS_TIMEOUT)
	sb		$v1,TCBStatus[$t0]
	lh		$v1,TCBNext[$t0]
	sh		$v1,TimeoutList
	ldi		$t1,#NR_TCB
	bgeu	$v1,$t1,.done@
	lh		$t1,TCBPrev[$t0]			; t1 = h->prev
	sll		$v1,$v1,#10
	sh		$t1,TCBPrev[$v1]			; TimeoutList->prev = h->prev
	srl		$v1,$v1,#10
	sll		$t1,$t1,#10
	sh		$v1,TCBNext[$t1]			; h->prev->next = TimeoutList
.done@:	
endm
                        	
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	
                        	CTRLC				equ		$03
                        	BS					equ		$08
                        	LF					equ		$0A
                        	CR					equ		$0D
                        	XON					equ		$11
                        	XOFF				equ		$13
                        	DEL					equ		$7F
                        	VIA					equ		$FFDC0600
                        	VIA_PA			equ		$04
                        	VIA_DDRA		equ		$0C
                        	VIA_T1CL		equ		$10
                        	VIA_T1CH		equ		$14
                        	VIA_ACR			equ		$2C
                        	VIA_PCR			equ		$30
                        	VIA_IFR			equ		$34
                        	VIA_IER			equ		$38
                        	VIA_PARAW		equ		$3C
                        	UART				equ		$FFDC0A00
                        	UART_TRB		equ		$00
                        	UART_STAT		equ		$04
                        	UART_CMD		equ		$08
                        			; First 16kB is for TCB's
                        	INBUF				equ		$4100
                        	switchflag	equ		$4200
                        	milliseconds	equ		$4208
                        	
                        	
                        	.file "cs01rom.r5a",30
                        			code	18 bits
                        	;------------------------------------------------------------------------------
                        	; Exception vector table.
                        	;------------------------------------------------------------------------------
                        			org		$FFFC0000				; user mode exception
FFFC0000 7B40006F			jmp		IRQRout
FFFC0004 00000000			org 	$FFFC00C0				; machine mode exception
FFFC0008 00000000
FFFC000C 00000000
FFFC0010 00000000
FFFC0014 00000000
FFFC0018 00000000
FFFC001C 00000000
FFFC0020 00000000
FFFC0024 00000000
FFFC0028 00000000
FFFC002C 00000000
FFFC0030 00000000
FFFC0034 00000000
FFFC0038 00000000
FFFC003C 00000000
FFFC0040 00000000
FFFC0044 00000000
FFFC0048 00000000
FFFC004C 00000000
FFFC0050 00000000
FFFC0054 00000000
FFFC0058 00000000
FFFC005C 00000000
FFFC0060 00000000
FFFC0064 00000000
FFFC0068 00000000
FFFC006C 00000000
FFFC0070 00000000
FFFC0074 00000000
FFFC0078 00000000
FFFC007C 00000000
FFFC0080 00000000
FFFC0084 00000000
FFFC0088 00000000
FFFC008C 00000000
FFFC0090 00000000
FFFC0094 00000000
FFFC0098 00000000
FFFC009C 00000000
FFFC00A0 00000000
FFFC00A4 00000000
FFFC00A8 00000000
FFFC00AC 00000000
FFFC00B0 00000000
FFFC00B4 00000000
FFFC00B8 00000000
FFFC00BC 00000000
FFFC00C0 6F40006F			jmp		IRQRout
FFFC00C4 00000000			org		$FFFC00FC				; non-maskable interrupt
FFFC00C8 00000000
FFFC00CC 00000000
FFFC00D0 00000000
FFFC00D4 00000000
FFFC00D8 00000000
FFFC00DC 00000000
FFFC00E0 00000000
FFFC00E4 00000000
FFFC00E8 00000000
FFFC00EC 00000000
FFFC00F0 00000000
FFFC00F4 00000000
FFFC00F8 00000000
FFFC00FC 0040006F			jmp		MachineStart
                        	
                        	;------------------------------------------------------------------------------
                        	; User mode code starts here
                        	;------------------------------------------------------------------------------
                        			org		$FFFC0100
                        	MachineStart:
FFFC0100 00080737			ldi		$sp,#$80000-4		; setup machine mode stack pointer
FFFC0104 FFC70713
FFFC0108 3A9000EF			call	MMUInit					; initialize MMU for address space zero.
FFFC010C 740010EF			call	FMTKInit
FFFC0110 628010EF			call	ViaInit
FFFC0114 124010EF			call	SerialInit
FFFC0118 00006D13			ldi		$t0,#0
FFFC011C 181D1073			csrrw	$x0,#$181,$t0		; set ASID
FFFC0120 FFFC0D37			ldi		$t0,#$FFFC0000
FFFC0124 000D0D13
FFFC0128 301D1073			csrrw $x0,#$301,$t0		; set tvec
FFFC012C FFFC0D37			ldi		$t0,#UserStart
FFFC0130 140D0D13
FFFC0134 341D1073			csrrw	$x0,#$341,$t0		; set mepc
FFFC0138 3000E073			csrrs	$x0,#$300,#1		; enable interrupts
FFFC013C 10000073			eret									; switch to user mode
                        	UserStart:
FFFC0140 00E06913			ldi		$a0,#14							; Get current tid
FFFC0144 00000073			ecall
FFFC0148 0008E9B3			mov		$a1,$v1
FFFC014C 01806913			ldi		$a0,#24							; RequestIOFocus
FFFC0150 00000073			ecall
FFFC0154 00080737			ldi		$sp,#$80000-1028		; setup user mode stack pointer
FFFC0158 BFC70713
FFFC015C 00806D13			ldi		$t0,#$08						; turn on the LED
FFFC0160 FFDC0637			sw		$t0,VIA+VIA_PARAW
FFFC0164 63C60613
FFFC0168 00060633
FFFC016C 01A62023
FFFC0170 01006E13			ldi		$t2,#16							; send an XON just in case
FFFC0174 01106A93			ldi		$a3,#XON
                        	.0004:
FFFC0178 3B0010EF			call	SerialPutChar
FFFC017C FFFE0E13			sub		$t2,$t2,#1
FFFC0180 FE0E1CE3			bne		$t2,$x0,.0004
                        	.0002:
FFFC0184 FFFC0937			ldi		$a0,#msgStart				; spit out a startup message
FFFC0188 7EC90913
FFFC018C 5F4000EF			call	PutString
FFFC0190 00106913			ldi		a0,#1
FFFC0194 000069B7			ldi		a1,#24000
FFFC0198 DC098993
FFFC019C FFFC0A37			ldi		a2,#Monitor
FFFC01A0 2ECA0A13
FFFC01A4 00000073			ecall
FFFC01A8 708020EF			call	DumpReadyList
FFFC01AC 12000C63			bra		MonEntry
                        	
                        			; Now a loop to recieve and echo back characters
                        	.0003:
FFFC01B0 2B4010EF			call	SerialPeekChar
FFFC01B4 FE084EE3			blt		$v0,$x0,.0003
FFFC01B8 00086933			mov		$a0,$v0
FFFC01BC 36C010EF			call	SerialPutChar
FFFC01C0 FE0008E3			bra		.0003
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a character from input device. Checks for a CTRL-T which indicates to
                        	; switch the I/O focus.
                        	;
                        	; Parameters:
                        	;		none
                        	; Returns:
                        	;		v0 = character, -1 if none available
                        	;------------------------------------------------------------------------------
                        	
                        	Getch:
FFFC01C4 FF470713		sub		$sp,$sp,#12
FFFC01C8 00172023		sw		$ra,[$sp]
FFFC01CC 01272223		sw		$a0,4[$sp]
FFFC01D0 01372423		sw		$a1,8[$sp]
                        		
                        	.WFF13:
                        		
FFFC01D4 01406913		ldi		a0,#20
FFFC01D8 00000073		ecall
FFFC01DC 02089863	bne		v1,x0,.HasFocus3
FFFC01E0 284010EF		call	SerialPeekChar	;Direct
FFFC01E4 01406913		ldi		a0,#$14							; CTRL-T
FFFC01E8 01281A63		bne		$v0,$a0,.WFF23
FFFC01EC 1A8010EF		call	SerialGetChar
FFFC01F0 01506913		ldi		$a0,#21							; switch IO Focus
FFFC01F4 00000073		ecall
FFFC01F8 FC000EE3		bra		.WFF13
                        	.WFF23:
                        		
FFFC01FC 00506913		ldi		a0,#5
FFFC0200 00106993		ldi		a1,#1
FFFC0204 00000073		ecall
                        	
FFFC0208 FC0006E3		bra		.WFF13
                        	.HasFocus3:
FFFC020C 188010EF	call	SerialGetChar
FFFC0210 00072083		lw		$ra,[$sp]
FFFC0214 00472903		lw		$a0,4[$sp]
FFFC0218 00872983		lw		$a1,8[$sp]
FFFC021C 00C70713		add		$sp,$sp,#12
FFFC0220 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	Putch:
FFFC0224 FEC70713		sub		$sp,$sp,#20
FFFC0228 00172023		sw		$ra,[$sp]
FFFC022C 01072223		sw		$v0,4[$sp]
FFFC0230 01572423		sw		$a3,8[$sp]
FFFC0234 01172623		sw		$v1,12[$sp]
FFFC0238 01372823		sw		$a1,16[$sp]
FFFC023C 00096AB3		mov		$a3,$a0
FFFC0240 00506993		ldi		$a1,#5							; serial port
FFFC0244 020000EF		call	fputc
FFFC0248 00072083		lw		$ra,[$sp]
FFFC024C 00472803		lw		$v0,4[$sp]
FFFC0250 00872A83		lw		$a3,8[$sp]
FFFC0254 00C72883		lw		$v1,12[$sp]
FFFC0258 01072983		lw		$a1,16[$sp]
FFFC025C 01470713		add		$sp,$sp,#20
FFFC0260 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; fputc - put a character to an I/O device. If the task doesn't have the I/O
                        	; focus then it is rescheduled, allowing another task to run.
                        	;
                        	; Stack Space:
                        	;		6 words
                        	; Register Usage:
                        	;		a0 = FMTK_IO specify
                        	;		a2 = device putchar function
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a3 = character to put
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	fputc:
FFFC0264 FE870713		sub		$sp,$sp,#24
FFFC0268 00172023		sw		$ra,[$sp]
FFFC026C 01072223		sw		$v0,4[$sp]
FFFC0270 01272423		sw		$a0,8[$sp]
FFFC0274 01172623		sw		$v1,12[$sp]
FFFC0278 01372823		sw		$a1,16[$sp]
FFFC027C 01472A23		sw		$a2,20[$sp]
                        		
                        	.WFF14:
                        		
FFFC0280 01406913		ldi		a0,#20
FFFC0284 00000073		ecall
FFFC0288 02089863	bne		v1,x0,.HasFocus4
FFFC028C 1D8010EF		call	SerialPeekChar	;Direct
FFFC0290 01406913		ldi		a0,#$14							; CTRL-T
FFFC0294 01281A63		bne		$v0,$a0,.WFF24
FFFC0298 0FC010EF		call	SerialGetChar
FFFC029C 01506913		ldi		$a0,#21							; switch IO Focus
FFFC02A0 00000073		ecall
FFFC02A4 FC000EE3		bra		.WFF14
                        	.WFF24:
                        		
FFFC02A8 00506913		ldi		a0,#5
FFFC02AC 00106993		ldi		a1,#1
FFFC02B0 00000073		ecall
                        	
FFFC02B4 FC0006E3		bra		.WFF14
                        	.HasFocus4:
FFFC02B8 01A06913	ldi		$a0,#26							; FMTK_IO
FFFC02BC 00D06A13		ldi		$a2,#13							; putchar function
FFFC02C0 00000073		ecall
FFFC02C4 00072083		lw		$ra,[$sp]
FFFC02C8 00472803		lw		$v0,4[$sp]
FFFC02CC 00872903		lw		$a0,8[$sp]
FFFC02D0 00C72883		lw		$v1,12[$sp]
FFFC02D4 01072983		lw		$a1,16[$sp]
FFFC02D8 01472A03		lw		$a2,20[$sp]
FFFC02DC 01870713		add		$sp,$sp,#24
FFFC02E0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	MonEntry:
                        	;		flw			$f2,fltTen
                        	;		fsw			$f2,f2Save
                        	;		flw			$f1,fltTen
                        	;		fsw			$f1,f1Save
                        	;		fadd		$f18,$f2,$f1
                        	;		fsw			$f18,f18Save
FFFC02E4 00A06913			ldi		$a0,#10
FFFC02E8 00606A13			ldi		$a2,#6
                        	;		call	fltToString
                        	;		ldi		$a0,#STRTMP
                        	;		call	PutString
                        	
                        	Monitor:
FFFC02EC 00006213			ldi		$s1,#0					; s1 = input pointer
FFFC02F0 00D06913			ldi		$a0,#CR
FFFC02F4 F31FF0EF			call	Putch
FFFC02F8 00006913			ldi		$a0,#LF
		call	Putch
FFFC02FC F29FF0EF
FFFC0300 03E06913			ldi		$a0,#'>'
FFFC0304 F21FF0EF			call	Putch
                        	.0001:
FFFC0308 EBDFF0EF			call	Getch						; wait until character pressed
FFFC030C FE084EE3			blt		$v0,$x0,.0001
FFFC0310 00084D13			xor		$t0,$v0,#LF			; ignore line feed
		beq		$t0,$x0,.procLine
FFFC0314 0E0D0C63
FFFC0318 00D84D13			xor		$t0,$v0,#CR
FFFC031C 0E0D0863			beq		$t0,$x0,.procLine
FFFC0320 00884D13			xor		$t0,$v0,#BS
FFFC0324 080D0263			beq		$t0,$x0,.doBackspace
FFFC0328 07F84D13			xor		$t0,$v0,#DEL
FFFC032C 020D0263			beq		$t0,$x0,.doDelete
FFFC0330 00004637			sb		$v0,INBUF[$s1]
FFFC0334 10060613
FFFC0338 00460633
FFFC033C 01060023
FFFC0340 00120213			add		$s1,$s1,#1
FFFC0344 00086933			mov		$a0,$v0
FFFC0348 EDDFF0EF			call	Putch
FFFC034C FA000EE3			bra		.0001
                        	.doDelete:
FFFC0350 000262B3			mov		$s2,$s1
FFFC0354 00128293			add		$s2,$s2,#1
                        	.0002:
FFFC0358 00004637			lb		$t0,INBUF[$s2]
FFFC035C 10060613
FFFC0360 00560633
FFFC0364 00060D03
FFFC0368 00004637			sb		$t0,INBUF-1[$s2]
FFFC036C 0FF60613
FFFC0370 00560633
FFFC0374 01A60023
FFFC0378 00128293			add		$s2,$s2,#1
FFFC037C 00004637			add		$t0,$s2,#INBUF
FFFC0380 10060613
FFFC0384 00560D33
FFFC0388 00004637			slt		$t0,$t0,#INBUF+$7F
FFFC038C 17F60613
FFFC0390 FC0D14E3			bne		$t0,$x0,.0002
FFFC0394 00004637			sb		$x0,INBUF[$s2]
FFFC0398 10060613
FFFC039C 00560633
FFFC03A0 00060023
FFFC03A4 F60002E3			bra		.0001
                        	.doBackspace:
FFFC03A8 F60200E3			beq		$s1,$x0,.0001		; can't backspace anymore
FFFC03AC 00086933			mov		$a0,$v0					; show the backspace
FFFC03B0 E75FF0EF			call	Putch
FFFC03B4 FFF20213			sub		$s1,$s1,#1
FFFC03B8 000262B3			mov		$s2,$s1
                        	.0003:
FFFC03BC 00004637			lb		$t0,INBUF+1[$s2]
FFFC03C0 10160613
FFFC03C4 00560633
FFFC03C8 00060D03
FFFC03CC 00004637			sb		$t0,INBUF[$s2]
FFFC03D0 10060613
FFFC03D4 00560633
FFFC03D8 01A60023
FFFC03DC 00128293			add		$s2,$s2,#1
FFFC03E0 00004637			add		$t0,$s2,#INBUF
FFFC03E4 10060613
FFFC03E8 00560D33
FFFC03EC 00004637			slt		$t0,$t0,#INBUF+$7F
FFFC03F0 17F60613
FFFC03F4 FC0D14E3			bne		$t0,$x0,.0003
FFFC03F8 00004637			sb		$x0,INBUF[$s2]
FFFC03FC 10060613
FFFC0400 00560633
FFFC0404 00060023
FFFC0408 F00000E3			bra		.0001
                        	.procLine:
FFFC040C 00004637			sb		$x0,INBUF[$s1]
FFFC0410 10060613
FFFC0414 00460633
FFFC0418 00060023
FFFC041C 00006213			ldi		$s1,#0
                        	.skip:
FFFC0420 00004637			lb		$t0,INBUF[$s1]
FFFC0424 10060613
FFFC0428 00460633
FFFC042C 00060D03
FFFC0430 100D0A63			beq		$t0,$x0,.0005
FFFC0434 03ED4D93			xor		$t1,$t0,#'>'
FFFC0438 000D9663			bne		$t1,$x0,.0004
                        	.skip2:
FFFC043C 00120213			add		$s1,$s1,#1
FFFC0440 FE0000E3			bra		.skip
                        	.0004:
FFFC0444 020D4D93			xor		$t1,$t0,#' '
FFFC0448 FE0D8AE3			beq		$t1,$x0,.skip2
FFFC044C 009D4D93			xor		$t1,$t0,#'\t'
FFFC0450 FE0D86E3			beq		$t1,$x0,.skip2
FFFC0454 04DD4D93			xor		$t1,$t0,#'M'
FFFC0458 0E0D8863			beq		$t1,$x0,doMem
FFFC045C 04206D93			ldi		$t1,#'B'
FFFC0460 05BD1863			bne		$t0,$t1,.0006
FFFC0464 00106913			ldi		$a0,#1					; Start task
FFFC0468 000089B7			ldi		$a1,#32000			; 32 kB
FFFC046C D0098993
FFFC0470 FFFC3A37			ldi		$a2,#CSTART			; start address
FFFC0474 D30A0A13
FFFC0478 00000073			ecall
FFFC047C 0008E233			mov		$s1,$v1					; save v1
FFFC0480 FFFC1937			ldi		$a0,#msgCRLF
FFFC0484 8B290913
FFFC0488 2F8000EF			call	PutString
FFFC048C 00026933			mov		$a0,$s1					; get back v1
FFFC0490 290000EF			call	PutHexByte
FFFC0494 FFFC1937			ldi		$a0,#msgTaskStart
FFFC0498 8A490913
FFFC049C 2E4000EF			call	PutString
FFFC04A0 00506913			ldi		$a0,#5					; Reschedule task
FFFC04A4 00106993			ldi		$a1,#1					; sleep(0)
FFFC04A8 00000073			ecall
FFFC04AC E41FF06F			jmp		Monitor
                        	.0006:
FFFC04B0 04406D93			ldi		$t1,#'D'
FFFC04B4 03BD1663			bne		$t0,$t1,.0007
FFFC04B8 00004637			lb		$t0,INBUF+1[$s1]
FFFC04BC 10160613
FFFC04C0 00460633
FFFC04C4 00060D03
FFFC04C8 05406D93			ldi		$t1,#'T'
FFFC04CC 01BD1663			bne		$t0,$t1,.noT
FFFC04D0 4C0020EF			call	DumpTimeoutList
FFFC04D4 E19FF06F			jmp		Monitor
                        	.noT:
FFFC04D8 3D8020EF			call 	DumpReadyList
                        			;ldi		$a0,#15
                        			;ecall
FFFC04DC E11FF06F			jmp		Monitor
                        	.0007:
FFFC04E0 04506D93			ldi		$t1,#'E'
FFFC04E4 01BD1463			bne		$t0,$t1,.0008
FFFC04E8 0E80006F			jmp		EditMem
                        	.0008:
FFFC04EC 04606D93			ldi		$t1,#'F'
FFFC04F0 01BD1463			bne		$t0,$t1,.0009
FFFC04F4 0F40006F			jmp		FillMem
                        	.0009:
FFFC04F8 05306D93			ldi		$t1,#'S'
FFFC04FC 01BD1A63			bne		$t0,$t1,.0010
FFFC0500 00506913			ldi		$a0,#5					; sleep(0)
FFFC0504 00106993			ldi		$a1,#1
FFFC0508 00000073			ecall
FFFC050C DE1FF06F			jmp		Monitor
                        	.0010:
FFFC0510 04B06D93			ldi		$t1,#'K'
FFFC0514 01BD1C63			bne		$t0,$t1,.0011
FFFC0518 128000EF			call	GetHexNum
FFFC051C 00306913			ldi		$a0,#3					; kill task
FFFC0520 000869B3			mov		$a1,$v0					; a0 = pid
FFFC0524 00000073			ecall
FFFC0528 DC5FF06F			jmp		Monitor
                        	.0011:
FFFC052C 03F06D93			ldi		$t1,#'?'
FFFC0530 01BD1A63			bne		$t0,$t1,.0012
FFFC0534 FFFC1937			ldi		$a0,#msgMonHelp
FFFC0538 80290913
FFFC053C 244000EF			call	PutString
FFFC0540 DADFF06F			jmp		Monitor
                        	.0012:
                        	.0005:
FFFC0544 DA0004E3			bra		Monitor
                        	
                        	doMem:
FFFC0548 FFC70713			sub		$sp,$sp,#4
FFFC054C 00120213			add		$s1,$s1,#1
FFFC0550 00472023			sw		$s1,[$sp]
FFFC0554 00D06913			ldi		$a0,#CR
FFFC0558 CCDFF0EF			call	Putch
FFFC055C 00004937			ldi		$a0,INBUF
FFFC0560 10090913
FFFC0564 21C000EF			call	PutString
FFFC0568 00072203			lw		$s1,[$sp]
FFFC056C 00470713			add		$sp,$sp,#4
FFFC0570 0D0000EF			call	GetHexNum
FFFC0574 00086333			mov		$s3,$v0
FFFC0578 00120213			add		$s1,$s1,#1
FFFC057C 0C4000EF			call	GetHexNum
FFFC0580 006803B3			add		$s4,$v0,$s3
                        	.loop2:
FFFC0584 C41FF0EF			call	Getch						; check for ctrl-c
FFFC0588 00384813			xor		$v0,$v0,#3
FFFC058C D60800E3			beq		$v0,$x0,Monitor
FFFC0590 00D06913			ldi		$a0,#CR
FFFC0594 C91FF0EF			call	Putch
FFFC0598 00036933			mov		$a0,$s3
FFFC059C 144000EF			call	PutHexWord
FFFC05A0 03A06913			ldi		$a0,#':'
FFFC05A4 C81FF0EF			call	Putch
FFFC05A8 00706293			ldi		$s2,#7
                        	.loop:
FFFC05AC 02006913			ldi		$a0,#' '
FFFC05B0 C75FF0EF			call	Putch
FFFC05B4 00030903			lb		$a0,[$s3]
FFFC05B8 168000EF			call	PutHexByte
FFFC05BC 00130313			add		$s3,$s3,#1
FFFC05C0 FFF28293			sub		$s2,$s2,#1
FFFC05C4 FE02D4E3			bge		$s2,$x0,.loop
FFFC05C8 FA736EE3			bltu	$s3,$s4,.loop2
FFFC05CC D20000E3			bra		Monitor		
                        	
                        	EditMem:
FFFC05D0 070000EF			call	GetHexNum			; get address to edit
FFFC05D4 00086333			mov		$s3,$v0
FFFC05D8 00120213			add		$s1,$s1,#1
FFFC05DC 064000EF			call	GetHexNum			; get value to set
FFFC05E0 00680023			sb		$s3,[$v0]			; update mem
FFFC05E4 D09FF06F			jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	;	>F 1000 800 EE
                        	; Fills memory beginning at address $1000 for $800 bytes with the value $EE
                        	;------------------------------------------------------------------------------
                        	
                        	FillMem:
FFFC05E8 058000EF			call	GetHexNum			; get address
FFFC05EC 00086333			mov		$s3,$v0
FFFC05F0 00120213			add		$s1,$s1,#1
FFFC05F4 04C000EF			call	GetHexNum			; get length
FFFC05F8 000863B3			mov		$s4,$v0
FFFC05FC 00120213			add		$s1,$s1,#1
FFFC0600 040000EF			call	GetHexNum			; get byte to use
                        	.0001:
FFFC0604 01030023			sb		$v0,[$s3]
FFFC0608 FFF38393			sub		$s4,$s4,#1
FFFC060C FE704CE3			bgt		$s4,$x0,.0001
FFFC0610 CDDFF06F			jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; Skip over spaces and tabs in the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	SkipSpaces:
                        	.skip2:
FFFC0614 00004637			lb		$t0,INBUF[$s1]
FFFC0618 10060613
FFFC061C 00460633
FFFC0620 00060D03
FFFC0624 020D4D93			xor		$t1,$t0,#' '
FFFC0628 000D8863			beq		$t1,$x0,.skip1
FFFC062C 009D4D93			xor		$t1,$t0,#'\t'
FFFC0630 000D8463			beq		$t1,$x0,.skip1
FFFC0634 00008067			ret
                        	.skip1:
FFFC0638 00120213			add		$s1,$s1,#1
FFFC063C FC000CE3			bra		.skip2
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a hex number from the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	GetHexNum:
FFFC0640 00006813			ldi		$v0,#0							; v0 = num
FFFC0644 FFC70713			sub		$sp,$sp,#4
FFFC0648 00172023			sw		$ra,[$sp]
FFFC064C FC9FF0EF			call	SkipSpaces
                        	.next:
FFFC0650 00004637			lb		$t0,INBUF[$s1]
FFFC0654 10060613
FFFC0658 00460633
FFFC065C 00060D03
FFFC0660 03006E13			ldi		$t2,#'0'
FFFC0664 03CD4663			blt		$t0,$t2,.0001
FFFC0668 03A06E13			ldi		$t2,#'9'+1
FFFC066C 07CD4063			blt		$t0,$t2,.isDigit
FFFC0670 04106E13			ldi		$t2,#'A'
FFFC0674 01CD4E63			blt		$t0,$t2,.0001
FFFC0678 04706E13			ldi		$t2,#'F'+1
FFFC067C 03CD4063			blt		$t0,$t2,.isHexUpper
FFFC0680 06106E13			ldi		$t2,#'a'
FFFC0684 01CD4663			blt		$t0,$t2,.0001
FFFC0688 06706E13			ldi		$t2,#'f'+1
FFFC068C 03CD4463			blt		$t0,$t2,.isHexLower
                        	.0001:
FFFC0690 00072083			lw		$ra,[$sp]
FFFC0694 00470713			add		$sp,$sp,#4
FFFC0698 00008067			ret
                        	.isHexUpper:
FFFC069C 00481813			sll		$v0,$v0,#4
FFFC06A0 FBFD0D13			sub		$t0,$t0,#'A'
FFFC06A4 00AD0D13			add		$t0,$t0,#10
FFFC06A8 01A86833			or		$v0,$v0,$t0
FFFC06AC 00120213			add		$s1,$s1,#1
FFFC06B0 FA0000E3			bra		.next
                        	.isHexLower:
FFFC06B4 00481813			sll		$v0,$v0,#4
FFFC06B8 F9FD0D13			sub		$t0,$t0,#'a'
FFFC06BC 00AD0D13			add		$t0,$t0,#10
FFFC06C0 01A86833			or		$v0,$v0,$t0
FFFC06C4 00120213			add		$s1,$s1,#1
FFFC06C8 F80004E3			bra		.next
                        	.isDigit:
FFFC06CC 00481813			sll		$v0,$v0,#4
FFFC06D0 FD0D0D13			sub		$t0,$t0,#'0'
FFFC06D4 01A86833			or		$v0,$v0,$t0
FFFC06D8 00120213			add		$s1,$s1,#1
FFFC06DC F6000AE3			bra		.next
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a word as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexWord:
FFFC06E0 FF870713			sub		$sp,$sp,#8
FFFC06E4 00172023			sw		$ra,[$sp]
FFFC06E8 01272223			sw		$a0,4[$sp]
FFFC06EC 01095913			srl		$a0,$a0,#16
FFFC06F0 010000EF			call	PutHexHalf
FFFC06F4 00072083			lw		$ra,[$sp]
FFFC06F8 00472903			lw		$a0,4[$sp]
FFFC06FC 00870713			add		$sp,$sp,#8	; fall through to PutHexHalf
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a half-word (16 bits) as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexHalf:
FFFC0700 FF870713			sub		$sp,$sp,#8
FFFC0704 00172023			sw		$ra,[$sp]
FFFC0708 01272223			sw		$a0,4[$sp]
FFFC070C 00895913			srl		$a0,$a0,#8
FFFC0710 010000EF			call	PutHexByte
FFFC0714 00072083			lw		$ra,[$sp]
FFFC0718 00472903			lw		$a0,4[$sp]		
FFFC071C 00870713			add		$sp,$sp,#8	; fall through to PutHexByte
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a byte as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexByte:
FFFC0720 FF870713			sub		$sp,$sp,#8
FFFC0724 00172023			sw		$ra,[$sp]
FFFC0728 01272223			sw		$a0,4[$sp]
FFFC072C 00495913			srl		$a0,$a0,#4		; put the high order nybble first
FFFC0730 010000EF			call	PutHexNybble
FFFC0734 00072083			lw		$ra,[$sp]
FFFC0738 00472903			lw		$a0,4[$sp]
FFFC073C 00870713			add		$sp,$sp,#8		; fall through to PutHexNybble
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a nybble as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexNybble:
FFFC0740 FF870713			sub		$sp,$sp,#8
FFFC0744 00172023			sw		$ra,[$sp]
FFFC0748 01272223			sw		$a0,4[$sp]
FFFC074C 00F97913			and		$a0,$a0,#15		; strip off high order bits
FFFC0750 00A06D13			ldi		$t0,#10
FFFC0754 01A94A63			blt		$a0,$t0,.lt10
FFFC0758 FF690913			sub		$a0,$a0,#10
FFFC075C 04190913			add		$a0,$a0,#'A'
FFFC0760 AC5FF0EF			call	Putch
FFFC0764 00000663			bra		.0001
                        	.lt10:
FFFC0768 03090913			add		$a0,$a0,#'0'
FFFC076C AB9FF0EF			call	Putch
                        	.0001:
FFFC0770 00072083			lw		$ra,[$sp]
FFFC0774 00472903			lw		$a0,4[$sp]
FFFC0778 00870713			add		$sp,$sp,#8
FFFC077C 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; PutString
                        	;    Put a string of characters to the serial transmitter. Calls the 
                        	; Putch routine, so this routine also blocks if the transmitter is not
                        	; empty.
                        	;
                        	; Parameters:
                        	;		$a0 = pointer to null terminated string to put
                        	; Modifies:
                        	;		$t0 and $t1
                        	; Stack Space:
                        	;		2 words
                        	;------------------------------------------------------------------------------
                        	
                        	PutString:
FFFC0780 FF870713			sub		$sp,$sp,#8				; save link register
FFFC0784 00172023			sw		$ra,[$sp]
FFFC0788 01272223			sw		$a0,4[$sp]				; and argument
FFFC078C 00096DB3			mov		$t1,$a0						; t1 = pointer to string
                        	.0001:
FFFC0790 000D8903			lb		$a0,[$t1]
FFFC0794 001D8D93			add		$t1,$t1,#1				; advance pointer to next byte
FFFC0798 00090663			beq		$a0,$x0,.done			; branch if done
FFFC079C A89FF0EF			call	Putch							; output character
FFFC07A0 FE0008E3			bra		.0001
                        	.done:
FFFC07A4 00072083			lw		$ra,[$sp]					; restore return address
FFFC07A8 00472903			lw		$a0,4[$sp]				; and argument
FFFC07AC 00870713			add		$sp,$sp,#8
FFFC07B0 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Exception processing code starts here.
                        	; As per the RISCV privilege spec, the MSB indicates an external interrupt.
                        	; The system uses cause codes 32 to 63 for external devices. This cause code
                        	; range is reserved in the RISCV spec.
                        	;------------------------------------------------------------------------------
                        	.file "cs01rom.r5a",553
                        		code
                        		align	4                        	
                        	IRQRout:
FFFC07B4 00080737		ldi		$sp,#$80000-4		; setup machine mode stack pointer
FFFC07B8 FFC70713
FFFC07BC 34201D73		csrrw	$t0,#$342,$x0			; get cause code
FFFC07C0 000D4463		blt		$t0,$x0,.isIRQ		; irq or ecall?
FFFC07C4 4E00106F		jmp		OSCALL					; goto operating system call dispatcher
                        	.isIRQ:
FFFC07C8 01FD7D13		and		$t0,$t0,#31			; interrupting device # is low order 5 bits of cause code
FFFC07CC 007D1D13		sll		$t0,$t0,#7				; 128 bytes per device func table
FFFC07D0 0000A637		add		$t0,$t0,#DVF_Base+22*4	; load IRQ routine vector from device func table
FFFC07D4 05860613
FFFC07D8 01A60D33
FFFC07DC 000D2D03		lw		$t0,[$t0]
FFFC07E0 000D0463		beq		$t0,$x0,.noIRQ	; make sure there's an address to go to
FFFC07E4 000D0067		jmp		[$t0]						; jump to the IRQ routine
                        	.noIRQ:
FFFC07E8 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Message strings
                        	;------------------------------------------------------------------------------
                        	
                        	msgStart:
FFFC07EC 31305343			db		"CS01 System Starting.",13
FFFC07F0 73795320
FFFC07F4 206D6574
FFFC07F8 72617453
FFFC07FC 676E6974
FFFC0800 6F4D0D2E
                        	msgMonHelp:
FFFC0802 696E6F4D			db		"Monitor Commands",13
FFFC0806 20726F74
FFFC080A 6D6D6F43
FFFC080E 73646E61
FFFC0812 2D20420D
FFFC0813 202D2042			db		"B - start tiny basic",13
FFFC0817 72617473
FFFC081B 69742074
FFFC081F 6220796E
FFFC0823 63697361
FFFC0827 2D20440D
FFFC0828 202D2044			db		"D - dump ready que",13
FFFC082C 706D7564
FFFC0830 61657220
FFFC0834 71207964
FFFC0838 450D6575
FFFC083B 202D2045			db		"E - edit memory",13
FFFC083F 74696465
FFFC0843 6D656D20
FFFC0847 0D79726F
FFFC084B 202D2046			db		"F - fill memory",13
FFFC084F 6C6C6966
FFFC0853 6D656D20
FFFC0857 0D79726F
FFFC085B 743C204B			db		"K <tid> - kill task", 13
FFFC085F 203E6469
FFFC0863 696B202D
FFFC0867 74206C6C
FFFC086B 0D6B7361
FFFC086F 733C204D			db		"M <start> <length>	- dump memory",13
FFFC0873 74726174
FFFC0877 6C3C203E
FFFC087B 74676E65
FFFC087F 2D093E68
FFFC0883 6D756420
FFFC0887 656D2070
FFFC088B 79726F6D
FFFC088F 2D20530D
FFFC0890 202D2053			db		"S - switch task",13
FFFC0894 74697773
FFFC0898 74206863
FFFC089C 0D6B7361
FFFC08A0 00000000			db		0
FFFC08A1 20000000			align 
                        	
                        	msgTaskStart:
FFFC08A4 73617420			db		" task started."
FFFC08A8 7473206B
FFFC08AC 65747261
FFFC08B0 0A0D2E64
                        	msgCRLF:
FFFC08B2 00000A0D			db		13,10,0
                        	flt50:
FFFC08B5 00000000		dw	0x00000000,0x00000000,0x00000000,0x40049000
FFFC08B9 00000000
FFFC08BD 00000000
FFFC08C1 40049000
                        	flt20:
FFFC08C5 00000000		dw	0x00000000,0x00000000,0x00000000,0x40034000
FFFC08C9 00000000
FFFC08CD 00000000
FFFC08D1 40034000
                        	flt10:
FFFC08D5 00000000		dw	0x00000000,0x00000000,0x00000000,0x40024000
FFFC08D9 00000000
FFFC08DD 00000000
FFFC08E1 40024000
                        	
                        	.file "fltToString.r5a",1
                        	.file "fltToString.r5a",1
                        	STRTMP		equ		$0200
                        	
                        	; -----------------------------------------------------------------------------
                        	;		$fa0 = number to convert (f18)
                        	;		$a1	= width
                        	;		$a2 = precision
                        	;		$a3 = E
                        	;		$t2 = ndx
                        	;		$s9 = exp
                        	; -----------------------------------------------------------------------------
                        	
                        	fltToString:
FFFC08E5 006E1300			ldi		$t2,#0				; $t2 = 0
FFFC08E9 09095300
FFFC08EA E0090953			fmv		$a0,$f18
FFFC08EE 7F800637			and		$t0,$a0,#$7F800000
FFFC08F2 00060613
FFFC08F6 01267D33
FFFC08FA 7F800DB7			ldi		$t1,#$7F800000
FFFC08FE 000D8D93
FFFC0902 05BD1263			bne		$t0,$t1,.0001
FFFC0906 00800637			and		$t0,$a0,#$007FFFFF
FFFC090A FFF60613
FFFC090E 01267D33
FFFC0912 000D0E63			beq		$t0,$x0,.inf
FFFC0916 FFFC1637			ldt		$t0,msgNan
FFFC091A CA060613
FFFC091E 00060633
FFFC0922 00062D03
FFFC0926 21A02023			stt		$t0,STRTMP
FFFC092A 2E000E63			bra		.prt
                        	.inf:
FFFC092E FFFC1637			ldt		$t0,msgInf
FFFC0932 C9C60613
FFFC0936 00060633
FFFC093A 00062D03
FFFC093E 21A02023			stt		$t0,STRTMP
FFFC0942 2E000263			bra		.prt
                        	.0001:
FFFC0946 80000637			and		$t0,$a0,#$80000000
FFFC094A 00060613
FFFC094E 01267D33
FFFC0952 000D0E63			beq		$t0,$x0,.pos
FFFC0956 02D06D13			ldi		$t0,#'-'
FFFC095A 21AE0023			stb		$t0,STRTMP[$t2]
FFFC095E 001E0E13			add		$t2,$t2,#1
FFFC0962 80000637			and		$a0,$a0,#$7FFFFFFF
FFFC0966 FFF60613
FFFC096A 01267933
                        	.pos:
FFFC096E 00091A63			bne		$a0,$x0,.notZero
FFFC0972 03006D13			ldi		$t0,#'0'
FFFC0976 21AE0023			stb		$t0,STRTMP[$t2]
FFFC097A 200E00A3			stb		$x0,STRTMP+1[$t2]
FFFC097E 2A000463			bra		.prt		
                        	.notZero:
FFFC0982 00006633			mov		$s9,$x0			; exp = 0.0
                        	;	// Make a small number > 0 so we can get at the digits.
                        	;	if (dbl < 1.0) {
                        	;		while (dbl < 1.0) {
                        	;			dbl *= 1000000.0;
                        	;			exp -= 6;  
                        	;		}
                        	;	}
FFFC0986 FFFC1637			flw		$f3,fltOne
FFFC098A CA460613
FFFC098E 00060633
FFFC0992 00062187
FFFC0996 F0090053			fmv		$f0,$a0
FFFC099A A0391D53			flt		$t0,$f18,$f3
FFFC099E 020D0463			beq		$t0,$x0,.0002
FFFC09A2 FFFC1637			flw		$f4,fltMillion
FFFC09A6 CAC60613
FFFC09AA 00060633
FFFC09AE 00062207
                        	.0003:
FFFC09B2 A0391D53			flt		$t0,$f18,$f3
FFFC09B6 000D0863			beq		$t0,$x0,.0002
FFFC09BA 10490953			fmul	$f18,$f18,$f4
FFFC09BE FFA60613			sub		$s9,$s9,#6
FFFC09C2 FE0008E3			bra		.0003
                        	.0002:
                        	;	// The following is similar to using log10() and pow() functions.
                        	;	// Now dbl is >= 1.0
                        	;	// Create a number dbl2 on the same order of magnitude as dbl, but
                        	;	// less than dbl.
                        	;	dbl2 = 1.0;
                        	;	dbla = dbl2;
                        	;	if (dbl > dbl2) {	// dbl > 1.0 ?
                        	;		while (dbl2 <= dbl) {
                        	;			dbla = dbl2;
                        	;			dbl2 *= 10.0;	// increase power of 10
                        	;			exp++;
                        	;		}
                        	;		// The above loop goes one too far, we want the last value less
                        	;		// than dbl.
                        	;		dbl2 = dbla;
                        	;		exp--;
                        	;	}
FFFC09C6 FFFC1637			flw		$f1,fltOne				; $f1 = dbl2 = 1.0
FFFC09CA CA460613
FFFC09CE 00060633
FFFC09D2 00062087
FFFC09D6 38008153			fmov	$f2,$f1						; $f2 = dbla = dbl2
FFFC09DA A1209D53			flt		$t0,$f1,$f18				; if (dbl2 < dbl)
FFFC09DE 020D0A63			beq		$t0,$x0,.0004
FFFC09E2 FFFC1637			flw		$f5,fltTen				; $f5 = 10.0
FFFC09E6 CA860613
FFFC09EA 00060633
FFFC09EE 00062287
                        	.0006:
FFFC09F2 A1208D53			fle		$t0,$f1,$f18				; while ($f1 <= $f18)
FFFC09F6 000D0A63			beq		$t0,$x0,.0005
FFFC09FA 38008153			fmov	$f2,$f1						; dbla = dbl2
FFFC09FE 105080D3			fmul	$f1,$f1,$f5				; dbl2 *= 10.0
FFFC0A02 00160613			add		$s9,$s9,#1				; exp++;
FFFC0A06 FE0006E3			bra		.0006
                        	.0005:
FFFC0A0A 380100D3			fmov	$f1,$f2						; dbl2 = dbla
FFFC0A0E FFF60613			sub		$s9,$s9,#1				; exp--;
                        	.0004:
                        	;	// For small constants < 1000000 try and spit out a whole number
                        	;    if (exp >= 0 && exp < 6) {
                        	;        digits_before_decpt = exp+1;
                        	;		exp = 0;
                        	;	}
                        	;	else if (exp >= -6)
                        	;		digits_before_decpt = 1;
                        	;	else
                        	;		digits_before_decpt = -1;
FFFC0A12 00064E63			blt		$s9,$x0,.0007
FFFC0A16 00606413			ldi		$s5,#6
FFFC0A1A 00865A63			bge		$s9,$s5,.0007
FFFC0A1E FFFFE233			mov		$s1,#s0						; s1 = digits before decpt
FFFC0A22 00120213			add		$s1,$s1,#1
FFFC0A26 00006613			ldi		$s9,#0						; exp = 0
FFFC0A2A 00000C63			bra		.0008
                        	.0007:
FFFC0A2E FF906413			ldi		$s5,#-7
FFFC0A32 00864663			blt		$s9,$s5,.0009
FFFC0A36 00106213			ldi		$s1,#1
FFFC0A3A 00000463			bra		.0008
                        	.0009:
FFFC0A3E FFF06213			ldi		$s1,#-1
                        	.0008:
                        	;	// Spit out a leading zero before the decimal point for a small number.
                        	;    if (exp < -6) {
                        	;		buf[ndx] = '0';
                        	;		ndx++;
                        	;        buf[ndx] = '.';
                        	;        ndx++;
                        	;    }
FFFC0A42 FFA06413			ldi		$s5,#-6
FFFC0A46 00865E63			bge		$s9,$s5,.0010
FFFC0A4A 03006D13			ldi		$t0,#'0'
FFFC0A4E 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0A52 001E0E13			add		$t2,$t2,#1
FFFC0A56 02E06D13			ldi		$t0,#'.'
FFFC0A5A 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0A5E 001E0E13			add		$t2,$t2,#1
                        	.0010:
                        	;	// Now loop processing one digit at a time.
                        	;    for (nn = 0; nn < 30 && precision > 0; nn++) {
                        	;        digit = 0;
                        	;		dbla = dbl;
                        	;		// dbl is on the same order of magnitude as dbl2 so
                        	;		// a repeated subtract can be used to find the digit.
                        	;        while (dbl >= dbl2) {
                        	;            dbl -= dbl2;
                        	;            digit++;
                        	;        }
                        	;        buf[ndx] = digit + '0';
                        	;		// Now go back and perform just a single subtract and
                        	;		// a multiply to find out how much to reduce dbl by.
                        	;		// This should improve the accuracy
                        	;		if (digit > 2)
                        	;			dbl = dbla - dbl2 * digit;
                        	;        ndx++;
                        	;        digits_before_decpt--;
                        	;        if (digits_before_decpt==0) {
                        	;           buf[ndx] = '.';
                        	;           ndx++;
                        	;        }
                        	;        else if (digits_before_decpt < 0)
                        	;            precision--;
                        	;		// Shift the next digit to be tested into position.
                        	;        dbl *= 10.0;
                        	;    }
FFFC0A62 00006313			ldi		$s3,#0						; s3 = nn = 0
FFFC0A66 01E06413			ldi		$s5,#30
FFFC0A6A FFFC1637			flw		$f7,fltTen				; f7 = 10.0
FFFC0A6E CA860613
FFFC0A72 00060633
FFFC0A76 00062387
                        	.0016:
FFFC0A7A 00832D33			slt		$t0,$s3,$s5
FFFC0A7E 060D0863			beq		$t0,$x0,.0011
FFFC0A82 00006413			ldi		$s5,#0
FFFC0A86 07445463			bge		$s5,$a2,.0011			; (0 < precision)
FFFC0A8A 00006393			ldi		$s4,#0						; s4 = digit = 0
FFFC0A8E 38090153			fmov	$f2,$f18						; dbla = dbl
                        	.0013:
FFFC0A92 A1208D53			fle		$t0,$f1,$f18						; while (dbl2 <= dbl)
FFFC0A96 000D0863			beq		$t0,$x0,.0012
FFFC0A9A 08190953			fsub	$f18,$f18,$f1						; dbl -= dbl2
FFFC0A9E 00138393			add		$s4,$s4,#1						; digit++
FFFC0AA2 FE0008E3			bra		.0013
                        	.0012:
FFFC0AA6 03038413			add		$s5,$s4,#'0'			; buf[ndx] = digit + '0'
FFFC0AAA 208E0023			stb		$s5,STRTMP[$t2]
FFFC0AAE 00206413			ldi		$s5,#2						; if (2 < digit)
FFFC0AB2 00745863			bge		$s5,$s4,.0014
FFFC0AB6 D00382D3			fcvt.s.w	$f5,$s4				; f5 = digit as float
FFFC0ABA 10508353			fmul	$f6,$f1,$f5				; f6 = dbl2 * digit
FFFC0ABE 08610953			fsub	$f18,$f2,$f6				; dbl = dbla - dbl2 * digit
                        	.0014:
FFFC0AC2 001E0E13			add		$t2,$t2,#1				; ndx++
FFFC0AC6 FFF20213			sub		$s1,$s1,#1				; digits_before_decpt--;
FFFC0ACA 00021A63			bne		$s1,$x0,.0015			; if (digits_before_decpt==0)
FFFC0ACE 02E06D13			ldi		$t0,#'.'
FFFC0AD2 21AE0023			stb		$t0,STRTMP[$t2]		; buf[ndx] = '.'
FFFC0AD6 001E0E13			add		$t2,$t2,#1				; ndx++
FFFC0ADA 00000663			bra		.0017
                        	.0015:
FFFC0ADE 00025463			bge		$s1,$x0,.0017			; else if (digits_before_decpt < 0)
FFFC0AE2 FFFA0A13			sub		$a2,$a2,#1				; 	precision--
                        	.0017:
FFFC0AE6 10790953			fmul	$f18,$f18,$f7				; dbl *= 10.0
FFFC0AEA F80008E3			bra		.0016
                        	.0011:
                        	;	// Trim trailing zeros from the number
                        	;    do {
                        	;        ndx--;
                        	;    } while(buf[ndx]=='0');
                        	;    ndx++;
                        	.0018:
FFFC0AEE FFFE0E13			sub		$t2,$t2,#1				; ndx--
FFFC0AF2 200E0D03			ldb		$t0,STRTMP[$t2]
FFFC0AF6 030D4D13			xor		$t0,$t0,#'0'
FFFC0AFA FE0D0AE3			beq		$t0,$x0,.0018
FFFC0AFE 001E0E13			add		$t2,$t2,#1				; ndx++
                        	;	// Make sure we have at least one digit after the decimal point.
                        	;	if (buf[ndx]=='.') {
                        	;		ndx++;
                        	;		buf[ndx]='0';
                        	;		ndx++;
                        	;        buf[ndx]='\0';
                        	;	}
FFFC0B02 200E0D03			ldb		$t0,STRTMP[$t2]
FFFC0B06 02ED4D13			xor		$t0,$t0,#'.'
FFFC0B0A 000D1C63			bne		$t0,$x0,.0019
FFFC0B0E 001E0E13			add		$t2,$t2,#1
FFFC0B12 03006D13			ldi		$t0,#'0'
FFFC0B16 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0B1A 001E0E13			add		$t2,$t2,#1
FFFC0B1E 200E0023			stb		$x0,STRTMP[$t2]
                        	.0019:
                        	;	// If the number is times 10^0 don't output the exponent
                        	;   if (exp==0) {
                        	;        buf[ndx]='\0';
                        	;        goto prt;
                        	;    }
FFFC0B22 00061663			bne		$s9,$x0,.0020
FFFC0B26 200E0023			stb		$x0,STRTMP[$t2]
FFFC0B2A 0E000E63			bra		.prt
                        	.0020:
                        	;	// Spit out +/-E
                        	;    buf[ndx] = E;
                        	;    ndx++;
                        	;    if (exp < 0) {
                        	;        buf[ndx]='-';
                        	;        ndx++;
                        	;        exp = -exp;
                        	;    }
                        	;    else {
                        	;         buf[ndx]='+';
                        	;         ndx++;
                        	;    }
FFFC0B2E 04506D13			ldi		$t0,#'E'
FFFC0B32 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0B36 001E0E13			add		$t2,$t2,#1
FFFC0B3A 00065C63			bge		$s9,$x0,.0021
FFFC0B3E 02D06D13			ldi		$t0,#'-'
FFFC0B42 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0B46 001E0E13			add		$t2,$t2,#1
FFFC0B4A 40C00633			sub		$s9,$x0,$s9			; exp = -exp
FFFC0B4E 00000863			bra		.0022
                        	.0021:
FFFC0B52 02B06D13			ldi		$t0,#'+'
FFFC0B56 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0B5A 001E0E13			add		$t2,$t2,#1
                        	.0022:
                        	;	// now process the exponent
                        	;    digit = 0;
                        	;    while (exp >= 1000) {
                        	;        exp -= 1000;
                        	;        digit++;
                        	;    }
FFFC0B5E 00006393			ldi		$s4,#0
FFFC0B62 3E806D13			ldi		$t0,#1000
                        	.0025:
FFFC0B66 01A65463			bge		$s9,$t0,.0023
FFFC0B6A 00000863			bra		.0024
                        	.0023:
FFFC0B6E 41A60633			sub		$s9,$s9,$t0
FFFC0B72 00138393			add		$s4,$s4,#1
FFFC0B76 FE0008E3			bra		.0025
                        	.0024:
                        	;	d1 = digit;
                        	;	if (digit) {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0B7A 0003E4B3			mov		$s6,$s4					; s6 = d1 = s4 = digit
FFFC0B7E 00039863			bne		$s4,$x0,.0026
FFFC0B82 03038D13			add		$t0,$s4,#'0'
FFFC0B86 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0B8A 001E0E13			add		$t2,$t2,#1
                        	.0026:
                        	;	digit = 0;
                        	;    while (exp >= 100) {
                        	;        exp -= 100;
                        	;        digit++;
                        	;    }
FFFC0B8E 00006393			ldi		$s4,#0
FFFC0B92 06406D13			ldi		$t0,#100
                        	.0027:
FFFC0B96 01A65463			bge		$s9,$t0,.0028
FFFC0B9A 00000863			bra		.0029
                        	.0028:
FFFC0B9E 41A60633			sub		$s9,$s9,$t0
FFFC0BA2 00138393			add		$s4,$s4,#1
FFFC0BA6 FE0008E3			bra		.0027
                        	.0029:	
                        	;	d2 = digit;
                        	;	if (digit==0 && d1==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0BAA 0003E533			mov		$s7,$s4				; $s7 = d2
FFFC0BAE 00049463			bne		$s6,$x0,.0030
FFFC0BB2 00038863			beq		$s4,$x0,.0031
                        	.0030:
FFFC0BB6 03038D13			add		$t0,$s4,#'0'
FFFC0BBA 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0BBE 001E0E13			add		$t2,$t2,#1
                        	.0031:
                        	;	digit = 0;
                        	;    while (exp >= 10) {
                        	;        exp -= 10;
                        	;        digit++;
                        	;    }
FFFC0BC2 00006393			ldi		$s4,#0
FFFC0BC6 00A06D13			ldi		$t0,#10
                        	.0032:
FFFC0BCA 01A65463			bge		$s9,$t0,.0034
FFFC0BCE 00000863			bra		.0035
                        	.0034:
FFFC0BD2 41A60633			sub		$s9,$s9,$t0
FFFC0BD6 00138393			add		$s4,$s4,#1
FFFC0BDA FE0008E3			bra		.0032
                        	.0035:	
                        	;	d3 = digit;
                        	;	if (digit==0 && d1==0 && d2==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0BDE 0003E5B3			mov		$s8,$s4
FFFC0BE2 00039663			bne		$s4,$x0,.0036
FFFC0BE6 00049463			bne		$s6,$x0,.0036
FFFC0BEA 00050863			beq		$s7,$x0,.0037
                        	.0036:
FFFC0BEE 03038D13			add		$t0,$s4,#'0'
FFFC0BF2 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0BF6 001E0E13			add		$t2,$t2,#1
                        	.0037:
                        	;	digit = 0;
                        	;    while (exp >= 1) {
                        	;        exp -= 1;
                        	;        digit++;
                        	;    }
FFFC0BFA 00006393			ldi		$s4,#0
FFFC0BFE 00106D13			ldi		$t0,#1
                        	.0038:
FFFC0C02 01A65463			bge		$s9,$t0,.0040
FFFC0C06 00000863			bra		.0039
                        	.0040:
FFFC0C0A 41A60633			sub		$s9,$s9,$t0
FFFC0C0E 00138393			add		$s4,$s4,#1
FFFC0C12 FE0008E3			bra		.0038
                        	.0039:	
                        	;    buf[ndx] = digit + '0';
                        	;    ndx++;
                        	;    buf[ndx] = '\0';
FFFC0C16 03038D13			add		$t0,$s4,#'0'
FFFC0C1A 21AE0023			sb		$t0,STRTMP[$t2]
FFFC0C1E 001E0E13			add		$t2,$t2,#1
FFFC0C22 200E0023			sb		$x0,STRTMP[$t2]
                        	;	// Now pad the number on the left or right as requested.
                        	.prt:
                        	;    // pad left
                        	;    if (width > 0) {
                        	;        if (ndx < width) {
                        	;            for (nn = 39; nn >= width-ndx; nn--)
                        	;                buf[nn] = buf[nn-(width-ndx)];
                        	;            for (; nn >= 0; nn--)
                        	;                buf[nn] = ' ';
                        	;        }
                        	;    }
FFFC0C26 0409C663			blt		$a1,$x0,.0041
FFFC0C2A 04098463			beq		$a1,$x0,.0041
FFFC0C2E 013E4463			blt		$t2,$a1,.0042
FFFC0C32 04000063			bra		.0041
                        	.0042:
FFFC0C36 02706313			ldi		$s3,#39					; s3 = nn
FFFC0C3A 41C98D33			sub		$t0,$a1,$t2			; width-ndx
                        	.0045:
FFFC0C3E 01A35463			bge		$s3,$t0,.0043
FFFC0C42 00000C63			bra		.0044
                        	.0043:
FFFC0C46 41A304B3			sub		$s6,$s3,$t0			; nn-(width-ndx)
FFFC0C4A 20030D83			ldb		$t1,STRTMP[$s3]
FFFC0C4E 21B48023			stb		$t1,STRTMP[$s6]
FFFC0C52 FFF30313			sub		$s3,$s3,#1
FFFC0C56 FE0004E3			bra		.0045
                        	.0044:
FFFC0C5A 02006D13			ldi		$t0,#' '
                        	.0048:
FFFC0C5E 00035463			bge		$s3,$x0,.0046
FFFC0C62 00000863			bra		.0047
                        	.0046:
FFFC0C66 21A30023			stb		$t0,STRTMP[$s3]
FFFC0C6A FFF30313			sub		$s3,$s3,#1
FFFC0C6E FE0008E3			bra		.0048
                        	.0047:
                        	.0041:
                        	;    // pad right
                        	;    if (width < 0) {
                        	;        width = -width;
                        	;        while (ndx < width) {
                        	;            buf[ndx]=' ';
                        	;            ndx++;
                        	;        }
                        	;        buf[ndx]='\0';
                        	;    }
                        	;    return (ndx);
FFFC0C72 0209D063			bge		$a1,$x0,.0050
FFFC0C76 413009B3			sub		$a1,$x0,$a1
FFFC0C7A 02006D13			ldi		$t0,#' '
                        	.0052:
FFFC0C7E 013E5863			bge		$t2,$a1,.0051
FFFC0C82 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0C86 001E0E13			add		$t2,$t2,#1
FFFC0C8A FE000AE3			bra		.0052
                        	.0051:
FFFC0C8E 200E0023			stb		$x0,STRTMP[$t2]
                        	.0050:
FFFC0C92 000E6833			mov		$v0,$t2
FFFC0C96 00008067			ret
                        	
FFFC0C9A 6E490000			align	
                        	
                        	msgInf:
FFFC0C9C 00666E49			db	"Inf",0
                        	msgNan:
FFFC0CA0 006E614E			db	"Nan",0
                        	fltOne:
FFFC0CA4 3F800000			dw		$3F800000					; 1.0
                        	fltTen:
FFFC0CA8 41200000			dw		$41200000					; 10.0
                        	fltMillion:
FFFC0CAC 49742400			dw		$49742400					; 1,000,000
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "cs01Mem.r5a",1
                        	.file "cs01Mem.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	NPAGES	equ		$4300
                        	PAM			equ		$4800
                        	
                        	.file "cs01Mem.r5a",28
                        			code	18 bits
                        			align	4                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	MMUInit:
FFFC0CB0 0F606D13			ldi		$t0,#246				; set number of available pages (10 pages already allocated)
FFFC0CB4 00004637			sw		$t0,NPAGES			
FFFC0CB8 30060613
FFFC0CBC 00060633
FFFC0CC0 01A62023
                        			; Setup PAM
FFFC0CC4 1FF06D13			ldi		$t0,#$1FF				; permanently allocate pages for OS data
FFFC0CC8 00005637			sw		$t0,PAM
FFFC0CCC 80060613
FFFC0CD0 00060633
FFFC0CD4 01A62023
FFFC0CD8 00005637			sw		$x0,PAM+4
FFFC0CDC 80460613
FFFC0CE0 00060633
FFFC0CE4 00062023
FFFC0CE8 00005637			sw		$x0,PAM+8
FFFC0CEC 80860613
FFFC0CF0 00060633
FFFC0CF4 00062023
FFFC0CF8 00005637			sw		$x0,PAM+12
FFFC0CFC 80C60613
FFFC0D00 00060633
FFFC0D04 00062023
FFFC0D08 00005637			sw		$x0,PAM+16
FFFC0D0C 81060613
FFFC0D10 00060633
FFFC0D14 00062023
FFFC0D18 00005637			sw		$x0,PAM+20
FFFC0D1C 81460613
FFFC0D20 00060633
FFFC0D24 00062023
FFFC0D28 00005637			sw		$x0,PAM+24
FFFC0D2C 81860613
FFFC0D30 00060633
FFFC0D34 00062023
FFFC0D38 80000D37			ldi		$t0,#$80000000	; last page is system stack
FFFC0D3C 000D0D13
FFFC0D40 00005637			sw		$t0,PAM+28
FFFC0D44 81C60613
FFFC0D48 00060633
FFFC0D4C 01A62023
FFFC0D50 00006D13			ldi		$t0,#$00
FFFC0D54 00006D93			ldi		$t1,#$000				; regno
FFFC0D58 00001E37			ldi		$t2,#4096				; number of registers to update
FFFC0D5C 000E0E13
FFFC0D60 00006E93			ldi		$t3,#0					; number of pages pre-allocated
                        	.0001:
FFFC0D64 03BD000D			mvmap	$x0,$t0,$t1
FFFC0D68 001D0D13			add		$t0,$t0,#$01
FFFC0D6C 001D8D93			add		$t1,$t1,#$01		; increment page number
FFFC0D70 01DDE463			bltu	$t1,$t3,.0003
FFFC0D74 00006D33			mov		$t0,$x0					; mark pages unallocated
                        	.0003:
FFFC0D78 FFFE0E13			sub		$t2,$t2,#1
FFFC0D7C FE0E14E3			bne		$t2,$x0,.0001
FFFC0D80 0FF06D93			ldi		$t1,#$0FF				; allocate last page for stack
FFFC0D84 0FF06D13			ldi		$t0,#$FF
FFFC0D88 03BD000D			mvmap	$x0,$t0,$t1
                        			; Now setup segment registers
FFFC0D8C 00006D13			ldi		$t0,#$0
FFFC0D90 00706D93			ldi		$t1,#$07				; t1 = value to load RWX=111, base = 0
                        	.0002:
FFFC0D94 01AD800D			mvseg	$x0,$t1,$t0			; move to the segment register identifed by t0
FFFC0D98 001D0D13			add		$t0,$t0,#1			; pick next segment register
FFFC0D9C 010D2E13			slt		$t2,$t0,#16			; 16 segment regs
FFFC0DA0 FE0E1AE3			bne		$t2,$x0,.0002
FFFC0DA4 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Allocate a single page of memory. Available memory is indicated by a bitmmap
                        	; called the PAM for page allocation map.
                        	; There's only eight words to check so an unrolled loop works here.
                        	;
                        	; Modifies:
                        	;		t0,t1,t2
                        	; Returns:
                        	;		v0 = page allocated
                        	;------------------------------------------------------------------------------
                        	;
                        	AllocPage:
FFFC0DA8 FFC70713		sub		$sp,$sp,#4
FFFC0DAC 00172023		sw		$ra,[$sp]
FFFC0DB0 00005637		lw		$t0,PAM
FFFC0DB4 80060613
FFFC0DB8 00060633
FFFC0DBC 00062D03
FFFC0DC0 00000DB7		ldi		$t1,#$FFFFFFFF
FFFC0DC4 FFFD8D93
FFFC0DC8 01BD0E63		beq		$t0,$t1,.chkPam4
FFFC0DCC 178000EF		call	BitIndex
FFFC0DD0 00005637		sw		$t0,PAM
FFFC0DD4 80060613
FFFC0DD8 00060633
FFFC0DDC 01A62023
FFFC0DE0 14000C63		bra		.0001
                        	.chkPam4:
FFFC0DE4 00005637		lw		$t0,PAM+4
FFFC0DE8 80460613
FFFC0DEC 00060633
FFFC0DF0 00062D03
FFFC0DF4 03BD0063		beq		$t0,$t1,.chkPam8
FFFC0DF8 14C000EF		call	BitIndex
FFFC0DFC 00005637		sw		$t0,PAM+4
FFFC0E00 80460613
FFFC0E04 00060633
FFFC0E08 01A62023
FFFC0E0C 02080813		add		$v0,$v0,#32
FFFC0E10 12000463		bra		.0001
                        	.chkPam8:
FFFC0E14 00005637		lw		$t0,PAM+8
FFFC0E18 80860613
FFFC0E1C 00060633
FFFC0E20 00062D03
FFFC0E24 03BD0063		beq		$t0,$t1,.chkPam12
FFFC0E28 11C000EF		call	BitIndex
FFFC0E2C 00005637		sw		$t0,PAM+8
FFFC0E30 80860613
FFFC0E34 00060633
FFFC0E38 01A62023
FFFC0E3C 04080813		add		$v0,$v0,#64
FFFC0E40 0E000C63		bra		.0001
                        	.chkPam12:
FFFC0E44 00005637		lw		$t0,PAM+12
FFFC0E48 80C60613
FFFC0E4C 00060633
FFFC0E50 00062D03
FFFC0E54 03BD0063		beq		$t0,$t1,.chkPam16
FFFC0E58 0EC000EF		call	BitIndex
FFFC0E5C 00005637		sw		$t0,PAM+12
FFFC0E60 80C60613
FFFC0E64 00060633
FFFC0E68 01A62023
FFFC0E6C 06080813		add		$v0,$v0,#96
FFFC0E70 0C000463		bra		.0001
                        	.chkPam16:
FFFC0E74 00005637		lw		$t0,PAM+16
FFFC0E78 81060613
FFFC0E7C 00060633
FFFC0E80 00062D03
FFFC0E84 03BD0063		beq		$t0,$t1,.chkPam20
FFFC0E88 0BC000EF		call	BitIndex
FFFC0E8C 00005637		sw		$t0,PAM+16
FFFC0E90 81060613
FFFC0E94 00060633
FFFC0E98 01A62023
FFFC0E9C 08080813		add		$v0,$v0,#128
FFFC0EA0 08000C63		bra		.0001
                        	.chkPam20:
FFFC0EA4 00005637		lw		$t0,PAM+20
FFFC0EA8 81460613
FFFC0EAC 00060633
FFFC0EB0 00062D03
FFFC0EB4 03BD0063		beq		$t0,$t1,.chkPam24
FFFC0EB8 08C000EF		call	BitIndex
FFFC0EBC 00005637		sw		$t0,PAM+20
FFFC0EC0 81460613
FFFC0EC4 00060633
FFFC0EC8 01A62023
FFFC0ECC 0A080813		add		$v0,$v0,#160
FFFC0ED0 06000463		bra		.0001
                        	.chkPam24:
FFFC0ED4 00005637		lw		$t0,PAM+24
FFFC0ED8 81860613
FFFC0EDC 00060633
FFFC0EE0 00062D03
FFFC0EE4 03BD0063		beq		$t0,$t1,.chkPam28
FFFC0EE8 05C000EF		call	BitIndex
FFFC0EEC 00005637		sw		$t0,PAM+24
FFFC0EF0 81860613
FFFC0EF4 00060633
FFFC0EF8 01A62023
FFFC0EFC 0C080813		add		$v0,$v0,#192
FFFC0F00 02000C63		bra		.0001
                        	.chkPam28:
FFFC0F04 00005637		lw		$t0,PAM+28
FFFC0F08 81C60613
FFFC0F0C 00060633
FFFC0F10 00062D03
FFFC0F14 03BD0063		beq		$t0,$t1,.chkPamDone
FFFC0F18 02C000EF		call	BitIndex
FFFC0F1C 00005637		sw		$t0,PAM+28
FFFC0F20 81C60613
FFFC0F24 00060633
FFFC0F28 01A62023
FFFC0F2C 0E080813		add		$v0,$v0,#224
FFFC0F30 00000463		bra		.0001
                        	.chkPamDone:
FFFC0F34 00006813		ldi		$v0,#0						; no memory available
                        	.0001:
FFFC0F38 00072083		lw		$ra,[$sp]
FFFC0F3C 00470713		add		$sp,$sp,#4
FFFC0F40 00008067		ret
                        	
                        	; Returns:
                        	;		v0 = bit index of allocated page
                        	;
                        	BitIndex:
FFFC0F44 00006813		ldi		$v0,#0
                        	.0001:
FFFC0F48 001D7E13		and		$t2,$t0,#1
FFFC0F4C 000E0E63		beq		$t2,$x0,.foundFree
FFFC0F50 001D5D13		srl		$t0,$t0,#1
FFFC0F54 80000637		or		$t0,$t0,#$80000000	; do a rotate, we know bit = 1
FFFC0F58 00060613
FFFC0F5C 01A66D33
FFFC0F60 00180813		add		$v0,$v0,#1
FFFC0F64 FE0002E3		bra		.0001
                        	.foundFree:
FFFC0F68 001D6D13		or		$t0,$t0,#1					; mark page allocated
FFFC0F6C 00086DB3		mov		$t1,$v0
FFFC0F70 000D8A63		beq		$t1,$x0,.0003
                        	.0004:
FFFC0F74 001D1D13		sll		$t0,$t0,#1					; do a rotate
FFFC0F78 001D6D13		or		$t0,$t0,#1					; we know bit = 1
FFFC0F7C FFFD8D93		sub		$t1,$t1,#1
FFFC0F80 FE0D9AE3		bne		$t1,$x0,.0004
                        	.0003:
FFFC0F84 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = page number to free
                        	; Modifies:
                        	;		v0,v1,t0
                        	;------------------------------------------------------------------------------
                        	
                        	FreePage:
FFFC0F88 0FF06813		ldi		$v0,#255						; last page is permanently allocated to system stack
FFFC0F8C 05097263		bgeu	$a0,$v0,.xit
FFFC0F90 00906813		ldi		$v0,#9
FFFC0F94 03096E63		bltu	$a0,$v0,.xit				; first 9 pages (18kB) allocated permanently to system
FFFC0F98 00595813		srl		$v0,$a0,#5					; v0 = word
FFFC0F9C 01F97893		and		$v1,$a0,#31					; v1 = bit no
FFFC0FA0 00106D13		ldi		$t0,#1							; make a bitmask
FFFC0FA4 011D1D33		sll		$t0,$t0,$v1
FFFC0FA8 FFFD4D13		xor		$t0,$t0,#-1					; invert mask
FFFC0FAC 00005637		lw		$v1,PAM[$v0]
FFFC0FB0 80060613
FFFC0FB4 01060633
FFFC0FB8 00062883
FFFC0FBC 01A8F8B3		and		$v1,$v1,$t0					; clear bit
FFFC0FC0 00005637		sw		$v1,PAM[$v0]				; save PAM word back
FFFC0FC4 80060613
FFFC0FC8 01060633
FFFC0FCC 01162023
                        	.xit:
FFFC0FD0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Find a run of buckets available for mapping virtual to physical addresses.
                        	;
                        	; Parameters:
                        	;		a0 = pid
                        	;		a1 = number of pages required.
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		v0 = starting bucket number (includes ASID), -1 if no run found
                        	;------------------------------------------------------------------------------
                        	
                        	FindRun:
FFFC0FD4 00F97E93		and			$t3,$a0,#$0F			; t3 = pid
FFFC0FD8 008E9E93		sll			$t3,$t3,#8				; shift into usable position
FFFC0FDC 00006D93		ldi			$t1,#0						; t1 = count of consecutive empty buckets
FFFC0FE0 000EEE33		mov			$t2,$t3						; t2 = map entry number
FFFC0FE4 020E6E13		or			$t2,$t2,#OSPAGES	; start looking at page 32 (others are for OS)
FFFC0FE8 0FF06F93		ldi			$t5,#255					; max number of pages - 1
FFFC0FEC 01DFEFB3		or			$t5,$t5,$t3				; t5 = max in ASID
                        	.0001:
FFFC0FF0 03C0080D		mvmap		$v0,$x0,$t2				; get map entry into v0
FFFC0FF4 00080A63		beq			$v0,$x0,.empty0		; is it empty?
FFFC0FF8 001E0E13		add			$t2,$t2,#1
FFFC0FFC FFFE6AE3		bltu		$t2,$t5,.0001
                        	.0002:
FFFC1000 FFF06813		ldi			$v0,#-1						; got here so no run was found
FFFC1004 00008067		ret
                        	.empty0:
FFFC1008 000E6EB3		mov			$t3,$t2						; save first empty bucket
                        	.empty1:
FFFC100C FFFE7AE3		bgeu		$t2,$t5,.0002
FFFC1010 001D8D93		add			$t1,$t1,#1
FFFC1014 013DFC63		bgeu		$t1,$a1,.foundEnough
FFFC1018 001E0E13		add			$t2,$t2,#1				; next bucket
FFFC101C 03C0080D		mvmap		$v0,$x0,$t2				; get map entry
FFFC1020 FE0806E3		beq			$v0,$x0,.empty1
FFFC1024 00006DB3		mov			$t1,$x0						; reset counter
FFFC1028 FC0004E3		bra			.0001							; go back and find another run
                        	.foundEnough:
FFFC102C 000EE833		mov			$v0,$t3						; v0 = start of run
FFFC1030 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = pid
                        	;		a1 = amount of memory to allocate
                        	; Modifies:
                        	;		t0
                        	; Returns:
                        	;		v1 = pointer to allocated memory in virtual address space.
                        	;		v0 = E_Ok for success, E_NotAlloc otherwise
                        	;------------------------------------------------------------------------------
                        	;
                        	Alloc:
FFFC1034 FF070713		sub			$sp,$sp,#16
FFFC1038 00172023		sw			$ra,[$sp]
FFFC103C 00472223		sw			$s1,4[$sp]				; these regs must be saved
FFFC1040 00572423		sw			$s2,8[$sp]
FFFC1044 00672623		sw			$s3,12[$sp]
                        		; First check if there are enough pages available in the system.
FFFC1048 7FF98813		add			$v0,$a1,#2047			; v0 = round memory request
FFFC104C 00B85813		srl			$v0,$v0,#11				; v0 = convert to pages required
FFFC1050 00004637		lw			$t0,NPAGES				; check number of pages available
FFFC1054 30060613
FFFC1058 00060633
FFFC105C 00062D03
FFFC1060 010D7663		bleu		$v0,$t0,.enough
                        	.noRun2:
FFFC1064 00006893		ldi			$v1,#0						; not enough, return null
FFFC1068 06000663		bra			.noRun
                        	.enough:
FFFC106C 00096233		mov			$s1,$a0
FFFC1070 00026933		mov			$a0,$s1
                        		; There are enough pages, but is there a run long enough in map space?
FFFC1074 000862B3		mov			$s2,$v0				; save required # pages
FFFC1078 000869B3		mov			$a1,$v0
FFFC107C F59FF0EF		call		FindRun						; find a run of available slots
FFFC1080 FE0842E3		blt			$v0,$x0,.noRun2
                        		; Now there are enough pages, and a run available, so allocate
FFFC1084 00086233		mov			$s1,$v0						; s1 = start of run
FFFC1088 00004637		lw			$s3,NPAGES				; decrease number of pages available in system
FFFC108C 30060613
FFFC1090 00060633
FFFC1094 00062303
FFFC1098 40530333		sub			$s3,$s3,$s2
FFFC109C 00004637		sw			$s3,NPAGES
FFFC10A0 30060613
FFFC10A4 00060633
FFFC10A8 00662023
FFFC10AC 00086333		mov			$s3,$v0						; s3 = start of run
                        	.0001:
FFFC10B0 0000180D		palloc	$v0								; allocate a page (cheat and use hardware)
                        		;call		AllocPage
FFFC10B4 02080063		beq			$v0,$x0,.noRun
FFFC10B8 0268000D		mvmap		$x0,$v0,$s3				; map the page
FFFC10BC 00130313		add			$s3,$s3,#1				; next bucket
FFFC10C0 FFF28293		sub			$s2,$s2,#1
FFFC10C4 FE0296E3		bne			$s2,$x0,.0001
FFFC10C8 00B21893		sll			$v1,$s1,#11				; v0 = virtual address of allocated mem.
FFFC10CC 00006813		ldi			$v0,#E_Ok
FFFC10D0 00000463		bra			.xit
                        	.noRun:
FFFC10D4 00906813		ldi			$v0,#E_NotAlloc
                        	.xit
FFFC10D8 00072083		lw			$ra,[$sp]					; restore saved regs
FFFC10DC 00472203		lw			s1,4[$sp]
FFFC10E0 00872283		lw			s2,8[$sp]
FFFC10E4 00C72303		lw			s3,12[$sp]
FFFC10E8 01070713		add			$sp,$sp,#16
FFFC10EC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Allocate the stack page for a task. The stack is located at the highest
                        	; virtual address ($7F800).
                        	;
                        	; Parameters:
                        	;		a0 = pid to allocate for
                        	;	Returns:
                        	;		v0 = physical address, 0 if unsuccessful
                        	;		v1 = virtual address, not valid unless successful
                        	;------------------------------------------------------------------------------
                        	;
                        	AllocStack:
                        		; need save ra here if calling AllocPage
FFFC10F0 00891893		sll			$v1,$a0,#8			; 
FFFC10F4 0FF8E893		or			$v1,$v1,#255		; last page of memory is for stack
FFFC10F8 0310080D		mvmap		$v0,$x0,$v1			; check if stack already allocated
FFFC10FC 00081863		bne			$v0,$x0,.0001
FFFC1100 0000180D		palloc	$v0							; allocate a page
                        		;call		AllocPage
FFFC1104 00080A63		beq			$v0,$x0,.xit		; success?
FFFC1108 0318000D		mvmap		$x0,$v0,$v1
                        	.0001:
FFFC110C 0FF8F893		and			$v1,$v1,#255
FFFC1110 00B81813		sll			$v0,$v0,#11			; convert pages to addresses
FFFC1114 00B89893		sll			$v1,$v1,#11
                        	.xit:
FFFC1118 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; This routine will de-allocate all the pages associated with a task including
                        	; the stack.
                        	;
                        	; Parameters:
                        	;		a0 = pid to free memory for
                        	;	Modifies:
                        	;		a0,t0,t1,t3,t4
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	FreeAll:
                        		; need save ra if calling FreePage
FFFC111C 00006E93		ldi			$t3,#0
FFFC1120 00891F13		sll			$t4,$a0,#8
                        	.nxt:
FFFC1124 100EAD93		slt			$t1,$t3,#256		; number of buckets to check
FFFC1128 040D8A63		beq			$t1,$x0,.0001
FFFC112C 00001637		and			$t4,$t4,#$F00
FFFC1130 F0060613
FFFC1134 01E67F33
FFFC1138 01DF6F33		or			$t4,$t4,$t3			; combine pid and bucket number
FFFC113C 00006D13		ldi			$t0,#0					; new page number to set (indicates free)
FFFC1140 03ED0D0D		mvmap		$t0,$t0,$t4			; get page mapping and set to zero
FFFC1144 001E8E93		add			$t3,$t3,#1			; advance to next bucket
FFFC1148 0FFD7D13		and			$t0,$t0,#255		; pages are 1-255
FFFC114C FC0D0CE3		beq			$t0,$x0,.nxt		; 0 = no map in this bucket
FFFC1150 020D100D		pfree		$t0							; free the page
                        		;mov			$a0,$t0
                        		;call		FreePage
FFFC1154 00004637		lw			$t0,NPAGES			; update the number of available pages
FFFC1158 30060613
FFFC115C 00060633
FFFC1160 00062D03
FFFC1164 001D0D13		add			$t0,$t0,#1
FFFC1168 00004637		sw			$t0,NPAGES
FFFC116C 30060613
FFFC1170 00060633
FFFC1174 01A62023
FFFC1178 FA0006E3		bra			.nxt
                        	.0001:
FFFC117C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Convert a virtual address to a physical one
                        	;
                        	; Parameters:
                        	;		a0 = virtual address to convert
                        	; Modifies:
                        	;		t0
                        	; Returns:
                        	;		v0 = physcial address
                        	;------------------------------------------------------------------------------
                        	
                        	VirtToPhys:
FFFC1180 02094663		blt		$a0,$x0,.notMapped
FFFC1184 00B95D13		srl		$t0,$a0,#11					; convert virt to page
                        		
FFFC1188 18101873		csrrw	v0,#$181,x0
FFFC118C 00F87813		and		v0,v0,#15
FFFC1190 00881813	sll		$v0,$v0,#8
FFFC1194 01A86833		or		$v0,$v0,$t0					; and in tid
FFFC1198 0300080D		mvmap	$v0,$x0,$v0					; get the translation
FFFC119C 00B81813		sll		$v0,$v0,#11					; convert page to address
FFFC11A0 7FF97D13		and		$t0,$a0,#$7FF				; insert LSB's
FFFC11A4 01A86833		or		$v0,$v0,$t0
FFFC11A8 00008067		ret
                        	.notMapped:
FFFC11AC 00096833		mov		$v0,$a0
FFFC11B0 00008067		ret
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/serial.r5a",1
                        	.file "../fmtk/serial.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	SerRcvBuf		EQU		$9000
                        	SerXmitBuf	EQU		$9400
                        	SerHeadRcv	EQU		$9800
                        	SerTailRcv	EQU		$9804
                        	SerHeadXmit	EQU		$9808
                        	SerTailXmit	EQU		$980C
                        	SerRcvXon		EQU		$9810
                        	SerRcvXoff	EQU		$9811
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
                        	.file "../fmtk/serial.r5a",38
                        		code
FFFC11B4 00000000		align	
                        	
                        	SerialFuncTbl:
FFFC11B8 00000000		dw		0							; no operation
FFFC11BC 00000000		dw		0							; setup
FFFC11C0 00000000		dw		0							; initialize
FFFC11C4 00000000		dw		0							; status
FFFC11C8 00000000		dw		0							; media check
FFFC11CC 00000000		dw		0							; build BPB
FFFC11D0 00000000		dw		0							; open
FFFC11D4 00000000		dw		0							; close
FFFC11D8 FFFC1394		dw		SerialGetChar	; get char
FFFC11DC FFFC1464		dw		SerialPeekChar
FFFC11E0 00000000		dw		0							; get char direct
FFFC11E4 FFFC14CC		dw		SerialPeekCharDirect	; peek char direct
FFFC11E8 00000000		dw		0							; input status
FFFC11EC FFFC1528		dw		SerialPutChar
FFFC11F0 00000000		dw		0							; reserved
FFFC11F4 00000000		dw		0							; set position
FFFC11F8 00000000		dw		0							; read block
FFFC11FC 00000000		dw		0							; write block
FFFC1200 00000000		dw		0							; verify block
FFFC1204 00000000		dw		0							; output status
FFFC1208 00000000		dw		0							; flush input
FFFC120C 00000000		dw		0							; flush output
FFFC1210 FFFC15E4		dw		SerialIRQ			; IRQ routine
FFFC1214 00000000		dw		0							; Is removable
FFFC1218 00000000		dw		0							; ioctrl read
FFFC121C 00000000		dw		0							; ioctrl write
FFFC1220 00000000		dw		0							; output until busy
FFFC1224 00000000		dw		0							; 27
FFFC1228 00000000		dw		0
FFFC122C 00000000		dw		0
FFFC1230 00000000		dw		0
FFFC1234 00000000		dw		0							; 31
                        	
                        	MAX_DEV_OP			EQU		31
                        	
                        	;------------------------------------------------------------------------------
                        	; Initialize serial port.
                        	;
                        	; Modifies:
                        	;		$t0
                        	;------------------------------------------------------------------------------
                        	
                        	SerialInit:
FFFC1238 FFC70713		sub		$sp,$sp,#4
FFFC123C 00172023		sw		$ra,[$sp]
FFFC1240 00506913		ldi		$a0,#5							; serial device
FFFC1244 FFFC19B7		ldi		$a1,#SerialFuncTbl
FFFC1248 1B898993
FFFC124C 281010EF		call	CopyDevFuncTbl
FFFC1250 0000A637		sw		$x0,SerHeadRcv
FFFC1254 80060613
FFFC1258 00060633
FFFC125C 00062023
FFFC1260 0000A637		sw		$x0,SerTailRcv
FFFC1264 80460613
FFFC1268 00060633
FFFC126C 00062023
FFFC1270 0000A637		sw		$x0,SerHeadXmit
FFFC1274 80860613
FFFC1278 00060633
FFFC127C 00062023
FFFC1280 0000A637		sw		$x0,SerTailXmit
FFFC1284 80C60613
FFFC1288 00060633
FFFC128C 00062023
FFFC1290 0000A637		sb		$x0,SerRcvXon
FFFC1294 81060613
FFFC1298 00060633
FFFC129C 00060023
FFFC12A0 0000A637		sb		$x0,SerRcvXoff
FFFC12A4 81160613
FFFC12A8 00060633
FFFC12AC 00060023
FFFC12B0 00906D13		ldi		$t0,#$09						; dtr,rts active, rxint enabled, no parity
FFFC12B4 FFDC1637		sw		$t0,UART+8
FFFC12B8 A0860613
FFFC12BC 00060633
FFFC12C0 01A62023
FFFC12C4 00060D37		ldi		$t0,#$0006001E			; reset the fifo's
FFFC12C8 01ED0D13
FFFC12CC FFDC1637		sw		$t0,UART+12
FFFC12D0 A0C60613
FFFC12D4 00060633
FFFC12D8 01A62023
FFFC12DC 01E06D13		ldi		$t0,#$0000001E			; baud 9600, 1 stop bit, 8 bit, internal baud gen
FFFC12E0 FFDC1637		sw		$t0,UART+12
FFFC12E4 A0C60613
FFFC12E8 00060633
FFFC12EC 01A62023
FFFC12F0 00072083		lw		$ra,[$sp]
FFFC12F4 00470713		add		$sp,$sp,#4
FFFC12F8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	SerialServiceInit:
FFFC12FC 00106913		ldi		$a0,#1			; start task
FFFC1300 40006993		ldi		$a1,#1024		; memory required
FFFC1304 FFFC1A37		ldi		$a2,#SerialService
FFFC1308 314A0A13
FFFC130C 00000073		ecall
FFFC1310 00008067		ret
                        	SerialService:
FFFC1314 DE870713		sub		$sp,$sp,#512+24
FFFC1318 00E06913		ldi		$a0,#14			; get current tid
FFFC131C 00000073		ecall
FFFC1320 20470A13		add		$a2,$sp,#516
FFFC1324 000869B3		mov		$a1,$v0
FFFC1328 00606913		ldi		$a0,#6			; alloc mailbox
FFFC132C 00000073		ecall
                        	
                        	SerialServiceLoop:
FFFC1330 00A06913		ldi		$a0,#10			; waitmsg
FFFC1334 20470993		add		$a1,$sp,#516
FFFC1338 20870A13		add		$a2,$sp,#520
FFFC133C 20C70A93		add		$a3,$sp,#524
FFFC1340 21070B13		add		$a4,$sp,#528
FFFC1344 FFF06B93		ldi		$a5,#-1
FFFC1348 00000073		ecall
                        	
FFFC134C 00072D03		lw		$t0,[$sp]
FFFC1350 01FD7D13		and		$t0,$t0,#31
FFFC1354 001D1D13		sll		$t0,$t0,#1
FFFC1358 FFFC1637		lw		$t0,SerialFuncTbl[$t0]
FFFC135C 1B860613
FFFC1360 01A60633
FFFC1364 00062D03
FFFC1368 000D0067		jmp		[$t0]
                        	
                        	SerialFinishCmd:
FFFC136C 00C72983		lw		$a1,12[$sp]		; reply mbx
FFFC1370 00198993		add		$a1,$a1,#1		; -1 = no reply requested
FFFC1374 01298E63		beq		$a1,$a0,.0001
FFFC1378 FFF98993		sub		$a1,$a1,#1
FFFC137C 00906913		ldi		$a0,#9				; sendmsg
FFFC1380 FFF06A13		ldi		$a2,#-1
FFFC1384 FFF06A93		ldi		$a3,#-1
FFFC1388 FFF06B13		ldi		$a4,#-1
FFFC138C 00000073		ecall
                        	.0001:
FFFC1390 FA1FF06F		jmp		SerialServiceLoop
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialGetChar
                        	;
                        	; Check the serial port buffer to see if there's a char available. If there's
                        	; a char available then return it. If the buffer is almost empty then send an
                        	; XON.
                        	;
                        	; Stack Space:
                        	;		3 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$v0 = character or -1
                        	;------------------------------------------------------------------------------
                        	
                        	SerialGetChar:
FFFC1394 FF470713			sub		$sp,$sp,#12
FFFC1398 00172023			sw		$ra,[$sp]
FFFC139C 01172223			sw		$v1,4[$sp]
FFFC13A0 00472423			sw		$s1,8[$sp]
FFFC13A4 0000A637			lb		$s1,SerRcvXon				; skip sending XON if already sent
FFFC13A8 81060613
FFFC13AC 00060633
FFFC13B0 00060203
FFFC13B4 3000F273			csrrc	$s1,#$300,#1				; disable interrupts
FFFC13B8 04021263			bne		$s1,$x0,.0002
FFFC13BC 1EC000EF			call	SerialRcvCount			; check number of chars in receive buffer
FFFC13C0 00882813			slt		$v0,$v0,#8					; less than 8?
FFFC13C4 02080C63			beq		$v0,$x0,.0002
FFFC13C8 01106813			ldi		$v0,#XON						; if <8 send an XON
FFFC13CC 0000A637			sb		$x0,SerRcvXoff			; clear XOFF status
FFFC13D0 81160613
FFFC13D4 00060633
FFFC13D8 00060023
FFFC13DC 0000A637			sb		$v0,SerRcvXon				; flag so we don't send it multiple times
FFFC13E0 81060613
FFFC13E4 00060633
FFFC13E8 01060023
FFFC13EC FFDC1637			sb		$v0,UART+UART_TRB
FFFC13F0 A0060613
FFFC13F4 00060633
FFFC13F8 01060023
                        	.0002:
FFFC13FC 0000A637			lbu		$v1,SerHeadRcv			; check if anything is in buffer
FFFC1400 80060613
FFFC1404 00060633
FFFC1408 00064883
FFFC140C 0000A637			lbu		$v0,SerTailRcv
FFFC1410 80460613
FFFC1414 00060633
FFFC1418 00064803
FFFC141C 03180663			beq		$v0,$v1,.noChars		; no?
FFFC1420 00009637			lb		$v0,SerRcvBuf[$v1]	; get byte from buffer
FFFC1424 00060613
FFFC1428 01160633
FFFC142C 00060803
FFFC1430 00188893			add		$v1,$v1,#1					; update head index
FFFC1434 0000A637			sb		$v1,SerHeadRcv				
FFFC1438 80060613
FFFC143C 00060633
FFFC1440 01160023
FFFC1444 00000463			bra		.xit
                        	.noChars:
                        	.0001:
FFFC1448 FFF06813			ldi		$v0,#-1
                        	.xit
FFFC144C 30021073			csrrw	$x0,#$300,$s1				; restore interrupts
FFFC1450 00072083			lw		$ra,[$sp]
FFFC1454 00472883			lw		$v1,4[$sp]
FFFC1458 00872203			lw		$s1,8[$sp]
FFFC145C 00C70713			add		$sp,$sp,#12
FFFC1460 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPeekChar
                        	;
                        	; Check the serial port buffer to see if there's a char available. If there's
                        	; a char available then return it. But don't update the buffer indexes. No need
                        	; to send an XON here.
                        	;
                        	; Stack Space:
                        	;		3 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$v0 = character or -1
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPeekChar:
FFFC1464 FF470713			sub		$sp,$sp,#12
FFFC1468 00172023			sw		$ra,[$sp]
FFFC146C 01172223			sw		$v1,4[$sp]
FFFC1470 00472423			sw		$s1,8[$sp]
FFFC1474 3000F273			csrrc	$s1,#$300,#1				; disable interrupts
FFFC1478 0000A637			lbu		$v1,SerHeadRcv			; check if anything is in buffer
FFFC147C 80060613
FFFC1480 00060633
FFFC1484 00064883
FFFC1488 0000A637			lbu		$v0,SerTailRcv
FFFC148C 80460613
FFFC1490 00060633
FFFC1494 00064803
FFFC1498 01180C63			beq		$v0,$v1,.noChars		; no?
FFFC149C 00009637			lb		$v0,SerRcvBuf[$v1]	; get byte from buffer
FFFC14A0 00060613
FFFC14A4 01160633
FFFC14A8 00060803
FFFC14AC 00000463			bra		.xit
                        	.noChars:
                        	.0001:
FFFC14B0 FFF06813			ldi		$v0,#-1
                        	.xit
FFFC14B4 30021073			csrrw	$x0,#$300,$s1				; restore interrupts
FFFC14B8 00072083			lw		$ra,[$sp]
FFFC14BC 00472883			lw		$v1,4[$sp]
FFFC14C0 00872203			lw		$s1,8[$sp]
FFFC14C4 00C70713			add		$sp,$sp,#12
FFFC14C8 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPeekChar
                        	;		Get a character directly from the I/O port. This bypasses the input
                        	; buffer.
                        	;
                        	; Stack Space:
                        	;		3 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$v0 = character or -1
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPeekCharDirect:
FFFC14CC FF470713			sub		$sp,$sp,#12
FFFC14D0 00172023			sw		$ra,[$sp]
FFFC14D4 01172223			sw		$v1,4[$sp]
FFFC14D8 00472423			sw		$s1,8[$sp]
FFFC14DC 3000F273			csrrc	$s1,#$300,#1				; disable interrupts
FFFC14E0 FFDC1637			lb		$v0,UART+UART_STAT
FFFC14E4 A0460613
FFFC14E8 00060633
FFFC14EC 00060803
FFFC14F0 00887813			and		$v0,$v0,#8					; look for Rx not empty
FFFC14F4 00080C63			beq		$v0,$x0,.0001
FFFC14F8 FFDC1637			lb		$v0,UART+UART_TRB
FFFC14FC A0060613
FFFC1500 00060633
FFFC1504 00060803
FFFC1508 00000463			bra		.xit
                        	.0001:
FFFC150C FFF06813			ldi		$v0,#-1
                        	.xit
FFFC1510 30021073			csrrw	$x0,#$300,$s1				; restore interrupts
FFFC1514 00072083			lw		$ra,[$sp]
FFFC1518 00472883			lw		$v1,4[$sp]
FFFC151C 00872203			lw		$s1,8[$sp]
FFFC1520 00C70713			add		$sp,$sp,#12
FFFC1524 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPutChar
                        	;    Put a character to the serial transmitter. This routine blocks until the
                        	; transmitter is empty. The routine will attempt to transmit the char up to 
                        	; 10 times. If it still can't transmit the char then sleep is called and the
                        	; task is put to sleep for a tick. When it wakes up the routine continues to
                        	; try and send a character.
                        	;
                        	; Stack Space
                        	;		5 words
                        	; Parameters:
                        	;		$a3 = character to put
                        	; Modifies:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPutChar:
FFFC1528 FF470713		sub		$sp,$sp,#12
FFFC152C 01072023		sw		$v0,[$sp]
FFFC1530 00172223		sw		$ra,4[$sp]
FFFC1534 01172423		sw		$v1,8[$sp]
                        	.0002:
FFFC1538 FFF06893		ldi		$v1,#-1
                        	.0001:
FFFC153C FFF88893		sub		$v1,$v1,#1
FFFC1540 04088063		beq		$v1,$x0,.goSleep
FFFC1544 FFDC1637		lb		$v0,UART+UART_STAT	; wait until the uart indicates tx empty
FFFC1548 A0460613
FFFC154C 00060633
FFFC1550 00060803
FFFC1554 01087813		and		$v0,$v0,#16					; bit #4 of the status reg
FFFC1558 FE0802E3		beq		$v0,$x0,.0001				; branch if transmitter is not empty
FFFC155C FFDC1637		sb		$a3,UART+UART_TRB		; send the byte
FFFC1560 A0060613
FFFC1564 00060633
FFFC1568 01560023
FFFC156C 00072803		lw		$v0,[$sp]
FFFC1570 00472083		lw		$ra,4[$sp]
FFFC1574 00872883		lw		$v1,8[$sp]
FFFC1578 00C70713		add		$sp,$sp,#12
FFFC157C 00008067		ret
                        	.goSleep:
FFFC1580 FF870713		sub		$sp,$sp,#8
FFFC1584 01272023		sw		a0,[$sp]
FFFC1588 01372223		sw		a1,4[$sp]
FFFC158C 00506913		ldi		a0,#5								; sleep function
FFFC1590 00106993		ldi		a1,#1								; 1 tick
FFFC1594 00000073		ecall
FFFC1598 00072903		lw		a0,[$sp]
FFFC159C 00472983		lw		a1,4[$sp]
FFFC15A0 00870713		add		$sp,$sp,#8
FFFC15A4 F8000AE3		bra		.0002
                        	
                        	;------------------------------------------------------------------------------
                        	; Calculate number of character in input buffer
                        	;------------------------------------------------------------------------------
                        	
                        	SerialRcvCount:
FFFC15A8 0000A637		lbu		$v0,SerTailRcv	; v0 = tail index
FFFC15AC 80460613
FFFC15B0 00060633
FFFC15B4 00064803
FFFC15B8 0000A637		lbu		$v1,SerHeadRcv	; v1 = head index
FFFC15BC 80060613
FFFC15C0 00060633
FFFC15C4 00064883
FFFC15C8 41180D33		sub		$t0,$v0,$v1
FFFC15CC 000D5863		bge		$t0,$x0,.xit
FFFC15D0 10006D13		ldi		$t0,#256
FFFC15D4 411D0D33		sub		$t0,$t0,$v1
FFFC15D8 010D0D33		add		$t0,$t0,$v0
                        	.xit:
FFFC15DC 000D6833		mov		$v0,$t0
FFFC15E0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	SerialIRQ:
                        	.nxtByte:
FFFC15E4 00897D13		and		$t0,$a0,#$08				; bit 3 = rx full
FFFC15E8 0C0D0063		beq		$t0,$x0,.notRxInt
FFFC15EC FFDC1637		lw		$a1,UART+UART_TRB		; get data from Rx buffer to clear interrupt
FFFC15F0 A0060613
FFFC15F4 00060633
FFFC15F8 00062983
FFFC15FC 0000A637		lbu		$t2,SerHeadRcv			; get buffer indexes
FFFC1600 80060613
FFFC1604 00060633
FFFC1608 00064E03
FFFC160C 0000A637		lbu		$t3,SerTailRcv
FFFC1610 80460613
FFFC1614 00060633
FFFC1618 00064E83
FFFC161C 001E8E93		add		$t3,$t3,#1					; see if buffer full
FFFC1620 0FFEFE93		and		$t3,$t3,#255
FFFC1624 09DE0263		beq		$t2,$t3,.rxFull
FFFC1628 0000A637		sb		$t3,SerTailRcv			; update tail pointer
FFFC162C 80460613
FFFC1630 00060633
FFFC1634 01D60023
FFFC1638 FFFE8E93		sub		$t3,$t3,#1
FFFC163C 0FFEFE13		and		$t2,$t3,#255
FFFC1640 00009637		sb		$a1,SerRcvBuf[$t2]	; store recieved byte in buffer
FFFC1644 00060613
FFFC1648 01C60633
FFFC164C 01360023
FFFC1650 0000A637		lb		$v0,SerRcvXoff			; check if xoff already sent
FFFC1654 81160613
FFFC1658 00060633
FFFC165C 00060803
FFFC1660 02081A63		bne		$v0,$x0,.0001
FFFC1664 F45FF0EF		call	SerialRcvCount			; if more than 240 chars in buffer
FFFC1668 0F082813		slt		$v0,$v0,#240				; send an XOFF
FFFC166C 02081463		bne		$v0,$x0,.0001
FFFC1670 01306913		ldi		$a0,#XOFF
FFFC1674 0000A637		sb		$x0,SerRcvXon				; clear XON status
FFFC1678 81060613
FFFC167C 00060633
FFFC1680 00060023
FFFC1684 0000A637		sb		$a0,SerRcvXoff			; set XOFF status
FFFC1688 81160613
FFFC168C 00060633
FFFC1690 01260023
                        		sb		UART+UART_TRB
                        	.0001:
FFFC1694 FFDC1637		lw		$a0,UART+UART_STAT	; check the status for another byte
FFFC1698 A0460613
FFFC169C 00060633
FFFC16A0 00062903
FFFC16A4 F40000E3		bra		.nxtByte
                        	;	ldi		$a0,#$0B						; dtr,rts active, rxint disabled, no parity
                        	;	sw		$a0,UART+UART_CMD
                        	.rxFull:
                        	.notRxInt:
FFFC16A8 10000073		eret
                        	
                        	nmeSerial:
FFFC16AC 69726553		db		"Serial",0
FFFC16B0 00006C61
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/via.r5a",1
                        	.file "../fmtk/via.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
FFFC16B3 00000000		align	
FFFC16B7 00000000
                        	
                        	ViaFuncTbl:
FFFC16B8 00000000		dw		0							; no operation
FFFC16BC 00000000		dw		0							; setup
FFFC16C0 00000000		dw		0							; initialize
FFFC16C4 00000000		dw		0							; status
FFFC16C8 00000000		dw		0							; media check
FFFC16CC 00000000		dw		0							; build BPB
FFFC16D0 00000000		dw		0							; open
FFFC16D4 00000000		dw		0							; close
FFFC16D8 00000000		dw		0							; get char
FFFC16DC 00000000		dw		0							; Peek char
FFFC16E0 00000000		dw		0							; get char direct
FFFC16E4 00000000		dw		0							; peek char direct
FFFC16E8 00000000		dw		0							; input status
FFFC16EC 00000000		dw		0							; Put char
FFFC16F0 00000000		dw		0							; reserved
FFFC16F4 00000000		dw		0							; set position
FFFC16F8 00000000		dw		0							; read block
FFFC16FC 00000000		dw		0							; write block
FFFC1700 00000000		dw		0							; verify block
FFFC1704 00000000		dw		0							; output status
FFFC1708 00000000		dw		0							; flush input
FFFC170C 00000000		dw		0							; flush output
FFFC1710 FFFC1794		dw		ViaIRQ				; IRQ routine
FFFC1714 00000000		dw		0							; Is removable
FFFC1718 00000000		dw		0							; ioctrl read
FFFC171C 00000000		dw		0							; ioctrl write
FFFC1720 00000000		dw		0							; output until busy
FFFC1724 00000000		dw		0							; 27
FFFC1728 00000000		dw		0
FFFC172C 00000000		dw		0
FFFC1730 00000000		dw		0
FFFC1734 00000000		dw		0							; 31
                        	
                        	;------------------------------------------------------------------------------
                        	; ViaInit
                        	;
                        	; Initialize the versatile interface adapter.
                        	;------------------------------------------------------------------------------
                        	
                        	ViaInit:
FFFC1738 FFC70713		sub		$sp,$sp,#4
FFFC173C 00172023		sw		$ra,[$sp]
FFFC1740 00F06913		ldi		$a0,#15							; VIA device
FFFC1744 FFFC19B7		ldi		$a1,#ViaFuncTbl
FFFC1748 6B898993
FFFC174C 580010EF		call	CopyDevFuncTbl
                        		; Initialize port A low order eight bits as output, the remaining bits as
                        		; input.
FFFC1750 FFDC0DB7		ldi		$t1,VIA
FFFC1754 600D8D93
FFFC1758 0FF06D13		ldi		$t0,#$000000FF
FFFC175C 01ADA623		sw		$t0,VIA_DDRA[$t1]
FFFC1760 00106D13		ldi		$t0,#1							; select timer 3 access
FFFC1764 03AD88A3		sb		$t0,VIA_PCR+1[$t1]
FFFC1768 01F06D13		ldi		$t0,#$1F
FFFC176C 03AD86A3		sb		$t0,VIA_ACR+1[$t1]		; set timer 3 mode, timer 1/2 = 64 bit
FFFC1770 0016ED37		ldi		$t0,#$0016E360			;	divider value for 33.333Hz (30 ms)
FFFC1774 360D0D13
FFFC1778 01ADA823		sw		$t0,VIA_T1CL[$t1]
FFFC177C 000DAA23		sw		$x0,VIA_T1CH[$t1]		; trigger transfer to count registers
FFFC1780 18006D13		ldi		$t0,#$180						; emable timer3 interrupts
FFFC1784 03ADAC23		sw		$t0,VIA_IER[$t1]
FFFC1788 00072083		lw		$ra,[$sp]
FFFC178C 00470713		add		$sp,$sp,#4
FFFC1790 00008067		ret
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	ViaIRQ:
                        		; Was it the VIA that caused the interrupt?
FFFC1794 FFDC0637		lb		$t0,VIA+VIA_IFR
FFFC1798 63460613
FFFC179C 00060633
FFFC17A0 00060D03
FFFC17A4 040D5663		bge		$t0,$x0,.0003			; no
FFFC17A8 FFDC0637		lw		$t0,VIA+VIA_T1CL	; yes, clear interrupt
FFFC17AC 61060613
FFFC17B0 00060633
FFFC17B4 00062D03
FFFC17B8 00004637		lw		$t0,milliseconds
FFFC17BC 20860613
FFFC17C0 00060633
FFFC17C4 00062D03
FFFC17C8 01ED0D13		add		$t0,$t0,#30
FFFC17CC 00004637		sw		$t0,milliseconds
FFFC17D0 20860613
FFFC17D4 00060633
FFFC17D8 01A62023
FFFC17DC 00004637		sw		$t0,switchflag
FFFC17E0 20060613
FFFC17E4 00060633
FFFC17E8 01A62023
FFFC17EC 600000EF		call	FMTK_SchedulerIRQ
                        	.0003:
FFFC17F0 10000073		eret
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/task.r5a",1
                        	.file "../fmtk/task.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	QNDX		EQU		$4304
                        	READYQ	EQU		$4308
                        	PIDMAP	EQU		$4310
                        	missed_ticks	equ		$4320
                        	TimeoutList		equ		$4328
                        	Tick		EQU		$4330
                        	SysSema	EQU		$4340
                        	RDYQ0		EQU		$4400
                        	RDYQ1		EQU		$4500
                        	RDYQ2		EQU		$4600
                        	RDYQ3		EQU		$4700
                        	msgs		EQU		$4800
                        	mbxs		EQU		$8800
                        	mbxs_end	EQU	$8A00
                        	FreeMsg	EQU		$8C00
                        	
                        	.file "../fmtk/task.r5a",41
                        		code
                        		align	2                        	
                        	OSCallTbl:
FFFC17F4 201C016F		dh		FMTK_Initialize					; 0
FFFC17F6 20E0201C		dh		FMTK_StartTask					; 1
FFFC17F8 20EC20E0		dh		FMTK_ExitTask
FFFC17FA 017320EC		dh		FMTK_KillTask
FFFC17FC 1D180173		dh		FMTK_SetTaskPriority
FFFC17FE 213C1D18		dh		FMTK_Sleep							; 5
FFFC1800 21A4213C		dh		FMTK_AllocMbx
FFFC1802 017721A4		dh		FMTK_FreeMbx
FFFC1804 22240177		dh		FMTK_PostMsg
FFFC1806 23D02224		dh		FMTK_SendMsg
FFFC1808 23C423D0		dh		FMTK_WaitMsg						; 10
FFFC180A 017B23C4		dh		FMTK_PeekMsg
FFFC180C 0000017B		dh		FMTK_StartApp
FFFC180E 19600000		dh		0												; 13
FFFC1810 017D1960		dh		FMTK_GetCurrentTid
FFFC1812 0000017D		dh		DumpReadyQueue
FFFC1814 00000000		dh		0
FFFC1816 00000000		dh		0
FFFC1818 00000000		dh		0
FFFC181A 2AB40000		dh		0
FFFC181C 2B3C2AB4		dh		FMTK_HasIOFocus					; 20
FFFC181E 2BD42B3C		dh		FMTK_SwitchIOFocus			; 21
FFFC1820 2BE02BD4		dh		FMTK_ReleaseIOFocus			; 22
FFFC1822 2B482BE0		dh		FMTK_ForceReleaseIOFocus	; 23
FFFC1824 00002B48		dh		FMTK_RequestIOFocus			; 24
FFFC1826 2C7C0000		dh		0
FFFC1828 00002C7C		dh		FMTK_IO									; 26
                        	
                        	qToChk:
FFFC182A 02000000		db	0,0,0,2,0,0,4,2
FFFC182E 02040000
FFFC1832 02060000		db	0,0,6,2,0,0,4,2
FFFC1836 02040000
FFFC183A 02000000		db	0,0,0,2,0,0,4,2
FFFC183E 02040000
FFFC1842 02060000		db	0,0,6,2,0,0,4,2
FFFC1846 02040000
                        	
FFFC184A 46370000		align	
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FMTKInit:
FFFC184C 00004637		sw		$x0,QNDX
FFFC1850 30460613
FFFC1854 00060633
FFFC1858 00062023
FFFC185C 00004637		sw		$x0,PIDMAP
FFFC1860 31060613
FFFC1864 00060633
FFFC1868 00062023
FFFC186C 00004637		sw		$x0,missed_ticks
FFFC1870 32060613
FFFC1874 00060633
FFFC1878 00062023
FFFC187C FFF06D13		ldi		$t0,#-1
FFFC1880 00004637		sw		$t0,TimeoutList
FFFC1884 32860613
FFFC1888 00060633
FFFC188C 01A62023
FFFC1890 00004637		sw		$t0,READYQ
FFFC1894 30860613
FFFC1898 00060633
FFFC189C 01A62023
FFFC18A0 00004637		sw		$t0,READYQ+4
FFFC18A4 30C60613
FFFC18A8 00060633
FFFC18AC 01A62023
                        	
FFFC18B0 00009637		sw		$x0,IOFocusTbl
FFFC18B4 C1060613
FFFC18B8 00060633
FFFC18BC 00062023
FFFC18C0 00009637		sw		$t0,IOFocusNdx
FFFC18C4 C0860613
FFFC18C8 00060633
FFFC18CC 01A62023
                        	
                        		; zero out device function table
FFFC18D0 0000AD37		ldi		$t0,#DVF_Base
FFFC18D4 000D0D13
FFFC18D8 40006D93		ldi		$t1,#32*32
                        	.0003:
FFFC18DC 000D2023		sw		$x0,[$t0]
FFFC18E0 004D0D13		add		$t0,$t0,#4
FFFC18E4 FFFD8D93		sub		$t1,$t1,#1
FFFC18E8 FFB04AE3		bgt		$t1,$x0,.0003
                        	
                        		; Initialize mailboxes
FFFC18EC 00009D37		ldi		$t0,#mbxs
FFFC18F0 800D0D13
FFFC18F4 08006D93		ldi		$t1,#4*32
                        	.0001:
FFFC18F8 000D2023		sw		$x0,[$t0]
FFFC18FC 004D0D13		add		$t0,$t0,#4
FFFC1900 FFFD8D93		sub		$t1,$t1,#1
FFFC1904 FFB04AE3		bgt		$t1,$x0,.0001
                        	
                        		; Initialize free message list
FFFC1908 00005D37		ldi		$t0,#msgs
FFFC190C 800D0D13
FFFC1910 00009637		sw		$t0,FreeMsg
FFFC1914 C0060613
FFFC1918 00060633
FFFC191C 01A62023
FFFC1920 00006D93		ldi		$t1,#0
FFFC1924 20006E13		ldi		$t2,#512
                        	.0002:
FFFC1928 001D8D93		add		$t1,$t1,#1
FFFC192C 01BD2023		sw		$t1,MSG_LINK[$t0]
FFFC1930 010D0D13		add		$t0,$t0,#16
FFFC1934 FFFE0E13		sub		$t2,$t2,#1
FFFC1938 FFC048E3		bgt		$t2,$x0,.0002
                        	
                        		; unlock the system semaphore	
                        		
FFFC193C FFF06813		ldi		v0,#-1
FFFC1940 00004637		sw		v0,SysSema
FFFC1944 34060613
FFFC1948 00060633
FFFC194C 01062023
                        	
FFFC1950 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Get the task id for the currently running task.
                        	;
                        	; Returns:
                        	;		v0 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	GetCurrentTid:
FFFC1954 18101873		csrrw	$v0,#$181,$x0				; get current pid
FFFC1958 00F87813		and		$v0,$v0,#15					; mask off extra bits
FFFC195C 00008067		ret
                        	
                        	FMTK_GetCurrentTid:
                        		
FFFC1960 18101873		csrrw	v0,#$181,x0
FFFC1964 00F87813		and		v0,v0,#15
FFFC1968 000868B3	mov		$v1,$v0
FFFC196C 00006813		ldi		$v0,#E_Ok
FFFC1970 0608888D		mtu		$v1,$v1
FFFC1974 0608080D		mtu		$v0,$v0
FFFC1978 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	MapOSPages:
FFFC197C 02006813		ldi			$v0,#OSPAGES	; number of pages pre-mapped
FFFC1980 00006893		ldi			$v1,#0
FFFC1984 00891893		sll			$v1,$a0,#8		; put ASID in proper spot
                        	.nxt:
FFFC1988 0318800D		mvmap		$x0,$v1,$v1
FFFC198C 00188893		add			$v1,$v1,#1
FFFC1990 FFF80813		sub			$v0,$v0,#1
FFFC1994 FF004AE3		bgt			$v0,$x0,.nxt
FFFC1998 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Select the next task to run. The ready queues are searched in a circular
                        	; fashion beginning with the queue identified indirectly by QNDX. There are
                        	; four ready queues to hold tasks of four different priorities. This routine
                        	; dequeues a task from the ready list, then adds it back if it is still ready.
                        	; This takes care of a lot of scenarios. Such as the task no longer being
                        	; ready, or the priority changing.
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		v1, t0, t1, t2, t3, t4
                        	;	Returns:
                        	;		v0 = task id of task to run
                        	;------------------------------------------------------------------------------
                        	
                        	SelectTaskToRun:
FFFC199C FFC70713		sub		$sp,$sp,#4					; stack return address
FFFC19A0 00172023		sw		$ra,[$sp]
                        		; Pick the first queue to check, occasionally the queue
                        		; chosen isn't the highest priority one in order to 
                        		; prevent starvation of lower priority tasks.
FFFC19A4 00004637		lbu		$v1,QNDX						; get index into que check table
FFFC19A8 30460613
FFFC19AC 00060633
FFFC19B0 00064883
FFFC19B4 00188893		add		$v1,$v1,#1					; increment it, and limit
FFFC19B8 01F8F893		and		$v1,$v1,#31
FFFC19BC 00004637		sb		$v1,QNDX						; store back
FFFC19C0 30460613
FFFC19C4 00060633
FFFC19C8 01160023
FFFC19CC FFFC2637		lbu		$v1,qToChk[$v1]			; assume this will be valid
FFFC19D0 82A60613
FFFC19D4 01160633
FFFC19D8 00064883
FFFC19DC 00406E13		ldi		$t2,#4							; 4 queues to check
                        	.nxtQ:
FFFC19E0 00004637		lh		$v0,READYQ[$v1]			; check queue to see if contains any
FFFC19E4 30860613
FFFC19E8 01160633
FFFC19EC 00061803
FFFC19F0 02085063		bge		$v0,$x0,.dq					; yes, go dequeue
                        	.0001:
FFFC19F4 00288893		add		$v1,$v1,#2					; no, advance to next queue
FFFC19F8 0068F893		and		$v1,$v1,#6					; 4 max
FFFC19FC FFFE0E13		sub		$t2,$t2,#1					;
FFFC1A00 FFC040E3		bgt		$t2,$x0,.nxtQ				; go back to check next queue
                        		; Here, nothing else is actually ready to run
                        		; just go back to what we were doing.
                        		
FFFC1A04 18101873		csrrw	v0,#$181,x0
FFFC1A08 00F87813		and		v0,v0,#15
FFFC1A0C 02000E63	bra		.noTask
                        	.dq:
FFFC1A10 00F06E93		ldi		$t3,#MAX_TID				; ensure we have a valid tid
FFFC1A14 010EFE63		bleu	$v0,$t3,.goodTid
                        		; If the tid isn't valid the readyq was screwed up
FFFC1A18 FFF06E93		ldi		$t3,#-1							; indicate queue empty
FFFC1A1C 00004637		sh		$t3,READYQ[$v1]
FFFC1A20 30860613
FFFC1A24 01160633
FFFC1A28 01D61023
FFFC1A2C FC0004E3		bra		.0001								; and try next queue
                        	.goodTid:
FFFC1A30 00A81D93		sll		$t1,$v0,#10
FFFC1A34 2D0D9D03		lh		$t0,TCBNext[$t1]		; update head of ready queue
FFFC1A38 00004637		sh		$t0,READYQ[$v1]
FFFC1A3C 30860613
FFFC1A40 01160633
FFFC1A44 01A61023
                        	.noTask:
FFFC1A48 00072083		lw		$ra,[$sp]						; restore return address
FFFC1A4C 00470713		add		$sp,$sp,#4
FFFC1A50 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Swap from outgoing context to incoming context.
                        	;
                        	; Parameters:
                        	;		a0 = pointer to TCB of outgoing context
                        	;		a1 = pointer to TCB of incoming context
                        	;------------------------------------------------------------------------------
                        	
                        	SwapContext:
                        		; Save outgoing register set in TCB
FFFC1A54 0400810D		mfu		$x2,$x1
FFFC1A58 00292223		sw		$x2,4[$a0]
FFFC1A5C 0401010D		mfu		$x2,$x2
FFFC1A60 00292423		sw		$x2,8[$a0]
FFFC1A64 0401810D		mfu		$x2,$x3
FFFC1A68 00292623		sw		$x2,12[$a0]
FFFC1A6C 0402010D		mfu		$x2,$x4
FFFC1A70 00292823		sw		$x2,16[$a0]
FFFC1A74 0402810D		mfu		$x2,$x5
FFFC1A78 00292A23		sw		$x2,20[$a0]
FFFC1A7C 0403010D		mfu		$x2,$x6
FFFC1A80 00292C23		sw		$x2,24[$a0]
FFFC1A84 0403810D		mfu		$x2,$x7
FFFC1A88 00292E23		sw		$x2,28[$a0]
FFFC1A8C 0404010D		mfu		$x2,$x8
FFFC1A90 02292023		sw		$x2,32[$a0]
FFFC1A94 0404810D		mfu		$x2,$x9
FFFC1A98 02292223		sw		$x2,36[$a0]
FFFC1A9C 0405010D		mfu		$x2,$x10
FFFC1AA0 02292423		sw		$x2,40[$a0]
FFFC1AA4 0405810D		mfu		$x2,$x11
FFFC1AA8 02292623		sw		$x2,44[$a0]
FFFC1AAC 0406010D		mfu		$x2,$x12
FFFC1AB0 02292823		sw		$x2,48[$a0]
FFFC1AB4 0406810D		mfu		$x2,$x13
FFFC1AB8 02292A23		sw		$x2,52[$a0]
FFFC1ABC 0407010D		mfu		$x2,$x14
FFFC1AC0 02292C23		sw		$x2,56[$a0]
FFFC1AC4 0407810D		mfu		$x2,$x15
FFFC1AC8 02292E23		sw		$x2,60[$a0]
FFFC1ACC 0408010D		mfu		$x2,$x16
FFFC1AD0 04292023		sw		$x2,64[$a0]
FFFC1AD4 0408810D		mfu		$x2,$x17
FFFC1AD8 04292223		sw		$x2,68[$a0]
FFFC1ADC 0409010D		mfu		$x2,$x18
FFFC1AE0 04292423		sw		$x2,72[$a0]
FFFC1AE4 0409810D		mfu		$x2,$x19
FFFC1AE8 04292623		sw		$x2,76[$a0]
FFFC1AEC 040A010D		mfu		$x2,$x20
FFFC1AF0 04292823		sw		$x2,80[$a0]
FFFC1AF4 040A810D		mfu		$x2,$x21
FFFC1AF8 04292A23		sw		$x2,84[$a0]
FFFC1AFC 040B010D		mfu		$x2,$x22
FFFC1B00 04292C23		sw		$x2,88[$a0]
FFFC1B04 040B810D		mfu		$x2,$x23
FFFC1B08 04292E23		sw		$x2,92[$a0]
FFFC1B0C 040C010D		mfu		$x2,$x24
FFFC1B10 06292023		sw		$x2,96[$a0]
FFFC1B14 040C810D		mfu		$x2,$x25
FFFC1B18 06292223		sw		$x2,100[$a0]
FFFC1B1C 040D010D		mfu		$x2,$x26
FFFC1B20 06292423		sw		$x2,104[$a0]
FFFC1B24 040D810D		mfu		$x2,$x27
FFFC1B28 06292623		sw		$x2,108[$a0]
FFFC1B2C 040E010D		mfu		$x2,$x28
FFFC1B30 06292823		sw		$x2,112[$a0]
FFFC1B34 040E810D		mfu		$x2,$x29
FFFC1B38 06292A23		sw		$x2,116[$a0]
FFFC1B3C 040F010D		mfu		$x2,$x30
FFFC1B40 06292C23		sw		$x2,120[$a0]
FFFC1B44 040F810D		mfu		$x2,$x31
FFFC1B48 06292E23		sw		$x2,124[$a0]
FFFC1B4C 34101173		csrrw	$x2,#$341,$x0				; save off mepc
FFFC1B50 28292023		sw		$x2,TCBepc[$a0]
                        		; Now save off segment registers
FFFC1B54 00006D93		ldi		$t1,#0
                        	.svseg:
FFFC1B58 01B00D0D		mvseg	$t0,$x0,$t1
FFFC1B5C 002D9113		sll		$x2,$t1,#2
FFFC1B60 01210133		add		$x2,$x2,$a0
FFFC1B64 21A12023		sw		$t0,TCBsegs[$x2]
FFFC1B68 001D8D93		add		$t1,$t1,#1
FFFC1B6C 00FDFD93		and		$t1,$t1,#15
FFFC1B70 FE0D94E3		bne		$t1,$x0,.svseg
                        	
                        		; Switch memory maps
FFFC1B74 00A9D813		srl		$v0,$a1,#10					; convert pointer to tid
FFFC1B78 00F87813		and		$v0,$v0,#$F					; mask to 16 task
FFFC1B7C 181818F3		csrrw	$v1,#$181,$v0				; set ASID
                        		; User map has now been switched
                        	
                        		; Restore segment register set
FFFC1B80 00006D93		ldi		$t1,#0
                        	.rsseg:
FFFC1B84 002D9113		sll		$x2,$t1,#2
FFFC1B88 01310133		add		$x2,$x2,$a1
FFFC1B8C 20012D03		lw		$t0,TCBsegs[$x2]
FFFC1B90 01BD000D		mvseg	$x0,$t0,$t1
FFFC1B94 001D8D93		add		$t1,$t1,#1
FFFC1B98 00FDFD93		and		$t1,$t1,#15
FFFC1B9C FE0D94E3		bne		$t1,$x0,.rsseg
                        	
FFFC1BA0 2809A103		lw		$x2,TCBepc[$a1]			; restore epc
FFFC1BA4 34111073		csrrw	$x0,#$341,$x2
                        		; Restore incoming registers
FFFC1BA8 0049A103		lw		$x2,4[$a1]
FFFC1BAC 0601008D		mtu		$x1,$x2
FFFC1BB0 0089A103		lw		$x2,8[$a1]
FFFC1BB4 0601010D		mtu		$x2,$x2
FFFC1BB8 00C9A103		lw		$x2,12[$a1]
FFFC1BBC 0601018D		mtu		$x3,$x2
FFFC1BC0 0109A103		lw		$x2,16[$a1]
FFFC1BC4 0601020D		mtu		$x4,$x2
FFFC1BC8 0149A103		lw		$x2,20[$a1]
FFFC1BCC 0601028D		mtu		$x5,$x2
FFFC1BD0 0189A103		lw		$x2,24[$a1]
FFFC1BD4 0601030D		mtu		$x6,$x2
FFFC1BD8 01C9A103		lw		$x2,28[$a1]
FFFC1BDC 0601038D		mtu		$x7,$x2
FFFC1BE0 0209A103		lw		$x2,32[$a1]
FFFC1BE4 0601040D		mtu		$x8,$x2
FFFC1BE8 0249A103		lw		$x2,36[$a1]
FFFC1BEC 0601048D		mtu		$x9,$x2
FFFC1BF0 0289A103		lw		$x2,40[$a1]
FFFC1BF4 0601050D		mtu		$x10,$x2
FFFC1BF8 02C9A103		lw		$x2,44[$a1]
FFFC1BFC 0601058D		mtu		$x11,$x2
FFFC1C00 0309A103		lw		$x2,48[$a1]
FFFC1C04 0601060D		mtu		$x12,$x2
FFFC1C08 0349A103		lw		$x2,52[$a1]
FFFC1C0C 0601068D		mtu		$x13,$x2
FFFC1C10 0389A103		lw		$x2,56[$a1]
FFFC1C14 0601070D		mtu		$x14,$x2
FFFC1C18 03C9A103		lw		$x2,60[$a1]
FFFC1C1C 0601078D		mtu		$x15,$x2
FFFC1C20 0409A103		lw		$x2,64[$a1]
FFFC1C24 0601080D		mtu		$x16,$x2
FFFC1C28 0449A103		lw		$x2,68[$a1]
FFFC1C2C 0601088D		mtu		$x17,$x2
FFFC1C30 0489A103		lw		$x2,72[$a1]
FFFC1C34 0601090D		mtu		$x18,$x2
FFFC1C38 04C9A103		lw		$x2,76[$a1]
FFFC1C3C 0601098D		mtu		$x19,$x2
FFFC1C40 0509A103		lw		$x2,80[$a1]
FFFC1C44 06010A0D		mtu		$x20,$x2
FFFC1C48 0549A103		lw		$x2,84[$a1]
FFFC1C4C 06010A8D		mtu		$x21,$x2
FFFC1C50 0589A103		lw		$x2,88[$a1]
FFFC1C54 06010B0D		mtu		$x22,$x2
FFFC1C58 05C9A103		lw		$x2,92[$a1]
FFFC1C5C 06010B8D		mtu		$x23,$x2
FFFC1C60 0609A103		lw		$x2,96[$a1]
FFFC1C64 06010C0D		mtu		$x24,$x2
FFFC1C68 0649A103		lw		$x2,100[$a1]
FFFC1C6C 06010C8D		mtu		$x25,$x2
FFFC1C70 0689A103		lw		$x2,104[$a1]
FFFC1C74 06010D0D		mtu		$x26,$x2
FFFC1C78 06C9A103		lw		$x2,108[$a1]
FFFC1C7C 06010D8D		mtu		$x27,$x2
FFFC1C80 0709A103		lw		$x2,112[$a1]
FFFC1C84 06010E0D		mtu		$x28,$x2
FFFC1C88 0749A103		lw		$x2,116[$a1]
FFFC1C8C 06010E8D		mtu		$x29,$x2
FFFC1C90 0789A103		lw		$x2,120[$a1]
FFFC1C94 06010F0D		mtu		$x30,$x2
FFFC1C98 07C9A103		lw		$x2,124[$a1]
FFFC1C9C 06010F8D		mtu		$x31,$x2
FFFC1CA0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Operating system call dispatcher.
                        	;------------------------------------------------------------------------------
                        	
                        	OSCALL:
FFFC1CA4 00080737		ldi		$sp,#$80000-4		; setup machine mode stack pointer
FFFC1CA8 FFC70713
FFFC1CAC 0409090D		mfu		$a0,$a0
FFFC1CB0 0409898D		mfu		$a1,$a1
FFFC1CB4 040A0A0D		mfu		$a2,$a2
FFFC1CB8 040A8A8D		mfu		$a3,$a3
FFFC1CBC 040B0B0D		mfu		$a4,$a4
FFFC1CC0 040B8B8D		mfu		$a5,$a5
FFFC1CC4 01F97913		and		$a0,$a0,#31
FFFC1CC8 00191913		sll		$a0,$a0,#1
FFFC1CCC FFFC1637		lhu		$t0,OSCallTbl[$a0]
FFFC1CD0 7F460613
FFFC1CD4 01260633
FFFC1CD8 00065D03
FFFC1CDC FFFC0637		or		$t0,$t0,#$FFFC0000
FFFC1CE0 00060613
FFFC1CE4 01A66D33
FFFC1CE8 000D0067		jmp		[$t0]
                        	
                        	;------------------------------------------------------------------------------
                        	; Time accounting.
                        	; Update the length of time the task has been running.
                        	;
                        	; Parameters:
                        	;		s1 = pointer to TCB
                        	; Modifies:
                        	;		t2,t3,t4,t5
                        	;------------------------------------------------------------------------------
                        	
                        	AccountTime:
                        	.again:
                        	;	csrrw	$t3,#$741,$x0					; get high time
                        	;	csrrw	$t2,#$701,$x0					; get low time
                        	;	csrrw	$t4,#$741,$x0
                        	;	bne		$t3,$t4,.again
FFFC1CEC 00004637		lw		$t2,Tick
FFFC1CF0 33060613
FFFC1CF4 00060633
FFFC1CF8 00062E03
FFFC1CFC 2BC22C23		sw		$t2,TCBEndTick[$s1]
FFFC1D00 2B022E83		lw		$t3,TCBStartTick[$s1]
FFFC1D04 41DE0F33		sub		$t4,$t2,$t3						; end - start
FFFC1D08 2C022F83		lw		$t5,TCBTicks[$s1]
FFFC1D0C 01EF8FB3		add		$t5,$t5,$t4						; ticks + (end - start)
FFFC1D10 2DF22023		sw		$t5,TCBTicks[$s1]
FFFC1D14 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Sleep for a number of ticks. Tick interval determined by the VIA timer #3.
                        	; Passing a time of zero or less causes the function to return right away.
                        	;
                        	; Parameters:
                        	;		a1 = length of time to sleep (must be >= 0)
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_Sleep:
FFFC1D18 0C09C863		blt		$a1,$x0,ERETx
                        		
FFFC1D1C 18101873		csrrw	v0,#$181,x0
FFFC1D20 00F87813		and		v0,v0,#15
FFFC1D24 00A81213	sll		$s1,$v0,#10
FFFC1D28 00098863		beq		$a1,$x0,.0001
FFFC1D2C 00086933		mov		$a0,$v0								; a0 = current tid
FFFC1D30 075000EF		call	RemoveFromReadyList
FFFC1D34 10D000EF		call	InsertIntoTimeoutList	; a1 = timeout
                        	.0001:
FFFC1D38 28824803		lbu		$v0,TCBStatus[$s1]		; flag task as no longer running
FFFC1D3C F7F87813		and		$v0,$v0,#~TS_RUNNING
FFFC1D40 29020423		sb		$v0,TCBStatus[$s1]
                        	
FFFC1D44 FA9FF0EF		call	AccountTime						; uses s1
FFFC1D48 C55FF0EF		call	SelectTaskToRun
                        	
FFFC1D4C 00A81293		sll		$s2,$v0,#10						; s2 = pointer to incoming TCB
FFFC1D50 2882C103		lbu		$x2,TCBStatus[$s2]		; x2 = incoming status
FFFC1D54 08116E13		or		$t2,$x2,#TS_RUNNING|TS_READY	; set status = running
FFFC1D58 2C82A103		lw		$x2,TCBException[$s2]	;
FFFC1D5C 00010A63		beq		$x2,$x0,.noException
                        		; set link register to catch handler address
                        		;{
                        		;	t->regs[29] = t->regs[28];   // set link register to catch handler
                        		;	t->epc = t->regs[28];        // and the PC register
                        		;	t->regs[1] = t->exception;    // r1 = exception value
                        		;	t->exception = 0;
                        		;	t->regs[2] = 45;              // r2 = exception type
                        		;}
FFFC1D60 0022A223		sw		$x2,4[$s2]						; r1 = exception
FFFC1D64 2C02A423		sw		$x0,TCBException[$s2]	; tcb->exception = 0
FFFC1D68 02D06113		ldi		$x2,#45
FFFC1D6C 0022A423		sw		$x2,8[$s2]						; r2 = 45
                        	.noException:
                        	
                        		; If a message is ready, update status to ready and put
                        		; message in target memory. The task will be returning
                        		; from a WaitMsg so a return status of E_Ok is also set.
FFFC1D70 004E7113		and		$x2,$t2,#TS_MSGRDY
FFFC1D74 04010463		beq		$x2,$x0,.noMsg
FFFC1D78 0502A903		lw		$a0,80[$s2]					; user a2 (x20)
FFFC1D7C 00090863		beq		$a0,$x0,.0002
FFFC1D80 C00FF0EF		call	VirtToPhys
FFFC1D84 2982A103		lw		$x2,TCBMsgD1[$s2]
FFFC1D88 00282023		sw		$x2,[$v0]
                        	.0002:
FFFC1D8C 0542A903		lw		$a0,84[$s2]
FFFC1D90 00090863		beq		$a0,$x0,.0003
FFFC1D94 BECFF0EF		call	VirtToPhys
FFFC1D98 2A02A103		lw		$x2,TCBMsgD2[$s2]
FFFC1D9C 00282023		sw		$x2,[$v0]
                        	.0003:
FFFC1DA0 0582A903		lw		$a0,88[$s2]
FFFC1DA4 00090863		beq		$a0,$x0,.0004
FFFC1DA8 BD8FF0EF		call	VirtToPhys
FFFC1DAC 2A82A103		lw		$x2,TCBMsgD3[$s2]
FFFC1DB0 00282023		sw		$x2,[$v0]
                        	.0004:
FFFC1DB4 00006113		ldi		$x2,#E_Ok						; setup to return E_Ok
FFFC1DB8 0422A023		sw		$x2,64[$s2]					; in v0
                        	
                        	.noMsg:
FFFC1DBC FFBE7E13		and		$t2,$t2,#~TS_MSGRDY		; mask out message ready status
FFFC1DC0 29C28423		sb		$t2,TCBStatus[$s2]
FFFC1DC4 00520863		beq		$s1,$s2,.noCtxSwitch	; incoming and outgoing contexts the same?
FFFC1DC8 00026933		mov		$a0,$s1
FFFC1DCC 0002E9B3		mov		$a1,$s2
FFFC1DD0 C85FF0EF		call	SwapContext
                        	.noCtxSwitch:
FFFC1DD4 00004637		lw		$t2,Tick						; get tick
FFFC1DD8 33060613
FFFC1DDC 00060633
FFFC1DE0 00062E03
FFFC1DE4 2BC22823		sw		$t2,TCBStartTick[$s1]
                        	ERETx:
FFFC1DE8 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; SchedulerIRQ meant to be called from the timer ISR.
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_SchedulerIRQ:
FFFC1DEC FFC70713		sub		$sp,$sp,#4
FFFC1DF0 00172023		sw		$ra,[$sp]
FFFC1DF4 00004937		ldi		$a0,#SysSema
FFFC1DF8 34090913
FFFC1DFC 01406993		ldi		$a1,#20
                        		
FFFC1E00 18101873		csrrw	v0,#$181,x0
FFFC1E04 00F87813		and		v0,v0,#15
FFFC1E08 00A81213	sll		$s1,$v0,#10						; compute pointer to TCB
                        	;	call	LockSemaphore
                        	;	beq		$v0,$x0,.noLock
                        	; Might need the following if the external timer isn't used.
                        	;	csrrw	$v0,#$701,$x0					; get the time
                        	;	add		$v0,$v0,#600000				; wait 600,000 cycles @20MHz (30ms)
                        	;	csrrw	$x0,#$321,$v0					; set next interrupt time
FFFC1E0C 00004637		lw		$t5,Tick							; update tick count
FFFC1E10 33060613
FFFC1E14 00060633
FFFC1E18 00062F83
FFFC1E1C 001F8F93		add		$t5,$t5,#1
FFFC1E20 00004637		sw		$t5,Tick
FFFC1E24 33060613
FFFC1E28 00060633
FFFC1E2C 01F62023
FFFC1E30 EBDFF0EF		call	AccountTime
FFFC1E34 28824F83		lbu		$t5,TCBStatus[$s1]
FFFC1E38 020FEF93		or		$t5,$t5,#TS_PREEMPT
FFFC1E3C F7FFFF93		and		$t5,$t5,#~TS_RUNNING	; no longer running, but may still be ready
FFFC1E40 29F20423		sb		$t5,TCBStatus[$s1]
                        		; Keep popping the timeout list as long as there are tasks on it with
                        		; expired timeouts.
                        	.0001:
FFFC1E44 00004637		lh		$t5,TimeoutList
FFFC1E48 32860613
FFFC1E4C 00060633
FFFC1E50 00061F83
FFFC1E54 100FCA63		blt		$t5,$x0,.noTimeouts
FFFC1E58 01006F13		ldi		$t4,#NR_TCB
FFFC1E5C 11EFD663		bge		$t5,$t4,.noTimeouts
FFFC1E60 00AF9F13		sll		$t4,$t5,#10					; index to pointer
FFFC1E64 2E0F2E83		lw		$t3,TCBTimeout[$t4]
FFFC1E68 0DD04A63		bgt		$t3,$x0,.timeoutNotDone
                        		
FFFC1E6C 00004637		lh		$v0,TimeoutList				; anything on timeout list?
FFFC1E70 32860613
FFFC1E74 00060633
FFFC1E78 00061803
FFFC1E7C 0A084A63		blt		$v0,$x0,.done11
FFFC1E80 01006893		ldi		$v1,#NR_TCB
FFFC1E84 0B187663		bgeu	$v0,$v1,.done11
FFFC1E88 00A81D13		sll		$t0,$v0,#10						; tid to pointer
FFFC1E8C 288D4883		lbu		$v1,TCBStatus[$t0]		; no longer a waiting status
FFFC1E90 0088FD93		and		$t1,$v1,#TS_WAITMSG
FFFC1E94 060D8063		beq		$t1,$x0,.noWait11
                        		
FFFC1E98 FF070713		sub		$sp,$sp,#16
FFFC1E9C 00472023		sw		$s1,[$sp]
FFFC1EA0 01A72223		sw		$t0,4[$sp]
FFFC1EA4 01B72423		sw		$t1,8[$sp]
FFFC1EA8 01C72623		sw		$t2,12[$sp]
FFFC1EAC 00A91213		sll		$s1,$a0,#10						; tid to pointer
FFFC1EB0 28A21D03		lh		$t0,TCBWaitMbx[$s1]		; get mailbox handle
FFFC1EB4 020D4663		blt		$t0,$x0,.xit2					; handle good?
FFFC1EB8 004D1D13		sll		$t0,$t0,#4						; convert to pointer
FFFC1EBC 00009637		add		$t0,$t0,#mbxs					; by adding base address
FFFC1EC0 80060613
FFFC1EC4 01A60D33
FFFC1EC8 004D5D83		lhu		$t1,MBX_WTIDS[$t0]		; get waiting task list
FFFC1ECC 00106E13		ldi		$t2,#1								; create a mask for given task id
FFFC1ED0 012E1E33		sll		$t2,$t2,$a0
FFFC1ED4 FFFE4E13		xor		$t2,$t2,#-1
FFFC1ED8 01CDFDB3		and		$t1,$t1,$t2						; clear bit
FFFC1EDC 01BD1223		sh		$t1,MBX_WTIDS[$t0]		; update waiting task list
                        	.xit2:
FFFC1EE0 00072203		lw		$s1,[$sp]
FFFC1EE4 00472D03		lw		$t0,4[$sp]
FFFC1EE8 00872D83		lw		$t1,8[$sp]
FFFC1EEC 00C72E03		lw		$t2,12[$sp]
FFFC1EF0 01070713		add		$sp,$sp,#16
                        	.noWait11:
FFFC1EF4 FE78F893		and		$v1,$v1,#~(TS_WAITMSG|TS_TIMEOUT)
	sb		$v1,TCBStatus[$t0]
FFFC1EF8 291D0423
FFFC1EFC 2D0D1883		lh		$v1,TCBNext[$t0]
FFFC1F00 00004637		sh		$v1,TimeoutList
FFFC1F04 32860613
FFFC1F08 00060633
FFFC1F0C 01161023
FFFC1F10 01006D93		ldi		$t1,#NR_TCB
FFFC1F14 01B8FE63		bgeu	$v1,$t1,.done11
FFFC1F18 2D8D1D83		lh		$t1,TCBPrev[$t0]			; t1 = h->prev
FFFC1F1C 00A89893		sll		$v1,$v1,#10
FFFC1F20 2DB89C23		sh		$t1,TCBPrev[$v1]			; TimeoutList->prev = h->prev
FFFC1F24 00A8D893		srl		$v1,$v1,#10
FFFC1F28 00AD9D93		sll		$t1,$t1,#10
FFFC1F2C 2D1D9823		sh		$v1,TCBNext[$t1]			; h->prev->next = TimeoutList
                        	.done11:	
FFFC1F30 00086933	mov		$a0,$v0
FFFC1F34 5A4000EF		call	InsertIntoReadyList
FFFC1F38 F00006E3		bra		.0001
                        	.timeoutNotDone:
FFFC1F3C FFFE8E93		sub		$t3,$t3,#1
FFFC1F40 00004637		lw		$t2,missed_ticks
FFFC1F44 32060613
FFFC1F48 00060633
FFFC1F4C 00062E03
FFFC1F50 41CE8EB3		sub		$t3,$t3,$t2
FFFC1F54 2FDF2023		sw		$t3,TCBTimeout[$t4]
FFFC1F58 00004637		sw		$x0,missed_ticks
FFFC1F5C 32060613
FFFC1F60 00060633
FFFC1F64 00062023
                        	.noTimeouts:
                        		; The ready queue was just updated, there could be new tasks
                        		; ready to run.
FFFC1F68 A35FF0EF		call	SelectTaskToRun
                        	
FFFC1F6C 00A81293		sll		$s2,$v0,#10					; s2 = pointer to incoming TCB
FFFC1F70 2882C103		lbu		$x2,TCBStatus[$s2]	; x2 = incoming status
FFFC1F74 08116E13		or		$t2,$x2,#TS_RUNNING|TS_READY	; status = running
FFFC1F78 2C82A103		lw		$x2,TCBException[$s2]	;
FFFC1F7C 00010263		beq		$x2,$x0,.noException
                        		; set link register to catch handler address
                        		;{
                        		;	t->regs[29] = t->regs[28];   // set link register to catch handler
                        		;	t->epc = t->regs[28];        // and the PC register
                        		;	t->regs[1] = t->exception;    // r1 = exception value
                        		;	t->exception = 0;
                        		;	t->regs[2] = 45;              // r2 = exception type
                        		;}
                        	.noException:
                        	
                        		; If a message is ready, update status to ready and put
                        		; message in target memory. The task will be returning
                        		; from a WaitMsg so a return status of E_Ok is also set.
FFFC1F80 04000863		bra		.noMsg
FFFC1F84 004E7113		and		$x2,$t2,#TS_MSGRDY
FFFC1F88 04010463		beq		$x2,$x0,.noMsg
FFFC1F8C 0502A903		lw		$a0,80[$s2]					; user a2 (x20)
FFFC1F90 00090863		beq		$a0,$x0,.0002
FFFC1F94 9ECFF0EF		call	VirtToPhys
FFFC1F98 2982A103		lw		$x2,TCBMsgD1[$s2]
FFFC1F9C 00282023		sw		$x2,[$v0]
                        	.0002:
FFFC1FA0 0542A903		lw		$a0,84[$s2]
FFFC1FA4 00090863		beq		$a0,$x0,.0003
FFFC1FA8 9D8FF0EF		call	VirtToPhys
FFFC1FAC 2A02A103		lw		$x2,TCBMsgD2[$s2]
FFFC1FB0 00282023		sw		$x2,[$v0]
                        	.0003:
FFFC1FB4 0582A903		lw		$a0,88[$s2]
FFFC1FB8 00090863		beq		$a0,$x0,.0004
FFFC1FBC 9C4FF0EF		call	VirtToPhys
FFFC1FC0 2A82A103		lw		$x2,TCBMsgD3[$s2]
FFFC1FC4 00282023		sw		$x2,[$v0]
                        	.0004:
FFFC1FC8 00006113		ldi		$x2,#E_Ok						; setup to return E_Ok
FFFC1FCC 0422A023		sw		$x2,64[$s2]					; in v0
                        	
                        	.noMsg:
FFFC1FD0 FFBE7E13		and		$t2,$t2,#~TS_MSGRDY		; mask out message ready status
FFFC1FD4 29C28423		sb		$t2,TCBStatus[$s2]
FFFC1FD8 00520863		beq		$s1,$s2,.noCtxSwitch
FFFC1FDC 00026933		mov		$a0,$s1
FFFC1FE0 0002E9B3		mov		$a1,$s2
FFFC1FE4 A71FF0EF		call	SwapContext
                        	.noCtxSwitch:
                        		
FFFC1FE8 FFF06813		ldi		v0,#-1
FFFC1FEC 00004637		sw		v0,SysSema
FFFC1FF0 34060613
FFFC1FF4 00060633
FFFC1FF8 01062023
                        	
                        	.noLock:
FFFC1FFC 00072083		lw		$ra,[$sp]
FFFC2000 00470713		add		$sp,$sp,#4
FFFC2004 00004637		lw		$t2,Tick					; get tick
FFFC2008 33060613
FFFC200C 00060633
FFFC2010 00062E03
FFFC2014 2BC22823		sw		$t2,TCBStartTick[$s1]
FFFC2018 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Start a task.
                        	;	Task status is set to ready, priority normal, and the task is inserted into
                        	; the ready list. Segment registers are setup for a flat memory model.
                        	; 
                        	;	Parameters:
                        	;		a1 = memory required
                        	;		a2 = start pc (usually $100)
                        	;	Modifies:
                        	;		a0 = tid
                        	;	Returns:
                        	;		v0 = E_Ok if successful
                        	;		v1 = tid of started task if successful
                        	;------------------------------------------------------------------------------
                        	;
                        	FMTK_StartTask:
FFFC201C 7E8000EF		call	AllocTCB
FFFC2020 00004637		sb		$v1,$4321
FFFC2024 32160613
FFFC2028 00060633
FFFC202C 01160023
FFFC2030 0A081463		bne		$v0,$x0,.err
FFFC2034 0008E933		mov		$a0,$v1
FFFC2038 8E4FF0EF		call	FreeAll
FFFC203C 941FF0EF		call	MapOSPages			; Map OS pages into address space
FFFC2040 00A91213		sll		$s1,$a0,#10			; compute TCB address
FFFC2044 8ACFF0EF		call	AllocStack
FFFC2048 00080D37		ldi		$t0,#$7F800			; set stack pointer
FFFC204C 800D0D13
FFFC2050 03A22C23		sw		$t0,56[$s1]
FFFC2054 29422023		sw		$a2,TCBepc[$s1]	; address task will begin at
FFFC2058 FDDFE0EF		call	Alloc
FFFC205C 00004637		sb		$v0,$4320
FFFC2060 32060613
FFFC2064 00060633
FFFC2068 01060023
FFFC206C 06081663		bne		$v0,$x0,.err
FFFC2070 00106D13		ldi		$t0,#TS_READY
FFFC2074 29A20423		sb		$t0,TCBStatus[$s1]
FFFC2078 00206D13		ldi		$t0,#2					; normal execution priority
FFFC207C 29A204A3		sb		$t0,TCBPriority[$s1]
                        		; leave segment base at $0, flat memory model
FFFC2080 00606D13		ldi		$t0,#6							; read,write
FFFC2084 21A22023		sw		$t0,TCBsegs[$s1]			; segs 0 to 11
FFFC2088 21A22223		sw		$t0,TCBsegs+4[$s1]
FFFC208C 21A22423		sw		$t0,TCBsegs+8[$s1]
FFFC2090 21A22623		sw		$t0,TCBsegs+12[$s1]
FFFC2094 21A22823		sw		$t0,TCBsegs+16[$s1]
FFFC2098 21A22A23		sw		$t0,TCBsegs+20[$s1]
FFFC209C 21A22C23		sw		$t0,TCBsegs+24[$s1]
FFFC20A0 21A22E23		sw		$t0,TCBsegs+28[$s1]
FFFC20A4 23A22023		sw		$t0,TCBsegs+32[$s1]
FFFC20A8 23A22223		sw		$t0,TCBsegs+36[$s1]
FFFC20AC 23A22423		sw		$t0,TCBsegs+40[$s1]
FFFC20B0 23A22623		sw		$t0,TCBsegs+44[$s1]
FFFC20B4 00506D13		ldi		$t0,#5							; read,execute
FFFC20B8 23A22823		sw		$t0,TCBsegs+48[$s1]	; segs 12 to 15
FFFC20BC 23A22A23		sw		$t0,TCBsegs+52[$s1]
FFFC20C0 23A22C23		sw		$t0,TCBsegs+56[$s1]
FFFC20C4 23A22E23		sw		$t0,TCBsegs+60[$s1]
FFFC20C8 00A25913		srl		$a0,$s1,#10					; need the tid again
FFFC20CC 40C000EF		call	InsertIntoReadyList
FFFC20D0 000968B3		mov		v1,a0
FFFC20D4 0608888D		mtu		$v1,$v1
                        	.err:
FFFC20D8 0608080D		mtu		$v0,$v0
FFFC20DC 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Exit the current task.
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		a1 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_ExitTask:
                        		
FFFC20E0 18101873		csrrw	v0,#$181,x0
FFFC20E4 00F87813		and		v0,v0,#15
FFFC20E8 000869B3	mov		a1,v0
                        		; fall through to KillTask
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = tid of task to kill
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_KillTask:
FFFC20EC 04098663		beq		$a1,$x0,.immortal		; tid #0 is immortal (the system)
FFFC20F0 00206D13		ldi		$t0,#TS_DEAD				; flag task as dead (prevents it from being re-queued)
FFFC20F4 00F9FD93		and		$t1,$a1,#15					; limit pid
FFFC20F8 00AD9D93		sll		$t1,$t1,#10					; convert to TCB address
FFFC20FC 29AD8423		sb		$t0,TCBStatus[$t1]
FFFC2100 0009E933		mov		a0,a1								; a0 = pid
FFFC2104 818FF0EF		call	FreeAll							; free all the memory associated with the task
                        		; Now make process ID available for reuse
FFFC2108 00004637		lhu		$t1,PIDMAP
FFFC210C 31060613
FFFC2110 00060633
FFFC2114 00065D83
FFFC2118 00106D13		ldi		$t0,#1							; generate bit "off" mask
FFFC211C 013D1D33		sll		$t0,$t0,$a1
FFFC2120 FFFD4D13		xor		$t0,$t0,#-1					; complment for inverted mask
FFFC2124 01ADFDB3		and		$t1,$t1,$t0
FFFC2128 00004637		sh		$t1,PIDMAP
FFFC212C 31060613
FFFC2130 00060633
FFFC2134 01B61023
                        	.immortal:
FFFC2138 10000073		eret
                        	
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/msg.r5a",1
                        	.file "../fmtk/msg.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	MBX_OWNER			equ		0		; tid of owning task
                        	MBX_WTIDS			equ		4		; tasks waiting at mailbox
                        	MBX_MQHEAD		equ		8		
                        	MBX_MQTAIL		equ		12
                        	MBX_SIZE			equ		16
                        	
                        	MSG_LINK	equ		0
                        	MSG_D1		equ		4
                        	MSG_D2		equ		8
                        	MSG_D3		equ		12
                        	MSG_SIZE	equ		16
                        	
                        	;	bss
                        	;	align 4
                        	;FreeMsg	dw	0
                        	;msgs:
                        	;	fill.b	MSG_SIZE*1024,0
                        	;mbxs:
                        	;	fill.b	MBX_SIZE*32,0
                        	;mbxs_end:
                        	
                        	.file "../fmtk/msg.r5a",46
                        		code
                        		align	4                        	
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = task id of owner
                        	;		a2 = pointer where to store handle
                        	; Returns:
                        	;		v0 = E_Ok
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_AllocMbx:
FFFC213C 040A0E63		beq		$a2,$x0,.badArg
FFFC2140 00009D37		ldi		$t0,#mbxs
FFFC2144 800D0D13
                        	.nxt:
FFFC2148 000D4D83		lbu		$t1,MBX_OWNER[$t0]
FFFC214C 020D8063		beq		$t1,$x0,.noOwner
FFFC2150 010D0D13		add		$t0,$t0,#MBX_SIZE
FFFC2154 00009637		slt		$t1,$t0,#mbxs_end
FFFC2158 A0060613
FFFC215C FE0D96E3		bne		$t1,$x0,.nxt
FFFC2160 04006813		ldi		$v0,#E_NoMoreMbx
FFFC2164 0608080D		mtu		$v0,$v0
FFFC2168 10000073		eret
                        	.noOwner:
FFFC216C 013D0023		sb		$a1,MBX_OWNER[$t0]
FFFC2170 FFFF8637		sub		$t5,$t0,#mbxs				; convert pointer to handle
FFFC2174 80060613
FFFC2178 41A60FB3
FFFC217C 004FDF93		srl		$t5,$t5,#4
FFFC2180 000A6933		mov		$a0,$a2
FFFC2184 FFDFE0EF		call	VirtToPhys
FFFC2188 01F82023		sw		$t5,[$v0]
FFFC218C 00006813		ldi		$v0,#E_Ok
FFFC2190 0608080D		mtu		$v0,$v0
FFFC2194 10000073		eret
                        	.badArg:
FFFC2198 00106813		ldi		$v0,#E_Arg
FFFC219C 0608080D		mtu		$v0,$v0
FFFC21A0 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_FreeMbx:
FFFC21A4 0209A213		slt		$s1,$a1,#32
FFFC21A8 06020863		beq		$s1,$x0,.badMbx
FFFC21AC 00499213		sll		$s1,$a1,#4					; convert handle to pointer
FFFC21B0 00009637		add		$s1,$s1,#mbxs
FFFC21B4 80060613
FFFC21B8 00460233
FFFC21BC 00006293		ldi		$s2,#0
FFFC21C0 01006393		ldi		$s4,#16							; possibly 16 tasks
FFFC21C4 00422483		lw		$s6,MBX_WTIDS[$s1]
                        	.0002:
FFFC21C8 0014F313		and		$s3,$s6,#1
FFFC21CC 02030A63		beq		$s3,$x0,.0001
FFFC21D0 00A29413		sll		$s5,$s2,#10						; tid to pointer
FFFC21D4 28844803		lbu		$v0,TCBStatus[$s5]
FFFC21D8 FF787813		and		$v0,$v0,#~TS_WAITMSG	; no longer waiting
FFFC21DC 29040423		sb		$v0,TCBStatus[$s5]
FFFC21E0 01087813		and		$v0,$v0,#TS_TIMEOUT
FFFC21E4 00080663		beq		$v0,$x0,.0003
FFFC21E8 0002E933		mov		$a0,$s2
FFFC21EC 510000EF		call	RemoveFromTimeoutList
                        	.0003:
FFFC21F0 0002E933		mov		$a0,$s2
FFFC21F4 2E4000EF		call	InsertIntoReadyList
FFFC21F8 00B06813		ldi		$v0,#E_NoMsg					; but no message
FFFC21FC 05042023		sw		$v0,64[$s5]						; v0 = E_NoMsg
                        	.0001:
FFFC2200 0014D493		srl		$s6,$s6,#1
FFFC2204 00128293		add		$s2,$s2,#1
FFFC2208 FC72E0E3		bltu	$s2,$s4,.0002
FFFC220C 00006813		ldi		$v0,#E_Ok
FFFC2210 0608080D		mtu		$v0,$v0
FFFC2214 10000073		eret
                        	.badMbx:
FFFC2218 00406813		ldi		$v0,#E_BadMbx				; return null pointer if bad mailbox
FFFC221C 0608080D		mtu		$v0,$v0
FFFC2220 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Send a message to a mailbox.
                        	; The message will be broadcast to any waiting tasks. Waiting tasks will then
                        	; be moved to the ready list. If there are no waiting tasks then the message
                        	; is queued at the mailbox.
                        	;
                        	; Register Usage:
                        	;		t0 = mailbox pointer
                        	;		t1 = message pointer
                        	;		s1 = task id of waiting task
                        	; Modifies:
                        	;		a0
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = message d1
                        	;		a3 = message d2
                        	;		a4 = message d3
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_SendMsg:
FFFC2224 0209AD13		slt		$t0,$a1,#32
FFFC2228 0C0D0E63		beq		$t0,$x0,.badMbx
FFFC222C 00499D13		sll		$t0,$a1,#4					; convert handle to pointer
FFFC2230 00009637		add		$t0,$t0,#mbxs
FFFC2234 80060613
FFFC2238 01A60D33
FFFC223C 004D2F83		lw		$t5,MBX_WTIDS[$t0]
FFFC2240 060F8063		beq		$t5,$x0,.noWaiters
FFFC2244 00006213		ldi		$s1,#0
                        	.0001:
FFFC2248 001FF313		and		$s3,$t5,#1					; is tid waiting?
FFFC224C 02030C63		beq		$s3,$x0,.nxtTid
FFFC2250 00A21313		sll		$s3,$s1,#10					; convert tid to TCB pointer
FFFC2254 29432C23		sw		$a2,TCBMsgD1[$s3]		; copy message to TCB
FFFC2258 2B532023		sw		$a3,TCBMsgD2[$s3]
FFFC225C 2B632423		sw		$a4,TCBMsgD3[$s3]
FFFC2260 28834E03		lbu		$t2,TCBStatus[$s3]
FFFC2264 004E6E13		or		$t2,$t2,#TS_MSGRDY
FFFC2268 29C30423		sb		$t2,TCBStatus[$s3]
FFFC226C 00026933		mov		$a0,$s1
FFFC2270 FFC70713		sub		$sp,$sp,#4
FFFC2274 01A72023		sw		$t0,[$sp]						; push t0
FFFC2278 260000EF		call	InsertIntoReadyList
FFFC227C 00072D03		lw		$t0,[$sp]						; pop t0
FFFC2280 00470713		add		$sp,$sp,#4
                        	.nxtTid:
FFFC2284 001FDF93		srl		$t5,$t5,#1					; check next task
FFFC2288 00120213		add		$s1,$s1,#1
FFFC228C 00F27213		and		$s1,$s1,#15
FFFC2290 FA021CE3		bne		$s1,$x0,.0001
FFFC2294 000D2223		sw		$x0,MBX_WTIDS[$t0]	; clear waiters
FFFC2298 00006813		ldi		$v0,#E_Ok
FFFC229C 06000663		bra		.xit
                        	.noWaiters:
FFFC22A0 00009637		lw		$t1,FreeMsg
FFFC22A4 C0060613
FFFC22A8 00060633
FFFC22AC 00062D83
FFFC22B0 040D8663		beq		$t1,$x0,.noMsg			; message available?
FFFC22B4 000DAE03		lw		$t2,MSG_LINK[$t1]
FFFC22B8 00009637		sw		$t2,FreeMsg
FFFC22BC C0060613
FFFC22C0 00060633
FFFC22C4 01C62023
FFFC22C8 014DA223		sw		$a2,MSG_D1[$t1]
FFFC22CC 015DA423		sw		$a3,MSG_D2[$t1]
FFFC22D0 016DA623		sw		$a4,MSG_D3[$t1]
FFFC22D4 00CD2E83		lw		$t3,MBX_MQTAIL[$t0]
FFFC22D8 000E8A63		beq		$t3,$x0,.mbxEmpty
FFFC22DC 01BEA023		sw		$t1,MSG_LINK[$t3]
FFFC22E0 01BD2623		sw		$t1,MBX_MQTAIL[$t0]
FFFC22E4 00006813		ldi		$v0,#E_Ok
FFFC22E8 02000063		bra		.xit
                        	.mbxEmpty:
FFFC22EC 01BD2423		sw		$t1,MBX_MQHEAD[$t0]
FFFC22F0 01BD2623		sw		$t1,MBX_MQTAIL[$t0]
FFFC22F4 00006813		ldi		$v0,#E_Ok
FFFC22F8 00000863		bra		.xit
                        	.noMsg:
FFFC22FC 00B06813		ldi		$v0,#E_NoMsg
FFFC2300 00000463		bra		.xit
                        	.badMbx:
FFFC2304 00406813		ldi		$v0,#E_BadMbx				; return null pointer if bad mailbox
                        	.xit:
FFFC2308 0608080D		mtu		$v0,$v0
FFFC230C 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = pointer where to put message D1
                        	;		a3 = pointer where to put message D2
                        	;		a4 = pointer where to put message D3
                        	;		a5 = 1 = remove from queue
                        	;------------------------------------------------------------------------------
                        	
                        	PeekMsg:
FFFC2310 FFC70713		sub		$sp,$sp,#4
FFFC2314 00172023		sw		$ra,[$sp]
FFFC2318 0209AD13		slt		$t0,$a1,#32
FFFC231C 080D0C63		beq		$t0,$x0,.badMbx
FFFC2320 00499E13		sll		$t2,$a1,#4					; convert handle to pointer
FFFC2324 00009637		add		$t2,$t2,#mbxs
FFFC2328 80060613
FFFC232C 01C60E33
FFFC2330 008E2D83		lw		$t1,MBX_MQHEAD[$t2]
FFFC2334 060D8C63		beq		$t1,$x0,.noMsg
FFFC2338 020B8863		beq		$a5,$x0,.nodq
FFFC233C 000DAE83		lw		$t3,MSG_LINK[$t1]
FFFC2340 01DE2423		sw		$t3,MBX_MQHEAD[$t2]
                        		; This is done here only because interrupts are disabled
FFFC2344 00009637		lw		$t3,FreeMsg
FFFC2348 C0060613
FFFC234C 00060633
FFFC2350 00062E83
FFFC2354 01DDA023		sw		$t3,MSG_LINK[$t1]
FFFC2358 00009637		sw		$t1,FreeMsg
FFFC235C C0060613
FFFC2360 00060633
FFFC2364 01B62023
                        	.nodq:
FFFC2368 000A0A63		beq		$a2,$x0,.nod1
FFFC236C 000A6933		mov		$a0,$a2
FFFC2370 E11FE0EF		call	VirtToPhys
FFFC2374 004DAE83		lw		$t3,MSG_D1[$t1]
FFFC2378 01D82023		sw		$t3,[$v0]
                        	.nod1:
FFFC237C 000A8A63		beq		$a3,$x0,.nod2
FFFC2380 000AE933		mov		$a0,$a3
FFFC2384 DFDFE0EF		call	VirtToPhys
FFFC2388 008DAE83		lw		$t3,MSG_D2[$t1]
FFFC238C 01D82023		sw		$t3,[$v0]
                        	.nod2:
FFFC2390 000B0A63		beq		$a4,$x0,.nod3
FFFC2394 000B6933		mov		$a0,$a4
FFFC2398 DE9FE0EF		call	VirtToPhys
FFFC239C 00CDAE83		lw		$t3,MSG_D3[$t1]
FFFC23A0 01D82023		sw		$t3,[$v0]
                        	.nod3:
FFFC23A4 00006813		ldi		$v0,#E_Ok
FFFC23A8 00000863		bra		.ret
                        	.noMsg:
FFFC23AC 00B06813		ldi		$v0,#E_NoMsg
FFFC23B0 00000463		bra		.ret
                        	.badMbx:
FFFC23B4 00406813		ldi		$v0,#E_BadMbx				; return null pointer if bad mailbox
                        	.ret:
FFFC23B8 00072083		lw		$ra,[$sp]
FFFC23BC 00470713		add		$sp,$sp,#4
FFFC23C0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; PeekMsg will check for a message at a mailbox optionally dequeuing it.
                        	; If no message is available PeekMsg returns to the caller with a E_NoMsg
                        	; status.
                        	;
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = pointer where to put message D1
                        	;		a3 = pointer where to put message D2
                        	;		a4 = pointer where to put message D3
                        	;		a5 = 1 = remove from queue
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_PeekMsg:
FFFC23C4 F4DFF0EF		call	PeekMsg
FFFC23C8 0608080D		mtu		$v0,$v0
FFFC23CC 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Calling WaitMsg will cause the task to be queued at the mailbox and a task
                        	; switch to occur if there are no messages at the mailbox.
                        	;
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = pointer where to put message D1
                        	;		a3 = pointer where to put message D2
                        	;		a4 = pointer where to put message D3
                        	;		a5 = time limit
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_WaitMsg:
FFFC23D0 000BE433		mov		s5,a5
FFFC23D4 00106B93		ldi		a5,#1
FFFC23D8 F39FF0EF		call	PeekMsg							; check for a message, return if available
FFFC23DC 00B06D93		ldi		$t1,#E_NoMsg
FFFC23E0 01B80663		beq		$v0,$t1,.qt					; no message? Then go queue task
FFFC23E4 0608080D		mtu		$v0,$v0
FFFC23E8 10000073		eret
                        	.qt:
                        		
FFFC23EC 18101873		csrrw	v0,#$181,x0
FFFC23F0 00F87813		and		v0,v0,#15
FFFC23F4 00106E13	ldi		$t2,#1
FFFC23F8 010E1E33		sll		$t2,$t2,$v0
FFFC23FC 00499E93		sll		$t3,$a1,#4					; convert handle to pointer
FFFC2400 00009637		add		$t3,$t3,#mbxs
FFFC2404 80060613
FFFC2408 01D60EB3
FFFC240C 004EAF03		lw		$t4,MBX_WTIDS[$t3]	; get waiting task list
FFFC2410 01CF6F33		or		$t4,$t4,$t2					; set bit for tid
FFFC2414 01EEA223		sw		$t4,MBX_WTIDS[$t3]	; save task list
FFFC2418 00A81F13		sll		$t4,$v0,#10					; convert tid to TCB pointer
FFFC241C 288F4E83		lbu		$t3,TCBStatus[$t4]
FFFC2420 008EEE93		or		$t3,$t3,#TS_WAITMSG	; set waiting for message status
FFFC2424 FFEEFE93		and		$t3,$t3,#~TS_READY	; not ready
FFFC2428 29DF0423		sb		$t3,TCBStatus[$t4]
FFFC242C 293F0523		sb		$a1,TCBWaitMbx[$t4]	; set mailbox task is waiting for
FFFC2430 000BE9B3		mov		$a1,$a5
                        		; Continue by switching tasks
FFFC2434 8E5FF06F		jmp		FMTK_Sleep
                        	
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/tcb.r5a",1
                        	.file "../fmtk/tcb.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../fmtk/tcb.r5a",25
                        		code
                        		align	4                        	
                        	;------------------------------------------------------------------------------
                        	; Insert task into ready queue
                        	;
                        	; Parameters:
                        	;		a0 = tid to insert
                        	; Modifies:
                        	;		v1,t0,t1
                        	; Returns:
                        	;		v0 = 1 for success, 0 if failed
                        	;------------------------------------------------------------------------------
                        	
                        	InsertTask:
FFFC2438 FFC70713		sub		$sp,$sp,#4
FFFC243C 00172023		sw		$ra,[$sp]
FFFC2440 00F06893		ldi		$v1,#MAX_TID
FFFC2444 0728EE63		bgtu	$a0,$v1,.badTid
FFFC2448 00A91D13		sll		$t0,$a0,#10					; compute TCB address
FFFC244C 288D4883		lbu		$v1,TCBStatus[$t0]	; mark task as ready
FFFC2450 0018E893		or		$v1,$v1,#TS_READY
FFFC2454 291D0423		sb		$v1,TCBStatus[$t0]
FFFC2458 289D4883		lbu		$v1,TCBPriority[$t0]
FFFC245C 0038F893		and		$v1,$v1,#3
FFFC2460 00000637		lbu		$t0,HRDY0[$v1]
FFFC2464 1D760613
FFFC2468 01160633
FFFC246C 00064D03
FFFC2470 00000637		lbu		$t1,TRDY0[$v1]			; increment tail pointer
FFFC2474 1D860613
FFFC2478 01160633
FFFC247C 00064D83
FFFC2480 001D8D93		add		$t1,$t1,#1
FFFC2484 05BD0263		beq		$t0,$t1,.qfull			; test queue full?
FFFC2488 00000637		sb		$t1,TRDY0[$v1]			; store it back
FFFC248C 1D860613
FFFC2490 01160633
FFFC2494 01B60023
FFFC2498 00889E93		sll		$t3,$v1,#8					; compute t3 = readyq index
FFFC249C 00004637		add		$t3,$t3,#RDYQ0
FFFC24A0 40060613
FFFC24A4 01D60EB3
FFFC24A8 FFFD8D93		sub		$t1,$t1,#1					; back for store
FFFC24AC 0FFDFD93		and		$t1,$t1,#255
FFFC24B0 01DD8E33		add		$t2,$t1,$t3
FFFC24B4 012E0023		sb		$a0,[$t2]						; store tid of task
FFFC24B8 00006813		ldi		$v0,#E_Ok
FFFC24BC 00000863		bra		.xit
                        	.badTid:
FFFC24C0 00106813		ldi		$v0,#E_Arg
FFFC24C4 00000463		bra		.xit
                        	.qfull:
FFFC24C8 00506813		ldi		$v0,#E_QueFull
                        	.xit:
FFFC24CC 00072083		lw		$ra,[$sp]
FFFC24D0 00470713		add		$sp,$sp,#4
FFFC24D4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Insert task into ready list. The list is a doubly linked circular list.
                        	;
                        	; Stack Space:
                        	;		2 words
                        	; Parameters:
                        	;		a0 = tid to insert
                        	; Modifies:
                        	;		v1,t0,t1,t2
                        	; Returns:
                        	;		v0 = 1 for success, 0 if failed
                        	;------------------------------------------------------------------------------
                        	
                        	InsertIntoReadyList:
FFFC24D8 FFC70713		sub		$sp,$sp,#4
FFFC24DC 00172023		sw		$ra,[$sp]
FFFC24E0 A20FE0EF		call	PutHexHalf
FFFC24E4 00072083		lw		$ra,[$sp]
FFFC24E8 00470713		add		$sp,$sp,#4
FFFC24EC 00F06893		ldi		$v1,#MAX_TID				; check argument
FFFC24F0 0B28E663		bgtu	$a0,$v1,.badTid
FFFC24F4 FF470713		sub		$sp,$sp,#12
FFFC24F8 00472023		sw		$s1,[$sp]						; save callee save registers
FFFC24FC 00572223		sw		$s2,4[$sp]
FFFC2500 00172423		sw		$ra,8[$sp]
FFFC2504 00A91213		sll		$s1,$a0,#10					; tid to pointer
FFFC2508 28920D03		lb		$t0,TCBPriority[$s1]
FFFC250C 003D7D13		and		$t0,$t0,#3					; limit to four
FFFC2510 001D1D13		sll		$t0,$t0,#1					; *2 for indexing
FFFC2514 00004637		lh		$t1,READYQ[$t0]			; get head of queue for that priority
FFFC2518 30860613
FFFC251C 01A60633
FFFC2520 00061D83
FFFC2524 00096333		mov		$s3,$a0
FFFC2528 000DE933		mov		$a0,$t1
FFFC252C 9D4FE0EF		call	PutHexHalf
FFFC2530 00036933		mov		$a0,$s3
FFFC2534 020DD063		bge		$t1,$x0,.insert			; Is there a head?
FFFC2538 00004637		sh		$a0,READYQ[$t0]			; no head, simple to insert
FFFC253C 30860613
FFFC2540 01A60633
FFFC2544 01261023
FFFC2548 2D221823		sh		$a0,TCBNext[$s1]
FFFC254C 2D221C23		sh		$a0,TCBPrev[$s1]
FFFC2550 02000063		bra		.ok
                        		; Insert at tail of list, which is just before the head.
                        	.insert:
FFFC2554 00AD9293		sll		$s2,$t1,#10					; a little more complicated, tid to pointer
FFFC2558 2D829E03		lh		$t2,TCBPrev[$s2]		; t2 = head->prev
FFFC255C 2DC21C23		sh		$t2,TCBPrev[$s1]		; arg->prev = head->prev
FFFC2560 2DB21823		sh		$t1,TCBNext[$s1]		; arg->next = head, arg links are now set
FFFC2564 00AE1213		sll		$s1,$t2,#10					; s1 = head->prev (as a pointer)
FFFC2568 2D221823		sh		$a0,TCBNext[$s1]		; head->prev->next = arg
FFFC256C 2D229C23		sh		$a0,TCBPrev[$s2]		; head->prev = arg
                        	.ok:
FFFC2570 00006813		ldi		$v0,#E_Ok
                        	.xit:
FFFC2574 00072203		lw		$s1,[$sp]						; restore callee saved regs
FFFC2578 00472283		lw		$s2,4[$sp]
FFFC257C 00872083		lw		$ra,8[$sp]
FFFC2580 00C70713		add		$sp,$sp,#12
FFFC2584 FFC70713		sub		$sp,$sp,#4
FFFC2588 00172023		sw		$ra,[$sp]
FFFC258C 324000EF		call	DumpReadyList
FFFC2590 00072083		lw		$ra,[$sp]
FFFC2594 00470713		add		$sp,$sp,#4
FFFC2598 00008067		ret
                        	.badTid:
FFFC259C 00106813		ldi		$v0,#E_Arg
FFFC25A0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	RemoveFromReadyList:
FFFC25A4 00F06893		ldi		$v1,#MAX_TID					; check arg
FFFC25A8 0928E863		bgtu	$a0,$v1,.badTid
FFFC25AC FF870713		sub		$sp,$sp,#8
FFFC25B0 00472023		sw		$s1,[$sp]							; save callee saved regs
FFFC25B4 00572223		sw		$s2,4[$sp]
FFFC25B8 00A91213		sll		$s1,$a0,#10						; s1 = pointer to tcb
FFFC25BC 28820D03		lb		$t0,TCBStatus[$s1]		; set status no longer ready or running
FFFC25C0 F7ED7D13		and		$t0,$t0,#~(TS_READY|TS_RUNNING)
	sb		$t0,TCBStatus[$s1]
FFFC25C4 29A20423
FFFC25C8 28920D03		lb		$t0,TCBPriority[$s1]	; t0 = priority
FFFC25CC 003D7D13		and		$t0,$t0,#3						; limit to 0-3
FFFC25D0 001D1D13		sll		$t0,$t0,#1						; *2 for indexing
FFFC25D4 00004637		lh		$t1,READYQ[$t0]				; get head tid
FFFC25D8 30860613
FFFC25DC 01A60633
FFFC25E0 00061D83
FFFC25E4 2D021E03		lh		$t2,TCBNext[$s1]			; get arg->next
FFFC25E8 012D9A63		bne		$t1,$a0,.0001					; removing head of list?
FFFC25EC 00004637		sh		$t2,READYQ[$t0]				; yes, set new head to arg->next
FFFC25F0 30860613
FFFC25F4 01A60633
FFFC25F8 01C61023
                        	.0001:
FFFC25FC 000E4E63		blt		$t2,$x0,.0002					; validate t2 (arg->next)
FFFC2600 01C8EC63		bgtu	$t2,$v1,.0002					; there should always be an arg->next, arg->prev
FFFC2604 2D821E83		lh		$t3,TCBPrev[$s1]			; because the list is circular t3=arg->prev
FFFC2608 00AE9293		sll		$s2,$t3,#10						; s2 = arg->prev as a pointer
FFFC260C 2DC29823		sh		$t2,TCBNext[$s2]			; arg->prev->next = arg->next
FFFC2610 00AE1293		sll		$s2,$t2,#10						; s2 = arg->next as a pointer
FFFC2614 2DD29C23		sh		$t3,TCBPrev[$s2]			; arg->next->prev = arg->prev
                        		; Now indicate links in TCB are not in use.
                        	.0002:
FFFC2618 FFF06813		ldi		$v0,#-1
FFFC261C 2D021823		sh		$v0,TCBNext[$s1]
FFFC2620 2D021C23		sh		$v0,TCBPrev[$s1]
FFFC2624 00006813		ldi		$v0,#E_Ok							; we're ok
FFFC2628 00072203		lw		$s1,[$sp]							; restore callee saved regs
FFFC262C 00472283		lw		$s2,4[$sp]
FFFC2630 00870713		add		$sp,$sp,#8
FFFC2634 00008067		ret
                        	.badTid:
FFFC2638 00106813		ldi		$v0,#E_Arg
FFFC263C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = task id to insert
                        	;		a1 = timeout value
                        	; Modifies:
                        	;		t0,t1,t2,t3,t4,s1
                        	;------------------------------------------------------------------------------
                        	
                        	InsertIntoTimeoutList:
FFFC2640 00A91213		sll		$s1,$a0,#10					; tid to pointer
FFFC2644 FFF06D13		ldi		$t0,#-1						
FFFC2648 2DA21823		sh		$t0,TCBNext[$s1]		; initialize indexes to -1
FFFC264C 2DA21C23		sh		$t0,TCBPrev[$s1]
FFFC2650 00004637		lh		$t0,TimeoutList
FFFC2654 32860613
FFFC2658 00060633
FFFC265C 00061D03
FFFC2660 020D5063		bge		$t0,$x0,.0001
FFFC2664 2F322023		sw		$a1,TCBTimeout[$s1]
FFFC2668 00004637		sh		$a0,TimeoutList
FFFC266C 32860613
FFFC2670 00060633
FFFC2674 01261023
FFFC2678 00006813		ldi		$v0,#E_Ok
FFFC267C 00008067		ret
                        	.0001:
FFFC2680 00006DB3		mov		$t1,$x0
FFFC2684 000D6E33		mov		$t2,$t0
FFFC2688 00AE1E93		sll		$t3,$t2,#10
                        	.beginWhile:
FFFC268C 2E0EAF03		lw		$t4,TCBTimeout[$t3]
FFFC2690 013F5E63		ble		$a1,$t4,.endWhile
FFFC2694 41E989B3		sub		$a1,$a1,$t4
FFFC2698 000EEDB3		mov		$t1,$t3
FFFC269C 2D0E9E83		lh		$t3,TCBNext[$t3]
FFFC26A0 000EC663		blt		$t3,$x0,.endWhile
FFFC26A4 00AE9E93		sll		$t3,$t3,#10
FFFC26A8 FFBE92E3		bne		$t3,$t1,.beginWhile		; list screwed up?
                        	.endWhile
FFFC26AC 20AEDE13		sra		$t2,$t3,#10
FFFC26B0 2DC21823		sh		$t2,TCBNext[$s1]
FFFC26B4 20ADDE13		sra		$t2,$t1,#10
FFFC26B8 2DC21C23		sh		$t2,TCBPrev[$s1]
FFFC26BC 2E0EAE03		lw		$t2,TCBTimeout[$t3]
FFFC26C0 413E0E33		sub		$t2,$t2,$a1
FFFC26C4 2FCEA023		sw		$t2,TCBTimeout[$t3]
FFFC26C8 2D2E9C23		sh		$a0,TCBPrev[$t3]
FFFC26CC 000DC663		blt		$t1,$x0,.0002
FFFC26D0 2D2D9823		sh		$a0,TCBNext[$t1]
FFFC26D4 00000A63		bra		.0003
                        	.0002:
FFFC26D8 00004637		sh		$a0,TimeoutList
FFFC26DC 32860613
FFFC26E0 00060633
FFFC26E4 01261023
                        	.0003:
FFFC26E8 28824E03		lbu		$t2,TCBStatus[$s1]
FFFC26EC 010E6E13		or		$t2,$t2,#TS_TIMEOUT
FFFC26F0 29C20423		sb		$t2,TCBStatus[$s1]
FFFC26F4 00006813		ldi		$v0,#E_Ok
FFFC26F8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Remove a task from the timeout list. The timeouts of following tasks are
                        	; adjusted.
                        	;
                        	; Parameters:
                        	;		a0 = task id to remove
                        	; Modifies:
                        	;		t0,t1,t2
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	RemoveFromTimeoutList:
FFFC26FC FF470713		sub		$sp,$sp,#12
FFFC2700 00472023		sw		$s1,[$sp]
FFFC2704 00572423		sw		$s2,8[$sp]
FFFC2708 00172223		sw		$ra,4[$sp]
FFFC270C 00A91213		sll		$s1,$a0,#10						; tid to pointer
FFFC2710 28824D03		lbu		$t0,TCBStatus[$s1]		; check if waiting at a mailbox
FFFC2714 008D7D13		and		$t0,$t0,#TS_WAITMSG
FFFC2718 060D0063		beq		$t0,$x0,.noWait				
                        		
FFFC271C FF070713		sub		$sp,$sp,#16
FFFC2720 00472023		sw		$s1,[$sp]
FFFC2724 01A72223		sw		$t0,4[$sp]
FFFC2728 01B72423		sw		$t1,8[$sp]
FFFC272C 01C72623		sw		$t2,12[$sp]
FFFC2730 00A91213		sll		$s1,$a0,#10						; tid to pointer
FFFC2734 28A21D03		lh		$t0,TCBWaitMbx[$s1]		; get mailbox handle
FFFC2738 020D4663		blt		$t0,$x0,.xit15					; handle good?
FFFC273C 004D1D13		sll		$t0,$t0,#4						; convert to pointer
FFFC2740 00009637		add		$t0,$t0,#mbxs					; by adding base address
FFFC2744 80060613
FFFC2748 01A60D33
FFFC274C 004D5D83		lhu		$t1,MBX_WTIDS[$t0]		; get waiting task list
FFFC2750 00106E13		ldi		$t2,#1								; create a mask for given task id
FFFC2754 012E1E33		sll		$t2,$t2,$a0
FFFC2758 FFFE4E13		xor		$t2,$t2,#-1
FFFC275C 01CDFDB3		and		$t1,$t1,$t2						; clear bit
FFFC2760 01BD1223		sh		$t1,MBX_WTIDS[$t0]		; update waiting task list
                        	.xit15:
FFFC2764 00072203		lw		$s1,[$sp]
FFFC2768 00472D03		lw		$t0,4[$sp]
FFFC276C 00872D83		lw		$t1,8[$sp]
FFFC2770 00C72E03		lw		$t2,12[$sp]
FFFC2774 01070713		add		$sp,$sp,#16
                        	.noWait:
FFFC2778 00004637		lh		$t0,TimeoutList
FFFC277C 32860613
FFFC2780 00060633
FFFC2784 00061D03
FFFC2788 01A91C63		bne		$a0,$t0,.0001					; check removing head of list
FFFC278C 2D021D03		lh		$t0,TCBNext[$s1]
FFFC2790 00004637		sh		$t0,TimeoutList
FFFC2794 32860613
FFFC2798 00060633
FFFC279C 01A61023
                        	.0001:
FFFC27A0 2D021D03		lh		$t0,TCBNext[$s1]
FFFC27A4 020D4063		blt		$t0,$x0,.noNext
FFFC27A8 00AD1293		sll		$s2,$t0,#10
FFFC27AC 2D821D83		lh		$t1,TCBPrev[$s1]
FFFC27B0 2DB29C23		sh		$t1,TCBPrev[$s2]
FFFC27B4 2E02AD83		lw		$t1,TCBTimeout[$s2]
FFFC27B8 2E022E03		lw		$t2,TCBTimeout[$s1]
FFFC27BC 01CD8DB3		add		$t1,$t1,$t2
FFFC27C0 2FB2A023		sw		$t1,TCBTimeout[$s2]
                        	.noNext:
FFFC27C4 2D821D03		lh		$t0,TCBPrev[$s1]
FFFC27C8 000D4863		blt		$t0,$x0,.noPrev
FFFC27CC 00AD1293		sll		$s2,$t0,#10
FFFC27D0 2D021D03		lh		$t0,TCBNext[$s1]
FFFC27D4 2DA29823		sh		$t0,TCBNext[$s2]
                        	.noPrev:
FFFC27D8 28820D03		lb		$t0,TCBStatus[$s1]		; no longer timing out
FFFC27DC FE7D7D13		and		$t0,$t0,#~(TS_TIMEOUT|TS_WAITMSG)
	sb		$t0,TCBStatus[$s1]
FFFC27E0 29A20423
FFFC27E4 FFF06D13		ldi		$t0,#-1
FFFC27E8 2DA21823		sh		$t0,TCBNext[$s1]
FFFC27EC 2DA21C23		sh		$t0,TCBPrev[$s1]
FFFC27F0 00072203		lw		$s1,[$sp]							; restore callee saves
FFFC27F4 00472083		lw		$ra,4[$sp]
FFFC27F8 00872283		lw		$s2,8[$sp]
FFFC27FC 00C70713		add		$sp,$sp,#12
FFFC2800 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Returns:
                        	;		v1 = process id
                        	;------------------------------------------------------------------------------
                        	
                        	AllocTCB:
FFFC2804 00006D93		ldi		$t1,#0
FFFC2808 00004637		lhu		$v1,PIDMAP
FFFC280C 31060613
FFFC2810 00060633
FFFC2814 00065883
                        	.0001:
FFFC2818 0018FD13		and		$t0,$v1,#1
FFFC281C 020D0463		beq		$t0,$x0,.allocTid
FFFC2820 0018D893		srl		$v1,$v1,#1
FFFC2824 00008637		or		$v1,$v1,#$8000
FFFC2828 00060613
FFFC282C 011668B3
FFFC2830 001D8D93		add		$t1,$t1,#1
FFFC2834 00FDFD93		and		$t1,$t1,#15
FFFC2838 FE0D90E3		bne		$t1,$x0,.0001
                        	; here no tcbs available
FFFC283C 04506813		ldi		$v0,#E_NoMoreTCBs
FFFC2840 00008067		ret
                        	.allocTid:
FFFC2844 000DE833		mov		$v0,$t1
FFFC2848 0018E893		or		$v1,$v1,#1
FFFC284C 000D8A63		beq		$t1,$x0,.0003
                        	.0002:
FFFC2850 00189893		sll		$v1,$v1,#1
FFFC2854 0018E893		or		$v1,$v1,#1
FFFC2858 FFFD8D93		sub		$t1,$t1,#1
FFFC285C FE0D9AE3		bne		$t1,$x0,.0002
                        	.0003:
FFFC2860 00004637		sh		$v1,PIDMAP
FFFC2864 31060613
FFFC2868 00060633
FFFC286C 01161023
FFFC2870 000868B3		mov		$v1,$v0
FFFC2874 00006813		ldi		$v0,#E_Ok
FFFC2878 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FreeTCB:
FFFC287C 00106D13		ldi		$t0,#1
FFFC2880 012D1D33		sll		$t0,$t0,$a0
FFFC2884 FFFD4D13		xor		$t0,$t0,#-1
FFFC2888 00004637		lhu		$t1,PIDMAP
FFFC288C 31060613
FFFC2890 00060633
FFFC2894 00065D83
FFFC2898 01ADFDB3		and		$t1,$t1,$t0
FFFC289C 00004637		sh		$t1,PIDMAP
FFFC28A0 31060613
FFFC28A4 00060633
FFFC28A8 01B61023
FFFC28AC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Diagnostics
                        	;------------------------------------------------------------------------------
                        	
                        	DumpReadyList:
FFFC28B0 FE470713		sub		$sp,$sp,#28
FFFC28B4 00172023		sw		$ra,[$sp]
FFFC28B8 01272223		sw		$a0,4[$sp]
FFFC28BC 01472423		sw		$a2,8[$sp]
FFFC28C0 01572623		sw		$a3,12[$sp]
FFFC28C4 01B72823		sw		$t1,16[$sp]
FFFC28C8 01C72A23		sw		$t2,20[$sp]
FFFC28CC 01D72C23		sw		$t3,24[$sp]
FFFC28D0 FFFC3937		ldi		$a0,#msgReadyList
FFFC28D4 A5490913
FFFC28D8 EA9FD0EF		call	PutString
FFFC28DC 00006D93		ldi		$t1,#0
                        	.0002:
FFFC28E0 BEDFE0EF		call	SerialPeekCharDirect
FFFC28E4 00384813		xor		$v0,$v0,#CTRLC
FFFC28E8 08080263		beq		$v0,$x0,.brk
FFFC28EC 00D06913		ldi		$a0,#CR
FFFC28F0 935FD0EF		call	Putch
FFFC28F4 05106913		ldi		$a0,#'Q'
FFFC28F8 92DFD0EF		call	Putch
FFFC28FC 001DD913		srl		$a0,$t1,#1
FFFC2900 E41FD0EF		call	PutHexNybble
FFFC2904 03A06913		ldi		$a0,#':'
FFFC2908 91DFD0EF		call	Putch
FFFC290C 00004637		lh		$a2,READYQ[$t1]
FFFC2910 30860613
FFFC2914 01B60633
FFFC2918 00061A03
FFFC291C 040A4263		blt		$a2,$x0,.nxt
FFFC2920 000A6AB3		mov		$a3,$a2
                        	.0001:
FFFC2924 000AE933		mov		$a0,$a3
FFFC2928 DD9FD0EF		call	PutHexHalf
FFFC292C 02006913		ldi		$a0,#' '
FFFC2930 8F5FD0EF		call	Putch
FFFC2934 00AA9A93		sll		$a3,$a3,#10
FFFC2938 2D0A9903		lh		$a0,TCBNext[$a3]
FFFC293C DC5FD0EF		call	PutHexHalf
FFFC2940 02006913		ldi		$a0,#' '
FFFC2944 8E1FD0EF		call	Putch
FFFC2948 2D8A9903		lh		$a0,TCBPrev[$a3]
FFFC294C DB5FD0EF		call	PutHexHalf
FFFC2950 00D06913		ldi		$a0,#CR
FFFC2954 8D1FD0EF		call	Putch
FFFC2958 2D0A9A83		lh		$a3,TCBNext[$a3]
FFFC295C FD5A14E3		bne		$a2,$a3,.0001
                        	.nxt:
FFFC2960 002D8D93		add		$t1,$t1,#2
FFFC2964 008DAE13		slt		$t2,$t1,#8
FFFC2968 F60E1CE3		bne		$t2,$x0,.0002
                        	.brk:
FFFC296C 00072083		lw		$ra,[$sp]
FFFC2970 00472903		lw		$a0,4[$sp]
FFFC2974 00872A03		lw		$a2,8[$sp]
FFFC2978 00C72A83		lw		$a3,12[$sp]
FFFC297C 01072D83		lw		$t1,16[$sp]
FFFC2980 01472E03		lw		$t2,20[$sp]
FFFC2984 01872E83		lw		$t3,24[$sp]
FFFC2988 01C70713		add		$sp,$sp,#28
FFFC298C 00008067		ret
                        	
                        	DumpTimeoutList:
FFFC2990 FE470713		sub		$sp,$sp,#28
FFFC2994 00172023		sw		$ra,[$sp]
FFFC2998 01272223		sw		$a0,4[$sp]
FFFC299C 01472423		sw		$a2,8[$sp]
FFFC29A0 01572623		sw		$a3,12[$sp]
FFFC29A4 01B72823		sw		$t1,16[$sp]
FFFC29A8 01C72A23		sw		$t2,20[$sp]
FFFC29AC 01D72C23		sw		$t3,24[$sp]
FFFC29B0 FFFC3937		ldi		$a0,#msgTimeoutList
FFFC29B4 A8590913
FFFC29B8 DC9FD0EF		call	PutString
FFFC29BC 00006D93		ldi		$t1,#0
                        	.0002:
FFFC29C0 B0DFE0EF		call	SerialPeekCharDirect
FFFC29C4 00384813		xor		$v0,$v0,#CTRLC
FFFC29C8 06080463		beq		$v0,$x0,.brk
FFFC29CC 00D06913		ldi		$a0,#CR
FFFC29D0 855FD0EF		call	Putch
FFFC29D4 05106913		ldi		$a0,#'Q'
FFFC29D8 84DFD0EF		call	Putch
FFFC29DC 001DD913		srl		$a0,$t1,#1
FFFC29E0 D61FD0EF		call	PutHexNybble
FFFC29E4 03A06913		ldi		$a0,#':'
FFFC29E8 83DFD0EF		call	Putch
FFFC29EC 00004637		lh		$a2,TimeoutList
FFFC29F0 32860613
FFFC29F4 00060633
FFFC29F8 00061A03
FFFC29FC 020A4A63		blt		$a2,$x0,.brk
FFFC2A00 000A6AB3		mov		$a3,$a2
                        	.0001:
FFFC2A04 000AE933		mov		$a0,$a3
FFFC2A08 CF9FD0EF		call	PutHexHalf
FFFC2A0C 02D06913		ldi		$a0,#'-'
FFFC2A10 815FD0EF		call	Putch
FFFC2A14 00AA9A93		sll		$a3,$a3,#10
FFFC2A18 2E0AA903		lw		$a0,TCBTimeout[$a3]
FFFC2A1C CC5FD0EF		call	PutHexWord
FFFC2A20 00D06913		ldi		$a0,#CR
FFFC2A24 801FD0EF		call	Putch
FFFC2A28 2D0A9A83		lh		$a3,TCBNext[$a3]
FFFC2A2C FC0ADCE3		bge		$a3,$x0,.0001
                        	.brk:
FFFC2A30 00072083		lw		$ra,[$sp]
FFFC2A34 00472903		lw		$a0,4[$sp]
FFFC2A38 00872A03		lw		$a2,8[$sp]
FFFC2A3C 00C72A83		lw		$a3,12[$sp]
FFFC2A40 01072D83		lw		$t1,16[$sp]
FFFC2A44 01472E03		lw		$t2,20[$sp]
FFFC2A48 01872E83		lw		$t3,24[$sp]
FFFC2A4C 01C70713		add		$sp,$sp,#28
FFFC2A50 00008067		ret
                        	
                        	msgReadyList:
FFFC2A54 6165520D		db	CR,"Ready List",CR
FFFC2A58 4C207964
FFFC2A5C 0D747369
FFFC2A60 20657551		db	"Que Tid  Prv  Nxt",CR
FFFC2A64 20646954
FFFC2A68 76725020
FFFC2A6C 784E2020
FFFC2A70 2D2D0D74
FFFC2A72 2D2D2D2D		db	"-----------------",CR,0
FFFC2A76 2D2D2D2D
FFFC2A7A 2D2D2D2D
FFFC2A7E 2D2D2D2D
FFFC2A82 0D000D2D
                        	
                        	msgTimeoutList:
FFFC2A85 6D69540D		db	CR,"Timeout List",CR
FFFC2A89 74756F65
FFFC2A8D 73694C20
FFFC2A91 54200D74
FFFC2A93 64695420		db	" Tid - Timeout",CR
FFFC2A97 54202D20
FFFC2A9B 6F656D69
FFFC2A9F 2D0D7475
FFFC2AA2 2D2D2D2D		db	"--------------",CR,0
FFFC2AA6 2D2D2D2D
FFFC2AAA 2D2D2D2D
FFFC2AAE 000D2D2D
                        	
FFFC2AB2 18730000		align 
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/iofocus.r5a",1
                        	.file "../fmtk/iofocus.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	IOFocusNdx		EQU		$8C08
                        	IOFocusTbl		EQU		$8C10
                        	
                        	;-----------------------------------------------------------------------------
                        	; IO Focus routines complicated by the fact that the base address of TCB
                        	; zero is zero (looks like a null pointer but isn't). So the value -1 is 
                        	; used to indicate no focus index.
                        	;-----------------------------------------------------------------------------
                        	
                        	.file "../fmtk/iofocus.r5a",34
                        		code
                        		align	4                        	
                        	
                        	;-----------------------------------------------------------------------------
                        	; Determine if the currently running task has the I/O focus.
                        	;
                        	; Stack Space:
                        	;		2 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		v0 = E_Ok
                        	;		v1 = 1 if task has IO focus, 0 otherwise
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_HasIOFocus:
                        		
FFFC2AB4 18101873		csrrw	v0,#$181,x0
FFFC2AB8 00F87813		and		v0,v0,#15
FFFC2ABC 00A81813	sll		$v0,$v0,#10
FFFC2AC0 00009637		lw		$v1,IOFocusNdx
FFFC2AC4 C0860613
FFFC2AC8 00060633
FFFC2ACC 00062883
FFFC2AD0 01180663		beq		$v0,$v1,.hasFocus
FFFC2AD4 00006893		ldi		$v1,#0
FFFC2AD8 00000463		bra		.xit
                        	.hasFocus:
FFFC2ADC 00106893		ldi		$v1,#1
                        	.xit:
FFFC2AE0 00006813		ldi		$v0,#E_Ok
FFFC2AE4 0608080D		mtu		$v0,$v0
FFFC2AE8 0608888D		mtu		$v1,$v1
FFFC2AEC 10000073		eret
                        	
                        	;-----------------------------------------------------------------------------
                        	; First check if it's even possible to switch the focus to another
                        	; task. The I/O focus list could be empty or there may be only a
                        	; single task in the list. In either case it's not possible to
                        	; switch.
                        	;
                        	; Stack Space:
                        	;		2 words
                        	;	Parameters:
                        	;		none
                        	;	Modifies:
                        	;		none
                        	;	Returns:
                        	;		v0 = E_Ok
                        	;-----------------------------------------------------------------------------
                        	
                        	SwitchIOFocusHelper:
FFFC2AF0 FF870713		sub		$sp,$sp,#8
FFFC2AF4 01A72023		sw		$t0,[$sp]
FFFC2AF8 01B72223		sw		$t1,4[$sp]
FFFC2AFC 00009637		lw		$t0,IOFocusNdx			; get focus pointer
FFFC2B00 C0860613
FFFC2B04 00060633
FFFC2B08 00062D03
FFFC2B0C 000D4E63		blt		$t0,$x0,.noFocus		; is it -1?
FFFC2B10 2E8D2D83		lw		$t1,IOF_NEXT[$t0]
FFFC2B14 01AD8A63		beq		$t1,$t0,.sameFocus
                        		; swap virtual screens
                        		; set vidmem pointer
FFFC2B18 00009637		sw		$t1,IOFocusNdx
FFFC2B1C C0860613
FFFC2B20 00060633
FFFC2B24 01B62023
                        	.sameFocus:
                        	.noFocus:
FFFC2B28 00006813		ldi		$v0,E_Ok
FFFC2B2C 00072D03		lw		$t0,[$sp]
FFFC2B30 00472D83		lw		$t1,4[$sp]
FFFC2B34 00870713		add		$sp,$sp,#8
FFFC2B38 00008067		ret
                        	
                        	FMTK_SwitchIOFocus:
FFFC2B3C FB5FF0EF		call	SwitchIOFocusHelper
FFFC2B40 0608080D		mtu		$v0,$v0
FFFC2B44 10000073		eret
                        	
                        	;-----------------------------------------------------------------------------
                        	; The I/O focus list is an array indicating which jobs are requesting the
                        	; I/O focus. The I/O focus is user controlled by pressing CNTRL-T on the
                        	; keyboard.
                        	;
                        	; Parameters:
                        	;		a1 = task id requesting focus for
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_RequestIOFocus:
FFFC2B48 00106D13		ldi		$t0,#1
FFFC2B4C 013D1D33		sll		$t0,$t0,$a1
FFFC2B50 00009637		lw		$t1,IOFocusTbl			; Is the task already included in the IO focus?
FFFC2B54 C1060613
FFFC2B58 00060633
FFFC2B5C 00062D83
FFFC2B60 01ADFE33		and		$t2,$t1,$t0					; test bit
FFFC2B64 060E1263		bne		$t2,$x0,.ret				; If so, don't add again
FFFC2B68 01ADEDB3		or		$t1,$t1,$t0					; set bit indicator
FFFC2B6C 00009637		sw		$t1,IOFocusTbl
FFFC2B70 C1060613
FFFC2B74 00060633
FFFC2B78 01B62023
FFFC2B7C 00009637		lw		$t0,IOFocusNdx			; get current index
FFFC2B80 C0860613
FFFC2B84 00060633
FFFC2B88 00062D03
FFFC2B8C 00A99D93		sll		$t1,$a1,#10					; t1 = pointer to TCB
FFFC2B90 020D5063		bge		$t0,$x0,.notEmpty		; is there one? (!= -1)
FFFC2B94 00009637		sw		$t1,IOFocusNdx			; no current index, so set equal to requester
FFFC2B98 C0860613
FFFC2B9C 00060633
FFFC2BA0 01B62023
FFFC2BA4 2FBDA423		sw		$t1,IOF_NEXT[$t1]		; and loop back to self
FFFC2BA8 2FBDA823		sw		$t1,IOF_PREV[$t1]
FFFC2BAC 00000E63		bra		.ret
                        	.notEmpty:
FFFC2BB0 2F0D2E03		lw		$t2,IOF_PREV[$t0]		; insert t1 into focus ring
FFFC2BB4 2FCDA823		sw		$t2,IOF_PREV[$t1]
FFFC2BB8 2FADA423		sw		$t0,IOF_NEXT[$t1]
FFFC2BBC 2F0D2E03		lw		$t2,IOF_PREV[$t0]
FFFC2BC0 2FBE2423		sw		$t1,IOF_NEXT[$t2]
FFFC2BC4 2FBD2823		sw		$t1,IOF_PREV[$t0]
                        	.ret:
FFFC2BC8 00006813		ldi		$v0,#E_Ok
FFFC2BCC 0608080D		mtu		$v0,$v0
FFFC2BD0 10000073		eret
                        	
                        	;-----------------------------------------------------------------------------
                        	; ReleaseIOFocus called when the task no longer desires to be on the I/O
                        	; focus list.
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_ReleaseIOFocus:
                        		
FFFC2BD4 18101873		csrrw	v0,#$181,x0
FFFC2BD8 00F87813		and		v0,v0,#15
FFFC2BDC 000869B3	mov		a1,v0
                        		; fall into ForceReleaseIOFocus
                        	
                        	;-----------------------------------------------------------------------------
                        	; Releasing the I/O focus causes the focus to switch if the running job
                        	; had the I/O focus.
                        	; ForceReleaseIOFocus forces the release of the IO focus for a job
                        	; different than the one currently running.
                        	; 
                        	; Parameters:
                        	;		a1 = task id to release
                        	; Returns:
                        	;		v0 = E_Ok
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_ForceReleaseIOFocus:
FFFC2BE0 00106D13		ldi		$t0,#1
FFFC2BE4 013D1D33		sll		$t0,$t0,$a1
FFFC2BE8 00009637		lw		$t1,IOFocusTbl
FFFC2BEC C1060613
FFFC2BF0 00060633
FFFC2BF4 00062D83
FFFC2BF8 01ADFE33		and		$t2,$t1,$t0				; test bit for task
FFFC2BFC 060E0A63		beq		$t2,$x0,.noFocus	; does it even have the focus?
FFFC2C00 FFFD4D13		xor		$t0,$t0,#-1				; get inverted mask
FFFC2C04 01ADFDB3		and		$t1,$t1,$t0				; clear bit for task
FFFC2C08 00009637		sw		$t1,IOFocusTbl
FFFC2C0C C1060613
FFFC2C10 00060633
FFFC2C14 01B62023
FFFC2C18 00009637		lw		$t1,IOFocusNdx		; check if the focus being released is the current
FFFC2C1C C0860613
FFFC2C20 00060633
FFFC2C24 00062D83
FFFC2C28 00A99D13		sll		$t0,$a1,#10				; io focus. If so, switch focus
FFFC2C2C 01BD1463		bne		$t0,$t1,.notSame
FFFC2C30 EC1FF0EF		call	SwitchIOFocusHelper
                        	.notSame:
FFFC2C34 2E8D2E03		lw		$t2,IOF_NEXT[$t0]
FFFC2C38 020E4C63		blt		$t2,$x0,.done
FFFC2C3C 01AE0A63		beq		$t2,$t0,.pjSame
FFFC2C40 2F0D2D83		lw		$t1,IOF_PREV[$t0]
FFFC2C44 2FBE2823		sw		$t1,IOF_PREV[$t2]
FFFC2C48 2FCDA423		sw		$t2,IOF_NEXT[$t1]
FFFC2C4C 00000C63		bra		.0001
                        	.pjSame:
FFFC2C50 FFF06D93		ldi		$t1,#-1
FFFC2C54 00009637		sw		$t1,IOFocusNdx
FFFC2C58 C0860613
FFFC2C5C 00060633
FFFC2C60 01B62023
                        	.0001:
FFFC2C64 FFF06D93		ldi		$t1,#-1
FFFC2C68 2FBD2423		sw		$t1,IOF_NEXT[$t0]	
FFFC2C6C 2FBD2823		sw		$t1,IOF_PREV[$t0]	
                        	.done:
                        	.noFocus:
FFFC2C70 00006813		ldi		$v0,#E_Ok
FFFC2C74 0608080D		mtu		$v0,$v0
FFFC2C78 10000073		eret
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "../fmtk/io.r5a",1
                        	.file "../fmtk/io.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;Standard Devices are:
                        	
                        	;#		Device					Standard name
                        	
                        	;0		NULL device 			NUL		(OS built-in)
                        	;1		Keyboard (sequential)	KBD		(OS built-in)
                        	;2		Video (sequential)		VID		(OS built-in)
                        	;3		Printer (parallel 1)	LPT
                        	;4		Printer (parallel 2)	LPT2
                        	;5		RS-232 1				COM1	(OS built-in)
                        	;6		RS-232 2				COM2
                        	;7		RS-232 3				COM3
                        	;8		RS-232 4				COM4
                        	;9		Parallel xfer	  PTI
                        	;10		Floppy					FD0
                        	;11		Floppy					FD1
                        	;12		Hard disk				HD0
                        	;13		Hard disk				HD1
                        	;14
                        	;15   VIA							VIA1
                        	;16		SDCard					CARD1 	(OS built-in)
                        	;17
                        	;18
                        	;19
                        	;20
                        	;21
                        	;22
                        	;23
                        	;24
                        	;25
                        	;26
                        	;27
                        	;28		Audio						PSG1	(OS built-in)
                        	;29
                        	;30   Random Number		PRNG
                        	;31		Debug						DBG
                        	
                        	; The following must be at least 128 byte aligned
                        	DVF_Base		EQU		$A000
                        	DVF_Limit		EQU		$B000
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a2 = function
                        	;		a3 = data
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_IO:
FFFC2C7C 02006813		ldi		$v0,#32
FFFC2C80 0509F263		bgeu	$a1,$v0,.badDev
FFFC2C84 02006893		ldi		$v1,#32
FFFC2C88 031A7A63		bgeu	$a2,$v1,.badFunc
FFFC2C8C 00799813		sll		$v0,$a1,#7					; each device allowed 32 functions (*128)
FFFC2C90 002A1893		sll		$v1,$a2,#2					; function number *4
FFFC2C94 0000A637		add		$v0,$v0,#DVF_Base		; base address of function table
FFFC2C98 00060613
FFFC2C9C 01060833
FFFC2CA0 01186833		or		$v0,$v0,$v1
FFFC2CA4 00082803		lw		$v0,[$v0]
FFFC2CA8 00080A63		beq		$v0,$x0,.badFunc
FFFC2CAC 000800E7		call	[$v0]
                        	.xit:
FFFC2CB0 0608080D		mtu		$v0,$v0
FFFC2CB4 0608888D		mtu		$v1,$v1
FFFC2CB8 10000073		eret
                        	.badFunc:
FFFC2CBC 02206813		ldi		$v0,#E_BadDevOp
FFFC2CC0 FE0008E3		bra		.xit
                        	.badDev:
FFFC2CC4 02006813		ldi		$v0,#E_BadDevNum
FFFC2CC8 FE0004E3		bra		.xit
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = I/O channel
                        	;		a1 = points to function table
                        	;------------------------------------------------------------------------------
                        	
                        	CopyDevFuncTbl:
FFFC2CCC 00791813		sll		$v0,$a0,#7					; each device allowed 32 functions (*128)
FFFC2CD0 0000A637		add		$v0,$v0,#DVF_Base		; base address of function table
FFFC2CD4 00060613
FFFC2CD8 01060833
FFFC2CDC 02006D13		ldi		$t0,#32							; 32 functions to copy
                        	.again:
FFFC2CE0 0009AE03		lw		$t2,[$a1]
FFFC2CE4 01C82023		sw		$t2,[$v0]
FFFC2CE8 00498993		add		$a1,$a1,#4
FFFC2CEC 00480813		add		$v0,$v0,#4
FFFC2CF0 FFFD0D13		sub		$t0,$t0,#1
FFFC2CF4 FFA046E3		bgt		$t0,$x0,.again
FFFC2CF8 00008067		ret
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "TinyBasic.r5a",1
                        	.file "TinyBasic.r5a",1
                        	;****************************************************************;
                        	;                                                                ;
                        	;		Tiny BASIC for the CS01                                      ;
                        	;                                                                ;
                        	; Derived from a 68000 derivative of Palo Alto Tiny BASIC as     ;
                        	; published in the May 1976 issue of Dr. Dobb's Journal.         ;
                        	; Adapted to the 68000 by:                                       ;
                        	;	Gordon brndly						                         ;
                        	;	12147 - 51 Street					                         ;
                        	;	Edmonton AB  T5W 3G8					                     ;
                        	;	Canada							                             ;
                        	;	(updated mailing address for 1996)			                 ;
                        	;                                                                ;
                        	; Adapted to the CS01 by:                                        ;
                        	;    Robert Finch                                                ;
                        	;    Ontario, Canada                                             ;
                        	;	 robfinch<remove>@finitron.ca    	                             ;  
                        	;****************************************************************;
                        	;  Copyright (C) 2016-2020 by Robert Finch. This program may be	 ;
                        	;    freely distributed for personal use only. All commercial	 ;
                        	;		       rights are reserved.			                     ;
                        	;****************************************************************;
                        	;
                        	; Register Usage
                        	; $t2 = text pointer (global usage)
                        	; r3,r4 = inputs parameters to subroutines
                        	; a1 = return value
                        	;
                        	;* Vers. 1.0  1984/7/17	- Original version by Gordon brndly
                        	;*	1.1  1984/12/9	- Addition of '0x' print term by Marvin Lipford
                        	;*	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                        	
                        	CR		EQU	0x0D		;ASCII equates
                        	LINEFD	EQU	0x0A		; Don't use LF (same as load float instruction)
                        	TAB		EQU	0x09
                        	CTRLC	EQU	0x03
                        	CTRLH	EQU	0x08
                        	CTRLI	EQU	0x09
                        	CTRLJ	EQU	0x0A
                        	CTRLK	EQU	0x0B
                        	CTRLM   EQU 0x0D
                        	CTRLS	EQU	0x13
                        	CTRLX	EQU	0x18
                        	XON		EQU	0x11
                        	XOFF	EQU	0x13
                        	
                        	FILENAME	EQU		0x6C0
                        	FILEBUF		EQU		0x07F600
                        	OSSP		EQU		0x700
                        	TXTUNF		EQU		OSSP+4
                        	VARBGN		EQU		TXTUNF+4
                        	VAREND		EQU		VARBGN+4
                        	LOPVAR		EQU		VAREND+4
                        	STKGOS		EQU		LOPVAR+4
                        	CURRNT		EQU		STKGOS+4
                        	BUFFER		EQU		CURRNT+4
                        	BUFLEN		EQU		84
                        	LOPPT		EQU		BUFFER+84
                        	LOPLN		EQU		LOPPT+4
                        	LOPINC		EQU		LOPLN+4
                        	LOPLMT		EQU		LOPINC+4
                        	NUMWKA		EQU		LOPLMT+24
                        	STKINP		EQU		NUMWKA+4
                        	STKBOT		EQU		STKINP+4
                        	usrJmp		EQU		STKBOT+4
                        	IRQROUT		EQU		usrJmp+4
                        	
                        	OUTPTR		EQU		IRQROUT+4
                        	INPPTR		EQU		OUTPTR+4
                        	CursorFlash	EQU		INPPTR+4
                        	IRQFlag		EQU		CursorFlash+4
                        	
                        	;
                        	; Modifiable system constants:
                        	;
                        	;THRD_AREA	dw	0x04000000	; threading switch area 0x04000000-0x40FFFFF
                        	;bitmap dw	0x00100000	; bitmap graphics memory 0x04100000-0x417FFFF
                        	TXTBGN		EQU		0x001800	;TXT ;beginning of program memory
                        	ENDMEM		EQU		0x008000	; end of available memory
                        	STACKOFFS	EQU		0x07FFFC	; stack offset
                        	
                        	
                        	.file "TinyBasic.r5a",84
                        			code
FFFC2CFC 00000000			align	25
                        	
                        	;
                        	; Standard jump table. You can change these addresses if you are
                        	; customizing this interpreter for a different environment.
                        	;
                        	TinyBasic:
                        	GOSTART:	
FFFC2D00 0300006F			jmp	CSTART	;	Cold Start entry point
                        	GOWARM:	
FFFC2D04 0BC0006F			jmp	WSTART	;	Warm Start entry point
                        	GOOUT:	
FFFC2D08 5590106F			jmp	OUTC	;	Jump to character-out routine
                        	GOIN:	
FFFC2D0C 5590106F			jmp	INCH	;Jump to character-in routine
                        	GOAUXO:	
FFFC2D10 00000637			jmp	AUXOUT	;	Jump to auxiliary-out routine
FFFC2D14 23860067
                        	GOAUXI:	
FFFC2D18 00000637			jmp	AUXIN	;	Jump to auxiliary-in routine
FFFC2D1C 23A60067
                        	GOBYE:	
FFFC2D20 5750106F			jmp	BYEBYE	;	Jump to monitor, DOS, etc.
                        	
FFFC2D24 00000000		align	1
FFFC2D28 00000000
FFFC2D2C 00000000
                        	
                        	//message "CSTART"
                        	public CSTART:
	; First save off the link register and OS sp value
FFFC2D30 70E02023		sw		$sp,OSSP
FFFC2D34 00080737		ldi		$sp,#STACKOFFS	; initialize stack pointer
FFFC2D38 FFC70713
FFFC2D3C 00E06913		ldi		$a0,#14							; Get current tid
FFFC2D40 00000073		ecall
FFFC2D44 0008E9B3		mov		$a1,$v1
FFFC2D48 01806913		ldi		$a0,#24							; RequestIOFocus
FFFC2D4C 00000073		ecall
                        	;	call	_DBGHomeCursor[pc]
FFFC2D50 00006933		mov		a0,r0			; turn off keyboard echoing
                        	//	call	SetKeyboardEcho
                        	//	stz		CursorFlash
                        	//	ldx		#0x10000020	; black chars, yellow background
                        	;	stx		charToPrint
                        	;	call	_DBGClearScreen[pc]
FFFC2D54 FFFC5937		ldi		a0,#msgInit	;	tell who we are
FFFC2D58 A9C90913
FFFC2D5C 309010EF		call	PRMESG
FFFC2D60 00002937		ldi		a0,#TXTBGN	;	init. end-of-program pointer
FFFC2D64 80090913
FFFC2D68 71202223		sw		a0,TXTUNF
FFFC2D6C 00008937		ldi		a0,#ENDMEM	;	get address of end of memory
FFFC2D70 00090913
FFFC2D74 00080937		ldi		a0,#$7F800
FFFC2D78 80090913
FFFC2D7C 79202E23		sw		a0,STKBOT
FFFC2D80 00008937		ldi		a0,#ENDMEM
FFFC2D84 00090913
FFFC2D88 71202623		sw		a0,VAREND
FFFC2D8C CE090913		sub		a0,a0,#800 	;   100 vars
FFFC2D90 71202423		sw    a0,VARBGN
FFFC2D94 47C000EF		call  clearVars   ; clear the variable area
FFFC2D98 7A002223		sw		r0,IRQROUT
FFFC2D9C 70802903		lw    a0,VARBGN   ; calculate number of bytes free
FFFC2DA0 70402983		lw		a1,TXTUNF
FFFC2DA4 41390933		sub   a0,a0,a1
FFFC2DA8 00606993		ldi		a1,#6		; max 6 digits
FFFC2DAC 00A06A13		ldi		a2,#10	; base 10
FFFC2DB0 7E4010EF		call  PRTNUM
FFFC2DB4 FFFC5937		ldi		a0,#msgBytesFree
FFFC2DB8 B3D90913
FFFC2DBC 2A9010EF		call	PRMESG
                        	WSTART:
FFFC2DC0 70002823		sw		x0,LOPVAR   ; initialize internal variables
FFFC2DC4 70002A23		sw		x0,STKGOS
FFFC2DC8 70002C23		sw		x0,CURRNT	;	current line number pointer = 0
FFFC2DCC 00080737		ldi		$sp,#STACKOFFS	;	init S.P. again, just in case
FFFC2DD0 FFC70713
FFFC2DD4 FFFC5937		ldi		a0,#msgReady	;	display "Ready"
FFFC2DD8 B4A90913
FFFC2DDC 289010EF		call	PRMESG
                        	BASPRMPT:
FFFC2DE0 00E06913		ldi		a0,#14		; get current tid
FFFC2DE4 00000073		ecall
FFFC2DE8 0008E933		mov		a0,v1
FFFC2DEC 935FD0EF		call	PutHexByte
FFFC2DF0 03E06913		ldi		a0,#'>'		; Prompt with a '>' and
FFFC2DF4 470010EF		call	GETLN		; read a line.
FFFC2DF8 1BD010EF		call	TOUPBUF 	; convert to upper case
FFFC2DFC 000E64B3		mov		$s6,$t2		; save pointer to end of line
FFFC2E00 71C06E13		ldi		$t2,#BUFFER	; point to the beginning of line
FFFC2E04 10D010EF		call	TSTNUM		; is there a number there?
FFFC2E08 17D010EF		call	IGNBLK		; skip trailing blanks
FFFC2E0C 000E4483		lbu		$s6,[$t2]
FFFC2E10 00D4C493		xor		$s6,$s6,#CR	; s6 = flag empty line
                        	; does line no. exist? (or nonzero?)
FFFC2E14 28088663		beq		v1,x0,DIRECT		; if not, it's a direct statement
FFFC2E18 00100DB7		ldi		$t1,#$FFFFF
FFFC2E1C FFFD8D93
FFFC2E20 010DD863		ble		v0,$t1,ST2	; see if line no. is <= 16 bits
FFFC2E24 FFFC5937		ldi		a0,#msgLineRange	; if not, we've overflowed
FFFC2E28 B6590913
FFFC2E2C 3F40106F		jmp		ERROR
                        	ST2:
FFFC2E30 00086933	  mov		$a0,$v0		; a0 = line number
FFFC2E34 000E6433	  mov		$s5,$t2			; save line buffer pointer
FFFC2E38 FFCE0E13		sub		$t2,$t2,#4
FFFC2E3C 012E2023	  sw		$a0,[$t2]		;	This will end up in buffer
FFFC2E40 518010EF		call	FNDLN		; find this line in save area
FFFC2E44 000EE533		mov		$s7,$t3		; save possible line pointer
FFFC2E48 00080663		beq		$v0,$x0,INSLINE	; if not found, insert
FFFC2E4C 000EE933		mov		$a0,$t3
FFFC2E50 044000EF		call	DeleteLine
                        	INSLINE:
FFFC2E54 F80486E3		beq		$s6,$x0,BASPRMPT	; line was empty
FFFC2E58 00046933		mov		$a0,$s5			; a0 = buffer pointer	
                        		; GetBuflen just get the length of the text.
                        		; A line number is stuffed just before the text
                        		; so length needs to be adjusted by 4.
FFFC2E5C 0A0000EF		call	GetBuflen
FFFC2E60 00480393		add		$s4,$v0,#4
FFFC2E64 00056933		mov		$a0,$s7
FFFC2E68 0003E9B3		mov		$a1,$s4
FFFC2E6C 0BC000EF		call	OpenSpace
FFFC2E70 00081863		bne		$v0,$x0,.0001	; space available?
FFFC2E74 FFFC5937		ldi		a0,#msgTooBig	; no space available
FFFC2E78 C3790913
FFFC2E7C 3A40106F		jmp		ERROR
                        	.0001:
FFFC2E80 00056933		mov		$a0,$s7			; target
FFFC2E84 FFC40993		sub		$a1,$s5,#4	; source (incl lineno)
FFFC2E88 0003EA33		mov		$a2,$s4			; length
FFFC2E8C 050000EF		call	InsertLine
FFFC2E90 F40008E3		bra		BASPRMPT
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = pointer to line to delete
                        	; Modifies:
                        	;		t0,t1,t2,t3
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	DeleteLine:
                        		; Find the end of the line to delete
FFFC2E94 00490D13		add		$t0,$a0,#4		; t0 = pointer to line past line number
FFFC2E98 00D06E13		ldi		$t2,#CR
FFFC2E9C 70402E83		lw		$t3,TXTUNF		; last text address
                        	.0002:
FFFC2EA0 000D4D83		lbu		$t1,[$t0]
FFFC2EA4 000D8A63		beq		$t1,$x0,.0003	; might be null
FFFC2EA8 01CD8663		beq		$t1,$t2,.0001	; lines end with CR
FFFC2EAC 001D0D13		add		$t0,$t0,#1
FFFC2EB0 FFDD68E3		bltu	$t0,$t3,.0002	; end of program?
                        	.0001:
FFFC2EB4 001D0D13		add		$t0,$t0,#1
                        	.0003:
                        		; pull text after eol overtop
FFFC2EB8 000D4F03		lbu		$t4,[$t0]			; copy from next line
FFFC2EBC 01E90023		sb		$t4,[$a0]			; overtop deleted line
FFFC2EC0 001D0D13		add		$t0,$t0,#1		; increment pointers
FFFC2EC4 00190913		add		$a0,$a0,#1
FFFC2EC8 FFAEF8E3		bleu	$t0,$t3,.0003	; to end of program
                        		; update end of text
FFFC2ECC 412D0933		sub		$a0,$t0,$a0		; difference of pointers = length
FFFC2ED0 412E8EB3		sub		$t3,$t3,$a0		
FFFC2ED4 71D02223		sw		$t3,TXTUNF
FFFC2ED8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = insertion point
                        	; 	a1 = source buffer
                        	; 	a2 = length
                        	; Modifies:
                        	;		a0,a1,a2,t1
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	InsertLine:
FFFC2EDC 000A0E63		beq		$a2,$x0,.done		; zero length? Probably a SW error
                        	.0001:
FFFC2EE0 0009CD83		lbu		$t1,[$a1]				; get from source text
FFFC2EE4 01B90023		sb		$t1,[$a0]				; store to insertion point
FFFC2EE8 00198993		add		$a1,$a1,#1			; increment pointers
FFFC2EEC 00190913		add		$a0,$a0,#1
FFFC2EF0 FFFA0A13		sub		$a2,$a2,#1			; decrement length
FFFC2EF4 FF4066E3		bgtu	$a2,$x0,.0001
                        	.done:
FFFC2EF8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; GetBuflen - get the length of text in a buffer. The length is taken up to
                        	; the first null character or carriage return character encountered.
                        	;
                        	; Parameters:
                        	;		a0 = pointer to buffer
                        	; Modifies:
                        	;		t2,t3,t5
                        	; Returns:
                        	;		v0 = length of data in buffer
                        	;------------------------------------------------------------------------------
                        	
                        	GetBuflen:
FFFC2EFC 00006813		ldi		$v0,#0
FFFC2F00 00D06E93		ldi		$t3,#CR
FFFC2F04 00096FB3		mov		$t5,$a0
                        	.0002:
FFFC2F08 000FCE03		lbu		$t2,[$t5]
FFFC2F0C 001F8F93		add		$t5,$t5,#1
FFFC2F10 000E0A63		beq		$t2,$x0,.0001
FFFC2F14 01DE0663		beq		$t2,$t3,.0004
FFFC2F18 00180813		add		$v0,$v0,#1
FFFC2F1C FE0006E3		bra		.0002
                        	.0004:
FFFC2F20 00180813		add		$v0,$v0,#1
                        	.0001:
FFFC2F24 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = place to insert line
                        	; 	a1 = buffer length
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		v0 = 1 if successful, 0 if not enough room available
                        	;------------------------------------------------------------------------------
                        	
                        	OpenSpace:
FFFC2F28 70402E03		lw		$t2,TXTUNF
FFFC2F2C 000E6EB3		mov		$t3,$t2				; t3 = old end of text
FFFC2F30 013E0E33		add		$t2,$t2,$a1		; increment end of text by buffer length
FFFC2F34 70802D83		lw		$t1,VARBGN		; compare to start of variables
FFFC2F38 03BE7263		bgeu	$t2,$t1,.noSpace	; enough room?
FFFC2F3C 71C02223		sw		$t2,TXTUNF		; yes, set new end of text
                        	.0003:
FFFC2F40 000ECF83		lbu		$t5,[$t3]			; copy old text
FFFC2F44 01FE0023		sb		$t5,[$t2]			; to new text loc
FFFC2F48 FFFE8E93		sub		$t3,$t3,#1		; decrement pointers
FFFC2F4C FFFE0E13		sub		$t2,$t2,#1
FFFC2F50 FF2EF8E3		bgeu	$t3,$a0,.0003	; until insert point reached
FFFC2F54 00106813		ldi		$v0,#1				; return success
FFFC2F58 00008067		ret
                        	.noSpace:
FFFC2F5C 00006813		ldi		$v0,#0
FFFC2F60 00008067		ret	
                        	
                        	;******************************************************************
                        	;
                        	; *** Tables *** DIRECT *** EXEC ***
                        	;
                        	; This section of the code tests a string against a table. When
                        	; a match is found, control is transferred to the section of
                        	; code according to the table.
                        	;
                        	; At 'EXEC', r8 should point to the string, r9 should point to
                        	; the character table, and r10 should point to the execution
                        	; table. At 'DIRECT', r8 should point to the string, r9 and
                        	; r10 will be set up to point to TAB1 and TAB1_1, which are
                        	; the tables of all direct and statement commands.
                        	;
                        	; A '.' in the string will terminate the test and the partial
                        	; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                        	; 'PRIN.', or 'PRINT' will all match 'PRINT'.
                        	;
                        	; There are two tables: the character table and the execution
                        	; table. The character table consists of any number of text items.
                        	; Each item is a string of characters with the last character's
                        	; high bit set to one. The execution table holds a 32-bit
                        	; execution addresses that correspond to each entry in the
                        	; character table.
                        	;
                        	; The end of the character table is a 0 byte which corresponds
                        	; to the default routine in the execution table, which is
                        	; executed if none of the other table items are matched.
                        	;
                        	; Character-matching tables:
                        	TAB1:
FFFC2F64 D453494C		db	"LIS",'T'+0x80        ; Direct commands
FFFC2F68 C4414F4C		db	"LOA",'D'+0x80
FFFC2F6C 52D7454E		db	"NE",'W'+0x80
FFFC2F6F 53CE5552		db	"RU",'N'+0x80
FFFC2F72 C5564153		db	"SAV",'E'+0x80
                        	TAB2:
FFFC2F76 D458454E		db	"NEX",'T'+0x80         ; Direct / statement
FFFC2F7A 49D4454C		db	"LE",'T'+0x80
FFFC2F7D 4F47C649		db	"I",'F'+0x80
FFFC2F7F CF544F47		db	"GOT",'O'+0x80
FFFC2F83 55534F47		db	"GOSU",'B'+0x80
FFFC2F87 544552C2
FFFC2F88 55544552		db	"RETUR",'N'+0x80
FFFC2F8C 4552CE52
FFFC2F8E 46CD4552		db	"RE",'M'+0x80
FFFC2F91 49D24F46		db	"FO",'R'+0x80
FFFC2F94 55504E49		db	"INPU",'T'+0x80
FFFC2F98 495250D4
FFFC2F99 4E495250		db	"PRIN",'T'+0x80
FFFC2F9D 4B4F50D4
FFFC2F9E C54B4F50		db	"POK",'E'+0x80
FFFC2FA2 454B4F50		db	"POKE",'W'+0x80
FFFC2FA6 4B4F50D7
FFFC2FA7 454B4F50		db	"POKE",'H'+0x80
FFFC2FAB 454959C8
FFFC2FAC 4C454959		db	"YIEL",'D'+0x80
FFFC2FB0 4F5453C4
FFFC2FB1 D04F5453		db	"STO",'P'+0x80
FFFC2FB5 53C55942		db	"BY",'E'+0x80
FFFC2FB8 43D35953		db	"SY",'S'+0x80
FFFC2FBB 43D34C43		db	"CL",'S'+0x80
FFFC2FBE 52D24C43	    db  "CL",'R'+0x80
FFFC2FC1 C6434452	    db	"RDC",'F'+0x80
FFFC2FC5 52494E4F	    db	"ONIR",'Q'+0x80
FFFC2FC9 494157D1
FFFC2FCA D4494157	    db	"WAI",'T'+0x80
FFFC2FCE 45455000		db	0
                        	TAB4:
FFFC2FCF CB454550		db	"PEE",'K'+0x80         ;Functions
FFFC2FD3 4B454550		db	"PEEK",'W'+0x80
FFFC2FD7 454550D7
FFFC2FD8 4B454550		db	"PEEK",'H'+0x80
FFFC2FDC C44E52C8
FFFC2FDD 41C44E52		db	"RN",'D'+0x80
FFFC2FE0 53D34241		db	"AB",'S'+0x80
FFFC2FE3 54CE4753		db  "SG",'N'+0x80
FFFC2FE6 CB434954		db	"TIC",'K'+0x80
FFFC2FEA C55A4953		db	"SIZ",'E'+0x80
FFFC2FEE 41D25355		db  "US",'R'+0x80
FFFC2FF1 4F4C4C41	  db	"ALLOCMB",'X'+0x80
FFFC2FF5 D8424D43
FFFC2FF9 444E4553	  db	"SENDMS",'G'+0x80
FFFC2FFD 57C7534D
FFFC3000 54494157	  db	"WAITMS",'G'+0x80
FFFC3004 00C7534D
FFFC3007 00CF5400		db	0
                        	TAB5:
FFFC3008 5300CF54		db	"T",'O'+0x80           ;"TO" in "FOR"
FFFC300A 45545300		db	0
                        	TAB6:
FFFC300B D0455453		db	"STE",'P'+0x80         ;"STEP" in "FOR"
FFFC300F 3CBD3E00		db	0
                        	TAB8:
FFFC3010 BE3CBD3E		db	'>','='+0x80           ;Relational operators
FFFC3012 BDBEBE3C		db	'<','>'+0x80
FFFC3014 BD3CBDBE		db	'>'+0x80
FFFC3015 BCBD3CBD		db	'='+0x80
FFFC3016 00BCBD3C		db	'<','='+0x80
FFFC3018 4E4100BC		db	'<'+0x80
FFFC3019 C44E4100		db	0
                        	TAB9:
FFFC301A 00C44E41	    db  "AN",'D'+0x80
FFFC301D 00D24F00	    db  0
                        	TAB10:
FFFC301E 0000D24F	    db  "O",'R'+0x80
FFFC3020 32800000	    db  0
                        	
                        	;* Execution address tables:
                        	; We save some bytes by specifiying only the low order 16 bits of the address
                        	;
FFFC3021 48328000		align	
                        	
                        	TAB1_1:
FFFC3022 37483280		dh	LISTX			;Direct commands
FFFC3024 31283748		dh	LOAD3
FFFC3026 31503128		dh	NEW
FFFC3028 37B03150		dh	RUN
FFFC302A 347C37B0		dh	SAVE3
                        	TAB2_1:
FFFC302C 3600347C		dh	NEXT		;	Direct / statement
FFFC302E 34F43600		dh	LET
FFFC3030 31E434F4		dh	IF0
FFFC3032 336831E4		dh	GOTO
FFFC3034 33AC3368		dh	GOSUB
FFFC3036 350033AC		dh	RETURN
FFFC3038 33F03500		dh	IF2			; REM
FFFC303A 353433F0		dh	FOR
FFFC303C 32C83534		dh	INPUT
FFFC303E 390C32C8		dh	PRINT
FFFC3040 3938390C		dh	POKE
FFFC3042 39643938		dh	POKEW
FFFC3044 31443964		dh	POKEH
FFFC3046 313C3144		dh	YIELD0
FFFC3048 2D20313C		dh	STOP
FFFC304A 399C2D20		dh	GOBYE
FFFC304C 027D399C		dh	SYSX
FFFC304E 3208027D		dh	_cls
FFFC3050 027F3208		dh  _clr
FFFC3052 3248027F		dh	_rdcf
FFFC3054 32703248		dh  ONIRQ
FFFC3056 35F43270		dh	WAITIRQ
FFFC3058 3FB835F4		dh	DEFLT
                        	TAB4_1:
FFFC305A 3FD03FB8		dh	PEEK			;Functions
FFFC305C 3FE83FD0		dh	PEEKW
FFFC305E 40403FE8		dh	PEEKH
FFFC3060 00004040		dh	RND
FFFC3062 40D40000		dh	ABS
FFFC3064 40C040D4		dh  SGN
FFFC3066 411040C0		dh	TICKX
FFFC3068 40004110		dh	SIZEX
FFFC306A 487C4000		dh  USRX
FFFC306C 48EC487C		dh	ALLOCMBX
FFFC306E 498848EC		dh	SENDMSG
FFFC3070 3D944988		dh	WAITMSG
FFFC3072 34103D94		dh	XP40
                        	TAB5_1
FFFC3074 42183410		dh	FR1			;"TO" in "FOR"
FFFC3076 342C4218		dh	QWHAT
                        	TAB6_1
FFFC3078 3434342C		dh	FR2			;"STEP" in "FOR"
FFFC307A 3B4C3434		dh	FR3
                        	TAB8_1
FFFC307C 3B643B4C		dh	XP11	;>=		Relational operators
FFFC307E 3B7C3B64		dh	XP12	;<>
FFFC3080 3BAC3B7C		dh	XP13	;>
FFFC3082 3B943BAC		dh	XP15	;=
FFFC3084 3BC43B94		dh	XP14	;<=
FFFC3086 3C043BC4		dh	XP16	;<
FFFC3088 3A5C3C04		dh	XP17
                        	TAB9_1
FFFC308A 3A703A5C	    dh  XP_AND
FFFC308C 39FC3A70	    dh  XP_ANDX
                        	TAB10_1
FFFC308E 3A1039FC	    dh  XP_OR
FFFC3090 00003A10	    dh  XP_ORX
                        	
                        	;*
                        	; r3 = match flag (trashed)
                        	; r9 = text table
                        	; r10 = exec table
                        	; r11 = trashed
FFFC3092 00000000		align	1
FFFC3096 00000000
FFFC309A 00000000
FFFC309E 3EB70000
                        	
                        	//message "DIRECT"
                        	DIRECT:
FFFC30A0 FFFC3EB7		ldi		$t3,#TAB1
FFFC30A4 F64E8E93
FFFC30A8 FFFC3F37		ldi		$t4,#TAB1_1
FFFC30AC 022F0F13
                        	EXEC:
FFFC30B0 6D4010EF		call	IGNBLK		; ignore leading blanks
FFFC30B4 000E6FB3		mov		$t5,$t2		; save the pointer
FFFC30B8 000061B3		mov		r3,r0		; clear match flag
                        	EXLP:
FFFC30BC 000E4903		lbu		a0,[$t2]		; get the program character
FFFC30C0 001E0E13		add		$t2,$t2,#1
FFFC30C4 000EC983		lbu		a1,[$t3]		; get the table character
FFFC30C8 00099663		bne		a1,x0,EXNGO		; If end of table,
FFFC30CC 000FEE33		mov		$t2,$t5		;	restore the text pointer and...
FFFC30D0 04000263		bra		EXGO		;   execute the default.
                        	EXNGO:
FFFC30D4 04390063		beq		a0,r3,EXGO	; Else check for period... if so, execute
FFFC30D8 07F9F993		and		a1,a1,#0x7f	; ignore the table's high bit
FFFC30DC 03298263		beq		a1,a0,EXMAT	;		is there a match?
FFFC30E0 002F0F13		add		$t4,$t4,#2	;if not, try the next entry
FFFC30E4 000FEE33		mov		$t2,$t5		; reset the program pointer
FFFC30E8 000061B3		mov		r3,x0		; sorry, no match
                        	EX1:
FFFC30EC 000EC903		lbu		a0,[$t3]		; get to the end of the entry
FFFC30F0 001E8E93		add		$t3,$t3,#1
FFFC30F4 08097D93		and		$t1,$a0,#$80
FFFC30F8 FE0D8AE3		beq		$t1,$r0,EX1	; test for bit 7 set
FFFC30FC FC0000E3		bra		EXLP		; back for more matching
                        	EXMAT:
FFFC3100 02E06193		ldi		r3,#'.'		; we've got a match so far
FFFC3104 000EC903		lbu		a0,[$t3]		; end of table entry?
FFFC3108 001E8E93		add		$t3,$t3,#1
FFFC310C 08097D93		and		$t1,$a0,#$80
FFFC3110 FA0D86E3		beq		$t1,$r0,EXLP		; test for bit 7 set, if not, go back for more
                        	EXGO:
                        		; execute the appropriate routine
FFFC3114 000F5903		lhu		a0,[$t4]	; get the low mid order byte
FFFC3118 FFFC0637		or		a0,a0,#$FFFC0000	; add in ROM base
FFFC311C 00060613
FFFC3120 01266933
FFFC3124 00090067		jmp		[a0]
                        	
                        	    
                        	;******************************************************************
                        	;
                        	; What follows is the code to execute direct and statement
                        	; commands. Control is transferred to these points via the command
                        	; table lookup code of 'DIRECT' and 'EXEC' in the last section.
                        	; After the command is executed, control is transferred to other
                        	; sections as follows:
                        	;
                        	; For 'LISTX', 'NEW', and 'STOP': go back to the warm start point.
                        	; For 'RUN': go execute the first stored line if any; else go
                        	; back to the warm start point.
                        	; For 'GOTO' and 'GOSUB': go execute the target line.
                        	; For 'RETURN' and 'NEXT'; go back to saved return line.
                        	; For all others: if 'CURRNT' is 0, go to warm start; else go
                        	; execute next command. (This is done in 'FINISH'.)
                        	;
                        	;******************************************************************
                        	;
                        	; *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                        	;
                        	; 'NEW<CR>' sets TXTUNF to point to TXTBGN
                        	;
                        	
                        	NEW:
FFFC3128 0A8010EF		call	ENDCHK
FFFC312C 00002837		ldi		v0,#TXTBGN
FFFC3130 80080813
FFFC3134 71002223		sw		v0,TXTUNF	;	set the end pointer
FFFC3138 0D8000EF		call  clearVars
                        	
                        	; 'STOP<CR>' goes back to WSTART
                        	;
                        	STOP:
FFFC313C 094010EF		call	ENDCHK
FFFC3140 C81FF06F		jmp		WSTART		; WSTART will reset the stack
                        	
                        	;------------------------------------------------------------------------------
                        	; YIELD suspends execution of TinyBasic by switching to the next ready task.
                        	;------------------------------------------------------------------------------
                        	
                        	YIELD0:
FFFC3144 00D06913		ldi		a0,#13
FFFC3148 00000073		ecall
FFFC314C 2140006F		jmp		FINISH
                        	
                        	;------------------------------------------------------------------------------
                        	; 'RUN<CR>' finds the first stored line, stores its address
                        	; in CURRNT, and starts executing it. Note that only those
                        	; commands in TAB2 are legal for a stored program.
                        	;
                        	; There are 3 more entries in 'RUN':
                        	; 'RUNNXL' finds next line, stores it's address and executes it.
                        	; 'RUNTSL' stores the address of this line and executes it.
                        	; 'RUNSML' continues the execution on same line.
                        	;
                        	RUN:
FFFC3150 080010EF		call	ENDCHK
FFFC3154 00002E37		ldi		$t2,#TXTBGN	;	set pointer to beginning
FFFC3158 800E0E13
FFFC315C 71C02C23		sw		$t2,CURRNT
FFFC3160 0B0000EF		call  clearVars
                        	
                        	RUNNXL:					; RUN <next line>
FFFC3164 71802E03		lw		$t2,CURRNT	; executing a program?
FFFC3168 000E1463		bne		$t2,x0,RUN3	; if not, we've finished a direct stat.
                        	RUN2:
FFFC316C C55FF06F		jmp		WSTART
                        	RUN3:
FFFC3170 7A402903		lw		a0,IRQROUT		; are we handling IRQ's ?
FFFC3174 02090E63		beq		a0,x0,RUN1
FFFC3178 7B402D83		lw		$t1,IRQFlag		; was there an IRQ ?
FFFC317C 020D8A63		beq		$t1,x0,RUN1
FFFC3180 7A002A23		sw		x0,IRQFlag
FFFC3184 2D0010EF		call	PUSHA_		; the same code as a GOSUB
FFFC3188 FF470713		sub		$sp,$sp,#12
FFFC318C 71402903		lw		a0,STKGOS
FFFC3190 01272023		sw		a0,[$sp]
FFFC3194 71802903		lw		a0,CURRNT
FFFC3198 01272223		sw		a0,4[$sp]
FFFC319C 01C72423		sw		$t2,8[$sp]
FFFC31A0 70002823		sw		x0,LOPVAR		; load new values
FFFC31A4 70E02A23		sw		$sp,STKGOS
FFFC31A8 7A402E83		lw		$t3,IRQROUT
FFFC31AC 00000C63		bra		RUNTSL
                        	RUN1:
FFFC31B0 000E6EB3		mov		$t3,$t2
FFFC31B4 00006933		mov		a0,x0
FFFC31B8 1C0010EF		call	FNDLNP		; else find the next line number
FFFC31BC 70402D83		lw		$t1,TXTUNF	; if we've fallen off the end, stop
FFFC31C0 FBBEF6E3		bgeu	$t3,$t1,RUN2
                        	
                        	RUNTSL:					; RUN <this line>
FFFC31C4 71D02C23		sw		$t3,CURRNT	; set CURRNT to point to the line no.
FFFC31C8 004E8E13		add		$t2,$t3,#4	; set the text pointer to
                        	
                        	RUNSML:                 ; RUN <same line>
FFFC31CC 668010EF		call	CHKIO		; see if a control-C was pressed
FFFC31D0 FFFC3EB7		ldi		$t3,#TAB2		; find command in TAB2
FFFC31D4 F76E8E93
FFFC31D8 FFFC3F37		ldi		$t4,#TAB2_1
FFFC31DC 02CF0F13
FFFC31E0 ED1FF06F		jmp		EXEC		; and execute it
                        	
                        	
                        	;******************************************************************
                        	; 'GOTO expr<CR>' evaluates the expression, finds the target
                        	; line, and jumps to 'RUNTSL' to do it.
                        	;******************************************************************
                        	;
                        	GOTO:
FFFC31E4 7E4000EF		call	OREXPR		;evaluate the following expression
FFFC31E8 000862B3		mov   r5,v0
FFFC31EC 7E5000EF		call 	ENDCHK		;must find end of line
FFFC31F0 0002E933		mov   a0,r5
FFFC31F4 164010EF		call 	FNDLN		; find the target line
FFFC31F8 FC0816E3		bne		v0,x0,RUNTSL; go do it
FFFC31FC FFFC5937		ldi		a0,#msgBadGotoGosub
FFFC3200 C0590913
FFFC3204 01C0106F		jmp		ERROR		; no such line no.
                        	
                        	_clr:
FFFC3208 008000EF	    call    clearVars
FFFC320C 1540006F	    jmp     FINISH
                        	
                        	; Clear the variable area of memory
                        	clearVars:
FFFC3210 FF870713		sub		$sp,$sp,#8
FFFC3214 00672023		sw		r6,[$sp]
FFFC3218 00172223		sw		$ra,4[$sp]
FFFC321C 06406313	  ldi   r6,#100    	; number of word pairs to clear
FFFC3220 70802803	  lw    v0,VARBGN
                        	.cv1:
FFFC3224 00082023	  sw		x0,[$v0]		; variable name
FFFC3228 00082223	  sw		x0,4[$v0]		; and value
FFFC322C 00880813	  add		v0,v0,#8
FFFC3230 FFF30313	  sub		r6,r6,#1
FFFC3234 FE6048E3		bgt		r6,x0,.cv1
FFFC3238 00072303	  lw		r6,[$sp]
FFFC323C 00472083	  lw		$ra,4[$sp]
FFFC3240 00870713	  add		$sp,$sp,#8
FFFC3244 00008067	  ret
                        	
                        	;******************************************************************
                        	; ONIRQ <line number>
                        	; ONIRQ sets up an interrupt handler which acts like a specialized
                        	; subroutine call. ONIRQ is coded like a GOTO that never executes.
                        	;******************************************************************
                        	;
                        	ONIRQ:
FFFC3248 780000EF		call	OREXPR		;evaluate the following expression
FFFC324C 000862B3		mov   r5,v0
FFFC3250 781000EF		call 	ENDCHK		;must find end of line
FFFC3254 0002E933		mov   a0,r5
FFFC3258 100010EF		call 	FNDLN		; find the target line
FFFC325C 00081663		bne		v0,r0,ONIRQ1
FFFC3260 7A002223		sw		x0,IRQROUT
FFFC3264 0FC0006F		jmp		FINISH
                        	ONIRQ1:
FFFC3268 7BD02223		sw		$t3,IRQROUT
FFFC326C 0F40006F		jmp		FINISH
                        	
                        	WAITIRQ:
FFFC3270 5C4010EF		call	CHKIO		; see if a control-C was pressed
FFFC3274 7B402D83		lw		$t1,IRQFlag
FFFC3278 FE0D8CE3		beq		$t1,x0,WAITIRQ
FFFC327C 0E40006F		jmp		FINISH
                        	
                        	
                        	;******************************************************************
                        	; LIST
                        	;
                        	; LISTX has two forms:
                        	; 'LIST<CR>' lists all saved lines
                        	; 'LIST #<CR>' starts listing at the line #
                        	; Control-S pauses the listing, control-C stops it.
                        	;******************************************************************
                        	;
                        	LISTX:
FFFC3280 490010EF		call		TSTNUM		; see if there's a line no.
FFFC3284 000862B3		mov      r5,v0
FFFC3288 749000EF		call		ENDCHK		; if not, we get a zero
FFFC328C 0002E933		mov      a0,r5
FFFC3290 0C8010EF		call		FNDLN		; find this or next line
                        	LS1:
FFFC3294 00081663		bne		v0,r0,LS4
                        	LS5:
FFFC3298 70402D83		lw		$t1,TXTUNF
FFFC329C B3BEF2E3		bgeu	$t3,$t1,WSTART	; warm start if we passed the end
                        	LS4:
FFFC32A0 000EE933		mov		a0,$t3
FFFC32A4 3C4010EF		call	PRTLN		; print the line
FFFC32A8 00086EB3		mov		$t3,$v0		; set pointer for next
FFFC32AC 588010EF		call	CHKIO		; check for listing halt request
FFFC32B0 00080A63		beq		v0,x0,LS3
FFFC32B4 01306D93		ldi		$t1,#CTRLS
FFFC32B8 01B81663		bne		v0,$t1,LS3; pause the listing?
                        	LS2:
FFFC32BC 578010EF		call 	CHKIO		; if so, wait for another keypress
FFFC32C0 FE080EE3		beq		v0,r0,LS2
                        	LS3:
                        	;	mov		$v0,$x0
FFFC32C4 FC000AE3		bra		LS5
                        	;	mov		a0,r0
                        	;	call	FNDSKP	;FNDLNP		; find the next line
                        	;	bra		LS1
                        	
                        	
                        	;******************************************************************
                        	; PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                        	; where '....' is a list of expressions, formats, back-arrows,
                        	; and strings.	These items a separated by commas.
                        	;
                        	; A format is a pound sign followed by a number.  It controls
                        	; the number of spaces the value of an expression is going to
                        	; be printed in.  It stays effective for the rest of the print
                        	; command unless changed by another format.  If no format is
                        	; specified, 11 positions will be used.
                        	;
                        	; A string is quoted in a pair of single- or double-quotes.
                        	;
                        	; An underline (back-arrow) means generate a <CR> without a <LF>
                        	;
                        	; A <CR LF> is generated after the entire list has been printed
                        	; or if the list is empty.  If the list ends with a semicolon,
                        	; however, no <CR LF> is generated.
                        	;******************************************************************
                        	;
                        	PRINT:
FFFC32C8 00B06293		ldi		r5,#11		; D4 = number of print spaces
FFFC32CC 3F8010EF		call	TSTC		; if null list and ":"
FFFC32D0 0000003A		dw		':'
FFFC32D4 00000663		bra		PR2
FFFC32D8 584010EF		call	CRLF		; give CR-LF and continue
FFFC32DC EF1FF06F		jmp		RUNSML		;		execution on the same line
                        	PR2:
FFFC32E0 3E4010EF		call	TSTC		;if null list and <CR>
FFFC32E4 0000000D		dw		CR
FFFC32E8 00000663		bra		PR0
FFFC32EC 570010EF		call	CRLF		;also give CR-LF and
FFFC32F0 E75FF06F		jmp		RUNNXL		;execute the next line
                        	PR0:
FFFC32F4 3D0010EF		call	TSTC		;else is it a format?
FFFC32F8 00000023		dw		'#'
FFFC32FC 00000863		bra		PR1
FFFC3300 6C8000EF		call	OREXPR		; yes, evaluate expression
FFFC3304 000862B3		mov		r5,v0	; and save it as print width
FFFC3308 02000263		bra		PR3		; look for more to print
                        	PR1:
FFFC330C 3B8010EF		call	TSTC	;	is character expression? (MRL)
FFFC3310 00000024		dw		'$'
FFFC3314 00000863		bra		PR4
FFFC3318 6B0000EF		call	OREXPR	;	yep. Evaluate expression (MRL)
FFFC331C 9EDFF0EF		call	GOOUT	;	print low byte (MRL)
FFFC3320 00000663		bra		PR3		;look for more. (MRL)
                        	PR4:
FFFC3324 1DC010EF		call	QTSTG	;	is it a string?
                        		; the following branch must occupy only 1 word!
FFFC3328 02000063		bra		PR8		;	if not, must be an expression
                        	PR3:
FFFC332C 398010EF		call		TSTC	;	if ",", go find next
FFFC3330 0000002C		dw		','
FFFC3334 00000663		bra		PR6
FFFC3338 65D000EF		call		FIN		;in the list.
FFFC333C FA000CE3		bra		PR0
                        	PR6:
FFFC3340 51C010EF		call		CRLF		;list ends here
FFFC3344 01C0006F		jmp		FINISH
                        	PR8:
FFFC3348 680000EF		call	OREXPR		; evaluate the expression
FFFC334C 00086933		mov		a0,v0
FFFC3350 00506993		ldi		a1,#5		; set the width
FFFC3354 00A06A13		ldi		a2,#10
FFFC3358 23C010EF		call	PRTNUM		; print its value
FFFC335C FC0008E3		bra		PR3			; more to print?
                        	
                        	
                        	FINISH:
FFFC3360 635000EF		call	FIN		; Check end of command
FFFC3364 6B50006F		jmp		QWHAT	; print "What?" if wrong
                        	
                        	
                        	;*******************************************************************
                        	;
                        	; *** GOSUB *** & RETURN ***
                        	;
                        	; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                        	; except that the current text pointer, stack pointer, etc. are
                        	; saved so that execution can be continued after the subroutine
                        	; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                        	; recursive), the save area must be stacked.  The stack pointer
                        	; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                        	; If we are in the main routine, 'STKGOS' is zero (this was done
                        	; in the initialization section of the interpreter), but we still
                        	; save it as a flag for no further 'RETURN's.
                        	;******************************************************************
                        	;
                        	GOSUB:
FFFC3368 0EC010EF		call	PUSHA_		; save the current 'FOR' parameters
FFFC336C 65C000EF		call	OREXPR		; get line number
FFFC3370 00086933		mov		$a0,$v0
FFFC3374 7E5000EF		call	FNDLN		; find the target line
FFFC3378 00081863		bne		v0,r0,gosub1
FFFC337C FFFC5937		ldi		a0,#msgBadGotoGosub
FFFC3380 C0590913
FFFC3384 69D0006F		jmp		ERROR		; if not there, say "How?"
                        	gosub1:
FFFC3388 FF470713		sub		$sp,$sp,#12
FFFC338C 71402903		lw		a0,STKGOS	; 'STKGOS'
FFFC3390 01272023		sw		a0,[$sp]
FFFC3394 71802903		lw		a0,CURRNT	; found it, save old 'CURRNT'...
FFFC3398 01272223		sw		a0,4[$sp]
FFFC339C 01C72423		sw		$t2,8[$sp]
FFFC33A0 70002823		sw		$x0,LOPVAR		; load new values
FFFC33A4 70E02A23		sw		$sp,STKGOS
FFFC33A8 E1DFF06F		jmp		RUNTSL
                        	
                        	
                        	;******************************************************************
                        	; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                        	; returns the execution to the command after the most recent
                        	; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                        	; a 'GOSUB' and is thus an error.
                        	;******************************************************************
                        	;
                        	RETURN:
FFFC33AC 625000EF		call	ENDCHK		; there should be just a <CR>
FFFC33B0 71402983		lw		a1,STKGOS		; get old stack pointer
FFFC33B4 00099863		bne		a1,x0,return1
FFFC33B8 FFFC5937		ldi		a0,#msgRetWoGosub
FFFC33BC C2190913
FFFC33C0 6610006F		jmp		ERROR		; if zero, it doesn't exist
                        	return1:
FFFC33C4 0009E733		mov		$sp,a1		; else restore it
FFFC33C8 00072903		lw		a0,[$sp]
FFFC33CC 00470713		add		$sp,$sp,#4
FFFC33D0 71202A23		sw		a0,STKGOS	; and the old 'STKGOS'
FFFC33D4 00072903		lw		a0,[$sp]
FFFC33D8 00470713		add		$sp,$sp,#4
FFFC33DC 71202C23		sw		a0,CURRNT	; and the old 'CURRNT'
FFFC33E0 00072E03		lw		$t2,[$sp]	; and the old text pointer
FFFC33E4 00470713		add		$sp,$sp,#4
FFFC33E8 034010EF		call	POPA_		;and the old 'FOR' parameters
FFFC33EC F75FF06F		jmp		FINISH		;and we are back home
                        	
                        	;******************************************************************
                        	; *** FOR *** & NEXT ***
                        	;
                        	; 'FOR' has two forms:
                        	; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                        	; The second form means the same thing as the first form with a
                        	; STEP of positive 1.  The interpreter will find the variable 'var'
                        	; and set its value to the current value of 'exp1'.  It also
                        	; evaluates 'exp2' and 'exp1' and saves all these together with
                        	; the text pointer, etc. in the 'FOR' save area, which consists of
                        	; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                        	; already something in the save area (indicated by a non-zero
                        	; 'LOPVAR'), then the old save area is saved on the stack before
                        	; the new values are stored.  The interpreter will then dig in the
                        	; stack and find out if this same variable was used in another
                        	; currently active 'FOR' loop.  If that is the case, then the old
                        	; 'FOR' loop is deactivated. (i.e. purged from the stack)
                        	;******************************************************************
                        	;
                        	FOR:
FFFC33F0 064010EF		call	PUSHA_		; save the old 'FOR' save area
FFFC33F4 539000EF		call	SETVAL		; set the control variable
FFFC33F8 71002823		sw		v0,LOPVAR		; save its address
FFFC33FC FFFC3EB7		ldi		$t3,#TAB5
FFFC3400 008E8E93
FFFC3404 FFFC3F37		ldi		$t4,#TAB5_1	; use 'EXEC' to test for 'TO'
FFFC3408 074F0F13
FFFC340C CA5FF06F		jmp		EXEC
                        	FR1:
FFFC3410 5B8000EF		call	OREXPR		; evaluate the limit
FFFC3414 77002E23		sw		v0,LOPLMT	; save that
FFFC3418 FFFC3EB7		ldi		$t3,#TAB6
FFFC341C 00BE8E93
FFFC3420 FFFC3F37		ldi		$t4,#TAB6_1	; use 'EXEC' to test for the word 'STEP
FFFC3424 078F0F13
FFFC3428 C89FF06F		jmp		EXEC
                        	FR2:
FFFC342C 59C000EF		call	OREXPR		; found it, get the step value
FFFC3430 00000463		bra		FR4
                        	FR3:
FFFC3434 00106813		ldi		v0,#1		; not found, step defaults to 1
                        	FR4:
FFFC3438 77002C23		sw		v0,LOPINC	; save that too
                        	FR5:
FFFC343C 71802983		lw		a1,CURRNT
FFFC3440 77302A23		sw		a1,LOPLN	; save address of current line number
FFFC3444 77C02823		sw		$t2,LOPPT	; and text pointer
FFFC3448 000761B3		mov		r3,$sp		; dig into the stack to find 'LOPVAR'
FFFC344C 71002303		lw		r6,LOPVAR
FFFC3450 00000463		bra		FR7
                        	FR6:
FFFC3454 01418193		add		r3,r3,#20	; look at next stack frame
                        	FR7:
FFFC3458 0001A983		lw		a1,[r3]		; is it zero?
FFFC345C 00098E63		beq		a1,x0,FR8	; if so, we're done
FFFC3460 FE699AE3		bne		a1,r6,FR6	; same as current LOPVAR? nope, look some more
                        	
FFFC3464 0001E933	  mov		a0,r3	   ; Else remove 5 words from...
FFFC3468 000769B3		mov		a1,$sp
FFFC346C 01418A13		add		a2,r3,#20  ; inside the stack.
FFFC3470 7A5000EF		call	MVDOWN
FFFC3474 01470713		add		$sp,$sp,#20	; set the SP 5 long words up
                        	;	lw		a0,[$sp]		; ???
                        	;	add		$sp,$sp,#4
                        	FR8:
FFFC3478 EE9FF06F	  jmp	    FINISH		; and continue execution
                        	
                        	
                        	;******************************************************************
                        	; 'NEXT var' serves as the logical (not necessarily physical) end
                        	; of the 'FOR' loop.  The control variable 'var' is checked with
                        	; the 'LOPVAR'.  If they are not the same, the interpreter digs in
                        	; the stack to find the right one and purges all those that didn't
                        	; match.  Either way, it then adds the 'STEP' to that variable and
                        	; checks the result with against the limit value.  If it is within
                        	; the limit, control loops back to the command following the
                        	; 'FOR'.  If it's outside the limit, the save area is purged and
                        	; execution continues.
                        	;******************************************************************
                        	;
                        	NEXT:
FFFC347C 00006933		mov		a0,x0		; don't allocate it
FFFC3480 189000EF		call	TSTV		; get address of variable
FFFC3484 00081863		bne		v0,x0,NX4
FFFC3488 FFFC5937		ldi		a0,#msgNextVar
FFFC348C BE290913
FFFC3490 580008E3		bra		ERROR		; if no variable, say "What?"
                        	NX4:
FFFC3494 00086EB3		mov		$t3,v0	; save variable's address
                        	NX0:
FFFC3498 71002903		lw		a0,LOPVAR	; If 'LOPVAR' is zero, we never...
FFFC349C 00091863		bne		a0,x0,NX5	; had a FOR loop
FFFC34A0 FFFC5937		ldi		a0,#msgNextFor
FFFC34A4 BD090913
FFFC34A8 56000CE3		bra		ERROR
                        	NX5:
FFFC34AC 01D90663		beq		a0,$t3,NX2	; else we check them OK, they agree
FFFC34B0 76D000EF		call	POPA_		; nope, let's see the next frame
FFFC34B4 FE0002E3		bra		NX0
                        	NX2:
FFFC34B8 000EA903		lw		a0,[$t3]		; get control variable's value
FFFC34BC 77802983		lw		a1,LOPINC
FFFC34C0 01390933		add		a0,a0,a1	; add in loop increment
                        	;	BVS.L	QHOW		say "How?" for 32-bit overflow
FFFC34C4 012EA023		sw		a0,[$t3]		; save control variable's new value
FFFC34C8 77C02183		lw		r3,LOPLMT	; get loop's limit value
FFFC34CC 0009D663		bge		a1,x0,NX1	; check loop increment, branch if loop increment is positive
FFFC34D0 00394E63		blt		a0,r3,NXPurge	; test against limit
FFFC34D4 00000463		bra     NX3
                        	NX1:
FFFC34D8 0121CA63		bgt		a0,r3,NXPurge
                        	NX3:
FFFC34DC 77402E03		lw		$t2,LOPLN	; Within limit, go back to the...
FFFC34E0 71C02C23		sw		$t2,CURRNT
FFFC34E4 77002E03		lw		$t2,LOPPT	; saved 'CURRNT' and text pointer.
FFFC34E8 E79FF06F		jmp		FINISH
                        	NXPurge:
FFFC34EC 731000EF	  call    POPA_        ; purge this loop
FFFC34F0 E71FF06F	  jmp     FINISH
                        	
                        	
                        	;******************************************************************
                        	; *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                        	;
                        	; 'REM' can be followed by anything and is ignored by the
                        	; interpreter.
                        	;
                        	;REM
                        	;    br	    IF2		    ; skip the rest of the line
                        	; 'IF' is followed by an expression, as a condition and one or
                        	; more commands (including other 'IF's) separated by colons.
                        	; Note that the word 'THEN' is not used.  The interpreter evaluates
                        	; the expression.  If it is non-zero, execution continues.  If it
                        	; is zero, the commands that follow are ignored and execution
                        	; continues on the next line.
                        	;******************************************************************
                        	;
                        	IF0:
FFFC34F4 4D4000EF	  call	OREXPR		; evaluate the expression
                        	IF1:
FFFC34F8 00080463	  beq	  v0,x0,IF2	; is it zero? if not, continue
FFFC34FC CD1FF06F	  jmp		RUNSML
                        	IF2:
FFFC3500 000E6EB3	  mov		$t3,$t2	; set lookup pointer
FFFC3504 00006933		mov		a0,x0		; find line #0 (impossible)
FFFC3508 6D1000EF		call	FNDSKP		; if so, skip the rest of the line
FFFC350C 00081463		bne		v0,x0,IF3; if no next line, do a warm start
FFFC3510 8B1FF06F		jmp		WSTART
                        	IF3:
FFFC3514 CB1FF06F		jmp		RUNTSL		; run the next line
                        	
                        	
                        	;******************************************************************
                        	; INPUT is called first and establishes a stack frame
                        	INPERR:
FFFC3518 79802703		lw		$sp,STKINP		; restore the old stack pointer
FFFC351C 00072903		lw		a0,[$sp]
FFFC3520 00470713		add		$sp,$sp,#4
FFFC3524 71202C23		sw		a0,CURRNT		; and old 'CURRNT'
FFFC3528 00072E03		lw		$t2,[$sp]		; and old text pointer
FFFC352C 00470713		add		$sp,$sp,#4
FFFC3530 01470713		add		$sp,$sp,#20	; fall through will subtract 20
                        	
                        	; 'INPUT' is like the 'PRINT' command, and is followed by a list
                        	; of items.  If the item is a string in single or double quotes,
                        	; or is an underline (back arrow), it has the same effect as in
                        	; 'PRINT'.  If an item is a variable, this variable name is
                        	; printed out followed by a colon, then the interpreter waits for
                        	; an expression to be typed in.  The variable is then set to the
                        	; value of this expression.  If the variable is preceeded by a
                        	; string (again in single or double quotes), the string will be
                        	; displayed followed by a colon.  The interpreter the waits for an
                        	; expression to be entered and sets the variable equal to the
                        	; expression's value.  If the input expression is invalid, the
                        	; interpreter will print "What?", "How?", or "Sorry" and reprint
                        	; the prompt and redo the input.  The execution will not terminate
                        	; unless you press control-C.  This is handled in 'INPERR'.
                        	;
                        	INPUT:
FFFC3534 FEC70713		sub		$sp,$sp,#20	; allocate five words on stack
FFFC3538 00572823		sw		r5,16[$sp]	; save off r5 into stack var
                        	IP6:
FFFC353C 01C72023		sw		$t2,[$sp]	; save in case of error
FFFC3540 7C1000EF		call	QTSTG		; is next item a string?
FFFC3544 00000C63		bra		IP2			; nope - this branch must take only 1 word
FFFC3548 00106913		ldi		a0,#1		; allocate var
FFFC354C 0BD000EF		call	TSTV		; yes, but is it followed by a variable?
FFFC3550 08090463		beq    a0,r0,IP4   ; if not, brnch
FFFC3554 00096F33		mov		$t4,a0		; put away the variable's address
FFFC3558 04000063		bra		IP3			; if so, input to variable
                        	IP2:
FFFC355C 01C72223		sw		$t2,4[$sp]	; save off in stack var for 'PRTSTG'
FFFC3560 00106913		ldi		a0,#1
FFFC3564 0A5000EF		call	TSTV		; must be a variable now
FFFC3568 00091A63		bne		a0,r0,IP7
FFFC356C FFFC5937		ldi		a0,#msgInputVar
FFFC3570 BB490913
FFFC3574 01470713		add		$sp,$sp,#20	; cleanup stack
FFFC3578 4A0004E3		bra		ERROR		; "What?" it isn't?
                        	IP7:
FFFC357C 00096F33		mov		$t4,a0		; put away the variable's address
FFFC3580 000E4283		lbu		r5,[$t2]		; get ready for 'PRTSTG' by null terminating
FFFC3584 000E0023		sb		x0,[$t2]
FFFC3588 000069B3		mov		a1,x0
FFFC358C 00472903		lw		a0,4[$sp]	; get back text pointer
FFFC3590 709000EF		call	PRTSTG		; print string as prompt
FFFC3594 005E0023		sb		r5,[$t2]		; un-null terminate
                        	IP3
FFFC3598 01C72223		sw		$t2,4[$sp]	; save in case of error
FFFC359C 71802903		lw		a0,CURRNT
FFFC35A0 01272423		sw		a0,8[$sp]	; also save 'CURRNT'
FFFC35A4 FFF06913		ldi		a0,#-1
FFFC35A8 71202C23		sw		a0,CURRNT	; flag that we are in INPUT
FFFC35AC 78E02C23		sw		$sp,STKINP	; save the stack pointer too
FFFC35B0 01E72623		sw		$t4,12[$sp]	; save the variable address
FFFC35B4 03A06913		ldi		a0,#':'		; print a colon first
FFFC35B8 4AD000EF		call	GETLN		; then get an input line
FFFC35BC 71C06E13		ldi		$t2,#BUFFER	; point to the buffer
FFFC35C0 408000EF		call	OREXPR		; evaluate the input
FFFC35C4 00C72F03		lw		$t4,12[$sp]	; restore the variable address
FFFC35C8 012F2023		sw		a0,[$t4]	; save value in variable
FFFC35CC 00872903		lw		a0,8[$sp]	; restore old 'CURRNT'
FFFC35D0 71202C23		sw		a0,CURRNT
FFFC35D4 00472E03		lw		$t2,4[$sp]	; and the old text pointer
                        	IP4:
FFFC35D8 0EC010EF		call	TSTC
FFFC35DC 0000002C		dw		','
FFFC35E0 00000463		bra		IP5
FFFC35E4 F4000CE3		bra		IP6			; yes, more items
                        	IP5:
FFFC35E8 01072283		lw		r5,16[$sp]
FFFC35EC 01470713		add		$sp,$sp,#20	; cleanup stack
FFFC35F0 D71FF06F	 	jmp		FINISH
                        	
                        	
                        	DEFLT:
FFFC35F4 000E4903	  lbu    	a0,[$t2]
FFFC35F8 00D06D93	  ldi			$t1,#CR
FFFC35FC D7B902E3		beq	    a0,$t1,FINISH	    ; empty line is OK else it is 'LET'
                        	
                        	
                        	;******************************************************************
                        	; 'LET' is followed by a list of items separated by commas.
                        	; Each item consists of a variable, an equals sign, and an
                        	; expression.  The interpreter evaluates the expression and sets
                        	; the variable to that value.  The interpreter will also handle
                        	; 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                        	;******************************************************************
                        	;
                        	LET:
FFFC3600 32D000EF	  call	SETVAL		; do the assignment
FFFC3604 0C0010EF		call	TSTC		; check for more 'LET' items
FFFC3608 0000002C		dw		','
FFFC360C D55FF06F		jmp		FINISH
FFFC3610 FE0008E3		bra	    LET
                        	LT1:
FFFC3614 D4DFF06F	  jmp	    FINISH		; until we are finished.
                        	
                        	
                        	;******************************************************************
                        	; *** LOAD *** & SAVE ***
                        	;
                        	; These two commands transfer a program to/from an auxiliary
                        	; device such as a cassette, another computer, etc.  The program
                        	; is converted to an easily-stored format: each line starts with
                        	; a colon, the line no. as 4 hex digits, and the rest of the line.
                        	; At the end, a line starting with an '@' sign is sent.  This
                        	; format can be read back with a minimum of processing time by
                        	; the RTF65002
                        	;******************************************************************
                        	;
                        	LOAD
FFFC3618 00002E37		ldi		$t2,#TXTBGN	; set pointer to start of prog. area
FFFC361C 800E0E13
FFFC3620 00D06913		ldi		a0,#CR		; For a CP/M host, tell it we're ready...
FFFC3624 EECFF0EF		call	GOAUXO		; by sending a CR to finish PIP command.
                        	LOD1:
FFFC3628 EF0FF0EF		call	GOAUXI		; look for start of line
FFFC362C FF205EE3		ble		a0,r0,LOD1
FFFC3630 04006D93		ldi		$t1,#'@'
FFFC3634 03B90E63		beq		a0,$t1,LODEND	; end of program?
FFFC3638 01A06D93		ldi		$t1,#$1A
FFFC363C 03B90A63		beq		a0,$t1,LODEND	; or EOF marker
FFFC3640 03A06D93		ldi		$t1,#':'
FFFC3644 FFB912E3		bne		a0,$t1,LOD1	; if not, is it start of line? if not, wait for it
FFFC3648 030000EF		call	GCHAR		; get line number
FFFC364C 012E2023		sw		a0,[$t2]		; store it
FFFC3650 004E0E13		add		$t2,$t2,#4
                        	LOD2:
FFFC3654 EC4FF0EF		call	GOAUXI		; get another text char.
FFFC3658 FF205EE3		ble		a0,r0,LOD2
FFFC365C 012E0023		sb		a0,[$t2]		; store it
FFFC3660 001E0E13		add		$t2,$t2,#1
FFFC3664 00D06D93		ldi		$t1,#CR
FFFC3668 FFB916E3		bne		a0,$t1,LOD2		; is it the end of the line? if not, go back for more
FFFC366C FA000EE3		bra		LOD1		; if so, start a new line
                        	LODEND:
FFFC3670 71C02223		sw		$t2,TXTUNF	; set end-of program pointer
FFFC3674 F4CFF06F		jmp		WSTART		; back to direct mode
                        	
                        	
                        	; get character from input (32 bit value)
                        	GCHAR:
FFFC3678 FF470713		sub		$sp,$sp,#12
FFFC367C 00572023		sw		r5,[$sp]
FFFC3680 00672223		sw		r6,4[$sp]
FFFC3684 00172423		sw		$ra,8[$sp]
FFFC3688 00806313		ldi		r6,#8       ; repeat ten times
FFFC368C 00006293		ldi		r5,#0
                        	GCHAR1:
FFFC3690 E88FF0EF		call	GOAUXI		; get a char
FFFC3694 FF205EE3		ble		a0,r0,GCHAR1
FFFC3698 02C000EF		call	asciiToHex
FFFC369C 00429293		sll		r5,r5,#4
FFFC36A0 0122E2B3		or		r5,r5,a0
FFFC36A4 FFF30313		sub		r6,r6,#1
FFFC36A8 FE6064E3		bgtu	r6,r0,GCHAR1
FFFC36AC 0002E933		mov		a0,r5
FFFC36B0 00072283		lw		r5,[$sp]
FFFC36B4 00472303		lw		r6,4[$sp]
FFFC36B8 00872083		lw		$ra,8[$sp]
FFFC36BC 00C70713		add		$sp,$sp,#12
FFFC36C0 00008067		ret
                        	
                        	; convert an ascii char to hex code
                        	; input
                        	;	a0 = char to convert
                        	
                        	asciiToHex:
FFFC36C4 03906D93		ldi		$t1,#'9'
FFFC36C8 012DF463		bleu	a0,$t1,a2h1; less than '9'
FFFC36CC FF990913		sub		a0,a0,#7	; shift 'A' to '9'+1
                        	a2h1:
FFFC36D0 FD090913		sub		a0,a0,#'0'
FFFC36D4 00F97913		and		a0,a0,#15	; make sure a nybble
FFFC36D8 00008067		ret
                        	
                        	GetFilename:
FFFC36DC FFC70713		sub		$sp,$sp,#4
FFFC36E0 00172023		sw		$ra,[$sp]
FFFC36E4 7E1000EF		call	TSTC
FFFC36E8 00000022		dw		'"'
FFFC36EC 04000C63		bra		gfn1
FFFC36F0 000061B3		mov		r3,r0
                        	gfn2:
FFFC36F4 000E4903		lbu		a0,[$t2]		; get text character
FFFC36F8 001E0E13		add		$t2,$t2,#1
FFFC36FC 02206D93		ldi		$t1,#'"'
FFFC3700 03B90263		beq		a0,$t1,gfn3
FFFC3704 02090063		beq		a0,r0,gfn3
FFFC3708 6D218023		sb		a0,FILENAME[r3]
FFFC370C 00118193		add		r3,r3,#1
FFFC3710 04006D93		ldi		$t1,#64
FFFC3714 FFB1E0E3		bltu	r3,$t1,gfn2
FFFC3718 00072083		lw		$ra,[$sp]
FFFC371C 00470713		add		$sp,$sp,#4
FFFC3720 00008067		ret
                        	gfn3:
FFFC3724 02006913		ldi		a0,#' '
FFFC3728 6D218023		sb		a0,FILENAME[r3]
FFFC372C 00118193		add		r3,r3,#1
FFFC3730 04006D93		ldi		$t1,#64
FFFC3734 FFB1E8E3		bltu	r3,$t1,gfn3
FFFC3738 00072083		lw		$ra,[$sp]
FFFC373C 00470713		add		$sp,$sp,#4
FFFC3740 00008067		ret
                        	gfn1:
FFFC3744 E7CFF06F		jmp		WSTART
                        	
                        	LOAD3:
FFFC3748 F95FF0EF		call	GetFilename
FFFC374C 00000637		call	AUXIN_INIT
FFFC3750 2F8600E7
FFFC3754 EC5FF06F		jmp		LOAD
                        	
                        	;	call		OREXPR		;evaluate the following expression
                        	;	ld		a0,#5000
FFFC3758 000019B7		ld		a1,#$E00
FFFC375C E0098993
FFFC3760 00000637		call	SDReadSector
FFFC3764 2F9600E7
FFFC3768 00190913		add		a0,a0,#1
FFFC376C 000029B7		ldi		a1,#TXTBGN
FFFC3770 80098993
                        	LOAD4:
FFFC3774 FFC70713		sub		$sp,$sp,#4
FFFC3778 01272023		sw		a0,[$sp]
FFFC377C 00000637		call	SDReadSector
FFFC3780 2F9600E7
FFFC3784 20098993		add		a1,a1,#512
FFFC3788 00072903		lw		a0,[$sp]
FFFC378C 00470713		add		$sp,$sp,#4
FFFC3790 00190913		add		a0,a0,#1
FFFC3794 00002237		ldi		r4,#TXTBGN
FFFC3798 80020213
FFFC379C 00010637		add		r4,r4,#65536
FFFC37A0 00060613
FFFC37A4 00460233
FFFC37A8 FC49C6E3		blt		a1,r4,LOAD4
                        	LOAD5:
FFFC37AC E0000A63		bra		WSTART
                        	
                        	
                        	SAVE3:
FFFC37B0 F2DFF0EF		call	GetFilename
FFFC37B4 00000637		call	AUXOUT_INIT
FFFC37B8 2FC600E7
FFFC37BC 0600006F		jmp		SAVE
                        	
FFFC37C0 208000EF		call	OREXPR		;evaluate the following expression
                        	;	lda		#5000		; starting sector
FFFC37C4 000019B7		ldi		a1,#$E00	; starting address to write
FFFC37C8 E0098993
FFFC37CC 00000637		call	SDWriteSector
FFFC37D0 2FE600E7
FFFC37D4 00190913		add		a0,a0,#1
FFFC37D8 000029B7		ldi		a1,#TXTBGN
FFFC37DC 80098993
                        	SAVE4:
FFFC37E0 FFC70713		sub		$sp,$sp,#4
FFFC37E4 01272023		sw		a0,[$sp]
FFFC37E8 00000637		call	SDWriteSector
FFFC37EC 2FE600E7
FFFC37F0 20098993		add		a1,a1,#512
FFFC37F4 00072903		lw		a0,[$sp]
FFFC37F8 00470713		add		$sp,$sp,#4
FFFC37FC 00190913		add		a0,a0,#1
FFFC3800 00002237		ldi		r4,#TXTBGN
FFFC3804 80020213
FFFC3808 00010637		add		r4,r4,#65536
FFFC380C 00060613
FFFC3810 00460233
FFFC3814 FC49C6E3		blt		a1,r4,SAVE4
FFFC3818 DA000463		bra		WSTART
                        	
                        	SAVE:
FFFC381C 00002E37		ldi		$t2,#TXTBGN	;set pointer to start of prog. area
FFFC3820 800E0E13
FFFC3824 70402E83		lw		$t3,TXTUNF	;set pointer to end of prog. area
                        	SAVE1:
FFFC3828 054000EF		call	AUXOCRLF    ; send out a CR & LF (CP/M likes this)
FFFC382C 03CEC863		bgt		$t2,$t3,SAVEND; are we finished?
FFFC3830 03A06913		ldi		a0,#':'		; if not, start a line
FFFC3834 CDCFF0EF		call	GOAUXO
FFFC3838 000E2903		lw		a0,[$t2]		; get line number
FFFC383C 004E0E13		add		$t2,$t2,#4
FFFC3840 060000EF		call	PWORD       ; output line number as 5-digit hex
                        	SAVE2:
FFFC3844 000E4903		lbu		a0,[$t2]		; get a text char.
FFFC3848 001E0E13		add		$t2,$t2,#1
FFFC384C 00D06D93		ldi		$t1,#CR
FFFC3850 FDB90CE3		beq		a0,$t1,SAVE1	; is it the end of the line? if so, send CR & LF and start new line
FFFC3854 CBCFF0EF		call	GOAUXO		; send it out
FFFC3858 FE0006E3		bra		SAVE2		; go back for more text
                        	SAVEND:
FFFC385C 04006913		ldi		a0,#'@'		; send end-of-program indicator
FFFC3860 CB0FF0EF		call	GOAUXO
FFFC3864 018000EF		call	AUXOCRLF    ; followed by a CR & LF
FFFC3868 01A06913		ldi		a0,#$1A		; and a control-Z to end the CP/M file
FFFC386C CA4FF0EF		call	GOAUXO
FFFC3870 00000637		call	AUXOUT_FLUSH
FFFC3874 305600E7
FFFC3878 D4000463		bra		WSTART		; then go do a warm start
                        	
                        	; output a CR LF sequence to auxillary output
                        	; Registers Affected
                        	;   r3 = LF
                        	AUXOCRLF:
FFFC387C FFC70713		sub		$sp,$sp,#4
FFFC3880 00172023		sw		$ra,[$sp]
FFFC3884 00D06913	  ldi		a0,#CR
FFFC3888 C88FF0EF	  call	GOAUXO
FFFC388C 00A06913	  ldi		a0,#LINEFD
FFFC3890 C80FF0EF	  call	GOAUXO
FFFC3894 00072083	  lw		$ra,[$sp]
FFFC3898 00470713	  add		$sp,$sp,#4
FFFC389C 00008067	  ret
                        	
                        	
                        	; output a word in hex format
                        	; tricky because of the need to reverse the order of the chars
                        	PWORD:
FFFC38A0 FF870713		sub		$sp,$sp,#8
FFFC38A4 00572023		sw		r5,[$sp]
FFFC38A8 00172223		sw		$ra,4[$sp]
FFFC38AC 7A206293		ldi		r5,#NUMWKA+14
FFFC38B0 00096233		mov		r4,a0		; r4 = value
                        	pword1:
FFFC38B4 00026933	  mov   a0,r4	    ; a0 = value
FFFC38B8 00425213	  srl		r4,r4,#4	; shift over to next nybble
FFFC38BC 038000EF	  call	toAsciiHex  ; convert LS nybble to ascii hex
FFFC38C0 01228023	  sb    a0,[r5]		; save in work area
FFFC38C4 FFF28293	  sub		r5,r5,#1
FFFC38C8 79406D93	  ldi		$t1,#NUMWKA
FFFC38CC FFB2D4E3		bge		r5,$t1,pword1
                        	pword2:
FFFC38D0 00128293	  add		r5,r5,#1
FFFC38D4 0002C903	  lbu   a0,[r5]     ; get char to output
FFFC38D8 C38FF0EF		call	GOAUXO		; send it
FFFC38DC 7A206D93		ldi		$t1,#NUMWKA+14
FFFC38E0 FFB2C8E3		blt		r5,$t1,pword2
FFFC38E4 00072283		lw		r5,[$sp]
FFFC38E8 00472083		lw		$ra,4[$sp]
FFFC38EC 00870713		add		$sp,$sp,#8
FFFC38F0 00008067		ret
                        	
                        	; convert nybble in a1 to ascii hex chaa1
                        	; a1 = character to convert
                        	
                        	toAsciiHex:
FFFC38F4 00F97913		and		a0,a0,#15	; make sure it's a nybble
FFFC38F8 00A06D93		ldi		$t1,#10
FFFC38FC 01B94463		blt		a0,$t1,tah1	; > 10 ?
FFFC3900 00790913		add		a0,a0,#7	; bump it up to the letter 'A'
                        	tah1:
FFFC3904 03090913		add		a0,a0,#'0'	; bump up to ascii '0'
FFFC3908 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	; *** POKE ***
                        	;
                        	; 'POKE expr1,expa1' stores the byte from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEW expr1,expa1' stores the word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEH expr1,expa1' stores the half-word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	;******************************************************************
                        	;
                        	POKE:
FFFC390C 0BC000EF		call	OREXPR		; get the memory address
FFFC3910 5B5000EF		call	TSTC		; it must be followed by a comma
FFFC3914 0000002C		dw		','
FFFC3918 06000C63		bra		PKER
FFFC391C FFC70713		sub		$sp,$sp,#4
FFFC3920 01272023		sw		a0,[$sp]	; save the address
FFFC3924 0A4000EF		call	OREXPR		; get the byte to be POKE'd
FFFC3928 00072983		lw		a1,[$sp]	; get the address back
FFFC392C 00470713		add		$sp,$sp,#4
FFFC3930 01298023		sb		a0,[a1]		; store the byte in memory
FFFC3934 A2DFF06F		jmp		FINISH
                        	
                        	POKEW:
FFFC3938 090000EF		call	OREXPR		; get the memory address
FFFC393C 589000EF		call	TSTC		; it must be followed by a comma
FFFC3940 0000002C		dw		','
FFFC3944 04000663		bra		PKER
FFFC3948 FFC70713		sub		$sp,$sp,#4
FFFC394C 01272023		sw		a0,[$sp]	; save the address
FFFC3950 078000EF		call	OREXPR		; get the byte to be POKE'd
FFFC3954 00072983		lw		a1,[$sp]	; get the address back
FFFC3958 00470713		add		$sp,$sp,#4
FFFC395C 0129A023		sw		a0,[a1]		; store the byte in memory
FFFC3960 A01FF06F		jmp		FINISH
                        	
                        	POKEH:
FFFC3964 064000EF		call	OREXPR		; get the memory address
FFFC3968 55D000EF		call	TSTC		; it must be followed by a comma
FFFC396C 0000002C		dw		','
FFFC3970 02000063		bra		PKER
FFFC3974 FFC70713		sub		$sp,$sp,#4
FFFC3978 01272023		sw		a0,[$sp]	; save the address
FFFC397C 04C000EF		call	OREXPR		; get the byte to be POKE'd
FFFC3980 00072983		lw		a1,[$sp]	; get the address back
FFFC3984 00470713		add		$sp,$sp,#4
FFFC3988 01299023		sh		a0,[a1]		; store the byte in memory
FFFC398C 9D5FF06F		jmp		FINISH
                        	
                        	PKER:
FFFC3990 FFFC5937		ldi		a0,#msgComma
FFFC3994 B5290913
FFFC3998 0890006F		jmp		ERROR		; if no comma, say "What?"
                        	
                        	;******************************************************************
                        	; 'SYSX expr' jumps to the machine language subroutine whose
                        	; starting address is specified by 'expr'.  The subroutine can use
                        	; all registers but must leave the stack the way it found it.
                        	; The subroutine returns to the interpreter by executing an RTS.
                        	;******************************************************************
                        	
                        	SYSX:
FFFC399C 02C000EF		call	OREXPR		; get the subroutine's address
FFFC39A0 00081863		bne		v0,r0,sysx1; make sure we got a valid address
FFFC39A4 FFFC5937		ld		a0,#msgSYSBad
FFFC39A8 BA390913
FFFC39AC 0750006F		jmp		ERROR
                        	sysx1:
FFFC39B0 FFC70713		sub		$sp,$sp,#4
FFFC39B4 01C72023		sw		$t2,[$sp]	; save the text pointer
FFFC39B8 000800E7		call	[v0]			; jump to the subroutine
FFFC39BC 00072E03		lw		$t2,[$sp]	; restore the text pointer
FFFC39C0 00470713		add		$sp,$sp,#4
FFFC39C4 99DFF06F		jmp		FINISH
                        	
                        	;******************************************************************
                        	; *** EXPR ***
                        	;
                        	; 'EXPR' evaluates arithmetical or logical expressions.
                        	; <OREXPR>::= <ANDEXPR> OR <ANDEXPR> ...
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	; <EXPR>::=<ADDEXPR>
                        	;	   <ADDEXPR><rel.op.><ADDEXPR>
                        	; where <rel.op.> is one of the operators in TAB8 and the result
                        	; of these operations is 1 if true and 0 if false.
                        	; <ADDEXPR>::=(+ or -)<MULEXPR>(+ or -)<MULEXPR>(...
                        	; where () are optional and (... are optional repeats.
                        	; <MULEXPR>::=<FUNCEXPR>( <* or /><FUNCEXPR> )(...
                        	; <FUNCEXPR>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                        	; as an index, functions can have an <EXPR> as arguments, and
                        	; <FUNCEXPR> can be an <EXPR> in parenthesis.
                        	;
                        	
                        	; <OREXPR>::=<ANDEXPR> OR <ANDEXPR> ...
                        	;
                        	OREXPR:
FFFC39C8 FF470713		sub		$sp,$sp,#12
FFFC39CC 00172023		sw		$ra,[$sp]
FFFC39D0 00372223		sw		r3,4[$sp]
FFFC39D4 00472423		sw		r4,8[$sp]
FFFC39D8 058000EF		call	ANDEXPR		; get first <ANDEXPR>
                        	XP_OR1:
FFFC39DC FF870713		sub		$sp,$sp,#8
FFFC39E0 01072023		sw		$v0,[$sp]		; save <ANDEXPR> value
FFFC39E4 01172223		sw		$v1,4[$sp]	; save type
FFFC39E8 FFFC3EB7		ldi		$t3,#TAB10	; look up a logical operator
FFFC39EC 01EE8E93
FFFC39F0 FFFC3F37		ldi		$t4,#TAB10_1
FFFC39F4 08EF0F13
FFFC39F8 EB8FF06F		jmp		EXEC		; go do it
                        	XP_OR:
FFFC39FC 034000EF	  call	ANDEXPR
FFFC3A00 00072903	  lw		$a0,[$sp]
FFFC3A04 00870713	  add		$sp,$sp,#8
FFFC3A08 01286833	  or    v0,v0,a0
FFFC3A0C FC0008E3	  bra   XP_OR1
                        	XP_ORX:
FFFC3A10 00072803	  lw		$v0,[$sp]
FFFC3A14 00472883	  lw		$v1,4[$sp]
FFFC3A18 00870713	  add		$sp,$sp,#8
FFFC3A1C 00072083		lw		$ra,[$sp]
FFFC3A20 00472183		lw		r3,4[$sp]
FFFC3A24 00872203		lw		r4,8[$sp]
FFFC3A28 00C70713		add		$sp,$sp,#12
FFFC3A2C 00008067	  ret
                        	
                        	
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	;
                        	ANDEXPR:
FFFC3A30 FFC70713		sub		$sp,$sp,#4
FFFC3A34 00172023		sw		$ra,[$sp]
FFFC3A38 0E8000EF		call	EXPR		; get first <EXPR>
                        	XP_AND1:
FFFC3A3C FF870713		sub		$sp,$sp,#8
FFFC3A40 01072023		sw		$v0,[$sp]		; save <EXPR> value
FFFC3A44 01172223		sw		$v1,4[$sp]	; save type
FFFC3A48 FFFC3EB7		ldi		$t3,#TAB9		; look up a logical operator
FFFC3A4C 01AE8E93
FFFC3A50 FFFC3F37		ldi		$t4,#TAB9_1
FFFC3A54 08AF0F13
FFFC3A58 E58FF06F		jmp		EXEC		; go do it
                        	XP_AND:
FFFC3A5C 0C4000EF	  call	EXPR
FFFC3A60 00072903	  lw		$a0,[$sp]
FFFC3A64 00870713	  add		$sp,$sp,#8
FFFC3A68 01287833	  and   v0,v0,a0
FFFC3A6C FC0008E3	  bra   XP_AND1
                        	XP_ANDX:
FFFC3A70 00072803	  lw		$v0,[$sp]
FFFC3A74 00472883	  lw		$v1,4[$sp]
FFFC3A78 00870713	  add		$sp,$sp,#8
FFFC3A7C 00072083		lw		$ra,[$sp]
FFFC3A80 00470713		add		$sp,$sp,#4
FFFC3A84 00008067	  ret
                        	
                        	
                        	; Determine if the character is a digit
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if digit, otherwise 0
                        	;
                        	isDigit:
FFFC3A88 03006D93		ldi		$t1,#'0'
FFFC3A8C 01B94A63		blt		a0,$t1,isDigitFalse
FFFC3A90 03906D93		ldi		$t1,#'9'
FFFC3A94 012DC663		bgt		a0,$t1,isDigitFalse
FFFC3A98 00106813		ldi		v0,#1
FFFC3A9C 00008067	  ret
                        	isDigitFalse:
FFFC3AA0 00006833	  mov		v0,r0
FFFC3AA4 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphabetic
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlpha:
FFFC3AA8 04106D93		ldi		$t1,#'A'
FFFC3AAC 03B94263		blt		a0,$t1,isAlphaFalse
FFFC3AB0 05A06D93		ldi		$t1,#'Z'
FFFC3AB4 012DDA63		ble		a0,$t1,isAlphaTrue
FFFC3AB8 06106D93		ldi		$t1,#'a'
FFFC3ABC 01B94A63		blt		a0,$t1,isAlphaFalse
FFFC3AC0 07A06D93		ldi		$t1,#'z'
FFFC3AC4 012DC663		bgt		a0,$t1,isAlphaFalse
                        	isAlphaTrue:
FFFC3AC8 00106813	  ldi		v0,#1
FFFC3ACC 00008067	  ret
                        	isAlphaFalse:
FFFC3AD0 00006833	  mov		v0,r0
FFFC3AD4 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphanumeric
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlnum:
FFFC3AD8 FFC70713		sub		$sp,$sp,#4
FFFC3ADC 00172023		sw		$ra,[$sp]
FFFC3AE0 FA9FF0EF	  call	isDigit
FFFC3AE4 00081463		bne		v0,r0,isDigitx	; if it is a digit
FFFC3AE8 FC1FF0EF	  call  isAlpha
                        	isDigitx:
FFFC3AEC 00072083		lw		$ra,[$sp]
FFFC3AF0 00470713		add		$sp,$sp,#4
FFFC3AF4 00008067	  ret
                        	
                        	FORCEFIT:
FFFC3AF8 03198263		beq		a1,v1,.0001				; types match
FFFC3AFC 00006D13		ldi		$t0,#0
FFFC3B00 01A98663		beq		a1,$t0,.intAnd
                        	;	itof	$f1,$v0
FFFC3B04 00106913		ldi		a0,#1
FFFC3B08 00008067		ret
                        	.intAnd:
FFFC3B0C 00106D13		ldi		$t0,#1
FFFC3B10 01A89663		bne		$v1,$t0,.0001
                        	;	itof	$f2,$a1
FFFC3B14 00106993		ldi		$a1,#1
FFFC3B18 00008067		ret
                        	.0001:
FFFC3B1C 00008067		ret
                        	
                        	EXPR:
FFFC3B20 FFC70713		sub		$sp,$sp,#4
FFFC3B24 00172023		sw		$ra,[$sp]
FFFC3B28 11C000EF		call	ADDEXPR
FFFC3B2C FF870713		sub		$sp,$sp,#8				; save <ADDEXPR> value
FFFC3B30 01072023		sw		v0,[$sp]
FFFC3B34 01172223		sw		v1,4[$sp]					; save type
FFFC3B38 FFFC3EB7		ldi		$t3,#TAB8		; look up a relational operator
FFFC3B3C 010E8E93
FFFC3B40 FFFC3F37		ldi		$t4,#TAB8_1
FFFC3B44 07CF0F13
FFFC3B48 D68FF06F		jmp		EXEC		; go do it
                        	XP11:
FFFC3B4C 00072903		lw		a0,[$sp]
FFFC3B50 00472983		lw		a1,4[$sp]
FFFC3B54 00870713		add		$sp,$sp,#8
FFFC3B58 0C4000EF		call	XP18	; is it ">="?
FFFC3B5C 09095A63		bge		a0,v0,XPRT1	; no, return v0=1
FFFC3B60 06000E63		bra		XPRT0	; else return v0=0
                        	XP12:
FFFC3B64 00072903		lw		a0,[$sp]
FFFC3B68 00472983		lw		a1,4[$sp]
FFFC3B6C 00870713		add		$sp,$sp,#8
FFFC3B70 0AC000EF		call	XP18	; is it "<>"?
FFFC3B74 07091E63		bne		a0,v0,XPRT1	; no, return a1=1
FFFC3B78 06000263		bra		XPRT0	; else return a1=0
                        	XP13:
FFFC3B7C 00072903		lw		a0,[$sp]
FFFC3B80 00472983		lw		a1,4[$sp]
FFFC3B84 00870713		add		$sp,$sp,#8
FFFC3B88 094000EF		call	XP18	; is it ">"?
FFFC3B8C 07284263		bgt		a0,v0,XPRT1	; no, return a1=1
FFFC3B90 04000663		bra		XPRT0	; else return a1=0
                        	XP14:
FFFC3B94 00072903		lw		a0,[$sp]
FFFC3B98 00472983		lw		a1,4[$sp]
FFFC3B9C 00870713		add		$sp,$sp,#8
FFFC3BA0 07C000EF		call	XP18	; is it "<="?
FFFC3BA4 05285663		ble		a0,v0,XPRT1	; no, return a1=1
FFFC3BA8 02000A63		bra		XPRT0	; else return a1=0
                        	XP15:
FFFC3BAC 00072903		lw		a0,[$sp]
FFFC3BB0 00472983		lw		a1,4[$sp]
FFFC3BB4 00870713		add		$sp,$sp,#8
FFFC3BB8 064000EF		call	XP18	; is it "="?
FFFC3BBC 03090A63		beq		a0,v0,XPRT1	; if not, return a1=1
FFFC3BC0 00000E63		bra		XPRT0	; else return a1=0
                        	XP16:
FFFC3BC4 00072903		lw		a0,[$sp]
FFFC3BC8 00472983		lw		a1,4[$sp]
FFFC3BCC 00870713		add		$sp,$sp,#8
FFFC3BD0 04C000EF		call	XP18	; is it "<"?
FFFC3BD4 01094E63		blt		a0,v0,XPRT1	; if not, return a1=1
FFFC3BD8 00000263		bra		XPRT0	; else return a1=0
                        	XPRT0:
FFFC3BDC 00006833		mov		v0,x0   ; return a0=0 (false)
FFFC3BE0 000068B3		mov		v1,x0		; type = int
FFFC3BE4 00072083		lw		$ra,[$sp]
FFFC3BE8 00470713		add		$sp,$sp,#4
FFFC3BEC 00008067		ret
                        	XPRT1:
FFFC3BF0 00106813		ldi		v0,#1	; return a0=1 (true)
FFFC3BF4 00006893		ldi		v1,#0	; type = int
FFFC3BF8 00072083		lw		$ra,[$sp]
FFFC3BFC 00470713		add		$sp,$sp,#4
FFFC3C00 00008067		ret
                        	
                        	XP17:				; it's not a rel. operator
FFFC3C04 00072803		lw		v0,[$sp]; return a1=<ADDEXPR>
FFFC3C08 00472883		lw		v1,4[$sp]
FFFC3C0C 00870713		add		$sp,$sp,#8
FFFC3C10 00072083		lw		$ra,[$sp]
FFFC3C14 00470713		add		$sp,$sp,#4
FFFC3C18 00008067		ret
                        	
                        	XP18:
FFFC3C1C FF470713		sub		$sp,$sp,#12
FFFC3C20 00172023		sw		$ra,[$sp]
FFFC3C24 01072223		sw		v0,4[$sp]
FFFC3C28 01172423		sw		v1,8[$sp]
FFFC3C2C 018000EF		call	ADDEXPR		; do a second <ADDEXPR>
FFFC3C30 00472903		lw		a0,4[$sp]
FFFC3C34 00872983		lw		a1,8[$sp]
FFFC3C38 00072083		lw		$ra,[$sp]
FFFC3C3C 00C70713		add		$sp,$sp,#12
FFFC3C40 00008067		ret
                        	
                        	; <ADDEXPR>::=(+ or -)<MULEXPR>(+ or -)<MULEXPR>(...
                        	//message "ADDEXPR"
                        	ADDEXPR:
FFFC3C44 FFC70713		sub		$sp,$sp,#4
FFFC3C48 00172023		sw		$ra,[$sp]
FFFC3C4C 279000EF		call	TSTC		; negative sign?
FFFC3C50 0000002D		dw		'-'
FFFC3C54 00000C63		bra		XP21
FFFC3C58 00006833		mov		v0,r0		; yes, fake '0-'
FFFC3C5C FF870713		sub		$sp,$sp,#8
FFFC3C60 01072023		sw		v0,[$sp]
FFFC3C64 01172223		sw		v1,4[$sp]
FFFC3C68 04000863		bra		XP26
                        	XP21:
FFFC3C6C 259000EF		call	TSTC		; positive sign? ignore it
FFFC3C70 0000002B		dw		'+'
FFFC3C74 00000263		bra		XP22
                        	XP22:
FFFC3C78 064000EF		call	MULEXPR		; first <MULEXPR>
                        	XP23:
FFFC3C7C FF870713		sub		$sp,$sp,#8; yes, save the value
FFFC3C80 01072023		sw		v0,[$sp]
FFFC3C84 01172223		sw		v1,4[$sp]	; and type
FFFC3C88 23D000EF		call	TSTC		; add?
FFFC3C8C 0000002B		dw		'+'
FFFC3C90 00000E63		bra		XP25
FFFC3C94 048000EF		call	MULEXPR		; get the second <MULEXPR>
                        	XP24:
FFFC3C98 00072903		lw		a0,[$sp]
FFFC3C9C 00472983		lw		a1,4[$sp]
FFFC3CA0 00870713		add		$sp,$sp,#8
FFFC3CA4 01280833		add		v0,v0,a0	; add it to the first <MULEXPR>
                        	;	BVS.L	QHOW		brnch if there's an overflow
FFFC3CA8 FC000AE3		bra		XP23		; else go back for more operations
                        	XP25:
FFFC3CAC 219000EF		call	TSTC		; subtract?
FFFC3CB0 0000002D		dw		'-'
FFFC3CB4 00000863		bra		XP45
                        	XP26:
FFFC3CB8 024000EF		call	MULEXPR		; get second <MULEXPR>
FFFC3CBC 41000833		sub		v0,r0,v0	; change its sign
FFFC3CC0 FC000CE3		bra		XP24		; and do an addition
                        	XP45:
FFFC3CC4 00072803		lw		v0,[$sp]
FFFC3CC8 00472883		lw		v1,4[$sp]
FFFC3CCC 00870713		add		$sp,$sp,#8
FFFC3CD0 00072083		lw		$ra,[$sp]
FFFC3CD4 00470713		add		$sp,$sp,#4
FFFC3CD8 00008067		ret
                        	
                        	
                        	; <MULEXPR>::=<FUNCEXPR>( <* or /><FUNCEXPR> )(...
                        	
                        	MULEXPR:
FFFC3CDC FFC70713		sub		$sp,$sp,#4
FFFC3CE0 00172023		sw		$ra,[$sp]
FFFC3CE4 094000EF		call	FUNCEXPR		; get first <FUNCEXPR>
                        	XP31:
FFFC3CE8 FF870713		sub		$sp,$sp,#8
FFFC3CEC 01072023		sw		v0,[$sp]; yes, save that first result
FFFC3CF0 01172223		sw		v1,4[$sp]
FFFC3CF4 1D1000EF		call	TSTC		; multiply?
FFFC3CF8 0000002A		dw		'*'
FFFC3CFC 00000E63		bra		XP34
FFFC3D00 078000EF		call	FUNCEXPR		; get second <FUNCEXPR>
FFFC3D04 00072903		lw		a0,[$sp]
FFFC3D08 00472983		lw		a1,4[$sp]
FFFC3D0C 00870713		add		$sp,$sp,#8
FFFC3D10 03280833		mul		v0,v0,a0	; multiply the two
FFFC3D14 FC000AE3		bra		XP31        ; then look for more terms
                        	XP34:
FFFC3D18 1AD000EF		call	TSTC		; divide?
FFFC3D1C 0000002F		dw		'/'
FFFC3D20 00000E63		bra		XP35
FFFC3D24 054000EF		call	FUNCEXPR		; get second <FUNCEXPR>
FFFC3D28 00072903		lw		a0,[$sp]
FFFC3D2C 00472983		lw		a1,4[$sp]
FFFC3D30 00870713		add		$sp,$sp,#8
FFFC3D34 03284833		div		v0,v0,a0	; do the division
FFFC3D38 FA0008E3		bra		XP31		; go back for any more terms
                        	XP35:
FFFC3D3C 189000EF		call	TSTC
FFFC3D40 00000025		dw		'%'
FFFC3D44 00000E63		bra		XP47
FFFC3D48 030000EF		call	FUNCEXPR
FFFC3D4C 00072903		lw		a0,[$sp]
FFFC3D50 00472983		lw		a1,4[$sp]
FFFC3D54 00870713		add		$sp,$sp,#8
FFFC3D58 03286833		rem		v0,v0,a0
FFFC3D5C F80006E3		bra		XP31
                        	XP47:
FFFC3D60 00072803		lw		v0,[$sp]
FFFC3D64 00472883		lw		v1,4[$sp]
FFFC3D68 00870713		add		$sp,$sp,#8
FFFC3D6C 00072083		lw		$ra,[$sp]
FFFC3D70 00470713		add		$sp,$sp,#4
FFFC3D74 00008067		ret
                        	
                        	
                        	; Functions are called through FUNCEXPR
                        	; <FUNCEXPR>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	
                        	FUNCEXPR:
FFFC3D78 FFC70713		sub		$sp,$sp,#4
FFFC3D7C 00172023		sw		$ra,[$sp]
FFFC3D80 FFFC3EB7	  ldi		$t3,#TAB4		; find possible function
FFFC3D84 FCFE8E93
FFFC3D88 FFFC3F37	  ldi		$t4,#TAB4_1
FFFC3D8C 05AF0F13
FFFC3D90 B20FF06F		jmp		EXEC        ; branch to function which does subsequent ret for FUNCEXPR
                        	XP40:                   ; we get here if it wasn't a function
FFFC3D94 00006933		mov		a0,x0
FFFC3D98 070000EF		call	TSTV
FFFC3D9C 00080A63		beq   v0,x0,XP41	; not a variable
FFFC3DA0 00082803		lw		$v0,[$v0]		; if a variable, return its value in v0
FFFC3DA4 00072083		lw		$ra,[$sp]
FFFC3DA8 00470713		add		$sp,$sp,#4
FFFC3DAC 00008067		ret
                        	XP41:
FFFC3DB0 161000EF		call	TSTNUM		; or is it a number?
FFFC3DB4 00089463		bne		v1,x0,XP46	; (if not, # of digits will be zero) if so, return it in v0
FFFC3DB8 010000EF		call	PARN        ; check for (EXPR)
                        	XP46:
FFFC3DBC 00072083		lw		$ra,[$sp]
FFFC3DC0 00470713		add		$sp,$sp,#4
FFFC3DC4 00008067		ret
                        	
                        	
                        	; Check for a parenthesized expression
                        	PARN:
FFFC3DC8 FFC70713		sub		$sp,$sp,#4
FFFC3DCC 00172023		sw		$ra,[$sp]	
FFFC3DD0 0F5000EF		call	TSTC		; else look for ( OREXPR )
FFFC3DD4 00000028		dw		'('
FFFC3DD8 02000063		bra		XP43
FFFC3DDC BEDFF0EF		call	OREXPR
FFFC3DE0 0E5000EF		call	TSTC
FFFC3DE4 00000029		dw		')'
FFFC3DE8 00000863		bra		XP43
                        	XP42:
FFFC3DEC 00072083		lw		$ra,[$sp]
FFFC3DF0 00470713		add		$sp,$sp,#4
FFFC3DF4 00008067		ret
                        	XP43:
FFFC3DF8 00470713		add		$sp,$sp,#4		; get rid of return address
FFFC3DFC FFFC5937		ldi		a0,#msgWhat
FFFC3E00 AD890913
FFFC3E04 41C0006F		jmp		ERROR
                        	
                        	
                        	; ===== Test for a valid variable name.  Returns Z=1 if not
                        	;	found, else returns Z=0 and the address of the
                        	;	variable in a0.
                        	; Parameters
                        	;		a0 = 1 = allocate if not found
                        	; Returns
                        	;		v0 = address of variable, zero if not found
                        	
                        	TSTV:
FFFC3E08 FF870713		sub		$sp,$sp,#8
FFFC3E0C 00572023		sw		r5,[$sp]
FFFC3E10 00172223		sw		$ra,4[$sp]
FFFC3E14 000962B3		mov		r5,a0		; r5=allocate flag
FFFC3E18 16D000EF		call	IGNBLK
FFFC3E1C 000E4903		lbu		a0,[$t2]		; look at the program text
FFFC3E20 04006D93		ldi		$t1,#'@'
FFFC3E24 07B94263		blt		a0,$t1,tstv_notfound	; C=1: not a variable
FFFC3E28 03B91E63		bne		a0,$t1,TV1				; brnch if not "@" array
FFFC3E2C 001E0E13		add		$t2,$t2,#1	; If it is, it should be
FFFC3E30 F99FF0EF		call	PARN		; followed by (EXPR) as its index.
                        	;	BCS.L	QHOW		say "How?" if index is too big
FFFC3E34 00000263		bra		TV3
                        	TV3:
FFFC3E38 FFC70713		sub		$sp,$sp,#4	; save the index
FFFC3E3C 01072023		sw		v0,[$sp]
FFFC3E40 2D0000EF		call	SIZEX		; get amount of free memory
FFFC3E44 00072983		lw		a1,[$sp]
FFFC3E48 00470713		add		$sp,$sp,#4	; get back the index
FFFC3E4C 0109C663		blt		a1,v0,TV2		; see if there's enough memory
FFFC3E50 00870713		add		$sp,$sp,#8
FFFC3E54 3B80006F		jmp   QSORRY		; if not, say "Sorry"
                        	TV2:
FFFC3E58 70802903		lw		a0,VARBGN	; put address of array element...
FFFC3E5C 41390833		sub   v0,a0,a1    ; into a0 (neg. offset is used)
FFFC3E60 00000C63		bra   TSTVRT
                        	TV1:	
FFFC3E64 038000EF	  call	getVarName      ; get variable name
FFFC3E68 00080863	  beq   v0,x0,TSTVRT    ; if not, return v0=0
FFFC3E6C 00086933	  mov		a0,v0
FFFC3E70 0002E9B3	  mov		a1,r5
FFFC3E74 0D4000EF	  call	findVar     ; find or allocate
                        	TSTVRT:
FFFC3E78 00072283		lw		r5,[$sp]
FFFC3E7C 00472083		lw		$ra,4[$sp]
FFFC3E80 00870713		add		$sp,$sp,#8
FFFC3E84 00008067		ret								; v0<>0 (if found)
                        	tstv_notfound:
FFFC3E88 00072283		lw		r5,[$sp]
FFFC3E8C 00472083		lw		$ra,4[$sp]
FFFC3E90 00870713		add		$sp,$sp,#8
FFFC3E94 00006833		mov		v0,x0				; v0=0 if not found
FFFC3E98 00008067	  ret
                        	
                        	; Get a variable name. Called after blanks have been ignored.
                        	;
                        	; Returns
                        	;   v0 = 3 character variable name + type
                        	;
                        	getVarName:
FFFC3E9C FF470713		sub		$sp,$sp,#12
FFFC3EA0 00572023		sw		r5,[$sp]
FFFC3EA4 00172223		sw		$ra,4[$sp]
FFFC3EA8 000E4903	  lbu   a0,[$t2]		; get first character
FFFC3EAC 01272423	  sw		a0,8[$sp]		; save off current name
FFFC3EB0 BF9FF0EF	  call	isAlpha
FFFC3EB4 08080063	  beq   v0,r0,gvn1
FFFC3EB8 00206293	  ldi	  r5,#2       ; loop two more times
                        	
                        		; check for second/third character
                        	gvn4:
FFFC3EBC 001E0E13		add		$t2,$t2,#1
FFFC3EC0 000E4903		lbu   a0,[$t2]		; do we have another char ?
FFFC3EC4 C15FF0EF		call	isAlnum
FFFC3EC8 02080863		beq   v0,x0,gvn2	; nope
FFFC3ECC 00872903		lw		a0,8[$sp]		; get varname
FFFC3ED0 00891913		sll		a0,a0,#8
FFFC3ED4 000E4983		lbu   a1,[$t2]
FFFC3ED8 01396933		or    a0,a0,a1   	; add in new char
FFFC3EDC 01272423	  sw		a0,8[$sp]		; save off current name again
FFFC3EE0 FFF28293	  sub		r5,r5,#1
FFFC3EE4 FC504CE3	  bgt		r5,x0,gvn4
                        	
                        	 	; now ignore extra variable name characters
                        	gvn6:
FFFC3EE8 001E0E13		add		$t2,$t2,#1
FFFC3EEC 000E4903		lbu   a0,[$t2]		; do we have another char ?
FFFC3EF0 BE9FF0EF	  call  isAlnum
FFFC3EF4 FE081AE3	  bne   v0,x0,gvn6	; keep looping as long as we have identifier chars
                        	
                        	  ; check for a variable type
                        	gvn2:
FFFC3EF8 000E4983		lbu   a1,[$t2]
FFFC3EFC 02506D93		ldi		$t1,#'%'
FFFC3F00 01B98A63		beq		a1,$t1,gvn3
FFFC3F04 02406D93		ldi		$t1,#'$'
FFFC3F08 01B98663		beq		a1,$t1,gvn3
FFFC3F0C FFFE0E13	  sub		$t2,$t2,#1
FFFC3F10 02E06993	  ldi		$a1,#'.'		; if no variable type assume float
                        	
                        	  ; insert variable type indicator and return
                        	gvn3:
FFFC3F14 001E0E13		add		$t2,$t2,#1
FFFC3F18 00872903		lw		a0,8[$sp]		; get varname
FFFC3F1C 00891913		sll		a0,a0,#8
FFFC3F20 01396833	  or    v0,a0,a1    ; add in variable type
FFFC3F24 00072283	  lw		r5,[$sp]
FFFC3F28 00472083	  lw		$ra,4[$sp]
FFFC3F2C 00C70713	  add		$sp,$sp,#12
FFFC3F30 00008067	  ret								; return a0 = varname
                        	
                        	  ; not a variable name
                        	gvn1:
FFFC3F34 00072283		lw		r5,[$sp]
FFFC3F38 00472083	  lw		$ra,4[$sp]
FFFC3F3C 00C70713		add		$sp,$sp,#12
FFFC3F40 00006833	  mov		v0,x0       ; return v0 = 0 if not a varname
FFFC3F44 00008067	  ret
                        	
                        	
                        	; Find variable
                        	;   a0 = varname
                        	;		a1 = allocate flag
                        	; Returns
                        	;   v0 = variable address, Z =0 if found / allocated, Z=1 if not found
                        	
                        	findVar:
FFFC3F48 FF870713		sub		$sp,$sp,#8
FFFC3F4C 00772023		sw		x7,[$sp]
FFFC3F50 00372223		sw		x3,4[$sp]
FFFC3F54 70802183	  lw    x3,VARBGN
                        	fv4:
FFFC3F58 0001A383	  lw    x7,[x3]     ; get varname / type
FFFC3F5C 02038663	  beq   x7,x0,fv3		; no more vars ?
FFFC3F60 02790863	  beq   a0,x7,fv1		; match ?
FFFC3F64 00818193		add		x3,x3,#8		; move to next var
FFFC3F68 70C02383	  lw    x7,VAREND		; 
FFFC3F6C FE71C6E3	  blt   x3,x7,fv4		; loop back to look at next var
                        	
                        	  ; variable not found
                        	  ; no more memory
FFFC3F70 00072383	  lw		x7,[$sp]
FFFC3F74 00472183	  lw		x3,4[$sp]
FFFC3F78 00870713	  add		$sp,$sp,#8
FFFC3F7C FFFC5937	  ldi		a0,#msgVarSpace
FFFC3F80 B2690913
FFFC3F84 29C0006F	  jmp   ERROR
                        	
                        	  ; variable not found
                        	  ; allocate new ?
                        	fv3:
FFFC3F88 00098E63		beq		a1,x0,fv2
FFFC3F8C 0121A023	  sw    a0,[x3]     ; save varname / type
                        	  ; found variable
                        	  ; return address
                        	fv1:
FFFC3F90 00418813	  add		v0,x3,#4
FFFC3F94 00072383	  lw		x7,[$sp]
FFFC3F98 00472183	  lw		x3,4[$sp]
FFFC3F9C 00870713	  add		$sp,$sp,#8
FFFC3FA0 00008067	  ret			    			; v0 = address
                        	
                        	  ; didn't find var and not allocating
                        	fv2:
FFFC3FA4 00072383	  lw		x7,[$sp]
FFFC3FA8 00472183	  lw		x3,4[$sp]
FFFC3FAC 00870713	  add		$sp,$sp,#8
FFFC3FB0 00006833		mov		v0,x0				; v0 = nullptr
FFFC3FB4 00008067	  ret
                        	
                        	; The following functions are entered via a jump instruction with
                        	; the return address already saved.
                        	
                        	; ===== The PEEK function returns the byte stored at the address
                        	;	contained in the following expression.
                        	;
                        	PEEK:
FFFC3FB8 E11FF0EF		call	PARN		; get the memory address
FFFC3FBC 00080803		lb		v0,[v0]		; get the addressed byte
FFFC3FC0 000068B3		mov		v1,x0			; type = int
FFFC3FC4 00072083		lw		$ra,[$sp]
FFFC3FC8 00470713		add		$sp,$sp,#4
FFFC3FCC 00008067		ret
                        	PEEKW:
FFFC3FD0 DF9FF0EF		call	PARN		; get the memory address
FFFC3FD4 00082803		lw		v0,[v0]		; get the addressed word
FFFC3FD8 000068B3		mov		v1,x0			; type = int
FFFC3FDC 00072083		lw		$ra,[$sp]
FFFC3FE0 00470713		add		$sp,$sp,#4
FFFC3FE4 00008067		ret
                        	PEEKH:
FFFC3FE8 DE1FF0EF		call	PARN		; get the memory address
FFFC3FEC 00081803		lh		v0,[v0]		; get the addressed byte
FFFC3FF0 000068B3		mov		v1,x0			; type = int
FFFC3FF4 00072083		lw		$ra,[$sp]
FFFC3FF8 00470713		add		$sp,$sp,#4
FFFC3FFC 00008067		ret
                        	
                        	
                        	; user function call
                        	; call the user function with argument in a0, type in a1
                        	USRX:
FFFC4000 FFC70713		sub		$sp,$sp,#4
FFFC4004 01A72023		sw		$t0,[$sp]
FFFC4008 DC1FF0EF		call	PARN		; get expression value
FFFC400C 00086933		mov		a0,v0
FFFC4010 0008E9B3		mov		a1,v1
FFFC4014 FFC70713		sub		$sp,$sp,#4	; save the text pointer
FFFC4018 01C72023		sw		$t2,[$sp]
FFFC401C 7A002D03		lw		$t0,usrJmp
FFFC4020 000D00E7		call	[$t0]			; get usr vector, jump to the subroutine
FFFC4024 00072E03		lw		$t2,[$sp]	; restore the text pointer
FFFC4028 00470713		add		$sp,$sp,#4
FFFC402C 00072D03		lw		$t0,[$sp]
FFFC4030 00470713		add		$sp,$sp,#4
FFFC4034 00072083		lw		$ra,[$sp]
FFFC4038 00470713		add		$sp,$sp,#4
FFFC403C 00008067		ret
                        	
                        	
                        	; ===== The RND function returns a random number from 1 to
                        	;	the value of the following expression in D0.
                        	;
                        	RND:
FFFC4040 D89FF0EF		call	PARN		; get the upper limit
FFFC4044 04080063		beq		v0,r0,rnd2	; it must be positive and non-zero
FFFC4048 02084663		blt		v0,r0,rnd1
FFFC404C 000869B3		mov		a1,v0
FFFC4050 000868B3		mov		v1,v0
FFFC4054 00000637		call	gen_rand	; generate a random number
FFFC4058 347600E7
FFFC405C 03186833		rem		v0,v0,v1
FFFC4060 00180813		add		v0,v0,#1
FFFC4064 000068B3		mov		v1,x0
FFFC4068 00072083		lw		$ra,[$sp]
FFFC406C 00470713		add		$sp,$sp,#4
FFFC4070 00008067		ret
                        	rnd1:
FFFC4074 FFFC5937		ldi		a0,#msgRNDBad
FFFC4078 B9090913
FFFC407C 00470713		add		$sp,$sp,#4
FFFC4080 1A00006F		jmp		ERROR
                        	rnd2:
FFFC4084 00000637		call	gen_rand	; generate a random number
FFFC4088 347600E7
FFFC408C 000068B3		mov		v1,x0
FFFC4090 00072083		lw		$ra,[$sp]
FFFC4094 00470713		add		$sp,$sp,#4
FFFC4098 00008067		ret
                        	
                        	; ===== The ABS function returns an absolute value in a1.
                        	;
                        	ABS:
FFFC409C D2DFF0EF		call	PARN		; get the following expr.'s value
FFFC40A0 00084863		blt		v0,r0,ABS1
FFFC40A4 00072083		lw		$ra,[$sp]
FFFC40A8 00470713		add		$sp,$sp,#4
FFFC40AC 00008067		ret
                        	ABS1:
FFFC40B0 41000833		sub		v0,x0,v0
FFFC40B4 00072083		lw		$ra,[$sp]
FFFC40B8 00470713		add		$sp,$sp,#4
FFFC40BC 00008067		ret
                        	
                        	
                        	;==== The TICK function returns the cpu tick value in a0.
                        	;
                        	TICKX:
FFFC40C0 C0001873		csrrw	v0,#$C00,x0
FFFC40C4 000068B3		mov		v1,x0
FFFC40C8 00072083		lw		$ra,[$sp]
FFFC40CC 00470713		add		$sp,$sp,#4
FFFC40D0 00008067		ret
                        	
                        	; ===== The SGN function returns the sign in a0. +1,0, or -1
                        	;
                        	SGN:
FFFC40D4 CF5FF0EF		call	PARN		; get the following expr.'s value
FFFC40D8 000068B3		mov		v1,x0
FFFC40DC 02080463		beq		v0,r0,SGN1
FFFC40E0 00084A63		blt		v0,r0,SGN2
FFFC40E4 00106813		ldi		v0,#1
FFFC40E8 00072083		lw		$ra,[$sp]
FFFC40EC 00470713		add		$sp,$sp,#4
FFFC40F0 00008067		ret
                        	SGN2:
FFFC40F4 FFF06813		ldi		v0,#-1
FFFC40F8 00072083		lw		$ra,[$sp]
FFFC40FC 00470713		add		$sp,$sp,#4
FFFC4100 00008067		ret
                        	SGN1:
FFFC4104 00072083		lw		$ra,[$sp]
FFFC4108 00470713		add		$sp,$sp,#4
FFFC410C 00008067		ret	
                        	
                        	; ===== The SIZE function returns the size of free memory in v0.
                        	; does not consider memory used by @()
                        	;
                        	SIZEX:
FFFC4110 70802803		lw		v0,VARBGN	; get the number of free bytes...
FFFC4114 70402883		lw		v1,TXTUNF	; between 'TXTUNF' and 'VARBGN'
FFFC4118 41180833		sub		v0,v0,v1
FFFC411C 000068B3		mov		v1,x0			; type = int
FFFC4120 00072083		lw		$ra,[$sp]
FFFC4124 00470713		add		$sp,$sp,#4
FFFC4128 00008067		ret					; return the number in v0
                        	
                        	
                        	;******************************************************************
                        	;
                        	; *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                        	;
                        	; 'SETVAL' expects a variable, followed by an equal sign and then
                        	; an expression.  It evaluates the expression and sets the variable
                        	; to that value.
                        	;
                        	; returns
                        	; a1 = variable's address
                        	;
                        	SETVAL:
FFFC412C FFC70713		sub		$sp,$sp,#4
FFFC4130 00172023		sw		$ra,[$sp]
FFFC4134 00106913	  ldi		a0,#1		; allocate var
FFFC4138 CD1FF0EF	  call	TSTV		; variable name?
FFFC413C 00081A63	  bne		v0,x0,.sv2
FFFC4140 FFFC5937	 	ldi		a0,#msgVar
FFFC4144 B7A90913
FFFC4148 00470713		add		$sp,$sp,#4
FFFC414C 0D40006F	 	jmp		ERROR 
                        	.sv2:
FFFC4150 FFC70713		sub		$sp,$sp,#4
FFFC4154 01072023		sw		v0,[$sp]	; save the variable's address
FFFC4158 56C000EF		call	TSTC			; get past the "=" sign
FFFC415C 0000003D		dw		'='
FFFC4160 02000663		bra		SV1
FFFC4164 865FF0EF		call	OREXPR		; evaluate the expression
FFFC4168 00072983		lw		a1,[$sp]	; get back the variable's address
FFFC416C 00470713		add		$sp,$sp,#4
FFFC4170 0109A023		sw    v0,[a1]   ; and save value in the variable
FFFC4174 0009E833		mov		v0,a1			; return v0 = variable address
FFFC4178 FFC9A883		lw		v1,-4[a1]
FFFC417C 0FF8F893		and		v1,v1,#$FF
FFFC4180 00072083		lw		$ra,[$sp]
FFFC4184 00470713		add		$sp,$sp,#4
FFFC4188 00008067		ret
                        	SV1:
FFFC418C 00470713		add		$sp,$sp,#4
FFFC4190 0880006F	  jmp	  QWHAT		; if no "=" sign
                        	
                        	
                        	; 'FIN' checks the end of a command.  If it ended with ":",
                        	; execution continues.	If it ended with a CR, it finds the
                        	; the next line and continues from there.
                        	;
                        	FIN:
FFFC4194 FFC70713		sub		$sp,$sp,#4
FFFC4198 00172023		sw		$ra,[$sp]
FFFC419C 528000EF		call	TSTC		; *** FIN ***
FFFC41A0 0000003A		dw		':'
FFFC41A4 00000663		bra		FI1
FFFC41A8 00470713		add		$sp,$sp,#4	; if ":", discard return address
FFFC41AC 820FF06F		jmp		RUNSML		; continue on the same line
                        	FI1:
FFFC41B0 514000EF		call	TSTC		; not ":", is it a CR?
FFFC41B4 0000000D		dw		CR
FFFC41B8 00000663		bra		FI2
                        							; else return to the caller
FFFC41BC 00470713		add		$sp,$sp,#4	; yes, purge return address
FFFC41C0 FA5FE06F		jmp		RUNNXL		; execute the next line
                        	FI2:
FFFC41C4 00072083		lw		$ra,[$sp]
FFFC41C8 00470713		add		$sp,$sp,#4
FFFC41CC 00008067		ret					; else return to the caller
                        	
                        	
                        	; 'ENDCHK' checks if a command is ended with a CR. This is
                        	; required in certain commands, such as GOTO, RETURN, STOP, etc.
                        	;
                        	; Check that there is nothing else on the line
                        	; Registers Affected
                        	;   a0
                        	;
                        	ENDCHK:
FFFC41D0 FFC70713		sub		$sp,$sp,#4
FFFC41D4 00172023		sw		$ra,[$sp]
FFFC41D8 5AC000EF		call	IGNBLK
FFFC41DC 000E4903		lbu		a0,[$t2]
FFFC41E0 00D06D93		ldi		$t1,#CR
FFFC41E4 01B90863		beq		a0,$t1,ec1	; does it end with a CR?
FFFC41E8 FFFC5937		ldi		a0,#msgExtraChars
FFFC41EC C4B90913
FFFC41F0 0300006F		jmp		ERROR
                        	ec1:
FFFC41F4 00072083		lw		$ra,[$sp]
FFFC41F8 00470713		add		$sp,$sp,#4
FFFC41FC 00008067		ret
                        	
                        	; 'ERROR' prints the string pointed to by a0. It then prints the
                        	; line pointed to by CURRNT with a "?" inserted at where the
                        	; old text pointer (should be on top of the stack) points to.
                        	; Execution of Tiny BASIC is stopped and a warm start is done.
                        	; If CURRNT is zero (indicating a direct command), the direct
                        	; command is not printed. If CURRNT is -1 (indicating
                        	; 'INPUT' command in progress), the input line is not printed
                        	; and execution is not terminated but continues at 'INPERR'.
                        	;
                        	; Related to 'ERROR' are the following:
                        	; 'QWHAT' saves text pointer on stack and gets "What?" message.
                        	; 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                        	; 'QSORRY' and 'ASORRY' do the same kind of thing.
                        	; 'QHOW' and 'AHOW' also do this for "How?".
                        	;
                        	TOOBIG:
FFFC4200 FFFC5937		ldi		a0,#msgTooBig
FFFC4204 C3790913
FFFC4208 00000C63		bra		ERROR
                        	QSORRY:
FFFC420C FFFC5937	  ldi		a0,#SRYMSG
FFFC4210 ADF90913
FFFC4214 00000663		bra	    ERROR
                        	QWHAT:
FFFC4218 FFFC5937		ldi		a0,#msgWhat
FFFC421C AD890913
                        	ERROR:
FFFC4220 644000EF		call	PRMESG		; display the error message
FFFC4224 71802903		lw		a0,CURRNT	; get the current line pointer
FFFC4228 02090C63		beq		a0,r0,ERROR1	; if zero, do a warm start
FFFC422C FFF06D93		ldi		$t1,#-1
FFFC4230 AFB90463		beq		a0,$t1,INPERR	; is the line no. pointer = -1? if so, redo input
FFFC4234 000E4283		lbu		r5,[$t2]		; save the char. pointed to
FFFC4238 000E0023		sb		x0,[$t2]		; put a zero where the error is
FFFC423C 71802903		lw		a0,CURRNT	; point to start of current line
FFFC4240 428000EF		call	PRTLN		; display the line in error up to the 0
FFFC4244 00096333		mov     r6,a0	    ; save off end pointer
FFFC4248 005E0023		sb		r5,[$t2]		; restore the character
FFFC424C 03F06913		ldi		a0,#'?'		; display a "?"
FFFC4250 AB9FE0EF		call	GOOUT
FFFC4254 000069B3		mov		a1,r0		; stop char = 0
FFFC4258 FFF30913		sub		a0,r6,#1	; point back to the error char.
FFFC425C 23C000EF		call	PRTSTG		; display the rest of the line
                        	ERROR1:
FFFC4260 B61FE06F		jmp	    WSTART		; and do a warm start
                        	
                        	;******************************************************************
                        	;
                        	; *** GETLN *** FNDLN (& friends) ***
                        	;
                        	; 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                        	; the character in r3 (given by the caller), then it fills the
                        	; buffer and echos. It ignores LF's but still echos
                        	; them back. Control-H is used to delete the last character
                        	; entered (if there is one), and control-X is used to delete the
                        	; whole line and start over again. CR signals the end of a line,
                        	; and causes 'GETLN' to return.
                        	;
                        	;
                        	GETLN:
FFFC4264 FF870713		sub		$sp,$sp,#8
FFFC4268 00572023		sw		r5,[$sp]
FFFC426C 00172223		sw		$ra,4[$sp]
FFFC4270 A99FE0EF		call	GOOUT		; display the prompt
FFFC4274 00106913		ldi		a0,#1
                        	;	sw		a0,CursorFlash	; turn on cursor flash
FFFC4278 02006913		ldi		a0,#' '		; and a space
FFFC427C A8DFE0EF		call	GOOUT
FFFC4280 71C06E13		ldi		$t2,#BUFFER	; $t2 is the buffer pointer
                        	.GL1:
FFFC4284 5B0000EF		call	CHKIO		; check keyboard
FFFC4288 FE080EE3		beq		v0,x0,.GL1	; wait for a char. to come in
FFFC428C 00806D93		ldi		$t1,#CTRLH
FFFC4290 05B80663		beq		v0,$t1,.GL3	; delete last character? if so
FFFC4294 01806D93		ldi		$t1,#CTRLX
FFFC4298 07B80663		beq		v0,$t1,.GL4	; delete the whole line?
FFFC429C 00D06D93		ldi		$t1,#CR
FFFC42A0 01B80663		beq		v0,$t1,.GL2		; accept a CR
FFFC42A4 02006D93		ldi		$t1,#' '
FFFC42A8 FDB84EE3		blt		v0,$t1,.GL1	; if other control char., discard it
                        	.GL2:
FFFC42AC 010E0023		sb		v0,[$t2]		; save the char.
FFFC42B0 001E0E13		add		$t2,$t2,#1
FFFC42B4 FFC70713		sub		$sp,$sp,#4
FFFC42B8 01072023		sw		v0,[$sp]
FFFC42BC 00086933		mov		$a0,$v0
FFFC42C0 A49FE0EF		call	GOOUT		; echo the char back out
FFFC42C4 00072803		lw		v0,[$sp]; get char back (GOOUT destroys a0)
FFFC42C8 00470713		add		$sp,$sp,#4
FFFC42CC 00D06D93		ldi		$t1,#CR
FFFC42D0 07B80663		beq		v0,$t1,.GL7			; if it's a CR, end the line
FFFC42D4 76F06D93		ldi		$t1,#BUFFER+BUFLEN-1
FFFC42D8 FBBE46E3		blt		$t2,$t1,.GL1		; any more room? ; yes: get some more, else delete last char.
                        	.GL3:
FFFC42DC 00806913		ldi		a0,#CTRLH	; delete a char. if possible
FFFC42E0 A29FE0EF		call	GOOUT
FFFC42E4 02006913		ldi		a0,#' '
FFFC42E8 A21FE0EF		call	GOOUT
FFFC42EC 71C06D93		ldi		$t1,#BUFFER
FFFC42F0 F9CDDAE3		ble		$t2,$t1,.GL1	; any char.'s left?	; if not
FFFC42F4 00806913		ldi		a0,#CTRLH		; if so, finish the BS-space-BS sequence
FFFC42F8 A11FE0EF		call	GOOUT
FFFC42FC FFFE0E13		sub		$t2,$t2,#1	; decrement the text pointer
FFFC4300 F80002E3		bra		.GL1		; back for more
                        	.GL4:
FFFC4304 000E6933		mov		a0,$t2		; delete the whole line
FFFC4308 8E490293		sub		r5,a0,#BUFFER   ; figure out how many backspaces we need
FFFC430C 02028463		beq		r5,r0,.GL6		; if none needed, brnch
FFFC4310 FFF28293		sub		r5,r5,#1		; loop count is one less
                        	.GL5:
FFFC4314 00806913		ldi		a0,#CTRLH		; and display BS-space-BS sequences
FFFC4318 9F1FE0EF		call	GOOUT
FFFC431C 02006913		ldi		a0,#' '
FFFC4320 9E9FE0EF		call	GOOUT
FFFC4324 00806913		ldi		a0,#CTRLH
FFFC4328 9E1FE0EF		call	GOOUT
FFFC432C FFF28293		sub		r5,r5,#1
FFFC4330 FE0292E3		bne		r5,r0,.GL5
                        	.GL6:
FFFC4334 71C06E13		ldi		$t2,#BUFFER	; reinitialize the text pointer
FFFC4338 F40006E3		bra		.GL1		; and go back for more
                        	.GL7:
FFFC433C 000E0023		sb		x0,[$t2]		; null terminate line
                        	;	sw		x0,CursorFlash	; turn off cursor flash
FFFC4340 00A06913		ldi		a0,#LINEFD	; echo a LF for the CR
FFFC4344 9C5FE0EF		call	GOOUT
FFFC4348 00072283		lw		r5,[$sp]
FFFC434C 00472083		lw		$ra,4[$sp]
FFFC4350 00870713		add		$sp,$sp,#8
FFFC4354 00008067		ret
                        	
                        	
                        	; 'FNDLN' finds a line with a given line no. (in a0) in the
                        	; text save area.  $t3 is used as the text pointer. If the line
                        	; is found, $t3 will point to the beginning of that line
                        	; (i.e. the high byte of the line no.), and $v0 = 1.
                        	; If that line is not there and a line with a higher line no.
                        	; is found, $t3 points there and $v0 = 0. If we reached
                        	; the end of the text save area and cannot find the line, flags
                        	; $t3 = 0, $v0 = 0.
                        	; $v0=1 if line found
                        	; r0 = 1	<= line is found
                        	;	$t3 = pointer to line
                        	; r0 = 0    <= line is not found
                        	;	r9 = zero, if end of text area
                        	;	r9 = otherwise higher line number
                        	;
                        	; 'FNDLN' will initialize $t3 to the beginning of the text save
                        	; area to start the search. Some other entries of this routine
                        	; will not initialize $t3 and do the search.
                        	; 'FNDLNP' will start with $t3 and search for the line no.
                        	; 'FNDNXT' will bump $t3 by 4, find a CR and then start search.
                        	; 'FNDSKP' uses $t3 to find a CR, and then starts the search.
                        	; return Z=1 if line is found, r9 = pointer to line
                        	;
                        	; Parameters
                        	;	a0 = line number to find
                        	;
                        	FNDLN:
FFFC4358 00100DB7		ldi		$t1,#$FFFFF
FFFC435C FFFD8D93
FFFC4360 01B94863		blt		a0,$t1,fl1	; line no. must be < 65535
FFFC4364 FFFC5937		ld		a0,#msgLineRange
FFFC4368 B6590913
FFFC436C EB5FF06F		jmp		ERROR
                        	fl1:
FFFC4370 00002EB7		ldi		$t3,#TXTBGN	; init. the text save pointer
FFFC4374 800E8E93
                        	
                        	FNDLNP:
FFFC4378 70402F03		lw		$t4,TXTUNF	; check if we passed the end
FFFC437C 05EEF463		bgeu	$t3,$t4,FNDRET1; if so, return with r9=0,a0=0
FFFC4380 FF870713		sub		$sp,$sp,#8	; push a0
FFFC4384 01272023		sw		a0,[$sp]
FFFC4388 00172223		sw		ra,4[$sp]
FFFC438C 000EE933		mov		a0,t3
FFFC4390 2AC000EF		call	LoadWord		; get line number
FFFC4394 00072903		lw		a0,[$sp]		; pop a0
FFFC4398 00472083		lw		ra,4[$sp]
FFFC439C 00870713		add		$sp,$sp,#8
FFFC43A0 03280663		beq		v0,a0,FNDRET2
FFFC43A4 03286863		bltu	v0,a0,FNDNXT	; is this the line we want? no, not there yet
                        	FNDRET:
FFFC43A8 004E8E93		add		$t3,$t3,#4	; find the next line, skip over line number
                        	.0001:
FFFC43AC 000EC883		lbu		v1,[$t3]
FFFC43B0 001E8E93		add		$t3,$t3,#1
FFFC43B4 00D06D93		ldi		$t1,#CR
FFFC43B8 FFB89AE3		bne		v1,$t1,.0001	; try to find a CR, keep looking
FFFC43BC 00006833		mov		v0,x0	; line not found, but $t3=next line pointer
FFFC43C0 00008067		ret
                        	FNDRET1:
                        	;	eor		r9,r9,r9	; no higher line
FFFC43C4 00006833		mov		v0,x0	; line not found
FFFC43C8 00008067		ret
                        	FNDRET2:
FFFC43CC 00106813		ldi		v0,#1	; line found
FFFC43D0 00008067		ret
                        	
                        	FNDNXT:
FFFC43D4 004E8E93		add		$t3,$t3,#4	; find the next line
                        	
                        	FNDSKP:
FFFC43D8 000EC883		lbu		v1,[$t3]
FFFC43DC 001E8E93		add		$t3,$t3,#1
FFFC43E0 00D06D93		ldi		$t1,#CR
FFFC43E4 FFB89AE3		bne		v1,$t1,FNDSKP	; try to find a CR, keep looking
FFFC43E8 F80008E3		bra		FNDLNP		; check if end of text
                        	
                        	
                        	;******************************************************************
                        	; 'MVUP' moves a block up from where a0 points to where a1 points
                        	; until a0=a2
                        	;
                        	MVUP1:
FFFC43EC 00090203		lb		r4,[a0]
FFFC43F0 00498023		sb		r4,[a1]
FFFC43F4 00190913		add		a0,a0,#1
FFFC43F8 00198993		add		a1,a1,#1
                        	MVUP:
FFFC43FC FF4918E3		bne		a0,a2,MVUP1
FFFC4400 00008067		ret
                        	
                        	
                        	; 'MVDOWN' moves a block down from where a0 points to where a1
                        	; points until a0=a2
                        	;
                        	MVDOWN1:
FFFC4404 FFF90913		sub		a0,a0,#1
FFFC4408 FFF98993		sub		a1,a1,#1
FFFC440C 00090203		lb		r4,[a0]
FFFC4410 00498023		sb		r4,[a1]
                        	MVDOWN:
FFFC4414 FF4918E3		bne		a0,a2,MVDOWN1
FFFC4418 00008067		ret
                        	
                        	
                        	; 'POPA_' restores the 'FOR' loop variable save area from the stack
                        	;
                        	; 'PUSHA_' stacks for 'FOR' loop variable save area onto the stack
                        	;
                        	; Note: a single zero word is stored on the stack in the
                        	; case that no FOR loops need to be saved. This needs to be
                        	; done because PUSHA_ / POPA_ is called all the time.
                        	//message "POPA_"
                        	POPA_:
FFFC441C 00072903		lw		a0,[$sp]
FFFC4420 00470713		add		$sp,$sp,#4
FFFC4424 71202823		sw		a0,LOPVAR	; restore LOPVAR, but zero means no more
FFFC4428 02090463		beq		a0,x0,PP1
FFFC442C 00072903		lw		a0,[$sp]
FFFC4430 77202823		sw		a0,LOPPT
FFFC4434 00472903		lw		a0,4[$sp]
FFFC4438 77202A23		sw		a0,LOPLN
FFFC443C 00872903		lw		a0,8[$sp]
FFFC4440 77202E23		sw		a0,LOPLMT
FFFC4444 00C72903		lw		a0,12[$sp]
FFFC4448 77202C23		sw		a0,LOPINC
FFFC444C 01070713		add		$sp,$sp,#16
                        	PP1:
FFFC4450 00008067		ret
                        	
                        	
                        	PUSHA_:
FFFC4454 79C02903		lw		a0,STKBOT	; Are we running out of stack room?
FFFC4458 01490913		add		a0,a0,#20	; we might need this many bytes
FFFC445C DB2748E3		blt		$sp,a0,QSORRY	; out of stack space
FFFC4460 71002983		lw		a1,LOPVAR		; save loop variables
FFFC4464 02098463		beq		a1,x0,PU1		; if LOPVAR is zero, that's all
FFFC4468 FF070713		sub		$sp,$sp,#16
FFFC446C 77002903		lw		a0,LOPPT
FFFC4470 01272023		sw		a0,[$sp]
FFFC4474 77402903		lw		a0,LOPLN
FFFC4478 01272223		sw		a0,4[$sp]
FFFC447C 77C02903		lw		a0,LOPLMT
FFFC4480 01272423		sw		a0,8[$sp]
FFFC4484 77802903		lw		a0,LOPINC
FFFC4488 01272623		sw		a0,12[$sp]
                        	PU1:
FFFC448C FFC70713		sub		$sp,$sp,#4
FFFC4490 01372023		sw		a1,[$sp]
FFFC4494 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	;
                        	; 'PRTSTG' prints a string pointed to by a0. It stops printing
                        	; and returns to the caller when either a CR is printed or when
                        	; the next byte is the same as what was passed in a1 by the
                        	; caller.
                        	;
                        	; 'PRTLN' prints the saved text line pointed to by r3
                        	; with line no. and all.
                        	;
                        	
                        	; a0 = pointer to string
                        	; a1 = stop character
                        	; return v0 = pointer to end of line + 1
                        	
                        	PRTSTG:
FFFC4498 FEC70713		sub		$sp,$sp,#20
FFFC449C 00572023		sw		r5,[$sp]
FFFC44A0 00672223		sw		r6,4[$sp]
FFFC44A4 00772423		sw		r7,8[$sp]
FFFC44A8 00172623		sw		$ra,12[$sp]
FFFC44AC 01272823		sw		$a0,16[$sp]
FFFC44B0 000962B3		mov   r5,a0	    ; r5 = pointer
FFFC44B4 0009E333		mov   r6,a1	    ; r6 = stop char
                        	.PS1:
FFFC44B8 0002C383	  lbu   r7,[r5]     ; get a text character
FFFC44BC 00128293		add		r5,r5,#1
FFFC44C0 00638E63		beq	  r7,r6,.PRTRET	; same as stop character? if so, return
FFFC44C4 0003E933		mov   a0,r7
FFFC44C8 841FE0EF		call	GOOUT		; display the char.
FFFC44CC 00D06D93		ldi		$t1,#CR
FFFC44D0 FFB394E3		bne   r7,$t1,.PS1	; is it a C.R.? no, go back for more
FFFC44D4 00A06913		ldi		a0,#LINEFD  ; yes, add a L.F.
FFFC44D8 831FE0EF		call	GOOUT
                        	.PRTRET:
FFFC44DC 0003E8B3	  mov   v1,r7	    ; return a1 = stop char
FFFC44E0 0002E833		mov		v0,r5		; return a0 = line pointer
FFFC44E4 00072283		lw		$r5,[$sp]
FFFC44E8 00472303		lw		$r6,4[$sp]
FFFC44EC 00872383		lw		$r7,8[$sp]
FFFC44F0 00C72083		lw		$ra,12[$sp]
FFFC44F4 01072903		lw		$a0,16[$sp]
FFFC44F8 01470713		add		$sp,$sp,#20
FFFC44FC 00008067	  ret					; then return
                        	
                        	
                        	; 'QTSTG' looks for an underline (back-arrow on some systems),
                        	; single-quote, or double-quote.  If none of these are found, returns
                        	; to the caller.  If underline, outputs a CR without a LF.  If single
                        	; or double quote, prints the quoted string and demands a matching
                        	; end quote.  After the printing, the next i-word of the caller is
                        	; skipped over (usually a branch instruction).
                        	;
                        	QTSTG:
FFFC4500 FFC70713		sub		$sp,$sp,#4
FFFC4504 00172023		sw		$ra,[$sp]
FFFC4508 1BC000EF		call	TSTC		; *** QTSTG ***
FFFC450C 00000022		dw		'"'
FFFC4510 02000063		bra		QT3
FFFC4514 02206993		ldi		a1,#'"'		; it is a "
                        	QT1:
FFFC4518 000E6933		mov		a0,$t2
FFFC451C F7DFF0EF		call	PRTSTG		; print until another
FFFC4520 00086E33		mov		$t2,v0
FFFC4524 00D06D93		ldi		$t1,#CR
FFFC4528 03B89863		bne		v1,$t1,QT2	; was last one a CR?
FFFC452C C39FE06F		jmp		RUNNXL		; if so run next line
                        	QT3:
FFFC4530 194000EF		call	TSTC		; is it a single quote?
FFFC4534 0000005C		dw		'\''
FFFC4538 00000663		bra		QT4
FFFC453C 02706993		ldi		a1,#'\''	; if so, do same as above
FFFC4540 FC000CE3		bra		QT1
                        	QT4:
FFFC4544 180000EF		call	TSTC		; is it an underline?
FFFC4548 0000005F		dw		'_'
FFFC454C 00000C63		bra		QT5
FFFC4550 00D06913		ldi		a0,#CR		; if so, output a CR without LF
FFFC4554 FB4FE0EF		call	GOOUT
                        	QT2:
FFFC4558 00072083		lw		$ra,[$sp]		; get return address
FFFC455C 00470713		add		$sp,$sp,#4
FFFC4560 00408067		jmp		4[$ra]		; skip following branch
                        	QT5:					; not " ' or _
FFFC4564 00072083		lw		$ra,[$sp]		; get return address
FFFC4568 00470713		add		$sp,$sp,#4
FFFC456C 00008067		ret
                        	
                        	; Output a CR LF sequence
                        	;
                        	prCRLF:
FFFC4570 FFC70713		sub		$sp,$sp,#4
FFFC4574 00172023		sw		$ra,[$sp]
FFFC4578 00D06913		ldi		a0,#CR
FFFC457C F8CFE0EF		call	GOOUT
FFFC4580 00A06913		ldi		a0,#LINEFD
FFFC4584 F84FE0EF		call	GOOUT
FFFC4588 00072083		lw		$ra,[$sp]
FFFC458C 00470713		add		$sp,$sp,#4
FFFC4590 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; 'PRTNUM' prints the 32 bit number in a0, leading blanks are added if
                        	; needed to pad the number of spaces to the number in a1.
                        	; However, if the number of digits is larger than the no. in
                        	; a1, all digits are printed anyway. Negative sign is also
                        	; printed and counted in, positive sign is not.
                        	;
                        	; Parameters
                        	; 	a0 = number to print
                        	; 	a1 = number of digits
                        	;		a2 = base (eg 10, 16)
                        	; Register Usage
                        	;		s2 = number of padding spaces
                        	; Modifies:
                        	;		a0,a1,t1
                        	; Returns:
                        	;		none
                        	;-------------------------------------------------------------------------------
                        	
FFFC4594 FEC70713	public PRTNUM:
	sub		$sp,$sp,#20
FFFC4598 00472023		sw		$s1,[$sp]
FFFC459C 00572223		sw		$s2,4[$sp]
FFFC45A0 00672423		sw		$s3,8[$sp]
FFFC45A4 00772623		sw		$s4,12[$sp]
FFFC45A8 00172823		sw		$ra,16[$sp]
FFFC45AC 79406393		ldi		s4,#NUMWKA	; r7 = pointer to numeric work area
FFFC45B0 00096333		mov		s3,a0		; save number for later
FFFC45B4 0009E2B3		mov		s2,a1		; s2 = min number of chars
FFFC45B8 00095663		bge		a0,x0,.PN2	; is it negative? if not
FFFC45BC 41200933		sub		a0,x0,a0	; else make it positive
FFFC45C0 FFF28293		sub		s2,s2,#1	; one less for width count
                        	.PN2:
FFFC45C4 00A06D93		ldi		$t1,#10
                        	.PN1:
FFFC45C8 034969B3		rem		a1,a0,a2	; a1 = a0 mod 10
FFFC45CC 03494933		div		a0,a0,a2	; a0 /= 10 divide by 10
FFFC45D0 013A7463		bleu	a1,a2,.PN7
FFFC45D4 00798993		add		a1,a1,#'A'-10-'0'
                        	.PN7:
FFFC45D8 03098993		add		a1,a1,#'0'	; convert remainder to ascii
FFFC45DC 01338023		sb		a1,[$s4]		; and store in buffer
FFFC45E0 00138393		add		s4,s4,#1
FFFC45E4 FFF28293		sub		s2,s2,#1	; decrement width
FFFC45E8 FE0910E3		bne		a0,x0,.PN1
FFFC45EC 00505A63		ble		$s2,$x0,.PN4	; test pad count, skip padding if not needed
                        	.PN3:
FFFC45F0 02006913		ldi		$a0,#' '		; display the required leading spaces
FFFC45F4 F14FE0EF		call	GOOUT
FFFC45F8 FFF28293		sub		$s2,$s2,#1
FFFC45FC FE504AE3		bgt		$s2,$x0,.PN3
                        	.PN4:
FFFC4600 00035663		bge		$s3,$x0,.PN5	; is number negative?
FFFC4604 02D06913		ldi		$a0,#'-'		; if so, display the sign
FFFC4608 F00FE0EF		call	GOOUT
                        	.PN5:
FFFC460C 79406D93		ldi		$t1,#NUMWKA
                        	.PN6:
FFFC4610 FFF38393		sub		$s4,$s4,#1
FFFC4614 0003C903		lbu		$a0,[$s4]		; now unstack the digits and display
FFFC4618 EF0FE0EF		call	GOOUT
FFFC461C FE7DEAE3		bgtu	$s4,$t1,.PN6
                        	
FFFC4620 00072203		lw		$s1,[$sp]
FFFC4624 00472283		lw		$s2,4[$sp]
FFFC4628 00872303		lw		$s3,8[$sp]
FFFC462C 00C72383		lw		$s4,12[$sp]
FFFC4630 01072083		lw		$ra,16[$sp]
FFFC4634 01470713		add		$sp,$sp,#20
FFFC4638 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; Load a word from memory using unaligned access.
                        	; Moves forwards through memory
                        	;
                        	; Parameters:
                        	;		a0 = pointer to word
                        	; Returns:
                        	;		v0 = word loaded
                        	;-------------------------------------------------------------------------------
                        	LoadWord:
FFFC463C 00094803	  lbu		$v0,[$a0]	
FFFC4640 00194883	  lbu		$v1,1[$a0]
FFFC4644 00889893	  sll		$v1,$v1,#8
FFFC4648 01186833	  or		$v0,$v0,$v1
FFFC464C 00294883	  lbu		$v1,2[$a0]
FFFC4650 01089893	  sll		$v1,$v1,#16
FFFC4654 01186833	  or		$v0,$v0,$v1
FFFC4658 00394883	  lbu		$v1,3[$a0]
FFFC465C 01889893	  sll		$v1,$v1,#24
FFFC4660 01186833	  or		$v0,$v0,$v1
FFFC4664 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = pointer to line
                        	; Returns:
                        	;		v0 = pointer to end of line + 1
                        	;-------------------------------------------------------------------------------
                        	
                        	PRTLN:
FFFC4668 FF070713		sub		$sp,$sp,#16
FFFC466C 00572023		sw		$r5,[$sp]
FFFC4670 00172223		sw		$ra,4[$sp]
FFFC4674 01272423		sw		$a0,8[$sp]
FFFC4678 01372623		sw		$a1,12[$sp]
FFFC467C 000962B3	  mov		$r5,$a0		; r5 = pointer
                        	  ; get the line number stored as binary
                        	  ; assume unaligned loads not allowed
FFFC4680 FBDFF0EF	  call	LoadWord
FFFC4684 00086933	  mov		a0,v0
                        	
FFFC4688 00428293		add		r5,r5,#4
FFFC468C 00506993	  ldi		a1,#5       ; display a 0 or more digit line no.
FFFC4690 00A06A13	  ldi		a2,#10
FFFC4694 F01FF0EF		call	PRTNUM
FFFC4698 02006913		ldi		a0,#' '     ; followed by a blank
FFFC469C E6CFE0EF		call	GOOUT
FFFC46A0 000069B3		mov		a1,r0       ; stop char. is a zero
FFFC46A4 0002E933		mov		a0,r5
FFFC46A8 DF1FF0EF		call  PRTSTG		; display the rest of the line
FFFC46AC 00072283		lw		$r5,[$sp]
FFFC46B0 00472083		lw		$ra,4[$sp]
FFFC46B4 00872903		lw		$a0,8[$sp]
FFFC46B8 00C72983		lw		$a1,12[$sp]
FFFC46BC 01070713		add		$sp,$sp,#16
FFFC46C0 00008067		ret
                        	
                        	
                        	; ===== Test text byte following the call to this subroutine. If it
                        	;	equals the byte pointed to by t2, return to the code following
                        	;	the call. 
                        	;
                        	; Parameters:
                        	;		<static> word byte to look for
                        	;		<static> branch if not found
                        	; Registers Affected
                        	;   none
                        	; Returns
                        	;		t2 = updated text pointer
                        	;
                        	TSTC:
FFFC46C4 FF470713		sub		$sp,$sp,#12
FFFC46C8 01272023		sw		$a0,[$sp]
FFFC46CC 00172223		sw		$ra,4[$sp]
FFFC46D0 01372423		sw		$a1,8[$sp]
FFFC46D4 0B0000EF		call	IGNBLK		; ignore leading blanks
FFFC46D8 00472083		lw		$ra,4[$sp]	; get return address, it's needed for a reference
FFFC46DC 000E4903		lbu		$a0,[$t2]
FFFC46E0 0000C983		lbu		$a1,[$ra]
FFFC46E4 01298A63		beq		$a1,$a0,TC1	; is it = to what t2 points to? if so
FFFC46E8 00072903		lw		$a0,[$sp]		; restore a0
FFFC46EC 00872983		lw		$a1,8[$sp]
FFFC46F0 00C70713		add		$sp,$sp,#12	;
FFFC46F4 00408067		jmp		4[$ra]			; jump to the routine skip param
                        	TC1:
FFFC46F8 001E0E13		add		$t2,$t2,#1	; if equal, bump text pointer
FFFC46FC 00072903		lw		$a0,[$sp]
FFFC4700 00472083		lw		$ra,4[$sp]
FFFC4704 00872983		lw		$a1,8[$sp]
FFFC4708 00C70713		add		$sp,$sp,#12
FFFC470C 00808067		jmp		8[$ra]			; jump back, skip parm and branch
                        	
                        	
                        	; ===== See if the text pointed to by $t2 is a number. If so,
                        	;	return the number in $v0 and the number of digits in $v1,
                        	;	else return zero in $v0 and $v1.
                        	; Registers Affected
                        	;   a0,a1,r3,r4
                        	; Returns
                        	; 	v0 = number
                        	;		v1 = number of digits in number
                        	;	t2 = updated text pointer
                        	;
                        	TSTNUM:
FFFC4710 FF870713		sub		$sp,$sp,#8
FFFC4714 00172223		sw		$ra,4[$sp]
FFFC4718 00372023		sw		r3,[$sp]
FFFC471C 068000EF		call	IGNBLK		; skip over blanks
FFFC4720 00006833		mov		$v0,$x0		; initialize return parameters
FFFC4724 000068B3		mov		$v1,$x0
                        	TN1:
FFFC4728 000E4183		lbu		r3,[$t2]
FFFC472C 03006D93		ldi		$t1,#'0'
FFFC4730 05B1C263		blt		r3,$t1,TSNMRET; is it less than zero?
FFFC4734 03906D93		ldi		$t1,#'9'
FFFC4738 023DCE63		bgt		r3,$t1,TSNMRET; is it greater than nine?
FFFC473C 00000DB7		ldi		$t1,#$7FFFFFFFFFFFFFF
FFFC4740 FFFD8D93
FFFC4744 010DF863		bleu	$v0,$t1,TN2; see if there's room for new digit
FFFC4748 FFFC5937		ldi		$a0,#msgNumTooBig
FFFC474C B0190913
FFFC4750 AD1FF06F		jmp		ERROR		; if not, we've overflowd
                        	TN2:
FFFC4754 001E0E13		add		$t2,$t2,#1	; adjust text pointer
FFFC4758 00181E93		sll		$t3,$v0,#1	; quickly multiply result by 10
FFFC475C 00381813		sll		$v0,$v0,#3	; *8
FFFC4760 01D80833		add		$v0,$v0,$t3	; *8 + *2
FFFC4764 00F1F193		and		r3,r3,#$0F	; add in the new digit
FFFC4768 00380833		add		$v0,$v0,r3
FFFC476C 00188893		add		$v1,$v1,#1	; increment the no. of digits
FFFC4770 FA000CE3		bra		TN1
                        	TSNMRET:
FFFC4774 00072183		lw		r3,[$sp]
FFFC4778 00472083		lw		$ra,4[$sp]
FFFC477C 00870713		add		$sp,$sp,#8
FFFC4780 00008067		ret
                        	
                        	
                        	;===== Skip over blanks in the text pointed to by $t2.
                        	;
                        	; Registers Affected:
                        	;	$t2
                        	; Returns
                        	;	$t2 = pointer updateded past any spaces or tabs
                        	;
                        	IGNBLK:
FFFC4784 FFC70713		sub		$sp,$sp,#4
FFFC4788 01272023		sw		$a0,[$sp]
                        	IGB2:
FFFC478C 000E4903		lbu		a0,[$t2]			; get char
FFFC4790 02006D93		ldi		$t1,#' '
FFFC4794 01B90663		beq		$a0,$t1,IGB1	; see if it's a space
FFFC4798 00906D93		ldi		$t1,#'\t'
FFFC479C 01B91663		bne		a0,$t1,IGBRET	; or a tab
                        	IGB1:
FFFC47A0 001E0E13		add		$t2,$t2,#1		; increment the text pointer
FFFC47A4 FE0004E3		bra		IGB2
                        	IGBRET:
FFFC47A8 00072903		lw		$a0,[$sp]
FFFC47AC 00470713		add		$sp,$sp,#4
FFFC47B0 00008067		ret
                        	
                        	; ===== Convert the line of text in the input buffer to upper
                        	;	case (except for stuff between quotes).
                        	;
                        	; Registers Affected
                        	;   a0,r3
                        	; Returns
                        	;	r8 = pointing to end of text in buffer
                        	;
                        	TOUPBUF:
FFFC47B4 FFC70713		sub		$sp,$sp,#4
FFFC47B8 00172023		sw		$ra,[$sp]
FFFC47BC 71C06E13		ldi		$t2,#BUFFER	; set up text pointer
FFFC47C0 000061B3		mov		r3,x0		; clear quote flag
                        	TOUPB1:
FFFC47C4 000E4903		lbu		a0,[$t2]		; get the next text char.
FFFC47C8 001E0E13		add		$t2,$t2,#1
FFFC47CC 00D06D93		ldi		$t1,#CR
FFFC47D0 03B90E63		beq		a0,$t1,TOUPBRT		; is it end of line?
FFFC47D4 02206D93		ldi		$t1,#'"'
FFFC47D8 01B90E63		beq		a0,$t1,DOQUO	; a double quote?
FFFC47DC 02706D93		ldi		$t1,#'\''
FFFC47E0 01B90A63		beq		a0,$t1,DOQUO	; or a single quote?
FFFC47E4 FE0190E3		bne		r3,x0,TOUPB1	; inside quotes?
FFFC47E8 030000EF		call	toUpper 	; convert to upper case
FFFC47EC FF0E0FA3		sb		v0,-1[$t2]	; store it
FFFC47F0 FC000AE3		bra		TOUPB1		; and go back for more
                        	DOQUO:
FFFC47F4 00019663		bne		r3,x0,DOQUO1; are we inside quotes?
FFFC47F8 000961B3		mov		r3,a0		; if not, toggle inside-quotes flag
FFFC47FC FC0004E3		bra		TOUPB1
                        	DOQUO1:
FFFC4800 FD2192E3		bne		r3,a0,TOUPB1; make sure we're ending proper quote
FFFC4804 000061B3		mov		r3,r0		; else clear quote flag
FFFC4808 FA000EE3		bra		TOUPB1
                        	TOUPBRT:
FFFC480C 00072083		lw		$ra,[$sp]
FFFC4810 00470713		add		$sp,$sp,#4
FFFC4814 00008067		ret
                        	
                        	
                        	; ===== Convert the character in a0 to upper case
                        	;
                        	toUpper:
FFFC4818 00096833		mov		$v0,$a0
FFFC481C 06182D93		slt		$t1,$v0,#'a'
FFFC4820 000D9863		bne   $t1,$x0,TOUPRET	; is it < 'a'?
FFFC4824 07A06D93		ldi		$t1,#'z'
FFFC4828 010DC463		bgt		$v0,$t1,TOUPRET	; or > 'z'?
FFFC482C FE080813		sub		$v0,$v0,#32	  ; if not, make it upper case
                        	TOUPRET:
FFFC4830 00008067		ret
                        	
                        	; 'CHKIO' checks the input. If there's no input, it will return
                        	; to the caller with the a0=0. If there is input, the input byte is in a0.
                        	; However, if a control-C is read, 'CHKIO' will warm-start BASIC and will
                        	; not return to the caller.
                        	;
                        	//message "CHKIO"
                        	CHKIO:
FFFC4834 FFC70713		sub		$sp,$sp,#4
FFFC4838 00172023		sw		$ra,[$sp]
FFFC483C 228000EF		call	INCH		; get input if possible
FFFC4840 00080863		beq		$v0,$x0,CHKRET	; if Zero, no input
FFFC4844 00384893		xor		$v1,$v0,#CTRLC
FFFC4848 00089463		bne		$v1,$x0,CHKRET; is it control-C?
FFFC484C D74FE06F		jmp		WSTART		; if so, do a warm start
                        	CHKRET:
FFFC4850 00072083		lw		$ra,[$sp]
FFFC4854 00470713		add		$sp,$sp,#4
FFFC4858 00008067		ret
                        	
                        	; ===== Display a CR-LF sequence
                        	;
                        	CRLF:
FFFC485C FFFC5937		ldi		a0,#CLMSG
FFFC4860 AE590913
                        	
                        	; ===== Display a zero-ended string pointed to by register a0
                        	; Registers Affected
                        	;   a0,a1,r4
                        	;
                        	PRMESG:
FFFC4864 FFC70713		sub		$sp,$sp,#4
FFFC4868 00172023		sw		$ra,[$sp]
FFFC486C F15FB0EF		call	PutString
FFFC4870 00072083		lw		$ra,[$sp]
FFFC4874 00470713		add		$sp,$sp,#4
FFFC4878 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;	erc = ALLOCMBX (<handle var>)
                        	;------------------------------------------------------------------------------
                        	
                        	ALLOCMBX:
FFFC487C E49FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC4880 00000028		dw		'('
FFFC4884 04000E63		bra		.paren
FFFC4888 00106913		ldi		a0,#1
FFFC488C D7CFF0EF		call	TSTV
FFFC4890 00081863		bne		v0,x0,.0001
FFFC4894 FFFC5937		ldi		a0,#msgVar
FFFC4898 B7A90913
FFFC489C 985FF06F		jmp		ERROR
                        	.0001:
FFFC48A0 E25FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC48A4 00000029		dw		')'
FFFC48A8 02000C63		bra		.paren
FFFC48AC 00086233		mov		s1,v0
FFFC48B0 00E06913		ldi		a0,#14			; get current tid
FFFC48B4 00000073		ecall
FFFC48B8 0008E9B3		mov		a1,v1
FFFC48BC 00026A33		mov		a2,s1
FFFC48C0 00606913		ldi		a0,#6
FFFC48C4 00000073		ecall
FFFC48C8 00081463		bne		v0,x0,.0002
FFFC48CC 01122023		sw		v1,[s1]				; save handle in variable
                        	.0002:
FFFC48D0 000068B3		mov		v1,x0
FFFC48D4 00072083		lw		$ra,[$sp]
FFFC48D8 00470713		add		$sp,$sp,#4
FFFC48DC 00008067		ret
                        	.paren:
FFFC48E0 FFFC5937		ldi		a0,#msgParen
FFFC48E4 C8790913
FFFC48E8 939FF06F		jmp		ERROR
                        	
                        	;------------------------------------------------------------------------------
                        	; erc = SENDMSG (<handle var>, <msg data 1>, <msg data 2>, <msg data 3>)
                        	;------------------------------------------------------------------------------
                        	
                        	SENDMSG:
FFFC48EC DD9FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC48F0 00000028		dw		'('
FFFC48F4 08000463		bra		.paren
FFFC48F8 8D0FF0EF		call	OREXPR	; get the mailbox handle
FFFC48FC 00086233		mov		s1,v0
FFFC4900 DC5FF0EF		call	TSTC		; it must be followed by a comma
FFFC4904 0000002C		dw		','
FFFC4908 06000463		bra		.err
FFFC490C 8BCFF0EF		call	OREXPR	; get the memory address
FFFC4910 000862B3		mov		s2,v0
FFFC4914 DB1FF0EF		call	TSTC		; it must be followed by a comma
FFFC4918 0000002C		dw		','
FFFC491C 04000A63		bra		.err
FFFC4920 8A8FF0EF		call	OREXPR	; get the memory address
FFFC4924 00086333		mov		s3,v0
FFFC4928 D9DFF0EF		call	TSTC		; it must be followed by a comma
FFFC492C 0000002C		dw		','
FFFC4930 04000063		bra		.err
FFFC4934 894FF0EF		call	OREXPR	; get the memory address
FFFC4938 000863B3		mov		s4,v0
FFFC493C D89FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC4940 00000029		dw		')'
FFFC4944 02000C63		bra		.paren
FFFC4948 00906913		ldi		a0,#9		; SendMsg
FFFC494C 000269B3		mov		a1,s1
FFFC4950 0002EA33		mov		a2,s2
FFFC4954 00036AB3		mov		a3,s3
FFFC4958 0003EB33		mov		a4,s4
FFFC495C 00000073		ecall
FFFC4960 000068B3		mov		v1,x0
FFFC4964 00072083		lw		$ra,[$sp]
FFFC4968 00470713		add		$sp,$sp,#4
FFFC496C 00008067		ret
                        	.err:
FFFC4970 FFFC5937		ldi		a0,#msgComma
FFFC4974 B5290913
FFFC4978 8A9FF06F		jmp		ERROR
                        	.paren:
FFFC497C FFFC5937		ldi		a0,#msgParen
FFFC4980 C8790913
FFFC4984 89DFF06F		jmp		ERROR
                        	
                        	;------------------------------------------------------------------------------
                        	; WAITMSG <handle var>, <var for data 1>, <var for data 2>, <var for data 3>,
                        	;		<expr>
                        	;------------------------------------------------------------------------------
                        	
                        	WAITMSG:
FFFC4988 D3DFF0EF		call	TSTC		; else look for ( OREXPR )
FFFC498C 00000028		dw		'('
FFFC4990 0C000263		bra		.paren
FFFC4994 834FF0EF		call	OREXPR	; get the mailbox handle
FFFC4998 00086233		mov		s1,v0
FFFC499C D29FF0EF		call	TSTC		; it must be followed by a comma
FFFC49A0 0000002C		dw		','
FFFC49A4 0A000263		bra		.err
FFFC49A8 00106913		ldi		a0,#1
FFFC49AC C5CFF0EF		call	TSTV
FFFC49B0 00081863		bne		v0,x0,.0001
                        	.0002:
FFFC49B4 FFFC5937		ldi		a0,#msgVar
FFFC49B8 B7A90913
FFFC49BC 865FF06F		jmp		ERROR
                        	.0001:
FFFC49C0 D05FF0EF		call	TSTC		; it must be followed by a comma
FFFC49C4 0000002C		dw		','
FFFC49C8 08000063		bra		.err
FFFC49CC 000862B3		mov		s2,v0
FFFC49D0 00106913		ldi		a0,#1
FFFC49D4 C34FF0EF		call	TSTV
FFFC49D8 FC080EE3		beq		v0,x0,.0002
FFFC49DC CE9FF0EF		call	TSTC		; it must be followed by a comma
FFFC49E0 0000002C		dw		','
FFFC49E4 06000263		bra		.err
FFFC49E8 00086333		mov		s3,v0
FFFC49EC 00106913		ldi		a0,#1
FFFC49F0 C18FF0EF		call	TSTV
FFFC49F4 FC0800E3		beq		v0,x0,.0002
FFFC49F8 000863B3		mov		s4,v0
FFFC49FC CC9FF0EF		call	TSTC		; it must be followed by a comma
FFFC4A00 0000002C		dw		','
FFFC4A04 04000263		bra		.err
FFFC4A08 FC1FE0EF		call	OREXPR	; get queue remove flag
FFFC4A0C 00086BB3		mov		a5,v0
FFFC4A10 000863B3		mov		s4,v0
FFFC4A14 CB1FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC4A18 00000029		dw		')'
FFFC4A1C 02000C63		bra		.paren
FFFC4A20 00A06913		ldi		a0,#10		; WaitMsg
FFFC4A24 000269B3		mov		a1,s1
FFFC4A28 0002EA33		mov		a2,s2
FFFC4A2C 00036AB3		mov		a3,s3
FFFC4A30 0003EB33		mov		a4,s4
FFFC4A34 00000073		ecall
FFFC4A38 000068B3		mov		v1,x0
FFFC4A3C 00072083		lw		$ra,[$sp]
FFFC4A40 00470713		add		$sp,$sp,#4
FFFC4A44 00008067		ret
                        	.err:
FFFC4A48 FFFC5937		ldi		a0,#msgComma
FFFC4A4C B5290913
FFFC4A50 FD0FF06F		jmp		ERROR
                        	.paren:
FFFC4A54 FFFC5937		ldi		a0,#msgParen
FFFC4A58 C8790913
FFFC4A5C FC4FF06F		jmp		ERROR
                        	
                        	;*****************************************************
                        	; The following routines are the only ones that need *
                        	; to be changed for a different I/O environment.     *
                        	;*****************************************************
                        	
                        	; ===== Output character to the console (Port 1) from register a0
                        	;	(Preserves all registers.)
                        	;
                        	OUTC:
FFFC4A60 FC4FB06F		jmp		Putch
                        	
                        	; ===== Input a character from the console into register v0 (or
                        	;	return Zero status if there's no character available).
                        	;
                        	INCH:
FFFC4A64 FFC70713		sub 	$sp,$sp,#4
FFFC4A68 00172023		sw		$ra,[$sp]
FFFC4A6C F58FB0EF		call	Getch
FFFC4A70 00180813		add		$v0,$v0,#1				; prepare test -1
FFFC4A74 00080A63		beq		$v0,$x0,INCH1			; was = -1
FFFC4A78 FFF80813		sub		$v0,$v0,#1				; get char back
FFFC4A7C 00072083		lw		$ra,[$sp]
FFFC4A80 00470713		add		$sp,$sp,#4
FFFC4A84 00008067		ret
                        	INCH1:
FFFC4A88 00072083		lw		$ra,[$sp]		; return a zero for no-char
FFFC4A8C 00470713		add		$sp,$sp,#4
FFFC4A90 00008067		ret
                        	
                        	; ===== Return to the resident monitor, operating system, etc.
                        	;
                        	//message "BYEBYE"
                        	BYEBYE:
                        	//	call	ReleaseIOFocus
FFFC4A94 70002703		lw		$sp,OSSP
FFFC4A98 855FB06F		jmp		Monitor
                        	 
                        	
FFFC4A9C 53430A0D	msgInit	db	CR,LINEFD,"CS01 Tiny BASIC v1.0",CR,LINEFD,"(C) 2017-2020  Robert Finch",CR,CR,0
FFFC4AA0 54203130
FFFC4AA4 20796E69
FFFC4AA8 49534142
FFFC4AAC 31762043
FFFC4AB0 0A0D302E
FFFC4AB4 20294328
FFFC4AB8 37313032
FFFC4ABC 3230322D
FFFC4AC0 52202030
FFFC4AC4 7265626F
FFFC4AC8 69462074
FFFC4ACC 0D68636E
FFFC4AD0 0A0D000D
FFFC4AD2 4B4F0A0D	OKMSG	db	CR,LINEFD,"OK",CR,0
FFFC4AD6 6857000D
FFFC4AD8 74616857	msgWhat	db	"What?",CR,0
FFFC4ADC 53000D3F
FFFC4ADF 72726F53	SRYMSG	db	"Sorry."
FFFC4AE3 000D2E79
FFFC4AE5 6F43000D	CLMSG	db	CR,0
FFFC4AE7 706D6F43	msgReadError	db	"Compact FLASH read error",CR,0
FFFC4AEB 20746361
FFFC4AEF 53414C46
FFFC4AF3 65722048
FFFC4AF7 65206461
FFFC4AFB 726F7272
FFFC4AFF 754E000D
FFFC4B01 626D754E	msgNumTooBig	db	"Number is too big",CR,0
FFFC4B05 69207265
FFFC4B09 6F742073
FFFC4B0D 6962206F
FFFC4B11 44000D67
FFFC4B14 69766944	msgDivZero		db	"Division by zero",CR,0
FFFC4B18 6E6F6973
FFFC4B1C 20796220
FFFC4B20 6F72657A
FFFC4B24 754F000D
FFFC4B26 2074754F	msgVarSpace     db  "Out of variable space",CR,0
FFFC4B2A 7620666F
FFFC4B2E 61697261
FFFC4B32 20656C62
FFFC4B36 63617073
FFFC4B3A 20000D65
FFFC4B3D 74796220	msgBytesFree	db	" bytes free",CR,0
FFFC4B41 66207365
FFFC4B45 0D656572
FFFC4B49 65520D00
FFFC4B4A 6165520D	msgReady		db	CR,"Ready",CR,0
FFFC4B4E 000D7964
FFFC4B52 65707845	msgComma		db	"Expecting a comma",CR,0
FFFC4B56 6E697463
FFFC4B5A 20612067
FFFC4B5E 6D6D6F63
FFFC4B62 4C000D61
FFFC4B65 656E694C	msgLineRange	db	"Line number too big",CR,0
FFFC4B69 6D756E20
FFFC4B6D 20726562
FFFC4B71 206F6F74
FFFC4B75 0D676962
FFFC4B79 70784500
FFFC4B7A 65707845	msgVar			db "Expecting a variable",CR,0
FFFC4B7E 6E697463
FFFC4B82 20612067
FFFC4B86 69726176
FFFC4B8A 656C6261
FFFC4B8E 4E52000D
FFFC4B90 20444E52	msgRNDBad		db	"RND bad parameter",CR,0
FFFC4B94 20646162
FFFC4B98 61726170
FFFC4B9C 6574656D
FFFC4BA0 53000D72
FFFC4BA3 20535953	msgSYSBad		db	"SYS bad address",CR,0
FFFC4BA7 20646162
FFFC4BAB 72646461
FFFC4BAF 0D737365
FFFC4BB3 504E4900
FFFC4BB4 55504E49	msgInputVar		db	"INPUT expecting a variable",CR,0
FFFC4BB8 78652054
FFFC4BBC 74636570
FFFC4BC0 20676E69
FFFC4BC4 61762061
FFFC4BC8 62616972
FFFC4BCC 000D656C
FFFC4BD0 5458454E	msgNextFor		db	"NEXT without FOR",CR,0
FFFC4BD4 74697720
FFFC4BD8 74756F68
FFFC4BDC 524F4620
FFFC4BE0 454E000D
FFFC4BE2 5458454E	msgNextVar		db	"NEXT expecting a defined variable",CR,0
FFFC4BE6 70786520
FFFC4BEA 69746365
FFFC4BEE 6120676E
FFFC4BF2 66656420
FFFC4BF6 64656E69
FFFC4BFA 72617620
FFFC4BFE 6C626169
FFFC4C02 47000D65
FFFC4C05 4F544F47	msgBadGotoGosub	db	"GOTO/GOSUB bad line number",CR,0
FFFC4C09 534F472F
FFFC4C0D 62204255
FFFC4C11 6C206461
FFFC4C15 20656E69
FFFC4C19 626D756E
FFFC4C1D 000D7265
FFFC4C21 55544552	msgRetWoGosub   db	"RETURN without GOSUB",CR,0
FFFC4C25 77204E52
FFFC4C29 6F687469
FFFC4C2D 47207475
FFFC4C31 4255534F
FFFC4C35 7250000D
FFFC4C37 676F7250	msgTooBig		db	"Program is too big",CR,0
FFFC4C3B 206D6172
FFFC4C3F 74207369
FFFC4C43 62206F6F
FFFC4C47 000D6769
FFFC4C4B 72747845	msgExtraChars	db	"Extra characters on line ignored",CR,0
FFFC4C4F 68632061
FFFC4C53 63617261
FFFC4C57 73726574
FFFC4C5B 206E6F20
FFFC4C5F 656E696C
FFFC4C63 6E676920
FFFC4C67 6465726F
FFFC4C6B 4520000D
FFFC4C6D 766E4520	msgEnvFail		db	" Environment call failed",CR,0
FFFC4C71 6E6F7269
FFFC4C75 746E656D
FFFC4C79 6C616320
FFFC4C7D 6166206C
FFFC4C81 64656C69
FFFC4C85 7845000D
FFFC4C87 65707845	msgParen		db	"Expecting parenthesis",CR,0
FFFC4C8B 6E697463
FFFC4C8F 61702067
FFFC4C93 746E6572
FFFC4C97 69736568
FFFC4C9B 00000D73
                        	
                        	LSTROM	equ	*		; end of possible ROM area
;	END
                        	
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	.file "cs01rom.r5a",1
                        	
                        		rodata
                        		align 8                        	
                        	begin_init_data:
                        	_begin_init_data:
                        	
                        		rodata
                        		align 8                        	
                        	end_init_data:
                        	_end_init_data:
924 symbols
  Symbol Name                              seg     address bits
  ABS                                        code  fffc409c 18
  ABS1                                       code  fffc40b0 18
  ADDEXPR                                    code  fffc3c44 18
  ALLOCMBX                                   code  fffc487c 18
  ALLOCMBX.0001                              code  fffc48a0 18
  ALLOCMBX.0002                              code  fffc48d0 18
  ALLOCMBX.paren                             code  fffc48e0 18
  ANDEXPR                                    code  fffc3a30 18
  AUXIN                                      code  800000000000023a 32
  AUXIN_INIT                                 code  80000000000002f8 32
  AUXOCRLF                                   code  fffc387c 18
  AUXOUT                                     code  8000000000000238 32
  AUXOUT_FLUSH                               code  8000000000000305 32
  AUXOUT_INIT                                code  80000000000002fc 32
  AccountTime                                code  fffc1cec 18
  AccountTime.again                          code  fffc1cec 18
  Alloc                                      code  fffc1034 18
  Alloc.0001                                 code  fffc10b0 18
  Alloc.enough                               code  fffc106c 18
  Alloc.noRun                                code  fffc10d4 18
  Alloc.noRun2                               code  fffc1064 18
  Alloc.xit                                  code  fffc10d8 18
  AllocPage                                  code  fffc0da8 18
  AllocPage.0001                             code  fffc0f38 18
  AllocPage.chkPam12                         code  fffc0e44 18
  AllocPage.chkPam16                         code  fffc0e74 18
  AllocPage.chkPam20                         code  fffc0ea4 18
  AllocPage.chkPam24                         code  fffc0ed4 18
  AllocPage.chkPam28                         code  fffc0f04 18
  AllocPage.chkPam4                          code  fffc0de4 18
  AllocPage.chkPam8                          code  fffc0e14 18
  AllocPage.chkPamDone                       code  fffc0f34 18
  AllocStack                                 code  fffc10f0 18
  AllocStack.0001                            code  fffc110c 18
  AllocStack.xit                             code  fffc1118 18
  AllocTCB                                   code  fffc2804 18
  AllocTCB.0001                              code  fffc2818 18
  AllocTCB.0002                              code  fffc2850 18
  AllocTCB.0003                              code  fffc2860 18
  AllocTCB.allocTid                          code  fffc2844 18
  BASPRMPT                                   code  fffc2de0 18
  BS                                        const  000008 5
  BUFFER                                    const  00071c 12
  BUFLEN                                    const  000054 8
  BYEBYE                                     code  fffc4a94 18
  BitIndex                                   code  fffc0f44 18
  BitIndex.0001                              code  fffc0f48 18
  BitIndex.0003                              code  fffc0f84 18
  BitIndex.0004                              code  fffc0f74 18
  BitIndex.foundFree                         code  fffc0f68 18
  CHKIO                                      code  fffc4834 18
  CHKRET                                     code  fffc4850 18
  CLMSG                                      code  fffc4ae5 18
  CR                                        const  00000d 5
  CRLF                                       code  fffc485c 18
  CSTART                                     code  fffc2d30 32
  CTRLC                                     const  000003 3
  CTRLH                                     const  000008 5
  CTRLI                                     const  000009 5
  CTRLJ                                     const  00000a 5
  CTRLK                                     const  00000b 5
  CTRLM                                     const  00000d 5
  CTRLS                                     const  000013 6
  CTRLX                                     const  000018 6
  CURRNT                                    const  000718 12
  CopyDevFuncTbl                             code  fffc2ccc 18
  CopyDevFuncTbl.again                       code  fffc2ce0 18
  CursorFlash                               const  0007b0 12
  DCB_LastErc                               const  000018 6
  DCB_Mbx                                   const  000048 8
  DCB_Name                                  const  000000 1
  DCB_ReentCount                            const  000038 7
  DCB_Resv1                                 const  000058 8
  DCB_Resv2                                 const  000060 8
  DCB_Size                                  const  000068 8
  DCB_StartBlock                            const  000020 7
  DCB_Type                                  const  00000c 5
  DCB_fSingleUser                           const  000039 7
  DCB_hJob                                  const  000040 8
  DCB_nBPB                                  const  000010 6
  DCB_nBlocks                               const  000028 7
  DCB_pCmdProc                              const  000030 7
  DCB_pSema                                 const  000050 8
  DEFLT                                      code  fffc35f4 18
  DEL                                       const  00007f 8
  DIRECT                                     code  fffc30a0 18
  DOQUO                                      code  fffc47f4 18
  DOQUO1                                     code  fffc4800 18
  DRSP_DONE                                 const  000001 2
  DVC_BuildBPB                              const  000005 4
  DVC_Close                                 const  000007 4
  DVC_FlushInput                            const  000014 6
  DVC_FlushOutput                           const  000015 6
  DVC_GetChar                               const  000008 5
  DVC_GetCharDirect                         const  00000a 5
  DVC_IOCTRL_READ                           const  000018 6
  DVC_IOCTRL_WRITE                          const  000019 6
  DVC_IRQ                                   const  000016 6
  DVC_Initialize                            const  000002 3
  DVC_InputStatus                           const  00000c 5
  DVC_IsRemoveable                          const  000017 6
  DVC_MediaCheck                            const  000004 4
  DVC_Nop                                   const  000000 1
  DVC_Open                                  const  000006 4
  DVC_OutputStatus                          const  000013 6
  DVC_OutputUntilBusy                       const  00001a 6
  DVC_PeekChar                              const  000009 5
  DVC_PeekCharDirect                        const  00000b 5
  DVC_PutChar                               const  00000d 5
  DVC_ReadBlock                             const  000010 6
  DVC_SetPosition                           const  00000f 5
  DVC_Setup                                 const  000001 2
  DVC_Status                                const  000003 3
  DVC_VerifyBlock                           const  000012 6
  DVC_WriteBlock                            const  000011 6
  DVF_Base                                  const  00a000 17
  DVF_Limit                                 const  00b000 17
  DeleteLine                                 code  fffc2e94 18
  DeleteLine.0001                            code  fffc2eb4 18
  DeleteLine.0002                            code  fffc2ea0 18
  DeleteLine.0003                            code  fffc2eb8 18
  DumpReadyList                              code  fffc28b0 18
  DumpReadyList.0001                         code  fffc2924 18
  DumpReadyList.0002                         code  fffc28e0 18
  DumpReadyList.brk                          code  fffc296c 18
  DumpReadyList.nxt                          code  fffc2960 18
  DumpReadyQueue                             code  800000000000017d 32
  DumpTimeoutList                            code  fffc2990 18
  DumpTimeoutList.0001                       code  fffc2a04 18
  DumpTimeoutList.0002                       code  fffc29c0 18
  DumpTimeoutList.brk                        code  fffc2a30 18
  ENDCHK                                     code  fffc41d0 18
  ENDMEM                                    const  008000 17
  ERETx                                      code  fffc1de8 18
  ERROR                                      code  fffc4220 18
  ERROR1                                     code  fffc4260 18
  EX1                                        code  fffc30ec 18
  EXEC                                       code  fffc30b0 18
  EXGO                                       code  fffc3114 18
  EXLP                                       code  fffc30bc 18
  EXMAT                                      code  fffc3100 18
  EXNGO                                      code  fffc30d4 18
  EXPR                                       code  fffc3b20 18
  E_Arg                                     const  000001 2
  E_BadAlarm                                const  000011 6
  E_BadBlockNum                             const  000025 7
  E_BadDevNum                               const  000020 7
  E_BadDevOp                                const  000022 7
  E_BadMbx                                  const  000004 4
  E_DCBInUse                                const  000019 6
  E_NoDev                                   const  000021 7
  E_NoMem                                   const  00000c 5
  E_NoMoreAlarmBlks                         const  000044 8
  E_NoMoreMbx                               const  000040 8
  E_NoMoreMsgBlks                           const  000041 8
  E_NoMoreTCBs                              const  000045 8
  E_NoMsg                                   const  00000b 5
  E_NoThread                                const  000006 4
  E_NotAlloc                                const  000009 5
  E_NotOwner                                const  000012 6
  E_Ok                                      const  000000 1
  E_QueFull                                 const  000005 4
  E_QueStrategy                             const  000013 6
  E_ReadError                               const  000023 7
  E_Timeout                                 const  000010 6
  E_TooManyBlocks                           const  000026 7
  E_WriteError                              const  000024 7
  EditMem                                    code  fffc05d0 18
  FI1                                        code  fffc41b0 18
  FI2                                        code  fffc41c4 18
  FILEBUF                                   const  07f600 20
  FILENAME                                  const  0006c0 12
  FIN                                        code  fffc4194 18
  FINISH                                     code  fffc3360 18
  FMTKInit                                   code  fffc184c 18
  FMTKInit.0001                              code  fffc18f8 18
  FMTKInit.0002                              code  fffc1928 18
  FMTKInit.0003                              code  fffc18dc 18
  FMTK_AllocMbx                              code  fffc213c 18
  FMTK_AllocMbx.badArg                       code  fffc2198 18
  FMTK_AllocMbx.noOwner                      code  fffc216c 18
  FMTK_AllocMbx.nxt                          code  fffc2148 18
  FMTK_ExitTask                              code  fffc20e0 18
  FMTK_ForceReleaseIOFocus                   code  fffc2be0 18
  FMTK_ForceReleaseIOFocus.0001              code  fffc2c64 18
  FMTK_ForceReleaseIOFocus.done              code  fffc2c70 18
  FMTK_ForceReleaseIOFocus.noFocus           code  fffc2c70 18
  FMTK_ForceReleaseIOFocus.notSame           code  fffc2c34 18
  FMTK_ForceReleaseIOFocus.pjSame            code  fffc2c50 18
  FMTK_FreeMbx                               code  fffc21a4 18
  FMTK_FreeMbx.0001                          code  fffc2200 18
  FMTK_FreeMbx.0002                          code  fffc21c8 18
  FMTK_FreeMbx.0003                          code  fffc21f0 18
  FMTK_FreeMbx.badMbx                        code  fffc2218 18
  FMTK_GetCurrentTid                         code  fffc1960 18
  FMTK_HasIOFocus                            code  fffc2ab4 18
  FMTK_HasIOFocus.hasFocus                   code  fffc2adc 18
  FMTK_HasIOFocus.xit                        code  fffc2ae0 18
  FMTK_IO                                    code  fffc2c7c 18
  FMTK_IO.badDev                             code  fffc2cc4 18
  FMTK_IO.badFunc                            code  fffc2cbc 18
  FMTK_IO.xit                                code  fffc2cb0 18
  FMTK_Initialize                            code  800000000000016f 32
  FMTK_KillTask                              code  fffc20ec 18
  FMTK_KillTask.immortal                     code  fffc2138 18
  FMTK_PeekMsg                               code  fffc23c4 18
  FMTK_PostMsg                               code  8000000000000177 32
  FMTK_ReleaseIOFocus                        code  fffc2bd4 18
  FMTK_RequestIOFocus                        code  fffc2b48 18
  FMTK_RequestIOFocus.notEmpty               code  fffc2bb0 18
  FMTK_RequestIOFocus.ret                    code  fffc2bc8 18
  FMTK_SchedulerIRQ                          code  fffc1dec 18
  FMTK_SchedulerIRQ.0001                     code  fffc1e44 18
  FMTK_SchedulerIRQ.0002                     code  fffc1fa0 18
  FMTK_SchedulerIRQ.0003                     code  fffc1fb4 18
  FMTK_SchedulerIRQ.0004                     code  fffc1fc8 18
  FMTK_SchedulerIRQ.done11                   code  fffc1f30 18
  FMTK_SchedulerIRQ.noCtxSwitch              code  fffc1fe8 18
  FMTK_SchedulerIRQ.noException              code  fffc1f80 18
  FMTK_SchedulerIRQ.noLock                   code  fffc1ffc 18
  FMTK_SchedulerIRQ.noMsg                    code  fffc1fd0 18
  FMTK_SchedulerIRQ.noTimeouts               code  fffc1f68 18
  FMTK_SchedulerIRQ.noWait11                 code  fffc1ef4 18
  FMTK_SchedulerIRQ.timeoutNotDone           code  fffc1f3c 18
  FMTK_SchedulerIRQ.xit2                     code  fffc1ee0 18
  FMTK_SendMsg                               code  fffc2224 18
  FMTK_SendMsg.0001                          code  fffc2248 18
  FMTK_SendMsg.badMbx                        code  fffc2304 18
  FMTK_SendMsg.mbxEmpty                      code  fffc22ec 18
  FMTK_SendMsg.noMsg                         code  fffc22fc 18
  FMTK_SendMsg.noWaiters                     code  fffc22a0 18
  FMTK_SendMsg.nxtTid                        code  fffc2284 18
  FMTK_SendMsg.xit                           code  fffc2308 18
  FMTK_SetTaskPriority                       code  8000000000000173 32
  FMTK_Sleep                                 code  fffc1d18 18
  FMTK_Sleep.0001                            code  fffc1d38 18
  FMTK_Sleep.0002                            code  fffc1d8c 18
  FMTK_Sleep.0003                            code  fffc1da0 18
  FMTK_Sleep.0004                            code  fffc1db4 18
  FMTK_Sleep.noCtxSwitch                     code  fffc1dd4 18
  FMTK_Sleep.noException                     code  fffc1d70 18
  FMTK_Sleep.noMsg                           code  fffc1dbc 18
  FMTK_StartApp                              code  800000000000017b 32
  FMTK_StartTask                             code  fffc201c 18
  FMTK_StartTask.err                         code  fffc20d8 18
  FMTK_SwitchIOFocus                         code  fffc2b3c 18
  FMTK_WaitMsg                               code  fffc23d0 18
  FMTK_WaitMsg.qt                            code  fffc23ec 18
  FNDLN                                      code  fffc4358 18
  FNDLNP                                     code  fffc4378 18
  FNDNXT                                     code  fffc43d4 18
  FNDRET                                     code  fffc43a8 18
  FNDRET.0001                                code  fffc43ac 18
  FNDRET1                                    code  fffc43c4 18
  FNDRET2                                    code  fffc43cc 18
  FNDSKP                                     code  fffc43d8 18
  FOR                                        code  fffc33f0 18
  FORCEFIT                                   code  fffc3af8 18
  FORCEFIT.0001                              code  fffc3b1c 18
  FORCEFIT.intAnd                            code  fffc3b0c 18
  FR1                                        code  fffc3410 18
  FR2                                        code  fffc342c 18
  FR3                                        code  fffc3434 18
  FR4                                        code  fffc3438 18
  FR5                                        code  fffc343c 18
  FR6                                        code  fffc3454 18
  FR7                                        code  fffc3458 18
  FR8                                        code  fffc3478 18
  FUNCEXPR                                   code  fffc3d78 18
  FillMem                                    code  fffc05e8 18
  FillMem.0001                               code  fffc0604 18
  FindRun                                    code  fffc0fd4 18
  FindRun.0001                               code  fffc0ff0 18
  FindRun.0002                               code  fffc1000 18
  FindRun.empty0                             code  fffc1008 18
  FindRun.empty1                             code  fffc100c 18
  FindRun.foundEnough                        code  fffc102c 18
  FreeAll                                    code  fffc111c 18
  FreeAll.0001                               code  fffc117c 18
  FreeAll.nxt                                code  fffc1124 18
  FreeMsg                                   const  008c00 17
  FreePage                                   code  fffc0f88 18
  FreePage.xit                               code  fffc0fd0 18
  FreeTCB                                    code  fffc287c 18
  GCHAR                                      code  fffc3678 18
  GCHAR1                                     code  fffc3690 18
  GETLN                                      code  fffc4264 18
  GETLN.GL1                                  code  fffc4284 18
  GETLN.GL2                                  code  fffc42ac 18
  GETLN.GL3                                  code  fffc42dc 18
  GETLN.GL4                                  code  fffc4304 18
  GETLN.GL5                                  code  fffc4314 18
  GETLN.GL6                                  code  fffc4334 18
  GETLN.GL7                                  code  fffc433c 18
  GOAUXI                                     code  fffc2d18 18
  GOAUXO                                     code  fffc2d10 18
  GOBYE                                      code  fffc2d20 18
  GOIN                                       code  fffc2d0c 18
  GOOUT                                      code  fffc2d08 18
  GOSTART                                    code  fffc2d00 18
  GOSUB                                      code  fffc3368 18
  GOTO                                       code  fffc31e4 18
  GOWARM                                     code  fffc2d04 18
  GetBuflen                                  code  fffc2efc 18
  GetBuflen.0001                             code  fffc2f24 18
  GetBuflen.0002                             code  fffc2f08 18
  GetBuflen.0004                             code  fffc2f20 18
  GetCurrentTid                              code  fffc1954 18
  GetFilename                                code  fffc36dc 18
  GetHexNum                                  code  fffc0640 18
  GetHexNum.0001                             code  fffc0690 18
  GetHexNum.isDigit                          code  fffc06cc 18
  GetHexNum.isHexLower                       code  fffc06b4 18
  GetHexNum.isHexUpper                       code  fffc069c 18
  GetHexNum.next                             code  fffc0650 18
  Getch                                      code  fffc01c4 18
  Getch.HasFocus3                            code  fffc020c 18
  Getch.WFF13                                code  fffc01d4 18
  Getch.WFF23                                code  fffc01fc 18
  HRDY0                                      code  80000000000001d7 32
  IF0                                        code  fffc34f4 18
  IF1                                        code  fffc34f8 18
  IF2                                        code  fffc3500 18
  IF3                                        code  fffc3514 18
  IGB1                                       code  fffc47a0 18
  IGB2                                       code  fffc478c 18
  IGBRET                                     code  fffc47a8 18
  IGNBLK                                     code  fffc4784 18
  INBUF                                     const  004100 16
  INCH                                       code  fffc4a64 18
  INCH1                                      code  fffc4a88 18
  INPERR                                     code  fffc3518 18
  INPPTR                                    const  0007ac 12
  INPUT                                      code  fffc3534 18
  INSLINE                                    code  fffc2e54 18
  INSLINE.0001                               code  fffc2e80 18
  IOF_NEXT                                  const  0002e8 11
  IOF_PREV                                  const  0002f0 11
  IOFocusNdx                                const  008c08 17
  IOFocusTbl                                const  008c10 17
  IP2                                        code  fffc355c 18
  IP3                                        code  fffc3598 18
  IP4                                        code  fffc35d8 18
  IP5                                        code  fffc35e8 18
  IP6                                        code  fffc353c 18
  IP7                                        code  fffc357c 18
  IRQFlag                                   const  0007b4 12
  IRQROUT                                   const  0007a4 12
  IRQRout                                    code  fffc07b4 18
  IRQRout.isIRQ                              code  fffc07c8 18
  IRQRout.noIRQ                              code  fffc07e8 18
  InsertIntoReadyList                        code  fffc24d8 18
  InsertIntoReadyList.badTid                 code  fffc259c 18
  InsertIntoReadyList.insert                 code  fffc2554 18
  InsertIntoReadyList.ok                     code  fffc2570 18
  InsertIntoReadyList.xit                    code  fffc2574 18
  InsertIntoTimeoutList                      code  fffc2640 18
  InsertIntoTimeoutList.0001                 code  fffc2680 18
  InsertIntoTimeoutList.0002                 code  fffc26d8 18
  InsertIntoTimeoutList.0003                 code  fffc26e8 18
  InsertIntoTimeoutList.beginWhile           code  fffc268c 18
  InsertIntoTimeoutList.endWhile             code  fffc26ac 18
  InsertLine                                 code  fffc2edc 18
  InsertLine.0001                            code  fffc2ee0 18
  InsertLine.done                            code  fffc2ef8 18
  InsertTask                                 code  fffc2438 18
  InsertTask.badTid                          code  fffc24c0 18
  InsertTask.qfull                           code  fffc24c8 18
  InsertTask.xit                             code  fffc24cc 18
  LET                                        code  fffc3600 18
  LINEFD                                    const  00000a 5
  LISTX                                      code  fffc3280 18
  LOAD                                       code  fffc3618 18
  LOAD3                                      code  fffc3748 18
  LOAD4                                      code  fffc3774 18
  LOAD5                                      code  fffc37ac 18
  LOD1                                       code  fffc3628 18
  LOD2                                       code  fffc3654 18
  LODEND                                     code  fffc3670 18
  LOPINC                                    const  000778 12
  LOPLMT                                    const  00077c 12
  LOPLN                                     const  000774 12
  LOPPT                                     const  000770 12
  LOPVAR                                    const  000710 12
  LS1                                        code  fffc3294 18
  LS2                                        code  fffc32bc 18
  LS3                                        code  fffc32c4 18
  LS4                                        code  fffc32a0 18
  LS5                                        code  fffc3298 18
  LSTROM                                    const  000000 1
  LT1                                        code  fffc3614 18
  LoadWord                                   code  fffc463c 18
  MAX_DEV_OP                                const  00001f 6
  MAX_TID                                   const  00000f 5
  MBX_MQHEAD                                const  000008 5
  MBX_MQTAIL                                const  00000c 5
  MBX_OWNER                                 const  000000 1
  MBX_SIZE                                  const  000010 6
  MBX_WTIDS                                 const  000004 4
  MMUInit                                    code  fffc0cb0 18
  MMUInit.0001                               code  fffc0d64 18
  MMUInit.0002                               code  fffc0d94 18
  MMUInit.0003                               code  fffc0d78 18
  MSG_D1                                    const  000004 4
  MSG_D2                                    const  000008 5
  MSG_D3                                    const  00000c 5
  MSG_LINK                                  const  000000 1
  MSG_SIZE                                  const  000010 6
  MULEXPR                                    code  fffc3cdc 18
  MVDOWN                                     code  fffc4414 18
  MVDOWN1                                    code  fffc4404 18
  MVUP                                       code  fffc43fc 18
  MVUP1                                      code  fffc43ec 18
  MachineStart                               code  fffc0100 18
  MapOSPages                                 code  fffc197c 18
  MapOSPages.nxt                             code  fffc1988 18
  MonEntry                                   code  fffc02e4 18
  Monitor                                    code  fffc02ec 18
  Monitor.0001                               code  fffc0308 18
  Monitor.0002                               code  fffc0358 18
  Monitor.0003                               code  fffc03bc 18
  Monitor.0004                               code  fffc0444 18
  Monitor.0005                               code  fffc0544 18
  Monitor.0006                               code  fffc04b0 18
  Monitor.0007                               code  fffc04e0 18
  Monitor.0008                               code  fffc04ec 18
  Monitor.0009                               code  fffc04f8 18
  Monitor.0010                               code  fffc0510 18
  Monitor.0011                               code  fffc052c 18
  Monitor.0012                               code  fffc0544 18
  Monitor.doBackspace                        code  fffc03a8 18
  Monitor.doDelete                           code  fffc0350 18
  Monitor.noT                                code  fffc04d8 18
  Monitor.procLine                           code  fffc040c 18
  Monitor.skip                               code  fffc0420 18
  Monitor.skip2                              code  fffc043c 18
  NEW                                        code  fffc3128 18
  NEXT                                       code  fffc347c 18
  NPAGES                                    const  004300 16
  NR_DCB                                    const  000020 7
  NR_TCB                                    const  000010 6
  NUMWKA                                    const  000794 12
  NX0                                        code  fffc3498 18
  NX1                                        code  fffc34d8 18
  NX2                                        code  fffc34b8 18
  NX3                                        code  fffc34dc 18
  NX4                                        code  fffc3494 18
  NX5                                        code  fffc34ac 18
  NXPurge                                    code  fffc34ec 18
  OKMSG                                      code  fffc4ad2 18
  ONIRQ                                      code  fffc3248 18
  ONIRQ1                                     code  fffc3268 18
  OREXPR                                     code  fffc39c8 18
  OSCALL                                     code  fffc1ca4 18
  OSCallTbl                                  code  fffc17f4 18
  OSPAGES                                   const  000020 7
  OSSP                                      const  000700 12
  OUTC                                       code  fffc4a60 18
  OUTPTR                                    const  0007a8 12
  OpenSpace                                  code  fffc2f28 18
  OpenSpace.0003                             code  fffc2f40 18
  OpenSpace.noSpace                          code  fffc2f5c 18
  PAM                                       const  004800 16
  PARN                                       code  fffc3dc8 18
  PEEK                                       code  fffc3fb8 18
  PEEKH                                      code  fffc3fe8 18
  PEEKW                                      code  fffc3fd0 18
  PIDMAP                                    const  004310 16
  PKER                                       code  fffc3990 18
  POKE                                       code  fffc390c 18
  POKEH                                      code  fffc3964 18
  POKEW                                      code  fffc3938 18
  POPA_                                      code  fffc441c 18
  PP1                                        code  fffc4450 18
  PR0                                        code  fffc32f4 18
  PR1                                        code  fffc330c 18
  PR2                                        code  fffc32e0 18
  PR3                                        code  fffc332c 18
  PR4                                        code  fffc3324 18
  PR6                                        code  fffc3340 18
  PR8                                        code  fffc3348 18
  PRINT                                      code  fffc32c8 18
  PRMESG                                     code  fffc4864 18
  PRTLN                                      code  fffc4668 18
  PRTNUM                                     code  fffc4594 32
  PRTNUM.PN1                                 code  fffc45c8 18
  PRTNUM.PN2                                 code  fffc45c4 18
  PRTNUM.PN3                                 code  fffc45f0 18
  PRTNUM.PN4                                 code  fffc4600 18
  PRTNUM.PN5                                 code  fffc460c 18
  PRTNUM.PN6                                 code  fffc4610 18
  PRTNUM.PN7                                 code  fffc45d8 18
  PRTSTG                                     code  fffc4498 18
  PRTSTG.PRTRET                              code  fffc44dc 18
  PRTSTG.PS1                                 code  fffc44b8 18
  PU1                                        code  fffc448c 18
  PUSHA_                                     code  fffc4454 18
  PWORD                                      code  fffc38a0 18
  PeekMsg                                    code  fffc2310 18
  PeekMsg.badMbx                             code  fffc23b4 18
  PeekMsg.noMsg                              code  fffc23ac 18
  PeekMsg.nod1                               code  fffc237c 18
  PeekMsg.nod2                               code  fffc2390 18
  PeekMsg.nod3                               code  fffc23a4 18
  PeekMsg.nodq                               code  fffc2368 18
  PeekMsg.ret                                code  fffc23b8 18
  PutHexByte                                 code  fffc0720 18
  PutHexHalf                                 code  fffc0700 18
  PutHexNybble                               code  fffc0740 18
  PutHexNybble.0001                          code  fffc0770 18
  PutHexNybble.lt10                          code  fffc0768 18
  PutHexWord                                 code  fffc06e0 18
  PutString                                  code  fffc0780 18
  PutString.0001                             code  fffc0790 18
  PutString.done                             code  fffc07a4 18
  Putch                                      code  fffc0224 18
  QNDX                                      const  004304 16
  QSORRY                                     code  fffc420c 18
  QT1                                        code  fffc4518 18
  QT2                                        code  fffc4558 18
  QT3                                        code  fffc4530 18
  QT4                                        code  fffc4544 18
  QT5                                        code  fffc4564 18
  QTSTG                                      code  fffc4500 18
  QWHAT                                      code  fffc4218 18
  RDYQ0                                     const  004400 16
  RDYQ1                                     const  004500 16
  RDYQ2                                     const  004600 16
  RDYQ3                                     const  004700 16
  READYQ                                    const  004308 16
  RETURN                                     code  fffc33ac 18
  RND                                        code  fffc4040 18
  RUN                                        code  fffc3150 18
  RUN1                                       code  fffc31b0 18
  RUN2                                       code  fffc316c 18
  RUN3                                       code  fffc3170 18
  RUNNXL                                     code  fffc3164 18
  RUNSML                                     code  fffc31cc 18
  RUNTSL                                     code  fffc31c4 18
  RemoveFromReadyList                        code  fffc25a4 18
  RemoveFromReadyList.0001                   code  fffc25fc 18
  RemoveFromReadyList.0002                   code  fffc2618 18
  RemoveFromReadyList.badTid                 code  fffc2638 18
  RemoveFromTimeoutList                      code  fffc26fc 18
  RemoveFromTimeoutList.0001                 code  fffc27a0 18
  RemoveFromTimeoutList.noNext               code  fffc27c4 18
  RemoveFromTimeoutList.noPrev               code  fffc27d8 18
  RemoveFromTimeoutList.noWait               code  fffc2778 18
  RemoveFromTimeoutList.xit15                code  fffc2764 18
  SAVE                                       code  fffc381c 18
  SAVE1                                      code  fffc3828 18
  SAVE2                                      code  fffc3844 18
  SAVE3                                      code  fffc37b0 18
  SAVE4                                      code  fffc37e0 18
  SAVEND                                     code  fffc385c 18
  SDReadSector                               code  80000000000002f9 32
  SDWriteSector                              code  80000000000002fe 32
  SENDMSG                                    code  fffc48ec 18
  SENDMSG.err                                code  fffc4970 18
  SENDMSG.paren                              code  fffc497c 18
  SETVAL                                     code  fffc412c 18
  SETVAL.sv2                                 code  fffc4150 18
  SGN                                        code  fffc40d4 18
  SGN1                                       code  fffc4104 18
  SGN2                                       code  fffc40f4 18
  SIZEX                                      code  fffc4110 18
  SRYMSG                                     code  fffc4adf 18
  ST2                                        code  fffc2e30 18
  STACKOFFS                                 const  07fffc 20
  STKBOT                                    const  00079c 12
  STKGOS                                    const  000714 12
  STKINP                                    const  000798 12
  STOP                                       code  fffc313c 18
  STRTMP                                    const  000200 11
  SV1                                        code  fffc418c 18
  SYSX                                       code  fffc399c 18
  SelectTaskToRun                            code  fffc199c 18
  SelectTaskToRun.0001                       code  fffc19f4 18
  SelectTaskToRun.dq                         code  fffc1a10 18
  SelectTaskToRun.goodTid                    code  fffc1a30 18
  SelectTaskToRun.noTask                     code  fffc1a48 18
  SelectTaskToRun.nxtQ                       code  fffc19e0 18
  SerHeadRcv                                const  009800 17
  SerHeadXmit                               const  009808 17
  SerRcvBuf                                 const  009000 17
  SerRcvXoff                                const  009811 17
  SerRcvXon                                 const  009810 17
  SerTailRcv                                const  009804 17
  SerTailXmit                               const  00980c 17
  SerXmitBuf                                const  009400 17
  SerialFinishCmd                            code  fffc136c 18
  SerialFinishCmd.0001                       code  fffc1390 18
  SerialFuncTbl                              code  fffc11b8 18
  SerialGetChar                              code  fffc1394 18
  SerialGetChar.0001                         code  fffc1448 18
  SerialGetChar.0002                         code  fffc13fc 18
  SerialGetChar.noChars                      code  fffc1448 18
  SerialGetChar.xit                          code  fffc144c 18
  SerialIRQ                                  code  fffc15e4 18
  SerialIRQ.0001                             code  fffc1694 18
  SerialIRQ.notRxInt                         code  fffc16a8 18
  SerialIRQ.nxtByte                          code  fffc15e4 18
  SerialIRQ.rxFull                           code  fffc16a8 18
  SerialInit                                 code  fffc1238 18
  SerialPeekChar                             code  fffc1464 18
  SerialPeekChar.0001                        code  fffc14b0 18
  SerialPeekChar.noChars                     code  fffc14b0 18
  SerialPeekChar.xit                         code  fffc14b4 18
  SerialPeekCharDirect                       code  fffc14cc 18
  SerialPeekCharDirect.0001                  code  fffc150c 18
  SerialPeekCharDirect.xit                   code  fffc1510 18
  SerialPutChar                              code  fffc1528 18
  SerialPutChar.0001                         code  fffc153c 18
  SerialPutChar.0002                         code  fffc1538 18
  SerialPutChar.goSleep                      code  fffc1580 18
  SerialRcvCount                             code  fffc15a8 18
  SerialRcvCount.xit                         code  fffc15dc 18
  SerialService                              code  fffc1314 18
  SerialServiceInit                          code  fffc12fc 18
  SerialServiceLoop                          code  fffc1330 18
  SkipSpaces                                 code  fffc0614 18
  SkipSpaces.skip1                           code  fffc0638 18
  SkipSpaces.skip2                           code  fffc0614 18
  SwapContext                                code  fffc1a54 18
  SwapContext.rsseg                          code  fffc1b84 18
  SwapContext.svseg                          code  fffc1b58 18
  SwitchIOFocusHelper                        code  fffc2af0 18
  SwitchIOFocusHelper.noFocus                code  fffc2b28 18
  SwitchIOFocusHelper.sameFocus              code  fffc2b28 18
  SysSema                                   const  004340 16
  TAB                                       const  000009 5
  TAB1                                       code  fffc2f64 18
  TAB10                                      code  fffc301e 18
  TAB10_1                                    code  fffc308e 18
  TAB1_1                                     code  fffc3022 18
  TAB2                                       code  fffc2f76 18
  TAB2_1                                     code  fffc302c 18
  TAB4                                       code  fffc2fcf 18
  TAB4_1                                     code  fffc305a 18
  TAB5                                       code  fffc3008 18
  TAB5_1                                     code  fffc3074 18
  TAB6                                       code  fffc300b 18
  TAB6_1                                     code  fffc3078 18
  TAB8                                       code  fffc3010 18
  TAB8_1                                     code  fffc307c 18
  TAB9                                       code  fffc301a 18
  TAB9_1                                     code  fffc308a 18
  TC1                                        code  fffc46f8 18
  TCBEndTick                                const  0002b8 11
  TCBException                              const  0002c8 11
  TCBMsgD1                                  const  000298 11
  TCBMsgD2                                  const  0002a0 11
  TCBMsgD3                                  const  0002a8 11
  TCBName                                   const  0002f8 11
  TCBNext                                   const  0002d0 11
  TCBPrev                                   const  0002d8 11
  TCBPriority                               const  000289 11
  TCBStackBot                               const  000290 11
  TCBStartTick                              const  0002b0 11
  TCBStatus                                 const  000288 11
  TCBTicks                                  const  0002c0 11
  TCBTimeout                                const  0002e0 11
  TCBWaitMbx                                const  00028a 11
  TCBepc                                    const  000280 11
  TCBsegs                                   const  000200 11
  TICKX                                      code  fffc40c0 18
  TN1                                        code  fffc4728 18
  TN2                                        code  fffc4754 18
  TOOBIG                                     code  fffc4200 18
  TOUPB1                                     code  fffc47c4 18
  TOUPBRT                                    code  fffc480c 18
  TOUPBUF                                    code  fffc47b4 18
  TOUPRET                                    code  fffc4830 18
  TRDY0                                      code  80000000000001d8 32
  TSNMRET                                    code  fffc4774 18
  TSTC                                       code  fffc46c4 18
  TSTNUM                                     code  fffc4710 18
  TSTV                                       code  fffc3e08 18
  TSTVRT                                     code  fffc3e78 18
  TS_DEAD                                   const  000002 3
  TS_MSGRDY                                 const  000004 4
  TS_NONE                                   const  000000 1
  TS_PREEMPT                                const  000020 7
  TS_READY                                  const  000001 2
  TS_RUNNING                                const  000080 9
  TS_TIMEOUT                                const  000010 6
  TS_WAITMSG                                const  000008 5
  TV1                                        code  fffc3e64 18
  TV2                                        code  fffc3e58 18
  TV3                                        code  fffc3e38 18
  TXTBGN                                    const  001800 14
  TXTUNF                                    const  000704 12
  Tick                                      const  004330 16
  TimeoutList                               const  004328 16
  TinyBasic                                  code  fffc2d00 18
  UART                                      const  ffdc0a00 33
  UART_CMD                                  const  000008 5
  UART_STAT                                 const  000004 4
  UART_TRB                                  const  000000 1
  USRX                                       code  fffc4000 18
  UserStart                                  code  fffc0140 18
  UserStart.0002                             code  fffc0184 18
  UserStart.0003                             code  fffc01b0 18
  UserStart.0004                             code  fffc0178 18
  VARBGN                                    const  000708 12
  VAREND                                    const  00070c 12
  VIA                                       const  ffdc0600 33
  VIA_ACR                                   const  00002c 7
  VIA_DDRA                                  const  00000c 5
  VIA_IER                                   const  000038 7
  VIA_IFR                                   const  000034 7
  VIA_PA                                    const  000004 4
  VIA_PARAW                                 const  00003c 7
  VIA_PCR                                   const  000030 7
  VIA_T1CH                                  const  000014 6
  VIA_T1CL                                  const  000010 6
  ViaFuncTbl                                 code  fffc16b8 18
  ViaIRQ                                     code  fffc1794 18
  ViaIRQ.0003                                code  fffc17f0 18
  ViaInit                                    code  fffc1738 18
  VirtToPhys                                 code  fffc1180 18
  VirtToPhys.notMapped                       code  fffc11ac 18
  WAITIRQ                                    code  fffc3270 18
  WAITMSG                                    code  fffc4988 18
  WAITMSG.0001                               code  fffc49c0 18
  WAITMSG.0002                               code  fffc49b4 18
  WAITMSG.err                                code  fffc4a48 18
  WAITMSG.paren                              code  fffc4a54 18
  WSTART                                     code  fffc2dc0 18
  XOFF                                      const  000013 6
  XON                                       const  000011 6
  XP11                                       code  fffc3b4c 18
  XP12                                       code  fffc3b64 18
  XP13                                       code  fffc3b7c 18
  XP14                                       code  fffc3b94 18
  XP15                                       code  fffc3bac 18
  XP16                                       code  fffc3bc4 18
  XP17                                       code  fffc3c04 18
  XP18                                       code  fffc3c1c 18
  XP21                                       code  fffc3c6c 18
  XP22                                       code  fffc3c78 18
  XP23                                       code  fffc3c7c 18
  XP24                                       code  fffc3c98 18
  XP25                                       code  fffc3cac 18
  XP26                                       code  fffc3cb8 18
  XP31                                       code  fffc3ce8 18
  XP34                                       code  fffc3d18 18
  XP35                                       code  fffc3d3c 18
  XP40                                       code  fffc3d94 18
  XP41                                       code  fffc3db0 18
  XP42                                       code  fffc3dec 18
  XP43                                       code  fffc3df8 18
  XP45                                       code  fffc3cc4 18
  XP46                                       code  fffc3dbc 18
  XP47                                       code  fffc3d60 18
  XPRT0                                      code  fffc3bdc 18
  XPRT1                                      code  fffc3bf0 18
  XP_AND                                     code  fffc3a5c 18
  XP_AND1                                    code  fffc3a3c 18
  XP_ANDX                                    code  fffc3a70 18
  XP_OR                                      code  fffc39fc 18
  XP_OR1                                     code  fffc39dc 18
  XP_ORX                                     code  fffc3a10 18
  YIELD0                                     code  fffc3144 18
  _clr                                       code  fffc3208 18
  _cls                                       code  800000000000027d 32
  _end_init_data                           rodata  fffc5000 32
  _rdcf                                      code  800000000000027f 32
  a2h1                                       code  fffc36d0 18
  asciiToHex                                 code  fffc36c4 18
  begin_init_data                          rodata  fffc5000 32
  clearVars                                  code  fffc3210 18
  clearVars.cv1                              code  fffc3224 18
  doMem                                      code  fffc0548 18
  doMem.loop                                 code  fffc05ac 18
  doMem.loop2                                code  fffc0584 18
  ec1                                        code  fffc41f4 18
  end_init_data                            rodata  fffc5000 32
  findVar                                    code  fffc3f48 18
  fl1                                        code  fffc4370 18
  flt10                                      code  fffc08d5 18
  flt20                                      code  fffc08c5 18
  flt50                                      code  fffc08b5 18
  fltMillion                                 code  fffc0cac 18
  fltOne                                     code  fffc0ca4 18
  fltTen                                     code  fffc0ca8 18
  fltToString                                code  fffc08e5 18
  fltToString.0001                           code  fffc0946 18
  fltToString.0002                           code  fffc09c6 18
  fltToString.0003                           code  fffc09b2 18
  fltToString.0004                           code  fffc0a12 18
  fltToString.0005                           code  fffc0a0a 18
  fltToString.0006                           code  fffc09f2 18
  fltToString.0007                           code  fffc0a2e 18
  fltToString.0008                           code  fffc0a42 18
  fltToString.0009                           code  fffc0a3e 18
  fltToString.0010                           code  fffc0a62 18
  fltToString.0011                           code  fffc0aee 18
  fltToString.0012                           code  fffc0aa6 18
  fltToString.0013                           code  fffc0a92 18
  fltToString.0014                           code  fffc0ac2 18
  fltToString.0015                           code  fffc0ade 18
  fltToString.0016                           code  fffc0a7a 18
  fltToString.0017                           code  fffc0ae6 18
  fltToString.0018                           code  fffc0aee 18
  fltToString.0019                           code  fffc0b22 18
  fltToString.0020                           code  fffc0b2e 18
  fltToString.0021                           code  fffc0b52 18
  fltToString.0022                           code  fffc0b5e 18
  fltToString.0023                           code  fffc0b6e 18
  fltToString.0024                           code  fffc0b7a 18
  fltToString.0025                           code  fffc0b66 18
  fltToString.0026                           code  fffc0b8e 18
  fltToString.0027                           code  fffc0b96 18
  fltToString.0028                           code  fffc0b9e 18
  fltToString.0029                           code  fffc0baa 18
  fltToString.0030                           code  fffc0bb6 18
  fltToString.0031                           code  fffc0bc2 18
  fltToString.0032                           code  fffc0bca 18
  fltToString.0034                           code  fffc0bd2 18
  fltToString.0035                           code  fffc0bde 18
  fltToString.0036                           code  fffc0bee 18
  fltToString.0037                           code  fffc0bfa 18
  fltToString.0038                           code  fffc0c02 18
  fltToString.0039                           code  fffc0c16 18
  fltToString.0040                           code  fffc0c0a 18
  fltToString.0041                           code  fffc0c72 18
  fltToString.0042                           code  fffc0c36 18
  fltToString.0043                           code  fffc0c46 18
  fltToString.0044                           code  fffc0c5a 18
  fltToString.0045                           code  fffc0c3e 18
  fltToString.0046                           code  fffc0c66 18
  fltToString.0047                           code  fffc0c72 18
  fltToString.0048                           code  fffc0c5e 18
  fltToString.0050                           code  fffc0c92 18
  fltToString.0051                           code  fffc0c8e 18
  fltToString.0052                           code  fffc0c7e 18
  fltToString.inf                            code  fffc092e 18
  fltToString.notZero                        code  fffc0982 18
  fltToString.pos                            code  fffc096e 18
  fltToString.prt                            code  fffc0c26 18
  fputc                                      code  fffc0264 18
  fputc.HasFocus4                            code  fffc02b8 18
  fputc.WFF14                                code  fffc0280 18
  fputc.WFF24                                code  fffc02a8 18
  fv1                                        code  fffc3f90 18
  fv2                                        code  fffc3fa4 18
  fv3                                        code  fffc3f88 18
  fv4                                        code  fffc3f58 18
  gen_rand                                   code  8000000000000347 32
  getVarName                                 code  fffc3e9c 18
  gfn1                                       code  fffc3744 18
  gfn2                                       code  fffc36f4 18
  gfn3                                       code  fffc3724 18
  gosub1                                     code  fffc3388 18
  gvn1                                       code  fffc3f34 18
  gvn2                                       code  fffc3ef8 18
  gvn3                                       code  fffc3f14 18
  gvn4                                       code  fffc3ebc 18
  gvn6                                       code  fffc3ee8 18
  isAlnum                                    code  fffc3ad8 18
  isAlpha                                    code  fffc3aa8 18
  isAlphaFalse                               code  fffc3ad0 18
  isAlphaTrue                                code  fffc3ac8 18
  isDigit                                    code  fffc3a88 18
  isDigitFalse                               code  fffc3aa0 18
  isDigitx                                   code  fffc3aec 18
  mbxs                                      const  008800 17
  mbxs_end                                  const  008a00 17
  milliseconds                              const  004208 16
  missed_ticks                              const  004320 16
  msgBadGotoGosub                            code  fffc4c05 18
  msgBytesFree                               code  fffc4b3d 18
  msgCRLF                                    code  fffc08b2 18
  msgComma                                   code  fffc4b52 18
  msgDivZero                                 code  fffc4b14 18
  msgEnvFail                                 code  fffc4c6d 18
  msgExtraChars                              code  fffc4c4b 18
  msgInf                                     code  fffc0c9c 18
  msgInit                                    code  fffc4a9c 18
  msgInputVar                                code  fffc4bb4 18
  msgLineRange                               code  fffc4b65 18
  msgMonHelp                                 code  fffc0802 18
  msgNan                                     code  fffc0ca0 18
  msgNextFor                                 code  fffc4bd0 18
  msgNextVar                                 code  fffc4be2 18
  msgNumTooBig                               code  fffc4b01 18
  msgParen                                   code  fffc4c87 18
  msgRNDBad                                  code  fffc4b90 18
  msgReadError                               code  fffc4ae7 18
  msgReady                                   code  fffc4b4a 18
  msgReadyList                               code  fffc2a54 18
  msgRetWoGosub                              code  fffc4c21 18
  msgSYSBad                                  code  fffc4ba3 18
  msgStart                                   code  fffc07ec 18
  msgTaskStart                               code  fffc08a4 18
  msgTimeoutList                             code  fffc2a85 18
  msgTooBig                                  code  fffc4c37 18
  msgVar                                     code  fffc4b7a 18
  msgVarSpace                                code  fffc4b26 18
  msgWhat                                    code  fffc4ad8 18
  msgs                                      const  004800 16
  nmeSerial                                  code  fffc16ac 18
  prCRLF                                     code  fffc4570 18
  pword1                                     code  fffc38b4 18
  pword2                                     code  fffc38d0 18
  qToChk                                     code  fffc182a 18
  return1                                    code  fffc33c4 18
  rnd1                                       code  fffc4074 18
  rnd2                                       code  fffc4084 18
  switchflag                                const  004200 16
  sysx1                                      code  fffc39b0 18
  tah1                                       code  fffc3904 18
  toAsciiHex                                 code  fffc38f4 18
  toUpper                                    code  fffc4818 18
  tstv_notfound                              code  fffc3e88 18
  usrJmp                                    const  0007a0 12

Undefined Symbols
  AUXIN                                      code  800000000000023a 32
  AUXIN_INIT                                 code  80000000000002f8 32
  AUXOUT                                     code  8000000000000238 32
  AUXOUT_FLUSH                               code  8000000000000305 32
  AUXOUT_INIT                                code  80000000000002fc 32
  DumpReadyQueue                             code  800000000000017d 32
  FMTK_Initialize                            code  800000000000016f 32
  FMTK_PostMsg                               code  8000000000000177 32
  FMTK_SetTaskPriority                       code  8000000000000173 32
  FMTK_StartApp                              code  800000000000017b 32
  HRDY0                                      code  80000000000001d7 32
  SDReadSector                               code  80000000000002f9 32
  SDWriteSector                              code  80000000000002fe 32
  TRDY0                                      code  80000000000001d8 32
  _cls                                       code  800000000000027d 32
  _rdcf                                      code  800000000000027f 32
  gen_rand                                   code  8000000000000347 32

  Macro Name
 mGetCurrentTid                            -842150451

	csrrw	v0,#$181,x0
	and		v0,v0,#15

 mHasFocus                                 -842150451

	ldi		a0,#20
	ecall

 mMbxRemoveTask                            -842150451

	sub		$sp,$sp,#16
	sw		$s1,[$sp]
	sw		$t0,4[$sp]
	sw		$t1,8[$sp]
	sw		$t2,12[$sp]
	sll		$s1,$a0,#10						; tid to pointer
	lh		$t0,TCBWaitMbx[$s1]		; get mailbox handle
	blt		$t0,$x0,.xit@					; handle good?
	sll		$t0,$t0,#4						; convert to pointer
	add		$t0,$t0,#mbxs					; by adding base address
	lhu		$t1,MBX_WTIDS[$t0]		; get waiting task list
	ldi		$t2,#1								; create a mask for given task id
	sll		$t2,$t2,$a0
	xor		$t2,$t2,#-1
	and		$t1,$t1,$t2						; clear bit
	sh		$t1,MBX_WTIDS[$t0]		; update waiting task list
.xit@:
	lw		$s1,[$sp]
	lw		$t0,4[$sp]
	lw		$t1,8[$sp]
	lw		$t2,12[$sp]
	add		$sp,$sp,#16

 mPopTimeoutList                           -842150451

	lh		$v0,TimeoutList				; anything on timeout list?
	blt		$v0,$x0,.done@
	ldi		$v1,#NR_TCB
	bgeu	$v0,$v1,.done@
	sll		$t0,$v0,#10						; tid to pointer
	lbu		$v1,TCBStatus[$t0]		; no longer a waiting status
	and		$t1,$v1,#TS_WAITMSG
	beq		$t1,$x0,.noWait@
	
	sub		$sp,$sp,#16
	sw		$s1,[$sp]
	sw		$t0,4[$sp]
	sw		$t1,8[$sp]
	sw		$t2,12[$sp]
	sll		$s1,$a0,#10						; tid to pointer
	lh		$t0,TCBWaitMbx[$s1]		; get mailbox handle
	blt		$t0,$x0,.xit2					; handle good?
	sll		$t0,$t0,#4						; convert to pointer
	add		$t0,$t0,#mbxs					; by adding base address
	lhu		$t1,MBX_WTIDS[$t0]		; get waiting task list
	ldi		$t2,#1								; create a mask for given task id
	sll		$t2,$t2,$a0
	xor		$t2,$t2,#-1
	and		$t1,$t1,$t2						; clear bit
	sh		$t1,MBX_WTIDS[$t0]		; update waiting task list
.xit2:
	lw		$s1,[$sp]
	lw		$t0,4[$sp]
	lw		$t1,8[$sp]
	lw		$t2,12[$sp]
	add		$sp,$sp,#16
.noWait@:
	and		$v1,$v1,#~(TS_WAITMSG|TS_TIMEOUT)
	sb		$v1,TCBStatus[$t0]
	lh		$v1,TCBNext[$t0]
	sh		$v1,TimeoutList
	ldi		$t1,#NR_TCB
	bgeu	$v1,$t1,.done@
	lh		$t1,TCBPrev[$t0]			; t1 = h->prev
	sll		$v1,$v1,#10
	sh		$t1,TCBPrev[$v1]			; TimeoutList->prev = h->prev
	srl		$v1,$v1,#10
	sll		$t1,$t1,#10
	sh		$v1,TCBNext[$t1]			; h->prev->next = TimeoutList
.done@:	

 mSleep                                    1

	ldi		a0,#5
	ldi		a1,#0
	ecall

 mUnlockSemaphore                          1

	ldi		v0,#-1
	sw		v0,0

 mWaitForFocus                             -842150451

.WFF1@:
	
	ldi		a0,#20
	ecall
bne		v1,x0,.HasFocus@
	call	SerialPeekChar	;Direct
	ldi		a0,#$14							; CTRL-T
	bne		$v0,$a0,.WFF2@
	call	SerialGetChar
	ldi		$a0,#21							; switch IO Focus
	ecall
	bra		.WFF1@
.WFF2@:
	
	ldi		a0,#5
	ldi		a1,#1
	ecall

	bra		.WFF1@
.HasFocus@:

0 compressable instructions
The top 1024 are:
Comp  Opcode  Count
