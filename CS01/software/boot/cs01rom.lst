                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	BS					equ		$08
                        	LF					equ		$0A
                        	CR					equ		$0D
                        	XON					equ		$11
                        	XOFF				equ		$13
                        	DEL					equ		$7F
                        	VIA					equ		$FFDC0600
                        	VIA_PA			equ		$04
                        	VIA_DDRA		equ		$0C
                        	VIA_T1CL		equ		$10
                        	VIA_T1CH		equ		$14
                        	VIA_ACR			equ		$2C
                        	VIA_PCR			equ		$30
                        	VIA_IFR			equ		$34
                        	VIA_PARAW		equ		$3C
                        	UART				equ		$FFDC0A00
                        	UART_TRB		equ		$00
                        	UART_STAT		equ		$04
                        	UART_CMD		equ		$08
                        	INBUF				equ		$100
                        	MMUsmc			equ		$200
                        	
                        	x1Save			equ		$04
                        	x2Save			equ		$08
                        	x3Save			equ		$0C
                        	x4Save			equ		$10
                        	x5Save			equ		$14
                        	x6Save			equ		$18
                        	x7Save			equ		$1C
                        	x8Save			equ		$20
                        	x9Save			equ		$24
                        	x10Save			equ		$28
                        	x11Save			equ		$2C
                        	x12Save			equ		$30
                        	x13Save			equ		$34
                        	x14Save			equ		$38
                        	x15Save			equ		$3C
                        	x16Save			equ		$40
                        	x17Save			equ		$44
                        	x18Save			equ		$48
                        	x19Save			equ		$4C
                        	x20Save			equ		$50
                        	x21Save			equ		$54
                        	x22Save			equ		$58
                        	x23Save			equ		$5C
                        	x24Save			equ		$60
                        	x25Save			equ		$64
                        	x26Save			equ		$68
                        	x27Save			equ		$6C
                        	x28Save			equ		$70
                        	x29Save			equ		$74
                        	x30Save			equ		$78
                        	x31Save			equ		$7C
                        	f0Save			equ		$80
                        	f1Save			equ		$84
                        	f2Save			equ		$88
                        	f18Save			equ		$C8
                        	
                        	.file "cs01rom.asm",60
                        			code	18 bits
                        	;------------------------------------------------------------------------------
                        	; Exception vector table.
                        	;------------------------------------------------------------------------------
                        			org		$FFFC0000				; user mode exception
FFFC0000 6B00006F			jmp		IRQRout
FFFC0004 00000000			org 	$FFFC00C0				; machine mode exception
FFFC0008 00000000
FFFC000C 00000000
FFFC0010 00000000
FFFC0014 00000000
FFFC0018 00000000
FFFC001C 00000000
FFFC0020 00000000
FFFC0024 00000000
FFFC0028 00000000
FFFC002C 00000000
FFFC0030 00000000
FFFC0034 00000000
FFFC0038 00000000
FFFC003C 00000000
FFFC0040 00000000
FFFC0044 00000000
FFFC0048 00000000
FFFC004C 00000000
FFFC0050 00000000
FFFC0054 00000000
FFFC0058 00000000
FFFC005C 00000000
FFFC0060 00000000
FFFC0064 00000000
FFFC0068 00000000
FFFC006C 00000000
FFFC0070 00000000
FFFC0074 00000000
FFFC0078 00000000
FFFC007C 00000000
FFFC0080 00000000
FFFC0084 00000000
FFFC0088 00000000
FFFC008C 00000000
FFFC0090 00000000
FFFC0094 00000000
FFFC0098 00000000
FFFC009C 00000000
FFFC00A0 00000000
FFFC00A4 00000000
FFFC00A8 00000000
FFFC00AC 00000000
FFFC00B0 00000000
FFFC00B4 00000000
FFFC00B8 00000000
FFFC00BC 00000000
FFFC00C0 5F00006F			jmp		IRQRout
FFFC00C4 00000000			org		$FFFC00FC				; non-maskable interrupt
FFFC00C8 00000000
FFFC00CC 00000000
FFFC00D0 00000000
FFFC00D4 00000000
FFFC00D8 00000000
FFFC00DC 00000000
FFFC00E0 00000000
FFFC00E4 00000000
FFFC00E8 00000000
FFFC00EC 00000000
FFFC00F0 00000000
FFFC00F4 00000000
FFFC00F8 00000000
FFFC00FC 0040006F			jmp		MachineStart
                        	
                        	;------------------------------------------------------------------------------
                        	; User mode code starts here
                        	;------------------------------------------------------------------------------
                        			org		$FFFC0100
                        	MachineStart:
FFFC0100 00080737			ldi		$sp,#$80000-4		; setup machine mode stack pointer
FFFC0104 FFC70713
FFFC0108 00002937			ldi		$a0,#$1800
FFFC010C 80090913
FFFC0110 0007A9B7			ldi		$a1,#$7A000
FFFC0114 00098993
FFFC0118 41390933			sub		a0,a0,a1
FFFC011C 3B4000EF			call	PutHexWord
FFFC0120 249000EF			call	MMUInit					; initialize MMU for address space zero.
FFFC0124 FFFC0D37			ldi		$t0,#$FFFC0000
FFFC0128 000D0D13
FFFC012C 301D1073			csrrw $x0,#$301,$t0		; set tvec
FFFC0130 FFFC0D37			ldi		$t0,#UserStart
FFFC0134 140D0D13
FFFC0138 341D1073			csrrw	$x0,#$341,$t0		; set mepc
FFFC013C 10000073			eret									; switch to user mode
                        	UserStart:
FFFC0140 00080737			ldi		$sp,#$80000-1028		; setup user mode stack pointer
FFFC0144 BFC70713
FFFC0148 428000EF			call	VIAInit
FFFC014C 00806D13			ldi		$t0,#$08						; turn on the LED
FFFC0150 FFDC0637			sw		$t0,VIA+VIA_PARAW
FFFC0154 63C60613
FFFC0158 00060633
FFFC015C 01A62023
FFFC0160 50C000EF			call	SerialInit
FFFC0164 01006E13			ldi		$t2,#16							; send an XON just in case
FFFC0168 01106913			ldi		$a0,#XON
                        	.0004:
FFFC016C 4A0000EF			call	SerialPutChar
FFFC0170 FFFE0E13			sub		$t2,$t2,#1
FFFC0174 FE0E1CE3			bne		$t2,$x0,.0004
FFFC0178 04106913			ldi		$a0,#'A'						; Try sending the letter 'A'
FFFC017C 490000EF			call	SerialPutChar
                        	.0002:
FFFC0180 FFFC0937			ldi		$a0,#msgStart				; spit out a startup message
FFFC0184 71C90913
FFFC0188 4B0000EF			call	SerialPutString
FFFC018C 04000463			bra		MonEntry
                        	
                        			; Now a loop to recieve and echo back characters
                        	.0003:
FFFC0190 448000EF			call	SerialPeekChar
FFFC0194 FE084EE3			blt		$v0,$x0,.0003
FFFC0198 00086933			mov		$a0,$v0
FFFC019C 470000EF			call	SerialPutChar
FFFC01A0 FE0008E3			bra		.0003
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	Getch:
FFFC01A4 FFC70713			sub		$sp,$sp,#4
FFFC01A8 00172023			sw		$ra,[$sp]
FFFC01AC 42C000EF			call	SerialPeekChar
FFFC01B0 00072083			lw		$ra,[$sp]
FFFC01B4 00470713			add		$sp,$sp,#4
FFFC01B8 00008067			ret
                        	
                        	Putch:
FFFC01BC FFC70713			sub		$sp,$sp,#4
FFFC01C0 00172023			sw		$ra,[$sp]
FFFC01C4 448000EF			call	SerialPutChar
FFFC01C8 00072083			lw		$ra,[$sp]
FFFC01CC 00470713			add		$sp,$sp,#4
FFFC01D0 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	MonEntry:
FFFC01D4 FFFC1637			flw			$f2,fltTen
FFFC01D8 B6060613
FFFC01DC 00060633
FFFC01E0 00062107
FFFC01E4 08202427			fsw			$f2,f2Save
FFFC01E8 FFFC1637			flw			$f1,fltTen
FFFC01EC B6060613
FFFC01F0 00060633
FFFC01F4 00062087
FFFC01F8 08102227			fsw			$f1,f1Save
FFFC01FC 00110953			fadd		$f18,$f2,$f1
FFFC0200 0D202427			fsw			$f18,f18Save
FFFC0204 00A06913			ldi		$a0,#10
FFFC0208 00606A13			ldi		$a2,#6
                        	;		call	fltToString
                        	;		ldi		$a0,#STRTMP
                        	;		call	SerialPutString
                        	
                        	Monitor:
FFFC020C 00102223			sw		$x1,x1Save
FFFC0210 00202423			sw		$x2,x2Save
FFFC0214 00302623			sw		$x3,x3Save
FFFC0218 00402823			sw		$x4,x4Save
FFFC021C 00502A23			sw		$x5,x5Save
FFFC0220 00602C23			sw		$x6,x6Save
FFFC0224 00702E23			sw		$x7,x7Save
FFFC0228 02802023			sw		$x8,x8Save
FFFC022C 02902223			sw		$x9,x9Save
FFFC0230 02A02423			sw		$x10,x10Save
FFFC0234 02B02623			sw		$x11,x11Save
FFFC0238 02C02823			sw		$x12,x12Save
FFFC023C 02D02A23			sw		$x13,x13Save
FFFC0240 02E02C23			sw		$x14,x14Save
FFFC0244 02F02E23			sw		$x15,x15Save
FFFC0248 05002023			sw		$x16,x16Save
FFFC024C 05102223			sw		$x17,x17Save
FFFC0250 05202423			sw		$x18,x18Save
FFFC0254 05302423			sw		$x19,x18Save
FFFC0258 05402823			sw		$x20,x20Save
FFFC025C 05502A23			sw		$x21,x21Save
FFFC0260 05602C23			sw		$x22,x22Save
FFFC0264 05702E23			sw		$x23,x23Save
FFFC0268 07802023			sw		$x24,x24Save
FFFC026C 07902223			sw		$x25,x25Save
FFFC0270 07A02423			sw		$x26,x26Save
FFFC0274 07B02623			sw		$x27,x27Save
FFFC0278 07C02823			sw		$x28,x28Save
FFFC027C 07D02A23			sw		$x29,x29Save
FFFC0280 07E02C23			sw		$x30,x30Save
FFFC0284 07F02E23			sw		$x31,x31Save
FFFC0288 00006213			ldi		$s1,#0					; s1 = input pointer
FFFC028C 00D06913			ldi		$a0,#CR
FFFC0290 F2DFF0EF			call	Putch
FFFC0294 00006913			ldi		$a0,#LF
		call	Putch
FFFC0298 F25FF0EF
FFFC029C 03E06913			ldi		$a0,#'>'
FFFC02A0 F1DFF0EF			call	Putch
                        	.0001:
FFFC02A4 F01FF0EF			call	Getch						; wait until character pressed
FFFC02A8 FE084EE3			blt		$v0,$x0,.0001
FFFC02AC 00084D13			xor		$t0,$v0,#LF			; ignore line feed
		beq		$t0,$x0,.procLine
FFFC02B0 080D0863
FFFC02B4 00D84D13			xor		$t0,$v0,#CR
FFFC02B8 080D0463			beq		$t0,$x0,.procLine
FFFC02BC 00884D13			xor		$t0,$v0,#BS
FFFC02C0 040D0463			beq		$t0,$x0,.doBackspace
FFFC02C4 07F84D13			xor		$t0,$v0,#DEL
FFFC02C8 000D0C63			beq		$t0,$x0,.doDelete
FFFC02CC 11020023			sb		$v0,INBUF[$s1]
FFFC02D0 00120213			add		$s1,$s1,#1
FFFC02D4 00086933			mov		$a0,$v0
FFFC02D8 EE5FF0EF			call	Putch
FFFC02DC FC0004E3			bra		.0001
                        	.doDelete:
FFFC02E0 000262B3			mov		$s2,$s1
FFFC02E4 00128293			add		$s2,$s2,#1
                        	.0002:
FFFC02E8 10028D03			lb		$t0,INBUF[$s2]
FFFC02EC 0FA28FA3			sb		$t0,INBUF-1[$s2]
FFFC02F0 00128293			add		$s2,$s2,#1
FFFC02F4 10028D13			add		$t0,$s2,#INBUF
FFFC02F8 17FD2D13			slt		$t0,$t0,#INBUF+$7F
FFFC02FC FE0D16E3			bne		$t0,$x0,.0002
FFFC0300 10028023			sb		$x0,INBUF[$s2]
FFFC0304 FA0000E3			bra		.0001
                        	.doBackspace:
FFFC0308 00024D13			xor		$t0,$s1,#0
FFFC030C F80D0CE3			beq		$t0,$x0,.0001		; can't backspace anymore
FFFC0310 00086933			mov		$a0,$v0					; show the backspace
FFFC0314 EA9FF0EF			call	Putch
FFFC0318 FFF20213			sub		$s1,$s1,#1
FFFC031C 000262B3			mov		$s2,$s1
                        	.0003:
FFFC0320 10128D03			lb		$t0,INBUF+1[$s2]
FFFC0324 11A28023			sb		$t0,INBUF[$s2]
FFFC0328 00128293			add		$s2,$s2,#1
FFFC032C 10028D13			add		$t0,$s2,#INBUF
FFFC0330 17FD2D13			slt		$t0,$t0,#INBUF+$7F
FFFC0334 FE0D16E3			bne		$t0,$x0,.0003
FFFC0338 10028023			sb		$x0,INBUF[$s2]
FFFC033C F60004E3			bra		.0001
                        	.procLine:
FFFC0340 10020023			sb		$x0,INBUF[$s1]
FFFC0344 00006213			ldi		$s1,#0
                        	.skip:
FFFC0348 10020D03			lb		$t0,INBUF[$s1]
FFFC034C 020D0C63			beq		$t0,$x0,.0005
FFFC0350 03ED4D93			xor		$t1,$t0,#'>'
FFFC0354 000D9663			bne		$t1,$x0,.0004
                        	.skip2:
FFFC0358 00120213			add		$s1,$s1,#1
FFFC035C FE0006E3			bra		.skip
                        	.0004:
FFFC0360 020D4D93			xor		$t1,$t0,#' '
FFFC0364 FE0D8AE3			beq		$t1,$x0,.skip2
FFFC0368 009D4D93			xor		$t1,$t0,#'\t'
FFFC036C FE0D86E3			beq		$t1,$x0,.skip2
FFFC0370 04DD4D93			xor		$t1,$t0,#'M'
FFFC0374 000D8A63			beq		$t1,$x0,doMem
FFFC0378 04206D93			ldi		$t1,#'B'
FFFC037C 01BD1463			bne		$t0,$t1,.0006
FFFC0380 4B10006F			jmp		CSTART
                        	.0006:
                        	.0005:
FFFC0384 E80004E3			bra		Monitor
                        	
                        	doMem:
FFFC0388 FFC70713			sub		$sp,$sp,#4
FFFC038C 00120213			add		$s1,$s1,#1
FFFC0390 00472023			sw		$s1,[$sp]
FFFC0394 00D06913			ldi		$a0,#CR
FFFC0398 E25FF0EF			call	Putch
FFFC039C 00006913			ldi		$a0,#LF
		call	Putch
FFFC03A0 E1DFF0EF
FFFC03A4 10006913			ldi		$a0,INBUF
FFFC03A8 290000EF			call	SerialPutString
FFFC03AC 00072203			lw		$s1,[$sp]
FFFC03B0 00470713			add		$sp,$sp,#4
FFFC03B4 088000EF			call	GetHexNum
FFFC03B8 00086333			mov		$s3,$v0
FFFC03BC 00120213			add		$s1,$s1,#1
FFFC03C0 07C000EF			call	GetHexNum
FFFC03C4 006803B3			add		$s4,$v0,$s3
                        	.loop2:
FFFC03C8 DDDFF0EF			call	Getch						; check for ctrl-c
FFFC03CC 00384813			xor		$v0,$v0,#3
FFFC03D0 E2080EE3			beq		$v0,$x0,Monitor
FFFC03D4 00D06913			ldi		$a0,#CR
FFFC03D8 DE5FF0EF			call	Putch
FFFC03DC 00006913			ldi		$a0,#LF
		call	Putch
FFFC03E0 DDDFF0EF
FFFC03E4 00036933			mov		$a0,$s3
FFFC03E8 0E8000EF			call	PutHexWord
FFFC03EC 03A06913			ldi		$a0,#':'
FFFC03F0 DCDFF0EF			call	Putch
FFFC03F4 00706293			ldi		$s2,#7
                        	.loop:
FFFC03F8 02006913			ldi		$a0,#' '
FFFC03FC DC1FF0EF			call	Putch
FFFC0400 00030903			lb		$a0,[$s3]
FFFC0404 10C000EF			call	PutHexByte
FFFC0408 00130313			add		$s3,$s3,#1
FFFC040C FFF28293			sub		$s2,$s2,#1
FFFC0410 FE02D4E3			bge		$s2,$x0,.loop
FFFC0414 FA736AE3			bltu	$s3,$s4,.loop2
FFFC0418 DE000AE3			bra		Monitor		
                        	
                        	;------------------------------------------------------------------------------
                        	; Skip over spaces and tabs in the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	SkipSpaces:
                        	.skip2:
FFFC041C 10020D03			lb		$t0,INBUF[$s1]
FFFC0420 020D4D93			xor		$t1,$t0,#' '
FFFC0424 000D8863			beq		$t1,$x0,.skip1
FFFC0428 009D4D93			xor		$t1,$t0,#'\t'
FFFC042C 000D8463			beq		$t1,$x0,.skip1
FFFC0430 00008067			ret
                        	.skip1:
FFFC0434 00120213			add		$s1,$s1,#1
FFFC0438 FE0002E3			bra		.skip2
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a hex number from the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	GetHexNum:
FFFC043C 00006813			ldi		$v0,#0							; v0 = num
FFFC0440 FFC70713			sub		$sp,$sp,#4
FFFC0444 00172023			sw		$ra,[$sp]
FFFC0448 FD5FF0EF			call	SkipSpaces
                        	.next:
FFFC044C 10020D03			lb		$t0,INBUF[$s1]
FFFC0450 03006E13			ldi		$t2,#'0'
FFFC0454 03CD4663			blt		$t0,$t2,.0001
FFFC0458 03A06E13			ldi		$t2,#'9'+1
FFFC045C 07CD4063			blt		$t0,$t2,.isDigit
FFFC0460 04106E13			ldi		$t2,#'A'
FFFC0464 01CD4E63			blt		$t0,$t2,.0001
FFFC0468 04706E13			ldi		$t2,#'F'+1
FFFC046C 03CD4063			blt		$t0,$t2,.isHexUpper
FFFC0470 06106E13			ldi		$t2,#'a'
FFFC0474 01CD4663			blt		$t0,$t2,.0001
FFFC0478 06706E13			ldi		$t2,#'f'+1
FFFC047C 03CD4463			blt		$t0,$t2,.isHexLower
                        	.0001:
FFFC0480 00072083			lw		$ra,[$sp]
FFFC0484 00470713			add		$sp,$sp,#4
FFFC0488 00008067			ret
                        	.isHexUpper:
FFFC048C 00481813			sll		$v0,$v0,#4
FFFC0490 FBFD0D13			sub		$t0,$t0,#'A'
FFFC0494 00AD0D13			add		$t0,$t0,#10
FFFC0498 01A86833			or		$v0,$v0,$t0
FFFC049C 00120213			add		$s1,$s1,#1
FFFC04A0 FA0006E3			bra		.next
                        	.isHexLower:
FFFC04A4 00481813			sll		$v0,$v0,#4
FFFC04A8 F9FD0D13			sub		$t0,$t0,#'a'
FFFC04AC 00AD0D13			add		$t0,$t0,#10
FFFC04B0 01A86833			or		$v0,$v0,$t0
FFFC04B4 00120213			add		$s1,$s1,#1
FFFC04B8 F8000AE3			bra		.next
                        	.isDigit:
FFFC04BC 00481813			sll		$v0,$v0,#4
FFFC04C0 FD0D0D13			sub		$t0,$t0,#'0'
FFFC04C4 01A86833			or		$v0,$v0,$t0
FFFC04C8 00120213			add		$s1,$s1,#1
FFFC04CC F80000E3			bra		.next
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a word as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexWord:
FFFC04D0 FF870713			sub		$sp,$sp,#8
FFFC04D4 00172023			sw		$ra,[$sp]
FFFC04D8 01272223			sw		$a0,4[$sp]
FFFC04DC 01095913			srl		$a0,$a0,#16
FFFC04E0 010000EF			call	PutHexHalf
FFFC04E4 00072083			lw		$ra,[$sp]
FFFC04E8 00472903			lw		$a0,4[$sp]
FFFC04EC 00870713			add		$sp,$sp,#8	; fall through to PutHexHalf
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a half-word (16 bits) as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexHalf:
FFFC04F0 FF870713			sub		$sp,$sp,#8
FFFC04F4 00172023			sw		$ra,[$sp]
FFFC04F8 01272223			sw		$a0,4[$sp]
FFFC04FC 00895913			srl		$a0,$a0,#8
FFFC0500 010000EF			call	PutHexByte
FFFC0504 00072083			lw		$ra,[$sp]
FFFC0508 00472903			lw		$a0,4[$sp]		
FFFC050C 00870713			add		$sp,$sp,#8	; fall through to PutHexByte
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a byte as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexByte:
FFFC0510 FF870713			sub		$sp,$sp,#8
FFFC0514 00172023			sw		$ra,[$sp]
FFFC0518 01272223			sw		$a0,4[$sp]
FFFC051C 00495913			srl		$a0,$a0,#4		; put the high order nybble first
FFFC0520 010000EF			call	PutHexNybble
FFFC0524 00072083			lw		$ra,[$sp]
FFFC0528 00472903			lw		$a0,4[$sp]
FFFC052C 00870713			add		$sp,$sp,#8		; fall through to PutHexNybble
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a nybble as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexNybble:
FFFC0530 FF870713			sub		$sp,$sp,#8
FFFC0534 00172023			sw		$ra,[$sp]
FFFC0538 01272223			sw		$a0,4[$sp]
FFFC053C 00F97913			and		$a0,$a0,#15		; strip off high order bits
FFFC0540 00A06D13			ldi		$t0,#10
FFFC0544 01A94A63			blt		$a0,$t0,.lt10
FFFC0548 FF690913			sub		$a0,$a0,#10
FFFC054C 04190913			add		$a0,$a0,#'A'
FFFC0550 C6DFF0EF			call	Putch
FFFC0554 00000663			bra		.0001
                        	.lt10:
FFFC0558 03090913			add		$a0,$a0,#'0'
FFFC055C C61FF0EF			call	Putch
                        	.0001:
FFFC0560 00072083			lw		$ra,[$sp]
FFFC0564 00472903			lw		$a0,4[$sp]
FFFC0568 00870713			add		$sp,$sp,#8
FFFC056C 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; VIAInit
                        	;
                        	; Initialize the versatile interface adapter.
                        	;------------------------------------------------------------------------------
                        	
                        	VIAInit:
                        			; Initialize port A low order eight bits as output, the remaining bits as
                        			; input.
FFFC0570 0FF06D13			ldi		$t0,#$000000FF
FFFC0574 FFDC0637			sw		$t0,VIA+VIA_DDRA
FFFC0578 60C60613
FFFC057C 00060633
FFFC0580 01A62023
FFFC0584 00106D13			ldi		$t0,#1							; select timer 3 access
FFFC0588 FFDC0637			sb		$t0,VIA+VIA_PCR+1
FFFC058C 63160613
FFFC0590 00060633
FFFC0594 01A60023
FFFC0598 01F06D13			ldi		$t0,#$1F
FFFC059C FFDC0637			sb		$t0,VIA+VIA_ACR+1		; set timer 3 mode, timer 1/2 = 64 bit
FFFC05A0 62D60613
FFFC05A4 00060633
FFFC05A8 01A60023
FFFC05AC 00197D37			ldi		$t0,#$00196E6B			;	divider value for 30Hz
FFFC05B0 E6BD0D13
FFFC05B4 FFDC0637			sw		$t0,VIA+VIA_T1CL
FFFC05B8 61060613
FFFC05BC 00060633
FFFC05C0 01A62023
FFFC05C4 FFDC0637			sw		$x0,VIA+VIA_T1CH		; trigger transfer to count registers
FFFC05C8 61460613
FFFC05CC 00060633
FFFC05D0 00062023
FFFC05D4 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPeekChar
                        	;
                        	; Check the serial port status to see if there's a char available. If there's
                        	; a char available then return it.
                        	;
                        	; Modifies:
                        	;		$t0
                        	; Returns:
                        	;		$v0 = character or -1
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPeekChar:
FFFC05D8 FFDC1637			lb		$t0,UART+UART_STAT
FFFC05DC A0460613
FFFC05E0 00060633
FFFC05E4 00060D03
FFFC05E8 008D7D13			and		$t0,$t0,#8					; look for Rx not empty
FFFC05EC 000D0C63			beq		$t0,$x0,.0001
FFFC05F0 FFDC1637			lb		$v0,UART+UART_TRB
FFFC05F4 A0060613
FFFC05F8 00060633
FFFC05FC 00060803
FFFC0600 00008067			ret
                        	.0001:
FFFC0604 FFF06813			ldi		$v0,#-1
FFFC0608 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPutChar
                        	;    Put a character to the serial transmitter. This routine blocks until the
                        	; transmitter is empty.
                        	;
                        	; Parameters:
                        	;		$a0 = character to put
                        	; Modifies:
                        	;		$t0
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPutChar:
                        	.0001:
FFFC060C FFDC1637			lb		$t0,UART+UART_STAT	; wait until the uart indicates tx empty
FFFC0610 A0460613
FFFC0614 00060633
FFFC0618 00060D03
FFFC061C 010D7D13			and		$t0,$t0,#16					; bit #4 of the status reg
FFFC0620 FE0D06E3			beq		$t0,$x0,.0001				; branch if transmitter is not empty
FFFC0624 FFDC1637			sb		$a0,UART+UART_TRB		; send the byte
FFFC0628 A0060613
FFFC062C 00060633
FFFC0630 01260023
FFFC0634 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPutString
                        	;    Put a string of characters to the serial transmitter. Calls the 
                        	; SerialPutChar routine, so this routine also blocks if the transmitter is not
                        	; empty.
                        	;
                        	; Parameters:
                        	;		$a0 = pointer to null terminated string to put
                        	; Modifies:
                        	;		$t0 and $t1
                        	; Stack Space:
                        	;		2 words
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPutString:
FFFC0638 FF870713			sub		$sp,$sp,#8				; save link register
FFFC063C 00172023			sw		$ra,[$sp]
FFFC0640 01272223			sw		$a0,4[$sp]				; and argument
FFFC0644 00096DB3			mov		$t1,$a0						; t1 = pointer to string
                        	.0001:
FFFC0648 000D8903			lb		$a0,[$t1]
FFFC064C 001D8D93			add		$t1,$t1,#1				; advance pointer to next byte
FFFC0650 00090663			beq		$a0,$x0,.done			; branch if done
FFFC0654 FB9FF0EF			call	SerialPutChar			; output character
FFFC0658 FE0008E3			bra		.0001
                        	.done:
FFFC065C 00072083			lw		$ra,[$sp]					; restore return address
FFFC0660 00472903			lw		$a0,4[$sp]				; and argument
FFFC0664 00870713			add		$sp,$sp,#8
FFFC0668 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Initialize serial port.
                        	;
                        	; Modifies:
                        	;		$t0
                        	;------------------------------------------------------------------------------
                        	
                        	SerialInit:
FFFC066C 00B06D13			ldi		$t0,#$0B						; dtr,rts active, rxint disabled, no parity
FFFC0670 FFDC1637			sw		$t0,UART+8
FFFC0674 A0860613
FFFC0678 00060633
FFFC067C 01A62023
FFFC0680 00060D37			ldi		$t0,#$0006001E			; reset the fifo's
FFFC0684 01ED0D13
FFFC0688 FFDC1637			sw		$t0,UART+12
FFFC068C A0C60613
FFFC0690 00060633
FFFC0694 01A62023
FFFC0698 01E06D13			ldi		$t0,#$0000001E			; baud 9600, 1 stop bit, 8 bit, internal baud gen
FFFC069C FFDC1637			sw		$t0,UART+12
FFFC06A0 A0C60613
FFFC06A4 00060633
FFFC06A8 01A62023
FFFC06AC 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Exception processing code starts here.
                        	;------------------------------------------------------------------------------
                        	.file "cs01rom.asm",538
                        			code
                        			align	4                        	
                        	IRQRout:
FFFC06B0 00080737			ldi		$sp,#$80000-4		; setup machine mode stack pointer
FFFC06B4 FFC70713
FFFC06B8 34201D73			csrrw	$t0,#$342,$x0			; get cause code
FFFC06BC 000D4463			blt		$t0,$x0,.isIRQ		; irq or ecall?
FFFC06C0 10000073			eret										
                        	.isIRQ:
                        	 		; Was it the VIA that caused the interrupt?
FFFC06C4 FFDC0637			lb		$t0,VIA+VIA_IFR
FFFC06C8 63460613
FFFC06CC 00060633
FFFC06D0 00060D03
FFFC06D4 000D5C63			bge		$t0,$x0,.0001			; no
FFFC06D8 FFDC0637			lw		$t0,VIA+VIA_T1CL	; yes, clear interrupt
FFFC06DC 61060613
FFFC06E0 00060633
FFFC06E4 00062D03
FFFC06E8 10000073			eret
                        			; Was it the uart that caused the interrupt?
                        	.0001:
FFFC06EC FFDC1637			lb		$t0,UART+UART_STAT
FFFC06F0 A0460613
FFFC06F4 00060633
FFFC06F8 00060D03
FFFC06FC 000D4463			blt		$t0,$x0,.0002			; uart cause interrupt?
                        			; Some other interrupt
FFFC0700 10000073			eret
                        	.0002:
FFFC0704 00B06D13			ldi		$t0,#$0B						; dtr,rts active, rxint disabled, no parity
FFFC0708 FFDC1637			sw		$t0,UART+UART_CMD
FFFC070C A0860613
FFFC0710 00060633
FFFC0714 01A62023
FFFC0718 10000073			eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Message strings
                        	;------------------------------------------------------------------------------
                        	
                        	msgStart:
FFFC071C 31305343			db		"CS01 System Starting.",13,10
FFFC0720 73795320
FFFC0724 206D6574
FFFC0728 72617453
FFFC072C 676E6974
FFFC0730 4D0A0D2E
                        	msgMonHelp:
FFFC0733 696E6F4D			db		"Monitor Commands",13,10
FFFC0737 20726F74
FFFC073B 6D6D6F43
FFFC073F 73646E61
FFFC0743 20420A0D
FFFC0745 202D2042			db		"B - start tiny basic",13,10
FFFC0749 72617473
FFFC074D 69742074
FFFC0751 6220796E
FFFC0755 63697361
FFFC0759 204D0A0D
FFFC075B 733C204D			db		"M <start> <length>	- dump memory",13,10,0
FFFC075F 74726174
FFFC0763 6C3C203E
FFFC0767 74676E65
FFFC076B 2D093E68
FFFC076F 6D756420
FFFC0773 656D2070
FFFC0777 79726F6D
FFFC077B 00000A0D
FFFC077E 00000000			align 
                        	
                        	
                        	flt50:
FFFC0780 00000000		dw	0x00000000,0x00000000,0x00000000,0x40049000
FFFC0784 00000000
FFFC0788 00000000
FFFC078C 40049000
                        	flt20:
FFFC0790 00000000		dw	0x00000000,0x00000000,0x00000000,0x40034000
FFFC0794 00000000
FFFC0798 00000000
FFFC079C 40034000
                        	flt10:
FFFC07A0 00000000		dw	0x00000000,0x00000000,0x00000000,0x40024000
FFFC07A4 00000000
FFFC07A8 00000000
FFFC07AC 40024000
                        	
                        	.file "fltToString.asm",1
                        	.file "fltToString.asm",1
                        	STRTMP		equ		$0200
                        	
                        	; -----------------------------------------------------------------------------
                        	;		$fa0 = number to convert (f18)
                        	;		$a1	= width
                        	;		$a2 = precision
                        	;		$a3 = E
                        	;		$t2 = ndx
                        	;		$s9 = exp
                        	; -----------------------------------------------------------------------------
                        	
                        	fltToString:
FFFC07B0 00006E13			ldi		$t2,#0				; $t2 = 0
FFFC07B4 E0090953			fmv		$a0,$f18
FFFC07B8 7F800637			and		$t0,$a0,#$7F800000
FFFC07BC 01267D33
FFFC07C0 7F800DB7			ldi		$t1,#$7F800000
FFFC07C4 000D8D93
FFFC07C8 05BD1063			bne		$t0,$t1,.0001
FFFC07CC 00800637			and		$t0,$a0,#$007FFFFF
FFFC07D0 01267D33
FFFC07D4 000D0E63			beq		$t0,$x0,.inf
FFFC07D8 FFFC1637			ldt		$t0,msgNan
FFFC07DC B5860613
FFFC07E0 00060633
FFFC07E4 00062D03
FFFC07E8 21A02023			stt		$t0,STRTMP
FFFC07EC 2E000A63			bra		.prt
                        	.inf:
FFFC07F0 FFFC1637			ldt		$t0,msgInf
FFFC07F4 B5460613
FFFC07F8 00060633
FFFC07FC 00062D03
FFFC0800 21A02023			stt		$t0,STRTMP
FFFC0804 2C000E63			bra		.prt
                        	.0001:
FFFC0808 80000637			and		$t0,$a0,#$80000000
FFFC080C 01267D33
FFFC0810 000D0C63			beq		$t0,$x0,.pos
FFFC0814 02D06D13			ldi		$t0,#'-'
FFFC0818 21AE0023			stb		$t0,STRTMP[$t2]
FFFC081C 001E0E13			add		$t2,$t2,#1
FFFC0820 80000637			and		$a0,$a0,#$7FFFFFFF
FFFC0824 01267933
                        	.pos:
FFFC0828 00091A63			bne		$a0,$x0,.notZero
FFFC082C 03006D13			ldi		$t0,#'0'
FFFC0830 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0834 200E00A3			stb		$x0,STRTMP+1[$t2]
FFFC0838 2A000463			bra		.prt		
                        	.notZero:
FFFC083C 00006633			mov		$s9,$x0			; exp = 0.0
                        	;	// Make a small number > 0 so we can get at the digits.
                        	;	if (dbl < 1.0) {
                        	;		while (dbl < 1.0) {
                        	;			dbl *= 1000000.0;
                        	;			exp -= 6;  
                        	;		}
                        	;	}
FFFC0840 FFFC1637			flw		$f3,fltOne
FFFC0844 B5C60613
FFFC0848 00060633
FFFC084C 00062187
FFFC0850 F0090053			fmv		$f0,$a0
FFFC0854 A0391D53			flt		$t0,$f18,$f3
FFFC0858 020D0463			beq		$t0,$x0,.0002
FFFC085C FFFC1637			flw		$f4,fltMillion
FFFC0860 B6460613
FFFC0864 00060633
FFFC0868 00062207
                        	.0003:
FFFC086C A0391D53			flt		$t0,$f18,$f3
FFFC0870 000D0863			beq		$t0,$x0,.0002
FFFC0874 10490953			fmul	$f18,$f18,$f4
FFFC0878 FFA60613			sub		$s9,$s9,#6
FFFC087C FE0008E3			bra		.0003
                        	.0002:
                        	;	// The following is similar to using log10() and pow() functions.
                        	;	// Now dbl is >= 1.0
                        	;	// Create a number dbl2 on the same order of magnitude as dbl, but
                        	;	// less than dbl.
                        	;	dbl2 = 1.0;
                        	;	dbla = dbl2;
                        	;	if (dbl > dbl2) {	// dbl > 1.0 ?
                        	;		while (dbl2 <= dbl) {
                        	;			dbla = dbl2;
                        	;			dbl2 *= 10.0;	// increase power of 10
                        	;			exp++;
                        	;		}
                        	;		// The above loop goes one too far, we want the last value less
                        	;		// than dbl.
                        	;		dbl2 = dbla;
                        	;		exp--;
                        	;	}
FFFC0880 FFFC1637			flw		$f1,fltOne				; $f1 = dbl2 = 1.0
FFFC0884 B5C60613
FFFC0888 00060633
FFFC088C 00062087
FFFC0890 38008153			fmov	$f2,$f1						; $f2 = dbla = dbl2
FFFC0894 A1209D53			flt		$t0,$f1,$f18				; if (dbl2 < dbl)
FFFC0898 020D0A63			beq		$t0,$x0,.0004
FFFC089C FFFC1637			flw		$f5,fltTen				; $f5 = 10.0
FFFC08A0 B6060613
FFFC08A4 00060633
FFFC08A8 00062287
                        	.0006:
FFFC08AC A1208D53			fle		$t0,$f1,$f18				; while ($f1 <= $f18)
FFFC08B0 000D0A63			beq		$t0,$x0,.0005
FFFC08B4 38008153			fmov	$f2,$f1						; dbla = dbl2
FFFC08B8 105080D3			fmul	$f1,$f1,$f5				; dbl2 *= 10.0
FFFC08BC 00160613			add		$s9,$s9,#1				; exp++;
FFFC08C0 FE0006E3			bra		.0006
                        	.0005:
FFFC08C4 380100D3			fmov	$f1,$f2						; dbl2 = dbla
FFFC08C8 FFF60613			sub		$s9,$s9,#1				; exp--;
                        	.0004:
                        	;	// For small constants < 1000000 try and spit out a whole number
                        	;    if (exp >= 0 && exp < 6) {
                        	;        digits_before_decpt = exp+1;
                        	;		exp = 0;
                        	;	}
                        	;	else if (exp >= -6)
                        	;		digits_before_decpt = 1;
                        	;	else
                        	;		digits_before_decpt = -1;
FFFC08CC 00064E63			blt		$s9,$x0,.0007
FFFC08D0 00606413			ldi		$s5,#6
FFFC08D4 00865A63			bge		$s9,$s5,.0007
FFFC08D8 FFFFE233			mov		$s1,#s0						; s1 = digits before decpt
FFFC08DC 00120213			add		$s1,$s1,#1
FFFC08E0 00006613			ldi		$s9,#0						; exp = 0
FFFC08E4 00000C63			bra		.0008
                        	.0007:
FFFC08E8 FF906413			ldi		$s5,#-7
FFFC08EC 00864663			blt		$s9,$s5,.0009
FFFC08F0 00106213			ldi		$s1,#1
FFFC08F4 00000463			bra		.0008
                        	.0009:
FFFC08F8 FFF06213			ldi		$s1,#-1
                        	.0008:
                        	;	// Spit out a leading zero before the decimal point for a small number.
                        	;    if (exp < -6) {
                        	;		buf[ndx] = '0';
                        	;		ndx++;
                        	;        buf[ndx] = '.';
                        	;        ndx++;
                        	;    }
FFFC08FC FFA06413			ldi		$s5,#-6
FFFC0900 00865E63			bge		$s9,$s5,.0010
FFFC0904 03006D13			ldi		$t0,#'0'
FFFC0908 21AE0023			stb		$t0,STRTMP[$t2]
FFFC090C 001E0E13			add		$t2,$t2,#1
FFFC0910 02E06D13			ldi		$t0,#'.'
FFFC0914 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0918 001E0E13			add		$t2,$t2,#1
                        	.0010:
                        	;	// Now loop processing one digit at a time.
                        	;    for (nn = 0; nn < 30 && precision > 0; nn++) {
                        	;        digit = 0;
                        	;		dbla = dbl;
                        	;		// dbl is on the same order of magnitude as dbl2 so
                        	;		// a repeated subtract can be used to find the digit.
                        	;        while (dbl >= dbl2) {
                        	;            dbl -= dbl2;
                        	;            digit++;
                        	;        }
                        	;        buf[ndx] = digit + '0';
                        	;		// Now go back and perform just a single subtract and
                        	;		// a multiply to find out how much to reduce dbl by.
                        	;		// This should improve the accuracy
                        	;		if (digit > 2)
                        	;			dbl = dbla - dbl2 * digit;
                        	;        ndx++;
                        	;        digits_before_decpt--;
                        	;        if (digits_before_decpt==0) {
                        	;           buf[ndx] = '.';
                        	;           ndx++;
                        	;        }
                        	;        else if (digits_before_decpt < 0)
                        	;            precision--;
                        	;		// Shift the next digit to be tested into position.
                        	;        dbl *= 10.0;
                        	;    }
FFFC091C 00006313			ldi		$s3,#0						; s3 = nn = 0
FFFC0920 01E06413			ldi		$s5,#30
FFFC0924 FFFC1637			flw		$f7,fltTen				; f7 = 10.0
FFFC0928 B6060613
FFFC092C 00060633
FFFC0930 00062387
                        	.0016:
FFFC0934 00832D33			slt		$t0,$s3,$s5
FFFC0938 060D0863			beq		$t0,$x0,.0011
FFFC093C 00006413			ldi		$s5,#0
FFFC0940 07445463			bge		$s5,$a2,.0011			; (0 < precision)
FFFC0944 00006393			ldi		$s4,#0						; s4 = digit = 0
FFFC0948 38090153			fmov	$f2,$f18						; dbla = dbl
                        	.0013:
FFFC094C A1208D53			fle		$t0,$f1,$f18						; while (dbl2 <= dbl)
FFFC0950 000D0863			beq		$t0,$x0,.0012
FFFC0954 08190953			fsub	$f18,$f18,$f1						; dbl -= dbl2
FFFC0958 00138393			add		$s4,$s4,#1						; digit++
FFFC095C FE0008E3			bra		.0013
                        	.0012:
FFFC0960 03038413			add		$s5,$s4,#'0'			; buf[ndx] = digit + '0'
FFFC0964 208E0023			stb		$s5,STRTMP[$t2]
FFFC0968 00206413			ldi		$s5,#2						; if (2 < digit)
FFFC096C 00745863			bge		$s5,$s4,.0014
FFFC0970 D00382D3			fcvt.s.w	$f5,$s4				; f5 = digit as float
FFFC0974 10508353			fmul	$f6,$f1,$f5				; f6 = dbl2 * digit
FFFC0978 08610953			fsub	$f18,$f2,$f6				; dbl = dbla - dbl2 * digit
                        	.0014:
FFFC097C 001E0E13			add		$t2,$t2,#1				; ndx++
FFFC0980 FFF20213			sub		$s1,$s1,#1				; digits_before_decpt--;
FFFC0984 00021A63			bne		$s1,$x0,.0015			; if (digits_before_decpt==0)
FFFC0988 02E06D13			ldi		$t0,#'.'
FFFC098C 21AE0023			stb		$t0,STRTMP[$t2]		; buf[ndx] = '.'
FFFC0990 001E0E13			add		$t2,$t2,#1				; ndx++
FFFC0994 00000663			bra		.0017
                        	.0015:
FFFC0998 00025463			bge		$s1,$x0,.0017			; else if (digits_before_decpt < 0)
FFFC099C FFFA0A13			sub		$a2,$a2,#1				; 	precision--
                        	.0017:
FFFC09A0 10790953			fmul	$f18,$f18,$f7				; dbl *= 10.0
FFFC09A4 F80008E3			bra		.0016
                        	.0011:
                        	;	// Trim trailing zeros from the number
                        	;    do {
                        	;        ndx--;
                        	;    } while(buf[ndx]=='0');
                        	;    ndx++;
                        	.0018:
FFFC09A8 FFFE0E13			sub		$t2,$t2,#1				; ndx--
FFFC09AC 200E0D03			ldb		$t0,STRTMP[$t2]
FFFC09B0 030D4D13			xor		$t0,$t0,#'0'
FFFC09B4 FE0D0AE3			beq		$t0,$x0,.0018
FFFC09B8 001E0E13			add		$t2,$t2,#1				; ndx++
                        	;	// Make sure we have at least one digit after the decimal point.
                        	;	if (buf[ndx]=='.') {
                        	;		ndx++;
                        	;		buf[ndx]='0';
                        	;		ndx++;
                        	;        buf[ndx]='\0';
                        	;	}
FFFC09BC 200E0D03			ldb		$t0,STRTMP[$t2]
FFFC09C0 02ED4D13			xor		$t0,$t0,#'.'
FFFC09C4 000D1C63			bne		$t0,$x0,.0019
FFFC09C8 001E0E13			add		$t2,$t2,#1
FFFC09CC 03006D13			ldi		$t0,#'0'
FFFC09D0 21AE0023			stb		$t0,STRTMP[$t2]
FFFC09D4 001E0E13			add		$t2,$t2,#1
FFFC09D8 200E0023			stb		$x0,STRTMP[$t2]
                        	.0019:
                        	;	// If the number is times 10^0 don't output the exponent
                        	;   if (exp==0) {
                        	;        buf[ndx]='\0';
                        	;        goto prt;
                        	;    }
FFFC09DC 00061663			bne		$s9,$x0,.0020
FFFC09E0 200E0023			stb		$x0,STRTMP[$t2]
FFFC09E4 0E000E63			bra		.prt
                        	.0020:
                        	;	// Spit out +/-E
                        	;    buf[ndx] = E;
                        	;    ndx++;
                        	;    if (exp < 0) {
                        	;        buf[ndx]='-';
                        	;        ndx++;
                        	;        exp = -exp;
                        	;    }
                        	;    else {
                        	;         buf[ndx]='+';
                        	;         ndx++;
                        	;    }
FFFC09E8 04506D13			ldi		$t0,#'E'
FFFC09EC 21AE0023			stb		$t0,STRTMP[$t2]
FFFC09F0 001E0E13			add		$t2,$t2,#1
FFFC09F4 00065C63			bge		$s9,$x0,.0021
FFFC09F8 02D06D13			ldi		$t0,#'-'
FFFC09FC 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0A00 001E0E13			add		$t2,$t2,#1
FFFC0A04 40C00633			sub		$s9,$x0,$s9			; exp = -exp
FFFC0A08 00000863			bra		.0022
                        	.0021:
FFFC0A0C 02B06D13			ldi		$t0,#'+'
FFFC0A10 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0A14 001E0E13			add		$t2,$t2,#1
                        	.0022:
                        	;	// now process the exponent
                        	;    digit = 0;
                        	;    while (exp >= 1000) {
                        	;        exp -= 1000;
                        	;        digit++;
                        	;    }
FFFC0A18 00006393			ldi		$s4,#0
FFFC0A1C 3E806D13			ldi		$t0,#1000
                        	.0025:
FFFC0A20 01A65463			bge		$s9,$t0,.0023
FFFC0A24 00000863			bra		.0024
                        	.0023:
FFFC0A28 41A60633			sub		$s9,$s9,$t0
FFFC0A2C 00138393			add		$s4,$s4,#1
FFFC0A30 FE0008E3			bra		.0025
                        	.0024:
                        	;	d1 = digit;
                        	;	if (digit) {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0A34 0003E4B3			mov		$s6,$s4					; s6 = d1 = s4 = digit
FFFC0A38 00039863			bne		$s4,$x0,.0026
FFFC0A3C 03038D13			add		$t0,$s4,#'0'
FFFC0A40 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0A44 001E0E13			add		$t2,$t2,#1
                        	.0026:
                        	;	digit = 0;
                        	;    while (exp >= 100) {
                        	;        exp -= 100;
                        	;        digit++;
                        	;    }
FFFC0A48 00006393			ldi		$s4,#0
FFFC0A4C 06406D13			ldi		$t0,#100
                        	.0027:
FFFC0A50 01A65463			bge		$s9,$t0,.0028
FFFC0A54 00000863			bra		.0029
                        	.0028:
FFFC0A58 41A60633			sub		$s9,$s9,$t0
FFFC0A5C 00138393			add		$s4,$s4,#1
FFFC0A60 FE0008E3			bra		.0027
                        	.0029:	
                        	;	d2 = digit;
                        	;	if (digit==0 && d1==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0A64 0003E533			mov		$s7,$s4				; $s7 = d2
FFFC0A68 00049463			bne		$s6,$x0,.0030
FFFC0A6C 00038863			beq		$s4,$x0,.0031
                        	.0030:
FFFC0A70 03038D13			add		$t0,$s4,#'0'
FFFC0A74 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0A78 001E0E13			add		$t2,$t2,#1
                        	.0031:
                        	;	digit = 0;
                        	;    while (exp >= 10) {
                        	;        exp -= 10;
                        	;        digit++;
                        	;    }
FFFC0A7C 00006393			ldi		$s4,#0
FFFC0A80 00A06D13			ldi		$t0,#10
                        	.0032:
FFFC0A84 01A65463			bge		$s9,$t0,.0034
FFFC0A88 00000863			bra		.0035
                        	.0034:
FFFC0A8C 41A60633			sub		$s9,$s9,$t0
FFFC0A90 00138393			add		$s4,$s4,#1
FFFC0A94 FE0008E3			bra		.0032
                        	.0035:	
                        	;	d3 = digit;
                        	;	if (digit==0 && d1==0 && d2==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0A98 0003E5B3			mov		$s8,$s4
FFFC0A9C 00039663			bne		$s4,$x0,.0036
FFFC0AA0 00049463			bne		$s6,$x0,.0036
FFFC0AA4 00050863			beq		$s7,$x0,.0037
                        	.0036:
FFFC0AA8 03038D13			add		$t0,$s4,#'0'
FFFC0AAC 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0AB0 001E0E13			add		$t2,$t2,#1
                        	.0037:
                        	;	digit = 0;
                        	;    while (exp >= 1) {
                        	;        exp -= 1;
                        	;        digit++;
                        	;    }
FFFC0AB4 00006393			ldi		$s4,#0
FFFC0AB8 00106D13			ldi		$t0,#1
                        	.0038:
FFFC0ABC 01A65463			bge		$s9,$t0,.0040
FFFC0AC0 00000863			bra		.0039
                        	.0040:
FFFC0AC4 41A60633			sub		$s9,$s9,$t0
FFFC0AC8 00138393			add		$s4,$s4,#1
FFFC0ACC FE0008E3			bra		.0038
                        	.0039:	
                        	;    buf[ndx] = digit + '0';
                        	;    ndx++;
                        	;    buf[ndx] = '\0';
FFFC0AD0 03038D13			add		$t0,$s4,#'0'
FFFC0AD4 21AE0023			sb		$t0,STRTMP[$t2]
FFFC0AD8 001E0E13			add		$t2,$t2,#1
FFFC0ADC 200E0023			sb		$x0,STRTMP[$t2]
                        	;	// Now pad the number on the left or right as requested.
                        	.prt:
                        	;    // pad left
                        	;    if (width > 0) {
                        	;        if (ndx < width) {
                        	;            for (nn = 39; nn >= width-ndx; nn--)
                        	;                buf[nn] = buf[nn-(width-ndx)];
                        	;            for (; nn >= 0; nn--)
                        	;                buf[nn] = ' ';
                        	;        }
                        	;    }
FFFC0AE0 0409C663			blt		$a1,$x0,.0041
FFFC0AE4 04098463			beq		$a1,$x0,.0041
FFFC0AE8 013E4463			blt		$t2,$a1,.0042
FFFC0AEC 04000063			bra		.0041
                        	.0042:
FFFC0AF0 02706313			ldi		$s3,#39					; s3 = nn
FFFC0AF4 41C98D33			sub		$t0,$a1,$t2			; width-ndx
                        	.0045:
FFFC0AF8 01A35463			bge		$s3,$t0,.0043
FFFC0AFC 00000C63			bra		.0044
                        	.0043:
FFFC0B00 41A304B3			sub		$s6,$s3,$t0			; nn-(width-ndx)
FFFC0B04 20030D83			ldb		$t1,STRTMP[$s3]
FFFC0B08 21B48023			stb		$t1,STRTMP[$s6]
FFFC0B0C FFF30313			sub		$s3,$s3,#1
FFFC0B10 FE0004E3			bra		.0045
                        	.0044:
FFFC0B14 02006D13			ldi		$t0,#' '
                        	.0048:
FFFC0B18 00035463			bge		$s3,$x0,.0046
FFFC0B1C 00000863			bra		.0047
                        	.0046:
FFFC0B20 21A30023			stb		$t0,STRTMP[$s3]
FFFC0B24 FFF30313			sub		$s3,$s3,#1
FFFC0B28 FE0008E3			bra		.0048
                        	.0047:
                        	.0041:
                        	;    // pad right
                        	;    if (width < 0) {
                        	;        width = -width;
                        	;        while (ndx < width) {
                        	;            buf[ndx]=' ';
                        	;            ndx++;
                        	;        }
                        	;        buf[ndx]='\0';
                        	;    }
                        	;    return (ndx);
FFFC0B2C 0209D063			bge		$a1,$x0,.0050
FFFC0B30 413009B3			sub		$a1,$x0,$a1
FFFC0B34 02006D13			ldi		$t0,#' '
                        	.0052:
FFFC0B38 013E5863			bge		$t2,$a1,.0051
FFFC0B3C 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0B40 001E0E13			add		$t2,$t2,#1
FFFC0B44 FE000AE3			bra		.0052
                        	.0051:
FFFC0B48 200E0023			stb		$x0,STRTMP[$t2]
                        	.0050:
FFFC0B4C 000E6833			mov		$v0,$t2
FFFC0B50 00008067			ret
                        	
                        			align	4                        	
                        	msgInf:
FFFC0B54 00666E49			db	"Inf",0
                        	msgNan:
FFFC0B58 006E614E			db	"Nan",0
                        	fltOne:
FFFC0B5C 3F800000			dw		$3F800000					; 1.0
                        	fltTen:
FFFC0B60 41200000			dw		$41200000					; 10.0
                        	fltMillion:
FFFC0B64 49742400			dw		$49742400					; 1,000,000
                        	
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "cs01Mem.asm",1
                        	.file "cs01Mem.asm",1
                        	; PAM is a bitmask of allocated pages. There are 256 pages (256 bits)
                        	; 8 words storage required.
                        	;
                        	PAM			equ		$300
                        	
                        	.file "cs01Mem.asm",7
                        			code	18 bits
                        			align	4                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	MMUInit:
FFFC0B68 00001E37			ldi		$t2,#4096				; number of registers to update
FFFC0B6C 000E0E13
FFFC0B70 00006D13			ldi		$t0,#$00
FFFC0B74 00006D93			ldi		$t1,#$000				; regno
                        	.0001:
FFFC0B78 03BD000D			mvmap	$x0,$t0,$t1
FFFC0B7C 001D0D13			add		$t0,$t0,#$01		; increment page numbers
FFFC0B80 001D8D93			add		$t1,$t1,#$01
FFFC0B84 FFFE0E13			sub		$t2,$t2,#1
FFFC0B88 FE0E18E3			bne		$t2,$x0,.0001
                        			; Now setup segment registers
FFFC0B8C 00006D13			ldi		$t0,#$0
FFFC0B90 00706D93			ldi		$t1,#$07				; t1 = value to load RWX=111, base = 0
                        	.0002:
FFFC0B94 01AD800D			mvseg	$x0,$t1,$t0			; move to the segment register identifed by t0
FFFC0B98 001D0D13			add		$t0,$t0,#1			; pick next segment register
FFFC0B9C 010D2E13			slt		$t2,$t0,#16			; 16 segment regs
FFFC0BA0 FE0E1AE3			bne		$t2,$x0,.0002
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	InitPAM:
FFFC0BA4 00106D13			ldi		$t0,#1			; permanently allocate first page
FFFC0BA8 31A02023			sw		$t0,PAM
FFFC0BAC 30002223			sw		$x0,PAM+4
FFFC0BB0 30002423			sw		$x0,PAM+8
FFFC0BB4 30002623			sw		$x0,PAM+12
FFFC0BB8 30002823			sw		$x0,PAM+16
FFFC0BBC 30002A23			sw		$x0,PAM+20
FFFC0BC0 30002C23			sw		$x0,PAM+24
FFFC0BC4 30002E23			sw		$x0,PAM+28
FFFC0BC8 00008067			ret
                        	
                        	; There's only eight words to check so an unrolled loop works here.
                        	;
                        	AllocPage:
FFFC0BCC FFC70713		sub		$sp,$sp,#4
FFFC0BD0 00172023		sw		$ra,[$sp]
FFFC0BD4 30002D03		lw		$t0,PAM
FFFC0BD8 00000DB7		ldi		$t1,#$FFFFFFFF
FFFC0BDC FFFD8D93
FFFC0BE0 01BD0863		beq		$t0,$t1,.chkPam4
FFFC0BE4 0C4000EF		call	BitIndex
FFFC0BE8 31202023		sw		$a0,PAM
FFFC0BEC 0A000863		bra		.0001
                        	.chkPam4:
FFFC0BF0 30402D03		lw		$t0,PAM+4
FFFC0BF4 01BD0A63		beq		$t0,$t1,.chkPam8
FFFC0BF8 0B0000EF		call	BitIndex
FFFC0BFC 31202223		sw		$a0,PAM+4
FFFC0C00 00880813		add		$v0,$v0,#8
FFFC0C04 08000C63		bra		.0001
                        	.chkPam8:
FFFC0C08 30802D03		lw		$t0,PAM+8
FFFC0C0C 01BD0A63		beq		$t0,$t1,.chkPam12
FFFC0C10 098000EF		call	BitIndex
FFFC0C14 31202423		sw		$a0,PAM+8
FFFC0C18 01080813		add		$v0,$v0,#16
FFFC0C1C 08000063		bra		.0001
                        	.chkPam12:
FFFC0C20 30C02D03		lw		$t0,PAM+12
FFFC0C24 01BD0A63		beq		$t0,$t1,.chkPam16
FFFC0C28 080000EF		call	BitIndex
FFFC0C2C 31202623		sw		$a0,PAM+12
FFFC0C30 01880813		add		$v0,$v0,#24
FFFC0C34 06000463		bra		.0001
                        	.chkPam16:
FFFC0C38 31002D03		lw		$t0,PAM+16
FFFC0C3C 01BD0A63		beq		$t0,$t1,.chkPam20
FFFC0C40 068000EF		call	BitIndex
FFFC0C44 31202823		sw		$a0,PAM+16
FFFC0C48 02080813		add		$v0,$v0,#32
FFFC0C4C 04000863		bra		.0001
                        	.chkPam20:
FFFC0C50 31402D03		lw		$t0,PAM+20
FFFC0C54 01BD0A63		beq		$t0,$t1,.chkPam24
FFFC0C58 050000EF		call	BitIndex
FFFC0C5C 31202A23		sw		$a0,PAM+20
FFFC0C60 02880813		add		$v0,$v0,#40
FFFC0C64 02000C63		bra		.0001
                        	.chkPam24:
FFFC0C68 31802D03		lw		$t0,PAM+24
FFFC0C6C 01BD0A63		beq		$t0,$t1,.chkPam28
FFFC0C70 038000EF		call	BitIndex
FFFC0C74 31202C23		sw		$a0,PAM+24
FFFC0C78 03080813		add		$v0,$v0,#48
FFFC0C7C 02000063		bra		.0001
                        	.chkPam28:
FFFC0C80 31C02D03		lw		$t0,PAM+28
FFFC0C84 01BD0A63		beq		$t0,$t1,.chkPamDone
FFFC0C88 020000EF		call	BitIndex
FFFC0C8C 31202E23		sw		$a0,PAM+28
FFFC0C90 03880813		add		$v0,$v0,#56
FFFC0C94 00000463		bra		.0001
                        	.chkPamDone:
FFFC0C98 00006813		ldi		$v0,#0						; no memory available
                        	.0001:
FFFC0C9C 00072083		lw		$ra,[$sp]
FFFC0CA0 00470713		add		$sp,$sp,#4
FFFC0CA4 00008067		ret
                        	
                        	; Returns:
                        	;		v0 = bit index of allocated page
                        	;
                        	BitIndex:
FFFC0CA8 00006813		ldi		$v0,#0
                        	.0001:
FFFC0CAC 00197E13		and		$t2,$a0,#1
FFFC0CB0 000E0C63		beq		$t2,$x0,.foundFree
FFFC0CB4 00195913		srl		$a0,$a0,#1
FFFC0CB8 80000637		or		$a0,$a0,#$80000000	; do a rotate, we know bit = 1
FFFC0CBC 01266933
FFFC0CC0 00180813		add		$v0,$v0,#1
FFFC0CC4 FE0004E3		bra		.0001
                        	.foundFree:
FFFC0CC8 00196913		or		$a0,$a0,#1					; mark page allocated
FFFC0CCC 00086DB3		mov		$t1,$v0
FFFC0CD0 000D8A63		beq		$t1,$x0,.0003
                        	.0004:
FFFC0CD4 00191913		sll		$a0,$a0,#1					; do a rotate
FFFC0CD8 00196913		or		$a0,$a0,#1					; we know bit = 1
FFFC0CDC FFFD8D93		sub		$t1,$t1,#1
FFFC0CE0 FE0D9AE3		bne		$t1,$x0,.0004
                        	.0003:
FFFC0CE4 00008067		ret
                        	
                        	FindRun:
FFFC0CE8 00006D93		ldi			$t1,#0						; t1 = count of consecutive empty buckets
FFFC0CEC 8C001D73		csrrw		$t0,#$8C0,$x0
FFFC0CF0 0FFD7813		and			$v0,$t0,#$FF
FFFC0CF4 00080263		beq			$v0,$x0,.empty0
                        	.empty0:
                        	
                        	
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "TinyBasic.asm",1
                        	.file "TinyBasic.asm",1
                        	;****************************************************************;
                        	;                                                                ;
                        	;		Tiny BASIC for the CS01                                      ;
                        	;                                                                ;
                        	; Derived from a 68000 derivative of Palo Alto Tiny BASIC as     ;
                        	; published in the May 1976 issue of Dr. Dobb's Journal.         ;
                        	; Adapted to the 68000 by:                                       ;
                        	;	Gordon brndly						                         ;
                        	;	12147 - 51 Street					                         ;
                        	;	Edmonton AB  T5W 3G8					                     ;
                        	;	Canada							                             ;
                        	;	(updated mailing address for 1996)			                 ;
                        	;                                                                ;
                        	; Adapted to the CS01 by:                                        ;
                        	;    Robert Finch                                                ;
                        	;    Ontario, Canada                                             ;
                        	;	 robfinch<remove>@finitron.ca    	                             ;  
                        	;****************************************************************;
                        	;  Copyright (C) 2016-2020 by Robert Finch. This program may be	 ;
                        	;    freely distributed for personal use only. All commercial	 ;
                        	;		       rights are reserved.			                     ;
                        	;****************************************************************;
                        	;
                        	; Register Usage
                        	; $t2 = text pointer (global usage)
                        	; r3,r4 = inputs parameters to subroutines
                        	; a1 = return value
                        	;
                        	;* Vers. 1.0  1984/7/17	- Original version by Gordon brndly
                        	;*	1.1  1984/12/9	- Addition of '0x' print term by Marvin Lipford
                        	;*	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                        	
                        	CR		EQU	0x0D		;ASCII equates
                        	LINEFD	EQU	0x0A		; Don't use LF (same as load float instruction)
                        	TAB		EQU	0x09
                        	CTRLC	EQU	0x03
                        	CTRLH	EQU	0x08
                        	CTRLI	EQU	0x09
                        	CTRLJ	EQU	0x0A
                        	CTRLK	EQU	0x0B
                        	CTRLM   EQU 0x0D
                        	CTRLS	EQU	0x13
                        	CTRLX	EQU	0x18
                        	XON		EQU	0x11
                        	XOFF	EQU	0x13
                        	
                        	FILENAME	EQU		0x6C0
                        	FILEBUF		EQU		0x07F600
                        	OSSP		EQU		0x700
                        	TXTUNF		EQU		OSSP+4
                        	VARBGN		EQU		TXTUNF+4
                        	LOPVAR		EQU		VARBGN+4
                        	STKGOS		EQU		LOPVAR+4
                        	CURRNT		EQU		STKGOS+4
                        	BUFFER		EQU		CURRNT+4
                        	BUFLEN		EQU		84
                        	LOPPT		EQU		BUFFER+84
                        	LOPLN		EQU		LOPPT+4
                        	LOPINC		EQU		LOPLN+4
                        	LOPLMT		EQU		LOPINC+4
                        	NUMWKA		EQU		LOPLMT+4
                        	STKINP		EQU		NUMWKA+4
                        	STKBOT		EQU		STKINP+4
                        	usrJmp		EQU		STKBOT+4
                        	IRQROUT		EQU		usrJmp+4
                        	
                        	OUTPTR		EQU		IRQROUT+4
                        	INPPTR		EQU		OUTPTR+4
                        	CursorFlash	EQU		INPPTR+4
                        	IRQFlag		EQU		CursorFlash+4
                        	
                        	;
                        	; Modifiable system constants:
                        	;
                        	;THRD_AREA	dw	0x04000000	; threading switch area 0x04000000-0x40FFFFF
                        	;bitmap dw	0x00100000	; bitmap graphics memory 0x04100000-0x417FFFF
                        	TXTBGN		EQU		0x01800			;TXT ;beginning of program memory
                        	ENDMEM		EQU		0x080000	; end of available memory
                        	STACKOFFS	EQU		0x07FEFC	; stack offset - leave a little room for the BIOS stacks
                        	
                        	
                        	.file "TinyBasic.asm",83
                        			code
FFFC0CF8 00000000			align	409
FFFC0CFC 00000000
FFFC0D00 00000000
FFFC0D04 00000000
FFFC0D08 00000000
FFFC0D0C 00000000
FFFC0D10 00000000
FFFC0D14 00000000
FFFC0D18 00000000
FFFC0D1C 00000000
FFFC0D20 00000000
FFFC0D24 00000000
FFFC0D28 00000000
FFFC0D2C 00000000
FFFC0D30 00000000
FFFC0D34 00000000
FFFC0D38 00000000
FFFC0D3C 00000000
FFFC0D40 00000000
FFFC0D44 00000000
FFFC0D48 00000000
FFFC0D4C 00000000
FFFC0D50 00000000
FFFC0D54 00000000
FFFC0D58 00000000
FFFC0D5C 00000000
FFFC0D60 00000000
FFFC0D64 00000000
FFFC0D68 00000000
FFFC0D6C 00000000
FFFC0D70 00000000
FFFC0D74 00000000
FFFC0D78 00000000
FFFC0D7C 00000000
FFFC0D80 00000000
FFFC0D84 00000000
FFFC0D88 00000000
FFFC0D8C 00000000
FFFC0D90 00000000
FFFC0D94 00000000
FFFC0D98 00000000
FFFC0D9C 00000000
FFFC0DA0 00000000
FFFC0DA4 00000000
FFFC0DA8 00000000
FFFC0DAC 00000000
FFFC0DB0 00000000
FFFC0DB4 00000000
FFFC0DB8 00000000
FFFC0DBC 00000000
FFFC0DC0 00000000
FFFC0DC4 00000000
FFFC0DC8 00000000
FFFC0DCC 00000000
FFFC0DD0 00000000
FFFC0DD4 00000000
FFFC0DD8 00000000
FFFC0DDC 00000000
FFFC0DE0 00000000
FFFC0DE4 00000000
FFFC0DE8 00000000
FFFC0DEC 00000000
FFFC0DF0 00000000
FFFC0DF4 00000000
FFFC0DF8 00000000
FFFC0DFC 00000000
FFFC0E00 00000000
FFFC0E04 00000000
FFFC0E08 00000000
FFFC0E0C 00000000
FFFC0E10 00000000
FFFC0E14 00000000
FFFC0E18 00000000
FFFC0E1C 00000000
FFFC0E20 00000000
FFFC0E24 00000000
FFFC0E28 00000000
FFFC0E2C 00000000
FFFC0E30 00000000
FFFC0E34 00000000
FFFC0E38 00000000
FFFC0E3C 00000000
FFFC0E40 00000000
FFFC0E44 00000000
FFFC0E48 00000000
FFFC0E4C 00000000
FFFC0E50 00000000
FFFC0E54 00000000
FFFC0E58 00000000
FFFC0E5C 00000000
FFFC0E60 00000000
FFFC0E64 00000000
FFFC0E68 00000000
FFFC0E6C 00000000
FFFC0E70 00000000
FFFC0E74 00000000
FFFC0E78 00000000
FFFC0E7C 00000000
FFFC0E80 00000000
FFFC0E84 00000000
FFFC0E88 00000000
FFFC0E8C 00000000
FFFC0E90 00000000
FFFC0E94 00000000
FFFC0E98 00000000
FFFC0E9C 00000000
FFFC0EA0 00000000
FFFC0EA4 00000000
FFFC0EA8 00000000
FFFC0EAC 00000000
FFFC0EB0 00000000
FFFC0EB4 00000000
FFFC0EB8 00000000
FFFC0EBC 00000000
FFFC0EC0 00000000
FFFC0EC4 00000000
FFFC0EC8 00000000
FFFC0ECC 00000000
FFFC0ED0 00000000
FFFC0ED4 00000000
FFFC0ED8 00000000
FFFC0EDC 00000000
FFFC0EE0 00000000
FFFC0EE4 00000000
FFFC0EE8 00000000
FFFC0EEC 00000000
FFFC0EF0 00000000
FFFC0EF4 00000000
FFFC0EF8 00000000
FFFC0EFC 00000000
FFFC0F00 00000000
FFFC0F04 00000000
FFFC0F08 00000000
FFFC0F0C 00000000
FFFC0F10 00000000
FFFC0F14 00000000
FFFC0F18 00000000
FFFC0F1C 00000000
FFFC0F20 00000000
FFFC0F24 00000000
FFFC0F28 00000000
FFFC0F2C 00000000
FFFC0F30 00000000
FFFC0F34 00000000
FFFC0F38 00000000
FFFC0F3C 00000000
FFFC0F40 00000000
FFFC0F44 00000000
FFFC0F48 00000000
FFFC0F4C 00000000
FFFC0F50 00000000
FFFC0F54 00000000
FFFC0F58 00000000
FFFC0F5C 00000000
FFFC0F60 00000000
FFFC0F64 00000000
FFFC0F68 00000000
FFFC0F6C 00000000
FFFC0F70 00000000
FFFC0F74 00000000
FFFC0F78 00000000
FFFC0F7C 00000000
FFFC0F80 00000000
FFFC0F84 00000000
FFFC0F88 00000000
FFFC0F8C 00000000
FFFC0F90 00000000
FFFC0F94 00000000
FFFC0F98 00000000
FFFC0F9C 00000000
FFFC0FA0 00000000
FFFC0FA4 00000000
FFFC0FA8 00000000
FFFC0FAC 00000000
FFFC0FB0 00000000
FFFC0FB4 00000000
FFFC0FB8 00000000
FFFC0FBC 00000000
FFFC0FC0 00000000
FFFC0FC4 00000000
FFFC0FC8 00000000
FFFC0FCC 00000000
FFFC0FD0 00000000
FFFC0FD4 00000000
FFFC0FD8 00000000
FFFC0FDC 00000000
FFFC0FE0 00000000
FFFC0FE4 00000000
FFFC0FE8 00000000
FFFC0FEC 00000000
FFFC0FF0 00000000
FFFC0FF4 00000000
FFFC0FF8 00000000
FFFC0FFC 00000000
                        	
                        	;
                        	; Standard jump table. You can change these addresses if you are
                        	; customizing this interpreter for a different environment.
                        	;
                        	TinyBasic:
                        	GOSTART:	
FFFC1000 0300006F			jmp	CSTART	;	Cold Start entry point
                        	GOWARM:	
FFFC1004 0C00006F			jmp	WSTART	;	Warm Start entry point
                        	GOOUT:	
FFFC1008 3350106F			jmp	OUTC	;	Jump to character-out routine
                        	GOIN:	
FFFC100C 3350106F			jmp	INCH	;Jump to character-in routine
                        	GOAUXO:	
FFFC1010 00000637			jmp	AUXOUT	;	Jump to auxiliary-out routine
FFFC1014 0F060067
                        	GOAUXI:	
FFFC1018 00000637			jmp	AUXIN	;	Jump to auxiliary-in routine
FFFC101C 0F260067
                        	GOBYE:	
FFFC1020 00000637			jmp	BYEBYE	;	Jump to monitor, DOS, etc.
FFFC1024 0F460067
                        	
FFFC1028 00000000		align	1
FFFC102C 00000000
                        	
                        	//message "CSTART"
                        	public CSTART:
	; First save off the link register and OS sp value
FFFC1030 70E02023		sw		$sp,OSSP
FFFC1034 00080737		ldi		$sp,#STACKOFFS	; initialize stack pointer
FFFC1038 EFC70713
                        	//	call	_RequestIOFocus
                        	;	call	_DBGHomeCursor[pc]
FFFC103C 00006933		mov		a0,r0			; turn off keyboard echoing
                        	//	call	SetKeyboardEcho
                        	//	stz		CursorFlash
                        	//	ldx		#0x10000020	; black chars, yellow background
                        	;	stx		charToPrint
                        	;	call	_DBGClearScreen[pc]
FFFC1040 FFFC3937		ldi		a0,#msgInit	;	tell who we are
FFFC1044 B7090913
FFFC1048 2D9010EF		call	PRMESG
FFFC104C 00002937		ldi		a0,#TXTBGN	;	init. end-of-program pointer
FFFC1050 80090913
FFFC1054 71202223		sw		a0,TXTUNF
FFFC1058 00080937		ldi		a0,#ENDMEM	;	get address of end of memory
FFFC105C 00090913
FFFC1060 FFFFE637		sub		a0,a0,#8192	; 	reserve 4K for the stack
FFFC1064 41260933
FFFC1068 79202223		sw		a0,STKBOT
FFFC106C FFFF8637		sub		a0,a0,#32768 ;   1000 vars
FFFC1070 41260933
FFFC1074 71202423		sw     a0,VARBGN
FFFC1078 70402903		lw			$a0,TXTUNF
FFFC107C C54FF0EF		call		PutHexWord
FFFC1080 02006913		ldi			$a0,#' '
FFFC1084 F85FF0EF		call		GOOUT
FFFC1088 70802903		lw			$a0,VARBGN
FFFC108C C44FF0EF		call		PutHexWord
FFFC1090 3CC000EF		call    clearVars   ; clear the variable area
FFFC1094 02006913		ldi			$a0,#' '
FFFC1098 F71FF0EF		call		GOOUT
FFFC109C 78002623		sw		r0,IRQROUT
FFFC10A0 70802903		lw     a0,VARBGN   ; calculate number of bytes free
FFFC10A4 70402983		lw		a1,TXTUNF
FFFC10A8 41390933		sub     a0,a0,a1
FFFC10AC C24FF0EF		call	PutHexWord
FFFC10B0 00C06993		ldi		a1,#12		; max 12 digits
FFFC10B4 734010EF		call  	PRTNUM
FFFC10B8 FFFC3937		ldi		a0,#msgBytesFree
FFFC10BC C1990913
FFFC10C0 261010EF		call	PRMESG
                        	WSTART:
FFFC10C4 70002623		sw		x0,LOPVAR   ; initialize internal variables
FFFC10C8 70002823		sw		x0,STKGOS
FFFC10CC 70002A23		sw		x0,CURRNT	;	current line number pointer = 0
FFFC10D0 00080737		ldi		$sp,#STACKOFFS	;	init S.P. again, just in case
FFFC10D4 EFC70713
FFFC10D8 FFFC3937		ldi		a0,#msgReady	;	display "Ready"
FFFC10DC C2790913
FFFC10E0 241010EF		call	PRMESG
                        	ST3:
FFFC10E4 03E06913		ldi		a0,#'>'		; Prompt with a '>' and
FFFC10E8 3F8010EF		call	GETLN		; read a line.
FFFC10EC 185010EF		call	TOUPBUF 	; convert to upper case
FFFC10F0 000E64B3		mov		$s6,$t2		; save pointer to end of line
FFFC10F4 71806E13		ldi		$t2,#BUFFER	; point to the beginning of line
FFFC10F8 0D5010EF		call	TSTNUM		; is there a number there?
FFFC10FC 145010EF		call	IGNBLK		; skip trailing blanks
                        	; does line no. exist? (or nonzero?)
FFFC1100 20088063		beq		v1,x0,DIRECT		; if not, it's a direct statement
FFFC1104 00100DB7		ldi		$t1,#$FFFFF
FFFC1108 FFFD8D93
FFFC110C 010DD863		ble		v0,$t1,ST2	; see if line no. is <= 16 bits
FFFC1110 FFFC3937		ldi		a0,#msgLineRange	; if not, we've overflowed
FFFC1114 C4590913
FFFC1118 3840106F		jmp		ERROR
                        	ST2:
                        	  ; ugliness - store a character at potentially an
                        	  ; odd address (unaligned).
FFFC111C 00086933	  mov		$a0,$v0		; a1 = line number
FFFC1120 FFCE0E13		sub		$t2,$t2,#4
FFFC1124 012E2023	  sw		$a0,[$t2]		;
FFFC1128 4AC010EF		call	FNDLN		; find this line in save area
FFFC112C 000EE533		mov		$s7,$t3		; save possible line pointer
FFFC1130 06080863		beq		$v0,$x0,ST4	; if not found, insert
                        		; here we found the line, so we're replacing the line
                        		; in the text area
                        		; first step - delete the line
FFFC1134 00006933		mov		a0,x0
FFFC1138 4E8010EF		call	FNDNXT		; find the next line (into t3)
FFFC113C 00091863		bne		a0,x0,ST7
FFFC1140 70402D83		lw		$t1,TXTUNF
FFFC1144 05BEFA63		bgeu	$t3,$t1,ST6
FFFC1148 040E8863		beq		$t3,r0,ST6
                        	ST7:
FFFC114C 000EE933		mov		a0,$t3		; a0 = pointer to next line
FFFC1150 000569B3		mov		a1,$s7		; pointer to line to be deleted
FFFC1154 70402183		lw		r3,TXTUNF		; points to top of save area
FFFC1158 41D18933		sub		a0,r3,$t3	; a0 = length to move TXTUNF-pointer to next line
                        	;	dea					; count is one less
FFFC115C 000EE9B3		mov		a1,$t3		; a1 = pointer to next line
FFFC1160 000561B3		mov		r3,$s7		; r3 = pointer to line to delete
FFFC1164 FFC70713		sub		$sp,$sp,#4
FFFC1168 00472023		sw		r4,[$sp]
                        	
                        	ST8:
FFFC116C 000E0203		lb		r4,[$t2]
FFFC1170 00418023		sb		r4,[r3]
FFFC1174 001E0E13		add		$t2,$t2,#1
FFFC1178 00118193		add		r3,r3,#1
FFFC117C FFF90913		sub		a0,a0,#1
FFFC1180 FE0916E3		bne		a0,r0,ST8
                        	
FFFC1184 00072203		lw		r4,[$sp]
FFFC1188 00470713		add		$sp,$sp,#4
FFFC118C 70302223		sw		r3,TXTUNF		; update the end pointer
                        		; we moved the lines of text after the line being
                        		; deleted down, so the pointer to the next line
                        		; needs to be reset
FFFC1190 00056EB3		mov		$t3,$s7
FFFC1194 00000663		bra		ST4
                        		; here there were no more lines, so just move the
                        		; end of text pointer down
                        	ST6:
FFFC1198 70A02223		sw		$s7,TXTUNF
FFFC119C 00056EB3		mov		$t3,$s7
                        	ST4:
                        		; here we're inserting because the line wasn't found
                        		; or it was deleted	from the text area
FFFC11A0 41C48933		sub		$a0,$s6,$t2		; calculate the length of new line
FFFC11A4 B2CFF0EF		call	PutHexWord
FFFC11A8 00706D93		ldi		$t1,#7
FFFC11AC F32DFCE3		bleu	$a0,$t1,ST3		; is it just a line no. & CR? if so, it was just a delete
                        	
                        		; compute new end of text
FFFC11B0 70402F03		lw		$t4,TXTUNF		; r10 = old TXTUNF
FFFC11B4 012F0FB3		add		$t5,$t4,a0		; r11 = new top of TXTUNF (r1=line length)
                        	
FFFC11B8 70802D83		lw		$t1,VARBGN
FFFC11BC 01FDF863		bleu	$t5,$t1,ST5		; see if there's enough room
FFFC11C0 FFFC3937		ldi		a0,#msgTooBig	; if not, say so
FFFC11C4 D2090913
FFFC11C8 2D40106F		jmp		ERROR
                        	
                        		; open a space in the text area
                        	ST5:
FFFC11CC 71F02223		sw		$t5,TXTUNF	; if so, store new end position
FFFC11D0 000F6933		mov		a0,$t4		; points to old end of text
FFFC11D4 000FE9B3		mov		a1,$t5		; points to new end of text
FFFC11D8 000EE1B3		mov		r3,$t3	    ; points to start of line after insert line
FFFC11DC 484010EF		call	MVDOWN		; move things out of the way
                        	
                        		; copy line into text space
FFFC11E0 000E6933		mov		a0,$t2		; set up to do the insertion; move from buffer
FFFC11E4 000569B3		mov		a1,$s7		; to vacated space
FFFC11E8 0004E1B3		mov		r3,$s6		; until end of buffer
FFFC11EC 45C010EF		call	MVUP		; do it
FFFC11F0 EF5FF06F		jmp		ST3			; go back and get another line
                        	
                        	;******************************************************************
                        	;
                        	; *** Tables *** DIRECT *** EXEC ***
                        	;
                        	; This section of the code tests a string against a table. When
                        	; a match is found, control is transferred to the section of
                        	; code according to the table.
                        	;
                        	; At 'EXEC', r8 should point to the string, r9 should point to
                        	; the character table, and r10 should point to the execution
                        	; table. At 'DIRECT', r8 should point to the string, r9 and
                        	; r10 will be set up to point to TAB1 and TAB1_1, which are
                        	; the tables of all direct and statement commands.
                        	;
                        	; A '.' in the string will terminate the test and the partial
                        	; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                        	; 'PRIN.', or 'PRINT' will all match 'PRINT'.
                        	;
                        	; There are two tables: the character table and the execution
                        	; table. The character table consists of any number of text items.
                        	; Each item is a string of characters with the last character's
                        	; high bit set to one. The execution table holds a 32-bit
                        	; execution addresses that correspond to each entry in the
                        	; character table.
                        	;
                        	; The end of the character table is a 0 byte which corresponds
                        	; to the default routine in the execution table, which is
                        	; executed if none of the other table items are matched.
                        	;
                        	; Character-matching tables:
                        	TAB1:
FFFC11F4 D453494C		db	"LIS",'T'+0x80        ; Direct commands
FFFC11F8 C4414F4C		db	"LOA",'D'+0x80
FFFC11FC 52D7454E		db	"NE",'W'+0x80
FFFC11FF 53CE5552		db	"RU",'N'+0x80
FFFC1202 C5564153		db	"SAV",'E'+0x80
                        	TAB2:
FFFC1206 D458454E		db	"NEX",'T'+0x80         ; Direct / statement
FFFC120A 49D4454C		db	"LE",'T'+0x80
FFFC120D 4F47C649		db	"I",'F'+0x80
FFFC120F CF544F47		db	"GOT",'O'+0x80
FFFC1213 55534F47		db	"GOSU",'B'+0x80
FFFC1217 544552C2
FFFC1218 55544552		db	"RETUR",'N'+0x80
FFFC121C 4552CE52
FFFC121E 46CD4552		db	"RE",'M'+0x80
FFFC1221 49D24F46		db	"FO",'R'+0x80
FFFC1224 55504E49		db	"INPU",'T'+0x80
FFFC1228 495250D4
FFFC1229 4E495250		db	"PRIN",'T'+0x80
FFFC122D 4B4F50D4
FFFC122E C54B4F50		db	"POK",'E'+0x80
FFFC1232 454B4F50		db	"POKE",'W'+0x80
FFFC1236 4B4F50D7
FFFC1237 454B4F50		db	"POKE",'H'+0x80
FFFC123B 4F5453C8
FFFC123C D04F5453		db	"STO",'P'+0x80
FFFC1240 53C55942		db	"BY",'E'+0x80
FFFC1243 43D35953		db	"SY",'S'+0x80
FFFC1246 43D34C43		db	"CL",'S'+0x80
FFFC1249 52D24C43	    db  "CL",'R'+0x80
FFFC124C C6434452	    db	"RDC",'F'+0x80
FFFC1250 52494E4F	    db	"ONIR",'Q'+0x80
FFFC1254 494157D1
FFFC1255 D4494157	    db	"WAI",'T'+0x80
FFFC1259 45455000		db	0
                        	TAB4:
FFFC125A CB454550		db	"PEE",'K'+0x80         ;Functions
FFFC125E 4B454550		db	"PEEK",'W'+0x80
FFFC1262 454550D7
FFFC1263 4B454550		db	"PEEK",'H'+0x80
FFFC1267 C44E52C8
FFFC1268 41C44E52		db	"RN",'D'+0x80
FFFC126B 53D34241		db	"AB",'S'+0x80
FFFC126E 54CE4753		db  "SG",'N'+0x80
FFFC1271 CB434954		db	"TIC",'K'+0x80
FFFC1275 C55A4953		db	"SIZ",'E'+0x80
FFFC1279 00D25355		db  "US",'R'+0x80
FFFC127C 00CF5400		db	0
                        	TAB5:
FFFC127D 5300CF54		db	"T",'O'+0x80           ;"TO" in "FOR"
FFFC127F 45545300		db	0
                        	TAB6:
FFFC1280 D0455453		db	"STE",'P'+0x80         ;"STEP" in "FOR"
FFFC1284 3CBD3E00		db	0
                        	TAB8:
FFFC1285 BE3CBD3E		db	'>','='+0x80           ;Relational operators
FFFC1287 BDBEBE3C		db	'<','>'+0x80
FFFC1289 BD3CBDBE		db	'>'+0x80
FFFC128A BCBD3CBD		db	'='+0x80
FFFC128B 00BCBD3C		db	'<','='+0x80
FFFC128D 4E4100BC		db	'<'+0x80
FFFC128E C44E4100		db	0
                        	TAB9:
FFFC128F 00C44E41	    db  "AN",'D'+0x80
FFFC1292 00D24F00	    db  0
                        	TAB10:
FFFC1293 C800D24F	    db  "O",'R'+0x80
FFFC1295 B414C800	    db  0
                        	
                        	;* Execution address tables:
                        	; We save some bytes by specifiying only the low order 16 bits of the address
                        	;
                        		align	2                        	
                        	TAB1_1:
FFFC1296 19B414C8		dh	LISTX			;Direct commands
FFFC1298 138419B4		dh	LOAD3
FFFC129A 13A01384		dh	NEW
FFFC129C 1A1813A0		dh	RUN
FFFC129E 16E81A18		dh	SAVE3
                        	TAB2_1:
FFFC12A0 186416E8		dh	NEXT		;	Direct / statement
FFFC12A2 00001864		dh	LET
FFFC12A4 14300000		dh	IF
FFFC12A6 15C81430		dh	GOTO
FFFC12A8 160C15C8		dh	GOSUB
FFFC12AA 1768160C		dh	RETURN
FFFC12AC 16501768		dh	IF2			; REM
FFFC12AE 17981650		dh	FOR
FFFC12B0 15181798		dh	INPUT
FFFC12B2 1B701518		dh	PRINT
FFFC12B4 1BA01B70		dh	POKE
FFFC12B6 1BD01BA0		dh	POKEW
FFFC12B8 13981BD0		dh	POKEH
FFFC12BA 10201398		dh	STOP
FFFC12BC 1C0C1020		dh	GOBYE
FFFC12BE 012B1C0C		dh	SYSX
FFFC12C0 1454012B		dh	_cls
FFFC12C2 012D1454		dh  _clr
FFFC12C4 1490012D		dh	_rdcf
FFFC12C6 14B81490		dh  ONIRQ
FFFC12C8 185814B8		dh	WAITIRQ
FFFC12CA 222C1858		dh	DEFLT
                        	TAB4_1:
FFFC12CC 224C222C		dh	PEEK			;Functions
FFFC12CE 226C224C		dh	PEEKW
FFFC12D0 22BC226C		dh	PEEKH
FFFC12D2 000022BC		dh	RND
FFFC12D4 23540000		dh	ABS
FFFC12D6 234C2354		dh  SGN
FFFC12D8 2394234C		dh	TICKX
FFFC12DA 228C2394		dh	SIZEX
FFFC12DC 2000228C		dh  USRX
FFFC12DE 16702000		dh	XP40
                        	TAB5_1
FFFC12E0 24941670		dh	FR1			;"TO" in "FOR"
FFFC12E2 168C2494		dh	QWHAT
                        	TAB6_1
FFFC12E4 1694168C		dh	FR2			;"STEP" in "FOR"
FFFC12E6 1D9C1694		dh	FR3
                        	TAB8_1
FFFC12E8 1DB41D9C		dh	XP11	;>=		Relational operators
FFFC12EA 1DCC1DB4		dh	XP12	;<>
FFFC12EC 1DFC1DCC		dh	XP13	;>
FFFC12EE 1DE41DFC		dh	XP15	;=
FFFC12F0 1E141DE4		dh	XP14	;<=
FFFC12F2 1E541E14		dh	XP16	;<
FFFC12F4 1CB01E54		dh	XP17
                        	TAB9_1
FFFC12F6 1CC41CB0	    dh  XP_AND
FFFC12F8 1C601CC4	    dh  XP_ANDX
                        	TAB10_1
FFFC12FA 1C741C60	    dh  XP_OR
FFFC12FC 00001C74	    dh  XP_ORX
                        	
                        	;*
                        	; r3 = match flag (trashed)
                        	; r9 = text table
                        	; r10 = exec table
                        	; r11 = trashed
FFFC12FE 1EB70000		align	1
                        	
                        	//message "DIRECT"
                        	DIRECT:
FFFC1300 FFFC1EB7		ldi		$t3,#TAB1
FFFC1304 1F4E8E93
FFFC1308 FFFC1F37		ldi		$t4,#TAB1_1
FFFC130C 296F0F13
                        	EXEC:
FFFC1310 730010EF		call	IGNBLK		; ignore leading blanks
FFFC1314 000E6FB3		mov		$t5,$t2		; save the pointer
FFFC1318 000061B3		mov		r3,r0		; clear match flag
                        	EXLP:
FFFC131C 000E4903		lbu		a0,[$t2]		; get the program character
FFFC1320 001E0E13		add		$t2,$t2,#1
FFFC1324 000EC983		lbu		a1,[$t3]		; get the table character
FFFC1328 00099663		bne		a1,r0,EXNGO		; If end of table,
FFFC132C 000FEE33		mov		$t2,$t5		;	restore the text pointer and...
FFFC1330 04000263		bra		EXGO		;   execute the default.
                        	EXNGO:
FFFC1334 04390063		beq		a0,r3,EXGO	; Else check for period... if so, execute
FFFC1338 07F9F993		and		a1,a1,#0x7f	; ignore the table's high bit
FFFC133C 03298263		beq		a1,a0,EXMAT	;		is there a match?
FFFC1340 002F0F13		add		$t4,$t4,#2	;if not, try the next entry
FFFC1344 000FEE33		mov		$t2,$t5		; reset the program pointer
FFFC1348 000061B3		mov		r3,r0		; sorry, no match
                        	EX1:
FFFC134C 000EC903		lbu		a0,[$t3]		; get to the end of the entry
FFFC1350 001E8E93		add		$t3,$t3,#1
FFFC1354 08097D93		and		$t1,$a0,#$80
FFFC1358 FE0D8AE3		beq		$t1,$r0,EX1	; test for bit 7 set
FFFC135C FC0000E3		bra		EXLP		; back for more matching
                        	EXMAT:
FFFC1360 02E06193		ldi		r3,#'.'		; we've got a match so far
FFFC1364 000EC903		lbu		a0,[$t3]		; end of table entry?
FFFC1368 001E8E93		add		$t3,$t3,#1
FFFC136C 08097D93		and		$t1,$a0,#$80
FFFC1370 FA0D86E3		beq		$t1,$r0,EXLP		; test for bit 7 set, if not, go back for more
                        	EXGO:
                        		; execute the appropriate routine
FFFC1374 000F5903		lhu		a0,[$t4]	; get the low mid order byte
FFFC1378 FFFC0637		or		a0,a0,#$FFFC0000	; add in ROM base
FFFC137C 01266933
FFFC1380 00090067		jmp		[a0]
                        	
                        	    
                        	;******************************************************************
                        	;
                        	; What follows is the code to execute direct and statement
                        	; commands. Control is transferred to these points via the command
                        	; table lookup code of 'DIRECT' and 'EXEC' in the last section.
                        	; After the command is executed, control is transferred to other
                        	; sections as follows:
                        	;
                        	; For 'LISTX', 'NEW', and 'STOP': go back to the warm start point.
                        	; For 'RUN': go execute the first stored line if any; else go
                        	; back to the warm start point.
                        	; For 'GOTO' and 'GOSUB': go execute the target line.
                        	; For 'RETURN' and 'NEXT'; go back to saved return line.
                        	; For all others: if 'CURRNT' is 0, go to warm start; else go
                        	; execute next command. (This is done in 'FINISH'.)
                        	;
                        	;******************************************************************
                        	;
                        	; *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                        	;
                        	; 'NEW<CR>' sets TXTUNF to point to TXTBGN
                        	;
                        	
                        	NEW:
FFFC1384 0C8010EF		call	ENDCHK
FFFC1388 00002937		ldi		a0,#TXTBGN
FFFC138C 80090913
FFFC1390 71202223		sw		a0,TXTUNF	;	set the end pointer
FFFC1394 0C8000EF		call    clearVars
                        	
                        	; 'STOP<CR>' goes back to WSTART
                        	;
                        	STOP:
FFFC1398 0B4010EF		call	ENDCHK
FFFC139C D29FF06F		jmp		WSTART		; WSTART will reset the stack
                        	
                        	; 'RUN<CR>' finds the first stored line, stores its address
                        	; in CURRNT, and starts executing it. Note that only those
                        	; commands in TAB2 are legal for a stored program.
                        	;
                        	; There are 3 more entries in 'RUN':
                        	; 'RUNNXL' finds next line, stores it's address and executes it.
                        	; 'RUNTSL' stores the address of this line and executes it.
                        	; 'RUNSML' continues the execution on same line.
                        	;
                        	RUN:
FFFC13A0 0AC010EF		call	ENDCHK
FFFC13A4 00002E37		ldi		$t2,#TXTBGN	;	set pointer to beginning
FFFC13A8 800E0E13
FFFC13AC 71C02A23		sw		$t2,CURRNT
FFFC13B0 0AC000EF		call  clearVars
                        	
                        	RUNNXL					; RUN <next line>
FFFC13B4 71402903		lw		a0,CURRNT	; executing a program?
FFFC13B8 D00906E3		beq		a0,r0,WSTART	; if not, we've finished a direct stat.
FFFC13BC 78C02903		lw		a0,IRQROUT		; are we handling IRQ's ?
FFFC13C0 02090E63		beq		a0,r0,RUN1
FFFC13C4 79C02D83		lw		$t1,IRQFlag		; was there an IRQ ?
FFFC13C8 020D8A63		beq		$t1,r0,RUN1
FFFC13CC 78002E23		sw		r0,IRQFlag
FFFC13D0 2D0010EF		call	PUSHA_		; the same code as a GOSUB
FFFC13D4 FF470713		sub		$sp,$sp,#12
FFFC13D8 71002903		lw		a0,STKGOS
FFFC13DC 01272023		sw		a0,[$sp]
FFFC13E0 71402903		lw		a0,CURRNT
FFFC13E4 01272223		sw		a0,4[$sp]
FFFC13E8 01C72423		sw		$t2,8[$sp]
FFFC13EC 70002623		sw		r0,LOPVAR		; load new values
FFFC13F0 70E02823		sw		$sp,STKGOS
FFFC13F4 78C02E83		lw		$t3,IRQROUT
FFFC13F8 00000C63		bra		RUNTSL
                        	RUN1:
FFFC13FC 00006933		mov		a0,r0	    ; else find the next line number
FFFC1400 000E6EB3		mov		$t3,$t2
FFFC1404 1F0010EF		call	FNDLNP		; search for the next line
                        	;	cmp		#0
                        	;	bne		RUNTSL
FFFC1408 70402D83		lw		$t1,TXTUNF	; if we've fallen off the end, stop
FFFC140C CBBEFCE3		bgeu	$t3,$t1,WSTART
                        	
                        	RUNTSL					; RUN <this line>
FFFC1410 71D02A23		sw		$t3,CURRNT	; set CURRNT to point to the line no.
FFFC1414 004E8E13		add		$t2,$t3,#4	; set the text pointer to
                        	
                        	RUNSML                 ; RUN <same line>
FFFC1418 6D8010EF		call	CHKIO		; see if a control-C was pressed
FFFC141C FFFC1EB7		ldi		$t3,#TAB2		; find command in TAB2
FFFC1420 206E8E93
FFFC1424 FFFC1F37		ldi		$t4,#TAB2_1
FFFC1428 2A0F0F13
FFFC142C EE5FF06F		jmp		EXEC		; and execute it
                        	
                        	
                        	; 'GOTO expr<CR>' evaluates the expression, finds the target
                        	; line, and jumps to 'RUNTSL' to do it.
                        	;
                        	GOTO:
FFFC1430 009000EF		call	OREXPR		;evaluate the following expression
                        	;	call	DisplayWord
FFFC1434 000962B3		mov     r5,a0
FFFC1438 014010EF		call 	ENDCHK		;must find end of line
FFFC143C 0002E933		mov     a0,r5
FFFC1440 194010EF		call 	FNDLN		; find the target line
FFFC1444 FC0916E3		bne		a0,r0,RUNTSL; go do it
FFFC1448 FFFC3937		ldi		a0,#msgBadGotoGosub
FFFC144C CEC90913
FFFC1450 04C0106F		jmp		ERROR		; no such line no.
                        	
                        	_clr:
FFFC1454 008000EF	    call    clearVars
FFFC1458 1680006F	    jmp     FINISH
                        	
                        	; Clear the variable area of memory
                        	clearVars:
FFFC145C FF870713		sub		$sp,$sp,#8
FFFC1460 00672023		sw		r6,[$sp]
FFFC1464 00172223		sw		$ra,4[$sp]
FFFC1468 40006313	  ldi   r6,#1024    ; number of words to clear
FFFC146C 70802903	  lw    a0,VARBGN
                        	.cv1:
FFFC1470 00092023	  sw		r0,[a0]
FFFC1474 00890913	  add		a0,a0,#8
FFFC1478 FFF30313	  sub		r6,r6,#1
FFFC147C FE031AE3		bne		r6,r0,.cv1
FFFC1480 00072303	  lw		r6,[$sp]
FFFC1484 00472083	  lw		$ra,4[$sp]
FFFC1488 00870713	  add		$sp,$sp,#8
FFFC148C 00008067	  ret
                        	
                        	;******************************************************************
                        	; ONIRQ <line number>
                        	; ONIRQ sets up an interrupt handler which acts like a specialized
                        	; subroutine call. ONIRQ is coded like a GOTO that never executes.
                        	;******************************************************************
                        	;
                        	ONIRQ:
FFFC1490 7A8000EF		call	OREXPR		;evaluate the following expression
FFFC1494 000962B3		mov     r5,a0
FFFC1498 7B5000EF		call 	ENDCHK		;must find end of line
FFFC149C 0002E933		mov     a0,r5
FFFC14A0 134010EF		call 	FNDLN		; find the target line
FFFC14A4 00091663		bne		a0,r0,ONIRQ1
FFFC14A8 78002623		sw		r0,IRQROUT
FFFC14AC 1140006F		jmp		FINISH
                        	ONIRQ1:
FFFC14B0 79D02623		sw		$t3,IRQROUT
FFFC14B4 10C0006F		jmp		FINISH
                        	
                        	WAITIRQ:
FFFC14B8 638010EF		call	CHKIO		; see if a control-C was pressed
FFFC14BC 79C02D83		lw		$t1,IRQFlag
FFFC14C0 FE0D8CE3		beq		$t1,r0,WAITIRQ
FFFC14C4 0FC0006F		jmp		FINISH
                        	
                        	
                        	;******************************************************************
                        	; LIST
                        	;
                        	; LISTX has two forms:
                        	; 'LIST<CR>' lists all saved lines
                        	; 'LIST #<CR>' starts listing at the line #
                        	; Control-S pauses the listing, control-C stops it.
                        	;******************************************************************
                        	;
                        	LISTX:
FFFC14C8 504010EF		call		TSTNUM		; see if there's a line no.
FFFC14CC 000862B3		mov      r5,v0
FFFC14D0 77D000EF		call		ENDCHK		; if not, we get a zero
FFFC14D4 0002E933		mov      a0,r5
FFFC14D8 0FC010EF		call		FNDLN		; find this or next line
                        	LS1:
FFFC14DC 00081663		bne		v0,r0,LS4
FFFC14E0 70402D83		lw		$t1,TXTUNF
FFFC14E4 BFBEF0E3		bgeu	$t3,$t1,WSTART	; warm start if we passed the end
                        	LS4:
FFFC14E8 000EE933		mov		a0,$t3
FFFC14EC 464010EF		call	PRTLN		; print the line
FFFC14F0 00096EB3		mov		$t3,a0		; set pointer for next
FFFC14F4 5FC010EF		call	CHKIO		; check for listing halt request
FFFC14F8 00080A63		beq		v0,r0,LS3
FFFC14FC 01306D93		ldi		$t1,#CTRLS
FFFC1500 01B81663		bne		v0,$t1,LS3; pause the listing?
                        	LS2:
FFFC1504 5EC010EF		call 	CHKIO		; if so, wait for another keypress
FFFC1508 FE080EE3		beq		v0,r0,LS2
                        	LS3:
FFFC150C 00006933		mov		a0,r0
FFFC1510 0E4010EF		call	FNDLNP		; find the next line
FFFC1514 FC0004E3		bra		LS1
                        	
                        	
                        	;******************************************************************
                        	; PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                        	; where '....' is a list of expressions, formats, back-arrows,
                        	; and strings.	These items a separated by commas.
                        	;
                        	; A format is a pound sign followed by a number.  It controls
                        	; the number of spaces the value of an expression is going to
                        	; be printed in.  It stays effective for the rest of the print
                        	; command unless changed by another format.  If no format is
                        	; specified, 11 positions will be used.
                        	;
                        	; A string is quoted in a pair of single- or double-quotes.
                        	;
                        	; An underline (back-arrow) means generate a <CR> without a <LF>
                        	;
                        	; A <CR LF> is generated after the entire list has been printed
                        	; or if the list is empty.  If the list ends with a semicolon,
                        	; however, no <CR LF> is generated.
                        	;******************************************************************
                        	;
                        	PRINT:
FFFC1518 00B06293		ldi		r5,#11		; D4 = number of print spaces
FFFC151C 03A06193		ldi		r3,#':'
FFFC1520 FFFC1237		ldi		r4,#PR2
FFFC1524 53420213
FFFC1528 46C010EF		call	TSTC		; if null list and ":"
FFFC152C 5EC010EF		call	CRLF		; give CR-LF and continue
FFFC1530 EE9FF06F		jmp		RUNSML		;		execution on the same line
                        	PR2:
FFFC1534 00D06193		ldi		r3,#CR
FFFC1538 FFFC1237		ldi		r4,#PR0
FFFC153C 54C20213
FFFC1540 454010EF		call	TSTC		;if null list and <CR>
FFFC1544 5D4010EF		call	CRLF		;also give CR-LF and
FFFC1548 E6DFF06F		jmp		RUNNXL		;execute the next line
                        	PR0:
FFFC154C 02306193		ldi		r3,#'#'
FFFC1550 FFFC1237		ldi		r4,#PR1
FFFC1554 56820213
FFFC1558 43C010EF		call	TSTC		;else is it a format?
FFFC155C 6DC000EF		call	OREXPR		; yes, evaluate expression
FFFC1560 000862B3		mov		r5,v0	; and save it as print width
FFFC1564 02000463		bra		PR3		; look for more to print
                        	PR1:
FFFC1568 02406193		ldi		r3,#'$'
FFFC156C FFFC1237		ldi		r4,#PR4
FFFC1570 58420213
FFFC1574 420010EF		call	TSTC	;	is character expression? (MRL)
FFFC1578 6C0000EF		call	OREXPR	;	yep. Evaluate expression (MRL)
FFFC157C A8DFF0EF		call	GOOUT	;	print low byte (MRL)
FFFC1580 00000663		bra		PR3		;look for more. (MRL)
                        	PR4:
FFFC1584 1C0010EF		call	QTSTG	;	is it a string?
                        		; the following branch must occupy only two bytes!
FFFC1588 02000263		bra		PR8		;	if not, must be an expression
                        	PR3:
FFFC158C 02C06193		ldi		r3,#','
FFFC1590 FFFC1237		ldi		r4,#PR6
FFFC1594 5A420213
FFFC1598 3FC010EF		call		TSTC	;	if ",", go find next
FFFC159C 66D000EF		call		FIN		;in the list.
FFFC15A0 FA0006E3		bra		PR0
                        	PR6:
FFFC15A4 574010EF		call		CRLF		;list ends here
FFFC15A8 0180006F		jmp		FINISH
                        	PR8:
FFFC15AC 68C000EF		call	OREXPR		; evaluate the expression
FFFC15B0 00086933		mov		a0,v0
FFFC15B4 0002E9B3		mov		a1,r5		; set the width
FFFC15B8 230010EF		call	PRTNUM		; print its value
FFFC15BC FC0008E3		bra		PR3			; more to print?
                        	
                        	
                        	FINISH:
FFFC15C0 649000EF		call	FIN		; Check end of command
FFFC15C4 6D10006F		jmp		QWHAT	; print "What?" if wrong
                        	
                        	
                        	;*******************************************************************
                        	;
                        	; *** GOSUB *** & RETURN ***
                        	;
                        	; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                        	; except that the current text pointer, stack pointer, etc. are
                        	; saved so that execution can be continued after the subroutine
                        	; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                        	; recursive), the save area must be stacked.  The stack pointer
                        	; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                        	; If we are in the main routine, 'STKGOS' is zero (this was done
                        	; in the initialization section of the interpreter), but we still
                        	; save it as a flag for no further 'RETURN's.
                        	;******************************************************************
                        	;
                        	GOSUB:
FFFC15C8 0D8010EF		call	PUSHA_		; save the current 'FOR' parameters
FFFC15CC 66C000EF		call	OREXPR		; get line number
FFFC15D0 00086933		mov		$a0,$v0
FFFC15D4 000010EF		call	FNDLN		; find the target line
FFFC15D8 00091863		bne		a0,r0,gosub1
FFFC15DC FFFC3937		ldi		a0,#msgBadGotoGosub
FFFC15E0 CEC90913
FFFC15E4 6B90006F		jmp		ERROR		; if not there, say "How?"
                        	gosub1:
FFFC15E8 FF470713		sub		$sp,$sp,#12
FFFC15EC 71002903		lw		a0,STKGOS	; 'STKGOS'
FFFC15F0 01272023		sw		a0,[$sp]
FFFC15F4 71402903		lw		a0,CURRNT	; found it, save old 'CURRNT'...
FFFC15F8 01272223		sw		a0,4[$sp]
FFFC15FC 01C72423		sw		$t2,8[$sp]
FFFC1600 70002623		sw		r0,LOPVAR		; load new values
FFFC1604 70E02823		sw		$sp,STKGOS
FFFC1608 E09FF06F		jmp		RUNTSL
                        	
                        	
                        	;******************************************************************
                        	; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                        	; returns the execution to the command after the most recent
                        	; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                        	; a 'GOSUB' and is thus an error.
                        	;******************************************************************
                        	;
                        	RETURN:
FFFC160C 641000EF		call	ENDCHK		; there should be just a <CR>
FFFC1610 71002983		lw		a1,STKGOS		; get old stack pointer
FFFC1614 00099863		bne		a1,r0,return1
FFFC1618 FFFC3937		ldi		a0,#msgRetWoGosub
FFFC161C D0990913
FFFC1620 67D0006F		jmp		ERROR		; if zero, it doesn't exist
                        	return1:
FFFC1624 0009E733		mov		$sp,a1		; else restore it
FFFC1628 00072903		lw		a0,[$sp]
FFFC162C 00470713		add		$sp,$sp,#4
FFFC1630 71202823		sw		a0,STKGOS	; and the old 'STKGOS'
FFFC1634 00072903		lw		a0,[$sp]
FFFC1638 00470713		add		$sp,$sp,#4
FFFC163C 71202A23		sw		a0,CURRNT	; and the old 'CURRNT'
FFFC1640 00072E03		lw		$t2,[$sp]	; and the old text pointer
FFFC1644 00470713		add		$sp,$sp,#4
FFFC1648 020010EF		call	POPA_		;and the old 'FOR' parameters
FFFC164C F75FF06F		jmp		FINISH		;and we are back home
                        	
                        	;******************************************************************
                        	; *** FOR *** & NEXT ***
                        	;
                        	; 'FOR' has two forms:
                        	; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                        	; The second form means the same thing as the first form with a
                        	; STEP of positive 1.  The interpreter will find the variable 'var'
                        	; and set its value to the current value of 'exp1'.  It also
                        	; evaluates 'exp2' and 'exp1' and saves all these together with
                        	; the text pointer, etc. in the 'FOR' save area, which consists of
                        	; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                        	; already something in the save area (indicated by a non-zero
                        	; 'LOPVAR'), then the old save area is saved on the stack before
                        	; the new values are stored.  The interpreter will then dig in the
                        	; stack and find out if this same variable was used in another
                        	; currently active 'FOR' loop.  If that is the case, then the old
                        	; 'FOR' loop is deactivated. (i.e. purged from the stack)
                        	;******************************************************************
                        	;
                        	FOR:
FFFC1650 050010EF		call	PUSHA_		; save the old 'FOR' save area
FFFC1654 551000EF		call	SETVAL		; set the control variable
FFFC1658 71202623		sw		a0,LOPVAR		; save its address
FFFC165C FFFC1EB7		ldi		$t3,#TAB5
FFFC1660 27DE8E93
FFFC1664 FFFC1F37		ldi		$t4,#TAB5_1	; use 'EXEC' to test for 'TO'
FFFC1668 2E0F0F13
FFFC166C CA5FF06F		jmp		EXEC
                        	FR1:
FFFC1670 5C8000EF		call	OREXPR		; evaluate the limit
FFFC1674 77202C23		sw		a0,LOPLMT	; save that
FFFC1678 FFFC1EB7		ldi		$t3,#TAB6
FFFC167C 280E8E93
FFFC1680 FFFC1F37		ldi		$t4,#TAB6_1	; use 'EXEC' to test for the word 'STEP
FFFC1684 2E4F0F13
FFFC1688 C89FF06F		jmp		EXEC
                        	FR2:
FFFC168C 5AC000EF		call	OREXPR		; found it, get the step value
FFFC1690 00000463		bra		FR4
                        	FR3:
FFFC1694 00106913		ldi		a0,#1		; not found, step defaults to 1
                        	FR4:
FFFC1698 77202A23		sw		a0,LOPINC	; save that too
                        	FR5:
FFFC169C 71402983		lw		a1,CURRNT
FFFC16A0 77302823		sw		a1,LOPLN	; save address of current line number
FFFC16A4 77C02623		sw		$t2,LOPPT	; and text pointer
FFFC16A8 000761B3		mov		r3,$sp		; dig into the stack to find 'LOPVAR'
FFFC16AC 70C02303		lw		r6,LOPVAR
FFFC16B0 00000463		bra		FR7
                        	FR6:
FFFC16B4 01418193		add		r3,r3,#20	; look at next stack frame
                        	FR7:
FFFC16B8 0001A983		lw		a1,[r3]		; is it zero?
FFFC16BC 02098463		beq		a1,r0,FR8	; if so, we're done
FFFC16C0 FE699AE3		bne		a1,r6,FR6	; same as current LOPVAR? nope, look some more
                        	
FFFC16C4 0001E933	  mov		a0,r3	   ; Else remove 5 words from...
FFFC16C8 01418993		add		a1,r3,#20  ; inside the stack.
FFFC16CC 000769B3		mov		a1,$sp
FFFC16D0 0009E1B3		mov		r3,a1
FFFC16D4 78D000EF		call	MVDOWN
FFFC16D8 01470713		add		$sp,$sp,#20	; set the SP 5 long words up
FFFC16DC 00072903		lw		a0,[$sp]
FFFC16E0 00470713		add		$sp,$sp,#4
                        	FR8:
FFFC16E4 EDDFF06F	  jmp	    FINISH		; and continue execution
                        	
                        	
                        	;******************************************************************
                        	; 'NEXT var' serves as the logical (not necessarily physical) end
                        	; of the 'FOR' loop.  The control variable 'var' is checked with
                        	; the 'LOPVAR'.  If they are not the same, the interpreter digs in
                        	; the stack to find the right one and purges all those that didn't
                        	; match.  Either way, it then adds the 'STEP' to that variable and
                        	; checks the result with against the limit value.  If it is within
                        	; the limit, control loops back to the command following the
                        	; 'FOR'.  If it's outside the limit, the save area is purged and
                        	; execution continues.
                        	;******************************************************************
                        	;
                        	NEXT:
FFFC16E8 00006933		mov		a0,r0		; don't allocate it
FFFC16EC 199000EF		call	TSTV		; get address of variable
FFFC16F0 00091863		bne		a0,r0,NX4
FFFC16F4 FFFC3937		ldi		a0,#msgNextVar
FFFC16F8 CC890913
FFFC16FC 5A0000E3		bra		ERROR		; if no variable, say "What?"
                        	NX4:
FFFC1700 00096EB3		mov		$t3,a0	; save variable's address
                        	NX0:
FFFC1704 70C02903		lw		a0,LOPVAR	; If 'LOPVAR' is zero, we never...
FFFC1708 00091863		bne		a0,r0,NX5	; had a FOR loop
FFFC170C FFFC3937		ldi		a0,#msgNextFor
FFFC1710 CB590913
FFFC1714 580004E3		bra		ERROR
                        	NX5:
FFFC1718 01D90663		beq		a0,$t3,NX2	; else we check them OK, they agree
FFFC171C 74D000EF		call	POPA_		; nope, let's see the next frame
FFFC1720 FE0002E3		bra		NX0
                        	NX2:
FFFC1724 000EA903		lw		a0,[$t3]		; get control variable's value
FFFC1728 77402983		lw		a1,LOPINC
FFFC172C 01390933		add		a0,a0,a1	; add in loop increment
                        	;	BVS.L	QHOW		say "How?" for 32-bit overflow
FFFC1730 012EA023		sw		a0,[$t3]		; save control variable's new value
FFFC1734 77802183		lw		r3,LOPLMT	; get loop's limit value
FFFC1738 0009D663		bge		a1,r0,NX1	; check loop increment, branch if loop increment is positive
FFFC173C 00394E63		blt		a0,r3,NXPurge	; test against limit
FFFC1740 00000463		bra     NX3
                        	NX1:
FFFC1744 0121CA63		bgt		a0,r3,NXPurge
                        	NX3:
FFFC1748 77002E03		lw		$t2,LOPLN	; Within limit, go back to the...
FFFC174C 71C02A23		sw		$t2,CURRNT
FFFC1750 76C02E03		lw		$t2,LOPPT	; saved 'CURRNT' and text pointer.
FFFC1754 E6DFF06F		jmp		FINISH
                        	NXPurge:
FFFC1758 711000EF	  call    POPA_        ; purge this loop
FFFC175C E65FF06F	  jmp     FINISH
                        	
                        	
                        	;******************************************************************
                        	; *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                        	;
                        	; 'REM' can be followed by anything and is ignored by the
                        	; interpreter.
                        	;
                        	;REM
                        	;    br	    IF2		    ; skip the rest of the line
                        	; 'IF' is followed by an expression, as a condition and one or
                        	; more commands (including other 'IF's) separated by colons.
                        	; Note that the word 'THEN' is not used.  The interpreter evaluates
                        	; the expression.  If it is non-zero, execution continues.  If it
                        	; is zero, the commands that follow are ignored and execution
                        	; continues on the next line.
                        	;******************************************************************
                        	;
                        	IF:
FFFC1760 4D8000EF	    call	OREXPR		; evaluate the expression
                        	IF1:
FFFC1764 CA091AE3	    bne	    a0,r0,RUNSML		; is it zero? if not, continue
                        	IF2:
FFFC1768 000E6EB3	    mov		$t3,$t2	; set lookup pointer
FFFC176C 00006933		mov		a0,r0		; find line #0 (impossible)
FFFC1770 6B5000EF		call	FNDSKP		; if so, skip the rest of the line
FFFC1774 940948E3		blt		a0,r0,WSTART; if no next line, do a warm start
                        	IF3:
FFFC1778 C99FF06F		jmp		RUNTSL		; run the next line
                        	
                        	
                        	;******************************************************************
                        	; INPUT is called first and establishes a stack frame
                        	INPERR:
FFFC177C 78002703		lw		$sp,STKINP		; restore the old stack pointer
FFFC1780 00072903		lw		a0,[$sp]
FFFC1784 00470713		add		$sp,$sp,#4
FFFC1788 71202A23		sw		a0,CURRNT		; and old 'CURRNT'
FFFC178C 00072E03		lw		$t2,[$sp]		; and old text pointer
FFFC1790 00470713		add		$sp,$sp,#4
FFFC1794 01470713		add		$sp,$sp,#20	; fall through will subtract 20
                        	
                        	; 'INPUT' is like the 'PRINT' command, and is followed by a list
                        	; of items.  If the item is a string in single or double quotes,
                        	; or is an underline (back arrow), it has the same effect as in
                        	; 'PRINT'.  If an item is a variable, this variable name is
                        	; printed out followed by a colon, then the interpreter waits for
                        	; an expression to be typed in.  The variable is then set to the
                        	; value of this expression.  If the variable is preceeded by a
                        	; string (again in single or double quotes), the string will be
                        	; displayed followed by a colon.  The interpreter the waits for an
                        	; expression to be entered and sets the variable equal to the
                        	; expression's value.  If the input expression is invalid, the
                        	; interpreter will print "What?", "How?", or "Sorry" and reprint
                        	; the prompt and redo the input.  The execution will not terminate
                        	; unless you press control-C.  This is handled in 'INPERR'.
                        	;
                        	INPUT:
FFFC1798 FEC70713		sub		$sp,$sp,#20	; allocate five words on stack
FFFC179C 00572823		sw		r5,16[$sp]	; save off r5 into stack var
                        	IP6:
FFFC17A0 01C72023		sw		$t2,[$sp]	; save in case of error
FFFC17A4 7A1000EF		call	QTSTG		; is next item a string?
FFFC17A8 00000C63		bra		IP2			; nope - this branch must take only two bytes
FFFC17AC 00106913		ldi		a0,#1		; allocate var
FFFC17B0 0D5000EF		call	TSTV		; yes, but is it followed by a variable?
FFFC17B4 08090263		beq    a0,r0,IP4   ; if not, brnch
FFFC17B8 00096F33		mov		$t4,a0		; put away the variable's address
FFFC17BC 02000E63		bra		IP3			; if so, input to variable
                        	IP2:
FFFC17C0 01C72223		sw		$t2,4[$sp]	; save off in stack var for 'PRTSTG'
FFFC17C4 00106913		ldi		a0,#1
FFFC17C8 0BD000EF		call	TSTV		; must be a variable now
FFFC17CC 00091A63		bne		a0,r0,IP7
FFFC17D0 FFFC3937		ldi		a0,#msgInputVar
FFFC17D4 C9890913
FFFC17D8 01470713		add		$sp,$sp,#20	; cleanup stack
FFFC17DC 4C0000E3		bra		ERROR		; "What?" it isn't?
                        	IP7:
FFFC17E0 00096F33		mov		$t4,a0		; put away the variable's address
FFFC17E4 000E4283		lbu		r5,[$t2]		; get ready for 'PRTSTG' by null terminating
FFFC17E8 000E0023		sb		r0,[$t2]
FFFC17EC 00472903		lw		a0,4[$sp]	; get back text pointer
FFFC17F0 6F5000EF		call	PRTSTG		; print string as prompt
FFFC17F4 005E0023		sb		r5,[$t2]		; un-null terminate
                        	IP3
FFFC17F8 01C72223		sw		$t2,4[$sp]	; save in case of error
FFFC17FC 71402903		lw		a0,CURRNT
FFFC1800 01272423		sw		a0,8[$sp]	; also save 'CURRNT'
FFFC1804 FFF06913		ldi		a0,#-1
FFFC1808 71202A23		sw		a0,CURRNT	; flag that we are in INPUT
FFFC180C 78E02023		sw		$sp,STKINP	; save the stack pointer too
FFFC1810 01E72623		sw		$t4,12[$sp]	; save the variable address
FFFC1814 03A06913		ldi		a0,#':'		; print a colon first
FFFC1818 4C9000EF		call	GETLN		; then get an input line
FFFC181C 71806E13		ldi		$t2,#BUFFER	; point to the buffer
FFFC1820 418000EF		call	OREXPR		; evaluate the input
FFFC1824 00C72F03		lw		$t4,12[$sp]	; restore the variable address
FFFC1828 012F2023		sw		a0,[$t4]	; save value in variable
FFFC182C 00872903		lw		a0,8[$sp]	; restore old 'CURRNT'
FFFC1830 71202A23		sw		a0,CURRNT
FFFC1834 00472E03		lw		$t2,4[$sp]	; and the old text pointer
                        	IP4:
FFFC1838 02C06193		ldi		r3,#','
FFFC183C FFFC2237		ldi		r4,#IP5		; is the next thing a comma?
FFFC1840 84C20213
FFFC1844 150010EF		call	TSTC
FFFC1848 F4000CE3		bra		IP6			; yes, more items
                        	IP5:
FFFC184C 01072283		lw		r5,16[$sp]
FFFC1850 01470713		add		$sp,$sp,#20	; cleanup stack
FFFC1854 D6DFF06F	 	jmp		FINISH
                        	
                        	
                        	DEFLT:
FFFC1858 000E4903	  lbu    	a0,[$t2]
FFFC185C 00D06D93	  ldi			$t1,#CR
FFFC1860 D7B900E3		beq	    a0,$t1,FINISH	    ; empty line is OK else it is 'LET'
                        	
                        	
                        	;******************************************************************
                        	; 'LET' is followed by a list of items separated by commas.
                        	; Each item consists of a variable, an equals sign, and an
                        	; expression.  The interpreter evaluates the expression and sets
                        	; the variable to that value.  The interpreter will also handle
                        	; 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                        	;******************************************************************
                        	;
                        	LET:
FFFC1864 341000EF	  call	SETVAL		; do the assignment
FFFC1868 02C06193	  ldi		r3,#','
FFFC186C FFFC1237	  ldi		r4,#FINISH
FFFC1870 5C020213
FFFC1874 120010EF		call	TSTC		; check for more 'LET' items
FFFC1878 FE0006E3		bra	    LET
                        	LT1:
FFFC187C D45FF06F	  jmp	    FINISH		; until we are finished.
                        	
                        	
                        	;******************************************************************
                        	; *** LOAD *** & SAVE ***
                        	;
                        	; These two commands transfer a program to/from an auxiliary
                        	; device such as a cassette, another computer, etc.  The program
                        	; is converted to an easily-stored format: each line starts with
                        	; a colon, the line no. as 4 hex digits, and the rest of the line.
                        	; At the end, a line starting with an '@' sign is sent.  This
                        	; format can be read back with a minimum of processing time by
                        	; the RTF65002
                        	;******************************************************************
                        	;
                        	LOAD
FFFC1880 00002E37		ldi		$t2,#TXTBGN	; set pointer to start of prog. area
FFFC1884 800E0E13
FFFC1888 00D06913		ldi		a0,#CR		; For a CP/M host, tell it we're ready...
FFFC188C F84FF0EF		call	GOAUXO		; by sending a CR to finish PIP command.
                        	LOD1:
FFFC1890 F88FF0EF		call	GOAUXI		; look for start of line
FFFC1894 FF205EE3		ble		a0,r0,LOD1
FFFC1898 04006D93		ldi		$t1,#'@'
FFFC189C 03B90E63		beq		a0,$t1,LODEND	; end of program?
FFFC18A0 01A06D93		ldi		$t1,#$1A
FFFC18A4 03B90A63		beq		a0,$t1,LODEND	; or EOF marker
FFFC18A8 03A06D93		ldi		$t1,#':'
FFFC18AC FFB912E3		bne		a0,$t1,LOD1	; if not, is it start of line? if not, wait for it
FFFC18B0 030000EF		call	GCHAR		; get line number
FFFC18B4 012E2023		sw		a0,[$t2]		; store it
FFFC18B8 004E0E13		add		$t2,$t2,#4
                        	LOD2:
FFFC18BC F5CFF0EF		call	GOAUXI		; get another text char.
FFFC18C0 FF205EE3		ble		a0,r0,LOD2
FFFC18C4 012E0023		sb		a0,[$t2]		; store it
FFFC18C8 001E0E13		add		$t2,$t2,#1
FFFC18CC 00D06D93		ldi		$t1,#CR
FFFC18D0 FFB916E3		bne		a0,$t1,LOD2		; is it the end of the line? if not, go back for more
FFFC18D4 FA000EE3		bra		LOD1		; if so, start a new line
                        	LODEND:
FFFC18D8 71C02223		sw		$t2,TXTUNF	; set end-of program pointer
FFFC18DC FE8FF06F		jmp		WSTART		; back to direct mode
                        	
                        	
                        	; get character from input (32 bit value)
                        	GCHAR:
FFFC18E0 FF470713		sub		$sp,$sp,#12
FFFC18E4 00572023		sw		r5,[$sp]
FFFC18E8 00672223		sw		r6,4[$sp]
FFFC18EC 00172423		sw		$ra,8[$sp]
FFFC18F0 00806313		ldi		r6,#8       ; repeat ten times
FFFC18F4 00006293		ldi		r5,#0
                        	GCHAR1:
FFFC18F8 F20FF0EF		call	GOAUXI		; get a char
FFFC18FC FF205EE3		ble		a0,r0,GCHAR1
FFFC1900 02C000EF		call	asciiToHex
FFFC1904 00429293		sll		r5,r5,#4
FFFC1908 0122E2B3		or		r5,r5,a0
FFFC190C FFF30313		sub		r6,r6,#1
FFFC1910 FE6064E3		bgtu	r6,r0,GCHAR1
FFFC1914 0002E933		mov		a0,r5
FFFC1918 00072283		lw		r5,[$sp]
FFFC191C 00472303		lw		r6,4[$sp]
FFFC1920 00872083		lw		$ra,8[$sp]
FFFC1924 00C70713		add		$sp,$sp,#12
FFFC1928 00008067		ret
                        	
                        	; convert an ascii char to hex code
                        	; input
                        	;	a0 = char to convert
                        	
                        	asciiToHex:
FFFC192C 03906D93		ldi		$t1,#'9'
FFFC1930 012DF463		bleu	a0,$t1,a2h1; less than '9'
FFFC1934 FF990913		sub		a0,a0,#7	; shift 'A' to '9'+1
                        	a2h1:
FFFC1938 FD090913		sub		a0,a0,#'0'
FFFC193C 00F97913		and		a0,a0,#15	; make sure a nybble
FFFC1940 00008067		ret
                        	
                        	GetFilename:
FFFC1944 FFC70713		sub		$sp,$sp,#4
FFFC1948 00172023		sw		$ra,[$sp]
FFFC194C 02206193		ldi		r3,#'"'
FFFC1950 FFFC2237		ldi		r4,#gfn1
FFFC1954 9B020213
FFFC1958 03C010EF		call	TSTC
FFFC195C 000061B3		mov		r3,r0
                        	gfn2:
FFFC1960 000E4903		lbu		a0,[$t2]		; get text character
FFFC1964 001E0E13		add		$t2,$t2,#1
FFFC1968 02206D93		ldi		$t1,#'"'
FFFC196C 03B90263		beq		a0,$t1,gfn3
FFFC1970 02090063		beq		a0,r0,gfn3
FFFC1974 6D218023		sb		a0,FILENAME[r3]
FFFC1978 00118193		add		r3,r3,#1
FFFC197C 04006D93		ldi		$t1,#64
FFFC1980 FFB1E0E3		bltu	r3,$t1,gfn2
FFFC1984 00072083		lw		$ra,[$sp]
FFFC1988 00470713		add		$sp,$sp,#4
FFFC198C 00008067		ret
                        	gfn3:
FFFC1990 02006913		ldi		a0,#' '
FFFC1994 6D218023		sb		a0,FILENAME[r3]
FFFC1998 00118193		add		r3,r3,#1
FFFC199C 04006D93		ldi		$t1,#64
FFFC19A0 FFB1E8E3		bltu	r3,$t1,gfn3
FFFC19A4 00072083		lw		$ra,[$sp]
FFFC19A8 00470713		add		$sp,$sp,#4
FFFC19AC 00008067		ret
                        	gfn1:
FFFC19B0 F14FF06F		jmp		WSTART
                        	
                        	LOAD3:
FFFC19B4 F91FF0EF		call	GetFilename
FFFC19B8 00000637		call	AUXIN_INIT
FFFC19BC 1A0600E7
FFFC19C0 EC1FF06F		jmp		LOAD
                        	
                        	;	call		OREXPR		;evaluate the following expression
                        	;	ld		a0,#5000
FFFC19C4 000019B7		ld		a1,#$E00
FFFC19C8 E0098993
FFFC19CC 00000637		call	SDReadSector
FFFC19D0 1A1600E7
FFFC19D4 00190913		add		a0,a0,#1
FFFC19D8 000029B7		ldi		a1,#TXTBGN
FFFC19DC 80098993
                        	LOAD4:
FFFC19E0 FFC70713		sub		$sp,$sp,#4
FFFC19E4 01272023		sw		a0,[$sp]
FFFC19E8 00000637		call	SDReadSector
FFFC19EC 1A1600E7
FFFC19F0 20098993		add		a1,a1,#512
FFFC19F4 00072903		lw		a0,[$sp]
FFFC19F8 00470713		add		$sp,$sp,#4
FFFC19FC 00190913		add		a0,a0,#1
FFFC1A00 00002237		ldi		r4,#TXTBGN
FFFC1A04 80020213
FFFC1A08 00010637		add		r4,r4,#65536
FFFC1A0C 00460233
FFFC1A10 FC49C8E3		blt		a1,r4,LOAD4
                        	LOAD5:
FFFC1A14 EA000863		bra		WSTART
                        	
                        	
                        	SAVE3:
FFFC1A18 F2DFF0EF		call	GetFilename
FFFC1A1C 00000637		call	AUXOUT_INIT
FFFC1A20 1A4600E7
FFFC1A24 05C0006F		jmp		SAVE
                        	
FFFC1A28 210000EF		call	OREXPR		;evaluate the following expression
                        	;	lda		#5000		; starting sector
FFFC1A2C 000019B7		ldi		a1,#$E00	; starting address to write
FFFC1A30 E0098993
FFFC1A34 00000637		call	SDWriteSector
FFFC1A38 1A6600E7
FFFC1A3C 00190913		add		a0,a0,#1
FFFC1A40 000029B7		ldi		a1,#TXTBGN
FFFC1A44 80098993
                        	SAVE4:
FFFC1A48 FFC70713		sub		$sp,$sp,#4
FFFC1A4C 01272023		sw		a0,[$sp]
FFFC1A50 00000637		call	SDWriteSector
FFFC1A54 1A6600E7
FFFC1A58 20098993		add		a1,a1,#512
FFFC1A5C 00072903		lw		a0,[$sp]
FFFC1A60 00470713		add		$sp,$sp,#4
FFFC1A64 00190913		add		a0,a0,#1
FFFC1A68 00002237		ldi		r4,#TXTBGN
FFFC1A6C 80020213
FFFC1A70 00010637		add		r4,r4,#65536
FFFC1A74 00460233
FFFC1A78 FC49C8E3		blt		a1,r4,SAVE4
FFFC1A7C E4000463		bra		WSTART
                        	
                        	SAVE:
FFFC1A80 00002E37		ldi		$t2,#TXTBGN	;set pointer to start of prog. area
FFFC1A84 800E0E13
FFFC1A88 70402E83		lw		$t3,TXTUNF	;set pointer to end of prog. area
                        	SAVE1:
FFFC1A8C 054000EF		call	AUXOCRLF    ; send out a CR & LF (CP/M likes this)
FFFC1A90 03CEC863		bgt		$t2,$t3,SAVEND; are we finished?
FFFC1A94 03A06913		ldi		a0,#':'		; if not, start a line
FFFC1A98 D78FF0EF		call	GOAUXO
FFFC1A9C 000E2903		lw		a0,[$t2]		; get line number
FFFC1AA0 004E0E13		add		$t2,$t2,#4
FFFC1AA4 060000EF		call	PWORD       ; output line number as 5-digit hex
                        	SAVE2:
FFFC1AA8 000E4903		lbu		a0,[$t2]		; get a text char.
FFFC1AAC 001E0E13		add		$t2,$t2,#1
FFFC1AB0 00D06D93		ldi		$t1,#CR
FFFC1AB4 FDB90CE3		beq		a0,$t1,SAVE1	; is it the end of the line? if so, send CR & LF and start new line
FFFC1AB8 D58FF0EF		call	GOAUXO		; send it out
FFFC1ABC FE0006E3		bra		SAVE2		; go back for more text
                        	SAVEND:
FFFC1AC0 04006913		ldi		a0,#'@'		; send end-of-program indicator
FFFC1AC4 D4CFF0EF		call	GOAUXO
FFFC1AC8 018000EF		call	AUXOCRLF    ; followed by a CR & LF
FFFC1ACC 01A06913		ldi		a0,#$1A		; and a control-Z to end the CP/M file
FFFC1AD0 D40FF0EF		call	GOAUXO
FFFC1AD4 00000637		call	AUXOUT_FLUSH
FFFC1AD8 1AD600E7
FFFC1ADC DE000463		bra		WSTART		; then go do a warm start
                        	
                        	; output a CR LF sequence to auxillary output
                        	; Registers Affected
                        	;   r3 = LF
                        	AUXOCRLF:
FFFC1AE0 FFC70713		sub		$sp,$sp,#4
FFFC1AE4 00172023		sw		$ra,[$sp]
FFFC1AE8 00D06913	  ldi		a0,#CR
FFFC1AEC D24FF0EF	  call	GOAUXO
FFFC1AF0 00A06913	  ldi		a0,#LINEFD
FFFC1AF4 D1CFF0EF	  call	GOAUXO
FFFC1AF8 00072083	  lw		$ra,[$sp]
FFFC1AFC 00470713	  add		$sp,$sp,#4
FFFC1B00 00008067	  ret
                        	
                        	
                        	; output a word in hex format
                        	; tricky because of the need to reverse the order of the chars
                        	PWORD:
FFFC1B04 FF870713		sub		$sp,$sp,#8
FFFC1B08 00572023		sw		r5,[$sp]
FFFC1B0C 00172223		sw		$ra,4[$sp]
FFFC1B10 78A06293		ldi		r5,#NUMWKA+14
FFFC1B14 00096233		mov		r4,a0		; r4 = value
                        	pword1:
FFFC1B18 00026933	  mov   a0,r4	    ; a0 = value
FFFC1B1C 00425213	  srl		r4,r4,#4	; shift over to next nybble
FFFC1B20 038000EF	  call	toAsciiHex  ; convert LS nybble to ascii hex
FFFC1B24 01228023	  sb    a0,[r5]		; save in work area
FFFC1B28 FFF28293	  sub		r5,r5,#1
FFFC1B2C 77C06D93	  ldi		$t1,#NUMWKA
FFFC1B30 FFB2D4E3		bge		r5,$t1,pword1
                        	pword2:
FFFC1B34 00128293	  add		r5,r5,#1
FFFC1B38 0002C903	  lbu   a0,[r5]     ; get char to output
FFFC1B3C CD4FF0EF		call	GOAUXO		; send it
FFFC1B40 78A06D93		ldi		$t1,#NUMWKA+14
FFFC1B44 FFB2C8E3		blt		r5,$t1,pword2
FFFC1B48 00072283		lw		r5,[$sp]
FFFC1B4C 00472083		lw		$ra,4[$sp]
FFFC1B50 00870713		add		$sp,$sp,#8
FFFC1B54 00008067		ret
                        	
                        	; convert nybble in a1 to ascii hex chaa1
                        	; a1 = character to convert
                        	
                        	toAsciiHex:
FFFC1B58 00F97913		and		a0,a0,#15	; make sure it's a nybble
FFFC1B5C 00A06D93		ldi		$t1,#10
FFFC1B60 01B94463		blt		a0,$t1,tah1	; > 10 ?
FFFC1B64 00790913		add		a0,a0,#7	; bump it up to the letter 'A'
                        	tah1:
FFFC1B68 03090913		add		a0,a0,#'0'	; bump up to ascii '0'
FFFC1B6C 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	; *** POKE ***
                        	;
                        	; 'POKE expr1,expa1' stores the byte from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEW expr1,expa1' stores the word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEH expr1,expa1' stores the half-word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	;******************************************************************
                        	;
                        	POKE:
FFFC1B70 0C8000EF		call	OREXPR		; get the memory address
FFFC1B74 02C06193		ldi		r3,#','
FFFC1B78 FFFC2237		ldi		r4,#PKER	; it must be followed by a comma
FFFC1B7C C0020213
FFFC1B80 615000EF		call	TSTC		; it must be followed by a comma
FFFC1B84 FFC70713		sub		$sp,$sp,#4
FFFC1B88 01272023		sw		a0,[$sp]	; save the address
FFFC1B8C 0AC000EF		call	OREXPR		; get the byte to be POKE'd
FFFC1B90 00072983		lw		a1,[$sp]	; get the address back
FFFC1B94 00470713		add		$sp,$sp,#4
FFFC1B98 01298023		sb		a0,[a1]		; store the byte in memory
FFFC1B9C A25FF06F		jmp		FINISH
                        	
                        	POKEW:
FFFC1BA0 098000EF		call	OREXPR		; get the memory address
FFFC1BA4 02C06193		ldi		r3,#','
FFFC1BA8 FFFC2237		ldi		r4,#PKER	; it must be followed by a comma
FFFC1BAC C0020213
FFFC1BB0 5E5000EF		call	TSTC		; it must be followed by a comma
FFFC1BB4 FFC70713		sub		$sp,$sp,#4
FFFC1BB8 01272023		sw		a0,[$sp]	; save the address
FFFC1BBC 07C000EF		call	OREXPR		; get the byte to be POKE'd
FFFC1BC0 00072983		lw		a1,[$sp]	; get the address back
FFFC1BC4 00470713		add		$sp,$sp,#4
FFFC1BC8 0129A023		sw		a0,[a1]		; store the byte in memory
FFFC1BCC 9F5FF06F		jmp		FINISH
                        	
                        	POKEH:
FFFC1BD0 068000EF		call	OREXPR		; get the memory address
FFFC1BD4 02C06193		ldi		r3,#','
FFFC1BD8 FFFC2237		ldi		r4,#PKER	; it must be followed by a comma
FFFC1BDC C0020213
FFFC1BE0 5B5000EF		call	TSTC		; it must be followed by a comma
FFFC1BE4 FFC70713		sub		$sp,$sp,#4
FFFC1BE8 01272023		sw		a0,[$sp]	; save the address
FFFC1BEC 04C000EF		call	OREXPR		; get the byte to be POKE'd
FFFC1BF0 00072983		lw		a1,[$sp]	; get the address back
FFFC1BF4 00470713		add		$sp,$sp,#4
FFFC1BF8 01299023		sh		a0,[a1]		; store the byte in memory
FFFC1BFC 9C5FF06F		jmp		FINISH
                        	
                        	PKER:
FFFC1C00 FFFC3937		ldi		a0,#msgComma
FFFC1C04 C3190913
FFFC1C08 0950006F		jmp		ERROR		; if no comma, say "What?"
                        	
                        	;******************************************************************
                        	; 'SYSX expr' jumps to the machine language subroutine whose
                        	; starting address is specified by 'expr'.  The subroutine can use
                        	; all registers but must leave the stack the way it found it.
                        	; The subroutine returns to the interpreter by executing an RTS.
                        	;******************************************************************
                        	
                        	SYSX:
FFFC1C0C 02C000EF		call	OREXPR		; get the subroutine's address
FFFC1C10 00091863		bne		a0,r0,sysx1; make sure we got a valid address
FFFC1C14 FFFC3937		ld		a0,#msgSYSBad
FFFC1C18 C8690913
FFFC1C1C 0810006F		jmp		ERROR
                        	sysx1:
FFFC1C20 FFC70713		sub		$sp,$sp,#4
FFFC1C24 01C72023		sw		$t2,[$sp]	; save the text pointer
FFFC1C28 000900E7		call	[a0]			; jump to the subroutine
FFFC1C2C 00072E03		lw		$t2,[$sp]	; restore the text pointer
FFFC1C30 00470713		add		$sp,$sp,#4
FFFC1C34 98DFF06F		jmp		FINISH
                        	
                        	;******************************************************************
                        	; *** EXPR ***
                        	;
                        	; 'EXPR' evaluates arithmetical or logical expressions.
                        	; <OREXPR>::= <ANDEXPR> OR <ANDEXPR> ...
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	; <EXPR>::=<EXPR2>
                        	;	   <EXPR2><rel.op.><EXPR2>
                        	; where <rel.op.> is one of the operators in TAB8 and the result
                        	; of these operations is 1 if true and 0 if false.
                        	; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                        	; where () are optional and (... are optional repeats.
                        	; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                        	; <EXPR4>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                        	; as an index, functions can have an <EXPR> as arguments, and
                        	; <EXPR4> can be an <EXPR> in parenthesis.
                        	;
                        	
                        	; <OREXPR>::=<ANDEXPR> OR <ANDEXPR> ...
                        	;
                        	OREXPR:
FFFC1C38 FFC70713		sub		$sp,$sp,#4
FFFC1C3C 00172023		sw		$ra,[$sp]
FFFC1C40 048000EF		call	ANDEXPR		; get first <ANDEXPR>
                        	XP_OR1:
FFFC1C44 FFC70713		sub		$sp,$sp,#4
FFFC1C48 01272023		sw		$a0,[$sp]	; save <ANDEXPR> value
FFFC1C4C FFFC1EB7		ld		$t3,#TAB10	; look up a logical operator
FFFC1C50 293E8E93
FFFC1C54 FFFC1F37		ld		$t4,#TAB10_1
FFFC1C58 2FAF0F13
FFFC1C5C EB4FF06F		jmp		EXEC		; go do it
                        	XP_OR:
FFFC1C60 028000EF	  call	ANDEXPR
FFFC1C64 00072983	  lw		$a1,[$sp]
FFFC1C68 00470713	  add		$sp,$sp,#4
FFFC1C6C 01396933	  or    a0,a0,a1
FFFC1C70 FC000AE3	  bra   XP_OR1
                        	XP_ORX:
FFFC1C74 00072903	  lw		$a0,[$sp]
FFFC1C78 00470713	  add		$sp,$sp,#4
FFFC1C7C 00072083		lw		$ra,[$sp]
FFFC1C80 00470713		add		$sp,$sp,#4
FFFC1C84 00008067	  ret
                        	
                        	
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	;
                        	ANDEXPR:
FFFC1C88 FFC70713		sub		$sp,$sp,#4
FFFC1C8C 00172023		sw		$ra,[$sp]
FFFC1C90 0E0000EF		call	EXPR		; get first <EXPR>
                        	XP_AND1:
FFFC1C94 FFC70713		sub		$sp,$sp,#4
FFFC1C98 01272023		sw		$a0,[$sp]	; save <EXPR> value
FFFC1C9C FFFC1EB7		ldi		$t3,#TAB9	; look up a logical operator
FFFC1CA0 28FE8E93
FFFC1CA4 FFFC1F37		ldi		$t4,#TAB9_1
FFFC1CA8 2F6F0F13
FFFC1CAC E64FF06F		jmp		EXEC		; go do it
                        	XP_AND:
FFFC1CB0 0C0000EF	  call	EXPR
FFFC1CB4 00072983	  lw		$a1,[$sp]
FFFC1CB8 00470713	  add		$sp,$sp,#4
FFFC1CBC 01397933	  and   a0,a0,a1
FFFC1CC0 FC000AE3	  bra   XP_AND1
                        	XP_ANDX:
FFFC1CC4 00072903	  lw		$a0,[$sp]
FFFC1CC8 00470713	  add		$sp,$sp,#4
FFFC1CCC 00072083		lw		$ra,[$sp]
FFFC1CD0 00470713		add		$sp,$sp,#4
FFFC1CD4 00008067	  ret
                        	
                        	
                        	; Determine if the character is a digit
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if digit, otherwise 0
                        	;
                        	isDigit:
FFFC1CD8 03006D93		ldi		$t1,#'0'
FFFC1CDC 01B94A63		blt		a0,$t1,isDigitFalse
FFFC1CE0 03906D93		ldi		$t1,#'9'
FFFC1CE4 012DC663		bgt		a0,$t1,isDigitFalse
FFFC1CE8 00106813		ldi		v0,#1
FFFC1CEC 00008067	  ret
                        	isDigitFalse:
FFFC1CF0 00006833	  mov		v0,r0
FFFC1CF4 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphabetic
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlpha:
FFFC1CF8 04106D93		ldi		$t1,#'A'
FFFC1CFC 03B94263		blt		a0,$t1,isAlphaFalse
FFFC1D00 05A06D93		ldi		$t1,#'Z'
FFFC1D04 012DDA63		ble		a0,$t1,isAlphaTrue
FFFC1D08 06106D93		ldi		$t1,#'a'
FFFC1D0C 01B94A63		blt		a0,$t1,isAlphaFalse
FFFC1D10 07A06D93		ldi		$t1,#'z'
FFFC1D14 012DC663		bgt		a0,$t1,isAlphaFalse
                        	isAlphaTrue:
FFFC1D18 00106813	  ldi		v0,#1
FFFC1D1C 00008067	  ret
                        	isAlphaFalse:
FFFC1D20 00006833	  mov		v0,r0
FFFC1D24 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphanumeric
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlnum:
FFFC1D28 FFC70713		sub		$sp,$sp,#4
FFFC1D2C 00172023		sw		$ra,[$sp]
FFFC1D30 FA9FF0EF	  call	isDigit
FFFC1D34 00081463		bne		v0,r0,isDigitx	; if it is a digit
FFFC1D38 FC1FF0EF	  call  isAlpha
                        	isDigitx:
FFFC1D3C 00072083		lw		$ra,[$sp]
FFFC1D40 00470713		add		$sp,$sp,#4
FFFC1D44 00008067	  ret
                        	
                        	FORCEFIT:
FFFC1D48 03198263		beq		a1,v1,.0001				; types match
FFFC1D4C 00006D13		ldi		$t0,#0
FFFC1D50 01A98663		beq		a1,$t0,.intAnd
                        	;	itof	$f1,$v0
FFFC1D54 00106913		ldi		a0,#1
FFFC1D58 00008067		ret
                        	.intAnd:
FFFC1D5C 00106D13		ldi		$t0,#1
FFFC1D60 01A89663		bne		$v1,$t0,.0001
                        	;	itof	$f2,$a1
FFFC1D64 00106993		ldi		$a1,#1
FFFC1D68 00008067		ret
                        	.0001:
FFFC1D6C 00008067		ret
                        	
                        	EXPR:
FFFC1D70 FFC70713		sub		$sp,$sp,#4
FFFC1D74 00172023		sw		$ra,[$sp]
FFFC1D78 11C000EF		call	EXPR2
FFFC1D7C FF870713		sub		$sp,$sp,#8				; save <EXPR2> value
FFFC1D80 01072023		sw		v0,[$sp]
FFFC1D84 01172223		sw		v1,4[$sp]					; save type
FFFC1D88 FFFC1EB7		ldi		$t3,#TAB8		; look up a relational operator
FFFC1D8C 285E8E93
FFFC1D90 FFFC1F37		ldi		$t4,#TAB8_1
FFFC1D94 2E8F0F13
FFFC1D98 D78FF06F		jmp		EXEC		; go do it
                        	XP11:
FFFC1D9C 00072903		lw		a0,[$sp]
FFFC1DA0 00472983		lw		a1,4[$sp]
FFFC1DA4 00870713		add		$sp,$sp,#8
FFFC1DA8 0C4000EF		call	XP18	; is it ">="?
FFFC1DAC 09095A63		bge		a0,v0,XPRT1	; no, return v0=1
FFFC1DB0 06000E63		bra		XPRT0	; else return v0=0
                        	XP12:
FFFC1DB4 00072903		lw		a0,[$sp]
FFFC1DB8 00472983		lw		a1,4[$sp]
FFFC1DBC 00870713		add		$sp,$sp,#8
FFFC1DC0 0AC000EF		call	XP18	; is it "<>"?
FFFC1DC4 07091E63		bne		a0,v0,XPRT1	; no, return a1=1
FFFC1DC8 06000263		bra		XPRT0	; else return a1=0
                        	XP13:
FFFC1DCC 00072903		lw		a0,[$sp]
FFFC1DD0 00472983		lw		a1,4[$sp]
FFFC1DD4 00870713		add		$sp,$sp,#8
FFFC1DD8 094000EF		call	XP18	; is it ">"?
FFFC1DDC 07284263		bgt		a0,v0,XPRT1	; no, return a1=1
FFFC1DE0 04000663		bra		XPRT0	; else return a1=0
                        	XP14:
FFFC1DE4 00072903		lw		a0,[$sp]
FFFC1DE8 00472983		lw		a1,4[$sp]
FFFC1DEC 00870713		add		$sp,$sp,#8
FFFC1DF0 07C000EF		call	XP18	; is it "<="?
FFFC1DF4 05285663		ble		a0,v0,XPRT1	; no, return a1=1
FFFC1DF8 02000A63		bra		XPRT0	; else return a1=0
                        	XP15:
FFFC1DFC 00072903		lw		a0,[$sp]
FFFC1E00 00472983		lw		a1,4[$sp]
FFFC1E04 00870713		add		$sp,$sp,#8
FFFC1E08 064000EF		call	XP18	; is it "="?
FFFC1E0C 03090A63		beq		a0,v0,XPRT1	; if not, return a1=1
FFFC1E10 00000E63		bra		XPRT0	; else return a1=0
                        	XP16:
FFFC1E14 00072903		lw		a0,[$sp]
FFFC1E18 00472983		lw		a1,4[$sp]
FFFC1E1C 00870713		add		$sp,$sp,#8
FFFC1E20 04C000EF		call	XP18	; is it "<"?
FFFC1E24 01094E63		blt		a0,v0,XPRT1	; if not, return a1=1
FFFC1E28 00000263		bra		XPRT0	; else return a1=0
                        	XPRT0:
FFFC1E2C 00006833		mov		v0,x0   ; return a0=0 (false)
FFFC1E30 000068B3		mov		v1,x0		; type = int
FFFC1E34 00072083		lw		$ra,[$sp]
FFFC1E38 00470713		add		$sp,$sp,#4
FFFC1E3C 00008067		ret
                        	XPRT1:
FFFC1E40 00106813		ldi		v0,#1	; return a0=1 (true)
FFFC1E44 00006893		ldi		v1,#0	; type = int
FFFC1E48 00072083		lw		$ra,[$sp]
FFFC1E4C 00470713		add		$sp,$sp,#4
FFFC1E50 00008067		ret
                        	
                        	XP17:				; it's not a rel. operator
FFFC1E54 00072803		lw		v0,[$sp]; return a1=<EXPR2>
FFFC1E58 00472883		lw		v1,4[$sp]
FFFC1E5C 00870713		add		$sp,$sp,#8
FFFC1E60 00072083		lw		$ra,[$sp]
FFFC1E64 00470713		add		$sp,$sp,#4
FFFC1E68 00008067		ret
                        	
                        	XP18:
FFFC1E6C FF470713		sub		$sp,$sp,#12
FFFC1E70 00172023		sw		$ra,[$sp]
FFFC1E74 01072223		sw		v0,4[$sp]
FFFC1E78 01172423		sw		v1,8[$sp]
FFFC1E7C 018000EF		call	EXPR2		; do a second <EXPR2>
FFFC1E80 00472903		lw		a0,4[$sp]
FFFC1E84 00872983		lw		a1,8[$sp]
FFFC1E88 00072083		lw		$ra,[$sp]
FFFC1E8C 00C70713		add		$sp,$sp,#12
FFFC1E90 00008067		ret
                        	
                        	; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                        	//message "EXPR2"
                        	EXPR2:
FFFC1E94 FFC70713		sub		$sp,$sp,#4
FFFC1E98 00172023		sw		$ra,[$sp]
FFFC1E9C 02D06193		ldi		r3,#'-'
FFFC1EA0 FFFC2237		ldi		r4,#XP21
FFFC1EA4 EC020213
FFFC1EA8 2ED000EF		call	TSTC		; negative sign?
FFFC1EAC 00006833		mov		v0,r0		; yes, fake '0-'
FFFC1EB0 FF870713		sub		$sp,$sp,#8
FFFC1EB4 01072023		sw		v0,[$sp]
FFFC1EB8 01172223		sw		v1,4[$sp]
FFFC1EBC 04000E63		bra		XP26
                        	XP21:
FFFC1EC0 02B06193		ldi		r3,#'+'
FFFC1EC4 FFFC2237		ldi		r4,#XP22
FFFC1EC8 ED020213
FFFC1ECC 2C9000EF		call	TSTC		; positive sign? ignore it
                        	XP22:
FFFC1ED0 06C000EF		call	EXPR3		; first <EXPR3>
                        	XP23:
FFFC1ED4 FF870713		sub		$sp,$sp,#8; yes, save the value
FFFC1ED8 01072023		sw		v0,[$sp]
FFFC1EDC 01172223		sw		v1,4[$sp]	; and type
FFFC1EE0 02B06193		ldi		r3,#'+'
FFFC1EE4 FFFC2237		ldi		r4,#XP25
FFFC1EE8 F0820213
FFFC1EEC 2A9000EF		call	TSTC		; add?
FFFC1EF0 04C000EF		call	EXPR3		; get the second <EXPR3>
                        	XP24:
FFFC1EF4 00072903		lw		a0,[$sp]
FFFC1EF8 00472983		lw		a1,4[$sp]
FFFC1EFC 00870713		add		$sp,$sp,#8
FFFC1F00 01280833		add		v0,v0,a0	; add it to the first <EXPR3>
                        	;	BVS.L	QHOW		brnch if there's an overflow
FFFC1F04 FC0008E3		bra		XP23		; else go back for more operations
                        	XP25:
FFFC1F08 02D06193		ldi		r3,#'-'
FFFC1F0C FFFC2237		ldi		r4,#XP45
FFFC1F10 F2420213
FFFC1F14 281000EF		call	TSTC		; subtract?
                        	XP26:
FFFC1F18 024000EF		call	EXPR3		; get second <EXPR3>
FFFC1F1C 41000833		sub		v0,r0,v0	; change its sign
FFFC1F20 FC000AE3		bra		XP24		; and do an addition
                        	XP45:
FFFC1F24 00072803		lw		v0,[$sp]
FFFC1F28 00472883		lw		v1,4[$sp]
FFFC1F2C 00870713		add		$sp,$sp,#8
FFFC1F30 00072083		lw		$ra,[$sp]
FFFC1F34 00470713		add		$sp,$sp,#4
FFFC1F38 00008067		ret
                        	
                        	
                        	; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                        	
                        	EXPR3:
FFFC1F3C FFC70713		sub		$sp,$sp,#4
FFFC1F40 00172023		sw		$ra,[$sp]
FFFC1F44 0A0000EF		call	EXPR4		; get first <EXPR4>
                        	XP31:
FFFC1F48 FF870713		sub		$sp,$sp,#8
FFFC1F4C 01072023		sw		v0,[$sp]; yes, save that first result
FFFC1F50 01172223		sw		v1,4[$sp]
FFFC1F54 02A06193		ldi		r3,#'*'
FFFC1F58 FFFC2237		ldi		r4,#XP34
FFFC1F5C F7C20213
FFFC1F60 235000EF		call	TSTC		; multiply?
FFFC1F64 080000EF		call	EXPR4		; get second <EXPR4>
FFFC1F68 00072903		lw		a0,[$sp]
FFFC1F6C 00472983		lw		a1,4[$sp]
FFFC1F70 00870713		add		$sp,$sp,#8
FFFC1F74 03280833		mul		v0,v0,a0	; multiply the two
FFFC1F78 FC0008E3		bra		XP31        ; then look for more terms
                        	XP34:
FFFC1F7C 02F06193		ldi		r3,#'/'
FFFC1F80 FFFC2237		ldi		r4,#XP35
FFFC1F84 FA420213
FFFC1F88 20D000EF		call	TSTC		; divide?
FFFC1F8C 058000EF		call	EXPR4		; get second <EXPR4>
FFFC1F90 00072903		lw		a0,[$sp]
FFFC1F94 00472983		lw		a1,4[$sp]
FFFC1F98 00870713		add		$sp,$sp,#8
FFFC1F9C 03284833		div		v0,v0,a0	; do the division
FFFC1FA0 FA0004E3		bra		XP31		; go back for any more terms
                        	XP35:
FFFC1FA4 02506193		ldi		r3,#'%'
FFFC1FA8 FFFC2237		ldi		r4,#XP47
FFFC1FAC FCC20213
FFFC1FB0 1E5000EF		call	TSTC
FFFC1FB4 030000EF		call	EXPR4
FFFC1FB8 00072903		lw		a0,[$sp]
FFFC1FBC 00472983		lw		a1,4[$sp]
FFFC1FC0 00870713		add		$sp,$sp,#8
FFFC1FC4 03286833		rem		v0,v0,a0
FFFC1FC8 F80000E3		bra		XP31
                        	XP47:
FFFC1FCC 00072803		lw		v0,[$sp]
FFFC1FD0 00472883		lw		v1,4[$sp]
FFFC1FD4 00870713		add		$sp,$sp,#8
FFFC1FD8 00072083		lw		$ra,[$sp]
FFFC1FDC 00470713		add		$sp,$sp,#4
FFFC1FE0 00008067		ret
                        	
                        	
                        	; Functions are called through EXPR4
                        	; <EXPR4>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	
                        	EXPR4:
FFFC1FE4 FFC70713		sub		$sp,$sp,#4
FFFC1FE8 00172023		sw		$ra,[$sp]
FFFC1FEC FFFC1EB7	  ldi		$t3,#TAB4		; find possible function
FFFC1FF0 25AE8E93
FFFC1FF4 FFFC1F37	  ldi		$t4,#TAB4_1
FFFC1FF8 2CCF0F13
FFFC1FFC B14FF06F		jmp		EXEC        ; branch to function which does subsequent ret for EXPR4
                        	XP40:                   ; we get here if it wasn't a function
FFFC2000 00006933		mov		a0,r0
FFFC2004 080000EF		call	TSTV
FFFC2008 00080E63		beq   v0,r0,XP41	; nor a variable
FFFC200C FFC82883		lw		v1,-4[v0]		; get type into v1
FFFC2010 0FF8F893		and		v1,v1,#$FF
FFFC2014 00082803		lw		v0,[v0]		; if a variable, return its value in a0
FFFC2018 00072083		lw		$ra,[$sp]
FFFC201C 00470713		add		$sp,$sp,#4
FFFC2020 00008067		ret
                        	XP41:
FFFC2024 1A9000EF		call	TSTNUM		; or is it a number?
FFFC2028 00089463		bne		v1,r0,XP46	; (if not, # of digits will be zero) if so, return it in a0
FFFC202C 010000EF		call	PARN        ; check for (EXPR)
                        	XP46:
FFFC2030 00072083		lw		$ra,[$sp]
FFFC2034 00470713		add		$sp,$sp,#4
FFFC2038 00008067		ret
                        	
                        	
                        	; Check for a parenthesized expression
                        	PARN:
FFFC203C FFC70713		sub		$sp,$sp,#4
FFFC2040 00172023		sw		$ra,[$sp]	
FFFC2044 02806193		ldi		r3,#'('
FFFC2048 FFFC2237		ldi		r4,#XP43
FFFC204C 07420213
FFFC2050 145000EF		call	TSTC		; else look for ( OREXPR )
FFFC2054 BE5FF0EF		call	OREXPR
FFFC2058 02906193		ldi		r3,#')'
FFFC205C FFFC2237		ldi		r4,#XP43
FFFC2060 07420213
FFFC2064 131000EF		call	TSTC
                        	XP42:
FFFC2068 00072083		lw		$ra,[$sp]
FFFC206C 00470713		add		$sp,$sp,#4
FFFC2070 00008067		ret
                        	XP43:
FFFC2074 00470713		add		$sp,$sp,#4		; get rid of return address
FFFC2078 FFFC3937		ldi		a0,#msgWhat
FFFC207C BAE90913
FFFC2080 41C0006F		jmp		ERROR
                        	
                        	
                        	; ===== Test for a valid variable name.  Returns Z=1 if not
                        	;	found, else returns Z=0 and the address of the
                        	;	variable in a0.
                        	; Parameters
                        	;	a0 = 1 = allocate if not found
                        	; Returns
                        	;	v0 = address of variable, zero if not found
                        	
                        	TSTV:
FFFC2084 FF870713		sub		$sp,$sp,#8
FFFC2088 00572023		sw		r5,[$sp]
FFFC208C 00172223		sw		$ra,4[$sp]
FFFC2090 000962B3		mov		r5,a0		; r5=allocate flag
FFFC2094 1AD000EF		call	IGNBLK
FFFC2098 000E4903		lbu		a0,[$t2]		; look at the program text
FFFC209C 04006D93		ldi		$t1,#'@'
FFFC20A0 07B94263		blt		a0,$t1,tstv_notfound	; C=1: not a variable
FFFC20A4 03B91E63		bne		a0,$t1,TV1				; brnch if not "@" array
FFFC20A8 001E0E13		add		$t2,$t2,#1	; If it is, it should be
FFFC20AC F91FF0EF		call	PARN		; followed by (EXPR) as its index.
                        	;	BCS.L	QHOW		say "How?" if index is too big
FFFC20B0 00000263		bra		TV3
                        	TV3:
FFFC20B4 FFC70713		sub		$sp,$sp,#4	; save the index
FFFC20B8 01272023		sw		a0,[$sp]
FFFC20BC 2D8000EF		call	SIZEX		; get amount of free memory
FFFC20C0 00072983		lw		a1,[$sp]
FFFC20C4 00470713		add		$sp,$sp,#4	; get back the index
FFFC20C8 0109C663		blt		a1,v0,TV2		; see if there's enough memory
FFFC20CC 00870713		add		$sp,$sp,#8
FFFC20D0 3B80006F		jmp   QSORRY		; if not, say "Sorry"
                        	TV2:
FFFC20D4 70802903		lw		a0,VARBGN	; put address of array element...
FFFC20D8 41390933		sub   a0,a0,a1    ; into a0 (neg. offset is used)
FFFC20DC 00000C63		bra   TSTVRT
                        	TV1:	
FFFC20E0 038000EF	  call	getVarName      ; get variable name
FFFC20E4 00080863	  beq   v0,r0,TSTVRT    ; if not, return v0=0
FFFC20E8 00086933	  mov		a0,v0
FFFC20EC 0002E9B3	  mov		a1,r5
FFFC20F0 0E4000EF	  call	findVar     ; find or allocate
                        	TSTVRT:
FFFC20F4 00072283		lw		r5,[$sp]
FFFC20F8 00472083		lw		$ra,4[$sp]
FFFC20FC 00870713		add		$sp,$sp,#8
FFFC2100 00008067		ret					; v0<>0 (found)
                        	tstv_notfound:
FFFC2104 00072283		lw		r5,[$sp]
FFFC2108 00472083		lw		$ra,4[$sp]
FFFC210C 00870713		add		$sp,$sp,#8
FFFC2110 00006833		mov		v0,r0		; v0=0 if not found
FFFC2114 00008067	  ret
                        	
                        	
                        	; Returns
                        	;   v0 = 3 character variable name + type
                        	;
                        	getVarName:
FFFC2118 FF870713		sub		$sp,$sp,#8
FFFC211C 00572023		sw		r5,[$sp]
FFFC2120 00172223		sw		$ra,4[$sp]
FFFC2124 000E4903	  lbu   a0,[$t2]		; get first character
FFFC2128 FFC70713	  sub		$sp,$sp,#4	; save off current name
FFFC212C 01272023	  sw		a0,[$sp]
FFFC2130 BC9FF0EF	  call	isAlpha
FFFC2134 08080463	  beq   v0,r0,gvn1
FFFC2138 00206293	  ldi	  r5,#2       ; loop two more times
                        	
                        		; check for second/third character
                        	gvn4:
FFFC213C 001E0E13		add		$t2,$t2,#1
FFFC2140 000E4903		lbu   a0,[$t2]		; do we have another char ?
FFFC2144 BE5FF0EF		call	isAlnum
FFFC2148 02080C63		beq   v0,r0,gvn2	; nope
FFFC214C 00072903		lw		a0,[$sp]
FFFC2150 00470713		add		$sp,$sp,#4	; get varname
FFFC2154 00891913		sll		a0,a0,#8
FFFC2158 000E4983		lbu   a1,[$t2]
FFFC215C 01396933		or    a0,a0,a1   ; add in new char
FFFC2160 FFC70713	  sub		$sp,$sp,#4	; save off current name again
FFFC2164 01272023	  sw		a0,[$sp]
FFFC2168 FFF28293	  sub		r5,r5,#1
FFFC216C FC5048E3	  bgt		r5,r0,gvn4
                        	
                        	 	; now ignore extra variable name characters
                        	gvn6:
FFFC2170 001E0E13		add		$t2,$t2,#1
FFFC2174 000E4903		lbu   a0,[$t2]		; do we have another char ?
FFFC2178 BB1FF0EF	  call  isAlnum
FFFC217C FE081AE3	  bne   v0,r0,gvn6	; keep looping as long as we have identifier chars
                        	
                        	  ; check for a variable type
                        	gvn2:
FFFC2180 000E4903		lbu   a0,[$t2]
FFFC2184 02506D93		ldi		$t1,#'%'
FFFC2188 01B90863		beq		a0,$t1,gvn3
FFFC218C 02406D93		ldi		$t1,#'$'
FFFC2190 01B90463		beq		a0,$t1,gvn3
FFFC2194 FFFE0E13	  sub		$t2,$t2,#1
                        	
                        	  ; insert variable type indicator and return
                        	gvn3:
FFFC2198 001E0E13		add		$t2,$t2,#1
FFFC219C 00072903		lw		a0,[$sp]
FFFC21A0 00470713		add		$sp,$sp,#4	; get varname
FFFC21A4 00899993		sll		a1,a1,#8
FFFC21A8 01396833	  or    v0,a0,a1    ; add in variable type
FFFC21AC 00072283	  lw		r5,[$sp]
FFFC21B0 00472083	  lw		$ra,4[$sp]
FFFC21B4 00870713	  add		$sp,$sp,#8
FFFC21B8 00008067	  ret					; return Z = 0, a0 = varname
                        	
                        	  ; not a variable name
                        	gvn1:
FFFC21BC 00470713		add		$sp,$sp,#4	; pop a0 (varname)
FFFC21C0 00072283		lw		r5,[$sp]
FFFC21C4 00472083	  lw		$ra,4[$sp]
FFFC21C8 00870713		add		$sp,$sp,#8
FFFC21CC 00006833	  mov		v0,r0       ; return Z = 1 if not a varname
FFFC21D0 00008067	  ret
                        	
                        	
                        	; Find variable
                        	;   a0 = varname
                        	;	a1 = allocate flag
                        	; Returns
                        	;   v0 = variable address, Z =0 if found / allocated, Z=1 if not found
                        	
                        	findVar:
FFFC21D4 FFC70713		sub		$sp,$sp,#4
FFFC21D8 00772023		sw		r7,[$sp]
FFFC21DC 70802183	  lw    r3,VARBGN
                        	fv4:
FFFC21E0 0001A383	  lw    r7,[r3]     ; get varname / type
FFFC21E4 02038063	  beq     r7,r0,fv3	; no more vars ?
FFFC21E8 02790263	  beq     a0,r7,fv1	; match ?
FFFC21EC 00818193		add		r3,r3,#8	; move to next var
FFFC21F0 78402383	  lw      r7,STKBOT
FFFC21F4 FE71C6E3	  blt     r3,r7,fv4	; loop back to look at next var
                        	
                        	  ; variable not found
                        	  ; no more memory
FFFC21F8 FFFC3937	  ldi		a0,#msgVarSpace
FFFC21FC C0190913
FFFC2200 29C0006F	  jmp     ERROR
                        	;    lw      lr,[sp]
                        	;    lw      r7,4[sp]
                        	;    add     sp,sp,#8
                        	;    lw      a0,#0
                        	;    ret
                        	
                        	    ; variable not found
                        	    ; allocate new ?
                        	fv3:
FFFC2204 00098C63		beq		a1,r0,fv2
FFFC2208 0121A023	  sw    a0,[r3]     ; save varname / type
                        	    ; found variable
                        	    ; return address
                        	fv1:
FFFC220C 00418813	  add		v0,r3,#4
FFFC2210 00072383	  lw		r7,[$sp]
FFFC2214 00470713	  add		$sp,$sp,#4
FFFC2218 00008067	  ret			    ; Z = 0, a0 = address
                        	
                        	    ; didn't find var and not allocating
                        	fv2:
FFFC221C 00072383	  lw		r7,[$sp]
FFFC2220 00470713	  add		$sp,$sp,#4
FFFC2224 00006833		mov		v0,r0	; Z = 1, a0 = 0
FFFC2228 00008067	  ret
                        	
                        	
                        	; ===== The PEEK function returns the byte stored at the address
                        	;	contained in the following expression.
                        	;
                        	PEEK:
FFFC222C FFC70713		sub		$sp,$sp,#4
FFFC2230 00172023		sw		$ra,[$sp]
FFFC2234 E09FF0EF		call	PARN		; get the memory address
FFFC2238 00080803		lb		v0,[v0]		; get the addressed byte
FFFC223C 000068B3		mov		v1,x0			; type = int
FFFC2240 00072083		lw		$ra,[$sp]
FFFC2244 00470713		add		$sp,$sp,#4
FFFC2248 00008067		ret
                        	PEEKW:
FFFC224C FFC70713		sub		$sp,$sp,#4
FFFC2250 00172023		sw		$ra,[$sp]
FFFC2254 DE9FF0EF		call	PARN		; get the memory address
FFFC2258 00082803		lw		v0,[v0]		; get the addressed word
FFFC225C 000068B3		mov		v1,x0			; type = int
FFFC2260 00072083		lw		$ra,[$sp]
FFFC2264 00470713		add		$sp,$sp,#4
FFFC2268 00008067		ret
                        	PEEKH:
FFFC226C FFC70713		sub		$sp,$sp,#4
FFFC2270 00172023		sw		$ra,[$sp]
FFFC2274 DC9FF0EF		call	PARN		; get the memory address
FFFC2278 00081803		lh		v0,[v0]		; get the addressed byte
FFFC227C 000068B3		mov		v1,x0			; type = int
FFFC2280 00072083		lw		$ra,[$sp]
FFFC2284 00470713		add		$sp,$sp,#4
FFFC2288 00008067		ret
                        	
                        	
                        	; user function call
                        	; call the user function with argument in a0
                        	USRX:
FFFC228C FFC70713		sub		$sp,$sp,#4
FFFC2290 00172023		sw		$ra,[$sp]
FFFC2294 DA9FF0EF		call	PARN		; get expression value
FFFC2298 FFC70713		sub		$sp,$sp,#4	; save the text pointer
FFFC229C 01C72023		sw		$t2,[$sp]
FFFC22A0 78802983		lw		a1,usrJmp
FFFC22A4 000980E7		call	[a1]			; get usr vector, jump to the subroutine
FFFC22A8 00072E03		lw		$t2,[$sp]	; restore the text pointer
FFFC22AC 00470713		add		$sp,$sp,#4
FFFC22B0 00072083		lw		$ra,[$sp]
FFFC22B4 00470713		add		$sp,$sp,#4
FFFC22B8 00008067		ret
                        	
                        	
                        	; ===== The RND function returns a random number from 1 to
                        	;	the value of the following expression in D0.
                        	;
                        	RND:
FFFC22BC FFC70713		sub		$sp,$sp,#4
FFFC22C0 00172023		sw		$ra,[$sp]
FFFC22C4 D79FF0EF		call	PARN		; get the upper limit
FFFC22C8 04080063		beq		v0,r0,rnd2	; it must be positive and non-zero
FFFC22CC 02084663		blt		v0,r0,rnd1
FFFC22D0 000869B3		mov		a1,v0
FFFC22D4 000868B3		mov		v1,v0
FFFC22D8 00000637		call	gen_rand	; generate a random number
FFFC22DC 1EF600E7
FFFC22E0 03186833		rem		v0,v0,v1
FFFC22E4 00180813		add		v0,v0,#1
FFFC22E8 000068B3		mov		v1,x0
FFFC22EC 00072083		lw		$ra,[$sp]
FFFC22F0 00470713		add		$sp,$sp,#4
FFFC22F4 00008067		ret
                        	rnd1:
FFFC22F8 FFFC3937		ldi		a0,#msgRNDBad
FFFC22FC C7290913
FFFC2300 00470713		add		$sp,$sp,#4
FFFC2304 1980006F		jmp		ERROR
                        	rnd2:
FFFC2308 00000637		call	gen_rand	; generate a random number
FFFC230C 1EF600E7
FFFC2310 000068B3		mov		v1,x0
FFFC2314 00072083		lw		$ra,[$sp]
FFFC2318 00470713		add		$sp,$sp,#4
FFFC231C 00008067		ret
                        	
                        	; ===== The ABS function returns an absolute value in a1.
                        	;
                        	ABS:
FFFC2320 FFC70713		sub		$sp,$sp,#4
FFFC2324 00172023		sw		$ra,[$sp]
FFFC2328 D15FF0EF		call	PARN		; get the following expr.'s value
FFFC232C 00084863		blt		v0,r0,ABS1
FFFC2330 00072083		lw		$ra,[$sp]
FFFC2334 00470713		add		$sp,$sp,#4
FFFC2338 00008067		ret
                        	ABS1:
FFFC233C 41000833		sub		v0,r0,v0
FFFC2340 00072083		lw		$ra,[$sp]
FFFC2344 00470713		add		$sp,$sp,#4
FFFC2348 00008067		ret
                        	
                        	
                        	;==== The TICK function returns the cpu tick value in a0.
                        	;
                        	TICKX:
FFFC234C C0001873		csrrw	v0,#$C00,r0
FFFC2350 00008067		ret
                        	
                        	; ===== The SGN function returns the sign in a0. +1,0, or -1
                        	;
                        	SGN:
FFFC2354 FFC70713		sub		$sp,$sp,#4
FFFC2358 00172023		sw		$ra,[$sp]
FFFC235C CE1FF0EF		call	PARN		; get the following expr.'s value
FFFC2360 02080463		beq		v0,r0,SGN1
FFFC2364 00084A63		blt		v0,r0,SGN2
FFFC2368 00106813		ldi		v0,#1
FFFC236C 00072083		lw		$ra,[$sp]
FFFC2370 00470713		add		$sp,$sp,#4
FFFC2374 00008067		ret
                        	SGN2:
FFFC2378 FFF06813		ldi		v0,#-1
FFFC237C 00072083		lw		$ra,[$sp]
FFFC2380 00470713		add		$sp,$sp,#4
FFFC2384 00008067		ret
                        	SGN1:
FFFC2388 00072083		lw		$ra,[$sp]
FFFC238C 00470713		add		$sp,$sp,#4
FFFC2390 00008067		ret	
                        	
                        	; ===== The SIZE function returns the size of free memory in v0.
                        	;
                        	SIZEX:
FFFC2394 70802803		lw		v0,VARBGN	; get the number of free bytes...
FFFC2398 70402883		lw		v1,TXTUNF	; between 'TXTUNF' and 'VARBGN'
FFFC239C 41180833		sub		v0,v0,v1
FFFC23A0 00008067		ret					; return the number in a0
                        	
                        	
                        	;******************************************************************
                        	;
                        	; *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                        	;
                        	; 'SETVAL' expects a variable, followed by an equal sign and then
                        	; an expression.  It evaluates the expression and sets the variable
                        	; to that value.
                        	;
                        	; returns
                        	; a1 = variable's address
                        	;
                        	SETVAL:
FFFC23A4 FFC70713		sub		$sp,$sp,#4
FFFC23A8 00172023		sw		$ra,[$sp]
FFFC23AC 00106913	  ldi		a0,#1		; allocate var
FFFC23B0 CD5FF0EF	  call	TSTV		; variable name?
FFFC23B4 00091A63	  bne		a0,r0,.sv2
FFFC23B8 FFFC3937	 	ldi		a0,#msgVar
FFFC23BC C5B90913
FFFC23C0 00470713		add		$sp,$sp,#4
FFFC23C4 0D80006F	 	jmp		ERROR 
                        	.sv2:
FFFC23C8 FFC70713		sub		$sp,$sp,#4
FFFC23CC 01272023		sw		a0,[$sp]	; save the variable's address
FFFC23D0 03D06193		ldi		r3,#'='
FFFC23D4 FFFC2237		ldi		r4,#SV1
FFFC23D8 40020213
FFFC23DC 5B8000EF		call	TSTC			; get past the "=" sign
FFFC23E0 859FF0EF		call	OREXPR		; evaluate the expression
FFFC23E4 00072983		lw		a1,[$sp]	; get back the variable's address
FFFC23E8 00470713		add		$sp,$sp,#4
FFFC23EC 0129A023		sw    a0,[a1]   ; and save value in the variable
FFFC23F0 0009E933		mov		a0,a1		; return a0 = variable address
FFFC23F4 00072083		lw		$ra,[$sp]
FFFC23F8 00470713		add		$sp,$sp,#4
FFFC23FC 00008067		ret
                        	SV1:
FFFC2400 00470713		add		$sp,$sp,#4
FFFC2404 0900006F	  jmp	    QWHAT		; if no "=" sign
                        	
                        	
                        	; 'FIN' checks the end of a command.  If it ended with ":",
                        	; execution continues.	If it ended with a CR, it finds the
                        	; the next line and continues from there.
                        	;
                        	FIN:
FFFC2408 FFC70713		sub		$sp,$sp,#4
FFFC240C 00172023		sw		$ra,[$sp]
FFFC2410 03A06193		ldi		r3,#':'
FFFC2414 FFFC2237		ldi		r4,#FI1
FFFC2418 42820213
FFFC241C 578000EF		call	TSTC		; *** FIN ***
FFFC2420 00470713		add		$sp,$sp,#4	; if ":", discard return address
FFFC2424 FF5FE06F		jmp		RUNSML		; continue on the same line
                        	FI1:
FFFC2428 00D06193		ldi		r3,#CR
FFFC242C FFFC2237		ldi		r4,#FI2
FFFC2430 44020213
FFFC2434 560000EF		call	TSTC		; not ":", is it a CR?
                        							; else return to the caller
FFFC2438 00470713		add		$sp,$sp,#4	; yes, purge return address
FFFC243C F79FE06F		jmp		RUNNXL		; execute the next line
                        	FI2:
FFFC2440 00072083		lw		$ra,[$sp]
FFFC2444 00470713		add		$sp,$sp,#4
FFFC2448 00008067		ret					; else return to the caller
                        	
                        	
                        	; 'ENDCHK' checks if a command is ended with a CR. This is
                        	; required in certain commands, such as GOTO, RETURN, STOP, etc.
                        	;
                        	; Check that there is nothing else on the line
                        	; Registers Affected
                        	;   a0
                        	;
                        	ENDCHK:
FFFC244C FFC70713		sub		$sp,$sp,#4
FFFC2450 00172023		sw		$ra,[$sp]
FFFC2454 5EC000EF		call	IGNBLK
FFFC2458 000E4903		lbu		a0,[$t2]
FFFC245C 00D06D93		ldi		$t1,#CR
FFFC2460 01B90863		beq		a0,$t1,ec1	; does it end with a CR?
FFFC2464 FFFC3937		ldi		a0,#msgExtraChars
FFFC2468 D3590913
FFFC246C 0300006F		jmp		ERROR
                        	ec1:
FFFC2470 00072083		lw		$ra,[$sp]
FFFC2474 00470713		add		$sp,$sp,#4
FFFC2478 00008067		ret
                        	
                        	; 'ERROR' prints the string pointed to by a0. It then prints the
                        	; line pointed to by CURRNT with a "?" inserted at where the
                        	; old text pointer (should be on top of the stack) points to.
                        	; Execution of Tiny BASIC is stopped and a warm start is done.
                        	; If CURRNT is zero (indicating a direct command), the direct
                        	; command is not printed. If CURRNT is -1 (indicating
                        	; 'INPUT' command in progress), the input line is not printed
                        	; and execution is not terminated but continues at 'INPERR'.
                        	;
                        	; Related to 'ERROR' are the following:
                        	; 'QWHAT' saves text pointer on stack and gets "What?" message.
                        	; 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                        	; 'QSORRY' and 'ASORRY' do the same kind of thing.
                        	; 'QHOW' and 'AHOW' also do this for "How?".
                        	;
                        	TOOBIG:
FFFC247C FFFC3937		ldi		a0,#msgTooBig
FFFC2480 D2090913
FFFC2484 00000C63		bra		ERROR
                        	QSORRY:
FFFC2488 FFFC3937	  ldi		a0,#SRYMSG
FFFC248C BB690913
FFFC2490 00000663		bra	    ERROR
                        	QWHAT:
FFFC2494 FFFC3937		ldi		a0,#msgWhat
FFFC2498 BAE90913
                        	ERROR:
FFFC249C 684000EF		call	PRMESG		; display the error message
FFFC24A0 71402903		lw		a0,CURRNT	; get the current line pointer
FFFC24A4 02090C63		beq		a0,r0,ERROR1	; if zero, do a warm start
FFFC24A8 FFF06D93		ldi		$t1,#-1
FFFC24AC ADB90863		beq		a0,$t1,INPERR	; is the line no. pointer = -1? if so, redo input
FFFC24B0 000E4283		lbu		r5,[$t2]		; save the char. pointed to
FFFC24B4 000E0023		sb		x0,[$t2]		; put a zero where the error is
FFFC24B8 71402903		lw		a0,CURRNT	; point to start of current line
FFFC24BC 494000EF		call	PRTLN		; display the line in error up to the 0
FFFC24C0 00096333		mov     r6,a0	    ; save off end pointer
FFFC24C4 005E0023		sb		r5,[$t2]		; restore the character
FFFC24C8 03F06913		ldi		a0,#'?'		; display a "?"
FFFC24CC B3DFE0EF		call	GOOUT
FFFC24D0 000069B3		mov		a1,r0		; stop char = 0
FFFC24D4 FFF30913		sub		a0,r6,#1	; point back to the error char.
FFFC24D8 20C000EF		call	PRTSTG		; display the rest of the line
                        	ERROR1:
FFFC24DC BE9FE06F		jmp	    WSTART		; and do a warm start
                        	
                        	;******************************************************************
                        	;
                        	; *** GETLN *** FNDLN (& friends) ***
                        	;
                        	; 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                        	; the character in r3 (given by the caller), then it fills the
                        	; buffer and echos. It ignores LF's but still echos
                        	; them back. Control-H is used to delete the last character
                        	; entered (if there is one), and control-X is used to delete the
                        	; whole line and start over again. CR signals the end of a line,
                        	; and causes 'GETLN' to return.
                        	;
                        	;
                        	GETLN:
FFFC24E0 FF870713		sub		$sp,$sp,#8
FFFC24E4 00572023		sw		r5,[$sp]
FFFC24E8 00172223		sw		$ra,4[$sp]
FFFC24EC B1DFE0EF		call	GOOUT		; display the prompt
FFFC24F0 00106913		ldi		a0,#1
                        	;	sw		a0,CursorFlash	; turn on cursor flash
FFFC24F4 02006913		ldi		a0,#' '		; and a space
FFFC24F8 B11FE0EF		call	GOOUT
FFFC24FC 71806E13		ldi		$t2,#BUFFER	; $t2 is the buffer pointer
                        	.GL1:
FFFC2500 5F0000EF		call	CHKIO		; check keyboard
FFFC2504 FE080EE3		beq		v0,x0,.GL1	; wait for a char. to come in
FFFC2508 00806D93		ldi		$t1,#CTRLH
FFFC250C 05B80663		beq		v0,$t1,.GL3	; delete last character? if so
FFFC2510 01806D93		ldi		$t1,#CTRLX
FFFC2514 07B80663		beq		v0,$t1,.GL4	; delete the whole line?
FFFC2518 00D06D93		ldi		$t1,#CR
FFFC251C 01B80663		beq		v0,$t1,.GL2		; accept a CR
FFFC2520 02006D93		ldi		$t1,#' '
FFFC2524 FDB84EE3		blt		v0,$t1,.GL1	; if other control char., discard it
                        	.GL2:
FFFC2528 010E0023		sb		v0,[$t2]		; save the char.
FFFC252C 001E0E13		add		$t2,$t2,#1
FFFC2530 FFC70713		sub		$sp,$sp,#4
FFFC2534 01072023		sw		v0,[$sp]
FFFC2538 00086933		mov		$a0,$v0
FFFC253C ACDFE0EF		call	GOOUT		; echo the char back out
FFFC2540 00072803		lw		v0,[$sp]; get char back (GOOUT destroys a0)
FFFC2544 00470713		add		$sp,$sp,#4
FFFC2548 00D06D93		ldi		$t1,#CR
FFFC254C 07B80663		beq		v0,$t1,.GL7			; if it's a CR, end the line
FFFC2550 76B06D93		ldi		$t1,#BUFFER+BUFLEN-1
FFFC2554 FBBE46E3		blt		$t2,$t1,.GL1		; any more room? ; yes: get some more, else delete last char.
                        	.GL3:
FFFC2558 00806913		ldi		a0,#CTRLH	; delete a char. if possible
FFFC255C AADFE0EF		call	GOOUT
FFFC2560 02006913		ldi		a0,#' '
FFFC2564 AA5FE0EF		call	GOOUT
FFFC2568 71806D93		ldi		$t1,#BUFFER
FFFC256C F9CDDAE3		ble		$t2,$t1,.GL1	; any char.'s left?	; if not
FFFC2570 00806913		ldi		a0,#CTRLH		; if so, finish the BS-space-BS sequence
FFFC2574 A95FE0EF		call	GOOUT
FFFC2578 FFFE0E13		sub		$t2,$t2,#1	; decrement the text pointer
FFFC257C F80002E3		bra		.GL1		; back for more
                        	.GL4:
FFFC2580 000E6933		mov		a0,$t2		; delete the whole line
FFFC2584 8E890293		sub		r5,a0,#BUFFER   ; figure out how many backspaces we need
FFFC2588 02028463		beq		r5,r0,.GL6		; if none needed, brnch
FFFC258C FFF28293		sub		r5,r5,#1		; loop count is one less
                        	.GL5:
FFFC2590 00806913		ldi		a0,#CTRLH		; and display BS-space-BS sequences
FFFC2594 A75FE0EF		call	GOOUT
FFFC2598 02006913		ldi		a0,#' '
FFFC259C A6DFE0EF		call	GOOUT
FFFC25A0 00806913		ldi		a0,#CTRLH
FFFC25A4 A65FE0EF		call	GOOUT
FFFC25A8 FFF28293		sub		r5,r5,#1
FFFC25AC FE0292E3		bne		r5,r0,.GL5
                        	.GL6:
FFFC25B0 71806E13		ldi		$t2,#BUFFER	; reinitialize the text pointer
FFFC25B4 F40006E3		bra		.GL1		; and go back for more
                        	.GL7:
FFFC25B8 000E0023		sb		x0,[$t2]		; null terminate line
                        	;	sw		x0,CursorFlash	; turn off cursor flash
FFFC25BC 00A06913		ldi		a0,#LINEFD	; echo a LF for the CR
FFFC25C0 A49FE0EF		call	GOOUT
FFFC25C4 00072283		lw		r5,[$sp]
FFFC25C8 00472083		lw		$ra,4[$sp]
FFFC25CC 00870713		add		$sp,$sp,#8
FFFC25D0 00008067		ret
                        	
                        	
                        	; 'FNDLN' finds a line with a given line no. (in a0) in the
                        	; text save area.  $t3 is used as the text pointer. If the line
                        	; is found, $t3 will point to the beginning of that line
                        	; (i.e. the high byte of the line no.), and $v0 = 1.
                        	; If that line is not there and a line with a higher line no.
                        	; is found, $t3 points there and $v0 = 0. If we reached
                        	; the end of the text save area and cannot find the line, flags
                        	; $t3 = 0, $v0 = 0.
                        	; $v0=1 if line found
                        	; r0 = 1	<= line is found
                        	;	$t3 = pointer to line
                        	; r0 = 0    <= line is not found
                        	;	r9 = zero, if end of text area
                        	;	r9 = otherwise higher line number
                        	;
                        	; 'FNDLN' will initialize $t3 to the beginning of the text save
                        	; area to start the search. Some other entries of this routine
                        	; will not initialize $t3 and do the search.
                        	; 'FNDLNP' will start with $t3 and search for the line no.
                        	; 'FNDNXT' will bump $t3 by 4, find a CR and then start search.
                        	; 'FNDSKP' uses $t3 to find a CR, and then starts the search.
                        	; return Z=1 if line is found, r9 = pointer to line
                        	;
                        	; Parameters
                        	;	a0 = line number to find
                        	;
                        	FNDLN:
FFFC25D4 00100DB7		ldi		$t1,#$FFFFF
FFFC25D8 FFFD8D93
FFFC25DC 01B94863		blt		a0,$t1,fl1	; line no. must be < 65535
FFFC25E0 FFFC3937		ld		a0,#msgLineRange
FFFC25E4 C4590913
FFFC25E8 EB5FF06F		jmp		ERROR
                        	fl1:
FFFC25EC 00002EB7		ld		$t3,#TXTBGN	; init. the text save pointer
FFFC25F0 800E8E93
                        	
                        	FNDLNP:
FFFC25F4 70402F03		lw		$t4,TXTUNF	; check if we passed the end
FFFC25F8 01EEDC63		bge		$t3,$t4,FNDRET1; if so, return with r9=0,a0=0
FFFC25FC 000EA803		lw		v0,[$t3]		; get line number
FFFC2600 01280C63		beq		v0,a0,FNDRET2
FFFC2604 01284E63		blt		v0,a0,FNDNXT	; is this the line we want? no, not there yet
                        	FNDRET:
FFFC2608 00006833		mov		v0,x0	; line not found, but $t3=next line pointer
FFFC260C 00008067		ret			; return the cond. codes
                        	FNDRET1:
                        	;	eor		r9,r9,r9	; no higher line
FFFC2610 00006833		mov		v0,x0	; line not found
FFFC2614 00008067		ret
                        	FNDRET2:
FFFC2618 00106813		ld		v0,#1	; line found
FFFC261C 00008067		ret
                        	
                        	FNDNXT:
FFFC2620 004E8E93		add		$t3,$t3,#4	; find the next line
                        	
                        	FNDSKP:
FFFC2624 000EC883		lbu		v1,[$t3]
FFFC2628 001E8E93		add		$t3,$t3,#1
FFFC262C 00D06D93		ldi		$t1,#CR
FFFC2630 FFB89AE3		bne		v1,$t1,FNDSKP	; try to find a CR, keep looking
FFFC2634 FC0000E3		bra		FNDLNP		; check if end of text
                        	
                        	
                        	;******************************************************************
                        	; 'MVUP' moves a block up from where a0 points to where a1 points
                        	; until a0=r3
                        	;
                        	MVUP1:
FFFC2638 00090203		lb		r4,[a0]
FFFC263C 00498023		sb		r4,[a1]
FFFC2640 00190913		add		a0,a0,#1
FFFC2644 00198993		add		a1,a1,#1
                        	MVUP:
FFFC2648 FE3918E3		bne		a0,r3,MVUP1
                        	MVRET:
FFFC264C 00008067		ret
                        	
                        	
                        	; 'MVDOWN' moves a block down from where a0 points to where a1
                        	; points until a0=r3
                        	;
                        	MVDOWN1:
FFFC2650 FFF90913		sub		a0,a0,#1
FFFC2654 FFF98993		sub		a1,a1,#1
FFFC2658 00090203		lb		r4,[a0]
FFFC265C 00498023		sb		r4,[a1]
                        	MVDOWN:
FFFC2660 FE3918E3		bne		a0,r3,MVDOWN1
FFFC2664 00008067		ret
                        	
                        	
                        	; 'POPA_' restores the 'FOR' loop variable save area from the stack
                        	;
                        	; 'PUSHA_' stacks for 'FOR' loop variable save area onto the stack
                        	;
                        	; Note: a single zero word is stored on the stack in the
                        	; case that no FOR loops need to be saved. This needs to be
                        	; done because PUSHA_ / POPA_ is called all the time.
                        	//message "POPA_"
                        	POPA_:
FFFC2668 00072903		lw		a0,[$sp]
FFFC266C 00470713		add		$sp,$sp,#4
FFFC2670 71202623		sw		a0,LOPVAR	; restore LOPVAR, but zero means no more
FFFC2674 02090463		beq		a0,r0,PP1
FFFC2678 00072903		lw		a0,[$sp]
FFFC267C 77202623		sw		a0,LOPPT
FFFC2680 00472903		lw		a0,4[$sp]
FFFC2684 77202823		sw		a0,LOPLN
FFFC2688 00872903		lw		a0,8[$sp]
FFFC268C 77202C23		sw		a0,LOPLMT
FFFC2690 00C72903		lw		a0,12[$sp]
FFFC2694 77202A23		sw		a0,LOPINC
FFFC2698 01070713		add		$sp,$sp,#16
                        	PP1:
FFFC269C 00008067		ret
                        	
                        	
                        	PUSHA_:
FFFC26A0 78402903		lw		a0,STKBOT	; Are we running out of stack room?
FFFC26A4 01490913		add		a0,a0,#20	; we might need this many bytes
FFFC26A8 DF2740E3		blt		$sp,a0,QSORRY	; out of stack space
FFFC26AC 70C02983		lw		a1,LOPVAR		; save loop variables
FFFC26B0 02098463		beq		a1,r0,PU1		; if LOPVAR is zero, that's all
FFFC26B4 FF070713		sub		$sp,$sp,#16
FFFC26B8 76C02903		lw		a0,LOPPT
FFFC26BC 01272023		sw		a0,[$sp]
FFFC26C0 77002903		lw		a0,LOPLN
FFFC26C4 01272223		sw		a0,4[$sp]
FFFC26C8 77802903		lw		a0,LOPLMT
FFFC26CC 01272423		sw		a0,8[$sp]
FFFC26D0 77402903		lw		a0,LOPINC
FFFC26D4 01272623		sw		a0,12[$sp]
                        	PU1:
FFFC26D8 FFC70713		sub		$sp,$sp,#4
FFFC26DC 01372023		sw		a1,[$sp]
FFFC26E0 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	;
                        	; 'PRTSTG' prints a string pointed to by a0. It stops printing
                        	; and returns to the caller when either a CR is printed or when
                        	; the next byte is the same as what was passed in a1 by the
                        	; caller.
                        	;
                        	; 'PRTLN' prints the saved text line pointed to by r3
                        	; with line no. and all.
                        	;
                        	
                        	; a0 = pointer to string
                        	; a1 = stop character
                        	; return a0 = pointer to end of line + 1
                        	
                        	PRTSTG:
FFFC26E4 FF070713		sub		$sp,$sp,#16
FFFC26E8 00572023		sw		r5,[$sp]
FFFC26EC 00672223		sw		r6,4[$sp]
FFFC26F0 00772423		sw		r7,8[$sp]
FFFC26F4 00172623		sw		$ra,12[$sp]
FFFC26F8 000962B3		mov   r5,a0	    ; r5 = pointer
FFFC26FC 0009E333		mov   r6,a1	    ; r6 = stop char
                        	.PS1:
FFFC2700 0002C383	  lbu   r7,[r5]     ; get a text character
FFFC2704 00128293		add		r5,r5,#1
FFFC2708 00638E63		beq	  r7,r6,.PRTRET	; same as stop character? if so, return
FFFC270C 0003E933		mov   a0,r7
FFFC2710 8F9FE0EF		call	GOOUT		; display the char.
FFFC2714 00D06D93		ldi		$t1,#CR
FFFC2718 FFB394E3		bne   r7,$t1,.PS1	; is it a C.R.? no, go back for more
FFFC271C 00A06913		ldi		a0,#LINEFD  ; yes, add a L.F.
FFFC2720 8E9FE0EF		call	GOOUT
                        	.PRTRET:
FFFC2724 0003E9B3	  mov   a1,r7	    ; return a1 = stop char
FFFC2728 0002E933		mov		a0,r5		; return a0 = line pointer
FFFC272C 00072283		lw		$r5,[$sp]
FFFC2730 00472303		lw		$r6,4[$sp]
FFFC2734 00872383		lw		$r7,8[$sp]
FFFC2738 00C72083		lw		$ra,12[$sp]
FFFC273C 01070713		add		$sp,$sp,#16
FFFC2740 00008067	  ret					; then return
                        	
                        	
                        	; 'QTSTG' looks for an underline (back-arrow on some systems),
                        	; single-quote, or double-quote.  If none of these are found, returns
                        	; to the caller.  If underline, outputs a CR without a LF.  If single
                        	; or double quote, prints the quoted string and demands a matching
                        	; end quote.  After the printing, the next i-word of the caller is
                        	; skipped over (usually a branch instruction).
                        	;
                        	QTSTG:
FFFC2744 FFC70713		sub		$sp,$sp,#4
FFFC2748 00172023		sw		$ra,[$sp]
FFFC274C 02206193		ldi		r3,#'"'
FFFC2750 FFFC2237		ldi		r4,#QT3
FFFC2754 77820213
FFFC2758 23C000EF		call	TSTC		; *** QTSTG ***
FFFC275C 02206993		ldi		a1,#'"'		; it is a "
                        	QT1:
FFFC2760 000E6933		mov		a0,$t2
FFFC2764 F81FF0EF		call	PRTSTG		; print until another
FFFC2768 00096E33		mov		$t2,a0
FFFC276C 00D06D93		ldi		$t1,#CR
FFFC2770 03B99C63		bne		a1,$t1,QT2	; was last one a CR?
FFFC2774 C41FE06F		jmp		RUNNXL		; if so run next line
                        	QT3:
FFFC2778 02706193		ldi		r3,#'\''
FFFC277C FFFC2237		ldi		r4,#QT4
FFFC2780 79020213
FFFC2784 210000EF		call	TSTC		; is it a single quote?
FFFC2788 02706993		ldi		a1,#'\''	; if so, do same as above
FFFC278C FC000AE3		bra		QT1
                        	QT4:
FFFC2790 05F06193		ldi		r3,#'_'
FFFC2794 FFFC2237		ldi		r4,#QT5
FFFC2798 7B820213
FFFC279C 1F8000EF		call	TSTC		; is it an underline?
FFFC27A0 00D06913		ldi		a0,#CR		; if so, output a CR without LF
FFFC27A4 865FE0EF		call	GOOUT
                        	QT2:
FFFC27A8 00072083		lw		$ra,[$sp]		; get return address
FFFC27AC 00470713		add		$sp,$sp,#4
FFFC27B0 00408093		add		$ra,$ra,#4	; add 4 to it in order to skip following branch
FFFC27B4 00008067		ret
                        	QT5:					; not " ' or _
FFFC27B8 00072083		lw		$ra,[$sp]		; get return address
FFFC27BC 00470713		add		$sp,$sp,#4
FFFC27C0 00008067		ret
                        	
                        	; Output a CR LF sequence
                        	;
                        	prCRLF:
FFFC27C4 FFC70713		sub		$sp,$sp,#4
FFFC27C8 00172023		sw		$ra,[$sp]
FFFC27CC 00D06913		ldi		a0,#CR
FFFC27D0 839FE0EF		call	GOOUT
FFFC27D4 00A06913		ldi		a0,#LINEFD
FFFC27D8 831FE0EF		call	GOOUT
FFFC27DC 00072083		lw		$ra,[$sp]
FFFC27E0 00470713		add		$sp,$sp,#4
FFFC27E4 00008067		ret
                        	
                        	; 'PRTNUM' prints the 32 bit number in a0, leading blanks are added if
                        	; needed to pad the number of spaces to the number in a1.
                        	; However, if the number of digits is larger than the no. in
                        	; a1, all digits are printed anyway. Negative sign is also
                        	; printed and counted in, positive sign is not.
                        	;
                        	; a0 = number to print
                        	; a1 = number of digits
                        	; Register Usage
                        	;	r5 = number of padding spaces
FFFC27E8 FEC70713	public PRTNUM:
	sub		$sp,$sp,#20
FFFC27EC 00472023		sw		$s1,[$sp]
FFFC27F0 00572223		sw		$s2,4[$sp]
FFFC27F4 00672423		sw		$s3,8[$sp]
FFFC27F8 00772623		sw		$s4,12[$sp]
FFFC27FC 00172823		sw		$ra,16[$sp]
FFFC2800 77C06393		ldi		s4,#NUMWKA	; r7 = pointer to numeric work area
FFFC2804 00096333		mov		s3,a0		; save number for later
FFFC2808 0009E2B3		mov		s2,a1		; r5 = min number of chars
FFFC280C 00095663		bge		a0,x0,PN2	; is it negative? if not
FFFC2810 41200933		sub		a0,x0,a0	; else make it positive
FFFC2814 FFF28293		sub		s2,s2,#1	; one less for width count
                        	PN2:
FFFC2818 00A06D93		ldi		$t1,#10
                        	PN1:
FFFC281C 03B969B3		rem		a1,a0,$t1	; a1 = a0 mod 10
FFFC2820 03B94933		div		a0,a0,$t1	; a0 /= 10 divide by 10
FFFC2824 03098993		add		a1,a1,#'0'	; convert remainder to ascii
FFFC2828 01338023		sb		a1,[$s4]		; and store in buffer
FFFC282C 00138393		add		s4,s4,#1
FFFC2830 FFF28293		sub		s2,s2,#1	; decrement width
FFFC2834 FE0914E3		bne		a0,r0,PN1
                        	PN6:
FFFC2838 00505A63		ble		$s2,$x0,PN4	; test pad count, skip padding if not needed
                        	PN3:
FFFC283C 02006913		ldi		$a0,#' '		; display the required leading spaces
FFFC2840 FC8FE0EF		call	GOOUT
FFFC2844 FFF28293		sub		$s2,$s2,#1
FFFC2848 FE504AE3		bgt		$s2,$x0,PN3
                        	PN4:
FFFC284C 00035663		bge		$s3,$x0,PN5	; is number negative?
FFFC2850 02D06913		ldi		$a0,#'-'		; if so, display the sign
FFFC2854 FB4FE0EF		call	GOOUT
                        	PN5:
FFFC2858 FFF38393		sub		$s4,$s4,#1
FFFC285C 0003C903		lbu		$a0,[$s4]		; now unstack the digits and display
FFFC2860 FA8FE0EF		call	GOOUT
FFFC2864 77C06D93		ldi		$t1,#NUMWKA
FFFC2868 FE7DE8E3		bgtu	$s4,$t1,PN5
                        	PNRET:
FFFC286C 00072203		lw		$s1,[$sp]
FFFC2870 00472283		lw		$s2,4[$sp]
FFFC2874 00872303		lw		$s3,8[$sp]
FFFC2878 00C72383		lw		$s4,12[$sp]
FFFC287C 01072083		lw		$ra,16[$sp]
FFFC2880 01470713		add		$sp,$sp,#20
FFFC2884 00008067		ret
                        	
                        	; a0 = number to print
                        	; a1 = number of digits
FFFC2888 FE870713	public PRTHEXNUM:
	sub		$sp,$sp,#24
FFFC288C 00472023		sw		$r4,[$sp]
FFFC2890 00572223		sw		$r5,4[$sp]
FFFC2894 00672423		sw		$r6,8[$sp]
FFFC2898 00772623		sw		$r7,12[$sp]
FFFC289C 00872823		sw		$r8,16[$sp]
FFFC28A0 00172A23		sw		$ra,20[$sp]
FFFC28A4 77C06393		ldi		r7,#NUMWKA	; r7 = pointer to numeric work area
FFFC28A8 00096333		mov		r6,a0		; save number for later
                        	;	setlo	r5,#20		; r5 = min number of chars
FFFC28AC 0009E2B3		mov		r5,a1
FFFC28B0 00096233		mov		r4,a0
FFFC28B4 00025663		bge		r4,r0,PHN2	; is it negative? if not
FFFC28B8 40400233		sub		r4,r0,r4	; else make it positive
FFFC28BC FFF28293		sub		r5,r5,#1	; one less for width count
                        	PHN2:
FFFC28C0 00A06413		ldi		r8,#10		; maximum of 10 digits
                        	PHN1:
FFFC28C4 00026933		mov		a0,r4
FFFC28C8 00F97913		and		a0,a0,#15
FFFC28CC 00A06D93		ldi		$t1,#10
FFFC28D0 01B96663		bltu	a0,$t1,PHN7
FFFC28D4 03790913		add		a0,a0,#'A'-10
FFFC28D8 00000463		bra		PHN8
                        	PHN7:
FFFC28DC 03090913		add		a0,a0,#'0'	; convert remainder to ascii
                        	PHN8:
FFFC28E0 01238023		sb		a0,[r7]		; and store in buffer
FFFC28E4 00138393		add		r7,r7,#1
FFFC28E8 FFF28293		sub		r5,r5,#1	; decrement width
FFFC28EC 00425213		srl		r4,r4,#4
FFFC28F0 00020663		beq		r4,r0,PHN6	; is it zero yet ?
FFFC28F4 FFF40413		sub		r8,r8,#1
FFFC28F8 FC8046E3		bgt		r8,r0,PHN1
                        	PHN6:	; test pad count	
FFFC28FC 00505A63		ble		r5,r0,PHN4	; skip padding if not needed
                        	PHN3:
FFFC2900 02006913		ldi		a0,#' '		; display the required leading spaces
FFFC2904 F04FE0EF		call	GOOUT
FFFC2908 FFF28293		sub		r5,r5,#1
FFFC290C FE504AE3		bgt		r5,r0,PHN3
                        	PHN4:
FFFC2910 00035663		bge		r6,r0,PHN5	; is number negative?
FFFC2914 02D06913		ldi		a0,#'-'		; if so, display the sign
FFFC2918 EF0FE0EF		call	GOOUT
                        	PHN5:
FFFC291C FFF38393		sub		r7,r7,#1
FFFC2920 0003C903		lbu		a0,[r7]		; now unstack the digits and display
FFFC2924 EE4FE0EF		call	GOOUT
FFFC2928 77C06D93		ldi		$t1,#NUMWKA
FFFC292C FE7DC8E3		bgt		r7,$t1,PHN5
                        	PHNRET:
FFFC2930 00072203		lw		$r4,[$sp]
FFFC2934 00472283		lw		$r5,4[$sp]
FFFC2938 00872303		lw		$r6,8[$sp]
FFFC293C 00C72383		lw		$r7,12[$sp]
FFFC2940 01072403		lw		$r8,16[$sp]
FFFC2944 01472083		lw		$ra,20[$sp]
FFFC2948 01870713		add		$sp,$sp,#24
FFFC294C 00008067		ret
                        	
                        	; a0 = pointer to line
                        	; returns a0 = pointer to end of line + 1
                        	PRTLN:
FFFC2950 FF870713		sub		$sp,$sp,#8
FFFC2954 00572023		sw		$r5,[$sp]
FFFC2958 00172223		sw		$ra,4[$sp]
FFFC295C 000962B3	  mov		$r5,$a0		; r5 = pointer
FFFC2960 0002A903	  lw		$a0,[$r5]		; get the binary line number
FFFC2964 00428293		add		r5,r5,#4
FFFC2968 00506993	  ldi		a1,#5       ; display a 0 or more digit line no.
FFFC296C E7DFF0EF		call	PRTNUM
FFFC2970 02006913		ldi		a0,#' '     ; followed by a blank
FFFC2974 E94FE0EF		call	GOOUT
FFFC2978 000069B3		mov		a1,r0       ; stop char. is a zero
FFFC297C 0002E933		mov		a0,r5
FFFC2980 D65FF0EF		call  PRTSTG		; display the rest of the line
FFFC2984 00072283		lw		$r5,[$sp]
FFFC2988 00472083		lw		$ra,4[$sp]
FFFC298C 00870713		add		$sp,$sp,#8
FFFC2990 00008067		ret
                        	
                        	
                        	; ===== Test text byte following the call to this subroutine. If it
                        	;	equals the byte pointed to by r8, return to the code following
                        	;	the call. If they are not equal, brnch to the point
                        	;	indicated in r4.
                        	;
                        	; Registers Affected
                        	;   r3,r8
                        	; Returns
                        	;	r8 = updated text pointer
                        	;
                        	TSTC:
FFFC2994 FF870713		sub		$sp,$sp,#8
FFFC2998 01272023		sw		$a0,[$sp]
FFFC299C 00172223		sw		$ra,4[$sp]
FFFC29A0 0A0000EF		call	IGNBLK		; ignore leading blanks
FFFC29A4 000E4903		lbu		$a0,[$t2]
FFFC29A8 01218863		beq		$r3,$a0,TC1	; is it = to what r8 points to? if so
FFFC29AC 00072903		lw		$a0,[$sp]
FFFC29B0 00870713		add		$sp,$sp,#8
FFFC29B4 00020067		jmp		[$r4]		; jump to the routine
                        	TC1:
FFFC29B8 001E0E13		add		$t2,$t2,#1	; if equal, bump text pointer
FFFC29BC 00072903		lw		$a0,[$sp]
FFFC29C0 00472083		lw		$ra,4[$sp]
FFFC29C4 00870713		add		$sp,$sp,#8
FFFC29C8 00008067		ret
                        	
                        	
                        	; ===== See if the text pointed to by $t2 is a number. If so,
                        	;	return the number in $v0 and the number of digits in $v1,
                        	;	else return zero in $v0 and $v1.
                        	; Registers Affected
                        	;   a0,a1,r3,r4
                        	; Returns
                        	; 	a0 = number
                        	;	a1 = number of digits in number
                        	;	r8 = updated text pointer
                        	;
                        	TSTNUM:
FFFC29CC FF870713		sub		$sp,$sp,#8
FFFC29D0 00172223		sw		$ra,4[$sp]
FFFC29D4 00372023		sw		r3,[$sp]
FFFC29D8 068000EF		call	IGNBLK		; skip over blanks
FFFC29DC 00006833		mov		$v0,$x0		; initialize return parameters
FFFC29E0 000068B3		mov		$v1,$x0
                        	TN1:
FFFC29E4 000E4183		lbu		r3,[$t2]
FFFC29E8 03006D93		ldi		$t1,#'0'
FFFC29EC 05B1C263		blt		r3,$t1,TSNMRET; is it less than zero?
FFFC29F0 03906D93		ldi		$t1,#'9'
FFFC29F4 023DCE63		bgt		r3,$t1,TSNMRET; is it greater than nine?
FFFC29F8 00000DB7		ldi		$t1,#$7FFFFFFFFFFFFFF
FFFC29FC FFFD8D93
FFFC2A00 010DF863		bleu	$v0,$t1,TN2; see if there's room for new digit
FFFC2A04 FFFC3937		ldi		$a0,#msgNumTooBig
FFFC2A08 BDA90913
FFFC2A0C A91FF06F		jmp		ERROR		; if not, we've overflowd
                        	TN2:
FFFC2A10 001E0E13		add		$t2,$t2,#1	; adjust text pointer
FFFC2A14 00181E93		sll		$t3,$v0,#1	; quickly multiply result by 10
FFFC2A18 00381813		sll		$v0,$v0,#3	; *8
FFFC2A1C 01D80833		add		$v0,$v0,$t3	; *8 + *2
FFFC2A20 00F1F193		and		r3,r3,#$0F	; add in the new digit
FFFC2A24 00380833		add		$v0,$v0,r3
FFFC2A28 00188893		add		$v1,$v1,#1	; increment the no. of digits
FFFC2A2C FA000CE3		bra		TN1
                        	TSNMRET:
FFFC2A30 00072183		lw		r3,[$sp]
FFFC2A34 00472083		lw		$ra,4[$sp]
FFFC2A38 00870713		add		$sp,$sp,#8
FFFC2A3C 00008067		ret
                        	
                        	
                        	;===== Skip over blanks in the text pointed to by $t2.
                        	;
                        	; Registers Affected:
                        	;	$t2
                        	; Returns
                        	;	$t2 = pointer updateded past any spaces or tabs
                        	;
                        	IGNBLK:
FFFC2A40 FFC70713		sub		$sp,$sp,#4
FFFC2A44 01272023		sw		$a0,[$sp]
                        	IGB2:
FFFC2A48 000E4903		lbu		a0,[$t2]			; get char
FFFC2A4C 02006D93		ldi		$t1,#' '
FFFC2A50 01B90663		beq		$a0,$t1,IGB1	; see if it's a space
FFFC2A54 00906D93		ldi		$t1,#'\t'
FFFC2A58 01B91663		bne		a0,$t1,IGBRET	; or a tab
                        	IGB1:
FFFC2A5C 001E0E13		add		$t2,$t2,#1		; increment the text pointer
FFFC2A60 FE0004E3		bra		IGB2
                        	IGBRET:
FFFC2A64 00072903		lw		$a0,[$sp]
FFFC2A68 00470713		add		$sp,$sp,#4
FFFC2A6C 00008067		ret
                        	
                        	; ===== Convert the line of text in the input buffer to upper
                        	;	case (except for stuff between quotes).
                        	;
                        	; Registers Affected
                        	;   a0,r3
                        	; Returns
                        	;	r8 = pointing to end of text in buffer
                        	;
                        	TOUPBUF:
FFFC2A70 FFC70713		sub		$sp,$sp,#4
FFFC2A74 00172023		sw		$ra,[$sp]
FFFC2A78 71806E13		ldi		$t2,#BUFFER	; set up text pointer
FFFC2A7C 000061B3		mov		r3,x0		; clear quote flag
                        	TOUPB1:
FFFC2A80 000E4903		lbu		a0,[$t2]		; get the next text char.
FFFC2A84 001E0E13		add		$t2,$t2,#1
FFFC2A88 00D06D93		ldi		$t1,#CR
FFFC2A8C 03B90E63		beq		a0,$t1,TOUPBRT		; is it end of line?
FFFC2A90 02206D93		ldi		$t1,#'"'
FFFC2A94 01B90E63		beq		a0,$t1,DOQUO	; a double quote?
FFFC2A98 02706D93		ldi		$t1,#'\''
FFFC2A9C 01B90A63		beq		a0,$t1,DOQUO	; or a single quote?
FFFC2AA0 FE0190E3		bne		r3,x0,TOUPB1	; inside quotes?
FFFC2AA4 030000EF		call	toUpper 	; convert to upper case
FFFC2AA8 FF0E0FA3		sb		v0,-1[$t2]	; store it
FFFC2AAC FC000AE3		bra		TOUPB1		; and go back for more
                        	DOQUO:
FFFC2AB0 00019663		bne		r3,x0,DOQUO1; are we inside quotes?
FFFC2AB4 000961B3		mov		r3,a0		; if not, toggle inside-quotes flag
FFFC2AB8 FC0004E3		bra		TOUPB1
                        	DOQUO1:
FFFC2ABC FD2192E3		bne		r3,a0,TOUPB1; make sure we're ending proper quote
FFFC2AC0 000061B3		mov		r3,r0		; else clear quote flag
FFFC2AC4 FA000EE3		bra		TOUPB1
                        	TOUPBRT:
FFFC2AC8 00072083		lw		$ra,[$sp]
FFFC2ACC 00470713		add		$sp,$sp,#4
FFFC2AD0 00008067		ret
                        	
                        	
                        	; ===== Convert the character in a0 to upper case
                        	;
                        	toUpper:
FFFC2AD4 00096833		mov		$v0,$a0
FFFC2AD8 06182D93		slt		$t1,$v0,#'a'
FFFC2ADC 000D9863		bne   $t1,$x0,TOUPRET	; is it < 'a'?
FFFC2AE0 07A06D93		ldi		$t1,#'z'
FFFC2AE4 010DC463		bgt		$v0,$t1,TOUPRET	; or > 'z'?
FFFC2AE8 FE080813		sub		$v0,$v0,#32	  ; if not, make it upper case
                        	TOUPRET:
FFFC2AEC 00008067		ret
                        	
                        	; 'CHKIO' checks the input. If there's no input, it will return
                        	; to the caller with the a0=0. If there is input, the input byte is in a0.
                        	; However, if a control-C is read, 'CHKIO' will warm-start BASIC and will
                        	; not return to the caller.
                        	;
                        	//message "CHKIO"
                        	CHKIO:
FFFC2AF0 FFC70713		sub		$sp,$sp,#4
FFFC2AF4 00172023		sw		$ra,[$sp]
FFFC2AF8 048000EF		call	INCH		; get input if possible
FFFC2AFC 00080863		beq		$v0,$x0,CHKRET	; if Zero, no input
FFFC2B00 00384D93		xor		$t1,$v0,#CTRLC
FFFC2B04 000D9463		bne		$t1,$x0,CHKRET; is it control-C?
FFFC2B08 DBCFE06F		jmp		WSTART		; if so, do a warm start
                        	CHKRET:
FFFC2B0C 00072083		lw		$ra,[$sp]
FFFC2B10 00470713		add		$sp,$sp,#4
FFFC2B14 00008067		ret
                        	
                        	; ===== Display a CR-LF sequence
                        	;
                        	CRLF:
FFFC2B18 FFFC3937		ldi		a0,#CLMSG
FFFC2B1C BBC90913
                        	
                        	; ===== Display a zero-ended string pointed to by register a0
                        	; Registers Affected
                        	;   a0,a1,r4
                        	;
                        	PRMESG:
FFFC2B20 FFC70713		sub		$sp,$sp,#4
FFFC2B24 00172023		sw		$ra,[$sp]
FFFC2B28 00096933		mov		$a0,$a0
FFFC2B2C B0DFD0EF		call	SerialPutString
FFFC2B30 00072083		lw		$ra,[$sp]
FFFC2B34 00470713		add		$sp,$sp,#4
FFFC2B38 00008067		ret
                        	
                        	;*****************************************************
                        	; The following routines are the only ones that need *
                        	; to be changed for a different I/O environment.     *
                        	;*****************************************************
                        	
                        	; ===== Output character to the console (Port 1) from register a0
                        	;	(Preserves all registers.)
                        	;
                        	OUTC:
FFFC2B3C AD1FD06F		jmp		SerialPutChar
                        	
                        	; ===== Input a character from the console into register R1 (or
                        	;	return Zero status if there's no character available).
                        	;
                        	INCH:
FFFC2B40 FFC70713		sub 	$sp,$sp,#4
FFFC2B44 00172023		sw		$ra,[$sp]
FFFC2B48 A91FD0EF		call	SerialPeekChar
FFFC2B4C FFF84D93		xor		$t1,$v0,#-1
FFFC2B50 000D8863		beq		$t1,$x0,INCH1
FFFC2B54 00072083		lw		$ra,[$sp]
FFFC2B58 00470713		add		$sp,$sp,#4
FFFC2B5C 00008067		ret
                        	INCH1:
FFFC2B60 00006833		mov		$v0,$x0	; return a zero for no-char
FFFC2B64 00072083		lw		$ra,[$sp]
FFFC2B68 00470713		add		$sp,$sp,#4
FFFC2B6C 00008067		ret
                        	
FFFC2B70 53430A0D	msgInit	db	CR,LINEFD,"CS01 Tiny BASIC v1.0",CR,LINEFD,"(C) 2017-2020  Robert Finch",CR,LINEFD,LINEFD,0
FFFC2B74 54203130
FFFC2B78 20796E69
FFFC2B7C 49534142
FFFC2B80 31762043
FFFC2B84 0A0D302E
FFFC2B88 20294328
FFFC2B8C 37313032
FFFC2B90 3230322D
FFFC2B94 52202030
FFFC2B98 7265626F
FFFC2B9C 69462074
FFFC2BA0 0D68636E
FFFC2BA4 0D000A0A
FFFC2BA7 4B4F0A0D	OKMSG	db	CR,LINEFD,"OK",CR,LINEFD,0
FFFC2BAB 57000A0D
FFFC2BAE 74616857	msgWhat	db	"What?",CR,LINEFD,0
FFFC2BB2 000A0D3F
FFFC2BB6 72726F53	SRYMSG	db	"Sorry."
FFFC2BBA 0A0D2E79
FFFC2BBC 43000A0D	CLMSG	db	CR,LINEFD,0
FFFC2BBF 706D6F43	msgReadError	db	"Compact FLASH read error",CR,LINEFD,0
FFFC2BC3 20746361
FFFC2BC7 53414C46
FFFC2BCB 65722048
FFFC2BCF 65206461
FFFC2BD3 726F7272
FFFC2BD7 4E000A0D
FFFC2BDA 626D754E	msgNumTooBig	db	"Number is too big",CR,LINEFD,0
FFFC2BDE 69207265
FFFC2BE2 6F742073
FFFC2BE6 6962206F
FFFC2BEA 000A0D67
FFFC2BEE 69766944	msgDivZero		db	"Division by zero",CR,LINEFD,0
FFFC2BF2 6E6F6973
FFFC2BF6 20796220
FFFC2BFA 6F72657A
FFFC2BFE 4F000A0D
FFFC2C01 2074754F	msgVarSpace     db  "Out of variable space",CR,LINEFD,0
FFFC2C05 7620666F
FFFC2C09 61697261
FFFC2C0D 20656C62
FFFC2C11 63617073
FFFC2C15 000A0D65
FFFC2C19 74796220	msgBytesFree	db	" bytes free",CR,LINEFD,0
FFFC2C1D 66207365
FFFC2C21 0D656572
FFFC2C25 0A0D000A
FFFC2C27 65520A0D	msgReady		db	CR,LINEFD,"Ready",CR,LINEFD,0
FFFC2C2B 0D796461
FFFC2C2F 7845000A
FFFC2C31 65707845	msgComma		db	"Expecting a comma",CR,LINEFD,0
FFFC2C35 6E697463
FFFC2C39 20612067
FFFC2C3D 6D6D6F63
FFFC2C41 000A0D61
FFFC2C45 656E694C	msgLineRange	db	"Line number too big",CR,LINEFD,0
FFFC2C49 6D756E20
FFFC2C4D 20726562
FFFC2C51 206F6F74
FFFC2C55 0D676962
FFFC2C59 7845000A
FFFC2C5B 65707845	msgVar			db "Expecting a variable",CR,LINEFD,0
FFFC2C5F 6E697463
FFFC2C63 20612067
FFFC2C67 69726176
FFFC2C6B 656C6261
FFFC2C6F 52000A0D
FFFC2C72 20444E52	msgRNDBad		db	"RND bad parameter",CR,LINEFD,0
FFFC2C76 20646162
FFFC2C7A 61726170
FFFC2C7E 6574656D
FFFC2C82 000A0D72
FFFC2C86 20535953	msgSYSBad		db	"SYS bad address",CR,LINEFD,0
FFFC2C8A 20646162
FFFC2C8E 72646461
FFFC2C92 0D737365
FFFC2C96 4E49000A
FFFC2C98 55504E49	msgInputVar		db	"INPUT expecting a variable",CR,LINEFD,0
FFFC2C9C 78652054
FFFC2CA0 74636570
FFFC2CA4 20676E69
FFFC2CA8 61762061
FFFC2CAC 62616972
FFFC2CB0 0A0D656C
FFFC2CB4 58454E00
FFFC2CB5 5458454E	msgNextFor		db	"NEXT without FOR",CR,LINEFD,0
FFFC2CB9 74697720
FFFC2CBD 74756F68
FFFC2CC1 524F4620
FFFC2CC5 4E000A0D
FFFC2CC8 5458454E	msgNextVar		db	"NEXT expecting a defined variable",CR,LINEFD,0
FFFC2CCC 70786520
FFFC2CD0 69746365
FFFC2CD4 6120676E
FFFC2CD8 66656420
FFFC2CDC 64656E69
FFFC2CE0 72617620
FFFC2CE4 6C626169
FFFC2CE8 000A0D65
FFFC2CEC 4F544F47	msgBadGotoGosub	db	"GOTO/GOSUB bad line number",CR,LINEFD,0
FFFC2CF0 534F472F
FFFC2CF4 62204255
FFFC2CF8 6C206461
FFFC2CFC 20656E69
FFFC2D00 626D756E
FFFC2D04 0A0D7265
FFFC2D08 54455200
FFFC2D09 55544552	msgRetWoGosub   db	"RETURN without GOSUB",CR,LINEFD,0
FFFC2D0D 77204E52
FFFC2D11 6F687469
FFFC2D15 47207475
FFFC2D19 4255534F
FFFC2D1D 50000A0D
FFFC2D20 676F7250	msgTooBig		db	"Program is too big",CR,LINEFD,0
FFFC2D24 206D6172
FFFC2D28 74207369
FFFC2D2C 62206F6F
FFFC2D30 0A0D6769
FFFC2D34 74784500
FFFC2D35 72747845	msgExtraChars	db	"Extra characters on line ignored",CR,LINEFD,0
FFFC2D39 68632061
FFFC2D3D 63617261
FFFC2D41 73726574
FFFC2D45 206E6F20
FFFC2D49 656E696C
FFFC2D4D 6E676920
FFFC2D51 6465726F
FFFC2D55 00000A0D
                        	
                        	LSTROM	equ	*		; end of possible ROM area
;	END
                        	
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	
                        		rodata
                        		align 8                        	
                        	begin_init_data:
                        	_begin_init_data:
                        	
                        		rodata
                        		align 8                        	
                        	end_init_data:
                        	_end_init_data:
576 symbols
  Symbol Name                              seg     address bits
  ABS                                        code  fffc2320 18
  ABS1                                       code  fffc233c 18
  ANDEXPR                                    code  fffc1c88 18
  AUXIN                                      code  80000000000000f2 32
  AUXIN_INIT                                 code  80000000000001a0 32
  AUXOCRLF                                   code  fffc1ae0 18
  AUXOUT                                     code  80000000000000f0 32
  AUXOUT_FLUSH                               code  80000000000001ad 32
  AUXOUT_INIT                                code  80000000000001a4 32
  AllocPage                                  code  fffc0bcc 18
  AllocPage.0001                             code  fffc0c9c 18
  AllocPage.chkPam12                         code  fffc0c20 18
  AllocPage.chkPam16                         code  fffc0c38 18
  AllocPage.chkPam20                         code  fffc0c50 18
  AllocPage.chkPam24                         code  fffc0c68 18
  AllocPage.chkPam28                         code  fffc0c80 18
  AllocPage.chkPam4                          code  fffc0bf0 18
  AllocPage.chkPam8                          code  fffc0c08 18
  AllocPage.chkPamDone                       code  fffc0c98 18
  BS                                        const  000008 5
  BUFFER                                    const  000718 12
  BUFLEN                                    const  000054 8
  BYEBYE                                     code  80000000000000f4 32
  BitIndex                                   code  fffc0ca8 18
  BitIndex.0001                              code  fffc0cac 18
  BitIndex.0003                              code  fffc0ce4 18
  BitIndex.0004                              code  fffc0cd4 18
  BitIndex.foundFree                         code  fffc0cc8 18
  CHKIO                                      code  fffc2af0 18
  CHKRET                                     code  fffc2b0c 18
  CLMSG                                      code  fffc2bbc 18
  CR                                        const  00000d 5
  CRLF                                       code  fffc2b18 18
  CSTART                                     code  fffc1030 32
  CTRLC                                     const  000003 3
  CTRLH                                     const  000008 5
  CTRLI                                     const  000009 5
  CTRLJ                                     const  00000a 5
  CTRLK                                     const  00000b 5
  CTRLM                                     const  00000d 5
  CTRLS                                     const  000013 6
  CTRLX                                     const  000018 6
  CURRNT                                    const  000714 12
  CursorFlash                               const  000798 12
  DEFLT                                      code  fffc1858 18
  DEL                                       const  00007f 8
  DIRECT                                     code  fffc1300 18
  DOQUO                                      code  fffc2ab0 18
  DOQUO1                                     code  fffc2abc 18
  ENDCHK                                     code  fffc244c 18
  ENDMEM                                    const  080000 21
  ERROR                                      code  fffc249c 18
  ERROR1                                     code  fffc24dc 18
  EX1                                        code  fffc134c 18
  EXEC                                       code  fffc1310 18
  EXGO                                       code  fffc1374 18
  EXLP                                       code  fffc131c 18
  EXMAT                                      code  fffc1360 18
  EXNGO                                      code  fffc1334 18
  EXPR                                       code  fffc1d70 18
  EXPR2                                      code  fffc1e94 18
  EXPR3                                      code  fffc1f3c 18
  EXPR4                                      code  fffc1fe4 18
  FI1                                        code  fffc2428 18
  FI2                                        code  fffc2440 18
  FILEBUF                                   const  07f600 20
  FILENAME                                  const  0006c0 12
  FIN                                        code  fffc2408 18
  FINISH                                     code  fffc15c0 18
  FNDLN                                      code  fffc25d4 18
  FNDLNP                                     code  fffc25f4 18
  FNDNXT                                     code  fffc2620 18
  FNDRET                                     code  fffc2608 18
  FNDRET1                                    code  fffc2610 18
  FNDRET2                                    code  fffc2618 18
  FNDSKP                                     code  fffc2624 18
  FOR                                        code  fffc1650 18
  FORCEFIT                                   code  fffc1d48 18
  FORCEFIT.0001                              code  fffc1d6c 18
  FORCEFIT.intAnd                            code  fffc1d5c 18
  FR1                                        code  fffc1670 18
  FR2                                        code  fffc168c 18
  FR3                                        code  fffc1694 18
  FR4                                        code  fffc1698 18
  FR5                                        code  fffc169c 18
  FR6                                        code  fffc16b4 18
  FR7                                        code  fffc16b8 18
  FR8                                        code  fffc16e4 18
  FindRun                                    code  fffc0ce8 18
  FindRun.empty0                             code  fffc0cf8 18
  GCHAR                                      code  fffc18e0 18
  GCHAR1                                     code  fffc18f8 18
  GETLN                                      code  fffc24e0 18
  GETLN.GL1                                  code  fffc2500 18
  GETLN.GL2                                  code  fffc2528 18
  GETLN.GL3                                  code  fffc2558 18
  GETLN.GL4                                  code  fffc2580 18
  GETLN.GL5                                  code  fffc2590 18
  GETLN.GL6                                  code  fffc25b0 18
  GETLN.GL7                                  code  fffc25b8 18
  GOAUXI                                     code  fffc1018 18
  GOAUXO                                     code  fffc1010 18
  GOBYE                                      code  fffc1020 18
  GOIN                                       code  fffc100c 18
  GOOUT                                      code  fffc1008 18
  GOSTART                                    code  fffc1000 18
  GOSUB                                      code  fffc15c8 18
  GOTO                                       code  fffc1430 18
  GOWARM                                     code  fffc1004 18
  GetFilename                                code  fffc1944 18
  GetHexNum                                  code  fffc043c 18
  GetHexNum.0001                             code  fffc0480 18
  GetHexNum.isDigit                          code  fffc04bc 18
  GetHexNum.isHexLower                       code  fffc04a4 18
  GetHexNum.isHexUpper                       code  fffc048c 18
  GetHexNum.next                             code  fffc044c 18
  Getch                                      code  fffc01a4 18
  IF                                         code  fffc1760 18
  IF1                                        code  fffc1764 18
  IF2                                        code  fffc1768 18
  IF3                                        code  fffc1778 18
  IGB1                                       code  fffc2a5c 18
  IGB2                                       code  fffc2a48 18
  IGBRET                                     code  fffc2a64 18
  IGNBLK                                     code  fffc2a40 18
  INBUF                                     const  000100 10
  INCH                                       code  fffc2b40 18
  INCH1                                      code  fffc2b60 18
  INPERR                                     code  fffc177c 18
  INPPTR                                    const  000794 12
  INPUT                                      code  fffc1798 18
  IP2                                        code  fffc17c0 18
  IP3                                        code  fffc17f8 18
  IP4                                        code  fffc1838 18
  IP5                                        code  fffc184c 18
  IP6                                        code  fffc17a0 18
  IP7                                        code  fffc17e0 18
  IRQFlag                                   const  00079c 12
  IRQROUT                                   const  00078c 12
  IRQRout                                    code  fffc06b0 18
  IRQRout.0001                               code  fffc06ec 18
  IRQRout.0002                               code  fffc0704 18
  IRQRout.isIRQ                              code  fffc06c4 18
  InitPAM                                    code  fffc0ba4 18
  LET                                        code  fffc1864 18
  LINEFD                                    const  00000a 5
  LISTX                                      code  fffc14c8 18
  LOAD                                       code  fffc1880 18
  LOAD3                                      code  fffc19b4 18
  LOAD4                                      code  fffc19e0 18
  LOAD5                                      code  fffc1a14 18
  LOD1                                       code  fffc1890 18
  LOD2                                       code  fffc18bc 18
  LODEND                                     code  fffc18d8 18
  LOPINC                                    const  000774 12
  LOPLMT                                    const  000778 12
  LOPLN                                     const  000770 12
  LOPPT                                     const  00076c 12
  LOPVAR                                    const  00070c 12
  LS1                                        code  fffc14dc 18
  LS2                                        code  fffc1504 18
  LS3                                        code  fffc150c 18
  LS4                                        code  fffc14e8 18
  LSTROM                                    const  000000 1
  LT1                                        code  fffc187c 18
  MMUInit                                    code  fffc0b68 18
  MMUInit.0001                               code  fffc0b78 18
  MMUInit.0002                               code  fffc0b94 18
  MMUsmc                                    const  000200 11
  MVDOWN                                     code  fffc2660 18
  MVDOWN1                                    code  fffc2650 18
  MVRET                                      code  fffc264c 18
  MVUP                                       code  fffc2648 18
  MVUP1                                      code  fffc2638 18
  MachineStart                               code  fffc0100 18
  MonEntry                                   code  fffc01d4 18
  Monitor                                    code  fffc020c 18
  Monitor.0001                               code  fffc02a4 18
  Monitor.0002                               code  fffc02e8 18
  Monitor.0003                               code  fffc0320 18
  Monitor.0004                               code  fffc0360 18
  Monitor.0005                               code  fffc0384 18
  Monitor.0006                               code  fffc0384 18
  Monitor.doBackspace                        code  fffc0308 18
  Monitor.doDelete                           code  fffc02e0 18
  Monitor.procLine                           code  fffc0340 18
  Monitor.skip                               code  fffc0348 18
  Monitor.skip2                              code  fffc0358 18
  NEW                                        code  fffc1384 18
  NEXT                                       code  fffc16e8 18
  NUMWKA                                    const  00077c 12
  NX0                                        code  fffc1704 18
  NX1                                        code  fffc1744 18
  NX2                                        code  fffc1724 18
  NX3                                        code  fffc1748 18
  NX4                                        code  fffc1700 18
  NX5                                        code  fffc1718 18
  NXPurge                                    code  fffc1758 18
  OKMSG                                      code  fffc2ba7 18
  ONIRQ                                      code  fffc1490 18
  ONIRQ1                                     code  fffc14b0 18
  OREXPR                                     code  fffc1c38 18
  OSSP                                      const  000700 12
  OUTC                                       code  fffc2b3c 18
  OUTPTR                                    const  000790 12
  PAM                                       const  000300 11
  PARN                                       code  fffc203c 18
  PEEK                                       code  fffc222c 18
  PEEKH                                      code  fffc226c 18
  PEEKW                                      code  fffc224c 18
  PHN1                                       code  fffc28c4 18
  PHN2                                       code  fffc28c0 18
  PHN3                                       code  fffc2900 18
  PHN4                                       code  fffc2910 18
  PHN5                                       code  fffc291c 18
  PHN6                                       code  fffc28fc 18
  PHN7                                       code  fffc28dc 18
  PHN8                                       code  fffc28e0 18
  PHNRET                                     code  fffc2930 18
  PKER                                       code  fffc1c00 18
  PN1                                        code  fffc281c 18
  PN2                                        code  fffc2818 18
  PN3                                        code  fffc283c 18
  PN4                                        code  fffc284c 18
  PN5                                        code  fffc2858 18
  PN6                                        code  fffc2838 18
  PNRET                                      code  fffc286c 18
  POKE                                       code  fffc1b70 18
  POKEH                                      code  fffc1bd0 18
  POKEW                                      code  fffc1ba0 18
  POPA_                                      code  fffc2668 18
  PP1                                        code  fffc269c 18
  PR0                                        code  fffc154c 18
  PR1                                        code  fffc1568 18
  PR2                                        code  fffc1534 18
  PR3                                        code  fffc158c 18
  PR4                                        code  fffc1584 18
  PR6                                        code  fffc15a4 18
  PR8                                        code  fffc15ac 18
  PRINT                                      code  fffc1518 18
  PRMESG                                     code  fffc2b20 18
  PRTHEXNUM                                  code  fffc2888 32
  PRTLN                                      code  fffc2950 18
  PRTNUM                                     code  fffc27e8 32
  PRTSTG                                     code  fffc26e4 18
  PRTSTG.PRTRET                              code  fffc2724 18
  PRTSTG.PS1                                 code  fffc2700 18
  PU1                                        code  fffc26d8 18
  PUSHA_                                     code  fffc26a0 18
  PWORD                                      code  fffc1b04 18
  PutHexByte                                 code  fffc0510 18
  PutHexHalf                                 code  fffc04f0 18
  PutHexNybble                               code  fffc0530 18
  PutHexNybble.0001                          code  fffc0560 18
  PutHexNybble.lt10                          code  fffc0558 18
  PutHexWord                                 code  fffc04d0 18
  Putch                                      code  fffc01bc 18
  QSORRY                                     code  fffc2488 18
  QT1                                        code  fffc2760 18
  QT2                                        code  fffc27a8 18
  QT3                                        code  fffc2778 18
  QT4                                        code  fffc2790 18
  QT5                                        code  fffc27b8 18
  QTSTG                                      code  fffc2744 18
  QWHAT                                      code  fffc2494 18
  RETURN                                     code  fffc160c 18
  RND                                        code  fffc22bc 18
  RUN                                        code  fffc13a0 18
  RUN1                                       code  fffc13fc 18
  RUNNXL                                     code  fffc13b4 18
  RUNSML                                     code  fffc1418 18
  RUNTSL                                     code  fffc1410 18
  SAVE                                       code  fffc1a80 18
  SAVE1                                      code  fffc1a8c 18
  SAVE2                                      code  fffc1aa8 18
  SAVE3                                      code  fffc1a18 18
  SAVE4                                      code  fffc1a48 18
  SAVEND                                     code  fffc1ac0 18
  SDReadSector                               code  80000000000001a1 32
  SDWriteSector                              code  80000000000001a6 32
  SETVAL                                     code  fffc23a4 18
  SETVAL.sv2                                 code  fffc23c8 18
  SGN                                        code  fffc2354 18
  SGN1                                       code  fffc2388 18
  SGN2                                       code  fffc2378 18
  SIZEX                                      code  fffc2394 18
  SRYMSG                                     code  fffc2bb6 18
  ST2                                        code  fffc111c 18
  ST3                                        code  fffc10e4 18
  ST4                                        code  fffc11a0 18
  ST5                                        code  fffc11cc 18
  ST6                                        code  fffc1198 18
  ST7                                        code  fffc114c 18
  ST8                                        code  fffc116c 18
  STACKOFFS                                 const  07fefc 20
  STKBOT                                    const  000784 12
  STKGOS                                    const  000710 12
  STKINP                                    const  000780 12
  STOP                                       code  fffc1398 18
  STRTMP                                    const  000200 11
  SV1                                        code  fffc2400 18
  SYSX                                       code  fffc1c0c 18
  SerialInit                                 code  fffc066c 18
  SerialPeekChar                             code  fffc05d8 18
  SerialPeekChar.0001                        code  fffc0604 18
  SerialPutChar                              code  fffc060c 18
  SerialPutChar.0001                         code  fffc060c 18
  SerialPutString                            code  fffc0638 18
  SerialPutString.0001                       code  fffc0648 18
  SerialPutString.done                       code  fffc065c 18
  SkipSpaces                                 code  fffc041c 18
  SkipSpaces.skip1                           code  fffc0434 18
  SkipSpaces.skip2                           code  fffc041c 18
  TAB                                       const  000009 5
  TAB1                                       code  fffc11f4 18
  TAB10                                      code  fffc1293 18
  TAB10_1                                    code  fffc12fa 18
  TAB1_1                                     code  fffc1296 18
  TAB2                                       code  fffc1206 18
  TAB2_1                                     code  fffc12a0 18
  TAB4                                       code  fffc125a 18
  TAB4_1                                     code  fffc12cc 18
  TAB5                                       code  fffc127d 18
  TAB5_1                                     code  fffc12e0 18
  TAB6                                       code  fffc1280 18
  TAB6_1                                     code  fffc12e4 18
  TAB8                                       code  fffc1285 18
  TAB8_1                                     code  fffc12e8 18
  TAB9                                       code  fffc128f 18
  TAB9_1                                     code  fffc12f6 18
  TC1                                        code  fffc29b8 18
  TICKX                                      code  fffc234c 18
  TN1                                        code  fffc29e4 18
  TN2                                        code  fffc2a10 18
  TOOBIG                                     code  fffc247c 18
  TOUPB1                                     code  fffc2a80 18
  TOUPBRT                                    code  fffc2ac8 18
  TOUPBUF                                    code  fffc2a70 18
  TOUPRET                                    code  fffc2aec 18
  TSNMRET                                    code  fffc2a30 18
  TSTC                                       code  fffc2994 18
  TSTNUM                                     code  fffc29cc 18
  TSTV                                       code  fffc2084 18
  TSTVRT                                     code  fffc20f4 18
  TV1                                        code  fffc20e0 18
  TV2                                        code  fffc20d4 18
  TV3                                        code  fffc20b4 18
  TXTBGN                                    const  001800 14
  TXTUNF                                    const  000704 12
  TinyBasic                                  code  fffc1000 18
  UART                                      const  ffdc0a00 33
  UART_CMD                                  const  000008 5
  UART_STAT                                 const  000004 4
  UART_TRB                                  const  000000 1
  USRX                                       code  fffc228c 18
  UserStart                                  code  fffc0140 18
  UserStart.0002                             code  fffc0180 18
  UserStart.0003                             code  fffc0190 18
  UserStart.0004                             code  fffc016c 18
  VARBGN                                    const  000708 12
  VIA                                       const  ffdc0600 33
  VIAInit                                    code  fffc0570 18
  VIA_ACR                                   const  00002c 7
  VIA_DDRA                                  const  00000c 5
  VIA_IFR                                   const  000034 7
  VIA_PA                                    const  000004 4
  VIA_PARAW                                 const  00003c 7
  VIA_PCR                                   const  000030 7
  VIA_T1CH                                  const  000014 6
  VIA_T1CL                                  const  000010 6
  WAITIRQ                                    code  fffc14b8 18
  WSTART                                     code  fffc10c4 18
  XOFF                                      const  000013 6
  XON                                       const  000011 6
  XP11                                       code  fffc1d9c 18
  XP12                                       code  fffc1db4 18
  XP13                                       code  fffc1dcc 18
  XP14                                       code  fffc1de4 18
  XP15                                       code  fffc1dfc 18
  XP16                                       code  fffc1e14 18
  XP17                                       code  fffc1e54 18
  XP18                                       code  fffc1e6c 18
  XP21                                       code  fffc1ec0 18
  XP22                                       code  fffc1ed0 18
  XP23                                       code  fffc1ed4 18
  XP24                                       code  fffc1ef4 18
  XP25                                       code  fffc1f08 18
  XP26                                       code  fffc1f18 18
  XP31                                       code  fffc1f48 18
  XP34                                       code  fffc1f7c 18
  XP35                                       code  fffc1fa4 18
  XP40                                       code  fffc2000 18
  XP41                                       code  fffc2024 18
  XP42                                       code  fffc2068 18
  XP43                                       code  fffc2074 18
  XP45                                       code  fffc1f24 18
  XP46                                       code  fffc2030 18
  XP47                                       code  fffc1fcc 18
  XPRT0                                      code  fffc1e2c 18
  XPRT1                                      code  fffc1e40 18
  XP_AND                                     code  fffc1cb0 18
  XP_AND1                                    code  fffc1c94 18
  XP_ANDX                                    code  fffc1cc4 18
  XP_OR                                      code  fffc1c60 18
  XP_OR1                                     code  fffc1c44 18
  XP_ORX                                     code  fffc1c74 18
  _clr                                       code  fffc1454 18
  _cls                                       code  800000000000012b 32
  _end_init_data                           rodata  fffc3000 32
  _rdcf                                      code  800000000000012d 32
  a2h1                                       code  fffc1938 18
  asciiToHex                                 code  fffc192c 18
  begin_init_data                          rodata  fffc3000 32
  clearVars                                  code  fffc145c 18
  clearVars.cv1                              code  fffc1470 18
  doMem                                      code  fffc0388 18
  doMem.loop                                 code  fffc03f8 18
  doMem.loop2                                code  fffc03c8 18
  ec1                                        code  fffc2470 18
  end_init_data                            rodata  fffc3000 32
  f0Save                                    const  000080 9
  f18Save                                   const  0000c8 9
  f1Save                                    const  000084 9
  f2Save                                    const  000088 9
  findVar                                    code  fffc21d4 18
  fl1                                        code  fffc25ec 18
  flt10                                      code  fffc07a0 18
  flt20                                      code  fffc0790 18
  flt50                                      code  fffc0780 18
  fltMillion                                 code  fffc0b64 18
  fltOne                                     code  fffc0b5c 18
  fltTen                                     code  fffc0b60 18
  fltToString                                code  fffc07b0 18
  fltToString.0001                           code  fffc0808 18
  fltToString.0002                           code  fffc0880 18
  fltToString.0003                           code  fffc086c 18
  fltToString.0004                           code  fffc08cc 18
  fltToString.0005                           code  fffc08c4 18
  fltToString.0006                           code  fffc08ac 18
  fltToString.0007                           code  fffc08e8 18
  fltToString.0008                           code  fffc08fc 18
  fltToString.0009                           code  fffc08f8 18
  fltToString.0010                           code  fffc091c 18
  fltToString.0011                           code  fffc09a8 18
  fltToString.0012                           code  fffc0960 18
  fltToString.0013                           code  fffc094c 18
  fltToString.0014                           code  fffc097c 18
  fltToString.0015                           code  fffc0998 18
  fltToString.0016                           code  fffc0934 18
  fltToString.0017                           code  fffc09a0 18
  fltToString.0018                           code  fffc09a8 18
  fltToString.0019                           code  fffc09dc 18
  fltToString.0020                           code  fffc09e8 18
  fltToString.0021                           code  fffc0a0c 18
  fltToString.0022                           code  fffc0a18 18
  fltToString.0023                           code  fffc0a28 18
  fltToString.0024                           code  fffc0a34 18
  fltToString.0025                           code  fffc0a20 18
  fltToString.0026                           code  fffc0a48 18
  fltToString.0027                           code  fffc0a50 18
  fltToString.0028                           code  fffc0a58 18
  fltToString.0029                           code  fffc0a64 18
  fltToString.0030                           code  fffc0a70 18
  fltToString.0031                           code  fffc0a7c 18
  fltToString.0032                           code  fffc0a84 18
  fltToString.0034                           code  fffc0a8c 18
  fltToString.0035                           code  fffc0a98 18
  fltToString.0036                           code  fffc0aa8 18
  fltToString.0037                           code  fffc0ab4 18
  fltToString.0038                           code  fffc0abc 18
  fltToString.0039                           code  fffc0ad0 18
  fltToString.0040                           code  fffc0ac4 18
  fltToString.0041                           code  fffc0b2c 18
  fltToString.0042                           code  fffc0af0 18
  fltToString.0043                           code  fffc0b00 18
  fltToString.0044                           code  fffc0b14 18
  fltToString.0045                           code  fffc0af8 18
  fltToString.0046                           code  fffc0b20 18
  fltToString.0047                           code  fffc0b2c 18
  fltToString.0048                           code  fffc0b18 18
  fltToString.0050                           code  fffc0b4c 18
  fltToString.0051                           code  fffc0b48 18
  fltToString.0052                           code  fffc0b38 18
  fltToString.inf                            code  fffc07f0 18
  fltToString.notZero                        code  fffc083c 18
  fltToString.pos                            code  fffc0828 18
  fltToString.prt                            code  fffc0ae0 18
  fv1                                        code  fffc220c 18
  fv2                                        code  fffc221c 18
  fv3                                        code  fffc2204 18
  fv4                                        code  fffc21e0 18
  gen_rand                                   code  80000000000001ef 32
  getVarName                                 code  fffc2118 18
  gfn1                                       code  fffc19b0 18
  gfn2                                       code  fffc1960 18
  gfn3                                       code  fffc1990 18
  gosub1                                     code  fffc15e8 18
  gvn1                                       code  fffc21bc 18
  gvn2                                       code  fffc2180 18
  gvn3                                       code  fffc2198 18
  gvn4                                       code  fffc213c 18
  gvn6                                       code  fffc2170 18
  isAlnum                                    code  fffc1d28 18
  isAlpha                                    code  fffc1cf8 18
  isAlphaFalse                               code  fffc1d20 18
  isAlphaTrue                                code  fffc1d18 18
  isDigit                                    code  fffc1cd8 18
  isDigitFalse                               code  fffc1cf0 18
  isDigitx                                   code  fffc1d3c 18
  msgBadGotoGosub                            code  fffc2cec 18
  msgBytesFree                               code  fffc2c19 18
  msgComma                                   code  fffc2c31 18
  msgDivZero                                 code  fffc2bee 18
  msgExtraChars                              code  fffc2d35 18
  msgInf                                     code  fffc0b54 18
  msgInit                                    code  fffc2b70 18
  msgInputVar                                code  fffc2c98 18
  msgLineRange                               code  fffc2c45 18
  msgMonHelp                                 code  fffc0733 18
  msgNan                                     code  fffc0b58 18
  msgNextFor                                 code  fffc2cb5 18
  msgNextVar                                 code  fffc2cc8 18
  msgNumTooBig                               code  fffc2bda 18
  msgRNDBad                                  code  fffc2c72 18
  msgReadError                               code  fffc2bbf 18
  msgReady                                   code  fffc2c27 18
  msgRetWoGosub                              code  fffc2d09 18
  msgSYSBad                                  code  fffc2c86 18
  msgStart                                   code  fffc071c 18
  msgTooBig                                  code  fffc2d20 18
  msgVar                                     code  fffc2c5b 18
  msgVarSpace                                code  fffc2c01 18
  msgWhat                                    code  fffc2bae 18
  prCRLF                                     code  fffc27c4 18
  pword1                                     code  fffc1b18 18
  pword2                                     code  fffc1b34 18
  return1                                    code  fffc1624 18
  rnd1                                       code  fffc22f8 18
  rnd2                                       code  fffc2308 18
  sysx1                                      code  fffc1c20 18
  tah1                                       code  fffc1b68 18
  toAsciiHex                                 code  fffc1b58 18
  toUpper                                    code  fffc2ad4 18
  tstv_notfound                              code  fffc2104 18
  usrJmp                                    const  000788 12
  x10Save                                   const  000028 7
  x11Save                                   const  00002c 7
  x12Save                                   const  000030 7
  x13Save                                   const  000034 7
  x14Save                                   const  000038 7
  x15Save                                   const  00003c 7
  x16Save                                   const  000040 8
  x17Save                                   const  000044 8
  x18Save                                   const  000048 8
  x19Save                                   const  00004c 8
  x1Save                                    const  000004 4
  x20Save                                   const  000050 8
  x21Save                                   const  000054 8
  x22Save                                   const  000058 8
  x23Save                                   const  00005c 8
  x24Save                                   const  000060 8
  x25Save                                   const  000064 8
  x26Save                                   const  000068 8
  x27Save                                   const  00006c 8
  x28Save                                   const  000070 8
  x29Save                                   const  000074 8
  x2Save                                    const  000008 5
  x30Save                                   const  000078 8
  x31Save                                   const  00007c 8
  x3Save                                    const  00000c 5
  x4Save                                    const  000010 6
  x5Save                                    const  000014 6
  x6Save                                    const  000018 6
  x7Save                                    const  00001c 6
  x8Save                                    const  000020 7
  x9Save                                    const  000024 7

Undefined Symbols
  AUXIN                                      code  80000000000000f2 32
  AUXIN_INIT                                 code  80000000000001a0 32
  AUXOUT                                     code  80000000000000f0 32
  AUXOUT_FLUSH                               code  80000000000001ad 32
  AUXOUT_INIT                                code  80000000000001a4 32
  BYEBYE                                     code  80000000000000f4 32
  SDReadSector                               code  80000000000001a1 32
  SDWriteSector                              code  80000000000001a6 32
  _cls                                       code  800000000000012b 32
  _rdcf                                      code  800000000000012d 32
  gen_rand                                   code  80000000000001ef 32

  Macro Name
0 compressable instructions
The top 1024 are:
Comp  Opcode  Count
