                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "../fmtk/const.asm",1
                        	.file "../fmtk/const.asm",1
                        	; First 128 bytes are for integer register set
                        	; Second 128 bytes are for float register set
                        	; Leave some room for 64-bit regs
                        	TCBsegs			EQU		$200		; segment register storage
                        	TCBepc			EQU		$280
                        	TCBStatus		EQU		$288
                        	TCBPriority	EQU		$289
                        	TCBWaitMbx	EQU		$28A
                        	TCBStackBot	EQU		$290
                        	TCBMsgD1		EQU		$298
                        	TCBMsgD2		EQU		$2A0
                        	TCBMsgD3		EQU		$2A8
                        	TCBStartTick	EQU	$2B0
                        	TCBEndTick	EQU		$2B8
                        	TCBTicks		EQU		$2C0
                        	TCBException	EQU	$2C8
                        	TCBNext			EQU		$2D0
                        	TCBPrev			EQU		$2D8
                        	TCBTimeout	EQU		$2E0
                        	IOF_NEXT		EQU		$2E8
                        	IOF_PREV		EQU		$2F0
                        	TCBName			EQU		$2F8
                        	
                        	TS_NONE			EQU		0
                        	TS_READY		EQU		1
                        	TS_DEAD			EQU		2
                        	TS_MSGRDY		EQU		4
                        	TS_WAITMSG	EQU		8
                        	TS_TIMEOUT	EQU		16
                        	TS_PREEMPT	EQU		32
                        	TS_RUNNING	EQU		128
                        	
                        	; error codes
                        	E_Ok		=		0x00
                        	E_Arg		=		0x01
                        	E_BadMbx	=		0x04
                        	E_QueFull	=		0x05
                        	E_NoThread	=		0x06
                        	E_NotAlloc	=		0x09
                        	E_NoMsg		=		0x0b
                        	E_Timeout	=		0x10
                        	E_BadAlarm	=		0x11
                        	E_NotOwner	=		0x12
                        	E_QueStrategy =		0x13
                        	E_BadDevNum	=		0x18
                        	E_DCBInUse	=		0x19
                        	; Device driver errors
                        	E_BadDevNum	=		0x20
                        	E_NoDev		=		0x21
                        	E_BadDevOp	=		0x22
                        	E_ReadError	=		0x23
                        	E_WriteError =		0x24
                        	E_BadBlockNum	=	0x25
                        	E_TooManyBlocks	=	0x26
                        	
                        	; resource errors
                        	E_NoMoreMbx	=		0x40
                        	E_NoMoreMsgBlks	=	0x41
                        	E_NoMoreAlarmBlks	=0x44
                        	E_NoMoreTCBs	=	0x45
                        	E_NoMem		= 12
                        	
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "../fmtk/config.asm",1
                        	.file "../fmtk/config.asm",1
                        	MAX_TID		EQU		15
                        	NR_TCB		EQU		16
                        	OSPAGES		EQU		32		; pages of memory dedicated to OS
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "../fmtk/device.inc",1
                        	.file "../fmtk/device.inc",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2014-2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; DeviceDriver.inc
                        	; - Device driver structures and constants                                                                         
                        	; ============================================================================
                        	
                        	;	.global			; global constants
                        	
                        	; Device Control Block
                        	;
                        	DCB_Name			EQU		0		; string: first byte is length, 11 chars max
                        	DCB_Type			EQU		0x0C
                        	DCB_nBPB			EQU		0x10
                        	DCB_LastErc			EQU		0x18		; last error code
                        	DCB_StartBlock		EQU		0x20		; starting block number (partitioned devices)
                        	DCB_nBlocks			EQU		0x28		; number of blocks on device
                        	DCB_pCmdProc		EQU		0x30		; pointer to command processor routine
                        	DCB_ReentCount		EQU		0x38		; re-entrancy count (1 to 255)
                        	DCB_fSingleUser		EQU		0x39
                        	DCB_hJob			EQU		0x40		; handle to associated job
                        	DCB_Mbx				EQU		0x48
                        	DCB_pSema			EQU		0x50		; pointer to device semaphore
                        	DCB_Resv1			EQU		0x58		; reserved
                        	DCB_Resv2			EQU		0x60		; reserved
                        	DCB_Size			EQU		0x68
                        	
                        	; Device command opcodes
                        	;
                        	DVC_Nop				EQU		0
                        	DVC_Setup			EQU		1
                        	DVC_Initialize		EQU		2
                        	DVC_Status			EQU		3
                        	DVC_MediaCheck		EQU		4
                        	DVC_BuildBPB		EQU		5
                        	DVC_Open			EQU		6
                        	DVC_Close			EQU		7
                        	DVC_GetChar			EQU		8
                        	DVC_PeekChar		EQU		9
                        	DVC_GetCharDirect	EQU		10
                        	DVC_PeekCharDirect	EQU		11
                        	DVC_InputStatus		EQU		12
                        	DVC_PutChar			EQU		13
                        	DVC_SetPosition		EQU		15
                        	DVC_ReadBlock		EQU		16
                        	DVC_WriteBlock		EQU		17
                        	DVC_VerifyBlock		EQU		18
                        	DVC_OutputStatus	EQU		19
                        	DVC_FlushInput		EQU		20
                        	DVC_FlushOutput		EQU		21
                        	DVC_IRQ				EQU		22
                        	DVC_IsRemoveable	EQU		23
                        	DVC_IOCTRL_READ		EQU		24
                        	DVC_IOCTRL_WRITE	EQU		25
                        	DVC_OutputUntilBusy	EQU		26
                        	
                        	MAX_DEV_OP			EQU		31
                        	
                        	
                        	DRSP_DONE			EQU		1
                        	
                        	;Standard Devices are:
                        	
                        	;#		Device					Standard name
                        	
                        	;0		NULL device 			NUL		(OS built-in)
                        	;1		Keyboard (sequential)	KBD		(OS built-in)
                        	;2		Video (sequential)		VID		(OS built-in)
                        	;3		Printer (parallel 1)	LPT
                        	;4		Printer (parallel 2)	LPT2
                        	;5		RS-232 1				COM1	(OS built-in)
                        	;6		RS-232 2				COM2
                        	;7		RS-232 3				COM3
                        	;8		RS-232 4				COM4
                        	;9		Parallel xfer	  PTI
                        	;10		Floppy					FD0
                        	;11		Floppy					FD1
                        	;12		Hard disk				HD0
                        	;13		Hard disk				HD1
                        	;14
                        	;15
                        	;16		SDCard					CARD1 	(OS built-in)
                        	;17
                        	;18
                        	;19
                        	;20
                        	;21
                        	;22
                        	;23
                        	;24
                        	;25
                        	;26
                        	;27
                        	;28		Audio						PSG1	(OS built-in)
                        	;29
                        	;30   Random Number		PRNG
                        	;31		Debug						DBG
                        	
                        	NR_DCB			EQU		32
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	
                        	BS					equ		$08
                        	LF					equ		$0A
                        	CR					equ		$0D
                        	XON					equ		$11
                        	XOFF				equ		$13
                        	DEL					equ		$7F
                        	VIA					equ		$FFDC0600
                        	VIA_PA			equ		$04
                        	VIA_DDRA		equ		$0C
                        	VIA_T1CL		equ		$10
                        	VIA_T1CH		equ		$14
                        	VIA_ACR			equ		$2C
                        	VIA_PCR			equ		$30
                        	VIA_IFR			equ		$34
                        	VIA_IER			equ		$38
                        	VIA_PARAW		equ		$3C
                        	UART				equ		$FFDC0A00
                        	UART_TRB		equ		$00
                        	UART_STAT		equ		$04
                        	UART_CMD		equ		$08
                        			; First 16kB is for TCB's
                        	INBUF				equ		$4100
                        	switchflag	equ		$4200
                        	milliseconds	equ		$4208
                        	
                        	
                        	.file "cs01rom.asm",29
                        			code	18 bits
                        	;------------------------------------------------------------------------------
                        	; Exception vector table.
                        	;------------------------------------------------------------------------------
                        			org		$FFFC0000				; user mode exception
FFFC0000 7280006F			jmp		IRQRout
FFFC0004 00000000			org 	$FFFC00C0				; machine mode exception
FFFC0008 00000000
FFFC000C 00000000
FFFC0010 00000000
FFFC0014 00000000
FFFC0018 00000000
FFFC001C 00000000
FFFC0020 00000000
FFFC0024 00000000
FFFC0028 00000000
FFFC002C 00000000
FFFC0030 00000000
FFFC0034 00000000
FFFC0038 00000000
FFFC003C 00000000
FFFC0040 00000000
FFFC0044 00000000
FFFC0048 00000000
FFFC004C 00000000
FFFC0050 00000000
FFFC0054 00000000
FFFC0058 00000000
FFFC005C 00000000
FFFC0060 00000000
FFFC0064 00000000
FFFC0068 00000000
FFFC006C 00000000
FFFC0070 00000000
FFFC0074 00000000
FFFC0078 00000000
FFFC007C 00000000
FFFC0080 00000000
FFFC0084 00000000
FFFC0088 00000000
FFFC008C 00000000
FFFC0090 00000000
FFFC0094 00000000
FFFC0098 00000000
FFFC009C 00000000
FFFC00A0 00000000
FFFC00A4 00000000
FFFC00A8 00000000
FFFC00AC 00000000
FFFC00B0 00000000
FFFC00B4 00000000
FFFC00B8 00000000
FFFC00BC 00000000
FFFC00C0 6680006F			jmp		IRQRout
FFFC00C4 00000000			org		$FFFC00FC				; non-maskable interrupt
FFFC00C8 00000000
FFFC00CC 00000000
FFFC00D0 00000000
FFFC00D4 00000000
FFFC00D8 00000000
FFFC00DC 00000000
FFFC00E0 00000000
FFFC00E4 00000000
FFFC00E8 00000000
FFFC00EC 00000000
FFFC00F0 00000000
FFFC00F4 00000000
FFFC00F8 00000000
FFFC00FC 0040006F			jmp		MachineStart
                        	
                        	;------------------------------------------------------------------------------
                        	; User mode code starts here
                        	;------------------------------------------------------------------------------
                        			org		$FFFC0100
                        	MachineStart:
FFFC0100 00080737			ldi		$sp,#$80000-4		; setup machine mode stack pointer
FFFC0104 FFC70713
FFFC0108 321000EF			call	MMUInit					; initialize MMU for address space zero.
FFFC010C 550010EF			call	FMTKInit
FFFC0110 438010EF			call	ViaInit
FFFC0114 0A4010EF			call	SerialInit
FFFC0118 FFFC0D37			ldi		$t0,#$FFFC0000
FFFC011C 000D0D13
FFFC0120 301D1073			csrrw $x0,#$301,$t0		; set tvec
FFFC0124 FFFC0D37			ldi		$t0,#UserStart
FFFC0128 138D0D13
FFFC012C 341D1073			csrrw	$x0,#$341,$t0		; set mepc
FFFC0130 3000E073			csrrs	$x0,#$300,#1		; enable interrupts
FFFC0134 10000073			eret									; switch to user mode
                        	UserStart:
FFFC0138 00E06913			ldi		$a0,#14							; Get current tid
FFFC013C 00000073			ecall
FFFC0140 0008E9B3			mov		$a1,$v1
FFFC0144 01806913			ldi		$a0,#24							; RequestIOFocus
FFFC0148 00000073			ecall
FFFC014C 00080737			ldi		$sp,#$80000-1028		; setup user mode stack pointer
FFFC0150 BFC70713
FFFC0154 00806D13			ldi		$t0,#$08						; turn on the LED
FFFC0158 FFDC0637			sw		$t0,VIA+VIA_PARAW
FFFC015C 63C60613
FFFC0160 00060633
FFFC0164 01A62023
FFFC0168 01006E13			ldi		$t2,#16							; send an XON just in case
FFFC016C 01106A93			ldi		$a3,#XON
                        	.0004:
FFFC0170 1FC010EF			call	SerialPutChar
FFFC0174 FFFE0E13			sub		$t2,$t2,#1
FFFC0178 FE0E1CE3			bne		$t2,$x0,.0004
                        	.0002:
FFFC017C FFFC0937			ldi		$a0,#msgStart				; spit out a startup message
FFFC0180 76490913
FFFC0184 570000EF			call	PutString
FFFC0188 00106913			ldi		a0,#1
FFFC018C 000069B7			ldi		a1,#24000
FFFC0190 DC098993
FFFC0194 FFFC0A37			ldi		a2,#Monitor
FFFC0198 2A0A0A13
FFFC019C 00000073			ecall
FFFC01A0 0E000C63			bra		MonEntry
                        	
                        			; Now a loop to recieve and echo back characters
                        	.0003:
FFFC01A4 110010EF			call	SerialPeekChar
FFFC01A8 FE084EE3			blt		$v0,$x0,.0003
FFFC01AC 00086933			mov		$a0,$v0
FFFC01B0 1BC010EF			call	SerialPutChar
FFFC01B4 FE0008E3			bra		.0003
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a character from input device. Checks for a CTRL-T which indicates to
                        	; switch the I/O focus.
                        	;
                        	; Parameters:
                        	;		none
                        	; Returns:
                        	;		v0 = character, -1 if none available
                        	;------------------------------------------------------------------------------
                        	
                        	Getch:
FFFC01B8 FF870713		sub		$sp,$sp,#8
FFFC01BC 00172023		sw		$ra,[$sp]
FFFC01C0 01272223		sw		$a0,4[$sp]
                        	.0002:
FFFC01C4 01406913		ldi		$a0,#20							; HasIOFocus?
FFFC01C8 00000073		ecall
FFFC01CC 00089263		bne		$v1,$x0,.hasFocus
                        	;	ldi		a0,#13							; reschedule
                        	;	ecall
                        	;	bra		.0002
                        	.hasFocus:
FFFC01D0 150010EF		call	SerialPeekCharDirect
FFFC01D4 01406913		ldi		a0,#$14							; CTRL-T
FFFC01D8 01281663		bne		$v0,$a0,.0001
FFFC01DC 01506913		ldi		$a0,#21							; switch IO Focus
FFFC01E0 00000073		ecall
                        	.0001:
FFFC01E4 00072083		lw		$ra,[$sp]
FFFC01E8 00472903		lw		$a0,4[$sp]
FFFC01EC 00870713		add		$sp,$sp,#8
FFFC01F0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	Putch:
FFFC01F4 FEC70713		sub		$sp,$sp,#20
FFFC01F8 00172023		sw		$ra,[$sp]
FFFC01FC 01072223		sw		$v0,4[$sp]
FFFC0200 01272423		sw		$a0,8[$sp]
FFFC0204 01172623		sw		$v1,12[$sp]
FFFC0208 01372823		sw		$a1,16[$sp]
FFFC020C 00096AB3		mov		$a3,$a0
FFFC0210 00506993		ldi		$a1,#5							; serial port
FFFC0214 020000EF		call	fputc
FFFC0218 00072083		lw		$ra,[$sp]
FFFC021C 00472803		lw		$v0,4[$sp]
FFFC0220 00872903		lw		$a0,8[$sp]
FFFC0224 00C72883		lw		$v1,12[$sp]
FFFC0228 01072983		lw		$a1,16[$sp]
FFFC022C 01470713		add		$sp,$sp,#20
FFFC0230 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; fputc - put a character to an I/O device. If the task doesn't have the I/O
                        	; focus then it is rescheduled, allowing another task to run.
                        	;
                        	; Stack Space:
                        	;		6 words
                        	; Register Usage:
                        	;		a0 = FMTK_IO specify
                        	;		a2 = device putchar function
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a3 = character to put
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	fputc:
FFFC0234 FE870713		sub		$sp,$sp,#24
FFFC0238 00172023		sw		$ra,[$sp]
FFFC023C 01072223		sw		$v0,4[$sp]
FFFC0240 01272423		sw		$a0,8[$sp]
FFFC0244 01172623		sw		$v1,12[$sp]
FFFC0248 01372823		sw		$a1,16[$sp]
FFFC024C 01472A23		sw		$a2,20[$sp]
                        	.0001:
FFFC0250 01406913		ldi		$a0,#20							; HasIOFocus?
FFFC0254 00000073		ecall
FFFC0258 00089A63		bne		$v1,$x0,.hasFocus
FFFC025C 00506913		ldi		a0,#5								; reschedule (sleep 0)
FFFC0260 00006993		ldi		a1,#0
FFFC0264 00000073		ecall
FFFC0268 FE0004E3		bra		.0001
                        	.hasFocus:
FFFC026C 01A06913		ldi		$a0,#26							; FMTK_IO
FFFC0270 00D06A13		ldi		$a2,#13							; putchar function
FFFC0274 00000073		ecall
FFFC0278 00072083		lw		$ra,[$sp]
FFFC027C 00472803		lw		$v0,4[$sp]
FFFC0280 00872903		lw		$a0,8[$sp]
FFFC0284 00C72883		lw		$v1,12[$sp]
FFFC0288 01072983		lw		$a1,16[$sp]
FFFC028C 01472A03		lw		$a2,20[$sp]
FFFC0290 01870713		add		$sp,$sp,#24
FFFC0294 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	MonEntry:
                        	;		flw			$f2,fltTen
                        	;		fsw			$f2,f2Save
                        	;		flw			$f1,fltTen
                        	;		fsw			$f1,f1Save
                        	;		fadd		$f18,$f2,$f1
                        	;		fsw			$f18,f18Save
FFFC0298 00A06913			ldi		$a0,#10
FFFC029C 00606A13			ldi		$a2,#6
                        	;		call	fltToString
                        	;		ldi		$a0,#STRTMP
                        	;		call	PutString
                        	
                        	Monitor:
FFFC02A0 00006213			ldi		$s1,#0					; s1 = input pointer
FFFC02A4 00D06913			ldi		$a0,#CR
FFFC02A8 F4DFF0EF			call	Putch
FFFC02AC 00006913			ldi		$a0,#LF
		call	Putch
FFFC02B0 F45FF0EF
FFFC02B4 03E06913			ldi		$a0,#'>'
FFFC02B8 F3DFF0EF			call	Putch
                        	.0001:
FFFC02BC EFDFF0EF			call	Getch						; wait until character pressed
FFFC02C0 FE084EE3			blt		$v0,$x0,.0001
FFFC02C4 00084D13			xor		$t0,$v0,#LF			; ignore line feed
		beq		$t0,$x0,.procLine
FFFC02C8 0E0D0C63
FFFC02CC 00D84D13			xor		$t0,$v0,#CR
FFFC02D0 0E0D0863			beq		$t0,$x0,.procLine
FFFC02D4 00884D13			xor		$t0,$v0,#BS
FFFC02D8 080D0263			beq		$t0,$x0,.doBackspace
FFFC02DC 07F84D13			xor		$t0,$v0,#DEL
FFFC02E0 020D0263			beq		$t0,$x0,.doDelete
FFFC02E4 00004637			sb		$v0,INBUF[$s1]
FFFC02E8 10060613
FFFC02EC 00460633
FFFC02F0 01060023
FFFC02F4 00120213			add		$s1,$s1,#1
FFFC02F8 00086933			mov		$a0,$v0
FFFC02FC EF9FF0EF			call	Putch
FFFC0300 FA000EE3			bra		.0001
                        	.doDelete:
FFFC0304 000262B3			mov		$s2,$s1
FFFC0308 00128293			add		$s2,$s2,#1
                        	.0002:
FFFC030C 00004637			lb		$t0,INBUF[$s2]
FFFC0310 10060613
FFFC0314 00560633
FFFC0318 00060D03
FFFC031C 00004637			sb		$t0,INBUF-1[$s2]
FFFC0320 0FF60613
FFFC0324 00560633
FFFC0328 01A60023
FFFC032C 00128293			add		$s2,$s2,#1
FFFC0330 00004637			add		$t0,$s2,#INBUF
FFFC0334 10060613
FFFC0338 00560D33
FFFC033C 00004637			slt		$t0,$t0,#INBUF+$7F
FFFC0340 17F60613
FFFC0344 FC0D14E3			bne		$t0,$x0,.0002
FFFC0348 00004637			sb		$x0,INBUF[$s2]
FFFC034C 10060613
FFFC0350 00560633
FFFC0354 00060023
FFFC0358 F60002E3			bra		.0001
                        	.doBackspace:
FFFC035C F60200E3			beq		$s1,$x0,.0001		; can't backspace anymore
FFFC0360 00086933			mov		$a0,$v0					; show the backspace
FFFC0364 E91FF0EF			call	Putch
FFFC0368 FFF20213			sub		$s1,$s1,#1
FFFC036C 000262B3			mov		$s2,$s1
                        	.0003:
FFFC0370 00004637			lb		$t0,INBUF+1[$s2]
FFFC0374 10160613
FFFC0378 00560633
FFFC037C 00060D03
FFFC0380 00004637			sb		$t0,INBUF[$s2]
FFFC0384 10060613
FFFC0388 00560633
FFFC038C 01A60023
FFFC0390 00128293			add		$s2,$s2,#1
FFFC0394 00004637			add		$t0,$s2,#INBUF
FFFC0398 10060613
FFFC039C 00560D33
FFFC03A0 00004637			slt		$t0,$t0,#INBUF+$7F
FFFC03A4 17F60613
FFFC03A8 FC0D14E3			bne		$t0,$x0,.0003
FFFC03AC 00004637			sb		$x0,INBUF[$s2]
FFFC03B0 10060613
FFFC03B4 00560633
FFFC03B8 00060023
FFFC03BC F00000E3			bra		.0001
                        	.procLine:
FFFC03C0 00004637			sb		$x0,INBUF[$s1]
FFFC03C4 10060613
FFFC03C8 00460633
FFFC03CC 00060023
FFFC03D0 00006213			ldi		$s1,#0
                        	.skip:
FFFC03D4 00004637			lb		$t0,INBUF[$s1]
FFFC03D8 10060613
FFFC03DC 00460633
FFFC03E0 00060D03
FFFC03E4 0C0D0A63			beq		$t0,$x0,.0005
FFFC03E8 03ED4D93			xor		$t1,$t0,#'>'
FFFC03EC 000D9663			bne		$t1,$x0,.0004
                        	.skip2:
FFFC03F0 00120213			add		$s1,$s1,#1
FFFC03F4 FE0000E3			bra		.skip
                        	.0004:
FFFC03F8 020D4D93			xor		$t1,$t0,#' '
FFFC03FC FE0D8AE3			beq		$t1,$x0,.skip2
FFFC0400 009D4D93			xor		$t1,$t0,#'\t'
FFFC0404 FE0D86E3			beq		$t1,$x0,.skip2
FFFC0408 04DD4D93			xor		$t1,$t0,#'M'
FFFC040C 0A0D8863			beq		$t1,$x0,doMem
FFFC0410 04206D93			ldi		$t1,#'B'
FFFC0414 05BD1663			bne		$t0,$t1,.0006
FFFC0418 00106913			ldi		$a0,#1					; Start task
FFFC041C 000089B7			ldi		$a1,#32000			; 32 kB
FFFC0420 D0098993
FFFC0424 FFFC3A37			ldi		$a2,#CSTART			; start address
FFFC0428 830A0A13
FFFC042C 00000073			ecall
FFFC0430 0008E233			mov		$s1,$v1					; save v1
FFFC0434 FFFC1937			ldi		$a0,#msgCRLF
FFFC0438 82A90913
FFFC043C 2B8000EF			call	PutString
FFFC0440 00026933			mov		$a0,$s1					; get back v1
FFFC0444 250000EF			call	PutHexByte
FFFC0448 FFFC1937			ldi		$a0,msgTaskStart
FFFC044C 81C90913
FFFC0450 2A4000EF			call	PutString
FFFC0454 00D06913			ldi		$a0,#13					; Reschedule task
FFFC0458 00000073			ecall
FFFC045C E45FF06F			jmp		Monitor
                        	.0006:
FFFC0460 04406D93			ldi		$t1,#'D'
FFFC0464 01BD1663			bne		$t0,$t1,.0007
FFFC0468 78D010EF			call 	DumpReadyQueue
                        			;ldi		$a0,#15
                        			;ecall
FFFC046C E35FF06F			jmp		Monitor
                        	.0007:
FFFC0470 04506D93			ldi		$t1,#'E'
FFFC0474 01BD1463			bne		$t0,$t1,.0008
FFFC0478 0CC0006F			jmp		EditMem
                        	.0008:
FFFC047C 04606D93			ldi		$t1,#'F'
FFFC0480 01BD1463			bne		$t0,$t1,.0009
FFFC0484 0D80006F			jmp		FillMem
                        	.0009:
FFFC0488 05306D93			ldi		$t1,#'S'
FFFC048C 01BD1863			bne		$t0,$t1,.0010
FFFC0490 00D06913			ldi		$a0,#13
FFFC0494 00000073			ecall
FFFC0498 E09FF06F			jmp		Monitor
                        	.0010:
FFFC049C 04B06D93			ldi		$t1,#'K'
FFFC04A0 01BD1C63			bne		$t0,$t1,.0011
FFFC04A4 110000EF			call	GetHexNum
FFFC04A8 00306913			ldi		$a0,#3					; kill task
FFFC04AC 000869B3			mov		$a1,$v0					; a0 = pid
FFFC04B0 00000073			ecall
FFFC04B4 DEDFF06F			jmp		Monitor
                        	.0011:
                        	.0005:
FFFC04B8 DE0004E3			bra		Monitor
                        	
                        	doMem:
FFFC04BC FFC70713			sub		$sp,$sp,#4
FFFC04C0 00120213			add		$s1,$s1,#1
FFFC04C4 00472023			sw		$s1,[$sp]
FFFC04C8 00D06913			ldi		$a0,#CR
FFFC04CC D29FF0EF			call	Putch
FFFC04D0 00004937			ldi		$a0,INBUF
FFFC04D4 10090913
FFFC04D8 21C000EF			call	PutString
FFFC04DC 00072203			lw		$s1,[$sp]
FFFC04E0 00470713			add		$sp,$sp,#4
FFFC04E4 0D0000EF			call	GetHexNum
FFFC04E8 00086333			mov		$s3,$v0
FFFC04EC 00120213			add		$s1,$s1,#1
FFFC04F0 0C4000EF			call	GetHexNum
FFFC04F4 006803B3			add		$s4,$v0,$s3
                        	.loop2:
FFFC04F8 CC1FF0EF			call	Getch						; check for ctrl-c
FFFC04FC 00384813			xor		$v0,$v0,#3
FFFC0500 DA0800E3			beq		$v0,$x0,Monitor
FFFC0504 00D06913			ldi		$a0,#CR
FFFC0508 CEDFF0EF			call	Putch
FFFC050C 00036933			mov		$a0,$s3
FFFC0510 144000EF			call	PutHexWord
FFFC0514 03A06913			ldi		$a0,#':'
FFFC0518 CDDFF0EF			call	Putch
FFFC051C 00706293			ldi		$s2,#7
                        	.loop:
FFFC0520 02006913			ldi		$a0,#' '
FFFC0524 CD1FF0EF			call	Putch
FFFC0528 00030903			lb		$a0,[$s3]
FFFC052C 168000EF			call	PutHexByte
FFFC0530 00130313			add		$s3,$s3,#1
FFFC0534 FFF28293			sub		$s2,$s2,#1
FFFC0538 FE02D4E3			bge		$s2,$x0,.loop
FFFC053C FA736EE3			bltu	$s3,$s4,.loop2
FFFC0540 D60000E3			bra		Monitor		
                        	
                        	EditMem:
FFFC0544 070000EF			call	GetHexNum			; get address to edit
FFFC0548 00086333			mov		$s3,$v0
FFFC054C 00120213			add		$s1,$s1,#1
FFFC0550 064000EF			call	GetHexNum			; get value to set
FFFC0554 00680023			sb		$s3,[$v0]			; update mem
FFFC0558 D49FF06F			jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	;	>F 1000 800 EE
                        	; Fills memory beginning at address $1000 for $800 bytes with the value $EE
                        	;------------------------------------------------------------------------------
                        	
                        	FillMem:
FFFC055C 058000EF			call	GetHexNum			; get address
FFFC0560 00086333			mov		$s3,$v0
FFFC0564 00120213			add		$s1,$s1,#1
FFFC0568 04C000EF			call	GetHexNum			; get length
FFFC056C 000863B3			mov		$s4,$v0
FFFC0570 00120213			add		$s1,$s1,#1
FFFC0574 040000EF			call	GetHexNum			; get byte to use
                        	.0001:
FFFC0578 01030023			sb		$v0,[$s3]
FFFC057C FFF38393			sub		$s4,$s4,#1
FFFC0580 FE704CE3			bgt		$s4,$x0,.0001
FFFC0584 D1DFF06F			jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; Skip over spaces and tabs in the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	SkipSpaces:
                        	.skip2:
FFFC0588 00004637			lb		$t0,INBUF[$s1]
FFFC058C 10060613
FFFC0590 00460633
FFFC0594 00060D03
FFFC0598 020D4D93			xor		$t1,$t0,#' '
FFFC059C 000D8863			beq		$t1,$x0,.skip1
FFFC05A0 009D4D93			xor		$t1,$t0,#'\t'
FFFC05A4 000D8463			beq		$t1,$x0,.skip1
FFFC05A8 00008067			ret
                        	.skip1:
FFFC05AC 00120213			add		$s1,$s1,#1
FFFC05B0 FC000CE3			bra		.skip2
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a hex number from the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	GetHexNum:
FFFC05B4 00006813			ldi		$v0,#0							; v0 = num
FFFC05B8 FFC70713			sub		$sp,$sp,#4
FFFC05BC 00172023			sw		$ra,[$sp]
FFFC05C0 FC9FF0EF			call	SkipSpaces
                        	.next:
FFFC05C4 00004637			lb		$t0,INBUF[$s1]
FFFC05C8 10060613
FFFC05CC 00460633
FFFC05D0 00060D03
FFFC05D4 03006E13			ldi		$t2,#'0'
FFFC05D8 03CD4663			blt		$t0,$t2,.0001
FFFC05DC 03A06E13			ldi		$t2,#'9'+1
FFFC05E0 07CD4063			blt		$t0,$t2,.isDigit
FFFC05E4 04106E13			ldi		$t2,#'A'
FFFC05E8 01CD4E63			blt		$t0,$t2,.0001
FFFC05EC 04706E13			ldi		$t2,#'F'+1
FFFC05F0 03CD4063			blt		$t0,$t2,.isHexUpper
FFFC05F4 06106E13			ldi		$t2,#'a'
FFFC05F8 01CD4663			blt		$t0,$t2,.0001
FFFC05FC 06706E13			ldi		$t2,#'f'+1
FFFC0600 03CD4463			blt		$t0,$t2,.isHexLower
                        	.0001:
FFFC0604 00072083			lw		$ra,[$sp]
FFFC0608 00470713			add		$sp,$sp,#4
FFFC060C 00008067			ret
                        	.isHexUpper:
FFFC0610 00481813			sll		$v0,$v0,#4
FFFC0614 FBFD0D13			sub		$t0,$t0,#'A'
FFFC0618 00AD0D13			add		$t0,$t0,#10
FFFC061C 01A86833			or		$v0,$v0,$t0
FFFC0620 00120213			add		$s1,$s1,#1
FFFC0624 FA0000E3			bra		.next
                        	.isHexLower:
FFFC0628 00481813			sll		$v0,$v0,#4
FFFC062C F9FD0D13			sub		$t0,$t0,#'a'
FFFC0630 00AD0D13			add		$t0,$t0,#10
FFFC0634 01A86833			or		$v0,$v0,$t0
FFFC0638 00120213			add		$s1,$s1,#1
FFFC063C F80004E3			bra		.next
                        	.isDigit:
FFFC0640 00481813			sll		$v0,$v0,#4
FFFC0644 FD0D0D13			sub		$t0,$t0,#'0'
FFFC0648 01A86833			or		$v0,$v0,$t0
FFFC064C 00120213			add		$s1,$s1,#1
FFFC0650 F6000AE3			bra		.next
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a word as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexWord:
FFFC0654 FF870713			sub		$sp,$sp,#8
FFFC0658 00172023			sw		$ra,[$sp]
FFFC065C 01272223			sw		$a0,4[$sp]
FFFC0660 01095913			srl		$a0,$a0,#16
FFFC0664 010000EF			call	PutHexHalf
FFFC0668 00072083			lw		$ra,[$sp]
FFFC066C 00472903			lw		$a0,4[$sp]
FFFC0670 00870713			add		$sp,$sp,#8	; fall through to PutHexHalf
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a half-word (16 bits) as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexHalf:
FFFC0674 FF870713			sub		$sp,$sp,#8
FFFC0678 00172023			sw		$ra,[$sp]
FFFC067C 01272223			sw		$a0,4[$sp]
FFFC0680 00895913			srl		$a0,$a0,#8
FFFC0684 010000EF			call	PutHexByte
FFFC0688 00072083			lw		$ra,[$sp]
FFFC068C 00472903			lw		$a0,4[$sp]		
FFFC0690 00870713			add		$sp,$sp,#8	; fall through to PutHexByte
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a byte as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexByte:
FFFC0694 FF870713			sub		$sp,$sp,#8
FFFC0698 00172023			sw		$ra,[$sp]
FFFC069C 01272223			sw		$a0,4[$sp]
FFFC06A0 00495913			srl		$a0,$a0,#4		; put the high order nybble first
FFFC06A4 010000EF			call	PutHexNybble
FFFC06A8 00072083			lw		$ra,[$sp]
FFFC06AC 00472903			lw		$a0,4[$sp]
FFFC06B0 00870713			add		$sp,$sp,#8		; fall through to PutHexNybble
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a nybble as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexNybble:
FFFC06B4 FF870713			sub		$sp,$sp,#8
FFFC06B8 00172023			sw		$ra,[$sp]
FFFC06BC 01272223			sw		$a0,4[$sp]
FFFC06C0 00F97913			and		$a0,$a0,#15		; strip off high order bits
FFFC06C4 00A06D13			ldi		$t0,#10
FFFC06C8 01A94A63			blt		$a0,$t0,.lt10
FFFC06CC FF690913			sub		$a0,$a0,#10
FFFC06D0 04190913			add		$a0,$a0,#'A'
FFFC06D4 B21FF0EF			call	Putch
FFFC06D8 00000663			bra		.0001
                        	.lt10:
FFFC06DC 03090913			add		$a0,$a0,#'0'
FFFC06E0 B15FF0EF			call	Putch
                        	.0001:
FFFC06E4 00072083			lw		$ra,[$sp]
FFFC06E8 00472903			lw		$a0,4[$sp]
FFFC06EC 00870713			add		$sp,$sp,#8
FFFC06F0 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; PutString
                        	;    Put a string of characters to the serial transmitter. Calls the 
                        	; Putch routine, so this routine also blocks if the transmitter is not
                        	; empty.
                        	;
                        	; Parameters:
                        	;		$a0 = pointer to null terminated string to put
                        	; Modifies:
                        	;		$t0 and $t1
                        	; Stack Space:
                        	;		2 words
                        	;------------------------------------------------------------------------------
                        	
                        	PutString:
FFFC06F4 FF870713			sub		$sp,$sp,#8				; save link register
FFFC06F8 00172023			sw		$ra,[$sp]
FFFC06FC 01272223			sw		$a0,4[$sp]				; and argument
FFFC0700 00096DB3			mov		$t1,$a0						; t1 = pointer to string
                        	.0001:
FFFC0704 000D8903			lb		$a0,[$t1]
FFFC0708 001D8D93			add		$t1,$t1,#1				; advance pointer to next byte
FFFC070C 00090663			beq		$a0,$x0,.done			; branch if done
FFFC0710 AE5FF0EF			call	Putch							; output character
FFFC0714 FE0008E3			bra		.0001
                        	.done:
FFFC0718 00072083			lw		$ra,[$sp]					; restore return address
FFFC071C 00472903			lw		$a0,4[$sp]				; and argument
FFFC0720 00870713			add		$sp,$sp,#8
FFFC0724 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Exception processing code starts here.
                        	;------------------------------------------------------------------------------
                        	.file "cs01rom.asm",550
                        		code
                        		align	4                        	
                        	IRQRout:
FFFC0728 00080737		ldi		$sp,#$80000-4		; setup machine mode stack pointer
FFFC072C FFC70713
FFFC0730 34201D73		csrrw	$t0,#$342,$x0			; get cause code
FFFC0734 000D4663		blt		$t0,$x0,.isIRQ		; irq or ecall?
FFFC0738 3A00106F		jmp		OSCALL					; 
FFFC073C 10000073		eret										
                        	.isIRQ:
FFFC0740 01FD7D13		and		$t0,$t0,#31			; device # is low order 5 bits of cause code
FFFC0744 007D1D13		sll		$t0,$t0,#7				; 128 bytes per device func table
FFFC0748 0000A637		add		$t0,$t0,#DVF_Base+22*4	; IRQ routine
FFFC074C 05860613
FFFC0750 01A60D33
FFFC0754 000D2D03		lw		$t0,[$t0]
FFFC0758 000D0463		beq		$t0,$x0,.noIRQ
FFFC075C 000D0067		jmp		[$t0]
                        	.noIRQ:
FFFC0760 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Message strings
                        	;------------------------------------------------------------------------------
                        	
                        	msgStart:
FFFC0764 31305343			db		"CS01 System Starting.",13
FFFC0768 73795320
FFFC076C 206D6574
FFFC0770 72617453
FFFC0774 676E6974
FFFC0778 6F4D0D2E
                        	msgMonHelp:
FFFC077A 696E6F4D			db		"Monitor Commands",13
FFFC077E 20726F74
FFFC0782 6D6D6F43
FFFC0786 73646E61
FFFC078A 2D20420D
FFFC078B 202D2042			db		"B - start tiny basic",13
FFFC078F 72617473
FFFC0793 69742074
FFFC0797 6220796E
FFFC079B 63697361
FFFC079F 2D20440D
FFFC07A0 202D2044			db		"D - dump ready que",13
FFFC07A4 706D7564
FFFC07A8 61657220
FFFC07AC 71207964
FFFC07B0 450D6575
FFFC07B3 202D2045			db		"E - edit memory",13
FFFC07B7 74696465
FFFC07BB 6D656D20
FFFC07BF 0D79726F
FFFC07C3 202D2046			db		"F - fill memory",13
FFFC07C7 6C6C6966
FFFC07CB 6D656D20
FFFC07CF 0D79726F
FFFC07D3 743C204B			db		"K <tid> - kill task", 13
FFFC07D7 203E6469
FFFC07DB 696B202D
FFFC07DF 74206C6C
FFFC07E3 0D6B7361
FFFC07E7 733C204D			db		"M <start> <length>	- dump memory",13
FFFC07EB 74726174
FFFC07EF 6C3C203E
FFFC07F3 74676E65
FFFC07F7 2D093E68
FFFC07FB 6D756420
FFFC07FF 656D2070
FFFC0803 79726F6D
FFFC0807 2D20530D
FFFC0808 202D2053			db		"S - switch task",13
FFFC080C 74697773
FFFC0810 74206863
FFFC0814 0D6B7361
FFFC0818 00000000			db		0
FFFC0819 20000000			align 
                        	
                        	msgTaskStart:
FFFC081C 73617420			db		" task started."
FFFC0820 7473206B
FFFC0824 65747261
FFFC0828 0A0D2E64
                        	msgCRLF:
FFFC082A 00000A0D			db		13,10,0
                        	flt50:
FFFC082D 00000000		dw	0x00000000,0x00000000,0x00000000,0x40049000
FFFC0831 00000000
FFFC0835 00000000
FFFC0839 40049000
                        	flt20:
FFFC083D 00000000		dw	0x00000000,0x00000000,0x00000000,0x40034000
FFFC0841 00000000
FFFC0845 00000000
FFFC0849 40034000
                        	flt10:
FFFC084D 00000000		dw	0x00000000,0x00000000,0x00000000,0x40024000
FFFC0851 00000000
FFFC0855 00000000
FFFC0859 40024000
                        	
                        	.file "fltToString.asm",1
                        	.file "fltToString.asm",1
                        	STRTMP		equ		$0200
                        	
                        	; -----------------------------------------------------------------------------
                        	;		$fa0 = number to convert (f18)
                        	;		$a1	= width
                        	;		$a2 = precision
                        	;		$a3 = E
                        	;		$t2 = ndx
                        	;		$s9 = exp
                        	; -----------------------------------------------------------------------------
                        	
                        	fltToString:
FFFC085D 006E1300			ldi		$t2,#0				; $t2 = 0
FFFC0861 09095300
FFFC0862 E0090953			fmv		$a0,$f18
FFFC0866 7F800637			and		$t0,$a0,#$7F800000
FFFC086A 00060613
FFFC086E 01267D33
FFFC0872 7F800DB7			ldi		$t1,#$7F800000
FFFC0876 000D8D93
FFFC087A 05BD1263			bne		$t0,$t1,.0001
FFFC087E 00800637			and		$t0,$a0,#$007FFFFF
FFFC0882 FFF60613
FFFC0886 01267D33
FFFC088A 000D0E63			beq		$t0,$x0,.inf
FFFC088E FFFC1637			ldt		$t0,msgNan
FFFC0892 C1860613
FFFC0896 00060633
FFFC089A 00062D03
FFFC089E 21A02023			stt		$t0,STRTMP
FFFC08A2 2E000E63			bra		.prt
                        	.inf:
FFFC08A6 FFFC1637			ldt		$t0,msgInf
FFFC08AA C1460613
FFFC08AE 00060633
FFFC08B2 00062D03
FFFC08B6 21A02023			stt		$t0,STRTMP
FFFC08BA 2E000263			bra		.prt
                        	.0001:
FFFC08BE 80000637			and		$t0,$a0,#$80000000
FFFC08C2 00060613
FFFC08C6 01267D33
FFFC08CA 000D0E63			beq		$t0,$x0,.pos
FFFC08CE 02D06D13			ldi		$t0,#'-'
FFFC08D2 21AE0023			stb		$t0,STRTMP[$t2]
FFFC08D6 001E0E13			add		$t2,$t2,#1
FFFC08DA 80000637			and		$a0,$a0,#$7FFFFFFF
FFFC08DE FFF60613
FFFC08E2 01267933
                        	.pos:
FFFC08E6 00091A63			bne		$a0,$x0,.notZero
FFFC08EA 03006D13			ldi		$t0,#'0'
FFFC08EE 21AE0023			stb		$t0,STRTMP[$t2]
FFFC08F2 200E00A3			stb		$x0,STRTMP+1[$t2]
FFFC08F6 2A000463			bra		.prt		
                        	.notZero:
FFFC08FA 00006633			mov		$s9,$x0			; exp = 0.0
                        	;	// Make a small number > 0 so we can get at the digits.
                        	;	if (dbl < 1.0) {
                        	;		while (dbl < 1.0) {
                        	;			dbl *= 1000000.0;
                        	;			exp -= 6;  
                        	;		}
                        	;	}
FFFC08FE FFFC1637			flw		$f3,fltOne
FFFC0902 C1C60613
FFFC0906 00060633
FFFC090A 00062187
FFFC090E F0090053			fmv		$f0,$a0
FFFC0912 A0391D53			flt		$t0,$f18,$f3
FFFC0916 020D0463			beq		$t0,$x0,.0002
FFFC091A FFFC1637			flw		$f4,fltMillion
FFFC091E C2460613
FFFC0922 00060633
FFFC0926 00062207
                        	.0003:
FFFC092A A0391D53			flt		$t0,$f18,$f3
FFFC092E 000D0863			beq		$t0,$x0,.0002
FFFC0932 10490953			fmul	$f18,$f18,$f4
FFFC0936 FFA60613			sub		$s9,$s9,#6
FFFC093A FE0008E3			bra		.0003
                        	.0002:
                        	;	// The following is similar to using log10() and pow() functions.
                        	;	// Now dbl is >= 1.0
                        	;	// Create a number dbl2 on the same order of magnitude as dbl, but
                        	;	// less than dbl.
                        	;	dbl2 = 1.0;
                        	;	dbla = dbl2;
                        	;	if (dbl > dbl2) {	// dbl > 1.0 ?
                        	;		while (dbl2 <= dbl) {
                        	;			dbla = dbl2;
                        	;			dbl2 *= 10.0;	// increase power of 10
                        	;			exp++;
                        	;		}
                        	;		// The above loop goes one too far, we want the last value less
                        	;		// than dbl.
                        	;		dbl2 = dbla;
                        	;		exp--;
                        	;	}
FFFC093E FFFC1637			flw		$f1,fltOne				; $f1 = dbl2 = 1.0
FFFC0942 C1C60613
FFFC0946 00060633
FFFC094A 00062087
FFFC094E 38008153			fmov	$f2,$f1						; $f2 = dbla = dbl2
FFFC0952 A1209D53			flt		$t0,$f1,$f18				; if (dbl2 < dbl)
FFFC0956 020D0A63			beq		$t0,$x0,.0004
FFFC095A FFFC1637			flw		$f5,fltTen				; $f5 = 10.0
FFFC095E C2060613
FFFC0962 00060633
FFFC0966 00062287
                        	.0006:
FFFC096A A1208D53			fle		$t0,$f1,$f18				; while ($f1 <= $f18)
FFFC096E 000D0A63			beq		$t0,$x0,.0005
FFFC0972 38008153			fmov	$f2,$f1						; dbla = dbl2
FFFC0976 105080D3			fmul	$f1,$f1,$f5				; dbl2 *= 10.0
FFFC097A 00160613			add		$s9,$s9,#1				; exp++;
FFFC097E FE0006E3			bra		.0006
                        	.0005:
FFFC0982 380100D3			fmov	$f1,$f2						; dbl2 = dbla
FFFC0986 FFF60613			sub		$s9,$s9,#1				; exp--;
                        	.0004:
                        	;	// For small constants < 1000000 try and spit out a whole number
                        	;    if (exp >= 0 && exp < 6) {
                        	;        digits_before_decpt = exp+1;
                        	;		exp = 0;
                        	;	}
                        	;	else if (exp >= -6)
                        	;		digits_before_decpt = 1;
                        	;	else
                        	;		digits_before_decpt = -1;
FFFC098A 00064E63			blt		$s9,$x0,.0007
FFFC098E 00606413			ldi		$s5,#6
FFFC0992 00865A63			bge		$s9,$s5,.0007
FFFC0996 FFFFE233			mov		$s1,#s0						; s1 = digits before decpt
FFFC099A 00120213			add		$s1,$s1,#1
FFFC099E 00006613			ldi		$s9,#0						; exp = 0
FFFC09A2 00000C63			bra		.0008
                        	.0007:
FFFC09A6 FF906413			ldi		$s5,#-7
FFFC09AA 00864663			blt		$s9,$s5,.0009
FFFC09AE 00106213			ldi		$s1,#1
FFFC09B2 00000463			bra		.0008
                        	.0009:
FFFC09B6 FFF06213			ldi		$s1,#-1
                        	.0008:
                        	;	// Spit out a leading zero before the decimal point for a small number.
                        	;    if (exp < -6) {
                        	;		buf[ndx] = '0';
                        	;		ndx++;
                        	;        buf[ndx] = '.';
                        	;        ndx++;
                        	;    }
FFFC09BA FFA06413			ldi		$s5,#-6
FFFC09BE 00865E63			bge		$s9,$s5,.0010
FFFC09C2 03006D13			ldi		$t0,#'0'
FFFC09C6 21AE0023			stb		$t0,STRTMP[$t2]
FFFC09CA 001E0E13			add		$t2,$t2,#1
FFFC09CE 02E06D13			ldi		$t0,#'.'
FFFC09D2 21AE0023			stb		$t0,STRTMP[$t2]
FFFC09D6 001E0E13			add		$t2,$t2,#1
                        	.0010:
                        	;	// Now loop processing one digit at a time.
                        	;    for (nn = 0; nn < 30 && precision > 0; nn++) {
                        	;        digit = 0;
                        	;		dbla = dbl;
                        	;		// dbl is on the same order of magnitude as dbl2 so
                        	;		// a repeated subtract can be used to find the digit.
                        	;        while (dbl >= dbl2) {
                        	;            dbl -= dbl2;
                        	;            digit++;
                        	;        }
                        	;        buf[ndx] = digit + '0';
                        	;		// Now go back and perform just a single subtract and
                        	;		// a multiply to find out how much to reduce dbl by.
                        	;		// This should improve the accuracy
                        	;		if (digit > 2)
                        	;			dbl = dbla - dbl2 * digit;
                        	;        ndx++;
                        	;        digits_before_decpt--;
                        	;        if (digits_before_decpt==0) {
                        	;           buf[ndx] = '.';
                        	;           ndx++;
                        	;        }
                        	;        else if (digits_before_decpt < 0)
                        	;            precision--;
                        	;		// Shift the next digit to be tested into position.
                        	;        dbl *= 10.0;
                        	;    }
FFFC09DA 00006313			ldi		$s3,#0						; s3 = nn = 0
FFFC09DE 01E06413			ldi		$s5,#30
FFFC09E2 FFFC1637			flw		$f7,fltTen				; f7 = 10.0
FFFC09E6 C2060613
FFFC09EA 00060633
FFFC09EE 00062387
                        	.0016:
FFFC09F2 00832D33			slt		$t0,$s3,$s5
FFFC09F6 060D0863			beq		$t0,$x0,.0011
FFFC09FA 00006413			ldi		$s5,#0
FFFC09FE 07445463			bge		$s5,$a2,.0011			; (0 < precision)
FFFC0A02 00006393			ldi		$s4,#0						; s4 = digit = 0
FFFC0A06 38090153			fmov	$f2,$f18						; dbla = dbl
                        	.0013:
FFFC0A0A A1208D53			fle		$t0,$f1,$f18						; while (dbl2 <= dbl)
FFFC0A0E 000D0863			beq		$t0,$x0,.0012
FFFC0A12 08190953			fsub	$f18,$f18,$f1						; dbl -= dbl2
FFFC0A16 00138393			add		$s4,$s4,#1						; digit++
FFFC0A1A FE0008E3			bra		.0013
                        	.0012:
FFFC0A1E 03038413			add		$s5,$s4,#'0'			; buf[ndx] = digit + '0'
FFFC0A22 208E0023			stb		$s5,STRTMP[$t2]
FFFC0A26 00206413			ldi		$s5,#2						; if (2 < digit)
FFFC0A2A 00745863			bge		$s5,$s4,.0014
FFFC0A2E D00382D3			fcvt.s.w	$f5,$s4				; f5 = digit as float
FFFC0A32 10508353			fmul	$f6,$f1,$f5				; f6 = dbl2 * digit
FFFC0A36 08610953			fsub	$f18,$f2,$f6				; dbl = dbla - dbl2 * digit
                        	.0014:
FFFC0A3A 001E0E13			add		$t2,$t2,#1				; ndx++
FFFC0A3E FFF20213			sub		$s1,$s1,#1				; digits_before_decpt--;
FFFC0A42 00021A63			bne		$s1,$x0,.0015			; if (digits_before_decpt==0)
FFFC0A46 02E06D13			ldi		$t0,#'.'
FFFC0A4A 21AE0023			stb		$t0,STRTMP[$t2]		; buf[ndx] = '.'
FFFC0A4E 001E0E13			add		$t2,$t2,#1				; ndx++
FFFC0A52 00000663			bra		.0017
                        	.0015:
FFFC0A56 00025463			bge		$s1,$x0,.0017			; else if (digits_before_decpt < 0)
FFFC0A5A FFFA0A13			sub		$a2,$a2,#1				; 	precision--
                        	.0017:
FFFC0A5E 10790953			fmul	$f18,$f18,$f7				; dbl *= 10.0
FFFC0A62 F80008E3			bra		.0016
                        	.0011:
                        	;	// Trim trailing zeros from the number
                        	;    do {
                        	;        ndx--;
                        	;    } while(buf[ndx]=='0');
                        	;    ndx++;
                        	.0018:
FFFC0A66 FFFE0E13			sub		$t2,$t2,#1				; ndx--
FFFC0A6A 200E0D03			ldb		$t0,STRTMP[$t2]
FFFC0A6E 030D4D13			xor		$t0,$t0,#'0'
FFFC0A72 FE0D0AE3			beq		$t0,$x0,.0018
FFFC0A76 001E0E13			add		$t2,$t2,#1				; ndx++
                        	;	// Make sure we have at least one digit after the decimal point.
                        	;	if (buf[ndx]=='.') {
                        	;		ndx++;
                        	;		buf[ndx]='0';
                        	;		ndx++;
                        	;        buf[ndx]='\0';
                        	;	}
FFFC0A7A 200E0D03			ldb		$t0,STRTMP[$t2]
FFFC0A7E 02ED4D13			xor		$t0,$t0,#'.'
FFFC0A82 000D1C63			bne		$t0,$x0,.0019
FFFC0A86 001E0E13			add		$t2,$t2,#1
FFFC0A8A 03006D13			ldi		$t0,#'0'
FFFC0A8E 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0A92 001E0E13			add		$t2,$t2,#1
FFFC0A96 200E0023			stb		$x0,STRTMP[$t2]
                        	.0019:
                        	;	// If the number is times 10^0 don't output the exponent
                        	;   if (exp==0) {
                        	;        buf[ndx]='\0';
                        	;        goto prt;
                        	;    }
FFFC0A9A 00061663			bne		$s9,$x0,.0020
FFFC0A9E 200E0023			stb		$x0,STRTMP[$t2]
FFFC0AA2 0E000E63			bra		.prt
                        	.0020:
                        	;	// Spit out +/-E
                        	;    buf[ndx] = E;
                        	;    ndx++;
                        	;    if (exp < 0) {
                        	;        buf[ndx]='-';
                        	;        ndx++;
                        	;        exp = -exp;
                        	;    }
                        	;    else {
                        	;         buf[ndx]='+';
                        	;         ndx++;
                        	;    }
FFFC0AA6 04506D13			ldi		$t0,#'E'
FFFC0AAA 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0AAE 001E0E13			add		$t2,$t2,#1
FFFC0AB2 00065C63			bge		$s9,$x0,.0021
FFFC0AB6 02D06D13			ldi		$t0,#'-'
FFFC0ABA 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0ABE 001E0E13			add		$t2,$t2,#1
FFFC0AC2 40C00633			sub		$s9,$x0,$s9			; exp = -exp
FFFC0AC6 00000863			bra		.0022
                        	.0021:
FFFC0ACA 02B06D13			ldi		$t0,#'+'
FFFC0ACE 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0AD2 001E0E13			add		$t2,$t2,#1
                        	.0022:
                        	;	// now process the exponent
                        	;    digit = 0;
                        	;    while (exp >= 1000) {
                        	;        exp -= 1000;
                        	;        digit++;
                        	;    }
FFFC0AD6 00006393			ldi		$s4,#0
FFFC0ADA 3E806D13			ldi		$t0,#1000
                        	.0025:
FFFC0ADE 01A65463			bge		$s9,$t0,.0023
FFFC0AE2 00000863			bra		.0024
                        	.0023:
FFFC0AE6 41A60633			sub		$s9,$s9,$t0
FFFC0AEA 00138393			add		$s4,$s4,#1
FFFC0AEE FE0008E3			bra		.0025
                        	.0024:
                        	;	d1 = digit;
                        	;	if (digit) {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0AF2 0003E4B3			mov		$s6,$s4					; s6 = d1 = s4 = digit
FFFC0AF6 00039863			bne		$s4,$x0,.0026
FFFC0AFA 03038D13			add		$t0,$s4,#'0'
FFFC0AFE 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0B02 001E0E13			add		$t2,$t2,#1
                        	.0026:
                        	;	digit = 0;
                        	;    while (exp >= 100) {
                        	;        exp -= 100;
                        	;        digit++;
                        	;    }
FFFC0B06 00006393			ldi		$s4,#0
FFFC0B0A 06406D13			ldi		$t0,#100
                        	.0027:
FFFC0B0E 01A65463			bge		$s9,$t0,.0028
FFFC0B12 00000863			bra		.0029
                        	.0028:
FFFC0B16 41A60633			sub		$s9,$s9,$t0
FFFC0B1A 00138393			add		$s4,$s4,#1
FFFC0B1E FE0008E3			bra		.0027
                        	.0029:	
                        	;	d2 = digit;
                        	;	if (digit==0 && d1==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0B22 0003E533			mov		$s7,$s4				; $s7 = d2
FFFC0B26 00049463			bne		$s6,$x0,.0030
FFFC0B2A 00038863			beq		$s4,$x0,.0031
                        	.0030:
FFFC0B2E 03038D13			add		$t0,$s4,#'0'
FFFC0B32 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0B36 001E0E13			add		$t2,$t2,#1
                        	.0031:
                        	;	digit = 0;
                        	;    while (exp >= 10) {
                        	;        exp -= 10;
                        	;        digit++;
                        	;    }
FFFC0B3A 00006393			ldi		$s4,#0
FFFC0B3E 00A06D13			ldi		$t0,#10
                        	.0032:
FFFC0B42 01A65463			bge		$s9,$t0,.0034
FFFC0B46 00000863			bra		.0035
                        	.0034:
FFFC0B4A 41A60633			sub		$s9,$s9,$t0
FFFC0B4E 00138393			add		$s4,$s4,#1
FFFC0B52 FE0008E3			bra		.0032
                        	.0035:	
                        	;	d3 = digit;
                        	;	if (digit==0 && d1==0 && d2==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0B56 0003E5B3			mov		$s8,$s4
FFFC0B5A 00039663			bne		$s4,$x0,.0036
FFFC0B5E 00049463			bne		$s6,$x0,.0036
FFFC0B62 00050863			beq		$s7,$x0,.0037
                        	.0036:
FFFC0B66 03038D13			add		$t0,$s4,#'0'
FFFC0B6A 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0B6E 001E0E13			add		$t2,$t2,#1
                        	.0037:
                        	;	digit = 0;
                        	;    while (exp >= 1) {
                        	;        exp -= 1;
                        	;        digit++;
                        	;    }
FFFC0B72 00006393			ldi		$s4,#0
FFFC0B76 00106D13			ldi		$t0,#1
                        	.0038:
FFFC0B7A 01A65463			bge		$s9,$t0,.0040
FFFC0B7E 00000863			bra		.0039
                        	.0040:
FFFC0B82 41A60633			sub		$s9,$s9,$t0
FFFC0B86 00138393			add		$s4,$s4,#1
FFFC0B8A FE0008E3			bra		.0038
                        	.0039:	
                        	;    buf[ndx] = digit + '0';
                        	;    ndx++;
                        	;    buf[ndx] = '\0';
FFFC0B8E 03038D13			add		$t0,$s4,#'0'
FFFC0B92 21AE0023			sb		$t0,STRTMP[$t2]
FFFC0B96 001E0E13			add		$t2,$t2,#1
FFFC0B9A 200E0023			sb		$x0,STRTMP[$t2]
                        	;	// Now pad the number on the left or right as requested.
                        	.prt:
                        	;    // pad left
                        	;    if (width > 0) {
                        	;        if (ndx < width) {
                        	;            for (nn = 39; nn >= width-ndx; nn--)
                        	;                buf[nn] = buf[nn-(width-ndx)];
                        	;            for (; nn >= 0; nn--)
                        	;                buf[nn] = ' ';
                        	;        }
                        	;    }
FFFC0B9E 0409C663			blt		$a1,$x0,.0041
FFFC0BA2 04098463			beq		$a1,$x0,.0041
FFFC0BA6 013E4463			blt		$t2,$a1,.0042
FFFC0BAA 04000063			bra		.0041
                        	.0042:
FFFC0BAE 02706313			ldi		$s3,#39					; s3 = nn
FFFC0BB2 41C98D33			sub		$t0,$a1,$t2			; width-ndx
                        	.0045:
FFFC0BB6 01A35463			bge		$s3,$t0,.0043
FFFC0BBA 00000C63			bra		.0044
                        	.0043:
FFFC0BBE 41A304B3			sub		$s6,$s3,$t0			; nn-(width-ndx)
FFFC0BC2 20030D83			ldb		$t1,STRTMP[$s3]
FFFC0BC6 21B48023			stb		$t1,STRTMP[$s6]
FFFC0BCA FFF30313			sub		$s3,$s3,#1
FFFC0BCE FE0004E3			bra		.0045
                        	.0044:
FFFC0BD2 02006D13			ldi		$t0,#' '
                        	.0048:
FFFC0BD6 00035463			bge		$s3,$x0,.0046
FFFC0BDA 00000863			bra		.0047
                        	.0046:
FFFC0BDE 21A30023			stb		$t0,STRTMP[$s3]
FFFC0BE2 FFF30313			sub		$s3,$s3,#1
FFFC0BE6 FE0008E3			bra		.0048
                        	.0047:
                        	.0041:
                        	;    // pad right
                        	;    if (width < 0) {
                        	;        width = -width;
                        	;        while (ndx < width) {
                        	;            buf[ndx]=' ';
                        	;            ndx++;
                        	;        }
                        	;        buf[ndx]='\0';
                        	;    }
                        	;    return (ndx);
FFFC0BEA 0209D063			bge		$a1,$x0,.0050
FFFC0BEE 413009B3			sub		$a1,$x0,$a1
FFFC0BF2 02006D13			ldi		$t0,#' '
                        	.0052:
FFFC0BF6 013E5863			bge		$t2,$a1,.0051
FFFC0BFA 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0BFE 001E0E13			add		$t2,$t2,#1
FFFC0C02 FE000AE3			bra		.0052
                        	.0051:
FFFC0C06 200E0023			stb		$x0,STRTMP[$t2]
                        	.0050:
FFFC0C0A 000E6833			mov		$v0,$t2
FFFC0C0E 00008067			ret
                        	
FFFC0C12 6E490000			align	
                        	
                        	msgInf:
FFFC0C14 00666E49			db	"Inf",0
                        	msgNan:
FFFC0C18 006E614E			db	"Nan",0
                        	fltOne:
FFFC0C1C 3F800000			dw		$3F800000					; 1.0
                        	fltTen:
FFFC0C20 41200000			dw		$41200000					; 10.0
                        	fltMillion:
FFFC0C24 49742400			dw		$49742400					; 1,000,000
                        	
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "cs01Mem.asm",1
                        	.file "cs01Mem.asm",1
                        	NPAGES	equ		$4300
                        	PAM			equ		$4800
                        	
                        	.file "cs01Mem.asm",5
                        			code	18 bits
                        			align	4                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	MMUInit:
FFFC0C28 0F606D13			ldi		$t0,#246				; set number of available pages (10 pages already allocated)
FFFC0C2C 00004637			sw		$t0,NPAGES			
FFFC0C30 30060613
FFFC0C34 00060633
FFFC0C38 01A62023
                        			; Setup PAM
FFFC0C3C 1FF06D13			ldi		$t0,#$1FF				; permanently allocate pages for OS data
FFFC0C40 00005637			sw		$t0,PAM
FFFC0C44 80060613
FFFC0C48 00060633
FFFC0C4C 01A62023
FFFC0C50 00005637			sw		$x0,PAM+4
FFFC0C54 80460613
FFFC0C58 00060633
FFFC0C5C 00062023
FFFC0C60 00005637			sw		$x0,PAM+8
FFFC0C64 80860613
FFFC0C68 00060633
FFFC0C6C 00062023
FFFC0C70 00005637			sw		$x0,PAM+12
FFFC0C74 80C60613
FFFC0C78 00060633
FFFC0C7C 00062023
FFFC0C80 00005637			sw		$x0,PAM+16
FFFC0C84 81060613
FFFC0C88 00060633
FFFC0C8C 00062023
FFFC0C90 00005637			sw		$x0,PAM+20
FFFC0C94 81460613
FFFC0C98 00060633
FFFC0C9C 00062023
FFFC0CA0 00005637			sw		$x0,PAM+24
FFFC0CA4 81860613
FFFC0CA8 00060633
FFFC0CAC 00062023
FFFC0CB0 80000D37			ldi		$t0,#$80000000	; last page is system stack
FFFC0CB4 000D0D13
FFFC0CB8 00005637			sw		$t0,PAM+28
FFFC0CBC 81C60613
FFFC0CC0 00060633
FFFC0CC4 01A62023
FFFC0CC8 00006D13			ldi		$t0,#$00
FFFC0CCC 00006D93			ldi		$t1,#$000				; regno
FFFC0CD0 00001E37			ldi		$t2,#4096				; number of registers to update
FFFC0CD4 000E0E13
FFFC0CD8 00A06E93			ldi		$t3,#10					; number of pages pre-allocated
                        	.0001:
FFFC0CDC 03BD000D			mvmap	$x0,$t0,$t1
FFFC0CE0 001D0D13			add		$t0,$t0,#$01
FFFC0CE4 001D8D93			add		$t1,$t1,#$01		; increment page number
FFFC0CE8 01DDE463			bltu	$t1,$t3,.0003
FFFC0CEC 00006D33			mov		$t0,$x0					; mark pages after 9 unallocated
                        	.0003:
FFFC0CF0 FFFE0E13			sub		$t2,$t2,#1
FFFC0CF4 FE0E14E3			bne		$t2,$x0,.0001
FFFC0CF8 0FF06D93			ldi		$t1,#$0FF				; allocate last page for stack
FFFC0CFC 0FF06D13			ldi		$t0,#$FF
FFFC0D00 03BD000D			mvmap	$x0,$t0,$t1
                        			; Now setup segment registers
FFFC0D04 00006D13			ldi		$t0,#$0
FFFC0D08 00706D93			ldi		$t1,#$07				; t1 = value to load RWX=111, base = 0
                        	.0002:
FFFC0D0C 01AD800D			mvseg	$x0,$t1,$t0			; move to the segment register identifed by t0
FFFC0D10 001D0D13			add		$t0,$t0,#1			; pick next segment register
FFFC0D14 010D2E13			slt		$t2,$t0,#16			; 16 segment regs
FFFC0D18 FE0E1AE3			bne		$t2,$x0,.0002
FFFC0D1C 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Allocate a single page of memory. Available memory is indicated by a bitmmap
                        	; called the PAM for page allocation map.
                        	; There's only eight words to check so an unrolled loop works here.
                        	;
                        	; Modifies:
                        	;		t0,t1,t2
                        	; Returns:
                        	;		v0 = page allocated
                        	;------------------------------------------------------------------------------
                        	;
                        	AllocPage:
FFFC0D20 FFC70713		sub		$sp,$sp,#4
FFFC0D24 00172023		sw		$ra,[$sp]
FFFC0D28 00005637		lw		$t0,PAM
FFFC0D2C 80060613
FFFC0D30 00060633
FFFC0D34 00062D03
FFFC0D38 00000DB7		ldi		$t1,#$FFFFFFFF
FFFC0D3C FFFD8D93
FFFC0D40 01BD0E63		beq		$t0,$t1,.chkPam4
FFFC0D44 178000EF		call	BitIndex
FFFC0D48 00005637		sw		$t0,PAM
FFFC0D4C 80060613
FFFC0D50 00060633
FFFC0D54 01A62023
FFFC0D58 14000C63		bra		.0001
                        	.chkPam4:
FFFC0D5C 00005637		lw		$t0,PAM+4
FFFC0D60 80460613
FFFC0D64 00060633
FFFC0D68 00062D03
FFFC0D6C 03BD0063		beq		$t0,$t1,.chkPam8
FFFC0D70 14C000EF		call	BitIndex
FFFC0D74 00005637		sw		$t0,PAM+4
FFFC0D78 80460613
FFFC0D7C 00060633
FFFC0D80 01A62023
FFFC0D84 02080813		add		$v0,$v0,#32
FFFC0D88 12000463		bra		.0001
                        	.chkPam8:
FFFC0D8C 00005637		lw		$t0,PAM+8
FFFC0D90 80860613
FFFC0D94 00060633
FFFC0D98 00062D03
FFFC0D9C 03BD0063		beq		$t0,$t1,.chkPam12
FFFC0DA0 11C000EF		call	BitIndex
FFFC0DA4 00005637		sw		$t0,PAM+8
FFFC0DA8 80860613
FFFC0DAC 00060633
FFFC0DB0 01A62023
FFFC0DB4 04080813		add		$v0,$v0,#64
FFFC0DB8 0E000C63		bra		.0001
                        	.chkPam12:
FFFC0DBC 00005637		lw		$t0,PAM+12
FFFC0DC0 80C60613
FFFC0DC4 00060633
FFFC0DC8 00062D03
FFFC0DCC 03BD0063		beq		$t0,$t1,.chkPam16
FFFC0DD0 0EC000EF		call	BitIndex
FFFC0DD4 00005637		sw		$t0,PAM+12
FFFC0DD8 80C60613
FFFC0DDC 00060633
FFFC0DE0 01A62023
FFFC0DE4 06080813		add		$v0,$v0,#96
FFFC0DE8 0C000463		bra		.0001
                        	.chkPam16:
FFFC0DEC 00005637		lw		$t0,PAM+16
FFFC0DF0 81060613
FFFC0DF4 00060633
FFFC0DF8 00062D03
FFFC0DFC 03BD0063		beq		$t0,$t1,.chkPam20
FFFC0E00 0BC000EF		call	BitIndex
FFFC0E04 00005637		sw		$t0,PAM+16
FFFC0E08 81060613
FFFC0E0C 00060633
FFFC0E10 01A62023
FFFC0E14 08080813		add		$v0,$v0,#128
FFFC0E18 08000C63		bra		.0001
                        	.chkPam20:
FFFC0E1C 00005637		lw		$t0,PAM+20
FFFC0E20 81460613
FFFC0E24 00060633
FFFC0E28 00062D03
FFFC0E2C 03BD0063		beq		$t0,$t1,.chkPam24
FFFC0E30 08C000EF		call	BitIndex
FFFC0E34 00005637		sw		$t0,PAM+20
FFFC0E38 81460613
FFFC0E3C 00060633
FFFC0E40 01A62023
FFFC0E44 0A080813		add		$v0,$v0,#160
FFFC0E48 06000463		bra		.0001
                        	.chkPam24:
FFFC0E4C 00005637		lw		$t0,PAM+24
FFFC0E50 81860613
FFFC0E54 00060633
FFFC0E58 00062D03
FFFC0E5C 03BD0063		beq		$t0,$t1,.chkPam28
FFFC0E60 05C000EF		call	BitIndex
FFFC0E64 00005637		sw		$t0,PAM+24
FFFC0E68 81860613
FFFC0E6C 00060633
FFFC0E70 01A62023
FFFC0E74 0C080813		add		$v0,$v0,#192
FFFC0E78 02000C63		bra		.0001
                        	.chkPam28:
FFFC0E7C 00005637		lw		$t0,PAM+28
FFFC0E80 81C60613
FFFC0E84 00060633
FFFC0E88 00062D03
FFFC0E8C 03BD0063		beq		$t0,$t1,.chkPamDone
FFFC0E90 02C000EF		call	BitIndex
FFFC0E94 00005637		sw		$t0,PAM+28
FFFC0E98 81C60613
FFFC0E9C 00060633
FFFC0EA0 01A62023
FFFC0EA4 0E080813		add		$v0,$v0,#224
FFFC0EA8 00000463		bra		.0001
                        	.chkPamDone:
FFFC0EAC 00006813		ldi		$v0,#0						; no memory available
                        	.0001:
FFFC0EB0 00072083		lw		$ra,[$sp]
FFFC0EB4 00470713		add		$sp,$sp,#4
FFFC0EB8 00008067		ret
                        	
                        	; Returns:
                        	;		v0 = bit index of allocated page
                        	;
                        	BitIndex:
FFFC0EBC 00006813		ldi		$v0,#0
                        	.0001:
FFFC0EC0 001D7E13		and		$t2,$t0,#1
FFFC0EC4 000E0E63		beq		$t2,$x0,.foundFree
FFFC0EC8 001D5D13		srl		$t0,$t0,#1
FFFC0ECC 80000637		or		$t0,$t0,#$80000000	; do a rotate, we know bit = 1
FFFC0ED0 00060613
FFFC0ED4 01A66D33
FFFC0ED8 00180813		add		$v0,$v0,#1
FFFC0EDC FE0002E3		bra		.0001
                        	.foundFree:
FFFC0EE0 001D6D13		or		$t0,$t0,#1					; mark page allocated
FFFC0EE4 00086DB3		mov		$t1,$v0
FFFC0EE8 000D8A63		beq		$t1,$x0,.0003
                        	.0004:
FFFC0EEC 001D1D13		sll		$t0,$t0,#1					; do a rotate
FFFC0EF0 001D6D13		or		$t0,$t0,#1					; we know bit = 1
FFFC0EF4 FFFD8D93		sub		$t1,$t1,#1
FFFC0EF8 FE0D9AE3		bne		$t1,$x0,.0004
                        	.0003:
FFFC0EFC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = page number to free
                        	; Modifies:
                        	;		v0,v1,t0
                        	;------------------------------------------------------------------------------
                        	
                        	FreePage:
FFFC0F00 0FF06813		ldi		$v0,#255						; last page is permanently allocated to system stack
FFFC0F04 05097263		bgeu	$a0,$v0,.xit
FFFC0F08 00906813		ldi		$v0,#9
FFFC0F0C 03096E63		bltu	$a0,$v0,.xit				; first 9 pages (18kB) allocated permanently to system
FFFC0F10 00595813		srl		$v0,$a0,#5					; v0 = word
FFFC0F14 01F97893		and		$v1,$a0,#31					; v1 = bit no
FFFC0F18 00106D13		ldi		$t0,#1							; make a bitmask
FFFC0F1C 011D1D13		sll		$t0,$t0,$v1
FFFC0F20 FFFD4D13		xor		$t0,$t0,#-1					; invert mask
FFFC0F24 00005637		lw		$v1,PAM[$v0]
FFFC0F28 80060613
FFFC0F2C 01060633
FFFC0F30 00062883
FFFC0F34 01A8F8B3		and		$v1,$v1,$t0					; clear bit
FFFC0F38 00005637		sw		$v1,PAM[$v0]				; save PAM word back
FFFC0F3C 80060613
FFFC0F40 01060633
FFFC0F44 01162023
                        	.xit:
FFFC0F48 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Find a run of buckets available for mapping virtual to physical addresses.
                        	;
                        	; Parameters:
                        	;		a0 = pid
                        	;		a1 = number of pages required.
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		v0 = starting bucket number (includes ASID), -1 if no run found
                        	;------------------------------------------------------------------------------
                        	
                        	FindRun:
FFFC0F4C 00F97E93		and			$t3,$a0,#$0F			; t3 = pid
FFFC0F50 008E9E93		sll			$t3,$t3,#8				; shift into usable position
FFFC0F54 00006D93		ldi			$t1,#0						; t1 = count of consecutive empty buckets
FFFC0F58 000EEE33		mov			$t2,$t3						; t2 = map entry number
FFFC0F5C 020E6E13		or			$t2,$t2,#OSPAGES	; start looking at page 32 (others are for OS)
FFFC0F60 0FF06F93		ldi			$t5,#255					; max number of pages - 1
FFFC0F64 01DFEFB3		or			$t5,$t5,$t3				; t5 = max in ASID
                        	.0001:
FFFC0F68 03C0080D		mvmap		$v0,$x0,$t2				; get map entry into v0
FFFC0F6C 00080A63		beq			$v0,$x0,.empty0		; is it empty?
FFFC0F70 001E0E13		add			$t2,$t2,#1
FFFC0F74 FFFE6AE3		bltu		$t2,$t5,.0001
FFFC0F78 FFF06813		ldi			$v0,#-1						; got here so no run was found
FFFC0F7C 00008067		ret
                        	.empty0:
FFFC0F80 000E6EB3		mov			$t3,$t2						; save first empty bucket
                        	.empty1:
FFFC0F84 001D8D93		add			$t1,$t1,#1
FFFC0F88 013DFC63		bgeu		$t1,$a1,.foundEnough
FFFC0F8C 001E0E13		add			$t2,$t2,#1				; next bucket
FFFC0F90 03C0080D		mvmap		$v0,$x0,$t2				; get map entry
FFFC0F94 FE0808E3		beq			$v0,$x0,.empty1
FFFC0F98 00006DB3		mov			$t1,$x0						; reset counter
FFFC0F9C FC0006E3		bra			.0001							; go back and find another run
                        	.foundEnough:
FFFC0FA0 000EE833		mov			$v0,$t3						; v0 = start of run
FFFC0FA4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = pid
                        	;		a1 = amount of memory to allocate
                        	; Modifies:
                        	;		t0
                        	; Returns:
                        	;		v1 = pointer to allocated memory in virtual address space.
                        	;		v0 = E_Ok for success, E_NotAlloc otherwise
                        	;------------------------------------------------------------------------------
                        	;
                        	Alloc:
FFFC0FA8 FF070713		sub			$sp,$sp,#16
FFFC0FAC 00172023		sw			$ra,[$sp]
FFFC0FB0 00472223		sw			$s1,4[$sp]				; these regs must be saved
FFFC0FB4 00572423		sw			$s2,8[$sp]
FFFC0FB8 00672623		sw			$s3,12[$sp]
                        		; First check if there are enough pages available in the system.
FFFC0FBC 7FF98813		add			$v0,$a1,#2047			; v0 = round memory request
FFFC0FC0 00B85813		srl			$v0,$v0,#11				; v0 = convert to pages required
FFFC0FC4 00004637		lw			$t0,NPAGES				; check number of pages available
FFFC0FC8 30060613
FFFC0FCC 00060633
FFFC0FD0 00062D03
FFFC0FD4 010D7663		bleu		$v0,$t0,.enough
                        	.noRun2:
FFFC0FD8 00006893		ldi			$v1,#0						; not enough, return null
FFFC0FDC 06000663		bra			.noRun
                        	.enough:
FFFC0FE0 00096233		mov			$s1,$a0
FFFC0FE4 00026933		mov			$a0,$s1
                        		; There are enough pages, but is there a run long enough in map space?
FFFC0FE8 000862B3		mov			$s2,$v0				; save required # pages
FFFC0FEC 000869B3		mov			$a1,$v0
FFFC0FF0 F5DFF0EF		call		FindRun						; find a run of available slots
FFFC0FF4 FE0842E3		blt			$v0,$x0,.noRun2
                        		; Now there are enough pages, and a run available, so allocate
FFFC0FF8 00086233		mov			$s1,$v0						; s1 = start of run
FFFC0FFC 00004637		lw			$s3,NPAGES				; decrease number of pages available in system
FFFC1000 30060613
FFFC1004 00060633
FFFC1008 00062303
FFFC100C 40530333		sub			$s3,$s3,$s2
FFFC1010 00004637		sw			$s3,NPAGES
FFFC1014 30060613
FFFC1018 00060633
FFFC101C 00662023
FFFC1020 00086333		mov			$s3,$v0						; s3 = start of run
                        	.0001:
FFFC1024 0000180D		palloc	$v0								; allocate a page (cheat and use hardware)
                        		;call		AllocPage
FFFC1028 02080063		beq			$v0,$x0,.noRun
FFFC102C 0268000D		mvmap		$x0,$v0,$s3				; map the page
FFFC1030 00130313		add			$s3,$s3,#1				; next bucket
FFFC1034 FFF28293		sub			$s2,$s2,#1
FFFC1038 FE0296E3		bne			$s2,$x0,.0001
FFFC103C 00B21893		sll			$v1,$s1,#11				; v0 = virtual address of allocated mem.
FFFC1040 00006813		ldi			$v0,#E_Ok
FFFC1044 00000463		bra			.xit
                        	.noRun:
FFFC1048 00906813		ldi			$v0,#E_NotAlloc
                        	.xit
FFFC104C 00072083		lw			$ra,[$sp]					; restore saved regs
FFFC1050 00472203		lw			s1,4[$sp]
FFFC1054 00872283		lw			s2,8[$sp]
FFFC1058 00C72303		lw			s3,12[$sp]
FFFC105C 01070713		add			$sp,$sp,#16
FFFC1060 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Allocate the stack page for a task. The stack is located at the highest
                        	; virtual address ($7F800).
                        	;
                        	; Parameters:
                        	;		a0 = pid to allocate for
                        	;	Returns:
                        	;		v0 = physical address, 0 if unsuccessful
                        	;		v1 = virtual address, not valid unless successful
                        	;------------------------------------------------------------------------------
                        	;
                        	AllocStack:
                        		; need save ra here if calling AllocPage
FFFC1064 00891893		sll			$v1,$a0,#8			; 
FFFC1068 0FF8E893		or			$v1,$v1,#255		; last page of memory is for stack
FFFC106C 0310080D		mvmap		$v0,$x0,$v1			; check if stack already allocated
FFFC1070 00081863		bne			$v0,$x0,.0001
FFFC1074 0000180D		palloc	$v0							; allocate a page
                        		;call		AllocPage
FFFC1078 00080A63		beq			$v0,$x0,.xit		; success?
FFFC107C 0318000D		mvmap		$x0,$v0,$v1
                        	.0001:
FFFC1080 0FF8F893		and			$v1,$v1,#255
FFFC1084 00B81813		sll			$v0,$v0,#11			; convert pages to addresses
FFFC1088 00B89893		sll			$v1,$v1,#11
                        	.xit:
FFFC108C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; This routine will de-allocate all the pages associated with a task including
                        	; the stack.
                        	;
                        	; Parameters:
                        	;		a0 = pid to free memory for
                        	;	Modifies:
                        	;		a0,t0,t1,t3,t4
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	FreeAll:
                        		; need save ra if calling FreePage
FFFC1090 00006E93		ldi			$t3,#0
FFFC1094 00891F13		sll			$t4,$a0,#8
                        	.nxt:
FFFC1098 100EAD93		slt			$t1,$t3,#256		; number of buckets to check
FFFC109C 040D8A63		beq			$t1,$x0,.0001
FFFC10A0 00001637		and			$t4,$t4,#$F00
FFFC10A4 F0060613
FFFC10A8 01E67F33
FFFC10AC 01DF6F33		or			$t4,$t4,$t3			; combine pid and bucket number
FFFC10B0 00006D13		ldi			$t0,#0					; new page number to set (indicates free)
FFFC10B4 03ED0D0D		mvmap		$t0,$t0,$t4			; get page mapping and set to zero
FFFC10B8 001E8E93		add			$t3,$t3,#1			; advance to next bucket
FFFC10BC 0FFD7D13		and			$t0,$t0,#255		; pages are 1-255
FFFC10C0 FC0D0CE3		beq			$t0,$x0,.nxt		; 0 = no map in this bucket
FFFC10C4 020D100D		pfree		$t0							; free the page
                        		;mov			$a0,$t0
                        		;call		FreePage
FFFC10C8 00004637		lw			$t0,NPAGES			; update the number of available pages
FFFC10CC 30060613
FFFC10D0 00060633
FFFC10D4 00062D03
FFFC10D8 001D0D13		add			$t0,$t0,#1
FFFC10DC 00004637		sw			$t0,NPAGES
FFFC10E0 30060613
FFFC10E4 00060633
FFFC10E8 01A62023
FFFC10EC FA0006E3		bra			.nxt
                        	.0001:
FFFC10F0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Convert a virtual address to a physical one
                        	;
                        	; Parameters:
                        	;		a0 = virtual address to convert
                        	; Modifies:
                        	;		t0
                        	; Returns:
                        	;		v0 = physcial address
                        	;------------------------------------------------------------------------------
                        	
                        	VirtToPhys:
FFFC10F4 02094C63		blt		$a0,$x0,.notMapped
FFFC10F8 FFC70713		sub		$sp,$sp,#4
FFFC10FC 00172023		sw		$ra,[$sp]
FFFC1100 00B95D13		srl		$t0,$a0,#11					; convert virt to page
FFFC1104 64C000EF		call	GetCurrentTid
FFFC1108 00881813		sll		$v0,$v0,#8
FFFC110C 01A86833		or		$v0,$v0,$t0					; and in tid
FFFC1110 0300080D		mvmap	$v0,$x0,$v0					; get the translation
FFFC1114 00B81813		sll		$v0,$v0,#11					; convert page to address
FFFC1118 7FF97D13		and		$t0,$a0,#$7FF				; insert LSB's
FFFC111C 01A86833		or		$v0,$v0,$t0
FFFC1120 00072083		lw		$ra,[$sp]
FFFC1124 00470713		add		$sp,$sp,#4
FFFC1128 00008067		ret
                        	.notMapped:
FFFC112C 00096833		mov		$v0,$a0
FFFC1130 00008067		ret
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "../fmtk/serial.asm",1
                        	.file "../fmtk/serial.asm",1
                        	SerRcvBuf		EQU		$9000
                        	SerXmitBuf	EQU		$9400
                        	SerHeadRcv	EQU		$9800
                        	SerTailRcv	EQU		$9804
                        	SerHeadXmit	EQU		$9808
                        	SerTailXmit	EQU		$980C
                        	SerRcvXon		EQU		$9810
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
FFFC1134 00000000		align	
                        	
                        	SerialFuncTbl:
FFFC1138 00000000		dw		0							; no operation
FFFC113C 00000000		dw		0							; setup
FFFC1140 00000000		dw		0							; initialize
FFFC1144 00000000		dw		0							; status
FFFC1148 00000000		dw		0							; media check
FFFC114C 00000000		dw		0							; build BPB
FFFC1150 00000000		dw		0							; open
FFFC1154 00000000		dw		0							; close
FFFC1158 00000000		dw		0							; get char
FFFC115C FFFC12B4		dw		SerialPeekChar
FFFC1160 00000000		dw		0							; get char direct
FFFC1164 FFFC1320		dw		SerialPeekCharDirect	; peek char direct
FFFC1168 00000000		dw		0							; input status
FFFC116C FFFC136C		dw		SerialPutChar
FFFC1170 00000000		dw		0							; reserved
FFFC1174 00000000		dw		0							; set position
FFFC1178 00000000		dw		0							; read block
FFFC117C 00000000		dw		0							; write block
FFFC1180 00000000		dw		0							; verify block
FFFC1184 00000000		dw		0							; output status
FFFC1188 00000000		dw		0							; flush input
FFFC118C 00000000		dw		0							; flush output
FFFC1190 FFFC1428		dw		SerialIRQ			; IRQ routine
FFFC1194 00000000		dw		0							; Is removable
FFFC1198 00000000		dw		0							; ioctrl read
FFFC119C 00000000		dw		0							; ioctrl write
FFFC11A0 00000000		dw		0							; output until busy
FFFC11A4 00000000		dw		0							; 27
FFFC11A8 00000000		dw		0
FFFC11AC 00000000		dw		0
FFFC11B0 00000000		dw		0
FFFC11B4 00000000		dw		0							; 31
                        	
                        	MAX_DEV_OP			EQU		31
                        	
                        	;------------------------------------------------------------------------------
                        	; Initialize serial port.
                        	;
                        	; Modifies:
                        	;		$t0
                        	;------------------------------------------------------------------------------
                        	
                        	SerialInit:
FFFC11B8 FFC70713		sub		$sp,$sp,#4
FFFC11BC 00172023		sw		$ra,[$sp]
FFFC11C0 00506913		ldi		$a0,#5							; serial device
FFFC11C4 FFFC19B7		ldi		$a1,#SerialFuncTbl
FFFC11C8 13898993
FFFC11CC 510010EF		call	CopyDevFuncTbl
FFFC11D0 00B06D13		ldi		$t0,#$0B						; dtr,rts active, rxint disabled, no parity
FFFC11D4 FFDC1637		sw		$t0,UART+8
FFFC11D8 A0860613
FFFC11DC 00060633
FFFC11E0 01A62023
FFFC11E4 00060D37		ldi		$t0,#$0006001E			; reset the fifo's
FFFC11E8 01ED0D13
FFFC11EC FFDC1637		sw		$t0,UART+12
FFFC11F0 A0C60613
FFFC11F4 00060633
FFFC11F8 01A62023
FFFC11FC 01E06D13		ldi		$t0,#$0000001E			; baud 9600, 1 stop bit, 8 bit, internal baud gen
FFFC1200 FFDC1637		sw		$t0,UART+12
FFFC1204 A0C60613
FFFC1208 00060633
FFFC120C 01A62023
FFFC1210 00072083		lw		$ra,[$sp]
FFFC1214 00470713		add		$sp,$sp,#4
FFFC1218 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	SerialServiceInit:
FFFC121C 00106913		ldi		$a0,#1			; start task
FFFC1220 40006993		ldi		$a1,#1024		; memory required
FFFC1224 FFFC1A37		ldi		$a2,#SerialService
FFFC1228 234A0A13
FFFC122C 00000073		ecall
FFFC1230 00008067		ret
                        	SerialService:
FFFC1234 DE870713		sub		$sp,$sp,#512+24
FFFC1238 00E06913		ldi		$a0,#14			; get current tid
FFFC123C 00000073		ecall
FFFC1240 20470A13		add		$a2,$sp,#516
FFFC1244 000869B3		mov		$a1,$v0
FFFC1248 00606913		ldi		$a0,#6			; alloc mailbox
FFFC124C 00000073		ecall
                        	
                        	SerialServiceLoop:
FFFC1250 00A06913		ldi		$a0,#10			; waitmsg
FFFC1254 20470993		add		$a1,$sp,#516
FFFC1258 20870A13		add		$a2,$sp,#520
FFFC125C 20C70A93		add		$a3,$sp,#524
FFFC1260 21070B13		add		$a4,$sp,#528
FFFC1264 FFF06B93		ldi		$a5,#-1
FFFC1268 00000073		ecall
                        	
FFFC126C 00072D03		lw		$t0,[$sp]
FFFC1270 01FD7D13		and		$t0,$t0,#31
FFFC1274 001D1D13		sll		$t0,$t0,#1
FFFC1278 FFFC1637		lw		$t0,SerialFuncTbl[$t0]
FFFC127C 13860613
FFFC1280 01A60633
FFFC1284 00062D03
FFFC1288 000D0067		jmp		[$t0]
                        	
                        	SerialFinishCmd:
FFFC128C 00C72983		lw		$a1,12[$sp]		; reply mbx
FFFC1290 00198993		add		$a1,$a1,#1		; -1 = no reply requested
FFFC1294 01298E63		beq		$a1,$a0,.0001
FFFC1298 FFF98993		sub		$a1,$a1,#1
FFFC129C 00906913		ldi		$a0,#9				; sendmsg
FFFC12A0 FFF06A13		ldi		$a2,#-1
FFFC12A4 FFF06A93		ldi		$a3,#-1
FFFC12A8 FFF06B13		ldi		$a4,#-1
FFFC12AC 00000073		ecall
                        	.0001:
FFFC12B0 FA1FF06F		jmp		SerialServiceLoop
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPeekChar
                        	;
                        	; Check the serial port buffer to see if there's a char available. If there's
                        	; a char available then return it.
                        	;
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$v0 = character or -1
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPeekChar:
FFFC12B4 FF870713			sub		$sp,$sp,#8
FFFC12B8 00172023			sw		$ra,[$sp]
FFFC12BC 01172223			sw		$v1,4[$sp]
                        	;		call	SerialRcvCount
                        	;		slt		$v0,$v0,#8
                        	;		beq		$v0,$x0,.0002
                        	;		ldi		$v0,#XON
                        	;		sb		$v0,UART+UART_TRB
                        	.0002:
FFFC12C0 0000A637			lbu		$v1,SerHeadRcv			; check if anything is in buffer
FFFC12C4 80060613
FFFC12C8 00060633
FFFC12CC 00064883
FFFC12D0 0000A637			lbu		$v0,SerTailRcv
FFFC12D4 80460613
FFFC12D8 00060633
FFFC12DC 00064803
FFFC12E0 03180663			beq		$v0,$v1,.noChars		; no?
FFFC12E4 00009637			lb		$v0,SerRcvBuf[$v1]	; get byte from buffer
FFFC12E8 00060613
FFFC12EC 01160633
FFFC12F0 00060803
FFFC12F4 00188893			add		$v1,$v1,#1					; update head index
FFFC12F8 0000A637			sb		$v1,SerHeadRcv				
FFFC12FC 80060613
FFFC1300 00060633
FFFC1304 01160023
FFFC1308 00000463			bra		.xit
                        	.noChars:
                        	.0001:
FFFC130C FFF06813			ldi		$v0,#-1
                        	.xit
FFFC1310 00072083			lw		$ra,[$sp]
FFFC1314 00472883			lw		$v1,4[$sp]
FFFC1318 00870713			add		$sp,$sp,#8
FFFC131C 00008067			ret
                        	
                        	SerialPeekCharDirect:
FFFC1320 FF870713			sub		$sp,$sp,#8
FFFC1324 00172023			sw		$ra,[$sp]
FFFC1328 01172223			sw		$v1,4[$sp]
FFFC132C FFDC1637			lb		$v0,UART+UART_STAT
FFFC1330 A0460613
FFFC1334 00060633
FFFC1338 00060803
FFFC133C 00887813			and		$v0,$v0,#8					; look for Rx not empty
FFFC1340 00080C63			beq		$v0,$x0,.0001
FFFC1344 FFDC1637			lb		$v0,UART+UART_TRB
FFFC1348 A0060613
FFFC134C 00060633
FFFC1350 00060803
FFFC1354 00000463			bra		.xit
                        	.0001:
FFFC1358 FFF06813			ldi		$v0,#-1
                        	.xit
FFFC135C 00072083			lw		$ra,[$sp]
FFFC1360 00472883			lw		$v1,4[$sp]
FFFC1364 00870713			add		$sp,$sp,#8
FFFC1368 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPutChar
                        	;    Put a character to the serial transmitter. This routine blocks until the
                        	; transmitter is empty. The routine will attempt to transmit the char up to 
                        	; 10 times. If it still can't transmit the char then sleep is called and the
                        	; task is put to sleep for a tick. When it wakes up the routine continues to
                        	; try and send a character.
                        	;
                        	; Stack Space
                        	;		5 words
                        	; Parameters:
                        	;		$a3 = character to put
                        	; Modifies:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPutChar:
FFFC136C FF470713		sub		$sp,$sp,#12
FFFC1370 01072023		sw		$v0,[$sp]
FFFC1374 00172223		sw		$ra,4[$sp]
FFFC1378 01172423		sw		$v1,8[$sp]
                        	.0002:
FFFC137C FFF06893		ldi		$v1,#-1
                        	.0001:
FFFC1380 FFF88893		sub		$v1,$v1,#1
FFFC1384 04088063		beq		$v1,$x0,.goSleep
FFFC1388 FFDC1637		lb		$v0,UART+UART_STAT	; wait until the uart indicates tx empty
FFFC138C A0460613
FFFC1390 00060633
FFFC1394 00060803
FFFC1398 01087813		and		$v0,$v0,#16					; bit #4 of the status reg
FFFC139C FE0802E3		beq		$v0,$x0,.0001				; branch if transmitter is not empty
FFFC13A0 FFDC1637		sb		$a3,UART+UART_TRB		; send the byte
FFFC13A4 A0060613
FFFC13A8 00060633
FFFC13AC 01560023
FFFC13B0 00072803		lw		$v0,[$sp]
FFFC13B4 00472083		lw		$ra,4[$sp]
FFFC13B8 00872883		lw		$v1,8[$sp]
FFFC13BC 00C70713		add		$sp,$sp,#12
FFFC13C0 00008067		ret
                        	.goSleep:
FFFC13C4 FF870713		sub		$sp,$sp,#8
FFFC13C8 01272023		sw		a0,[$sp]
FFFC13CC 01372223		sw		a1,4[$sp]
FFFC13D0 00506913		ldi		a0,#5								; sleep function
FFFC13D4 00106993		ldi		a1,#1								; 1 tick
FFFC13D8 00000073		ecall
FFFC13DC 00072903		lw		a0,[$sp]
FFFC13E0 00472983		lw		a1,4[$sp]
FFFC13E4 00870713		add		$sp,$sp,#8
FFFC13E8 F8000AE3		bra		.0002
                        	
                        	;------------------------------------------------------------------------------
                        	; Calculate number of character in input buffer
                        	;------------------------------------------------------------------------------
                        	
                        	SerialRcvCount:
FFFC13EC 0000A637		lbu		$v0,SerTailRcv	; v0 = tail index
FFFC13F0 80460613
FFFC13F4 00060633
FFFC13F8 00064803
FFFC13FC 0000A637		lbu		$v1,SerHeadRcv	; v1 = head index
FFFC1400 80060613
FFFC1404 00060633
FFFC1408 00064883
FFFC140C 41180D33		sub		$t0,$v0,$v1
FFFC1410 000D5863		bge		$t0,$x0,.xit
FFFC1414 10006D13		ldi		$t0,#256
FFFC1418 411D0D33		sub		$t0,$t0,$v1
FFFC141C 010D0D33		add		$t0,$t0,$v0
                        	.xit:
FFFC1420 000D6833		mov		$v0,$t0
FFFC1424 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	SerialIRQ:
                        	.nxtByte:
FFFC1428 00897D13		and		$t0,$a0,#$08				; bit 3 = rx full
FFFC142C 080D0663		beq		$t0,$x0,.notRxInt
FFFC1430 FFDC1637		lw		$a1,UART+UART_TRB		; get data from Rx buffer to clear interrupt
FFFC1434 A0060613
FFFC1438 00060633
FFFC143C 00062983
FFFC1440 0000A637		lbu		$t2,SerHeadRcv			; get buffer indexes
FFFC1444 80060613
FFFC1448 00060633
FFFC144C 00064E03
FFFC1450 0000A637		lbu		$t3,SerTailRcv
FFFC1454 80460613
FFFC1458 00060633
FFFC145C 00064E83
FFFC1460 001E8E93		add		$t3,$t3,#1					; see if buffer full
FFFC1464 0FFEFE93		and		$t3,$t3,#255
FFFC1468 05DE0863		beq		$t2,$t3,.rxFull
FFFC146C 0000A637		sb		$t2,SerTailRcv			; update tail pointer
FFFC1470 80460613
FFFC1474 00060633
FFFC1478 01C60023
FFFC147C FFFE0E13		sub		$t2,$t2,#1
FFFC1480 0FFEFE13		and		$t2,$t3,#255
FFFC1484 00009637		sb		$a1,SerRcvBuf[$t2]	; store recieved byte in buffer
FFFC1488 00060613
FFFC148C 01C60633
FFFC1490 01360023
FFFC1494 F59FF0EF		call	SerialRcvCount
FFFC1498 0F082813		slt		$v0,$v0,#240
FFFC149C 00081463		bne		$v0,$x0,.0001
FFFC14A0 01306913		ldi		$a0,#XOFF
                        		sb		UART+UART_TRB
                        	.0001:
FFFC14A4 FFDC1637		lw		$a0,UART+UART_STAT	; check the status for another byte
FFFC14A8 A0460613
FFFC14AC 00060633
FFFC14B0 00062903
FFFC14B4 F6000AE3		bra		.nxtByte
                        	;	ldi		$a0,#$0B						; dtr,rts active, rxint disabled, no parity
                        	;	sw		$a0,UART+UART_CMD
                        	.rxFull:
                        	.notRxInt:
FFFC14B8 10000073		eret
                        	
                        	nmeSerial:
FFFC14BC 69726553		db		"Serial",0
FFFC14C0 00006C61
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "../fmtk/via.asm",1
                        	.file "../fmtk/via.asm",1
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
FFFC14C3 00000000		align	
FFFC14C7 00000000
                        	
                        	ViaFuncTbl:
FFFC14C8 00000000		dw		0							; no operation
FFFC14CC 00000000		dw		0							; setup
FFFC14D0 00000000		dw		0							; initialize
FFFC14D4 00000000		dw		0							; status
FFFC14D8 00000000		dw		0							; media check
FFFC14DC 00000000		dw		0							; build BPB
FFFC14E0 00000000		dw		0							; open
FFFC14E4 00000000		dw		0							; close
FFFC14E8 00000000		dw		0							; get char
FFFC14EC 00000000		dw		0							; Peek char
FFFC14F0 00000000		dw		0							; get char direct
FFFC14F4 00000000		dw		0							; peek char direct
FFFC14F8 00000000		dw		0							; input status
FFFC14FC 00000000		dw		0							; Put char
FFFC1500 00000000		dw		0							; reserved
FFFC1504 00000000		dw		0							; set position
FFFC1508 00000000		dw		0							; read block
FFFC150C 00000000		dw		0							; write block
FFFC1510 00000000		dw		0							; verify block
FFFC1514 00000000		dw		0							; output status
FFFC1518 00000000		dw		0							; flush input
FFFC151C 00000000		dw		0							; flush output
FFFC1520 FFFC15A4		dw		ViaIRQ				; IRQ routine
FFFC1524 00000000		dw		0							; Is removable
FFFC1528 00000000		dw		0							; ioctrl read
FFFC152C 00000000		dw		0							; ioctrl write
FFFC1530 00000000		dw		0							; output until busy
FFFC1534 00000000		dw		0							; 27
FFFC1538 00000000		dw		0
FFFC153C 00000000		dw		0
FFFC1540 00000000		dw		0
FFFC1544 00000000		dw		0							; 31
                        	
                        	;------------------------------------------------------------------------------
                        	; ViaInit
                        	;
                        	; Initialize the versatile interface adapter.
                        	;------------------------------------------------------------------------------
                        	
                        	ViaInit:
FFFC1548 FFC70713		sub		$sp,$sp,#4
FFFC154C 00172023		sw		$ra,[$sp]
FFFC1550 00F06913		ldi		$a0,#15							; VIA device
FFFC1554 FFFC19B7		ldi		$a1,#ViaFuncTbl
FFFC1558 4C898993
FFFC155C 180010EF		call	CopyDevFuncTbl
                        		; Initialize port A low order eight bits as output, the remaining bits as
                        		; input.
FFFC1560 FFDC0DB7		ldi		$t1,VIA
FFFC1564 600D8D93
FFFC1568 0FF06D13		ldi		$t0,#$000000FF
FFFC156C 01ADA623		sw		$t0,VIA_DDRA[$t1]
FFFC1570 00106D13		ldi		$t0,#1							; select timer 3 access
FFFC1574 03AD88A3		sb		$t0,VIA_PCR+1[$t1]
FFFC1578 01F06D13		ldi		$t0,#$1F
FFFC157C 03AD86A3		sb		$t0,VIA_ACR+1[$t1]		; set timer 3 mode, timer 1/2 = 64 bit
FFFC1580 00197D37		ldi		$t0,#$00196E6B			;	divider value for 30Hz
FFFC1584 E6BD0D13
FFFC1588 01ADA823		sw		$t0,VIA_T1CL[$t1]
FFFC158C 000DAA23		sw		$x0,VIA_T1CH[$t1]		; trigger transfer to count registers
FFFC1590 18006D13		ldi		$t0,#$180						; emable timer3 interrupts
FFFC1594 03ADAC23		sw		$t0,VIA_IER[$t1]
FFFC1598 00072083		lw		$ra,[$sp]
FFFC159C 00470713		add		$sp,$sp,#4
FFFC15A0 00008067		ret
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	ViaIRQ:
                        		; Was it the VIA that caused the interrupt?
FFFC15A4 FFDC0637		lb		$t0,VIA+VIA_IFR
FFFC15A8 63460613
FFFC15AC 00060633
FFFC15B0 00060D03
FFFC15B4 040D5663		bge		$t0,$x0,.0003			; no
FFFC15B8 FFDC0637		lw		$t0,VIA+VIA_T1CL	; yes, clear interrupt
FFFC15BC 61060613
FFFC15C0 00060633
FFFC15C4 00062D03
FFFC15C8 00004637		lw		$t0,milliseconds
FFFC15CC 20860613
FFFC15D0 00060633
FFFC15D4 00062D03
FFFC15D8 01ED0D13		add		$t0,$t0,#30
FFFC15DC 00004637		sw		$t0,milliseconds
FFFC15E0 20860613
FFFC15E4 00060633
FFFC15E8 01A62023
FFFC15EC 00004637		sw		$t0,switchflag
FFFC15F0 20060613
FFFC15F4 00060633
FFFC15F8 01A62023
FFFC15FC 618000EF		call	FMTK_SchedulerIRQ
                        	.0003:
FFFC1600 10000073		eret
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "../fmtk/task.asm",1
                        	.file "../fmtk/task.asm",1
                        	
                        	QNDX		EQU		$4304
                        	HRDY0		EQU		$4308
                        	HRDY1		EQU		$4309
                        	HRDY2		EQU		$430A
                        	HRDY3		EQU		$430B
                        	TRDY0		EQU		$430C
                        	TRDY1		EQU		$430D
                        	TRDY2		EQU		$430E
                        	TRDY3		EQU		$430F
                        	PIDMAP	EQU		$4310
                        	missed_ticks	equ		$4320
                        	TimeoutList		equ		$4328
                        	Tick		EQU		$4330
                        	RDYQ0		EQU		$4400
                        	RDYQ1		EQU		$4500
                        	RDYQ2		EQU		$4600
                        	RDYQ3		EQU		$4700
                        	msgs		EQU		$4800
                        	mbxs		EQU		$8800
                        	mbxs_end	EQU	$8A00
                        	FreeMsg	EQU		$8C00
                        	
                        		align	2                        	
                        	OSCallTbl:
FFFC1604 1DC80164		dh		FMTK_Initialize					; 0
FFFC1606 1E881DC8		dh		FMTK_StartTask					; 1
FFFC1608 1E901E88		dh		FMTK_ExitTask
FFFC160A 01681E90		dh		FMTK_KillTask
FFFC160C 1B4C0168		dh		FMTK_SetTaskPriority
FFFC160E 1EE01B4C		dh		FMTK_Sleep							; 5
FFFC1610 1F481EE0		dh		FMTK_AllocMbx
FFFC1612 016C1F48		dh		FMTK_FreeMbx
FFFC1614 1FC8016C		dh		FMTK_PostMsg
FFFC1616 21741FC8		dh		FMTK_SendMsg
FFFC1618 21682174		dh		FMTK_WaitMsg						; 10
FFFC161A 01702168		dh		FMTK_PeekMsg
FFFC161C 00000170		dh		FMTK_StartApp
FFFC161E 175C0000		dh		0												; 13
FFFC1620 23F4175C		dh		FMTK_GetCurrentTid
FFFC1622 000023F4		dh		DumpReadyQueue
FFFC1624 00000000		dh		0
FFFC1626 00000000		dh		0
FFFC1628 00000000		dh		0
FFFC162A 24B80000		dh		0
FFFC162C 255424B8		dh		FMTK_HasIOFocus					; 20
FFFC162E 25F42554		dh		FMTK_SwitchIOFocus			; 21
FFFC1630 25FC25F4		dh		FMTK_ReleaseIOFocus			; 22
FFFC1632 256025FC		dh		FMTK_ForceReleaseIOFocus	; 23
FFFC1634 00002560		dh		FMTK_RequestIOFocus			; 24
FFFC1636 26A40000		dh		0
FFFC1638 000026A4		dh		FMTK_IO									; 26
                        	
                        	qToChk:
FFFC163A 01000000		db	0,0,0,1,0,0,2,1
FFFC163E 01020000
FFFC1642 01030000		db	0,0,3,1,0,0,2,1
FFFC1646 01020000
FFFC164A 01000000		db	0,0,0,1,0,0,2,1
FFFC164E 01020000
FFFC1652 01030000		db	0,0,3,1,0,0,2,1
FFFC1656 01020000
                        	
FFFC165A 46370000		align	
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FMTKInit:
FFFC165C 00004637		sw		$x0,QNDX
FFFC1660 30460613
FFFC1664 00060633
FFFC1668 00062023
FFFC166C 00004637		sw		$x0,HRDY0				; reset head and tail indexes
FFFC1670 30860613
FFFC1674 00060633
FFFC1678 00062023
FFFC167C 00004637		sw		$x0,TRDY0
FFFC1680 30C60613
FFFC1684 00060633
FFFC1688 00062023
FFFC168C 00004637		sw		$x0,PIDMAP
FFFC1690 31060613
FFFC1694 00060633
FFFC1698 00062023
FFFC169C 00004637		sw		$x0,missed_ticks
FFFC16A0 32060613
FFFC16A4 00060633
FFFC16A8 00062023
FFFC16AC FFF06D13		ldi		$t0,#-1
FFFC16B0 00004637		sw		$t0,TimeoutList
FFFC16B4 32860613
FFFC16B8 00060633
FFFC16BC 01A62023
                        	
FFFC16C0 00009637		sw		$x0,IOFocusTbl
FFFC16C4 C1060613
FFFC16C8 00060633
FFFC16CC 00062023
FFFC16D0 00009637		sw		$t0,IOFocusNdx
FFFC16D4 C0860613
FFFC16D8 00060633
FFFC16DC 01A62023
                        	
                        		; zero out device function table
FFFC16E0 0000AD37		ldi		$t0,#DVF_Base
FFFC16E4 000D0D13
FFFC16E8 40006D93		ldi		$t1,#32*32
                        	.0003:
FFFC16EC 000D2023		sw		$x0,[$t0]
FFFC16F0 004D0D13		add		$t0,$t0,#4
FFFC16F4 FFFD8D93		sub		$t1,$t1,#1
FFFC16F8 FFB04AE3		bgt		$t1,$x0,.0003
                        	
                        		; Initialize mailboxes
FFFC16FC 00009D37		ldi		$t0,#mbxs
FFFC1700 800D0D13
FFFC1704 08006D93		ldi		$t1,#4*32
                        	.0001:
FFFC1708 000D2023		sw		$x0,[$t0]
FFFC170C 004D0D13		add		$t0,$t0,#4
FFFC1710 FFFD8D93		sub		$t1,$t1,#1
FFFC1714 FFB04AE3		bgt		$t1,$x0,.0001
                        	
                        		; Initialize free message list
FFFC1718 00005D37		ldi		$t0,#msgs
FFFC171C 800D0D13
FFFC1720 00009637		sw		$t0,FreeMsg
FFFC1724 C0060613
FFFC1728 00060633
FFFC172C 01A62023
FFFC1730 00006D93		ldi		$t1,#0
FFFC1734 20006E13		ldi		$t2,#512
                        	.0002:
FFFC1738 001D8D93		add		$t1,$t1,#1
FFFC173C 01BD2023		sw		$t1,MSG_LINK[$t0]
FFFC1740 010D0D13		add		$t0,$t0,#16
FFFC1744 FFFE0E13		sub		$t2,$t2,#1
FFFC1748 FFC048E3		bgt		$t2,$x0,.0002
FFFC174C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Get the task id for the currently running task.
                        	;
                        	; Returns:
                        	;		v0 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	GetCurrentTid:
FFFC1750 18101873		csrrw	$v0,#$181,$x0				; get current pid
FFFC1754 00F87813		and		$v0,$v0,#15					; mask off extra bits
FFFC1758 00008067		ret
                        	
                        	FMTK_GetCurrentTid:
FFFC175C FF5FF0EF		call	GetCurrentTid
FFFC1760 000868B3		mov		$v1,$v0
FFFC1764 00006813		ldi		$v0,#E_Ok
FFFC1768 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	MapOSPages:
FFFC176C 02006813		ldi			$v0,#OSPAGES	; number of pages pre-mapped
FFFC1770 00006893		ldi			$v1,#0
FFFC1774 00891893		sll			$v1,$a0,#8		; put ASID in proper spot
                        	.nxt:
FFFC1778 0318800D		mvmap		$x0,$v1,$v1
FFFC177C 00188893		add			$v1,$v1,#1
FFFC1780 FFF80813		sub			$v0,$v0,#1
FFFC1784 FF004AE3		bgt			$v0,$x0,.nxt
FFFC1788 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Select the next task to run. The ready queues are searched in a circular
                        	; fashion beginning with the queue identified indirectly by QNDX. There are
                        	; four ready queues to hold tasks of four different priorities. This routine
                        	; dequeues a task from the ready list, then adds it back if it is still ready.
                        	; This takes care of a lot of scenarios. Such as the task no longer being
                        	; ready, or the priority changing.
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		v1, t0, t1, t2, t3, t4
                        	;	Returns:
                        	;		v0 = task id of task to run
                        	;------------------------------------------------------------------------------
                        	
                        	SelectTaskToRun:
FFFC178C FFC70713		sub		$sp,$sp,#4					; stack return address
FFFC1790 00172023		sw		$ra,[$sp]
                        		; Pick the first queue to check, occasionally the queue
                        		; chosen isn't the highest priority one in order to 
                        		; prevent starvation of lower priority tasks.
FFFC1794 00004637		lbu		$v1,QNDX						; get index into que check table
FFFC1798 30460613
FFFC179C 00060633
FFFC17A0 00064883
FFFC17A4 00188893		add		$v1,$v1,#1					; increment it, and limit
FFFC17A8 01F8F893		and		$v1,$v1,#31
FFFC17AC 00004637		sb		$v1,QNDX						; store back
FFFC17B0 30460613
FFFC17B4 00060633
FFFC17B8 01160023
FFFC17BC FFFC1637		lbu		$v1,qToChk[$v1]			; assume this will be valid
FFFC17C0 63A60613
FFFC17C4 01160633
FFFC17C8 00064883
FFFC17CC 00406E13		ldi		$t2,#4							; 4 queues to check
                        	.nxtQ:
FFFC17D0 00004637		lbu		$t0,HRDY0[$v1]			; check queue to see if contains any
FFFC17D4 30860613
FFFC17D8 01160633
FFFC17DC 00064D03
FFFC17E0 00004637		lbu		$t1,TRDY0[$v1]			; ready tasks
FFFC17E4 30C60613
FFFC17E8 01160633
FFFC17EC 00064D83
FFFC17F0 01BD1E63		bne		$t0,$t1,.dq					; yes, go dequeue
FFFC17F4 00188893		add		$v1,$v1,#1					; no, advance to next queue
FFFC17F8 0038F893		and		$v1,$v1,#3					; 4 max
FFFC17FC FFFE0E13		sub		$t2,$t2,#1					;
FFFC1800 FDC048E3		bgt		$t2,$x0,.nxtQ				; go back to check next queue
                        		; Here, nothing else is actually ready to run
                        		; just go back to what we were doing.
FFFC1804 F4DFF0EF		call	GetCurrentTid				; tail recursion here
FFFC1808 04000063		bra		.goodTid
                        	.dq:
FFFC180C 00889E93		sll		$t3,$v1,#8					; compute t3 = readyq index
FFFC1810 00004637		add		$t3,$t3,#RDYQ0
FFFC1814 40060613
FFFC1818 01D60EB3
FFFC181C 01DD0F33		add		$t4,$t0,$t3
FFFC1820 000F4803		lbu		$v0,[$t4]						; v0 = tid of ready task
FFFC1824 00F06E93		ldi		$t3,#MAX_TID				; ensure we have a valid tid
FFFC1828 030EF063		bleu	$v0,$t3,.goodTid
                        		; If the tid isn't valid, remove it from the queue and go back
                        		; and check the next queue entry
FFFC182C 001D0D13		add		$t0,$t0,#1					; advance readyq head
FFFC1830 0FFD7D13		and		$t0,$t0,#255
FFFC1834 00004637		sb		$t0,HRDY0[$v1]			; save head pointer
FFFC1838 30860613
FFFC183C 01160633
FFFC1840 01A60023
FFFC1844 F80006E3		bra		.nxtQ
                        	.goodTid:
FFFC1848 001D0D13		add		$t0,$t0,#1					; advance readyq head
FFFC184C 0FFD7D13		and		$t0,$t0,#255
FFFC1850 00004637		sb		$t0,HRDY0[$v1]			; save head pointer
FFFC1854 30860613
FFFC1858 01160633
FFFC185C 01A60023
                        		; Now filter out tasks (remove from ready list) that aren't ready to run
FFFC1860 00A81D13		sll		$t0,$v0,#10					; tid to pointer
FFFC1864 288D0D03		lb		$t0,TCBStatus[$t0]	; get status
FFFC1868 001D7D13		and		$t0,$t0,#TS_READY		; is it ready?
FFFC186C F60D02E3		beq		$t0,$x0,.nxtQ
                        		; And re-insert task into queue for next time
FFFC1870 00086933		mov		$a0,$v0
FFFC1874 175000EF		call	InsertTask					; could check if insert failed
FFFC1878 00096833		mov		$v0,$a0							; get back tid
FFFC187C 00072083		lw		$ra,[$sp]						; restore return address
FFFC1880 00470713		add		$sp,$sp,#4
FFFC1884 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Swap from outgoing context to incoming context.
                        	;
                        	; Parameters:
                        	;		a0 = pointer to TCB of outgoing context
                        	;		a1 = pointer to TCB of incoming context
                        	;------------------------------------------------------------------------------
                        	
                        	SwapContext:
                        		; Save outgoing register set in TCB
FFFC1888 0400810D		mfu		$x2,$x1
FFFC188C 00292223		sw		$x2,4[$a0]
FFFC1890 0401010D		mfu		$x2,$x2
FFFC1894 00292423		sw		$x2,8[$a0]
FFFC1898 0401810D		mfu		$x2,$x3
FFFC189C 00292623		sw		$x2,12[$a0]
FFFC18A0 0402010D		mfu		$x2,$x4
FFFC18A4 00292823		sw		$x2,16[$a0]
FFFC18A8 0402810D		mfu		$x2,$x5
FFFC18AC 00292A23		sw		$x2,20[$a0]
FFFC18B0 0403010D		mfu		$x2,$x6
FFFC18B4 00292C23		sw		$x2,24[$a0]
FFFC18B8 0403810D		mfu		$x2,$x7
FFFC18BC 00292E23		sw		$x2,28[$a0]
FFFC18C0 0404010D		mfu		$x2,$x8
FFFC18C4 02292023		sw		$x2,32[$a0]
FFFC18C8 0404810D		mfu		$x2,$x9
FFFC18CC 02292223		sw		$x2,36[$a0]
FFFC18D0 0405010D		mfu		$x2,$x10
FFFC18D4 02292423		sw		$x2,40[$a0]
FFFC18D8 0405810D		mfu		$x2,$x11
FFFC18DC 02292623		sw		$x2,44[$a0]
FFFC18E0 0406010D		mfu		$x2,$x12
FFFC18E4 02292823		sw		$x2,48[$a0]
FFFC18E8 0406810D		mfu		$x2,$x13
FFFC18EC 02292A23		sw		$x2,52[$a0]
FFFC18F0 0407010D		mfu		$x2,$x14
FFFC18F4 02292C23		sw		$x2,56[$a0]
FFFC18F8 0407810D		mfu		$x2,$x15
FFFC18FC 02292E23		sw		$x2,60[$a0]
FFFC1900 0408010D		mfu		$x2,$x16
FFFC1904 04292023		sw		$x2,64[$a0]
FFFC1908 0408810D		mfu		$x2,$x17
FFFC190C 04292223		sw		$x2,68[$a0]
FFFC1910 0409010D		mfu		$x2,$x18
FFFC1914 04292423		sw		$x2,72[$a0]
FFFC1918 0409810D		mfu		$x2,$x19
FFFC191C 04292623		sw		$x2,76[$a0]
FFFC1920 040A010D		mfu		$x2,$x20
FFFC1924 04292823		sw		$x2,80[$a0]
FFFC1928 040A810D		mfu		$x2,$x21
FFFC192C 04292A23		sw		$x2,84[$a0]
FFFC1930 040B010D		mfu		$x2,$x22
FFFC1934 04292C23		sw		$x2,88[$a0]
FFFC1938 040B810D		mfu		$x2,$x23
FFFC193C 04292E23		sw		$x2,92[$a0]
FFFC1940 040C010D		mfu		$x2,$x24
FFFC1944 06292023		sw		$x2,96[$a0]
FFFC1948 040C810D		mfu		$x2,$x25
FFFC194C 06292223		sw		$x2,100[$a0]
FFFC1950 040D010D		mfu		$x2,$x26
FFFC1954 06292423		sw		$x2,104[$a0]
FFFC1958 040D810D		mfu		$x2,$x27
FFFC195C 06292623		sw		$x2,108[$a0]
FFFC1960 040E010D		mfu		$x2,$x28
FFFC1964 06292823		sw		$x2,112[$a0]
FFFC1968 040E810D		mfu		$x2,$x29
FFFC196C 06292A23		sw		$x2,116[$a0]
FFFC1970 040F010D		mfu		$x2,$x30
FFFC1974 06292C23		sw		$x2,120[$a0]
FFFC1978 040F810D		mfu		$x2,$x31
FFFC197C 06292E23		sw		$x2,124[$a0]
FFFC1980 34101173		csrrw	$x2,#$341,$x0				; save off mepc
FFFC1984 28292023		sw		$x2,TCBepc[$a0]
                        		; Now save off segment registers
FFFC1988 00006D93		ldi		$t1,#0
                        	.svseg:
FFFC198C 01B00D0D		mvseg	$t0,$x0,$t1
FFFC1990 002D9113		sll		$x2,$t1,#2
FFFC1994 01210133		add		$x2,$x2,$a0
FFFC1998 21A12023		sw		$t0,TCBsegs[$x2]
FFFC199C 001D8D93		add		$t1,$t1,#1
FFFC19A0 00FDFD93		and		$t1,$t1,#15
FFFC19A4 FE0D94E3		bne		$t1,$x0,.svseg
                        	
                        		; Switch memory maps
FFFC19A8 00A9D813		srl		$v0,$a1,#10					; convert pointer to tid
FFFC19AC 00F87813		and		$v0,$v0,#$F					; mask to 16 task
FFFC19B0 181818F3		csrrw	$v1,#$181,$v0				; set ASID
                        		; User map has now been switched
                        	
                        		; Restore segment register set
FFFC19B4 00006D93		ldi		$t1,#0
                        	.rsseg:
FFFC19B8 002D9113		sll		$x2,$t1,#2
FFFC19BC 01310133		add		$x2,$x2,$a1
FFFC19C0 20012D03		lw		$t0,TCBsegs[$x2]
FFFC19C4 01BD000D		mvseg	$x0,$t0,$t1
FFFC19C8 001D8D93		add		$t1,$t1,#1
FFFC19CC 00FDFD93		and		$t1,$t1,#15
FFFC19D0 FE0D94E3		bne		$t1,$x0,.rsseg
                        	
FFFC19D4 2809A103		lw		$x2,TCBepc[$a1]			; restore epc
FFFC19D8 34111073		csrrw	$x0,#$341,$x2
                        		; Restore incoming registers
FFFC19DC 0049A103		lw		$x2,4[$a1]
FFFC19E0 0601008D		mtu		$x1,$x2
FFFC19E4 0089A103		lw		$x2,8[$a1]
FFFC19E8 0601010D		mtu		$x2,$x2
FFFC19EC 00C9A103		lw		$x2,12[$a1]
FFFC19F0 0601018D		mtu		$x3,$x2
FFFC19F4 0109A103		lw		$x2,16[$a1]
FFFC19F8 0601020D		mtu		$x4,$x2
FFFC19FC 0149A103		lw		$x2,20[$a1]
FFFC1A00 0601028D		mtu		$x5,$x2
FFFC1A04 0189A103		lw		$x2,24[$a1]
FFFC1A08 0601030D		mtu		$x6,$x2
FFFC1A0C 01C9A103		lw		$x2,28[$a1]
FFFC1A10 0601038D		mtu		$x7,$x2
FFFC1A14 0209A103		lw		$x2,32[$a1]
FFFC1A18 0601040D		mtu		$x8,$x2
FFFC1A1C 0249A103		lw		$x2,36[$a1]
FFFC1A20 0601048D		mtu		$x9,$x2
FFFC1A24 0289A103		lw		$x2,40[$a1]
FFFC1A28 0601050D		mtu		$x10,$x2
FFFC1A2C 02C9A103		lw		$x2,44[$a1]
FFFC1A30 0601058D		mtu		$x11,$x2
FFFC1A34 0309A103		lw		$x2,48[$a1]
FFFC1A38 0601060D		mtu		$x12,$x2
FFFC1A3C 0349A103		lw		$x2,52[$a1]
FFFC1A40 0601068D		mtu		$x13,$x2
FFFC1A44 0389A103		lw		$x2,56[$a1]
FFFC1A48 0601070D		mtu		$x14,$x2
FFFC1A4C 03C9A103		lw		$x2,60[$a1]
FFFC1A50 0601078D		mtu		$x15,$x2
FFFC1A54 0409A103		lw		$x2,64[$a1]
FFFC1A58 0601080D		mtu		$x16,$x2
FFFC1A5C 0449A103		lw		$x2,68[$a1]
FFFC1A60 0601088D		mtu		$x17,$x2
FFFC1A64 0489A103		lw		$x2,72[$a1]
FFFC1A68 0601090D		mtu		$x18,$x2
FFFC1A6C 04C9A103		lw		$x2,76[$a1]
FFFC1A70 0601098D		mtu		$x19,$x2
FFFC1A74 0509A103		lw		$x2,80[$a1]
FFFC1A78 06010A0D		mtu		$x20,$x2
FFFC1A7C 0549A103		lw		$x2,84[$a1]
FFFC1A80 06010A8D		mtu		$x21,$x2
FFFC1A84 0589A103		lw		$x2,88[$a1]
FFFC1A88 06010B0D		mtu		$x22,$x2
FFFC1A8C 05C9A103		lw		$x2,92[$a1]
FFFC1A90 06010B8D		mtu		$x23,$x2
FFFC1A94 0609A103		lw		$x2,96[$a1]
FFFC1A98 06010C0D		mtu		$x24,$x2
FFFC1A9C 0649A103		lw		$x2,100[$a1]
FFFC1AA0 06010C8D		mtu		$x25,$x2
FFFC1AA4 0689A103		lw		$x2,104[$a1]
FFFC1AA8 06010D0D		mtu		$x26,$x2
FFFC1AAC 06C9A103		lw		$x2,108[$a1]
FFFC1AB0 06010D8D		mtu		$x27,$x2
FFFC1AB4 0709A103		lw		$x2,112[$a1]
FFFC1AB8 06010E0D		mtu		$x28,$x2
FFFC1ABC 0749A103		lw		$x2,116[$a1]
FFFC1AC0 06010E8D		mtu		$x29,$x2
FFFC1AC4 0789A103		lw		$x2,120[$a1]
FFFC1AC8 06010F0D		mtu		$x30,$x2
FFFC1ACC 07C9A103		lw		$x2,124[$a1]
FFFC1AD0 06010F8D		mtu		$x31,$x2
FFFC1AD4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Operating system call dispatcher.
                        	;------------------------------------------------------------------------------
                        	
                        	OSCALL:
FFFC1AD8 00080737		ldi		$sp,#$80000-4		; setup machine mode stack pointer
FFFC1ADC FFC70713
FFFC1AE0 0409090D		mfu		$a0,$a0
FFFC1AE4 0409898D		mfu		$a1,$a1
FFFC1AE8 040A0A0D		mfu		$a2,$a2
FFFC1AEC 040A8A8D		mfu		$a3,$a3
FFFC1AF0 040B0B0D		mfu		$a4,$a4
FFFC1AF4 040B8B8D		mfu		$a5,$a5
FFFC1AF8 01F97913		and		$a0,$a0,#31
FFFC1AFC 00191913		sll		$a0,$a0,#1
FFFC1B00 FFFC1637		lhu		$t0,OSCallTbl[$a0]
FFFC1B04 60460613
FFFC1B08 01260633
FFFC1B0C 00065D03
FFFC1B10 FFFC0637		or		$t0,$t0,#$FFFC0000
FFFC1B14 00060613
FFFC1B18 01A66D33
FFFC1B1C 000D0067		jmp		[$t0]
                        	
                        	;------------------------------------------------------------------------------
                        	; Time accounting.
                        	; Update the length of time the task has been running.
                        	;
                        	; Parameters:
                        	;		s1 = pointer to TCB
                        	; Modifies:
                        	;		t2,t3,t4,t5
                        	;------------------------------------------------------------------------------
                        	
                        	AccountTime:
                        	.again:
                        	;	csrrw	$t3,#$741,$x0					; get high time
                        	;	csrrw	$t2,#$701,$x0					; get low time
                        	;	csrrw	$t4,#$741,$x0
                        	;	bne		$t3,$t4,.again
FFFC1B20 00004637		lw		$t2,Tick
FFFC1B24 33060613
FFFC1B28 00060633
FFFC1B2C 00062E03
FFFC1B30 2BC22C23		sw		$t2,TCBEndTick[$s1]
FFFC1B34 2B022E83		lw		$t3,TCBStartTick[$s1]
FFFC1B38 41DE0F33		sub		$t4,$t2,$t3						; end - start
FFFC1B3C 2C022F83		lw		$t5,TCBTicks[$s1]
FFFC1B40 01EF8FB3		add		$t5,$t5,$t4						; ticks + (end - start)
FFFC1B44 2DF22023		sw		$t5,TCBTicks[$s1]
FFFC1B48 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Sleep for a number of ticks. Tick interval determined by the VIA timer #3.
                        	; Passing a time of zero or less causes the function to return right away.
                        	;
                        	; Parameters:
                        	;		a1 = length of time to sleep (must be >= 0)
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_Sleep:
FFFC1B4C 0C09C263		blt		$a1,$x0,ERETx
FFFC1B50 C01FF0EF		call	GetCurrentTid
FFFC1B54 00A81213		sll		$s1,$v0,#10
FFFC1B58 00098C63		beq		$a1,$x0,.0001
FFFC1B5C 28824D83		lbu		$t1,TCBStatus[$s1]		; changing status will remove from ready queue
FFFC1B60 FFEDFD93		and		$t1,$t1,#~TS_READY		; on next dequeue
FFFC1B64 29B20423		sb		$t1,TCBStatus[$s1]
FFFC1B68 00086933		mov		$a0,$v0								; a0 = current tid
FFFC1B6C 71C000EF		call	InsertIntoTimeoutList	; a1 = timeout
                        	.0001:
FFFC1B70 28824803		lbu		$v0,TCBStatus[$s1]		; flag task as no longer running
FFFC1B74 F7F87813		and		$v0,$v0,#~TS_RUNNING
FFFC1B78 29020423		sb		$v0,TCBStatus[$s1]
                        	
FFFC1B7C FA5FF0EF		call	AccountTime						; uses s1
FFFC1B80 C0DFF0EF		call	SelectTaskToRun
                        	
FFFC1B84 00A81293		sll		$s2,$v0,#10						; s2 = pointer to incoming TCB
FFFC1B88 2882C103		lbu		$x2,TCBStatus[$s2]		; x2 = incoming status
FFFC1B8C 08116E13		or		$t2,$x2,#TS_RUNNING|TS_READY	; set status = running
FFFC1B90 2C82A103		lw		$x2,TCBException[$s2]	;
FFFC1B94 00010A63		beq		$x2,$x0,.noException
                        		; set link register to catch handler address
                        		;{
                        		;	t->regs[29] = t->regs[28];   // set link register to catch handler
                        		;	t->epc = t->regs[28];        // and the PC register
                        		;	t->regs[1] = t->exception;    // r1 = exception value
                        		;	t->exception = 0;
                        		;	t->regs[2] = 45;              // r2 = exception type
                        		;}
FFFC1B98 0022A223		sw		$x2,4[$s2]						; r1 = exception
FFFC1B9C 2C02A423		sw		$x0,TCBException[$s2]	; tcb->exception = 0
FFFC1BA0 02D06113		ldi		$x2,#45
FFFC1BA4 0022A423		sw		$x2,8[$s2]						; r2 = 45
                        	.noException:
                        	
                        		; If a message is ready, update status to ready and put
                        		; message in target memory. The task will be returning
                        		; from a WaitMsg so a return status of E_Ok is also set.
FFFC1BA8 004E7113		and		$x2,$t2,#TS_MSGRDY
FFFC1BAC 02010E63		beq		$x2,$x0,.noMsg
FFFC1BB0 0502A903		lw		$a0,80[$s2]					; user a2 (x20)
FFFC1BB4 D40FF0EF		call	VirtToPhys
FFFC1BB8 2982A103		lw		$x2,TCBMsgD1[$s2]
FFFC1BBC 00282023		sw		$x2,[$v0]
FFFC1BC0 0542A903		lw		$a0,84[$s2]
FFFC1BC4 D30FF0EF		call	VirtToPhys
FFFC1BC8 2A02A103		lw		$x2,TCBMsgD2[$s2]
FFFC1BCC 00282023		sw		$x2,[$v0]
FFFC1BD0 0582A903		lw		$a0,88[$s2]
FFFC1BD4 D20FF0EF		call	VirtToPhys
FFFC1BD8 2A82A103		lw		$x2,TCBMsgD3[$s2]
FFFC1BDC 00282023		sw		$x2,[$v0]
FFFC1BE0 00006113		ldi		$x2,#E_Ok						; setup to return E_Ok
FFFC1BE4 0422A023		sw		$x2,64[$s2]					; in v0
                        	
                        	.noMsg:
FFFC1BE8 FFBE7E13		and		$t2,$t2,#~TS_MSGRDY		; mask out message ready status
FFFC1BEC 29C28423		sb		$t2,TCBStatus[$s2]
                        	;	beq		$s1,$s2,.noCtxSwitch	; incoming and outgoing contexts the same?
FFFC1BF0 00026933		mov		$a0,$s1
FFFC1BF4 0002E9B3		mov		$a1,$s2
FFFC1BF8 C91FF0EF		call	SwapContext
                        	.noCtxSwitch:
FFFC1BFC 00004637		lw		$t2,Tick						; get tick
FFFC1C00 33060613
FFFC1C04 00060633
FFFC1C08 00062E03
FFFC1C0C 2BC22823		sw		$t2,TCBStartTick[$s1]
                        	ERETx:
FFFC1C10 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; SchedulerIRQ meant to be called from the timer ISR.
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_SchedulerIRQ:
FFFC1C14 FFC70713		sub		$sp,$sp,#4
FFFC1C18 00172023		sw		$ra,[$sp]
FFFC1C1C 00004637		lw		$t5,Tick							; update tick count
FFFC1C20 33060613
FFFC1C24 00060633
FFFC1C28 00062F83
FFFC1C2C 001F8F93		add		$t5,$t5,#1
FFFC1C30 00004637		sw		$t5,Tick
FFFC1C34 33060613
FFFC1C38 00060633
FFFC1C3C 01F62023
FFFC1C40 B11FF0EF		call	GetCurrentTid
FFFC1C44 00A81213		sll		$s1,$v0,#10						; compute pointer to TCB
FFFC1C48 ED9FF0EF		call	AccountTime
FFFC1C4C 28824F83		lbu		$t5,TCBStatus[$s1]
FFFC1C50 020FEF93		or		$t5,$t5,#TS_PREEMPT
FFFC1C54 F7FFFF93		and		$t5,$t5,#~TS_RUNNING	; no longer running, but may still be ready
FFFC1C58 29F20423		sb		$t5,TCBStatus[$s1]
                        		; Keep popping the timeout list as long as there are tasks on it with
                        		; expired timeouts.
                        	.0001:
FFFC1C5C 00004637		lh		$t5,TimeoutList
FFFC1C60 32860613
FFFC1C64 00060633
FFFC1C68 00061F83
FFFC1C6C 040FCA63		blt		$t5,$x0,.noTimeouts
FFFC1C70 01006F13		ldi		$t4,#NR_TCB
FFFC1C74 05EFD663		bge		$t5,$t4,.noTimeouts
FFFC1C78 00AF9F13		sll		$t4,$t5,#10					; index to pointer
FFFC1C7C 2E0F2E83		lw		$t3,TCBTimeout[$t4]
FFFC1C80 01D04A63		bgt		$t3,$x0,.timeoutNotDone
FFFC1C84 718000EF		call	PopTimeoutList
FFFC1C88 00086933		mov		$a0,$v0
FFFC1C8C 55C000EF		call	InsertTask
FFFC1C90 FC0006E3		bra		.0001
                        	.timeoutNotDone:
FFFC1C94 FFFE8E93		sub		$t3,$t3,#1
FFFC1C98 00004637		lw		$t2,missed_ticks
FFFC1C9C 32060613
FFFC1CA0 00060633
FFFC1CA4 00062E03
FFFC1CA8 41CE8EB3		sub		$t3,$t3,$t2
FFFC1CAC 2FDF2023		sw		$t3,TCBTimeout[$t4]
FFFC1CB0 00004637		sw		$x0,missed_ticks
FFFC1CB4 32060613
FFFC1CB8 00060633
FFFC1CBC 00062023
                        	.noTimeouts:
                        		; The ready queue was just updated, there could be new tasks
                        		; ready to run.
FFFC1CC0 ACDFF0EF		call	SelectTaskToRun
                        	
FFFC1CC4 00A81293		sll		$s2,$v0,#10					; s2 = pointer to incoming TCB
FFFC1CC8 2882C103		lbu		$x2,TCBStatus[$s2]	; x2 = incoming status
FFFC1CCC 08116E13		or		$t2,$x2,#TS_RUNNING|TS_READY	; status = running
FFFC1CD0 2C82A103		lw		$x2,TCBException[$s2]	;
FFFC1CD4 00010263		beq		$x2,$x0,.noException
                        		; set link register to catch handler address
                        		;{
                        		;	t->regs[29] = t->regs[28];   // set link register to catch handler
                        		;	t->epc = t->regs[28];        // and the PC register
                        		;	t->regs[1] = t->exception;    // r1 = exception value
                        		;	t->exception = 0;
                        		;	t->regs[2] = 45;              // r2 = exception type
                        		;}
                        	.noException:
                        	
                        		; If a message is ready, update status to ready and put
                        		; message in target memory. The task will be returning
                        		; from a WaitMsg so a return status of E_Ok is also set.
FFFC1CD8 004E7113		and		$x2,$t2,#TS_MSGRDY
FFFC1CDC 02010E63		beq		$x2,$x0,.noMsg
FFFC1CE0 0502A903		lw		$a0,80[$s2]					; user a2 (x20)
FFFC1CE4 C10FF0EF		call	VirtToPhys
FFFC1CE8 2982A103		lw		$x2,TCBMsgD1[$s2]
FFFC1CEC 00282023		sw		$x2,[$v0]
FFFC1CF0 0542A903		lw		$a0,84[$s2]
FFFC1CF4 C00FF0EF		call	VirtToPhys
FFFC1CF8 2A02A103		lw		$x2,TCBMsgD2[$s2]
FFFC1CFC 00282023		sw		$x2,[$v0]
FFFC1D00 0582A903		lw		$a0,88[$s2]
FFFC1D04 BF0FF0EF		call	VirtToPhys
FFFC1D08 2A82A103		lw		$x2,TCBMsgD3[$s2]
FFFC1D0C 00282023		sw		$x2,[$v0]
FFFC1D10 00006113		ldi		$x2,#E_Ok						; setup to return E_Ok
FFFC1D14 0422A023		sw		$x2,64[$s2]					; in v0
                        	
                        	.noMsg:
FFFC1D18 FFBE7E13		and		$t2,$t2,#~TS_MSGRDY		; mask out message ready status
FFFC1D1C 29C28423		sb		$t2,TCBStatus[$s2]
FFFC1D20 00520863		beq		$s1,$s2,.noCtxSwitch
FFFC1D24 00026933		mov		$a0,$s1
FFFC1D28 0002E9B3		mov		$a1,$s2
FFFC1D2C B5DFF0EF		call	SwapContext
                        	.noCtxSwitch:
FFFC1D30 00072083		lw		$ra,[$sp]
FFFC1D34 00470713		add		$sp,$sp,#4
FFFC1D38 00004637		lw		$t2,Tick					; get tick
FFFC1D3C 33060613
FFFC1D40 00060633
FFFC1D44 00062E03
FFFC1D48 2BC22823		sw		$t2,TCBStartTick[$s1]
FFFC1D4C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Returns:
                        	;		v1 = process id
                        	;------------------------------------------------------------------------------
                        	
                        	AllocTCB:
FFFC1D50 00006D93		ldi		$t1,#0
FFFC1D54 00004637		lhu		$v1,PIDMAP
FFFC1D58 31060613
FFFC1D5C 00060633
FFFC1D60 00065883
                        	.0001:
FFFC1D64 0018FD13		and		$t0,$v1,#1
FFFC1D68 020D0463		beq		$t0,$x0,.allocTid
FFFC1D6C 0018D893		srl		$v1,$v1,#1
FFFC1D70 00008637		or		$v1,$v1,#$8000
FFFC1D74 00060613
FFFC1D78 011668B3
FFFC1D7C 001D8D93		add		$t1,$t1,#1
FFFC1D80 00FDFD93		and		$t1,$t1,#15
FFFC1D84 FE0D90E3		bne		$t1,$x0,.0001
                        	; here no tcbs available
FFFC1D88 04506813		ldi		$v0,#E_NoMoreTCBs
FFFC1D8C 00008067		ret
                        	.allocTid:
FFFC1D90 000DE833		mov		$v0,$t1
FFFC1D94 0018E893		or		$v1,$v1,#1
FFFC1D98 000D8A63		beq		$t1,$x0,.0003
                        	.0002:
FFFC1D9C 00189893		sll		$v1,$v1,#1
FFFC1DA0 0018E893		or		$v1,$v1,#1
FFFC1DA4 FFFD8D93		sub		$t1,$t1,#1
FFFC1DA8 FE0D9AE3		bne		$t1,$x0,.0002
                        	.0003:
FFFC1DAC 00004637		sh		$v1,PIDMAP
FFFC1DB0 31060613
FFFC1DB4 00060633
FFFC1DB8 01161023
FFFC1DBC 000868B3		mov		$v1,$v0
FFFC1DC0 00006813		ldi		$v0,#E_Ok
FFFC1DC4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Start a task.
                        	;	Task status is set to ready, priority normal, and the task is inserted into
                        	; the ready queue. Segment registers are setup for a flat memory model.
                        	; 
                        	;	Parameters:
                        	;		a1 = memory required
                        	;		a2 = start pc (usually $100)
                        	;	Modifies:
                        	;		a0 = tid
                        	;	Returns:
                        	;		v0 = E_Ok if successful
                        	;		v1 = tid of started task if successful
                        	;------------------------------------------------------------------------------
                        	;
                        	FMTK_StartTask:
FFFC1DC8 FFC70713		sub		$sp,$sp,#4
FFFC1DCC 00172023		sw		$ra,[$sp]
FFFC1DD0 F81FF0EF		call	AllocTCB
FFFC1DD4 0A081263		bne		$v0,$x0,.err
FFFC1DD8 0008E933		mov		$a0,$v1
FFFC1DDC 991FF0EF		call	MapOSPages			; Map OS pages into address space
FFFC1DE0 00A89213		sll		$s1,$v1,#10			; compute TCB address
FFFC1DE4 A80FF0EF		call	AllocStack
FFFC1DE8 00080D37		ldi		$t0,#$7F800			; set stack pointer
FFFC1DEC 800D0D13
FFFC1DF0 03A22C23		sw		$t0,56[$s1]
FFFC1DF4 29422023		sw		$a2,TCBepc[$s1]	; address task will begin at
FFFC1DF8 9B0FF0EF		call	Alloc
FFFC1DFC 06081E63		bne		$v0,$x0,.err
FFFC1E00 00106D13		ldi		$t0,#TS_READY
FFFC1E04 29A20423		sb		$t0,TCBStatus[$s1]
FFFC1E08 00206D13		ldi		$t0,#2					; normal execution priority
FFFC1E0C 29A204A3		sb		$t0,TCBPriority[$s1]
                        		; leave segment base at $0, flat memory model
FFFC1E10 00606D13		ldi		$t0,#6							; read,write
FFFC1E14 21A22023		sw		$t0,TCBsegs[$s1]			; segs 0 to 11
FFFC1E18 21A22223		sw		$t0,TCBsegs+4[$s1]
FFFC1E1C 21A22423		sw		$t0,TCBsegs+8[$s1]
FFFC1E20 21A22623		sw		$t0,TCBsegs+12[$s1]
FFFC1E24 21A22823		sw		$t0,TCBsegs+16[$s1]
FFFC1E28 21A22A23		sw		$t0,TCBsegs+20[$s1]
FFFC1E2C 21A22C23		sw		$t0,TCBsegs+24[$s1]
FFFC1E30 21A22E23		sw		$t0,TCBsegs+28[$s1]
FFFC1E34 23A22023		sw		$t0,TCBsegs+32[$s1]
FFFC1E38 23A22223		sw		$t0,TCBsegs+36[$s1]
FFFC1E3C 23A22423		sw		$t0,TCBsegs+40[$s1]
FFFC1E40 23A22623		sw		$t0,TCBsegs+44[$s1]
FFFC1E44 00506D13		ldi		$t0,#5							; read,execute
FFFC1E48 23A22823		sw		$t0,TCBsegs+48[$s1]	; segs 12 to 15
FFFC1E4C 23A22A23		sw		$t0,TCBsegs+52[$s1]
FFFC1E50 23A22C23		sw		$t0,TCBsegs+56[$s1]
FFFC1E54 23A22E23		sw		$t0,TCBsegs+60[$s1]
FFFC1E58 00A25913		srl		$a0,$s1,#10					; need the tid again
FFFC1E5C 38C000EF		call	InsertTask
FFFC1E60 000968B3		mov		v1,a0
FFFC1E64 00072083		lw		$ra,[$sp]
FFFC1E68 00470713		add		$sp,$sp,#4
FFFC1E6C 0608080D		mtu		$v0,$v0
FFFC1E70 0608888D		mtu		$v1,$v1
FFFC1E74 10000073		eret
                        	.err:
                        	;	mov		$a0,$v0
                        	;	call	PutHexByte
FFFC1E78 00072083		lw		$ra,[$sp]
FFFC1E7C 00470713		add		$sp,$sp,#4
FFFC1E80 0608080D		mtu		$v0,$v0
FFFC1E84 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Exit the current task.
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		a1 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_ExitTask:
FFFC1E88 8C9FF0EF		call	GetCurrentTid
FFFC1E8C 000869B3		mov		a1,v0
                        		; fall through to KillTask
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = tid of task to kill
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_KillTask:
FFFC1E90 04098663		beq		$a1,$x0,.immortal		; tid #0 is immortal (the system)
FFFC1E94 00206D13		ldi		$t0,#TS_DEAD				; flag task as dead (prevents it from being re-queued)
FFFC1E98 00F9FD93		and		$t1,$a1,#15					; limit pid
FFFC1E9C 00AD9D93		sll		$t1,$t1,#10					; convert to TCB address
FFFC1EA0 29AD8423		sb		$t0,TCBStatus[$t1]
FFFC1EA4 0009E933		mov		a0,a1								; a0 = pid
FFFC1EA8 9E8FF0EF		call	FreeAll							; free all the memory associated with the task
                        		; Now make process ID available for reuse
FFFC1EAC 00004637		lhu		$t1,PIDMAP
FFFC1EB0 31060613
FFFC1EB4 00060633
FFFC1EB8 00065D83
FFFC1EBC 00106D13		ldi		$t0,#1							; generate bit "off" mask
FFFC1EC0 013D1D13		sll		$t0,$t0,$a1
FFFC1EC4 FFFD4D13		xor		$t0,$t0,#-1					; complment for inverted mask
FFFC1EC8 01ADFDB3		and		$t1,$t1,$t0
FFFC1ECC 00004637		sh		$t1,PIDMAP
FFFC1ED0 31060613
FFFC1ED4 00060633
FFFC1ED8 01B61023
                        	.immortal:
FFFC1EDC 10000073		eret
                        	
                        	
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "../fmtk/msg.asm",1
                        	.file "../fmtk/msg.asm",1
                        	MBX_OWNER			equ		0		; tid of owning task
                        	MBX_WTIDS			equ		4		; tasks waiting at mailbox
                        	MBX_MQHEAD		equ		8		
                        	MBX_MQTAIL		equ		12
                        	MBX_SIZE			equ		16
                        	
                        	MSG_LINK	equ		0
                        	MSG_D1		equ		4
                        	MSG_D2		equ		8
                        	MSG_D3		equ		12
                        	MSG_SIZE	equ		16
                        	
                        	;	bss
                        	;	align 4
                        	;FreeMsg	dw	0
                        	;msgs:
                        	;	fill.b	MSG_SIZE*1024,0
                        	;mbxs:
                        	;	fill.b	MBX_SIZE*32,0
                        	;mbxs_end:
                        	
                        	.file "../fmtk/msg.asm",23
                        		code
                        		align	4                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = task id of owner
                        	;		a2 = pointer where to store handle
                        	; Returns:
                        	;		v0 = E_Ok
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_AllocMbx:
FFFC1EE0 040A0E63		beq		$a2,$x0,.badArg
FFFC1EE4 00009D37		ldi		$t0,#mbxs
FFFC1EE8 800D0D13
                        	.nxt:
FFFC1EEC 000D4D83		lbu		$t1,MBX_OWNER[$t0]
FFFC1EF0 020D8063		beq		$t1,$x0,.noOwner
FFFC1EF4 010D0D13		add		$t0,$t0,#MBX_SIZE
FFFC1EF8 00009637		slt		$t1,$t0,#mbxs_end
FFFC1EFC A0060613
FFFC1F00 FE0D96E3		bne		$t1,$x0,.nxt
FFFC1F04 04006813		ldi		$v0,#E_NoMoreMbx
FFFC1F08 0608080D		mtu		$v0,$v0
FFFC1F0C 10000073		eret
                        	.noOwner:
FFFC1F10 013D0023		sb		$a1,MBX_OWNER[$t0]
FFFC1F14 FFFF8637		sub		$t5,$t0,#mbxs				; convert pointer to handle
FFFC1F18 80060613
FFFC1F1C 41A60FB3
FFFC1F20 004FDF93		srl		$t5,$t5,#4
FFFC1F24 000A6933		mov		$a0,$a2
FFFC1F28 9CCFF0EF		call	VirtToPhys
FFFC1F2C 01F82023		sw		$t5,[$v0]
FFFC1F30 00006813		ldi		$v0,#E_Ok
FFFC1F34 0608080D		mtu		$v0,$v0
FFFC1F38 10000073		eret
                        	.badArg:
FFFC1F3C 00106813		ldi		$v0,#E_Arg
FFFC1F40 0608080D		mtu		$v0,$v0
FFFC1F44 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_FreeMbx:
FFFC1F48 0209A213		slt		$s1,$a1,#32
FFFC1F4C 06020863		beq		$s1,$x0,.badMbx
FFFC1F50 00499213		sll		$s1,$a1,#4					; convert handle to pointer
FFFC1F54 00009637		add		$s1,$s1,#mbxs
FFFC1F58 80060613
FFFC1F5C 00460233
FFFC1F60 00006293		ldi		$s2,#0
FFFC1F64 01006393		ldi		$s4,#16							; possibly 16 tasks
FFFC1F68 00422483		lw		$s6,MBX_WTIDS[$s1]
                        	.0002:
FFFC1F6C 0014F313		and		$s3,$s6,#1
FFFC1F70 02030A63		beq		$s3,$x0,.0001
FFFC1F74 00A29413		sll		$s5,$s2,#10						; tid to pointer
FFFC1F78 28844803		lbu		$v0,TCBStatus[$s5]
FFFC1F7C FF787813		and		$v0,$v0,#~TS_WAITMSG	; no longer waiting
FFFC1F80 29040423		sb		$v0,TCBStatus[$s5]
FFFC1F84 01087813		and		$v0,$v0,#TS_TIMEOUT
FFFC1F88 00080663		beq		$v0,$x0,.0003
FFFC1F8C 0002E933		mov		$a0,$s2
FFFC1F90 3BC000EF		call	RemoveFromTimeoutList
                        	.0003:
FFFC1F94 0002E933		mov		$a0,$s2
FFFC1F98 250000EF		call	InsertTask
FFFC1F9C 00B06813		ldi		$v0,#E_NoMsg					; but no message
FFFC1FA0 05042023		sw		$v0,64[$s5]						; v0 = E_NoMsg
                        	.0001:
FFFC1FA4 0014D493		srl		$s6,$s6,#1
FFFC1FA8 00128293		add		$s2,$s2,#1
FFFC1FAC FC72E0E3		bltu	$s2,$s4,.0002
FFFC1FB0 00006813		ldi		$v0,#E_Ok
FFFC1FB4 0608080D		mtu		$v0,$v0
FFFC1FB8 10000073		eret
                        	.badMbx:
FFFC1FBC 00406813		ldi		$v0,#E_BadMbx				; return null pointer if bad mailbox
FFFC1FC0 0608080D		mtu		$v0,$v0
FFFC1FC4 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Send a message to a mailbox.
                        	; The message will be broadcast to any waiting tasks. Waiting tasks will then
                        	; be moved to the ready list. If there are no waiting tasks then the message
                        	; is queued at the mailbox.
                        	;
                        	; Register Usage:
                        	;		t0 = mailbox pointer
                        	;		t1 = message pointer
                        	;		s1 = task id of waiting task
                        	; Modifies:
                        	;		a0
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = message d1
                        	;		a3 = message d2
                        	;		a4 = message d3
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_SendMsg:
FFFC1FC8 0209AD13		slt		$t0,$a1,#32
FFFC1FCC 0C0D0E63		beq		$t0,$x0,.badMbx
FFFC1FD0 00499D13		sll		$t0,$a1,#4					; convert handle to pointer
FFFC1FD4 00009637		add		$t0,$t0,#mbxs
FFFC1FD8 80060613
FFFC1FDC 01A60D33
FFFC1FE0 004D2F83		lw		$t5,MBX_WTIDS[$t0]
FFFC1FE4 060F8063		beq		$t5,$x0,.noWaiters
FFFC1FE8 00006213		ldi		$s1,#0
                        	.0001:
FFFC1FEC 001FF313		and		$s3,$t5,#1					; is tid waiting?
FFFC1FF0 02030C63		beq		$s3,$x0,.nxtTid
FFFC1FF4 00A21313		sll		$s3,$s1,#10					; convert tid to TCB pointer
FFFC1FF8 29432C23		sw		$a2,TCBMsgD1[$s3]		; copy message to TCB
FFFC1FFC 2B532023		sw		$a3,TCBMsgD2[$s3]
FFFC2000 2B632423		sw		$a4,TCBMsgD3[$s3]
FFFC2004 28834E03		lbu		$t2,TCBStatus[$s3]
FFFC2008 004E6E13		or		$t2,$t2,#TS_MSGRDY
FFFC200C 29C30423		sb		$t2,TCBStatus[$s3]
FFFC2010 00026933		mov		$a0,$s1
FFFC2014 FFC70713		sub		$sp,$sp,#4
FFFC2018 01A72023		sw		$t0,[$sp]						; push t0
FFFC201C 1CC000EF		call	InsertTask
FFFC2020 00072D03		lw		$t0,[$sp]						; pop t0
FFFC2024 00470713		add		$sp,$sp,#4
                        	.nxtTid:
FFFC2028 001FDF93		srl		$t5,$t5,#1					; check next task
FFFC202C 00120213		add		$s1,$s1,#1
FFFC2030 00F27213		and		$s1,$s1,#15
FFFC2034 FA021CE3		bne		$s1,$x0,.0001
FFFC2038 000D2223		sw		$x0,MBX_WTIDS[$t0]	; clear waiters
FFFC203C 00006813		ldi		$v0,#E_Ok
FFFC2040 06000663		bra		.xit
                        	.noWaiters:
FFFC2044 00009637		lw		$t1,FreeMsg
FFFC2048 C0060613
FFFC204C 00060633
FFFC2050 00062D83
FFFC2054 040D8663		beq		$t1,$x0,.noMsg			; message available?
FFFC2058 000DAE03		lw		$t2,MSG_LINK[$t1]
FFFC205C 00009637		sw		$t2,FreeMsg
FFFC2060 C0060613
FFFC2064 00060633
FFFC2068 01C62023
FFFC206C 014DA223		sw		$a2,MSG_D1[$t1]
FFFC2070 015DA423		sw		$a3,MSG_D2[$t1]
FFFC2074 016DA623		sw		$a4,MSG_D3[$t1]
FFFC2078 00CD2E83		lw		$t3,MBX_MQTAIL[$t0]
FFFC207C 000E8A63		beq		$t3,$x0,.mbxEmpty
FFFC2080 01BEA023		sw		$t1,MSG_LINK[$t3]
FFFC2084 01BD2623		sw		$t1,MBX_MQTAIL[$t0]
FFFC2088 00006813		ldi		$v0,#E_Ok
FFFC208C 02000063		bra		.xit
                        	.mbxEmpty:
FFFC2090 01BD2423		sw		$t1,MBX_MQHEAD[$t0]
FFFC2094 01BD2623		sw		$t1,MBX_MQTAIL[$t0]
FFFC2098 00006813		ldi		$v0,#E_Ok
FFFC209C 00000863		bra		.xit
                        	.noMsg:
FFFC20A0 00B06813		ldi		$v0,#E_NoMsg
FFFC20A4 00000463		bra		.xit
                        	.badMbx:
FFFC20A8 00406813		ldi		$v0,#E_BadMbx				; return null pointer if bad mailbox
                        	.xit:
FFFC20AC 0608080D		mtu		$v0,$v0
FFFC20B0 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = pointer where to put message D1
                        	;		a3 = pointer where to put message D2
                        	;		a4 = pointer where to put message D3
                        	;		a5 = 1 = remove from queue
                        	;------------------------------------------------------------------------------
                        	
                        	PeekMsg:
FFFC20B4 FFC70713		sub		$sp,$sp,#4
FFFC20B8 00172023		sw		$ra,[$sp]
FFFC20BC 0209AD13		slt		$t0,$a1,#32
FFFC20C0 080D0C63		beq		$t0,$x0,.badMbx
FFFC20C4 00499E13		sll		$t2,$a1,#4					; convert handle to pointer
FFFC20C8 00009637		add		$t2,$t2,#mbxs
FFFC20CC 80060613
FFFC20D0 01C60E33
FFFC20D4 008E2D83		lw		$t1,MBX_MQHEAD[$t2]
FFFC20D8 060D8C63		beq		$t1,$x0,.noMsg
FFFC20DC 020B8863		beq		$a5,$x0,.nodq
FFFC20E0 000DAE83		lw		$t3,MSG_LINK[$t1]
FFFC20E4 01DE2423		sw		$t3,MBX_MQHEAD[$t2]
                        		; This is done here only because interrupts are disabled
FFFC20E8 00009637		lw		$t3,FreeMsg
FFFC20EC C0060613
FFFC20F0 00060633
FFFC20F4 00062E83
FFFC20F8 01DDA023		sw		$t3,MSG_LINK[$t1]
FFFC20FC 00009637		sw		$t1,FreeMsg
FFFC2100 C0060613
FFFC2104 00060633
FFFC2108 01B62023
                        	.nodq:
FFFC210C 000A0A63		beq		$a2,$x0,.nod1
FFFC2110 000A6933		mov		$a0,$a2
FFFC2114 FE1FE0EF		call	VirtToPhys
FFFC2118 004DAE83		lw		$t3,MSG_D1[$t1]
FFFC211C 01D82023		sw		$t3,[$v0]
                        	.nod1:
FFFC2120 000A8A63		beq		$a3,$x0,.nod2
FFFC2124 000AE933		mov		$a0,$a3
FFFC2128 FCDFE0EF		call	VirtToPhys
FFFC212C 008DAE83		lw		$t3,MSG_D2[$t1]
FFFC2130 01D82023		sw		$t3,[$v0]
                        	.nod2:
FFFC2134 000B0A63		beq		$a4,$x0,.nod3
FFFC2138 000B6933		mov		$a0,$a4
FFFC213C FB9FE0EF		call	VirtToPhys
FFFC2140 00CDAE83		lw		$t3,MSG_D3[$t1]
FFFC2144 01D82023		sw		$t3,[$v0]
                        	.nod3:
FFFC2148 00006813		ldi		$v0,#E_Ok
FFFC214C 00000863		bra		.ret
                        	.noMsg:
FFFC2150 00B06813		ldi		$v0,#E_NoMsg
FFFC2154 00000463		bra		.ret
                        	.badMbx:
FFFC2158 00406813		ldi		$v0,#E_BadMbx				; return null pointer if bad mailbox
                        	.ret:
FFFC215C 00072083		lw		$ra,[$sp]
FFFC2160 00470713		add		$sp,$sp,#4
FFFC2164 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; PeekMsg will check for a message at a mailbox optionally dequeuing it.
                        	; If no message is available PeekMsg returns to the caller with a E_NoMsg
                        	; status.
                        	;
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = pointer where to put message D1
                        	;		a3 = pointer where to put message D2
                        	;		a4 = pointer where to put message D3
                        	;		a5 = 1 = remove from queue
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_PeekMsg:
FFFC2168 F4DFF0EF		call	PeekMsg
FFFC216C 0608080D		mtu		$v0,$v0
FFFC2170 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Calling WaitMsg will cause the task to be queued at the mailbox and a task
                        	; switch to occur if there are no messages at the mailbox.
                        	;
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = pointer where to put message D1
                        	;		a3 = pointer where to put message D2
                        	;		a4 = pointer where to put message D3
                        	;		a5 = time limit
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_WaitMsg:
FFFC2174 000BE433		mov		s5,a5
FFFC2178 00106B93		ldi		a5,#1
FFFC217C F39FF0EF		call	PeekMsg							; check for a message, return if available
FFFC2180 00B06D93		ldi		$t1,#E_NoMsg
FFFC2184 01B80663		beq		$v0,$t1,.qt					; no message? Then go queue task
FFFC2188 0608080D		mtu		$v0,$v0
FFFC218C 10000073		eret
                        	.qt:
FFFC2190 DC0FF0EF		call	GetCurrentTid
FFFC2194 00106E13		ldi		$t2,#1
FFFC2198 010E1E13		sll		$t2,$t2,$v0
FFFC219C 00491E93		sll		$t3,$a0,#4					; convert handle to pointer
FFFC21A0 00009637		add		$t3,$t3,#mbxs
FFFC21A4 80060613
FFFC21A8 01D60EB3
FFFC21AC 004EAF03		lw		$t4,MBX_WTIDS[$t3]	; get waiting task list
FFFC21B0 01CF6F33		or		$t4,$t4,$t2					; set bit for tid
FFFC21B4 01EEA223		sw		$t4,MBX_WTIDS[$t3]	; save task list
FFFC21B8 00A81F13		sll		$t4,$v0,#10					; convert tid to TCB pointer
FFFC21BC 288F4E83		lbu		$t3,TCBStatus[$t4]
FFFC21C0 008EEE93		or		$t3,$t3,#TS_WAITMSG	; set waiting for message status
FFFC21C4 FFEEFE93		and		$t3,$t3,#~TS_READY	; not ready
FFFC21C8 29DF0423		sb		$t3,TCBStatus[$t4]
FFFC21CC 293F0523		sb		$a1,TCBWaitMbx[$t4]	; set mailbox task is waiting for
FFFC21D0 000B8863		beq		$a5,$x0,.noTimelimit
FFFC21D4 00086933		mov		$a0,$v0							; a0 = tid
FFFC21D8 000BE9B3		mov		$a1,$a5
FFFC21DC 0AC000EF		call	InsertIntoTimeoutList
                        	.noTimelimit:
                        		; Continue by switching tasks
FFFC21E0 00000637		jmp		FMTK_Reschedule
FFFC21E4 1C160067
                        	
                        	
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "../fmtk/tcb.asm",1
                        	.file "../fmtk/tcb.asm",1
                        	.file "../fmtk/tcb.asm",2
                        		code
                        		align	4                        	
                        	;------------------------------------------------------------------------------
                        	; Insert task into ready queue
                        	;
                        	; Parameters:
                        	;		a0 = tid to insert
                        	; Modifies:
                        	;		v1,t0,t1
                        	; Returns:
                        	;		v0 = 1 for success, 0 if failed
                        	;------------------------------------------------------------------------------
                        	
                        	InsertTask:
FFFC21E8 FFC70713		sub		$sp,$sp,#4
FFFC21EC 00172023		sw		$ra,[$sp]
FFFC21F0 00F06893		ldi		$v1,#MAX_TID
FFFC21F4 0728EE63		bgtu	$a0,$v1,.badTid
FFFC21F8 00A91D13		sll		$t0,$a0,#10					; compute TCB address
FFFC21FC 288D4883		lbu		$v1,TCBStatus[$t0]	; mark task as ready
FFFC2200 0018E893		or		$v1,$v1,#TS_READY
FFFC2204 291D0423		sb		$v1,TCBStatus[$t0]
FFFC2208 289D4883		lbu		$v1,TCBPriority[$t0]
FFFC220C 0038F893		and		$v1,$v1,#3
FFFC2210 00004637		lbu		$t0,HRDY0[$v1]
FFFC2214 30860613
FFFC2218 01160633
FFFC221C 00064D03
FFFC2220 00004637		lbu		$t1,TRDY0[$v1]			; increment tail pointer
FFFC2224 30C60613
FFFC2228 01160633
FFFC222C 00064D83
FFFC2230 001D8D93		add		$t1,$t1,#1
FFFC2234 05BD0263		beq		$t0,$t1,.qfull			; test queue full?
FFFC2238 00004637		sb		$t1,TRDY0[$v1]			; store it back
FFFC223C 30C60613
FFFC2240 01160633
FFFC2244 01B60023
FFFC2248 00889E93		sll		$t3,$v1,#8					; compute t3 = readyq index
FFFC224C 00004637		add		$t3,$t3,#RDYQ0
FFFC2250 40060613
FFFC2254 01D60EB3
FFFC2258 FFFD8D93		sub		$t1,$t1,#1					; back for store
FFFC225C 0FFDFD93		and		$t1,$t1,#255
FFFC2260 01DD8E33		add		$t2,$t1,$t3
FFFC2264 012E0023		sb		$a0,[$t2]						; store tid of task
FFFC2268 00006813		ldi		$v0,#E_Ok
FFFC226C 00000863		bra		.xit
                        	.badTid:
FFFC2270 00106813		ldi		$v0,#E_Arg
FFFC2274 00000463		bra		.xit
                        	.qfull:
FFFC2278 00506813		ldi		$v0,#E_QueFull
                        	.xit:
FFFC227C 00072083		lw		$ra,[$sp]
FFFC2280 00470713		add		$sp,$sp,#4
FFFC2284 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = task id to insert
                        	;		a1 = timeout value
                        	;------------------------------------------------------------------------------
                        	
                        	InsertIntoTimeoutList:
FFFC2288 00A91213		sll		$s1,$a0,#10				; tid to pointer
FFFC228C 00004637		lw		$t0,TimeoutList
FFFC2290 32860613
FFFC2294 00060633
FFFC2298 00062D03
FFFC229C 020D5663		bge		$t0,$x0,.0001
FFFC22A0 2F322023		sw		$a1,TCBTimeout[$s1]
FFFC22A4 00004637		sh		$a0,TimeoutList
FFFC22A8 32860613
FFFC22AC 00060633
FFFC22B0 01261023
FFFC22B4 FFF06D13		ldi		$t0,#-1
FFFC22B8 2DA21823		sh		$t0,TCBNext[$s1]
FFFC22BC 2DA21C23		sh		$t0,TCBPrev[$s1]
FFFC22C0 00006813		ldi		$v0,#E_Ok
FFFC22C4 00008067		ret
                        	.0001:
FFFC22C8 00006DB3		mov		$t1,$x0
FFFC22CC 00004637		lhu		$t2,TimeoutList
FFFC22D0 32860613
FFFC22D4 00060633
FFFC22D8 00065E03
FFFC22DC 00AE1E93		sll		$t3,$t2,#10
                        	.beginWhile:
FFFC22E0 2E0EAF03		lw		$t4,TCBTimeout[$t3]
FFFC22E4 013F5C63		ble		$a1,$t4,.endWhile
FFFC22E8 41E989B3		sub		$a1,$a1,$t4
FFFC22EC 000EEDB3		mov		$t1,$t3
FFFC22F0 2D0EDE83		lhu		$t3,TCBNext[$t3]
FFFC22F4 00AE9E93		sll		$t3,$t3,#10
FFFC22F8 FE0004E3		bra		.beginWhile
                        	.endWhile
FFFC22FC 00AEDE13		srl		$t2,$t3,#10
FFFC2300 2DC21823		sh		$t2,TCBNext[$s1]
FFFC2304 00ADDE13		srl		$t2,$t1,#10
FFFC2308 2DC21C23		sh		$t2,TCBPrev[$s1]
FFFC230C 2E0EAE03		lw		$t2,TCBTimeout[$t3]
FFFC2310 413E0E33		sub		$t2,$t2,$a1
FFFC2314 2FCEA023		sw		$t2,TCBTimeout[$t3]
FFFC2318 2D2E9C23		sh		$a0,TCBPrev[$t3]
FFFC231C 000D8663		beq		$t1,$x0,.0002
FFFC2320 2D2D9823		sh		$a0,TCBNext[$t1]
FFFC2324 00000A63		bra		.0003
                        	.0002:
FFFC2328 00004637		sh		$a0,TimeoutList
FFFC232C 32860613
FFFC2330 00060633
FFFC2334 01261023
                        	.0003:
FFFC2338 28824E03		lbu		$t2,TCBStatus[$s1]
FFFC233C 010E6E13		or		$t2,$t2,#TS_TIMEOUT
FFFC2340 29C20423		sb		$t2,TCBStatus[$s1]
FFFC2344 00006813		ldi		$v0,#E_Ok
FFFC2348 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	RemoveFromTimeoutList:
FFFC234C 00A91213		sll		$s1,$a0,#10					; tid to pointer
FFFC2350 2D025D03		lhu		$t0,TCBNext[$s1]
FFFC2354 020D4063		blt		$t0,$x0,.0001
FFFC2358 00AD1293		sll		$s2,$t0,#10
FFFC235C 2D825D83		lhu		$t1,TCBPrev[$s1]
FFFC2360 2DB29C23		sh		$t1,TCBPrev[$s2]
FFFC2364 2E02AD83		lw		$t1,TCBTimeout[$s2]
FFFC2368 2E022E03		lw		$t2,TCBTimeout[$s1]
FFFC236C 01CD8DB3		add		$t1,$t1,$t2
FFFC2370 2FB2A023		sw		$t1,TCBTimeout[$s2]
                        	.0001:
FFFC2374 2D825D03		lhu		$t0,TCBPrev[$s1]
FFFC2378 000D4863		blt		$t0,$x0,.0002
FFFC237C 00AD1293		sll		$s2,$t0,#10
FFFC2380 2D025D03		lhu		$t0,TCBNext[$s1]
FFFC2384 2DA29823		sh		$t0,TCBNext[$s2]
                        	.0002:
FFFC2388 28020423		sb		$x0,TCBStatus[$s1]	; status = TS_NONE
FFFC238C FFF06D13		ldi		$t0,#-1
FFFC2390 2DA21823		sh		$t0,TCBNext[$s1]
FFFC2394 2DA21C23		sh		$t0,TCBPrev[$s1]
FFFC2398 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Pop an entry off the timeout list.
                        	;
                        	; Modifies:
                        	;		v1,t0
                        	;	Returns:
                        			v0 = timeout list entry tid
                        	;------------------------------------------------------------------------------
                        	
                        	PopTimeoutList:
FFFC239C 00004637		lhu		$v0,TimeoutList
FFFC23A0 32860613
FFFC23A4 00060633
FFFC23A8 00065803
FFFC23AC 04084263		blt		$v0,$x0,.done
FFFC23B0 01006893		ldi		$v1,#NR_TCB
FFFC23B4 03187E63		bgeu	$v0,$v1,.done
FFFC23B8 00A81D13		sll		$t0,$v0,#10						; tid to pointer
FFFC23BC 288D4883		lbu		$v1,TCBStatus[$t0]		; no longer a waiting status
FFFC23C0 FE78F893		and		$v1,$v1,#~(TS_WAITMSG|TS_TIMEOUT)
	sb		$v1,TCBStatus[$t0]
FFFC23C4 291D0423
FFFC23C8 2D0D5883		lhu		$v1,TCBNext[$t0]
FFFC23CC 00004637		sh		$v1,TimeoutList
FFFC23D0 32860613
FFFC23D4 00060633
FFFC23D8 01161023
FFFC23DC 00084A63		blt		$v0,$x0,.done
FFFC23E0 01006893		ldi		$v1,#NR_TCB
FFFC23E4 01187663		bgeu	$v0,$v1,.done
FFFC23E8 FFF06893		ldi		$v1,#-1
FFFC23EC 2D1D1C23		sh		$v1,TCBPrev[$t0]
                        	.done:	
FFFC23F0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Diagnostics
                        	;------------------------------------------------------------------------------
                        	
                        	DumpReadyQueue:
FFFC23F4 FE470713		sub		$sp,$sp,#28
FFFC23F8 00172023		sw		$ra,[$sp]
FFFC23FC 01272223		sw		$a0,4[$sp]
FFFC2400 01472423		sw		$a2,8[$sp]
FFFC2404 01572623		sw		$a3,12[$sp]
FFFC2408 01B72823		sw		$t1,16[$sp]
FFFC240C 01C72A23		sw		$t2,20[$sp]
FFFC2410 01D72C23		sw		$t3,24[$sp]
FFFC2414 00006D93		ldi		$t1,#0
                        	.0002:
FFFC2418 00D06913		ldi		$a0,#CR
FFFC241C DD9FD0EF		call	Putch
FFFC2420 05106913		ldi		$a0,#'Q'
FFFC2424 DD1FD0EF		call	Putch
FFFC2428 000DE933		mov		$a0,$t1
FFFC242C A88FE0EF		call	PutHexNybble
FFFC2430 03A06913		ldi		$a0,#':'
FFFC2434 DC1FD0EF		call	Putch
FFFC2438 00004637		lbu		$a2,HRDY0[$t1]
FFFC243C 30860613
FFFC2440 01B60633
FFFC2444 00064A03
FFFC2448 00004637		lbu		$a3,TRDY0[$t1]
FFFC244C 30C60613
FFFC2450 01B60633
FFFC2454 00064A83
FFFC2458 035A0863		beq		$a2,$a3,.nxt
FFFC245C 008D9E13		sll		$t2,$t1,#8
FFFC2460 00004637		add		$t2,$t2,#RDYQ0
FFFC2464 40060613
FFFC2468 01C60E33
                        	.0001:
FFFC246C 014E0EB3		add		$t3,$t2,$a2
FFFC2470 000EC903		lbu		$a0,[$t3]
FFFC2474 A20FE0EF		call	PutHexByte
FFFC2478 02006913		ldi		$a0,#' '
FFFC247C D79FD0EF		call	Putch
FFFC2480 001A0A13		add		$a2,$a2,#1
FFFC2484 FF5A14E3		bne		$a2,$a3,.0001
                        	.nxt:
FFFC2488 001D8D93		add		$t1,$t1,#1
FFFC248C 004DAE13		slt		$t2,$t1,#4
FFFC2490 F80E14E3		bne		$t2,$x0,.0002
FFFC2494 00072083		lw		$ra,[$sp]
FFFC2498 00472903		lw		$a0,4[$sp]
FFFC249C 00872A03		lw		$a2,8[$sp]
FFFC24A0 00C72A83		lw		$a3,12[$sp]
FFFC24A4 01072D83		lw		$t1,16[$sp]
FFFC24A8 01472E03		lw		$t2,20[$sp]
FFFC24AC 01872E83		lw		$t3,24[$sp]
FFFC24B0 01C70713		add		$sp,$sp,#28
FFFC24B4 00008067		ret
                        	
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "../fmtk/iofocus.asm",1
                        	.file "../fmtk/iofocus.asm",1
                        	IOFocusNdx		EQU		$8C08
                        	IOFocusTbl		EQU		$8C10
                        	
                        	;-----------------------------------------------------------------------------
                        	; IO Focus routines complicated by the fact that the base address of TCB
                        	; zero is zero (looks like a null pointer but isn't). So the value -1 is 
                        	; used to indicate no focus index.
                        	;-----------------------------------------------------------------------------
                        	
                        	
                        	;-----------------------------------------------------------------------------
                        	; Determine if the currently running task has the I/O focus.
                        	;
                        	; Stack Space:
                        	;		2 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		v0 = E_Ok
                        	;		v1 = 1 if task has IO focus, 0 otherwise
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_HasIOFocus:
FFFC24B8 FFC70713		sub		$sp,$sp,#4
FFFC24BC 00172023		sw		$ra,[$sp]
FFFC24C0 A90FF0EF		call	GetCurrentTid
FFFC24C4 00A81813		sll		$v0,$v0,#10
FFFC24C8 00009637		lw		$v1,IOFocusNdx
FFFC24CC C0860613
FFFC24D0 00060633
FFFC24D4 00062883
FFFC24D8 01180663		beq		$v0,$v1,.hasFocus
FFFC24DC 00006893		ldi		$v1,#0
FFFC24E0 00000463		bra		.xit
                        	.hasFocus:
FFFC24E4 00106893		ldi		$v1,#1
                        	.xit:
FFFC24E8 00006813		ldi		$v0,#E_Ok
FFFC24EC 00072083		lw		$ra,[$sp]
FFFC24F0 00470713		add		$sp,$sp,#4
FFFC24F4 0608080D		mtu		$v0,$v0
FFFC24F8 0608888D		mtu		$v1,$v1
FFFC24FC 10000073		eret
                        	
                        	;-----------------------------------------------------------------------------
                        	; First check if it's even possible to switch the focus to another
                        	; task. The I/O focus list could be empty or there may be only a
                        	; single task in the list. In either case it's not possible to
                        	; switch.
                        	;
                        	; Stack Space:
                        	;		2 words
                        	;	Parameters:
                        	;		none
                        	;	Modifies:
                        	;		none
                        	;	Returns:
                        	;		v0 = E_Ok
                        	;-----------------------------------------------------------------------------
                        	
                        	SwitchIOFocusHelper:
FFFC2500 FF870713		sub		$sp,$sp,#8
FFFC2504 01A72023		sw		$t0,[$sp]
FFFC2508 01B72223		sw		$t1,4[$sp]
FFFC250C 00009637		lw		$t0,IOFocusNdx			; get focus pointer
FFFC2510 C0860613
FFFC2514 00060633
FFFC2518 00062D03
FFFC251C 001D0D13		add		$t0,$t0,#1					; is it -1?
FFFC2520 020D0063		beq		$t0,$x0,.noFocus		;
FFFC2524 FFFD0D13		sub		$t0,$t0,#1
FFFC2528 2E8D2D83		lw		$t1,IOF_NEXT[$t0]
FFFC252C 01AD8A63		beq		$t1,$t0,.sameFocus
                        		; swap virtual screens
                        		; set vidmem pointer
FFFC2530 00009637		sw		$t1,IOFocusNdx
FFFC2534 C0860613
FFFC2538 00060633
FFFC253C 01B62023
                        	.sameFocus:
                        	.noFocus:
FFFC2540 00006813		ldi		$v0,E_Ok
FFFC2544 00072D03		lw		$t0,[$sp]
FFFC2548 00472D83		lw		$t1,4[$sp]
FFFC254C 00870713		add		$sp,$sp,#8
FFFC2550 00008067		ret
                        	
                        	FMTK_SwitchIOFocus:
FFFC2554 FADFF0EF		call	SwitchIOFocusHelper
FFFC2558 0608080D		mtu		$v0,$v0
FFFC255C 10000073		eret
                        	
                        	;-----------------------------------------------------------------------------
                        	; The I/O focus list is an array indicating which jobs are requesting the
                        	; I/O focus. The I/O focus is user controlled by pressing ALT-TAB on the
                        	; keyboard.
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_RequestIOFocus:
FFFC2560 00106D13		ldi		$t0,#1
FFFC2564 013D1D13		sll		$t0,$t0,$a1
FFFC2568 00009637		lw		$t1,IOFocusTbl			; Is the task already included in the IO focus?
FFFC256C C1060613
FFFC2570 00060633
FFFC2574 00062D83
FFFC2578 01ADFE33		and		$t2,$t1,$t0
FFFC257C 060E1663		bne		$t2,$x0,.ret				; If so, don't add again
FFFC2580 01ADEDB3		or		$t1,$t1,$t0					; set bit indicator
FFFC2584 00009637		sw		$t1,IOFocusTbl
FFFC2588 C1060613
FFFC258C 00060633
FFFC2590 01B62023
FFFC2594 00009637		lw		$t0,IOFocusNdx			; get current index
FFFC2598 C0860613
FFFC259C 00060633
FFFC25A0 00062D03
FFFC25A4 00A99D93		sll		$t1,$a1,#10					; t1 = pointer to TCB
FFFC25A8 001D0D13		add		$t0,$t0,#1					; increment and see if it's zero (was -1)
FFFC25AC 020D1063		bne		$t0,$x0,.notEmpty		; is there one? (!= -1)
FFFC25B0 00009637		sw		$t1,IOFocusNdx			; no current index, so set equal to requester
FFFC25B4 C0860613
FFFC25B8 00060633
FFFC25BC 01B62023
FFFC25C0 2FBDA423		sw		$t1,IOF_NEXT[$t1]
FFFC25C4 2FBDA823		sw		$t1,IOF_PREV[$t1]
FFFC25C8 02000063		bra		.ret
                        	.notEmpty:
FFFC25CC FFFD0D13		sub		$t0,$t0,#1					; restore pointer value
FFFC25D0 2F0D2E03		lw		$t2,IOF_PREV[$t0]
FFFC25D4 2FCDA823		sw		$t2,IOF_PREV[$t1]
FFFC25D8 2FADA423		sw		$t0,IOF_NEXT[$t1]
FFFC25DC 2F0D2E03		lw		$t2,IOF_PREV[$t0]
FFFC25E0 2FBE2423		sw		$t1,IOF_NEXT[$t2]
FFFC25E4 2FBD2823		sw		$t1,IOF_PREV[$t0]
                        	.ret:
FFFC25E8 00006813		ldi		$v0,#E_Ok
FFFC25EC 0608080D		mtu		$v0,$v0
FFFC25F0 10000073		eret
                        	
                        	;-----------------------------------------------------------------------------
                        	; ReleaseIOFocus called when the task no longer desires to be on the I/O
                        	; focus list.
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_ReleaseIOFocus:
FFFC25F4 95CFF0EF		call	GetCurrentTid
FFFC25F8 000869B3		mov		a1,v0
                        		; fall into ForceReleaseIOFocus
                        	
                        	;-----------------------------------------------------------------------------
                        	; Releasing the I/O focus causes the focus to switch if the running job
                        	; had the I/O focus.
                        	; ForceReleaseIOFocus forces the release of the IO focus for a job
                        	; different than the one currently running.
                        	; 
                        	; Parameters:
                        	;		a1 = task id to release
                        	; Returns:
                        	;		v0 = E_Ok
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_ForceReleaseIOFocus:
FFFC25FC 00106D13		ldi		$t0,#1
FFFC2600 013D1D13		sll		$t0,$t0,$a1
FFFC2604 00009637		lw		$t1,IOFocusTbl
FFFC2608 C1060613
FFFC260C 00060633
FFFC2610 00062D83
FFFC2614 01ADFE33		and		$t2,$t1,$t0				; test bit for task
FFFC2618 080E0063		beq		$t2,$x0,.noFocus	; does it even have the focus?
FFFC261C FFFD4D13		xor		$t0,$t0,#-1				; get inverted mask
FFFC2620 01ADFDB3		and		$t1,$t1,$t0				; clear bit for task
FFFC2624 00009637		sw		$t1,IOFocusTbl
FFFC2628 C1060613
FFFC262C 00060633
FFFC2630 01B62023
FFFC2634 00009637		lw		$t1,IOFocusNdx		; check if the focus being released is the current
FFFC2638 C0860613
FFFC263C 00060633
FFFC2640 00062D83
FFFC2644 00A99D13		sll		$t0,$a1,#10				; io focus. If so, switch focus
FFFC2648 01BD1463		bne		$t0,$t1,.notSame
FFFC264C EB5FF0EF		call	SwitchIOFocusHelper
                        	.notSame:
FFFC2650 2E8D2E03		lw		$t2,IOF_NEXT[$t0]
FFFC2654 001E0E13		add		$t2,$t2,#1
FFFC2658 040E0063		beq		$t2,$x0,.done
FFFC265C FFFE0E13		sub		$t2,$t2,#1
FFFC2660 01AE0C63		beq		$t2,$t0,.pjSame
FFFC2664 2F0D2D83		lw		$t1,IOF_PREV[$t0]
FFFC2668 2FBE2823		sw		$t1,IOF_PREV[$t2]
FFFC266C 2F0D2D83		lw		$t1,IOF_PREV[$t0]
FFFC2670 2FCDA423		sw		$t2,IOF_NEXT[$t1]
FFFC2674 00000C63		bra		.0001
                        	.pjSame:
FFFC2678 FFF06D93		ldi		$t1,#-1
FFFC267C 00009637		sw		$t1,IOFocusNdx
FFFC2680 C0860613
FFFC2684 00060633
FFFC2688 01B62023
                        	.0001:
FFFC268C FFF06D93		ldi		$t1,#-1
FFFC2690 2FBD2423		sw		$t1,IOF_NEXT[$t0]	
FFFC2694 2FBD2823		sw		$t1,IOF_PREV[$t0]	
                        	.done:
                        	.noFocus:
FFFC2698 00006813		ldi		$v0,#E_Ok
FFFC269C 0608080D		mtu		$v0,$v0
FFFC26A0 10000073		eret
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "../fmtk/io.asm",1
                        	.file "../fmtk/io.asm",1
                        	;Standard Devices are:
                        	
                        	;#		Device					Standard name
                        	
                        	;0		NULL device 			NUL		(OS built-in)
                        	;1		Keyboard (sequential)	KBD		(OS built-in)
                        	;2		Video (sequential)		VID		(OS built-in)
                        	;3		Printer (parallel 1)	LPT
                        	;4		Printer (parallel 2)	LPT2
                        	;5		RS-232 1				COM1	(OS built-in)
                        	;6		RS-232 2				COM2
                        	;7		RS-232 3				COM3
                        	;8		RS-232 4				COM4
                        	;9		Parallel xfer	  PTI
                        	;10		Floppy					FD0
                        	;11		Floppy					FD1
                        	;12		Hard disk				HD0
                        	;13		Hard disk				HD1
                        	;14
                        	;15   VIA							VIA1
                        	;16		SDCard					CARD1 	(OS built-in)
                        	;17
                        	;18
                        	;19
                        	;20
                        	;21
                        	;22
                        	;23
                        	;24
                        	;25
                        	;26
                        	;27
                        	;28		Audio						PSG1	(OS built-in)
                        	;29
                        	;30   Random Number		PRNG
                        	;31		Debug						DBG
                        	
                        	DVF_Base		EQU		$A000
                        	DVF_Limit		EQU		$B000
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a2 = function
                        	;		a3 = data
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_IO:
FFFC26A4 00799813		sll		$v0,$a1,#7					; each device allowed 32 functions (*128)
FFFC26A8 002A1893		sll		$v1,$a2,#2					; function number *4
FFFC26AC 0000A637		add		$v0,$v0,#DVF_Base		; base address of function table
FFFC26B0 00060613
FFFC26B4 01060833
FFFC26B8 01186833		or		$v0,$v0,$v1
FFFC26BC 00082803		lw		$v0,[$v0]
FFFC26C0 00080A63		beq		$v0,$x0,.badFunc
FFFC26C4 000800E7		call	[$v0]
                        	.xit:
FFFC26C8 0608080D		mtu		$v0,$v0
FFFC26CC 0608888D		mtu		$v1,$v1
FFFC26D0 10000073		eret
                        	.badFunc:
FFFC26D4 02206813		ldi		$v0,#E_BadDevOp
FFFC26D8 FE0008E3		bra		.xit
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = I/O channel
                        	;		a1 = points to function table
                        	;------------------------------------------------------------------------------
                        	
                        	CopyDevFuncTbl:
FFFC26DC 00791813		sll		$v0,$a0,#7					; each device allowed 32 functions (*128)
FFFC26E0 0000A637		add		$v0,$v0,#DVF_Base		; base address of function table
FFFC26E4 00060613
FFFC26E8 01060833
FFFC26EC 02006D13		ldi		$t0,#32							; 32 functions to copy
                        	.again:
FFFC26F0 0009AE03		lw		$t2,[$a1]
FFFC26F4 01C82023		sw		$t2,[$v0]
FFFC26F8 00498993		add		$a1,$a1,#4
FFFC26FC 00480813		add		$v0,$v0,#4
FFFC2700 FFFD0D13		sub		$t0,$t0,#1
FFFC2704 FFA046E3		bgt		$t0,$x0,.again
FFFC2708 00008067		ret
                        	
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "TinyBasic.asm",1
                        	.file "TinyBasic.asm",1
                        	;****************************************************************;
                        	;                                                                ;
                        	;		Tiny BASIC for the CS01                                      ;
                        	;                                                                ;
                        	; Derived from a 68000 derivative of Palo Alto Tiny BASIC as     ;
                        	; published in the May 1976 issue of Dr. Dobb's Journal.         ;
                        	; Adapted to the 68000 by:                                       ;
                        	;	Gordon brndly						                         ;
                        	;	12147 - 51 Street					                         ;
                        	;	Edmonton AB  T5W 3G8					                     ;
                        	;	Canada							                             ;
                        	;	(updated mailing address for 1996)			                 ;
                        	;                                                                ;
                        	; Adapted to the CS01 by:                                        ;
                        	;    Robert Finch                                                ;
                        	;    Ontario, Canada                                             ;
                        	;	 robfinch<remove>@finitron.ca    	                             ;  
                        	;****************************************************************;
                        	;  Copyright (C) 2016-2020 by Robert Finch. This program may be	 ;
                        	;    freely distributed for personal use only. All commercial	 ;
                        	;		       rights are reserved.			                     ;
                        	;****************************************************************;
                        	;
                        	; Register Usage
                        	; $t2 = text pointer (global usage)
                        	; r3,r4 = inputs parameters to subroutines
                        	; a1 = return value
                        	;
                        	;* Vers. 1.0  1984/7/17	- Original version by Gordon brndly
                        	;*	1.1  1984/12/9	- Addition of '0x' print term by Marvin Lipford
                        	;*	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                        	
                        	CR		EQU	0x0D		;ASCII equates
                        	LINEFD	EQU	0x0A		; Don't use LF (same as load float instruction)
                        	TAB		EQU	0x09
                        	CTRLC	EQU	0x03
                        	CTRLH	EQU	0x08
                        	CTRLI	EQU	0x09
                        	CTRLJ	EQU	0x0A
                        	CTRLK	EQU	0x0B
                        	CTRLM   EQU 0x0D
                        	CTRLS	EQU	0x13
                        	CTRLX	EQU	0x18
                        	XON		EQU	0x11
                        	XOFF	EQU	0x13
                        	
                        	FILENAME	EQU		0x6C0
                        	FILEBUF		EQU		0x07F600
                        	OSSP		EQU		0x700
                        	TXTUNF		EQU		OSSP+4
                        	VARBGN		EQU		TXTUNF+4
                        	VAREND		EQU		VARBGN+4
                        	LOPVAR		EQU		VAREND+4
                        	STKGOS		EQU		LOPVAR+4
                        	CURRNT		EQU		STKGOS+4
                        	BUFFER		EQU		CURRNT+4
                        	BUFLEN		EQU		84
                        	LOPPT		EQU		BUFFER+84
                        	LOPLN		EQU		LOPPT+4
                        	LOPINC		EQU		LOPLN+4
                        	LOPLMT		EQU		LOPINC+4
                        	NUMWKA		EQU		LOPLMT+24
                        	STKINP		EQU		NUMWKA+4
                        	STKBOT		EQU		STKINP+4
                        	usrJmp		EQU		STKBOT+4
                        	IRQROUT		EQU		usrJmp+4
                        	
                        	OUTPTR		EQU		IRQROUT+4
                        	INPPTR		EQU		OUTPTR+4
                        	CursorFlash	EQU		INPPTR+4
                        	IRQFlag		EQU		CursorFlash+4
                        	
                        	;
                        	; Modifiable system constants:
                        	;
                        	;THRD_AREA	dw	0x04000000	; threading switch area 0x04000000-0x40FFFFF
                        	;bitmap dw	0x00100000	; bitmap graphics memory 0x04100000-0x417FFFF
                        	TXTBGN		EQU		0x001800	;TXT ;beginning of program memory
                        	ENDMEM		EQU		0x008000	; end of available memory
                        	STACKOFFS	EQU		0x07FFFC	; stack offset
                        	
                        	
                        	.file "TinyBasic.asm",84
                        			code
FFFC270C 00000000			align	25
FFFC2710 00000000
FFFC2714 00000000
FFFC2718 00000000
FFFC271C 00000000
FFFC2720 00000000
FFFC2724 00000000
FFFC2728 00000000
FFFC272C 00000000
FFFC2730 00000000
FFFC2734 00000000
FFFC2738 00000000
FFFC273C 00000000
FFFC2740 00000000
FFFC2744 00000000
FFFC2748 00000000
FFFC274C 00000000
FFFC2750 00000000
FFFC2754 00000000
FFFC2758 00000000
FFFC275C 00000000
FFFC2760 00000000
FFFC2764 00000000
FFFC2768 00000000
FFFC276C 00000000
FFFC2770 00000000
FFFC2774 00000000
FFFC2778 00000000
FFFC277C 00000000
FFFC2780 00000000
FFFC2784 00000000
FFFC2788 00000000
FFFC278C 00000000
FFFC2790 00000000
FFFC2794 00000000
FFFC2798 00000000
FFFC279C 00000000
FFFC27A0 00000000
FFFC27A4 00000000
FFFC27A8 00000000
FFFC27AC 00000000
FFFC27B0 00000000
FFFC27B4 00000000
FFFC27B8 00000000
FFFC27BC 00000000
FFFC27C0 00000000
FFFC27C4 00000000
FFFC27C8 00000000
FFFC27CC 00000000
FFFC27D0 00000000
FFFC27D4 00000000
FFFC27D8 00000000
FFFC27DC 00000000
FFFC27E0 00000000
FFFC27E4 00000000
FFFC27E8 00000000
FFFC27EC 00000000
FFFC27F0 00000000
FFFC27F4 00000000
FFFC27F8 00000000
FFFC27FC 00000000
                        	
                        	;
                        	; Standard jump table. You can change these addresses if you are
                        	; customizing this interpreter for a different environment.
                        	;
                        	TinyBasic:
                        	GOSTART:	
FFFC2800 0300006F			jmp	CSTART	;	Cold Start entry point
                        	GOWARM:	
FFFC2804 0BC0006F			jmp	WSTART	;	Warm Start entry point
                        	GOOUT:	
FFFC2808 5590106F			jmp	OUTC	;	Jump to character-out routine
                        	GOIN:	
FFFC280C 5590106F			jmp	INCH	;Jump to character-in routine
                        	GOAUXO:	
FFFC2810 00000637			jmp	AUXOUT	;	Jump to auxiliary-out routine
FFFC2814 21260067
                        	GOAUXI:	
FFFC2818 00000637			jmp	AUXIN	;	Jump to auxiliary-in routine
FFFC281C 21460067
                        	GOBYE:	
FFFC2820 5750106F			jmp	BYEBYE	;	Jump to monitor, DOS, etc.
                        	
FFFC2824 00000000		align	1
FFFC2828 00000000
FFFC282C 00000000
                        	
                        	//message "CSTART"
                        	public CSTART:
	; First save off the link register and OS sp value
FFFC2830 70E02023		sw		$sp,OSSP
FFFC2834 00080737		ldi		$sp,#STACKOFFS	; initialize stack pointer
FFFC2838 FFC70713
FFFC283C 00E06913		ldi		$a0,#14							; Get current tid
FFFC2840 00000073		ecall
FFFC2844 0008E9B3		mov		$a1,$v1
FFFC2848 01806913		ldi		$a0,#24							; RequestIOFocus
FFFC284C 00000073		ecall
                        	;	call	_DBGHomeCursor[pc]
FFFC2850 00006933		mov		a0,r0			; turn off keyboard echoing
                        	//	call	SetKeyboardEcho
                        	//	stz		CursorFlash
                        	//	ldx		#0x10000020	; black chars, yellow background
                        	;	stx		charToPrint
                        	;	call	_DBGClearScreen[pc]
FFFC2854 FFFC4937		ldi		a0,#msgInit	;	tell who we are
FFFC2858 59C90913
FFFC285C 309010EF		call	PRMESG
FFFC2860 00002937		ldi		a0,#TXTBGN	;	init. end-of-program pointer
FFFC2864 80090913
FFFC2868 71202223		sw		a0,TXTUNF
FFFC286C 00008937		ldi		a0,#ENDMEM	;	get address of end of memory
FFFC2870 00090913
FFFC2874 00080937		ldi		a0,#$7F800
FFFC2878 80090913
FFFC287C 79202E23		sw		a0,STKBOT
FFFC2880 00008937		ldi		a0,#ENDMEM
FFFC2884 00090913
FFFC2888 71202623		sw		a0,VAREND
FFFC288C CE090913		sub		a0,a0,#800 	;   100 vars
FFFC2890 71202423		sw    a0,VARBGN
FFFC2894 47C000EF		call  clearVars   ; clear the variable area
FFFC2898 7A002223		sw		r0,IRQROUT
FFFC289C 70802903		lw    a0,VARBGN   ; calculate number of bytes free
FFFC28A0 70402983		lw		a1,TXTUNF
FFFC28A4 41390933		sub   a0,a0,a1
FFFC28A8 00606993		ldi		a1,#6		; max 6 digits
FFFC28AC 00A06A13		ldi		a2,#10	; base 10
FFFC28B0 7E4010EF		call  PRTNUM
FFFC28B4 FFFC4937		ldi		a0,#msgBytesFree
FFFC28B8 63D90913
FFFC28BC 2A9010EF		call	PRMESG
                        	WSTART:
FFFC28C0 70002823		sw		x0,LOPVAR   ; initialize internal variables
FFFC28C4 70002A23		sw		x0,STKGOS
FFFC28C8 70002C23		sw		x0,CURRNT	;	current line number pointer = 0
FFFC28CC 00080737		ldi		$sp,#STACKOFFS	;	init S.P. again, just in case
FFFC28D0 FFC70713
FFFC28D4 FFFC4937		ldi		a0,#msgReady	;	display "Ready"
FFFC28D8 64A90913
FFFC28DC 289010EF		call	PRMESG
                        	BASPRMPT:
FFFC28E0 00E06913		ldi		a0,#14		; get current tid
FFFC28E4 00000073		ecall
FFFC28E8 0008E933		mov		a0,v1
FFFC28EC DA9FD0EF		call	PutHexByte
FFFC28F0 03E06913		ldi		a0,#'>'		; Prompt with a '>' and
FFFC28F4 470010EF		call	GETLN		; read a line.
FFFC28F8 1BD010EF		call	TOUPBUF 	; convert to upper case
FFFC28FC 000E64B3		mov		$s6,$t2		; save pointer to end of line
FFFC2900 71C06E13		ldi		$t2,#BUFFER	; point to the beginning of line
FFFC2904 10D010EF		call	TSTNUM		; is there a number there?
FFFC2908 17D010EF		call	IGNBLK		; skip trailing blanks
FFFC290C 000E4483		lbu		$s6,[$t2]
FFFC2910 00D4C493		xor		$s6,$s6,#CR	; s6 = flag empty line
                        	; does line no. exist? (or nonzero?)
FFFC2914 28088663		beq		v1,x0,DIRECT		; if not, it's a direct statement
FFFC2918 00100DB7		ldi		$t1,#$FFFFF
FFFC291C FFFD8D93
FFFC2920 010DD863		ble		v0,$t1,ST2	; see if line no. is <= 16 bits
FFFC2924 FFFC4937		ldi		a0,#msgLineRange	; if not, we've overflowed
FFFC2928 66590913
FFFC292C 3F40106F		jmp		ERROR
                        	ST2:
FFFC2930 00086933	  mov		$a0,$v0		; a0 = line number
FFFC2934 000E6433	  mov		$s5,$t2			; save line buffer pointer
FFFC2938 FFCE0E13		sub		$t2,$t2,#4
FFFC293C 012E2023	  sw		$a0,[$t2]		;	This will end up in buffer
FFFC2940 518010EF		call	FNDLN		; find this line in save area
FFFC2944 000EE533		mov		$s7,$t3		; save possible line pointer
FFFC2948 00080663		beq		$v0,$x0,INSLINE	; if not found, insert
FFFC294C 000EE933		mov		$a0,$t3
FFFC2950 044000EF		call	DeleteLine
                        	INSLINE:
FFFC2954 F80486E3		beq		$s6,$x0,BASPRMPT	; line was empty
FFFC2958 00046933		mov		$a0,$s5			; a0 = buffer pointer	
                        		; GetBuflen just get the length of the text.
                        		; A line number is stuffed just before the text
                        		; so length needs to be adjusted by 4.
FFFC295C 0A0000EF		call	GetBuflen
FFFC2960 00480393		add		$s4,$v0,#4
FFFC2964 00056933		mov		$a0,$s7
FFFC2968 0003E9B3		mov		$a1,$s4
FFFC296C 0BC000EF		call	OpenSpace
FFFC2970 00081863		bne		$v0,$x0,.0001	; space available?
FFFC2974 FFFC4937		ldi		a0,#msgTooBig	; no space available
FFFC2978 73790913
FFFC297C 3A40106F		jmp		ERROR
                        	.0001:
FFFC2980 00056933		mov		$a0,$s7			; target
FFFC2984 FFC40993		sub		$a1,$s5,#4	; source (incl lineno)
FFFC2988 0003EA33		mov		$a2,$s4			; length
FFFC298C 050000EF		call	InsertLine
FFFC2990 F40008E3		bra		BASPRMPT
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = pointer to line to delete
                        	; Modifies:
                        	;		t0,t1,t2,t3
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	DeleteLine:
                        		; Find the end of the line to delete
FFFC2994 00490D13		add		$t0,$a0,#4		; t0 = pointer to line past line number
FFFC2998 00D06E13		ldi		$t2,#CR
FFFC299C 70402E83		lw		$t3,TXTUNF		; last text address
                        	.0002:
FFFC29A0 000D4D83		lbu		$t1,[$t0]
FFFC29A4 000D8A63		beq		$t1,$x0,.0003	; might be null
FFFC29A8 01CD8663		beq		$t1,$t2,.0001	; lines end with CR
FFFC29AC 001D0D13		add		$t0,$t0,#1
FFFC29B0 FFDD68E3		bltu	$t0,$t3,.0002	; end of program?
                        	.0001:
FFFC29B4 001D0D13		add		$t0,$t0,#1
                        	.0003:
                        		; pull text after eol overtop
FFFC29B8 000D4F03		lbu		$t4,[$t0]			; copy from next line
FFFC29BC 01E90023		sb		$t4,[$a0]			; overtop deleted line
FFFC29C0 001D0D13		add		$t0,$t0,#1		; increment pointers
FFFC29C4 00190913		add		$a0,$a0,#1
FFFC29C8 FFAEF8E3		bleu	$t0,$t3,.0003	; to end of program
                        		; update end of text
FFFC29CC 412D0933		sub		$a0,$t0,$a0		; difference of pointers = length
FFFC29D0 412E8EB3		sub		$t3,$t3,$a0		
FFFC29D4 71D02223		sw		$t3,TXTUNF
FFFC29D8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = insertion point
                        	; 	a1 = source buffer
                        	; 	a2 = length
                        	; Modifies:
                        	;		a0,a1,a2,t1
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	InsertLine:
FFFC29DC 000A0E63		beq		$a2,$x0,.done		; zero length? Probably a SW error
                        	.0001:
FFFC29E0 0009CD83		lbu		$t1,[$a1]				; get from source text
FFFC29E4 01B90023		sb		$t1,[$a0]				; store to insertion point
FFFC29E8 00198993		add		$a1,$a1,#1			; increment pointers
FFFC29EC 00190913		add		$a0,$a0,#1
FFFC29F0 FFFA0A13		sub		$a2,$a2,#1			; decrement length
FFFC29F4 FF4066E3		bgtu	$a2,$x0,.0001
                        	.done:
FFFC29F8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; GetBuflen - get the length of text in a buffer. The length is taken up to
                        	; the first null character or carriage return character encountered.
                        	;
                        	; Parameters:
                        	;		a0 = pointer to buffer
                        	; Modifies:
                        	;		t2,t3,t5
                        	; Returns:
                        	;		v0 = length of data in buffer
                        	;------------------------------------------------------------------------------
                        	
                        	GetBuflen:
FFFC29FC 00006813		ldi		$v0,#0
FFFC2A00 00D06E93		ldi		$t3,#CR
FFFC2A04 00096FB3		mov		$t5,$a0
                        	.0002:
FFFC2A08 000FCE03		lbu		$t2,[$t5]
FFFC2A0C 001F8F93		add		$t5,$t5,#1
FFFC2A10 000E0A63		beq		$t2,$x0,.0001
FFFC2A14 01DE0663		beq		$t2,$t3,.0004
FFFC2A18 00180813		add		$v0,$v0,#1
FFFC2A1C FE0006E3		bra		.0002
                        	.0004:
FFFC2A20 00180813		add		$v0,$v0,#1
                        	.0001:
FFFC2A24 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = place to insert line
                        	; 	a1 = buffer length
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		v0 = 1 if successful, 0 if not enough room available
                        	;------------------------------------------------------------------------------
                        	
                        	OpenSpace:
FFFC2A28 70402E03		lw		$t2,TXTUNF
FFFC2A2C 000E6EB3		mov		$t3,$t2				; t3 = old end of text
FFFC2A30 013E0E33		add		$t2,$t2,$a1		; increment end of text by buffer length
FFFC2A34 70802D83		lw		$t1,VARBGN		; compare to start of variables
FFFC2A38 03BE7263		bgeu	$t2,$t1,.noSpace	; enough room?
FFFC2A3C 71C02223		sw		$t2,TXTUNF		; yes, set new end of text
                        	.0003:
FFFC2A40 000ECF83		lbu		$t5,[$t3]			; copy old text
FFFC2A44 01FE0023		sb		$t5,[$t2]			; to new text loc
FFFC2A48 FFFE8E93		sub		$t3,$t3,#1		; decrement pointers
FFFC2A4C FFFE0E13		sub		$t2,$t2,#1
FFFC2A50 FF2EF8E3		bgeu	$t3,$a0,.0003	; until insert point reached
FFFC2A54 00106813		ldi		$v0,#1				; return success
FFFC2A58 00008067		ret
                        	.noSpace:
FFFC2A5C 00006813		ldi		$v0,#0
FFFC2A60 00008067		ret	
                        	
                        	;******************************************************************
                        	;
                        	; *** Tables *** DIRECT *** EXEC ***
                        	;
                        	; This section of the code tests a string against a table. When
                        	; a match is found, control is transferred to the section of
                        	; code according to the table.
                        	;
                        	; At 'EXEC', r8 should point to the string, r9 should point to
                        	; the character table, and r10 should point to the execution
                        	; table. At 'DIRECT', r8 should point to the string, r9 and
                        	; r10 will be set up to point to TAB1 and TAB1_1, which are
                        	; the tables of all direct and statement commands.
                        	;
                        	; A '.' in the string will terminate the test and the partial
                        	; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                        	; 'PRIN.', or 'PRINT' will all match 'PRINT'.
                        	;
                        	; There are two tables: the character table and the execution
                        	; table. The character table consists of any number of text items.
                        	; Each item is a string of characters with the last character's
                        	; high bit set to one. The execution table holds a 32-bit
                        	; execution addresses that correspond to each entry in the
                        	; character table.
                        	;
                        	; The end of the character table is a 0 byte which corresponds
                        	; to the default routine in the execution table, which is
                        	; executed if none of the other table items are matched.
                        	;
                        	; Character-matching tables:
                        	TAB1:
FFFC2A64 D453494C		db	"LIS",'T'+0x80        ; Direct commands
FFFC2A68 C4414F4C		db	"LOA",'D'+0x80
FFFC2A6C 52D7454E		db	"NE",'W'+0x80
FFFC2A6F 53CE5552		db	"RU",'N'+0x80
FFFC2A72 C5564153		db	"SAV",'E'+0x80
                        	TAB2:
FFFC2A76 D458454E		db	"NEX",'T'+0x80         ; Direct / statement
FFFC2A7A 49D4454C		db	"LE",'T'+0x80
FFFC2A7D 4F47C649		db	"I",'F'+0x80
FFFC2A7F CF544F47		db	"GOT",'O'+0x80
FFFC2A83 55534F47		db	"GOSU",'B'+0x80
FFFC2A87 544552C2
FFFC2A88 55544552		db	"RETUR",'N'+0x80
FFFC2A8C 4552CE52
FFFC2A8E 46CD4552		db	"RE",'M'+0x80
FFFC2A91 49D24F46		db	"FO",'R'+0x80
FFFC2A94 55504E49		db	"INPU",'T'+0x80
FFFC2A98 495250D4
FFFC2A99 4E495250		db	"PRIN",'T'+0x80
FFFC2A9D 4B4F50D4
FFFC2A9E C54B4F50		db	"POK",'E'+0x80
FFFC2AA2 454B4F50		db	"POKE",'W'+0x80
FFFC2AA6 4B4F50D7
FFFC2AA7 454B4F50		db	"POKE",'H'+0x80
FFFC2AAB 454959C8
FFFC2AAC 4C454959		db	"YIEL",'D'+0x80
FFFC2AB0 4F5453C4
FFFC2AB1 D04F5453		db	"STO",'P'+0x80
FFFC2AB5 53C55942		db	"BY",'E'+0x80
FFFC2AB8 43D35953		db	"SY",'S'+0x80
FFFC2ABB 43D34C43		db	"CL",'S'+0x80
FFFC2ABE 52D24C43	    db  "CL",'R'+0x80
FFFC2AC1 C6434452	    db	"RDC",'F'+0x80
FFFC2AC5 52494E4F	    db	"ONIR",'Q'+0x80
FFFC2AC9 494157D1
FFFC2ACA D4494157	    db	"WAI",'T'+0x80
FFFC2ACE 45455000		db	0
                        	TAB4:
FFFC2ACF CB454550		db	"PEE",'K'+0x80         ;Functions
FFFC2AD3 4B454550		db	"PEEK",'W'+0x80
FFFC2AD7 454550D7
FFFC2AD8 4B454550		db	"PEEK",'H'+0x80
FFFC2ADC C44E52C8
FFFC2ADD 41C44E52		db	"RN",'D'+0x80
FFFC2AE0 53D34241		db	"AB",'S'+0x80
FFFC2AE3 54CE4753		db  "SG",'N'+0x80
FFFC2AE6 CB434954		db	"TIC",'K'+0x80
FFFC2AEA C55A4953		db	"SIZ",'E'+0x80
FFFC2AEE 41D25355		db  "US",'R'+0x80
FFFC2AF1 4F4C4C41	  db	"ALLOCMB",'X'+0x80
FFFC2AF5 D8424D43
FFFC2AF9 444E4553	  db	"SENDMS",'G'+0x80
FFFC2AFD 57C7534D
FFFC2B00 54494157	  db	"WAITMS",'G'+0x80
FFFC2B04 00C7534D
FFFC2B07 00CF5400		db	0
                        	TAB5:
FFFC2B08 5300CF54		db	"T",'O'+0x80           ;"TO" in "FOR"
FFFC2B0A 45545300		db	0
                        	TAB6:
FFFC2B0B D0455453		db	"STE",'P'+0x80         ;"STEP" in "FOR"
FFFC2B0F 3CBD3E00		db	0
                        	TAB8:
FFFC2B10 BE3CBD3E		db	'>','='+0x80           ;Relational operators
FFFC2B12 BDBEBE3C		db	'<','>'+0x80
FFFC2B14 BD3CBDBE		db	'>'+0x80
FFFC2B15 BCBD3CBD		db	'='+0x80
FFFC2B16 00BCBD3C		db	'<','='+0x80
FFFC2B18 4E4100BC		db	'<'+0x80
FFFC2B19 C44E4100		db	0
                        	TAB9:
FFFC2B1A 00C44E41	    db  "AN",'D'+0x80
FFFC2B1D 00D24F00	    db  0
                        	TAB10:
FFFC2B1E 0000D24F	    db  "O",'R'+0x80
FFFC2B20 2D800000	    db  0
                        	
                        	;* Execution address tables:
                        	; We save some bytes by specifiying only the low order 16 bits of the address
                        	;
FFFC2B21 482D8000		align	
                        	
                        	TAB1_1:
FFFC2B22 32482D80		dh	LISTX			;Direct commands
FFFC2B24 2C283248		dh	LOAD3
FFFC2B26 2C502C28		dh	NEW
FFFC2B28 32B02C50		dh	RUN
FFFC2B2A 2F7C32B0		dh	SAVE3
                        	TAB2_1:
FFFC2B2C 31002F7C		dh	NEXT		;	Direct / statement
FFFC2B2E 2FF43100		dh	LET
FFFC2B30 2CE42FF4		dh	IF0
FFFC2B32 2E682CE4		dh	GOTO
FFFC2B34 2EAC2E68		dh	GOSUB
FFFC2B36 30002EAC		dh	RETURN
FFFC2B38 2EF03000		dh	IF2			; REM
FFFC2B3A 30342EF0		dh	FOR
FFFC2B3C 2DC83034		dh	INPUT
FFFC2B3E 340C2DC8		dh	PRINT
FFFC2B40 3438340C		dh	POKE
FFFC2B42 34643438		dh	POKEW
FFFC2B44 2C443464		dh	POKEH
FFFC2B46 2C3C2C44		dh	YIELD0
FFFC2B48 28202C3C		dh	STOP
FFFC2B4A 349C2820		dh	GOBYE
FFFC2B4C 0257349C		dh	SYSX
FFFC2B4E 2D080257		dh	_cls
FFFC2B50 02592D08		dh  _clr
FFFC2B52 2D480259		dh	_rdcf
FFFC2B54 2D702D48		dh  ONIRQ
FFFC2B56 30F42D70		dh	WAITIRQ
FFFC2B58 3AB830F4		dh	DEFLT
                        	TAB4_1:
FFFC2B5A 3AD03AB8		dh	PEEK			;Functions
FFFC2B5C 3AE83AD0		dh	PEEKW
FFFC2B5E 3B403AE8		dh	PEEKH
FFFC2B60 00003B40		dh	RND
FFFC2B62 3BD40000		dh	ABS
FFFC2B64 3BC03BD4		dh  SGN
FFFC2B66 3C103BC0		dh	TICKX
FFFC2B68 3B003C10		dh	SIZEX
FFFC2B6A 437C3B00		dh  USRX
FFFC2B6C 43EC437C		dh	ALLOCMBX
FFFC2B6E 448843EC		dh	SENDMSG
FFFC2B70 38944488		dh	WAITMSG
FFFC2B72 2F103894		dh	XP40
                        	TAB5_1
FFFC2B74 3D182F10		dh	FR1			;"TO" in "FOR"
FFFC2B76 2F2C3D18		dh	QWHAT
                        	TAB6_1
FFFC2B78 2F342F2C		dh	FR2			;"STEP" in "FOR"
FFFC2B7A 364C2F34		dh	FR3
                        	TAB8_1
FFFC2B7C 3664364C		dh	XP11	;>=		Relational operators
FFFC2B7E 367C3664		dh	XP12	;<>
FFFC2B80 36AC367C		dh	XP13	;>
FFFC2B82 369436AC		dh	XP15	;=
FFFC2B84 36C43694		dh	XP14	;<=
FFFC2B86 370436C4		dh	XP16	;<
FFFC2B88 355C3704		dh	XP17
                        	TAB9_1
FFFC2B8A 3570355C	    dh  XP_AND
FFFC2B8C 34FC3570	    dh  XP_ANDX
                        	TAB10_1
FFFC2B8E 351034FC	    dh  XP_OR
FFFC2B90 00003510	    dh  XP_ORX
                        	
                        	;*
                        	; r3 = match flag (trashed)
                        	; r9 = text table
                        	; r10 = exec table
                        	; r11 = trashed
FFFC2B92 00000000		align	1
FFFC2B96 00000000
FFFC2B9A 00000000
FFFC2B9E 3EB70000
                        	
                        	//message "DIRECT"
                        	DIRECT:
FFFC2BA0 FFFC3EB7		ldi		$t3,#TAB1
FFFC2BA4 A64E8E93
FFFC2BA8 FFFC3F37		ldi		$t4,#TAB1_1
FFFC2BAC B22F0F13
                        	EXEC:
FFFC2BB0 6D4010EF		call	IGNBLK		; ignore leading blanks
FFFC2BB4 000E6FB3		mov		$t5,$t2		; save the pointer
FFFC2BB8 000061B3		mov		r3,r0		; clear match flag
                        	EXLP:
FFFC2BBC 000E4903		lbu		a0,[$t2]		; get the program character
FFFC2BC0 001E0E13		add		$t2,$t2,#1
FFFC2BC4 000EC983		lbu		a1,[$t3]		; get the table character
FFFC2BC8 00099663		bne		a1,x0,EXNGO		; If end of table,
FFFC2BCC 000FEE33		mov		$t2,$t5		;	restore the text pointer and...
FFFC2BD0 04000263		bra		EXGO		;   execute the default.
                        	EXNGO:
FFFC2BD4 04390063		beq		a0,r3,EXGO	; Else check for period... if so, execute
FFFC2BD8 07F9F993		and		a1,a1,#0x7f	; ignore the table's high bit
FFFC2BDC 03298263		beq		a1,a0,EXMAT	;		is there a match?
FFFC2BE0 002F0F13		add		$t4,$t4,#2	;if not, try the next entry
FFFC2BE4 000FEE33		mov		$t2,$t5		; reset the program pointer
FFFC2BE8 000061B3		mov		r3,x0		; sorry, no match
                        	EX1:
FFFC2BEC 000EC903		lbu		a0,[$t3]		; get to the end of the entry
FFFC2BF0 001E8E93		add		$t3,$t3,#1
FFFC2BF4 08097D93		and		$t1,$a0,#$80
FFFC2BF8 FE0D8AE3		beq		$t1,$r0,EX1	; test for bit 7 set
FFFC2BFC FC0000E3		bra		EXLP		; back for more matching
                        	EXMAT:
FFFC2C00 02E06193		ldi		r3,#'.'		; we've got a match so far
FFFC2C04 000EC903		lbu		a0,[$t3]		; end of table entry?
FFFC2C08 001E8E93		add		$t3,$t3,#1
FFFC2C0C 08097D93		and		$t1,$a0,#$80
FFFC2C10 FA0D86E3		beq		$t1,$r0,EXLP		; test for bit 7 set, if not, go back for more
                        	EXGO:
                        		; execute the appropriate routine
FFFC2C14 000F5903		lhu		a0,[$t4]	; get the low mid order byte
FFFC2C18 FFFC0637		or		a0,a0,#$FFFC0000	; add in ROM base
FFFC2C1C 00060613
FFFC2C20 01266933
FFFC2C24 00090067		jmp		[a0]
                        	
                        	    
                        	;******************************************************************
                        	;
                        	; What follows is the code to execute direct and statement
                        	; commands. Control is transferred to these points via the command
                        	; table lookup code of 'DIRECT' and 'EXEC' in the last section.
                        	; After the command is executed, control is transferred to other
                        	; sections as follows:
                        	;
                        	; For 'LISTX', 'NEW', and 'STOP': go back to the warm start point.
                        	; For 'RUN': go execute the first stored line if any; else go
                        	; back to the warm start point.
                        	; For 'GOTO' and 'GOSUB': go execute the target line.
                        	; For 'RETURN' and 'NEXT'; go back to saved return line.
                        	; For all others: if 'CURRNT' is 0, go to warm start; else go
                        	; execute next command. (This is done in 'FINISH'.)
                        	;
                        	;******************************************************************
                        	;
                        	; *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                        	;
                        	; 'NEW<CR>' sets TXTUNF to point to TXTBGN
                        	;
                        	
                        	NEW:
FFFC2C28 0A8010EF		call	ENDCHK
FFFC2C2C 00002837		ldi		v0,#TXTBGN
FFFC2C30 80080813
FFFC2C34 71002223		sw		v0,TXTUNF	;	set the end pointer
FFFC2C38 0D8000EF		call  clearVars
                        	
                        	; 'STOP<CR>' goes back to WSTART
                        	;
                        	STOP:
FFFC2C3C 094010EF		call	ENDCHK
FFFC2C40 C81FF06F		jmp		WSTART		; WSTART will reset the stack
                        	
                        	;------------------------------------------------------------------------------
                        	; YIELD suspends execution of TinyBasic by switching to the next ready task.
                        	;------------------------------------------------------------------------------
                        	
                        	YIELD0:
FFFC2C44 00D06913		ldi		a0,#13
FFFC2C48 00000073		ecall
FFFC2C4C 2140006F		jmp		FINISH
                        	
                        	;------------------------------------------------------------------------------
                        	; 'RUN<CR>' finds the first stored line, stores its address
                        	; in CURRNT, and starts executing it. Note that only those
                        	; commands in TAB2 are legal for a stored program.
                        	;
                        	; There are 3 more entries in 'RUN':
                        	; 'RUNNXL' finds next line, stores it's address and executes it.
                        	; 'RUNTSL' stores the address of this line and executes it.
                        	; 'RUNSML' continues the execution on same line.
                        	;
                        	RUN:
FFFC2C50 080010EF		call	ENDCHK
FFFC2C54 00002E37		ldi		$t2,#TXTBGN	;	set pointer to beginning
FFFC2C58 800E0E13
FFFC2C5C 71C02C23		sw		$t2,CURRNT
FFFC2C60 0B0000EF		call  clearVars
                        	
                        	RUNNXL:					; RUN <next line>
FFFC2C64 71802E03		lw		$t2,CURRNT	; executing a program?
FFFC2C68 000E1463		bne		$t2,x0,RUN3	; if not, we've finished a direct stat.
                        	RUN2:
FFFC2C6C C55FF06F		jmp		WSTART
                        	RUN3:
FFFC2C70 7A402903		lw		a0,IRQROUT		; are we handling IRQ's ?
FFFC2C74 02090E63		beq		a0,x0,RUN1
FFFC2C78 7B402D83		lw		$t1,IRQFlag		; was there an IRQ ?
FFFC2C7C 020D8A63		beq		$t1,x0,RUN1
FFFC2C80 7A002A23		sw		x0,IRQFlag
FFFC2C84 2D0010EF		call	PUSHA_		; the same code as a GOSUB
FFFC2C88 FF470713		sub		$sp,$sp,#12
FFFC2C8C 71402903		lw		a0,STKGOS
FFFC2C90 01272023		sw		a0,[$sp]
FFFC2C94 71802903		lw		a0,CURRNT
FFFC2C98 01272223		sw		a0,4[$sp]
FFFC2C9C 01C72423		sw		$t2,8[$sp]
FFFC2CA0 70002823		sw		x0,LOPVAR		; load new values
FFFC2CA4 70E02A23		sw		$sp,STKGOS
FFFC2CA8 7A402E83		lw		$t3,IRQROUT
FFFC2CAC 00000C63		bra		RUNTSL
                        	RUN1:
FFFC2CB0 000E6EB3		mov		$t3,$t2
FFFC2CB4 00006933		mov		a0,x0
FFFC2CB8 1C0010EF		call	FNDLNP		; else find the next line number
FFFC2CBC 70402D83		lw		$t1,TXTUNF	; if we've fallen off the end, stop
FFFC2CC0 FBBEF6E3		bgeu	$t3,$t1,RUN2
                        	
                        	RUNTSL:					; RUN <this line>
FFFC2CC4 71D02C23		sw		$t3,CURRNT	; set CURRNT to point to the line no.
FFFC2CC8 004E8E13		add		$t2,$t3,#4	; set the text pointer to
                        	
                        	RUNSML:                 ; RUN <same line>
FFFC2CCC 668010EF		call	CHKIO		; see if a control-C was pressed
FFFC2CD0 FFFC3EB7		ldi		$t3,#TAB2		; find command in TAB2
FFFC2CD4 A76E8E93
FFFC2CD8 FFFC3F37		ldi		$t4,#TAB2_1
FFFC2CDC B2CF0F13
FFFC2CE0 ED1FF06F		jmp		EXEC		; and execute it
                        	
                        	
                        	;******************************************************************
                        	; 'GOTO expr<CR>' evaluates the expression, finds the target
                        	; line, and jumps to 'RUNTSL' to do it.
                        	;******************************************************************
                        	;
                        	GOTO:
FFFC2CE4 7E4000EF		call	OREXPR		;evaluate the following expression
FFFC2CE8 000862B3		mov   r5,v0
FFFC2CEC 7E5000EF		call 	ENDCHK		;must find end of line
FFFC2CF0 0002E933		mov   a0,r5
FFFC2CF4 164010EF		call 	FNDLN		; find the target line
FFFC2CF8 FC0816E3		bne		v0,x0,RUNTSL; go do it
FFFC2CFC FFFC4937		ldi		a0,#msgBadGotoGosub
FFFC2D00 70590913
FFFC2D04 01C0106F		jmp		ERROR		; no such line no.
                        	
                        	_clr:
FFFC2D08 008000EF	    call    clearVars
FFFC2D0C 1540006F	    jmp     FINISH
                        	
                        	; Clear the variable area of memory
                        	clearVars:
FFFC2D10 FF870713		sub		$sp,$sp,#8
FFFC2D14 00672023		sw		r6,[$sp]
FFFC2D18 00172223		sw		$ra,4[$sp]
FFFC2D1C 06406313	  ldi   r6,#100    	; number of word pairs to clear
FFFC2D20 70802803	  lw    v0,VARBGN
                        	.cv1:
FFFC2D24 00082023	  sw		x0,[$v0]		; variable name
FFFC2D28 00082223	  sw		x0,4[$v0]		; and value
FFFC2D2C 00880813	  add		v0,v0,#8
FFFC2D30 FFF30313	  sub		r6,r6,#1
FFFC2D34 FE6048E3		bgt		r6,x0,.cv1
FFFC2D38 00072303	  lw		r6,[$sp]
FFFC2D3C 00472083	  lw		$ra,4[$sp]
FFFC2D40 00870713	  add		$sp,$sp,#8
FFFC2D44 00008067	  ret
                        	
                        	;******************************************************************
                        	; ONIRQ <line number>
                        	; ONIRQ sets up an interrupt handler which acts like a specialized
                        	; subroutine call. ONIRQ is coded like a GOTO that never executes.
                        	;******************************************************************
                        	;
                        	ONIRQ:
FFFC2D48 780000EF		call	OREXPR		;evaluate the following expression
FFFC2D4C 000862B3		mov   r5,v0
FFFC2D50 781000EF		call 	ENDCHK		;must find end of line
FFFC2D54 0002E933		mov   a0,r5
FFFC2D58 100010EF		call 	FNDLN		; find the target line
FFFC2D5C 00081663		bne		v0,r0,ONIRQ1
FFFC2D60 7A002223		sw		x0,IRQROUT
FFFC2D64 0FC0006F		jmp		FINISH
                        	ONIRQ1:
FFFC2D68 7BD02223		sw		$t3,IRQROUT
FFFC2D6C 0F40006F		jmp		FINISH
                        	
                        	WAITIRQ:
FFFC2D70 5C4010EF		call	CHKIO		; see if a control-C was pressed
FFFC2D74 7B402D83		lw		$t1,IRQFlag
FFFC2D78 FE0D8CE3		beq		$t1,x0,WAITIRQ
FFFC2D7C 0E40006F		jmp		FINISH
                        	
                        	
                        	;******************************************************************
                        	; LIST
                        	;
                        	; LISTX has two forms:
                        	; 'LIST<CR>' lists all saved lines
                        	; 'LIST #<CR>' starts listing at the line #
                        	; Control-S pauses the listing, control-C stops it.
                        	;******************************************************************
                        	;
                        	LISTX:
FFFC2D80 490010EF		call		TSTNUM		; see if there's a line no.
FFFC2D84 000862B3		mov      r5,v0
FFFC2D88 749000EF		call		ENDCHK		; if not, we get a zero
FFFC2D8C 0002E933		mov      a0,r5
FFFC2D90 0C8010EF		call		FNDLN		; find this or next line
                        	LS1:
FFFC2D94 00081663		bne		v0,r0,LS4
                        	LS5:
FFFC2D98 70402D83		lw		$t1,TXTUNF
FFFC2D9C B3BEF2E3		bgeu	$t3,$t1,WSTART	; warm start if we passed the end
                        	LS4:
FFFC2DA0 000EE933		mov		a0,$t3
FFFC2DA4 3C4010EF		call	PRTLN		; print the line
FFFC2DA8 00086EB3		mov		$t3,$v0		; set pointer for next
FFFC2DAC 588010EF		call	CHKIO		; check for listing halt request
FFFC2DB0 00080A63		beq		v0,x0,LS3
FFFC2DB4 01306D93		ldi		$t1,#CTRLS
FFFC2DB8 01B81663		bne		v0,$t1,LS3; pause the listing?
                        	LS2:
FFFC2DBC 578010EF		call 	CHKIO		; if so, wait for another keypress
FFFC2DC0 FE080EE3		beq		v0,r0,LS2
                        	LS3:
                        	;	mov		$v0,$x0
FFFC2DC4 FC000AE3		bra		LS5
                        	;	mov		a0,r0
                        	;	call	FNDSKP	;FNDLNP		; find the next line
                        	;	bra		LS1
                        	
                        	
                        	;******************************************************************
                        	; PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                        	; where '....' is a list of expressions, formats, back-arrows,
                        	; and strings.	These items a separated by commas.
                        	;
                        	; A format is a pound sign followed by a number.  It controls
                        	; the number of spaces the value of an expression is going to
                        	; be printed in.  It stays effective for the rest of the print
                        	; command unless changed by another format.  If no format is
                        	; specified, 11 positions will be used.
                        	;
                        	; A string is quoted in a pair of single- or double-quotes.
                        	;
                        	; An underline (back-arrow) means generate a <CR> without a <LF>
                        	;
                        	; A <CR LF> is generated after the entire list has been printed
                        	; or if the list is empty.  If the list ends with a semicolon,
                        	; however, no <CR LF> is generated.
                        	;******************************************************************
                        	;
                        	PRINT:
FFFC2DC8 00B06293		ldi		r5,#11		; D4 = number of print spaces
FFFC2DCC 3F8010EF		call	TSTC		; if null list and ":"
FFFC2DD0 0000003A		dw		':'
FFFC2DD4 00000663		bra		PR2
FFFC2DD8 584010EF		call	CRLF		; give CR-LF and continue
FFFC2DDC EF1FF06F		jmp		RUNSML		;		execution on the same line
                        	PR2:
FFFC2DE0 3E4010EF		call	TSTC		;if null list and <CR>
FFFC2DE4 0000000D		dw		CR
FFFC2DE8 00000663		bra		PR0
FFFC2DEC 570010EF		call	CRLF		;also give CR-LF and
FFFC2DF0 E75FF06F		jmp		RUNNXL		;execute the next line
                        	PR0:
FFFC2DF4 3D0010EF		call	TSTC		;else is it a format?
FFFC2DF8 00000023		dw		'#'
FFFC2DFC 00000863		bra		PR1
FFFC2E00 6C8000EF		call	OREXPR		; yes, evaluate expression
FFFC2E04 000862B3		mov		r5,v0	; and save it as print width
FFFC2E08 02000263		bra		PR3		; look for more to print
                        	PR1:
FFFC2E0C 3B8010EF		call	TSTC	;	is character expression? (MRL)
FFFC2E10 00000024		dw		'$'
FFFC2E14 00000863		bra		PR4
FFFC2E18 6B0000EF		call	OREXPR	;	yep. Evaluate expression (MRL)
FFFC2E1C 9EDFF0EF		call	GOOUT	;	print low byte (MRL)
FFFC2E20 00000663		bra		PR3		;look for more. (MRL)
                        	PR4:
FFFC2E24 1DC010EF		call	QTSTG	;	is it a string?
                        		; the following branch must occupy only 1 word!
FFFC2E28 02000063		bra		PR8		;	if not, must be an expression
                        	PR3:
FFFC2E2C 398010EF		call		TSTC	;	if ",", go find next
FFFC2E30 0000002C		dw		','
FFFC2E34 00000663		bra		PR6
FFFC2E38 65D000EF		call		FIN		;in the list.
FFFC2E3C FA000CE3		bra		PR0
                        	PR6:
FFFC2E40 51C010EF		call		CRLF		;list ends here
FFFC2E44 01C0006F		jmp		FINISH
                        	PR8:
FFFC2E48 680000EF		call	OREXPR		; evaluate the expression
FFFC2E4C 00086933		mov		a0,v0
FFFC2E50 00506993		ldi		a1,#5		; set the width
FFFC2E54 00A06A13		ldi		a2,#10
FFFC2E58 23C010EF		call	PRTNUM		; print its value
FFFC2E5C FC0008E3		bra		PR3			; more to print?
                        	
                        	
                        	FINISH:
FFFC2E60 635000EF		call	FIN		; Check end of command
FFFC2E64 6B50006F		jmp		QWHAT	; print "What?" if wrong
                        	
                        	
                        	;*******************************************************************
                        	;
                        	; *** GOSUB *** & RETURN ***
                        	;
                        	; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                        	; except that the current text pointer, stack pointer, etc. are
                        	; saved so that execution can be continued after the subroutine
                        	; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                        	; recursive), the save area must be stacked.  The stack pointer
                        	; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                        	; If we are in the main routine, 'STKGOS' is zero (this was done
                        	; in the initialization section of the interpreter), but we still
                        	; save it as a flag for no further 'RETURN's.
                        	;******************************************************************
                        	;
                        	GOSUB:
FFFC2E68 0EC010EF		call	PUSHA_		; save the current 'FOR' parameters
FFFC2E6C 65C000EF		call	OREXPR		; get line number
FFFC2E70 00086933		mov		$a0,$v0
FFFC2E74 7E5000EF		call	FNDLN		; find the target line
FFFC2E78 00081863		bne		v0,r0,gosub1
FFFC2E7C FFFC4937		ldi		a0,#msgBadGotoGosub
FFFC2E80 70590913
FFFC2E84 69D0006F		jmp		ERROR		; if not there, say "How?"
                        	gosub1:
FFFC2E88 FF470713		sub		$sp,$sp,#12
FFFC2E8C 71402903		lw		a0,STKGOS	; 'STKGOS'
FFFC2E90 01272023		sw		a0,[$sp]
FFFC2E94 71802903		lw		a0,CURRNT	; found it, save old 'CURRNT'...
FFFC2E98 01272223		sw		a0,4[$sp]
FFFC2E9C 01C72423		sw		$t2,8[$sp]
FFFC2EA0 70002823		sw		$x0,LOPVAR		; load new values
FFFC2EA4 70E02A23		sw		$sp,STKGOS
FFFC2EA8 E1DFF06F		jmp		RUNTSL
                        	
                        	
                        	;******************************************************************
                        	; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                        	; returns the execution to the command after the most recent
                        	; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                        	; a 'GOSUB' and is thus an error.
                        	;******************************************************************
                        	;
                        	RETURN:
FFFC2EAC 625000EF		call	ENDCHK		; there should be just a <CR>
FFFC2EB0 71402983		lw		a1,STKGOS		; get old stack pointer
FFFC2EB4 00099863		bne		a1,x0,return1
FFFC2EB8 FFFC4937		ldi		a0,#msgRetWoGosub
FFFC2EBC 72190913
FFFC2EC0 6610006F		jmp		ERROR		; if zero, it doesn't exist
                        	return1:
FFFC2EC4 0009E733		mov		$sp,a1		; else restore it
FFFC2EC8 00072903		lw		a0,[$sp]
FFFC2ECC 00470713		add		$sp,$sp,#4
FFFC2ED0 71202A23		sw		a0,STKGOS	; and the old 'STKGOS'
FFFC2ED4 00072903		lw		a0,[$sp]
FFFC2ED8 00470713		add		$sp,$sp,#4
FFFC2EDC 71202C23		sw		a0,CURRNT	; and the old 'CURRNT'
FFFC2EE0 00072E03		lw		$t2,[$sp]	; and the old text pointer
FFFC2EE4 00470713		add		$sp,$sp,#4
FFFC2EE8 034010EF		call	POPA_		;and the old 'FOR' parameters
FFFC2EEC F75FF06F		jmp		FINISH		;and we are back home
                        	
                        	;******************************************************************
                        	; *** FOR *** & NEXT ***
                        	;
                        	; 'FOR' has two forms:
                        	; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                        	; The second form means the same thing as the first form with a
                        	; STEP of positive 1.  The interpreter will find the variable 'var'
                        	; and set its value to the current value of 'exp1'.  It also
                        	; evaluates 'exp2' and 'exp1' and saves all these together with
                        	; the text pointer, etc. in the 'FOR' save area, which consists of
                        	; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                        	; already something in the save area (indicated by a non-zero
                        	; 'LOPVAR'), then the old save area is saved on the stack before
                        	; the new values are stored.  The interpreter will then dig in the
                        	; stack and find out if this same variable was used in another
                        	; currently active 'FOR' loop.  If that is the case, then the old
                        	; 'FOR' loop is deactivated. (i.e. purged from the stack)
                        	;******************************************************************
                        	;
                        	FOR:
FFFC2EF0 064010EF		call	PUSHA_		; save the old 'FOR' save area
FFFC2EF4 539000EF		call	SETVAL		; set the control variable
FFFC2EF8 71002823		sw		v0,LOPVAR		; save its address
FFFC2EFC FFFC3EB7		ldi		$t3,#TAB5
FFFC2F00 B08E8E93
FFFC2F04 FFFC3F37		ldi		$t4,#TAB5_1	; use 'EXEC' to test for 'TO'
FFFC2F08 B74F0F13
FFFC2F0C CA5FF06F		jmp		EXEC
                        	FR1:
FFFC2F10 5B8000EF		call	OREXPR		; evaluate the limit
FFFC2F14 77002E23		sw		v0,LOPLMT	; save that
FFFC2F18 FFFC3EB7		ldi		$t3,#TAB6
FFFC2F1C B0BE8E93
FFFC2F20 FFFC3F37		ldi		$t4,#TAB6_1	; use 'EXEC' to test for the word 'STEP
FFFC2F24 B78F0F13
FFFC2F28 C89FF06F		jmp		EXEC
                        	FR2:
FFFC2F2C 59C000EF		call	OREXPR		; found it, get the step value
FFFC2F30 00000463		bra		FR4
                        	FR3:
FFFC2F34 00106813		ldi		v0,#1		; not found, step defaults to 1
                        	FR4:
FFFC2F38 77002C23		sw		v0,LOPINC	; save that too
                        	FR5:
FFFC2F3C 71802983		lw		a1,CURRNT
FFFC2F40 77302A23		sw		a1,LOPLN	; save address of current line number
FFFC2F44 77C02823		sw		$t2,LOPPT	; and text pointer
FFFC2F48 000761B3		mov		r3,$sp		; dig into the stack to find 'LOPVAR'
FFFC2F4C 71002303		lw		r6,LOPVAR
FFFC2F50 00000463		bra		FR7
                        	FR6:
FFFC2F54 01418193		add		r3,r3,#20	; look at next stack frame
                        	FR7:
FFFC2F58 0001A983		lw		a1,[r3]		; is it zero?
FFFC2F5C 00098E63		beq		a1,x0,FR8	; if so, we're done
FFFC2F60 FE699AE3		bne		a1,r6,FR6	; same as current LOPVAR? nope, look some more
                        	
FFFC2F64 0001E933	  mov		a0,r3	   ; Else remove 5 words from...
FFFC2F68 000769B3		mov		a1,$sp
FFFC2F6C 01418A13		add		a2,r3,#20  ; inside the stack.
FFFC2F70 7A5000EF		call	MVDOWN
FFFC2F74 01470713		add		$sp,$sp,#20	; set the SP 5 long words up
                        	;	lw		a0,[$sp]		; ???
                        	;	add		$sp,$sp,#4
                        	FR8:
FFFC2F78 EE9FF06F	  jmp	    FINISH		; and continue execution
                        	
                        	
                        	;******************************************************************
                        	; 'NEXT var' serves as the logical (not necessarily physical) end
                        	; of the 'FOR' loop.  The control variable 'var' is checked with
                        	; the 'LOPVAR'.  If they are not the same, the interpreter digs in
                        	; the stack to find the right one and purges all those that didn't
                        	; match.  Either way, it then adds the 'STEP' to that variable and
                        	; checks the result with against the limit value.  If it is within
                        	; the limit, control loops back to the command following the
                        	; 'FOR'.  If it's outside the limit, the save area is purged and
                        	; execution continues.
                        	;******************************************************************
                        	;
                        	NEXT:
FFFC2F7C 00006933		mov		a0,x0		; don't allocate it
FFFC2F80 189000EF		call	TSTV		; get address of variable
FFFC2F84 00081863		bne		v0,x0,NX4
FFFC2F88 FFFC4937		ldi		a0,#msgNextVar
FFFC2F8C 6E290913
FFFC2F90 580008E3		bra		ERROR		; if no variable, say "What?"
                        	NX4:
FFFC2F94 00086EB3		mov		$t3,v0	; save variable's address
                        	NX0:
FFFC2F98 71002903		lw		a0,LOPVAR	; If 'LOPVAR' is zero, we never...
FFFC2F9C 00091863		bne		a0,x0,NX5	; had a FOR loop
FFFC2FA0 FFFC4937		ldi		a0,#msgNextFor
FFFC2FA4 6D090913
FFFC2FA8 56000CE3		bra		ERROR
                        	NX5:
FFFC2FAC 01D90663		beq		a0,$t3,NX2	; else we check them OK, they agree
FFFC2FB0 76D000EF		call	POPA_		; nope, let's see the next frame
FFFC2FB4 FE0002E3		bra		NX0
                        	NX2:
FFFC2FB8 000EA903		lw		a0,[$t3]		; get control variable's value
FFFC2FBC 77802983		lw		a1,LOPINC
FFFC2FC0 01390933		add		a0,a0,a1	; add in loop increment
                        	;	BVS.L	QHOW		say "How?" for 32-bit overflow
FFFC2FC4 012EA023		sw		a0,[$t3]		; save control variable's new value
FFFC2FC8 77C02183		lw		r3,LOPLMT	; get loop's limit value
FFFC2FCC 0009D663		bge		a1,x0,NX1	; check loop increment, branch if loop increment is positive
FFFC2FD0 00394E63		blt		a0,r3,NXPurge	; test against limit
FFFC2FD4 00000463		bra     NX3
                        	NX1:
FFFC2FD8 0121CA63		bgt		a0,r3,NXPurge
                        	NX3:
FFFC2FDC 77402E03		lw		$t2,LOPLN	; Within limit, go back to the...
FFFC2FE0 71C02C23		sw		$t2,CURRNT
FFFC2FE4 77002E03		lw		$t2,LOPPT	; saved 'CURRNT' and text pointer.
FFFC2FE8 E79FF06F		jmp		FINISH
                        	NXPurge:
FFFC2FEC 731000EF	  call    POPA_        ; purge this loop
FFFC2FF0 E71FF06F	  jmp     FINISH
                        	
                        	
                        	;******************************************************************
                        	; *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                        	;
                        	; 'REM' can be followed by anything and is ignored by the
                        	; interpreter.
                        	;
                        	;REM
                        	;    br	    IF2		    ; skip the rest of the line
                        	; 'IF' is followed by an expression, as a condition and one or
                        	; more commands (including other 'IF's) separated by colons.
                        	; Note that the word 'THEN' is not used.  The interpreter evaluates
                        	; the expression.  If it is non-zero, execution continues.  If it
                        	; is zero, the commands that follow are ignored and execution
                        	; continues on the next line.
                        	;******************************************************************
                        	;
                        	IF0:
FFFC2FF4 4D4000EF	  call	OREXPR		; evaluate the expression
                        	IF1:
FFFC2FF8 00080463	  beq	  v0,x0,IF2	; is it zero? if not, continue
FFFC2FFC CD1FF06F	  jmp		RUNSML
                        	IF2:
FFFC3000 000E6EB3	  mov		$t3,$t2	; set lookup pointer
FFFC3004 00006933		mov		a0,x0		; find line #0 (impossible)
FFFC3008 6D1000EF		call	FNDSKP		; if so, skip the rest of the line
FFFC300C 00081463		bne		v0,x0,IF3; if no next line, do a warm start
FFFC3010 8B1FF06F		jmp		WSTART
                        	IF3:
FFFC3014 CB1FF06F		jmp		RUNTSL		; run the next line
                        	
                        	
                        	;******************************************************************
                        	; INPUT is called first and establishes a stack frame
                        	INPERR:
FFFC3018 79802703		lw		$sp,STKINP		; restore the old stack pointer
FFFC301C 00072903		lw		a0,[$sp]
FFFC3020 00470713		add		$sp,$sp,#4
FFFC3024 71202C23		sw		a0,CURRNT		; and old 'CURRNT'
FFFC3028 00072E03		lw		$t2,[$sp]		; and old text pointer
FFFC302C 00470713		add		$sp,$sp,#4
FFFC3030 01470713		add		$sp,$sp,#20	; fall through will subtract 20
                        	
                        	; 'INPUT' is like the 'PRINT' command, and is followed by a list
                        	; of items.  If the item is a string in single or double quotes,
                        	; or is an underline (back arrow), it has the same effect as in
                        	; 'PRINT'.  If an item is a variable, this variable name is
                        	; printed out followed by a colon, then the interpreter waits for
                        	; an expression to be typed in.  The variable is then set to the
                        	; value of this expression.  If the variable is preceeded by a
                        	; string (again in single or double quotes), the string will be
                        	; displayed followed by a colon.  The interpreter the waits for an
                        	; expression to be entered and sets the variable equal to the
                        	; expression's value.  If the input expression is invalid, the
                        	; interpreter will print "What?", "How?", or "Sorry" and reprint
                        	; the prompt and redo the input.  The execution will not terminate
                        	; unless you press control-C.  This is handled in 'INPERR'.
                        	;
                        	INPUT:
FFFC3034 FEC70713		sub		$sp,$sp,#20	; allocate five words on stack
FFFC3038 00572823		sw		r5,16[$sp]	; save off r5 into stack var
                        	IP6:
FFFC303C 01C72023		sw		$t2,[$sp]	; save in case of error
FFFC3040 7C1000EF		call	QTSTG		; is next item a string?
FFFC3044 00000C63		bra		IP2			; nope - this branch must take only 1 word
FFFC3048 00106913		ldi		a0,#1		; allocate var
FFFC304C 0BD000EF		call	TSTV		; yes, but is it followed by a variable?
FFFC3050 08090463		beq    a0,r0,IP4   ; if not, brnch
FFFC3054 00096F33		mov		$t4,a0		; put away the variable's address
FFFC3058 04000063		bra		IP3			; if so, input to variable
                        	IP2:
FFFC305C 01C72223		sw		$t2,4[$sp]	; save off in stack var for 'PRTSTG'
FFFC3060 00106913		ldi		a0,#1
FFFC3064 0A5000EF		call	TSTV		; must be a variable now
FFFC3068 00091A63		bne		a0,r0,IP7
FFFC306C FFFC4937		ldi		a0,#msgInputVar
FFFC3070 6B490913
FFFC3074 01470713		add		$sp,$sp,#20	; cleanup stack
FFFC3078 4A0004E3		bra		ERROR		; "What?" it isn't?
                        	IP7:
FFFC307C 00096F33		mov		$t4,a0		; put away the variable's address
FFFC3080 000E4283		lbu		r5,[$t2]		; get ready for 'PRTSTG' by null terminating
FFFC3084 000E0023		sb		x0,[$t2]
FFFC3088 000069B3		mov		a1,x0
FFFC308C 00472903		lw		a0,4[$sp]	; get back text pointer
FFFC3090 709000EF		call	PRTSTG		; print string as prompt
FFFC3094 005E0023		sb		r5,[$t2]		; un-null terminate
                        	IP3
FFFC3098 01C72223		sw		$t2,4[$sp]	; save in case of error
FFFC309C 71802903		lw		a0,CURRNT
FFFC30A0 01272423		sw		a0,8[$sp]	; also save 'CURRNT'
FFFC30A4 FFF06913		ldi		a0,#-1
FFFC30A8 71202C23		sw		a0,CURRNT	; flag that we are in INPUT
FFFC30AC 78E02C23		sw		$sp,STKINP	; save the stack pointer too
FFFC30B0 01E72623		sw		$t4,12[$sp]	; save the variable address
FFFC30B4 03A06913		ldi		a0,#':'		; print a colon first
FFFC30B8 4AD000EF		call	GETLN		; then get an input line
FFFC30BC 71C06E13		ldi		$t2,#BUFFER	; point to the buffer
FFFC30C0 408000EF		call	OREXPR		; evaluate the input
FFFC30C4 00C72F03		lw		$t4,12[$sp]	; restore the variable address
FFFC30C8 012F2023		sw		a0,[$t4]	; save value in variable
FFFC30CC 00872903		lw		a0,8[$sp]	; restore old 'CURRNT'
FFFC30D0 71202C23		sw		a0,CURRNT
FFFC30D4 00472E03		lw		$t2,4[$sp]	; and the old text pointer
                        	IP4:
FFFC30D8 0EC010EF		call	TSTC
FFFC30DC 0000002C		dw		','
FFFC30E0 00000463		bra		IP5
FFFC30E4 F4000CE3		bra		IP6			; yes, more items
                        	IP5:
FFFC30E8 01072283		lw		r5,16[$sp]
FFFC30EC 01470713		add		$sp,$sp,#20	; cleanup stack
FFFC30F0 D71FF06F	 	jmp		FINISH
                        	
                        	
                        	DEFLT:
FFFC30F4 000E4903	  lbu    	a0,[$t2]
FFFC30F8 00D06D93	  ldi			$t1,#CR
FFFC30FC D7B902E3		beq	    a0,$t1,FINISH	    ; empty line is OK else it is 'LET'
                        	
                        	
                        	;******************************************************************
                        	; 'LET' is followed by a list of items separated by commas.
                        	; Each item consists of a variable, an equals sign, and an
                        	; expression.  The interpreter evaluates the expression and sets
                        	; the variable to that value.  The interpreter will also handle
                        	; 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                        	;******************************************************************
                        	;
                        	LET:
FFFC3100 32D000EF	  call	SETVAL		; do the assignment
FFFC3104 0C0010EF		call	TSTC		; check for more 'LET' items
FFFC3108 0000002C		dw		','
FFFC310C D55FF06F		jmp		FINISH
FFFC3110 FE0008E3		bra	    LET
                        	LT1:
FFFC3114 D4DFF06F	  jmp	    FINISH		; until we are finished.
                        	
                        	
                        	;******************************************************************
                        	; *** LOAD *** & SAVE ***
                        	;
                        	; These two commands transfer a program to/from an auxiliary
                        	; device such as a cassette, another computer, etc.  The program
                        	; is converted to an easily-stored format: each line starts with
                        	; a colon, the line no. as 4 hex digits, and the rest of the line.
                        	; At the end, a line starting with an '@' sign is sent.  This
                        	; format can be read back with a minimum of processing time by
                        	; the RTF65002
                        	;******************************************************************
                        	;
                        	LOAD
FFFC3118 00002E37		ldi		$t2,#TXTBGN	; set pointer to start of prog. area
FFFC311C 800E0E13
FFFC3120 00D06913		ldi		a0,#CR		; For a CP/M host, tell it we're ready...
FFFC3124 EECFF0EF		call	GOAUXO		; by sending a CR to finish PIP command.
                        	LOD1:
FFFC3128 EF0FF0EF		call	GOAUXI		; look for start of line
FFFC312C FF205EE3		ble		a0,r0,LOD1
FFFC3130 04006D93		ldi		$t1,#'@'
FFFC3134 03B90E63		beq		a0,$t1,LODEND	; end of program?
FFFC3138 01A06D93		ldi		$t1,#$1A
FFFC313C 03B90A63		beq		a0,$t1,LODEND	; or EOF marker
FFFC3140 03A06D93		ldi		$t1,#':'
FFFC3144 FFB912E3		bne		a0,$t1,LOD1	; if not, is it start of line? if not, wait for it
FFFC3148 030000EF		call	GCHAR		; get line number
FFFC314C 012E2023		sw		a0,[$t2]		; store it
FFFC3150 004E0E13		add		$t2,$t2,#4
                        	LOD2:
FFFC3154 EC4FF0EF		call	GOAUXI		; get another text char.
FFFC3158 FF205EE3		ble		a0,r0,LOD2
FFFC315C 012E0023		sb		a0,[$t2]		; store it
FFFC3160 001E0E13		add		$t2,$t2,#1
FFFC3164 00D06D93		ldi		$t1,#CR
FFFC3168 FFB916E3		bne		a0,$t1,LOD2		; is it the end of the line? if not, go back for more
FFFC316C FA000EE3		bra		LOD1		; if so, start a new line
                        	LODEND:
FFFC3170 71C02223		sw		$t2,TXTUNF	; set end-of program pointer
FFFC3174 F4CFF06F		jmp		WSTART		; back to direct mode
                        	
                        	
                        	; get character from input (32 bit value)
                        	GCHAR:
FFFC3178 FF470713		sub		$sp,$sp,#12
FFFC317C 00572023		sw		r5,[$sp]
FFFC3180 00672223		sw		r6,4[$sp]
FFFC3184 00172423		sw		$ra,8[$sp]
FFFC3188 00806313		ldi		r6,#8       ; repeat ten times
FFFC318C 00006293		ldi		r5,#0
                        	GCHAR1:
FFFC3190 E88FF0EF		call	GOAUXI		; get a char
FFFC3194 FF205EE3		ble		a0,r0,GCHAR1
FFFC3198 02C000EF		call	asciiToHex
FFFC319C 00429293		sll		r5,r5,#4
FFFC31A0 0122E2B3		or		r5,r5,a0
FFFC31A4 FFF30313		sub		r6,r6,#1
FFFC31A8 FE6064E3		bgtu	r6,r0,GCHAR1
FFFC31AC 0002E933		mov		a0,r5
FFFC31B0 00072283		lw		r5,[$sp]
FFFC31B4 00472303		lw		r6,4[$sp]
FFFC31B8 00872083		lw		$ra,8[$sp]
FFFC31BC 00C70713		add		$sp,$sp,#12
FFFC31C0 00008067		ret
                        	
                        	; convert an ascii char to hex code
                        	; input
                        	;	a0 = char to convert
                        	
                        	asciiToHex:
FFFC31C4 03906D93		ldi		$t1,#'9'
FFFC31C8 012DF463		bleu	a0,$t1,a2h1; less than '9'
FFFC31CC FF990913		sub		a0,a0,#7	; shift 'A' to '9'+1
                        	a2h1:
FFFC31D0 FD090913		sub		a0,a0,#'0'
FFFC31D4 00F97913		and		a0,a0,#15	; make sure a nybble
FFFC31D8 00008067		ret
                        	
                        	GetFilename:
FFFC31DC FFC70713		sub		$sp,$sp,#4
FFFC31E0 00172023		sw		$ra,[$sp]
FFFC31E4 7E1000EF		call	TSTC
FFFC31E8 00000022		dw		'"'
FFFC31EC 04000C63		bra		gfn1
FFFC31F0 000061B3		mov		r3,r0
                        	gfn2:
FFFC31F4 000E4903		lbu		a0,[$t2]		; get text character
FFFC31F8 001E0E13		add		$t2,$t2,#1
FFFC31FC 02206D93		ldi		$t1,#'"'
FFFC3200 03B90263		beq		a0,$t1,gfn3
FFFC3204 02090063		beq		a0,r0,gfn3
FFFC3208 6D218023		sb		a0,FILENAME[r3]
FFFC320C 00118193		add		r3,r3,#1
FFFC3210 04006D93		ldi		$t1,#64
FFFC3214 FFB1E0E3		bltu	r3,$t1,gfn2
FFFC3218 00072083		lw		$ra,[$sp]
FFFC321C 00470713		add		$sp,$sp,#4
FFFC3220 00008067		ret
                        	gfn3:
FFFC3224 02006913		ldi		a0,#' '
FFFC3228 6D218023		sb		a0,FILENAME[r3]
FFFC322C 00118193		add		r3,r3,#1
FFFC3230 04006D93		ldi		$t1,#64
FFFC3234 FFB1E8E3		bltu	r3,$t1,gfn3
FFFC3238 00072083		lw		$ra,[$sp]
FFFC323C 00470713		add		$sp,$sp,#4
FFFC3240 00008067		ret
                        	gfn1:
FFFC3244 E7CFF06F		jmp		WSTART
                        	
                        	LOAD3:
FFFC3248 F95FF0EF		call	GetFilename
FFFC324C 00000637		call	AUXIN_INIT
FFFC3250 2D2600E7
FFFC3254 EC5FF06F		jmp		LOAD
                        	
                        	;	call		OREXPR		;evaluate the following expression
                        	;	ld		a0,#5000
FFFC3258 000019B7		ld		a1,#$E00
FFFC325C E0098993
FFFC3260 00000637		call	SDReadSector
FFFC3264 2D3600E7
FFFC3268 00190913		add		a0,a0,#1
FFFC326C 000029B7		ldi		a1,#TXTBGN
FFFC3270 80098993
                        	LOAD4:
FFFC3274 FFC70713		sub		$sp,$sp,#4
FFFC3278 01272023		sw		a0,[$sp]
FFFC327C 00000637		call	SDReadSector
FFFC3280 2D3600E7
FFFC3284 20098993		add		a1,a1,#512
FFFC3288 00072903		lw		a0,[$sp]
FFFC328C 00470713		add		$sp,$sp,#4
FFFC3290 00190913		add		a0,a0,#1
FFFC3294 00002237		ldi		r4,#TXTBGN
FFFC3298 80020213
FFFC329C 00010637		add		r4,r4,#65536
FFFC32A0 00060613
FFFC32A4 00460233
FFFC32A8 FC49C6E3		blt		a1,r4,LOAD4
                        	LOAD5:
FFFC32AC E0000A63		bra		WSTART
                        	
                        	
                        	SAVE3:
FFFC32B0 F2DFF0EF		call	GetFilename
FFFC32B4 00000637		call	AUXOUT_INIT
FFFC32B8 2D6600E7
FFFC32BC 0600006F		jmp		SAVE
                        	
FFFC32C0 208000EF		call	OREXPR		;evaluate the following expression
                        	;	lda		#5000		; starting sector
FFFC32C4 000019B7		ldi		a1,#$E00	; starting address to write
FFFC32C8 E0098993
FFFC32CC 00000637		call	SDWriteSector
FFFC32D0 2D8600E7
FFFC32D4 00190913		add		a0,a0,#1
FFFC32D8 000029B7		ldi		a1,#TXTBGN
FFFC32DC 80098993
                        	SAVE4:
FFFC32E0 FFC70713		sub		$sp,$sp,#4
FFFC32E4 01272023		sw		a0,[$sp]
FFFC32E8 00000637		call	SDWriteSector
FFFC32EC 2D8600E7
FFFC32F0 20098993		add		a1,a1,#512
FFFC32F4 00072903		lw		a0,[$sp]
FFFC32F8 00470713		add		$sp,$sp,#4
FFFC32FC 00190913		add		a0,a0,#1
FFFC3300 00002237		ldi		r4,#TXTBGN
FFFC3304 80020213
FFFC3308 00010637		add		r4,r4,#65536
FFFC330C 00060613
FFFC3310 00460233
FFFC3314 FC49C6E3		blt		a1,r4,SAVE4
FFFC3318 DA000463		bra		WSTART
                        	
                        	SAVE:
FFFC331C 00002E37		ldi		$t2,#TXTBGN	;set pointer to start of prog. area
FFFC3320 800E0E13
FFFC3324 70402E83		lw		$t3,TXTUNF	;set pointer to end of prog. area
                        	SAVE1:
FFFC3328 054000EF		call	AUXOCRLF    ; send out a CR & LF (CP/M likes this)
FFFC332C 03CEC863		bgt		$t2,$t3,SAVEND; are we finished?
FFFC3330 03A06913		ldi		a0,#':'		; if not, start a line
FFFC3334 CDCFF0EF		call	GOAUXO
FFFC3338 000E2903		lw		a0,[$t2]		; get line number
FFFC333C 004E0E13		add		$t2,$t2,#4
FFFC3340 060000EF		call	PWORD       ; output line number as 5-digit hex
                        	SAVE2:
FFFC3344 000E4903		lbu		a0,[$t2]		; get a text char.
FFFC3348 001E0E13		add		$t2,$t2,#1
FFFC334C 00D06D93		ldi		$t1,#CR
FFFC3350 FDB90CE3		beq		a0,$t1,SAVE1	; is it the end of the line? if so, send CR & LF and start new line
FFFC3354 CBCFF0EF		call	GOAUXO		; send it out
FFFC3358 FE0006E3		bra		SAVE2		; go back for more text
                        	SAVEND:
FFFC335C 04006913		ldi		a0,#'@'		; send end-of-program indicator
FFFC3360 CB0FF0EF		call	GOAUXO
FFFC3364 018000EF		call	AUXOCRLF    ; followed by a CR & LF
FFFC3368 01A06913		ldi		a0,#$1A		; and a control-Z to end the CP/M file
FFFC336C CA4FF0EF		call	GOAUXO
FFFC3370 00000637		call	AUXOUT_FLUSH
FFFC3374 2DF600E7
FFFC3378 D4000463		bra		WSTART		; then go do a warm start
                        	
                        	; output a CR LF sequence to auxillary output
                        	; Registers Affected
                        	;   r3 = LF
                        	AUXOCRLF:
FFFC337C FFC70713		sub		$sp,$sp,#4
FFFC3380 00172023		sw		$ra,[$sp]
FFFC3384 00D06913	  ldi		a0,#CR
FFFC3388 C88FF0EF	  call	GOAUXO
FFFC338C 00A06913	  ldi		a0,#LINEFD
FFFC3390 C80FF0EF	  call	GOAUXO
FFFC3394 00072083	  lw		$ra,[$sp]
FFFC3398 00470713	  add		$sp,$sp,#4
FFFC339C 00008067	  ret
                        	
                        	
                        	; output a word in hex format
                        	; tricky because of the need to reverse the order of the chars
                        	PWORD:
FFFC33A0 FF870713		sub		$sp,$sp,#8
FFFC33A4 00572023		sw		r5,[$sp]
FFFC33A8 00172223		sw		$ra,4[$sp]
FFFC33AC 7A206293		ldi		r5,#NUMWKA+14
FFFC33B0 00096233		mov		r4,a0		; r4 = value
                        	pword1:
FFFC33B4 00026933	  mov   a0,r4	    ; a0 = value
FFFC33B8 00425213	  srl		r4,r4,#4	; shift over to next nybble
FFFC33BC 038000EF	  call	toAsciiHex  ; convert LS nybble to ascii hex
FFFC33C0 01228023	  sb    a0,[r5]		; save in work area
FFFC33C4 FFF28293	  sub		r5,r5,#1
FFFC33C8 79406D93	  ldi		$t1,#NUMWKA
FFFC33CC FFB2D4E3		bge		r5,$t1,pword1
                        	pword2:
FFFC33D0 00128293	  add		r5,r5,#1
FFFC33D4 0002C903	  lbu   a0,[r5]     ; get char to output
FFFC33D8 C38FF0EF		call	GOAUXO		; send it
FFFC33DC 7A206D93		ldi		$t1,#NUMWKA+14
FFFC33E0 FFB2C8E3		blt		r5,$t1,pword2
FFFC33E4 00072283		lw		r5,[$sp]
FFFC33E8 00472083		lw		$ra,4[$sp]
FFFC33EC 00870713		add		$sp,$sp,#8
FFFC33F0 00008067		ret
                        	
                        	; convert nybble in a1 to ascii hex chaa1
                        	; a1 = character to convert
                        	
                        	toAsciiHex:
FFFC33F4 00F97913		and		a0,a0,#15	; make sure it's a nybble
FFFC33F8 00A06D93		ldi		$t1,#10
FFFC33FC 01B94463		blt		a0,$t1,tah1	; > 10 ?
FFFC3400 00790913		add		a0,a0,#7	; bump it up to the letter 'A'
                        	tah1:
FFFC3404 03090913		add		a0,a0,#'0'	; bump up to ascii '0'
FFFC3408 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	; *** POKE ***
                        	;
                        	; 'POKE expr1,expa1' stores the byte from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEW expr1,expa1' stores the word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEH expr1,expa1' stores the half-word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	;******************************************************************
                        	;
                        	POKE:
FFFC340C 0BC000EF		call	OREXPR		; get the memory address
FFFC3410 5B5000EF		call	TSTC		; it must be followed by a comma
FFFC3414 0000002C		dw		','
FFFC3418 06000C63		bra		PKER
FFFC341C FFC70713		sub		$sp,$sp,#4
FFFC3420 01272023		sw		a0,[$sp]	; save the address
FFFC3424 0A4000EF		call	OREXPR		; get the byte to be POKE'd
FFFC3428 00072983		lw		a1,[$sp]	; get the address back
FFFC342C 00470713		add		$sp,$sp,#4
FFFC3430 01298023		sb		a0,[a1]		; store the byte in memory
FFFC3434 A2DFF06F		jmp		FINISH
                        	
                        	POKEW:
FFFC3438 090000EF		call	OREXPR		; get the memory address
FFFC343C 589000EF		call	TSTC		; it must be followed by a comma
FFFC3440 0000002C		dw		','
FFFC3444 04000663		bra		PKER
FFFC3448 FFC70713		sub		$sp,$sp,#4
FFFC344C 01272023		sw		a0,[$sp]	; save the address
FFFC3450 078000EF		call	OREXPR		; get the byte to be POKE'd
FFFC3454 00072983		lw		a1,[$sp]	; get the address back
FFFC3458 00470713		add		$sp,$sp,#4
FFFC345C 0129A023		sw		a0,[a1]		; store the byte in memory
FFFC3460 A01FF06F		jmp		FINISH
                        	
                        	POKEH:
FFFC3464 064000EF		call	OREXPR		; get the memory address
FFFC3468 55D000EF		call	TSTC		; it must be followed by a comma
FFFC346C 0000002C		dw		','
FFFC3470 02000063		bra		PKER
FFFC3474 FFC70713		sub		$sp,$sp,#4
FFFC3478 01272023		sw		a0,[$sp]	; save the address
FFFC347C 04C000EF		call	OREXPR		; get the byte to be POKE'd
FFFC3480 00072983		lw		a1,[$sp]	; get the address back
FFFC3484 00470713		add		$sp,$sp,#4
FFFC3488 01299023		sh		a0,[a1]		; store the byte in memory
FFFC348C 9D5FF06F		jmp		FINISH
                        	
                        	PKER:
FFFC3490 FFFC4937		ldi		a0,#msgComma
FFFC3494 65290913
FFFC3498 0890006F		jmp		ERROR		; if no comma, say "What?"
                        	
                        	;******************************************************************
                        	; 'SYSX expr' jumps to the machine language subroutine whose
                        	; starting address is specified by 'expr'.  The subroutine can use
                        	; all registers but must leave the stack the way it found it.
                        	; The subroutine returns to the interpreter by executing an RTS.
                        	;******************************************************************
                        	
                        	SYSX:
FFFC349C 02C000EF		call	OREXPR		; get the subroutine's address
FFFC34A0 00081863		bne		v0,r0,sysx1; make sure we got a valid address
FFFC34A4 FFFC4937		ld		a0,#msgSYSBad
FFFC34A8 6A390913
FFFC34AC 0750006F		jmp		ERROR
                        	sysx1:
FFFC34B0 FFC70713		sub		$sp,$sp,#4
FFFC34B4 01C72023		sw		$t2,[$sp]	; save the text pointer
FFFC34B8 000800E7		call	[v0]			; jump to the subroutine
FFFC34BC 00072E03		lw		$t2,[$sp]	; restore the text pointer
FFFC34C0 00470713		add		$sp,$sp,#4
FFFC34C4 99DFF06F		jmp		FINISH
                        	
                        	;******************************************************************
                        	; *** EXPR ***
                        	;
                        	; 'EXPR' evaluates arithmetical or logical expressions.
                        	; <OREXPR>::= <ANDEXPR> OR <ANDEXPR> ...
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	; <EXPR>::=<ADDEXPR>
                        	;	   <ADDEXPR><rel.op.><ADDEXPR>
                        	; where <rel.op.> is one of the operators in TAB8 and the result
                        	; of these operations is 1 if true and 0 if false.
                        	; <ADDEXPR>::=(+ or -)<MULEXPR>(+ or -)<MULEXPR>(...
                        	; where () are optional and (... are optional repeats.
                        	; <MULEXPR>::=<FUNCEXPR>( <* or /><FUNCEXPR> )(...
                        	; <FUNCEXPR>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                        	; as an index, functions can have an <EXPR> as arguments, and
                        	; <FUNCEXPR> can be an <EXPR> in parenthesis.
                        	;
                        	
                        	; <OREXPR>::=<ANDEXPR> OR <ANDEXPR> ...
                        	;
                        	OREXPR:
FFFC34C8 FF470713		sub		$sp,$sp,#12
FFFC34CC 00172023		sw		$ra,[$sp]
FFFC34D0 00372223		sw		r3,4[$sp]
FFFC34D4 00472423		sw		r4,8[$sp]
FFFC34D8 058000EF		call	ANDEXPR		; get first <ANDEXPR>
                        	XP_OR1:
FFFC34DC FF870713		sub		$sp,$sp,#8
FFFC34E0 01072023		sw		$v0,[$sp]		; save <ANDEXPR> value
FFFC34E4 01172223		sw		$v1,4[$sp]	; save type
FFFC34E8 FFFC3EB7		ldi		$t3,#TAB10	; look up a logical operator
FFFC34EC B1EE8E93
FFFC34F0 FFFC3F37		ldi		$t4,#TAB10_1
FFFC34F4 B8EF0F13
FFFC34F8 EB8FF06F		jmp		EXEC		; go do it
                        	XP_OR:
FFFC34FC 034000EF	  call	ANDEXPR
FFFC3500 00072903	  lw		$a0,[$sp]
FFFC3504 00870713	  add		$sp,$sp,#8
FFFC3508 01286833	  or    v0,v0,a0
FFFC350C FC0008E3	  bra   XP_OR1
                        	XP_ORX:
FFFC3510 00072803	  lw		$v0,[$sp]
FFFC3514 00472883	  lw		$v1,4[$sp]
FFFC3518 00870713	  add		$sp,$sp,#8
FFFC351C 00072083		lw		$ra,[$sp]
FFFC3520 00472183		lw		r3,4[$sp]
FFFC3524 00872203		lw		r4,8[$sp]
FFFC3528 00C70713		add		$sp,$sp,#12
FFFC352C 00008067	  ret
                        	
                        	
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	;
                        	ANDEXPR:
FFFC3530 FFC70713		sub		$sp,$sp,#4
FFFC3534 00172023		sw		$ra,[$sp]
FFFC3538 0E8000EF		call	EXPR		; get first <EXPR>
                        	XP_AND1:
FFFC353C FF870713		sub		$sp,$sp,#8
FFFC3540 01072023		sw		$v0,[$sp]		; save <EXPR> value
FFFC3544 01172223		sw		$v1,4[$sp]	; save type
FFFC3548 FFFC3EB7		ldi		$t3,#TAB9		; look up a logical operator
FFFC354C B1AE8E93
FFFC3550 FFFC3F37		ldi		$t4,#TAB9_1
FFFC3554 B8AF0F13
FFFC3558 E58FF06F		jmp		EXEC		; go do it
                        	XP_AND:
FFFC355C 0C4000EF	  call	EXPR
FFFC3560 00072903	  lw		$a0,[$sp]
FFFC3564 00870713	  add		$sp,$sp,#8
FFFC3568 01287833	  and   v0,v0,a0
FFFC356C FC0008E3	  bra   XP_AND1
                        	XP_ANDX:
FFFC3570 00072803	  lw		$v0,[$sp]
FFFC3574 00472883	  lw		$v1,4[$sp]
FFFC3578 00870713	  add		$sp,$sp,#8
FFFC357C 00072083		lw		$ra,[$sp]
FFFC3580 00470713		add		$sp,$sp,#4
FFFC3584 00008067	  ret
                        	
                        	
                        	; Determine if the character is a digit
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if digit, otherwise 0
                        	;
                        	isDigit:
FFFC3588 03006D93		ldi		$t1,#'0'
FFFC358C 01B94A63		blt		a0,$t1,isDigitFalse
FFFC3590 03906D93		ldi		$t1,#'9'
FFFC3594 012DC663		bgt		a0,$t1,isDigitFalse
FFFC3598 00106813		ldi		v0,#1
FFFC359C 00008067	  ret
                        	isDigitFalse:
FFFC35A0 00006833	  mov		v0,r0
FFFC35A4 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphabetic
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlpha:
FFFC35A8 04106D93		ldi		$t1,#'A'
FFFC35AC 03B94263		blt		a0,$t1,isAlphaFalse
FFFC35B0 05A06D93		ldi		$t1,#'Z'
FFFC35B4 012DDA63		ble		a0,$t1,isAlphaTrue
FFFC35B8 06106D93		ldi		$t1,#'a'
FFFC35BC 01B94A63		blt		a0,$t1,isAlphaFalse
FFFC35C0 07A06D93		ldi		$t1,#'z'
FFFC35C4 012DC663		bgt		a0,$t1,isAlphaFalse
                        	isAlphaTrue:
FFFC35C8 00106813	  ldi		v0,#1
FFFC35CC 00008067	  ret
                        	isAlphaFalse:
FFFC35D0 00006833	  mov		v0,r0
FFFC35D4 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphanumeric
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlnum:
FFFC35D8 FFC70713		sub		$sp,$sp,#4
FFFC35DC 00172023		sw		$ra,[$sp]
FFFC35E0 FA9FF0EF	  call	isDigit
FFFC35E4 00081463		bne		v0,r0,isDigitx	; if it is a digit
FFFC35E8 FC1FF0EF	  call  isAlpha
                        	isDigitx:
FFFC35EC 00072083		lw		$ra,[$sp]
FFFC35F0 00470713		add		$sp,$sp,#4
FFFC35F4 00008067	  ret
                        	
                        	FORCEFIT:
FFFC35F8 03198263		beq		a1,v1,.0001				; types match
FFFC35FC 00006D13		ldi		$t0,#0
FFFC3600 01A98663		beq		a1,$t0,.intAnd
                        	;	itof	$f1,$v0
FFFC3604 00106913		ldi		a0,#1
FFFC3608 00008067		ret
                        	.intAnd:
FFFC360C 00106D13		ldi		$t0,#1
FFFC3610 01A89663		bne		$v1,$t0,.0001
                        	;	itof	$f2,$a1
FFFC3614 00106993		ldi		$a1,#1
FFFC3618 00008067		ret
                        	.0001:
FFFC361C 00008067		ret
                        	
                        	EXPR:
FFFC3620 FFC70713		sub		$sp,$sp,#4
FFFC3624 00172023		sw		$ra,[$sp]
FFFC3628 11C000EF		call	ADDEXPR
FFFC362C FF870713		sub		$sp,$sp,#8				; save <ADDEXPR> value
FFFC3630 01072023		sw		v0,[$sp]
FFFC3634 01172223		sw		v1,4[$sp]					; save type
FFFC3638 FFFC3EB7		ldi		$t3,#TAB8		; look up a relational operator
FFFC363C B10E8E93
FFFC3640 FFFC3F37		ldi		$t4,#TAB8_1
FFFC3644 B7CF0F13
FFFC3648 D68FF06F		jmp		EXEC		; go do it
                        	XP11:
FFFC364C 00072903		lw		a0,[$sp]
FFFC3650 00472983		lw		a1,4[$sp]
FFFC3654 00870713		add		$sp,$sp,#8
FFFC3658 0C4000EF		call	XP18	; is it ">="?
FFFC365C 09095A63		bge		a0,v0,XPRT1	; no, return v0=1
FFFC3660 06000E63		bra		XPRT0	; else return v0=0
                        	XP12:
FFFC3664 00072903		lw		a0,[$sp]
FFFC3668 00472983		lw		a1,4[$sp]
FFFC366C 00870713		add		$sp,$sp,#8
FFFC3670 0AC000EF		call	XP18	; is it "<>"?
FFFC3674 07091E63		bne		a0,v0,XPRT1	; no, return a1=1
FFFC3678 06000263		bra		XPRT0	; else return a1=0
                        	XP13:
FFFC367C 00072903		lw		a0,[$sp]
FFFC3680 00472983		lw		a1,4[$sp]
FFFC3684 00870713		add		$sp,$sp,#8
FFFC3688 094000EF		call	XP18	; is it ">"?
FFFC368C 07284263		bgt		a0,v0,XPRT1	; no, return a1=1
FFFC3690 04000663		bra		XPRT0	; else return a1=0
                        	XP14:
FFFC3694 00072903		lw		a0,[$sp]
FFFC3698 00472983		lw		a1,4[$sp]
FFFC369C 00870713		add		$sp,$sp,#8
FFFC36A0 07C000EF		call	XP18	; is it "<="?
FFFC36A4 05285663		ble		a0,v0,XPRT1	; no, return a1=1
FFFC36A8 02000A63		bra		XPRT0	; else return a1=0
                        	XP15:
FFFC36AC 00072903		lw		a0,[$sp]
FFFC36B0 00472983		lw		a1,4[$sp]
FFFC36B4 00870713		add		$sp,$sp,#8
FFFC36B8 064000EF		call	XP18	; is it "="?
FFFC36BC 03090A63		beq		a0,v0,XPRT1	; if not, return a1=1
FFFC36C0 00000E63		bra		XPRT0	; else return a1=0
                        	XP16:
FFFC36C4 00072903		lw		a0,[$sp]
FFFC36C8 00472983		lw		a1,4[$sp]
FFFC36CC 00870713		add		$sp,$sp,#8
FFFC36D0 04C000EF		call	XP18	; is it "<"?
FFFC36D4 01094E63		blt		a0,v0,XPRT1	; if not, return a1=1
FFFC36D8 00000263		bra		XPRT0	; else return a1=0
                        	XPRT0:
FFFC36DC 00006833		mov		v0,x0   ; return a0=0 (false)
FFFC36E0 000068B3		mov		v1,x0		; type = int
FFFC36E4 00072083		lw		$ra,[$sp]
FFFC36E8 00470713		add		$sp,$sp,#4
FFFC36EC 00008067		ret
                        	XPRT1:
FFFC36F0 00106813		ldi		v0,#1	; return a0=1 (true)
FFFC36F4 00006893		ldi		v1,#0	; type = int
FFFC36F8 00072083		lw		$ra,[$sp]
FFFC36FC 00470713		add		$sp,$sp,#4
FFFC3700 00008067		ret
                        	
                        	XP17:				; it's not a rel. operator
FFFC3704 00072803		lw		v0,[$sp]; return a1=<ADDEXPR>
FFFC3708 00472883		lw		v1,4[$sp]
FFFC370C 00870713		add		$sp,$sp,#8
FFFC3710 00072083		lw		$ra,[$sp]
FFFC3714 00470713		add		$sp,$sp,#4
FFFC3718 00008067		ret
                        	
                        	XP18:
FFFC371C FF470713		sub		$sp,$sp,#12
FFFC3720 00172023		sw		$ra,[$sp]
FFFC3724 01072223		sw		v0,4[$sp]
FFFC3728 01172423		sw		v1,8[$sp]
FFFC372C 018000EF		call	ADDEXPR		; do a second <ADDEXPR>
FFFC3730 00472903		lw		a0,4[$sp]
FFFC3734 00872983		lw		a1,8[$sp]
FFFC3738 00072083		lw		$ra,[$sp]
FFFC373C 00C70713		add		$sp,$sp,#12
FFFC3740 00008067		ret
                        	
                        	; <ADDEXPR>::=(+ or -)<MULEXPR>(+ or -)<MULEXPR>(...
                        	//message "ADDEXPR"
                        	ADDEXPR:
FFFC3744 FFC70713		sub		$sp,$sp,#4
FFFC3748 00172023		sw		$ra,[$sp]
FFFC374C 279000EF		call	TSTC		; negative sign?
FFFC3750 0000002D		dw		'-'
FFFC3754 00000C63		bra		XP21
FFFC3758 00006833		mov		v0,r0		; yes, fake '0-'
FFFC375C FF870713		sub		$sp,$sp,#8
FFFC3760 01072023		sw		v0,[$sp]
FFFC3764 01172223		sw		v1,4[$sp]
FFFC3768 04000863		bra		XP26
                        	XP21:
FFFC376C 259000EF		call	TSTC		; positive sign? ignore it
FFFC3770 0000002B		dw		'+'
FFFC3774 00000263		bra		XP22
                        	XP22:
FFFC3778 064000EF		call	MULEXPR		; first <MULEXPR>
                        	XP23:
FFFC377C FF870713		sub		$sp,$sp,#8; yes, save the value
FFFC3780 01072023		sw		v0,[$sp]
FFFC3784 01172223		sw		v1,4[$sp]	; and type
FFFC3788 23D000EF		call	TSTC		; add?
FFFC378C 0000002B		dw		'+'
FFFC3790 00000E63		bra		XP25
FFFC3794 048000EF		call	MULEXPR		; get the second <MULEXPR>
                        	XP24:
FFFC3798 00072903		lw		a0,[$sp]
FFFC379C 00472983		lw		a1,4[$sp]
FFFC37A0 00870713		add		$sp,$sp,#8
FFFC37A4 01280833		add		v0,v0,a0	; add it to the first <MULEXPR>
                        	;	BVS.L	QHOW		brnch if there's an overflow
FFFC37A8 FC000AE3		bra		XP23		; else go back for more operations
                        	XP25:
FFFC37AC 219000EF		call	TSTC		; subtract?
FFFC37B0 0000002D		dw		'-'
FFFC37B4 00000863		bra		XP45
                        	XP26:
FFFC37B8 024000EF		call	MULEXPR		; get second <MULEXPR>
FFFC37BC 41000833		sub		v0,r0,v0	; change its sign
FFFC37C0 FC000CE3		bra		XP24		; and do an addition
                        	XP45:
FFFC37C4 00072803		lw		v0,[$sp]
FFFC37C8 00472883		lw		v1,4[$sp]
FFFC37CC 00870713		add		$sp,$sp,#8
FFFC37D0 00072083		lw		$ra,[$sp]
FFFC37D4 00470713		add		$sp,$sp,#4
FFFC37D8 00008067		ret
                        	
                        	
                        	; <MULEXPR>::=<FUNCEXPR>( <* or /><FUNCEXPR> )(...
                        	
                        	MULEXPR:
FFFC37DC FFC70713		sub		$sp,$sp,#4
FFFC37E0 00172023		sw		$ra,[$sp]
FFFC37E4 094000EF		call	FUNCEXPR		; get first <FUNCEXPR>
                        	XP31:
FFFC37E8 FF870713		sub		$sp,$sp,#8
FFFC37EC 01072023		sw		v0,[$sp]; yes, save that first result
FFFC37F0 01172223		sw		v1,4[$sp]
FFFC37F4 1D1000EF		call	TSTC		; multiply?
FFFC37F8 0000002A		dw		'*'
FFFC37FC 00000E63		bra		XP34
FFFC3800 078000EF		call	FUNCEXPR		; get second <FUNCEXPR>
FFFC3804 00072903		lw		a0,[$sp]
FFFC3808 00472983		lw		a1,4[$sp]
FFFC380C 00870713		add		$sp,$sp,#8
FFFC3810 03280833		mul		v0,v0,a0	; multiply the two
FFFC3814 FC000AE3		bra		XP31        ; then look for more terms
                        	XP34:
FFFC3818 1AD000EF		call	TSTC		; divide?
FFFC381C 0000002F		dw		'/'
FFFC3820 00000E63		bra		XP35
FFFC3824 054000EF		call	FUNCEXPR		; get second <FUNCEXPR>
FFFC3828 00072903		lw		a0,[$sp]
FFFC382C 00472983		lw		a1,4[$sp]
FFFC3830 00870713		add		$sp,$sp,#8
FFFC3834 03284833		div		v0,v0,a0	; do the division
FFFC3838 FA0008E3		bra		XP31		; go back for any more terms
                        	XP35:
FFFC383C 189000EF		call	TSTC
FFFC3840 00000025		dw		'%'
FFFC3844 00000E63		bra		XP47
FFFC3848 030000EF		call	FUNCEXPR
FFFC384C 00072903		lw		a0,[$sp]
FFFC3850 00472983		lw		a1,4[$sp]
FFFC3854 00870713		add		$sp,$sp,#8
FFFC3858 03286833		rem		v0,v0,a0
FFFC385C F80006E3		bra		XP31
                        	XP47:
FFFC3860 00072803		lw		v0,[$sp]
FFFC3864 00472883		lw		v1,4[$sp]
FFFC3868 00870713		add		$sp,$sp,#8
FFFC386C 00072083		lw		$ra,[$sp]
FFFC3870 00470713		add		$sp,$sp,#4
FFFC3874 00008067		ret
                        	
                        	
                        	; Functions are called through FUNCEXPR
                        	; <FUNCEXPR>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	
                        	FUNCEXPR:
FFFC3878 FFC70713		sub		$sp,$sp,#4
FFFC387C 00172023		sw		$ra,[$sp]
FFFC3880 FFFC3EB7	  ldi		$t3,#TAB4		; find possible function
FFFC3884 ACFE8E93
FFFC3888 FFFC3F37	  ldi		$t4,#TAB4_1
FFFC388C B5AF0F13
FFFC3890 B20FF06F		jmp		EXEC        ; branch to function which does subsequent ret for FUNCEXPR
                        	XP40:                   ; we get here if it wasn't a function
FFFC3894 00006933		mov		a0,x0
FFFC3898 070000EF		call	TSTV
FFFC389C 00080A63		beq   v0,x0,XP41	; not a variable
FFFC38A0 00082803		lw		$v0,[$v0]		; if a variable, return its value in v0
FFFC38A4 00072083		lw		$ra,[$sp]
FFFC38A8 00470713		add		$sp,$sp,#4
FFFC38AC 00008067		ret
                        	XP41:
FFFC38B0 161000EF		call	TSTNUM		; or is it a number?
FFFC38B4 00089463		bne		v1,x0,XP46	; (if not, # of digits will be zero) if so, return it in v0
FFFC38B8 010000EF		call	PARN        ; check for (EXPR)
                        	XP46:
FFFC38BC 00072083		lw		$ra,[$sp]
FFFC38C0 00470713		add		$sp,$sp,#4
FFFC38C4 00008067		ret
                        	
                        	
                        	; Check for a parenthesized expression
                        	PARN:
FFFC38C8 FFC70713		sub		$sp,$sp,#4
FFFC38CC 00172023		sw		$ra,[$sp]	
FFFC38D0 0F5000EF		call	TSTC		; else look for ( OREXPR )
FFFC38D4 00000028		dw		'('
FFFC38D8 02000063		bra		XP43
FFFC38DC BEDFF0EF		call	OREXPR
FFFC38E0 0E5000EF		call	TSTC
FFFC38E4 00000029		dw		')'
FFFC38E8 00000863		bra		XP43
                        	XP42:
FFFC38EC 00072083		lw		$ra,[$sp]
FFFC38F0 00470713		add		$sp,$sp,#4
FFFC38F4 00008067		ret
                        	XP43:
FFFC38F8 00470713		add		$sp,$sp,#4		; get rid of return address
FFFC38FC FFFC4937		ldi		a0,#msgWhat
FFFC3900 5D890913
FFFC3904 41C0006F		jmp		ERROR
                        	
                        	
                        	; ===== Test for a valid variable name.  Returns Z=1 if not
                        	;	found, else returns Z=0 and the address of the
                        	;	variable in a0.
                        	; Parameters
                        	;		a0 = 1 = allocate if not found
                        	; Returns
                        	;		v0 = address of variable, zero if not found
                        	
                        	TSTV:
FFFC3908 FF870713		sub		$sp,$sp,#8
FFFC390C 00572023		sw		r5,[$sp]
FFFC3910 00172223		sw		$ra,4[$sp]
FFFC3914 000962B3		mov		r5,a0		; r5=allocate flag
FFFC3918 16D000EF		call	IGNBLK
FFFC391C 000E4903		lbu		a0,[$t2]		; look at the program text
FFFC3920 04006D93		ldi		$t1,#'@'
FFFC3924 07B94263		blt		a0,$t1,tstv_notfound	; C=1: not a variable
FFFC3928 03B91E63		bne		a0,$t1,TV1				; brnch if not "@" array
FFFC392C 001E0E13		add		$t2,$t2,#1	; If it is, it should be
FFFC3930 F99FF0EF		call	PARN		; followed by (EXPR) as its index.
                        	;	BCS.L	QHOW		say "How?" if index is too big
FFFC3934 00000263		bra		TV3
                        	TV3:
FFFC3938 FFC70713		sub		$sp,$sp,#4	; save the index
FFFC393C 01072023		sw		v0,[$sp]
FFFC3940 2D0000EF		call	SIZEX		; get amount of free memory
FFFC3944 00072983		lw		a1,[$sp]
FFFC3948 00470713		add		$sp,$sp,#4	; get back the index
FFFC394C 0109C663		blt		a1,v0,TV2		; see if there's enough memory
FFFC3950 00870713		add		$sp,$sp,#8
FFFC3954 3B80006F		jmp   QSORRY		; if not, say "Sorry"
                        	TV2:
FFFC3958 70802903		lw		a0,VARBGN	; put address of array element...
FFFC395C 41390833		sub   v0,a0,a1    ; into a0 (neg. offset is used)
FFFC3960 00000C63		bra   TSTVRT
                        	TV1:	
FFFC3964 038000EF	  call	getVarName      ; get variable name
FFFC3968 00080863	  beq   v0,x0,TSTVRT    ; if not, return v0=0
FFFC396C 00086933	  mov		a0,v0
FFFC3970 0002E9B3	  mov		a1,r5
FFFC3974 0D4000EF	  call	findVar     ; find or allocate
                        	TSTVRT:
FFFC3978 00072283		lw		r5,[$sp]
FFFC397C 00472083		lw		$ra,4[$sp]
FFFC3980 00870713		add		$sp,$sp,#8
FFFC3984 00008067		ret								; v0<>0 (if found)
                        	tstv_notfound:
FFFC3988 00072283		lw		r5,[$sp]
FFFC398C 00472083		lw		$ra,4[$sp]
FFFC3990 00870713		add		$sp,$sp,#8
FFFC3994 00006833		mov		v0,x0				; v0=0 if not found
FFFC3998 00008067	  ret
                        	
                        	; Get a variable name. Called after blanks have been ignored.
                        	;
                        	; Returns
                        	;   v0 = 3 character variable name + type
                        	;
                        	getVarName:
FFFC399C FF470713		sub		$sp,$sp,#12
FFFC39A0 00572023		sw		r5,[$sp]
FFFC39A4 00172223		sw		$ra,4[$sp]
FFFC39A8 000E4903	  lbu   a0,[$t2]		; get first character
FFFC39AC 01272423	  sw		a0,8[$sp]		; save off current name
FFFC39B0 BF9FF0EF	  call	isAlpha
FFFC39B4 08080063	  beq   v0,r0,gvn1
FFFC39B8 00206293	  ldi	  r5,#2       ; loop two more times
                        	
                        		; check for second/third character
                        	gvn4:
FFFC39BC 001E0E13		add		$t2,$t2,#1
FFFC39C0 000E4903		lbu   a0,[$t2]		; do we have another char ?
FFFC39C4 C15FF0EF		call	isAlnum
FFFC39C8 02080863		beq   v0,x0,gvn2	; nope
FFFC39CC 00872903		lw		a0,8[$sp]		; get varname
FFFC39D0 00891913		sll		a0,a0,#8
FFFC39D4 000E4983		lbu   a1,[$t2]
FFFC39D8 01396933		or    a0,a0,a1   	; add in new char
FFFC39DC 01272423	  sw		a0,8[$sp]		; save off current name again
FFFC39E0 FFF28293	  sub		r5,r5,#1
FFFC39E4 FC504CE3	  bgt		r5,x0,gvn4
                        	
                        	 	; now ignore extra variable name characters
                        	gvn6:
FFFC39E8 001E0E13		add		$t2,$t2,#1
FFFC39EC 000E4903		lbu   a0,[$t2]		; do we have another char ?
FFFC39F0 BE9FF0EF	  call  isAlnum
FFFC39F4 FE081AE3	  bne   v0,x0,gvn6	; keep looping as long as we have identifier chars
                        	
                        	  ; check for a variable type
                        	gvn2:
FFFC39F8 000E4983		lbu   a1,[$t2]
FFFC39FC 02506D93		ldi		$t1,#'%'
FFFC3A00 01B98A63		beq		a1,$t1,gvn3
FFFC3A04 02406D93		ldi		$t1,#'$'
FFFC3A08 01B98663		beq		a1,$t1,gvn3
FFFC3A0C FFFE0E13	  sub		$t2,$t2,#1
FFFC3A10 02E06993	  ldi		$a1,#'.'		; if no variable type assume float
                        	
                        	  ; insert variable type indicator and return
                        	gvn3:
FFFC3A14 001E0E13		add		$t2,$t2,#1
FFFC3A18 00872903		lw		a0,8[$sp]		; get varname
FFFC3A1C 00891913		sll		a0,a0,#8
FFFC3A20 01396833	  or    v0,a0,a1    ; add in variable type
FFFC3A24 00072283	  lw		r5,[$sp]
FFFC3A28 00472083	  lw		$ra,4[$sp]
FFFC3A2C 00C70713	  add		$sp,$sp,#12
FFFC3A30 00008067	  ret								; return a0 = varname
                        	
                        	  ; not a variable name
                        	gvn1:
FFFC3A34 00072283		lw		r5,[$sp]
FFFC3A38 00472083	  lw		$ra,4[$sp]
FFFC3A3C 00C70713		add		$sp,$sp,#12
FFFC3A40 00006833	  mov		v0,x0       ; return v0 = 0 if not a varname
FFFC3A44 00008067	  ret
                        	
                        	
                        	; Find variable
                        	;   a0 = varname
                        	;		a1 = allocate flag
                        	; Returns
                        	;   v0 = variable address, Z =0 if found / allocated, Z=1 if not found
                        	
                        	findVar:
FFFC3A48 FF870713		sub		$sp,$sp,#8
FFFC3A4C 00772023		sw		x7,[$sp]
FFFC3A50 00372223		sw		x3,4[$sp]
FFFC3A54 70802183	  lw    x3,VARBGN
                        	fv4:
FFFC3A58 0001A383	  lw    x7,[x3]     ; get varname / type
FFFC3A5C 02038663	  beq   x7,x0,fv3		; no more vars ?
FFFC3A60 02790863	  beq   a0,x7,fv1		; match ?
FFFC3A64 00818193		add		x3,x3,#8		; move to next var
FFFC3A68 70C02383	  lw    x7,VAREND		; 
FFFC3A6C FE71C6E3	  blt   x3,x7,fv4		; loop back to look at next var
                        	
                        	  ; variable not found
                        	  ; no more memory
FFFC3A70 00072383	  lw		x7,[$sp]
FFFC3A74 00472183	  lw		x3,4[$sp]
FFFC3A78 00870713	  add		$sp,$sp,#8
FFFC3A7C FFFC4937	  ldi		a0,#msgVarSpace
FFFC3A80 62690913
FFFC3A84 29C0006F	  jmp   ERROR
                        	
                        	  ; variable not found
                        	  ; allocate new ?
                        	fv3:
FFFC3A88 00098E63		beq		a1,x0,fv2
FFFC3A8C 0121A023	  sw    a0,[x3]     ; save varname / type
                        	  ; found variable
                        	  ; return address
                        	fv1:
FFFC3A90 00418813	  add		v0,x3,#4
FFFC3A94 00072383	  lw		x7,[$sp]
FFFC3A98 00472183	  lw		x3,4[$sp]
FFFC3A9C 00870713	  add		$sp,$sp,#8
FFFC3AA0 00008067	  ret			    			; v0 = address
                        	
                        	  ; didn't find var and not allocating
                        	fv2:
FFFC3AA4 00072383	  lw		x7,[$sp]
FFFC3AA8 00472183	  lw		x3,4[$sp]
FFFC3AAC 00870713	  add		$sp,$sp,#8
FFFC3AB0 00006833		mov		v0,x0				; v0 = nullptr
FFFC3AB4 00008067	  ret
                        	
                        	; The following functions are entered via a jump instruction with
                        	; the return address already saved.
                        	
                        	; ===== The PEEK function returns the byte stored at the address
                        	;	contained in the following expression.
                        	;
                        	PEEK:
FFFC3AB8 E11FF0EF		call	PARN		; get the memory address
FFFC3ABC 00080803		lb		v0,[v0]		; get the addressed byte
FFFC3AC0 000068B3		mov		v1,x0			; type = int
FFFC3AC4 00072083		lw		$ra,[$sp]
FFFC3AC8 00470713		add		$sp,$sp,#4
FFFC3ACC 00008067		ret
                        	PEEKW:
FFFC3AD0 DF9FF0EF		call	PARN		; get the memory address
FFFC3AD4 00082803		lw		v0,[v0]		; get the addressed word
FFFC3AD8 000068B3		mov		v1,x0			; type = int
FFFC3ADC 00072083		lw		$ra,[$sp]
FFFC3AE0 00470713		add		$sp,$sp,#4
FFFC3AE4 00008067		ret
                        	PEEKH:
FFFC3AE8 DE1FF0EF		call	PARN		; get the memory address
FFFC3AEC 00081803		lh		v0,[v0]		; get the addressed byte
FFFC3AF0 000068B3		mov		v1,x0			; type = int
FFFC3AF4 00072083		lw		$ra,[$sp]
FFFC3AF8 00470713		add		$sp,$sp,#4
FFFC3AFC 00008067		ret
                        	
                        	
                        	; user function call
                        	; call the user function with argument in a0, type in a1
                        	USRX:
FFFC3B00 FFC70713		sub		$sp,$sp,#4
FFFC3B04 01A72023		sw		$t0,[$sp]
FFFC3B08 DC1FF0EF		call	PARN		; get expression value
FFFC3B0C 00086933		mov		a0,v0
FFFC3B10 0008E9B3		mov		a1,v1
FFFC3B14 FFC70713		sub		$sp,$sp,#4	; save the text pointer
FFFC3B18 01C72023		sw		$t2,[$sp]
FFFC3B1C 7A002D03		lw		$t0,usrJmp
FFFC3B20 000D00E7		call	[$t0]			; get usr vector, jump to the subroutine
FFFC3B24 00072E03		lw		$t2,[$sp]	; restore the text pointer
FFFC3B28 00470713		add		$sp,$sp,#4
FFFC3B2C 00072D03		lw		$t0,[$sp]
FFFC3B30 00470713		add		$sp,$sp,#4
FFFC3B34 00072083		lw		$ra,[$sp]
FFFC3B38 00470713		add		$sp,$sp,#4
FFFC3B3C 00008067		ret
                        	
                        	
                        	; ===== The RND function returns a random number from 1 to
                        	;	the value of the following expression in D0.
                        	;
                        	RND:
FFFC3B40 D89FF0EF		call	PARN		; get the upper limit
FFFC3B44 04080063		beq		v0,r0,rnd2	; it must be positive and non-zero
FFFC3B48 02084663		blt		v0,r0,rnd1
FFFC3B4C 000869B3		mov		a1,v0
FFFC3B50 000868B3		mov		v1,v0
FFFC3B54 00000637		call	gen_rand	; generate a random number
FFFC3B58 321600E7
FFFC3B5C 03186833		rem		v0,v0,v1
FFFC3B60 00180813		add		v0,v0,#1
FFFC3B64 000068B3		mov		v1,x0
FFFC3B68 00072083		lw		$ra,[$sp]
FFFC3B6C 00470713		add		$sp,$sp,#4
FFFC3B70 00008067		ret
                        	rnd1:
FFFC3B74 FFFC4937		ldi		a0,#msgRNDBad
FFFC3B78 69090913
FFFC3B7C 00470713		add		$sp,$sp,#4
FFFC3B80 1A00006F		jmp		ERROR
                        	rnd2:
FFFC3B84 00000637		call	gen_rand	; generate a random number
FFFC3B88 321600E7
FFFC3B8C 000068B3		mov		v1,x0
FFFC3B90 00072083		lw		$ra,[$sp]
FFFC3B94 00470713		add		$sp,$sp,#4
FFFC3B98 00008067		ret
                        	
                        	; ===== The ABS function returns an absolute value in a1.
                        	;
                        	ABS:
FFFC3B9C D2DFF0EF		call	PARN		; get the following expr.'s value
FFFC3BA0 00084863		blt		v0,r0,ABS1
FFFC3BA4 00072083		lw		$ra,[$sp]
FFFC3BA8 00470713		add		$sp,$sp,#4
FFFC3BAC 00008067		ret
                        	ABS1:
FFFC3BB0 41000833		sub		v0,x0,v0
FFFC3BB4 00072083		lw		$ra,[$sp]
FFFC3BB8 00470713		add		$sp,$sp,#4
FFFC3BBC 00008067		ret
                        	
                        	
                        	;==== The TICK function returns the cpu tick value in a0.
                        	;
                        	TICKX:
FFFC3BC0 C0001873		csrrw	v0,#$C00,x0
FFFC3BC4 000068B3		mov		v1,x0
FFFC3BC8 00072083		lw		$ra,[$sp]
FFFC3BCC 00470713		add		$sp,$sp,#4
FFFC3BD0 00008067		ret
                        	
                        	; ===== The SGN function returns the sign in a0. +1,0, or -1
                        	;
                        	SGN:
FFFC3BD4 CF5FF0EF		call	PARN		; get the following expr.'s value
FFFC3BD8 000068B3		mov		v1,x0
FFFC3BDC 02080463		beq		v0,r0,SGN1
FFFC3BE0 00084A63		blt		v0,r0,SGN2
FFFC3BE4 00106813		ldi		v0,#1
FFFC3BE8 00072083		lw		$ra,[$sp]
FFFC3BEC 00470713		add		$sp,$sp,#4
FFFC3BF0 00008067		ret
                        	SGN2:
FFFC3BF4 FFF06813		ldi		v0,#-1
FFFC3BF8 00072083		lw		$ra,[$sp]
FFFC3BFC 00470713		add		$sp,$sp,#4
FFFC3C00 00008067		ret
                        	SGN1:
FFFC3C04 00072083		lw		$ra,[$sp]
FFFC3C08 00470713		add		$sp,$sp,#4
FFFC3C0C 00008067		ret	
                        	
                        	; ===== The SIZE function returns the size of free memory in v0.
                        	; does not consider memory used by @()
                        	;
                        	SIZEX:
FFFC3C10 70802803		lw		v0,VARBGN	; get the number of free bytes...
FFFC3C14 70402883		lw		v1,TXTUNF	; between 'TXTUNF' and 'VARBGN'
FFFC3C18 41180833		sub		v0,v0,v1
FFFC3C1C 000068B3		mov		v1,x0			; type = int
FFFC3C20 00072083		lw		$ra,[$sp]
FFFC3C24 00470713		add		$sp,$sp,#4
FFFC3C28 00008067		ret					; return the number in v0
                        	
                        	
                        	;******************************************************************
                        	;
                        	; *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                        	;
                        	; 'SETVAL' expects a variable, followed by an equal sign and then
                        	; an expression.  It evaluates the expression and sets the variable
                        	; to that value.
                        	;
                        	; returns
                        	; a1 = variable's address
                        	;
                        	SETVAL:
FFFC3C2C FFC70713		sub		$sp,$sp,#4
FFFC3C30 00172023		sw		$ra,[$sp]
FFFC3C34 00106913	  ldi		a0,#1		; allocate var
FFFC3C38 CD1FF0EF	  call	TSTV		; variable name?
FFFC3C3C 00081A63	  bne		v0,x0,.sv2
FFFC3C40 FFFC4937	 	ldi		a0,#msgVar
FFFC3C44 67A90913
FFFC3C48 00470713		add		$sp,$sp,#4
FFFC3C4C 0D40006F	 	jmp		ERROR 
                        	.sv2:
FFFC3C50 FFC70713		sub		$sp,$sp,#4
FFFC3C54 01072023		sw		v0,[$sp]	; save the variable's address
FFFC3C58 56C000EF		call	TSTC			; get past the "=" sign
FFFC3C5C 0000003D		dw		'='
FFFC3C60 02000663		bra		SV1
FFFC3C64 865FF0EF		call	OREXPR		; evaluate the expression
FFFC3C68 00072983		lw		a1,[$sp]	; get back the variable's address
FFFC3C6C 00470713		add		$sp,$sp,#4
FFFC3C70 0109A023		sw    v0,[a1]   ; and save value in the variable
FFFC3C74 0009E833		mov		v0,a1			; return v0 = variable address
FFFC3C78 FFC9A883		lw		v1,-4[a1]
FFFC3C7C 0FF8F893		and		v1,v1,#$FF
FFFC3C80 00072083		lw		$ra,[$sp]
FFFC3C84 00470713		add		$sp,$sp,#4
FFFC3C88 00008067		ret
                        	SV1:
FFFC3C8C 00470713		add		$sp,$sp,#4
FFFC3C90 0880006F	  jmp	  QWHAT		; if no "=" sign
                        	
                        	
                        	; 'FIN' checks the end of a command.  If it ended with ":",
                        	; execution continues.	If it ended with a CR, it finds the
                        	; the next line and continues from there.
                        	;
                        	FIN:
FFFC3C94 FFC70713		sub		$sp,$sp,#4
FFFC3C98 00172023		sw		$ra,[$sp]
FFFC3C9C 528000EF		call	TSTC		; *** FIN ***
FFFC3CA0 0000003A		dw		':'
FFFC3CA4 00000663		bra		FI1
FFFC3CA8 00470713		add		$sp,$sp,#4	; if ":", discard return address
FFFC3CAC 820FF06F		jmp		RUNSML		; continue on the same line
                        	FI1:
FFFC3CB0 514000EF		call	TSTC		; not ":", is it a CR?
FFFC3CB4 0000000D		dw		CR
FFFC3CB8 00000663		bra		FI2
                        							; else return to the caller
FFFC3CBC 00470713		add		$sp,$sp,#4	; yes, purge return address
FFFC3CC0 FA5FE06F		jmp		RUNNXL		; execute the next line
                        	FI2:
FFFC3CC4 00072083		lw		$ra,[$sp]
FFFC3CC8 00470713		add		$sp,$sp,#4
FFFC3CCC 00008067		ret					; else return to the caller
                        	
                        	
                        	; 'ENDCHK' checks if a command is ended with a CR. This is
                        	; required in certain commands, such as GOTO, RETURN, STOP, etc.
                        	;
                        	; Check that there is nothing else on the line
                        	; Registers Affected
                        	;   a0
                        	;
                        	ENDCHK:
FFFC3CD0 FFC70713		sub		$sp,$sp,#4
FFFC3CD4 00172023		sw		$ra,[$sp]
FFFC3CD8 5AC000EF		call	IGNBLK
FFFC3CDC 000E4903		lbu		a0,[$t2]
FFFC3CE0 00D06D93		ldi		$t1,#CR
FFFC3CE4 01B90863		beq		a0,$t1,ec1	; does it end with a CR?
FFFC3CE8 FFFC4937		ldi		a0,#msgExtraChars
FFFC3CEC 74B90913
FFFC3CF0 0300006F		jmp		ERROR
                        	ec1:
FFFC3CF4 00072083		lw		$ra,[$sp]
FFFC3CF8 00470713		add		$sp,$sp,#4
FFFC3CFC 00008067		ret
                        	
                        	; 'ERROR' prints the string pointed to by a0. It then prints the
                        	; line pointed to by CURRNT with a "?" inserted at where the
                        	; old text pointer (should be on top of the stack) points to.
                        	; Execution of Tiny BASIC is stopped and a warm start is done.
                        	; If CURRNT is zero (indicating a direct command), the direct
                        	; command is not printed. If CURRNT is -1 (indicating
                        	; 'INPUT' command in progress), the input line is not printed
                        	; and execution is not terminated but continues at 'INPERR'.
                        	;
                        	; Related to 'ERROR' are the following:
                        	; 'QWHAT' saves text pointer on stack and gets "What?" message.
                        	; 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                        	; 'QSORRY' and 'ASORRY' do the same kind of thing.
                        	; 'QHOW' and 'AHOW' also do this for "How?".
                        	;
                        	TOOBIG:
FFFC3D00 FFFC4937		ldi		a0,#msgTooBig
FFFC3D04 73790913
FFFC3D08 00000C63		bra		ERROR
                        	QSORRY:
FFFC3D0C FFFC4937	  ldi		a0,#SRYMSG
FFFC3D10 5DF90913
FFFC3D14 00000663		bra	    ERROR
                        	QWHAT:
FFFC3D18 FFFC4937		ldi		a0,#msgWhat
FFFC3D1C 5D890913
                        	ERROR:
FFFC3D20 644000EF		call	PRMESG		; display the error message
FFFC3D24 71802903		lw		a0,CURRNT	; get the current line pointer
FFFC3D28 02090C63		beq		a0,r0,ERROR1	; if zero, do a warm start
FFFC3D2C FFF06D93		ldi		$t1,#-1
FFFC3D30 AFB90463		beq		a0,$t1,INPERR	; is the line no. pointer = -1? if so, redo input
FFFC3D34 000E4283		lbu		r5,[$t2]		; save the char. pointed to
FFFC3D38 000E0023		sb		x0,[$t2]		; put a zero where the error is
FFFC3D3C 71802903		lw		a0,CURRNT	; point to start of current line
FFFC3D40 428000EF		call	PRTLN		; display the line in error up to the 0
FFFC3D44 00096333		mov     r6,a0	    ; save off end pointer
FFFC3D48 005E0023		sb		r5,[$t2]		; restore the character
FFFC3D4C 03F06913		ldi		a0,#'?'		; display a "?"
FFFC3D50 AB9FE0EF		call	GOOUT
FFFC3D54 000069B3		mov		a1,r0		; stop char = 0
FFFC3D58 FFF30913		sub		a0,r6,#1	; point back to the error char.
FFFC3D5C 23C000EF		call	PRTSTG		; display the rest of the line
                        	ERROR1:
FFFC3D60 B61FE06F		jmp	    WSTART		; and do a warm start
                        	
                        	;******************************************************************
                        	;
                        	; *** GETLN *** FNDLN (& friends) ***
                        	;
                        	; 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                        	; the character in r3 (given by the caller), then it fills the
                        	; buffer and echos. It ignores LF's but still echos
                        	; them back. Control-H is used to delete the last character
                        	; entered (if there is one), and control-X is used to delete the
                        	; whole line and start over again. CR signals the end of a line,
                        	; and causes 'GETLN' to return.
                        	;
                        	;
                        	GETLN:
FFFC3D64 FF870713		sub		$sp,$sp,#8
FFFC3D68 00572023		sw		r5,[$sp]
FFFC3D6C 00172223		sw		$ra,4[$sp]
FFFC3D70 A99FE0EF		call	GOOUT		; display the prompt
FFFC3D74 00106913		ldi		a0,#1
                        	;	sw		a0,CursorFlash	; turn on cursor flash
FFFC3D78 02006913		ldi		a0,#' '		; and a space
FFFC3D7C A8DFE0EF		call	GOOUT
FFFC3D80 71C06E13		ldi		$t2,#BUFFER	; $t2 is the buffer pointer
                        	.GL1:
FFFC3D84 5B0000EF		call	CHKIO		; check keyboard
FFFC3D88 FE080EE3		beq		v0,x0,.GL1	; wait for a char. to come in
FFFC3D8C 00806D93		ldi		$t1,#CTRLH
FFFC3D90 05B80663		beq		v0,$t1,.GL3	; delete last character? if so
FFFC3D94 01806D93		ldi		$t1,#CTRLX
FFFC3D98 07B80663		beq		v0,$t1,.GL4	; delete the whole line?
FFFC3D9C 00D06D93		ldi		$t1,#CR
FFFC3DA0 01B80663		beq		v0,$t1,.GL2		; accept a CR
FFFC3DA4 02006D93		ldi		$t1,#' '
FFFC3DA8 FDB84EE3		blt		v0,$t1,.GL1	; if other control char., discard it
                        	.GL2:
FFFC3DAC 010E0023		sb		v0,[$t2]		; save the char.
FFFC3DB0 001E0E13		add		$t2,$t2,#1
FFFC3DB4 FFC70713		sub		$sp,$sp,#4
FFFC3DB8 01072023		sw		v0,[$sp]
FFFC3DBC 00086933		mov		$a0,$v0
FFFC3DC0 A49FE0EF		call	GOOUT		; echo the char back out
FFFC3DC4 00072803		lw		v0,[$sp]; get char back (GOOUT destroys a0)
FFFC3DC8 00470713		add		$sp,$sp,#4
FFFC3DCC 00D06D93		ldi		$t1,#CR
FFFC3DD0 07B80663		beq		v0,$t1,.GL7			; if it's a CR, end the line
FFFC3DD4 76F06D93		ldi		$t1,#BUFFER+BUFLEN-1
FFFC3DD8 FBBE46E3		blt		$t2,$t1,.GL1		; any more room? ; yes: get some more, else delete last char.
                        	.GL3:
FFFC3DDC 00806913		ldi		a0,#CTRLH	; delete a char. if possible
FFFC3DE0 A29FE0EF		call	GOOUT
FFFC3DE4 02006913		ldi		a0,#' '
FFFC3DE8 A21FE0EF		call	GOOUT
FFFC3DEC 71C06D93		ldi		$t1,#BUFFER
FFFC3DF0 F9CDDAE3		ble		$t2,$t1,.GL1	; any char.'s left?	; if not
FFFC3DF4 00806913		ldi		a0,#CTRLH		; if so, finish the BS-space-BS sequence
FFFC3DF8 A11FE0EF		call	GOOUT
FFFC3DFC FFFE0E13		sub		$t2,$t2,#1	; decrement the text pointer
FFFC3E00 F80002E3		bra		.GL1		; back for more
                        	.GL4:
FFFC3E04 000E6933		mov		a0,$t2		; delete the whole line
FFFC3E08 8E490293		sub		r5,a0,#BUFFER   ; figure out how many backspaces we need
FFFC3E0C 02028463		beq		r5,r0,.GL6		; if none needed, brnch
FFFC3E10 FFF28293		sub		r5,r5,#1		; loop count is one less
                        	.GL5:
FFFC3E14 00806913		ldi		a0,#CTRLH		; and display BS-space-BS sequences
FFFC3E18 9F1FE0EF		call	GOOUT
FFFC3E1C 02006913		ldi		a0,#' '
FFFC3E20 9E9FE0EF		call	GOOUT
FFFC3E24 00806913		ldi		a0,#CTRLH
FFFC3E28 9E1FE0EF		call	GOOUT
FFFC3E2C FFF28293		sub		r5,r5,#1
FFFC3E30 FE0292E3		bne		r5,r0,.GL5
                        	.GL6:
FFFC3E34 71C06E13		ldi		$t2,#BUFFER	; reinitialize the text pointer
FFFC3E38 F40006E3		bra		.GL1		; and go back for more
                        	.GL7:
FFFC3E3C 000E0023		sb		x0,[$t2]		; null terminate line
                        	;	sw		x0,CursorFlash	; turn off cursor flash
FFFC3E40 00A06913		ldi		a0,#LINEFD	; echo a LF for the CR
FFFC3E44 9C5FE0EF		call	GOOUT
FFFC3E48 00072283		lw		r5,[$sp]
FFFC3E4C 00472083		lw		$ra,4[$sp]
FFFC3E50 00870713		add		$sp,$sp,#8
FFFC3E54 00008067		ret
                        	
                        	
                        	; 'FNDLN' finds a line with a given line no. (in a0) in the
                        	; text save area.  $t3 is used as the text pointer. If the line
                        	; is found, $t3 will point to the beginning of that line
                        	; (i.e. the high byte of the line no.), and $v0 = 1.
                        	; If that line is not there and a line with a higher line no.
                        	; is found, $t3 points there and $v0 = 0. If we reached
                        	; the end of the text save area and cannot find the line, flags
                        	; $t3 = 0, $v0 = 0.
                        	; $v0=1 if line found
                        	; r0 = 1	<= line is found
                        	;	$t3 = pointer to line
                        	; r0 = 0    <= line is not found
                        	;	r9 = zero, if end of text area
                        	;	r9 = otherwise higher line number
                        	;
                        	; 'FNDLN' will initialize $t3 to the beginning of the text save
                        	; area to start the search. Some other entries of this routine
                        	; will not initialize $t3 and do the search.
                        	; 'FNDLNP' will start with $t3 and search for the line no.
                        	; 'FNDNXT' will bump $t3 by 4, find a CR and then start search.
                        	; 'FNDSKP' uses $t3 to find a CR, and then starts the search.
                        	; return Z=1 if line is found, r9 = pointer to line
                        	;
                        	; Parameters
                        	;	a0 = line number to find
                        	;
                        	FNDLN:
FFFC3E58 00100DB7		ldi		$t1,#$FFFFF
FFFC3E5C FFFD8D93
FFFC3E60 01B94863		blt		a0,$t1,fl1	; line no. must be < 65535
FFFC3E64 FFFC4937		ld		a0,#msgLineRange
FFFC3E68 66590913
FFFC3E6C EB5FF06F		jmp		ERROR
                        	fl1:
FFFC3E70 00002EB7		ldi		$t3,#TXTBGN	; init. the text save pointer
FFFC3E74 800E8E93
                        	
                        	FNDLNP:
FFFC3E78 70402F03		lw		$t4,TXTUNF	; check if we passed the end
FFFC3E7C 05EEF463		bgeu	$t3,$t4,FNDRET1; if so, return with r9=0,a0=0
FFFC3E80 FF870713		sub		$sp,$sp,#8	; push a0
FFFC3E84 01272023		sw		a0,[$sp]
FFFC3E88 00172223		sw		ra,4[$sp]
FFFC3E8C 000EE933		mov		a0,t3
FFFC3E90 2AC000EF		call	LoadWord		; get line number
FFFC3E94 00072903		lw		a0,[$sp]		; pop a0
FFFC3E98 00472083		lw		ra,4[$sp]
FFFC3E9C 00870713		add		$sp,$sp,#8
FFFC3EA0 03280663		beq		v0,a0,FNDRET2
FFFC3EA4 03286863		bltu	v0,a0,FNDNXT	; is this the line we want? no, not there yet
                        	FNDRET:
FFFC3EA8 004E8E93		add		$t3,$t3,#4	; find the next line, skip over line number
                        	.0001:
FFFC3EAC 000EC883		lbu		v1,[$t3]
FFFC3EB0 001E8E93		add		$t3,$t3,#1
FFFC3EB4 00D06D93		ldi		$t1,#CR
FFFC3EB8 FFB89AE3		bne		v1,$t1,.0001	; try to find a CR, keep looking
FFFC3EBC 00006833		mov		v0,x0	; line not found, but $t3=next line pointer
FFFC3EC0 00008067		ret
                        	FNDRET1:
                        	;	eor		r9,r9,r9	; no higher line
FFFC3EC4 00006833		mov		v0,x0	; line not found
FFFC3EC8 00008067		ret
                        	FNDRET2:
FFFC3ECC 00106813		ldi		v0,#1	; line found
FFFC3ED0 00008067		ret
                        	
                        	FNDNXT:
FFFC3ED4 004E8E93		add		$t3,$t3,#4	; find the next line
                        	
                        	FNDSKP:
FFFC3ED8 000EC883		lbu		v1,[$t3]
FFFC3EDC 001E8E93		add		$t3,$t3,#1
FFFC3EE0 00D06D93		ldi		$t1,#CR
FFFC3EE4 FFB89AE3		bne		v1,$t1,FNDSKP	; try to find a CR, keep looking
FFFC3EE8 F80008E3		bra		FNDLNP		; check if end of text
                        	
                        	
                        	;******************************************************************
                        	; 'MVUP' moves a block up from where a0 points to where a1 points
                        	; until a0=a2
                        	;
                        	MVUP1:
FFFC3EEC 00090203		lb		r4,[a0]
FFFC3EF0 00498023		sb		r4,[a1]
FFFC3EF4 00190913		add		a0,a0,#1
FFFC3EF8 00198993		add		a1,a1,#1
                        	MVUP:
FFFC3EFC FF4918E3		bne		a0,a2,MVUP1
FFFC3F00 00008067		ret
                        	
                        	
                        	; 'MVDOWN' moves a block down from where a0 points to where a1
                        	; points until a0=a2
                        	;
                        	MVDOWN1:
FFFC3F04 FFF90913		sub		a0,a0,#1
FFFC3F08 FFF98993		sub		a1,a1,#1
FFFC3F0C 00090203		lb		r4,[a0]
FFFC3F10 00498023		sb		r4,[a1]
                        	MVDOWN:
FFFC3F14 FF4918E3		bne		a0,a2,MVDOWN1
FFFC3F18 00008067		ret
                        	
                        	
                        	; 'POPA_' restores the 'FOR' loop variable save area from the stack
                        	;
                        	; 'PUSHA_' stacks for 'FOR' loop variable save area onto the stack
                        	;
                        	; Note: a single zero word is stored on the stack in the
                        	; case that no FOR loops need to be saved. This needs to be
                        	; done because PUSHA_ / POPA_ is called all the time.
                        	//message "POPA_"
                        	POPA_:
FFFC3F1C 00072903		lw		a0,[$sp]
FFFC3F20 00470713		add		$sp,$sp,#4
FFFC3F24 71202823		sw		a0,LOPVAR	; restore LOPVAR, but zero means no more
FFFC3F28 02090463		beq		a0,x0,PP1
FFFC3F2C 00072903		lw		a0,[$sp]
FFFC3F30 77202823		sw		a0,LOPPT
FFFC3F34 00472903		lw		a0,4[$sp]
FFFC3F38 77202A23		sw		a0,LOPLN
FFFC3F3C 00872903		lw		a0,8[$sp]
FFFC3F40 77202E23		sw		a0,LOPLMT
FFFC3F44 00C72903		lw		a0,12[$sp]
FFFC3F48 77202C23		sw		a0,LOPINC
FFFC3F4C 01070713		add		$sp,$sp,#16
                        	PP1:
FFFC3F50 00008067		ret
                        	
                        	
                        	PUSHA_:
FFFC3F54 79C02903		lw		a0,STKBOT	; Are we running out of stack room?
FFFC3F58 01490913		add		a0,a0,#20	; we might need this many bytes
FFFC3F5C DB2748E3		blt		$sp,a0,QSORRY	; out of stack space
FFFC3F60 71002983		lw		a1,LOPVAR		; save loop variables
FFFC3F64 02098463		beq		a1,x0,PU1		; if LOPVAR is zero, that's all
FFFC3F68 FF070713		sub		$sp,$sp,#16
FFFC3F6C 77002903		lw		a0,LOPPT
FFFC3F70 01272023		sw		a0,[$sp]
FFFC3F74 77402903		lw		a0,LOPLN
FFFC3F78 01272223		sw		a0,4[$sp]
FFFC3F7C 77C02903		lw		a0,LOPLMT
FFFC3F80 01272423		sw		a0,8[$sp]
FFFC3F84 77802903		lw		a0,LOPINC
FFFC3F88 01272623		sw		a0,12[$sp]
                        	PU1:
FFFC3F8C FFC70713		sub		$sp,$sp,#4
FFFC3F90 01372023		sw		a1,[$sp]
FFFC3F94 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	;
                        	; 'PRTSTG' prints a string pointed to by a0. It stops printing
                        	; and returns to the caller when either a CR is printed or when
                        	; the next byte is the same as what was passed in a1 by the
                        	; caller.
                        	;
                        	; 'PRTLN' prints the saved text line pointed to by r3
                        	; with line no. and all.
                        	;
                        	
                        	; a0 = pointer to string
                        	; a1 = stop character
                        	; return v0 = pointer to end of line + 1
                        	
                        	PRTSTG:
FFFC3F98 FEC70713		sub		$sp,$sp,#20
FFFC3F9C 00572023		sw		r5,[$sp]
FFFC3FA0 00672223		sw		r6,4[$sp]
FFFC3FA4 00772423		sw		r7,8[$sp]
FFFC3FA8 00172623		sw		$ra,12[$sp]
FFFC3FAC 01272823		sw		$a0,16[$sp]
FFFC3FB0 000962B3		mov   r5,a0	    ; r5 = pointer
FFFC3FB4 0009E333		mov   r6,a1	    ; r6 = stop char
                        	.PS1:
FFFC3FB8 0002C383	  lbu   r7,[r5]     ; get a text character
FFFC3FBC 00128293		add		r5,r5,#1
FFFC3FC0 00638E63		beq	  r7,r6,.PRTRET	; same as stop character? if so, return
FFFC3FC4 0003E933		mov   a0,r7
FFFC3FC8 841FE0EF		call	GOOUT		; display the char.
FFFC3FCC 00D06D93		ldi		$t1,#CR
FFFC3FD0 FFB394E3		bne   r7,$t1,.PS1	; is it a C.R.? no, go back for more
FFFC3FD4 00A06913		ldi		a0,#LINEFD  ; yes, add a L.F.
FFFC3FD8 831FE0EF		call	GOOUT
                        	.PRTRET:
FFFC3FDC 0003E8B3	  mov   v1,r7	    ; return a1 = stop char
FFFC3FE0 0002E833		mov		v0,r5		; return a0 = line pointer
FFFC3FE4 00072283		lw		$r5,[$sp]
FFFC3FE8 00472303		lw		$r6,4[$sp]
FFFC3FEC 00872383		lw		$r7,8[$sp]
FFFC3FF0 00C72083		lw		$ra,12[$sp]
FFFC3FF4 01072903		lw		$a0,16[$sp]
FFFC3FF8 01470713		add		$sp,$sp,#20
FFFC3FFC 00008067	  ret					; then return
                        	
                        	
                        	; 'QTSTG' looks for an underline (back-arrow on some systems),
                        	; single-quote, or double-quote.  If none of these are found, returns
                        	; to the caller.  If underline, outputs a CR without a LF.  If single
                        	; or double quote, prints the quoted string and demands a matching
                        	; end quote.  After the printing, the next i-word of the caller is
                        	; skipped over (usually a branch instruction).
                        	;
                        	QTSTG:
FFFC4000 FFC70713		sub		$sp,$sp,#4
FFFC4004 00172023		sw		$ra,[$sp]
FFFC4008 1BC000EF		call	TSTC		; *** QTSTG ***
FFFC400C 00000022		dw		'"'
FFFC4010 02000063		bra		QT3
FFFC4014 02206993		ldi		a1,#'"'		; it is a "
                        	QT1:
FFFC4018 000E6933		mov		a0,$t2
FFFC401C F7DFF0EF		call	PRTSTG		; print until another
FFFC4020 00086E33		mov		$t2,v0
FFFC4024 00D06D93		ldi		$t1,#CR
FFFC4028 03B89863		bne		v1,$t1,QT2	; was last one a CR?
FFFC402C C39FE06F		jmp		RUNNXL		; if so run next line
                        	QT3:
FFFC4030 194000EF		call	TSTC		; is it a single quote?
FFFC4034 0000005C		dw		'\''
FFFC4038 00000663		bra		QT4
FFFC403C 02706993		ldi		a1,#'\''	; if so, do same as above
FFFC4040 FC000CE3		bra		QT1
                        	QT4:
FFFC4044 180000EF		call	TSTC		; is it an underline?
FFFC4048 0000005F		dw		'_'
FFFC404C 00000C63		bra		QT5
FFFC4050 00D06913		ldi		a0,#CR		; if so, output a CR without LF
FFFC4054 FB4FE0EF		call	GOOUT
                        	QT2:
FFFC4058 00072083		lw		$ra,[$sp]		; get return address
FFFC405C 00470713		add		$sp,$sp,#4
FFFC4060 00408067		jmp		4[$ra]		; skip following branch
                        	QT5:					; not " ' or _
FFFC4064 00072083		lw		$ra,[$sp]		; get return address
FFFC4068 00470713		add		$sp,$sp,#4
FFFC406C 00008067		ret
                        	
                        	; Output a CR LF sequence
                        	;
                        	prCRLF:
FFFC4070 FFC70713		sub		$sp,$sp,#4
FFFC4074 00172023		sw		$ra,[$sp]
FFFC4078 00D06913		ldi		a0,#CR
FFFC407C F8CFE0EF		call	GOOUT
FFFC4080 00A06913		ldi		a0,#LINEFD
FFFC4084 F84FE0EF		call	GOOUT
FFFC4088 00072083		lw		$ra,[$sp]
FFFC408C 00470713		add		$sp,$sp,#4
FFFC4090 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; 'PRTNUM' prints the 32 bit number in a0, leading blanks are added if
                        	; needed to pad the number of spaces to the number in a1.
                        	; However, if the number of digits is larger than the no. in
                        	; a1, all digits are printed anyway. Negative sign is also
                        	; printed and counted in, positive sign is not.
                        	;
                        	; Parameters
                        	; 	a0 = number to print
                        	; 	a1 = number of digits
                        	;		a2 = base (eg 10, 16)
                        	; Register Usage
                        	;		s2 = number of padding spaces
                        	; Modifies:
                        	;		a0,a1,t1
                        	; Returns:
                        	;		none
                        	;-------------------------------------------------------------------------------
                        	
FFFC4094 FEC70713	public PRTNUM:
	sub		$sp,$sp,#20
FFFC4098 00472023		sw		$s1,[$sp]
FFFC409C 00572223		sw		$s2,4[$sp]
FFFC40A0 00672423		sw		$s3,8[$sp]
FFFC40A4 00772623		sw		$s4,12[$sp]
FFFC40A8 00172823		sw		$ra,16[$sp]
FFFC40AC 79406393		ldi		s4,#NUMWKA	; r7 = pointer to numeric work area
FFFC40B0 00096333		mov		s3,a0		; save number for later
FFFC40B4 0009E2B3		mov		s2,a1		; s2 = min number of chars
FFFC40B8 00095663		bge		a0,x0,.PN2	; is it negative? if not
FFFC40BC 41200933		sub		a0,x0,a0	; else make it positive
FFFC40C0 FFF28293		sub		s2,s2,#1	; one less for width count
                        	.PN2:
FFFC40C4 00A06D93		ldi		$t1,#10
                        	.PN1:
FFFC40C8 034969B3		rem		a1,a0,a2	; a1 = a0 mod 10
FFFC40CC 03494933		div		a0,a0,a2	; a0 /= 10 divide by 10
FFFC40D0 013A7463		bleu	a1,a2,.PN7
FFFC40D4 00798993		add		a1,a1,#'A'-10-'0'
                        	.PN7:
FFFC40D8 03098993		add		a1,a1,#'0'	; convert remainder to ascii
FFFC40DC 01338023		sb		a1,[$s4]		; and store in buffer
FFFC40E0 00138393		add		s4,s4,#1
FFFC40E4 FFF28293		sub		s2,s2,#1	; decrement width
FFFC40E8 FE0910E3		bne		a0,x0,.PN1
FFFC40EC 00505A63		ble		$s2,$x0,.PN4	; test pad count, skip padding if not needed
                        	.PN3:
FFFC40F0 02006913		ldi		$a0,#' '		; display the required leading spaces
FFFC40F4 F14FE0EF		call	GOOUT
FFFC40F8 FFF28293		sub		$s2,$s2,#1
FFFC40FC FE504AE3		bgt		$s2,$x0,.PN3
                        	.PN4:
FFFC4100 00035663		bge		$s3,$x0,.PN5	; is number negative?
FFFC4104 02D06913		ldi		$a0,#'-'		; if so, display the sign
FFFC4108 F00FE0EF		call	GOOUT
                        	.PN5:
FFFC410C 79406D93		ldi		$t1,#NUMWKA
                        	.PN6:
FFFC4110 FFF38393		sub		$s4,$s4,#1
FFFC4114 0003C903		lbu		$a0,[$s4]		; now unstack the digits and display
FFFC4118 EF0FE0EF		call	GOOUT
FFFC411C FE7DEAE3		bgtu	$s4,$t1,.PN6
                        	
FFFC4120 00072203		lw		$s1,[$sp]
FFFC4124 00472283		lw		$s2,4[$sp]
FFFC4128 00872303		lw		$s3,8[$sp]
FFFC412C 00C72383		lw		$s4,12[$sp]
FFFC4130 01072083		lw		$ra,16[$sp]
FFFC4134 01470713		add		$sp,$sp,#20
FFFC4138 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; Load a word from memory using unaligned access.
                        	; Moves forwards through memory
                        	;
                        	; Parameters:
                        	;		a0 = pointer to word
                        	; Returns:
                        	;		v0 = word loaded
                        	;-------------------------------------------------------------------------------
                        	LoadWord:
FFFC413C 00094803	  lbu		$v0,[$a0]	
FFFC4140 00194883	  lbu		$v1,1[$a0]
FFFC4144 00889893	  sll		$v1,$v1,#8
FFFC4148 01186833	  or		$v0,$v0,$v1
FFFC414C 00294883	  lbu		$v1,2[$a0]
FFFC4150 01089893	  sll		$v1,$v1,#16
FFFC4154 01186833	  or		$v0,$v0,$v1
FFFC4158 00394883	  lbu		$v1,3[$a0]
FFFC415C 01889893	  sll		$v1,$v1,#24
FFFC4160 01186833	  or		$v0,$v0,$v1
FFFC4164 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = pointer to line
                        	; Returns:
                        	;		v0 = pointer to end of line + 1
                        	;-------------------------------------------------------------------------------
                        	
                        	PRTLN:
FFFC4168 FF070713		sub		$sp,$sp,#16
FFFC416C 00572023		sw		$r5,[$sp]
FFFC4170 00172223		sw		$ra,4[$sp]
FFFC4174 01272423		sw		$a0,8[$sp]
FFFC4178 01372623		sw		$a1,12[$sp]
FFFC417C 000962B3	  mov		$r5,$a0		; r5 = pointer
                        	  ; get the line number stored as binary
                        	  ; assume unaligned loads not allowed
FFFC4180 FBDFF0EF	  call	LoadWord
FFFC4184 00086933	  mov		a0,v0
                        	
FFFC4188 00428293		add		r5,r5,#4
FFFC418C 00506993	  ldi		a1,#5       ; display a 0 or more digit line no.
FFFC4190 00A06A13	  ldi		a2,#10
FFFC4194 F01FF0EF		call	PRTNUM
FFFC4198 02006913		ldi		a0,#' '     ; followed by a blank
FFFC419C E6CFE0EF		call	GOOUT
FFFC41A0 000069B3		mov		a1,r0       ; stop char. is a zero
FFFC41A4 0002E933		mov		a0,r5
FFFC41A8 DF1FF0EF		call  PRTSTG		; display the rest of the line
FFFC41AC 00072283		lw		$r5,[$sp]
FFFC41B0 00472083		lw		$ra,4[$sp]
FFFC41B4 00872903		lw		$a0,8[$sp]
FFFC41B8 00C72983		lw		$a1,12[$sp]
FFFC41BC 01070713		add		$sp,$sp,#16
FFFC41C0 00008067		ret
                        	
                        	
                        	; ===== Test text byte following the call to this subroutine. If it
                        	;	equals the byte pointed to by t2, return to the code following
                        	;	the call. 
                        	;
                        	; Parameters:
                        	;		<static> word byte to look for
                        	;		<static> branch if not found
                        	; Registers Affected
                        	;   none
                        	; Returns
                        	;		t2 = updated text pointer
                        	;
                        	TSTC:
FFFC41C4 FF470713		sub		$sp,$sp,#12
FFFC41C8 01272023		sw		$a0,[$sp]
FFFC41CC 00172223		sw		$ra,4[$sp]
FFFC41D0 01372423		sw		$a1,8[$sp]
FFFC41D4 0B0000EF		call	IGNBLK		; ignore leading blanks
FFFC41D8 00472083		lw		$ra,4[$sp]	; get return address, it's needed for a reference
FFFC41DC 000E4903		lbu		$a0,[$t2]
FFFC41E0 0000C983		lbu		$a1,[$ra]
FFFC41E4 01298A63		beq		$a1,$a0,TC1	; is it = to what t2 points to? if so
FFFC41E8 00072903		lw		$a0,[$sp]		; restore a0
FFFC41EC 00872983		lw		$a1,8[$sp]
FFFC41F0 00C70713		add		$sp,$sp,#12	;
FFFC41F4 00408067		jmp		4[$ra]			; jump to the routine skip param
                        	TC1:
FFFC41F8 001E0E13		add		$t2,$t2,#1	; if equal, bump text pointer
FFFC41FC 00072903		lw		$a0,[$sp]
FFFC4200 00472083		lw		$ra,4[$sp]
FFFC4204 00872983		lw		$a1,8[$sp]
FFFC4208 00C70713		add		$sp,$sp,#12
FFFC420C 00808067		jmp		8[$ra]			; jump back, skip parm and branch
                        	
                        	
                        	; ===== See if the text pointed to by $t2 is a number. If so,
                        	;	return the number in $v0 and the number of digits in $v1,
                        	;	else return zero in $v0 and $v1.
                        	; Registers Affected
                        	;   a0,a1,r3,r4
                        	; Returns
                        	; 	v0 = number
                        	;		v1 = number of digits in number
                        	;	t2 = updated text pointer
                        	;
                        	TSTNUM:
FFFC4210 FF870713		sub		$sp,$sp,#8
FFFC4214 00172223		sw		$ra,4[$sp]
FFFC4218 00372023		sw		r3,[$sp]
FFFC421C 068000EF		call	IGNBLK		; skip over blanks
FFFC4220 00006833		mov		$v0,$x0		; initialize return parameters
FFFC4224 000068B3		mov		$v1,$x0
                        	TN1:
FFFC4228 000E4183		lbu		r3,[$t2]
FFFC422C 03006D93		ldi		$t1,#'0'
FFFC4230 05B1C263		blt		r3,$t1,TSNMRET; is it less than zero?
FFFC4234 03906D93		ldi		$t1,#'9'
FFFC4238 023DCE63		bgt		r3,$t1,TSNMRET; is it greater than nine?
FFFC423C 00000DB7		ldi		$t1,#$7FFFFFFFFFFFFFF
FFFC4240 FFFD8D93
FFFC4244 010DF863		bleu	$v0,$t1,TN2; see if there's room for new digit
FFFC4248 FFFC4937		ldi		$a0,#msgNumTooBig
FFFC424C 60190913
FFFC4250 AD1FF06F		jmp		ERROR		; if not, we've overflowd
                        	TN2:
FFFC4254 001E0E13		add		$t2,$t2,#1	; adjust text pointer
FFFC4258 00181E93		sll		$t3,$v0,#1	; quickly multiply result by 10
FFFC425C 00381813		sll		$v0,$v0,#3	; *8
FFFC4260 01D80833		add		$v0,$v0,$t3	; *8 + *2
FFFC4264 00F1F193		and		r3,r3,#$0F	; add in the new digit
FFFC4268 00380833		add		$v0,$v0,r3
FFFC426C 00188893		add		$v1,$v1,#1	; increment the no. of digits
FFFC4270 FA000CE3		bra		TN1
                        	TSNMRET:
FFFC4274 00072183		lw		r3,[$sp]
FFFC4278 00472083		lw		$ra,4[$sp]
FFFC427C 00870713		add		$sp,$sp,#8
FFFC4280 00008067		ret
                        	
                        	
                        	;===== Skip over blanks in the text pointed to by $t2.
                        	;
                        	; Registers Affected:
                        	;	$t2
                        	; Returns
                        	;	$t2 = pointer updateded past any spaces or tabs
                        	;
                        	IGNBLK:
FFFC4284 FFC70713		sub		$sp,$sp,#4
FFFC4288 01272023		sw		$a0,[$sp]
                        	IGB2:
FFFC428C 000E4903		lbu		a0,[$t2]			; get char
FFFC4290 02006D93		ldi		$t1,#' '
FFFC4294 01B90663		beq		$a0,$t1,IGB1	; see if it's a space
FFFC4298 00906D93		ldi		$t1,#'\t'
FFFC429C 01B91663		bne		a0,$t1,IGBRET	; or a tab
                        	IGB1:
FFFC42A0 001E0E13		add		$t2,$t2,#1		; increment the text pointer
FFFC42A4 FE0004E3		bra		IGB2
                        	IGBRET:
FFFC42A8 00072903		lw		$a0,[$sp]
FFFC42AC 00470713		add		$sp,$sp,#4
FFFC42B0 00008067		ret
                        	
                        	; ===== Convert the line of text in the input buffer to upper
                        	;	case (except for stuff between quotes).
                        	;
                        	; Registers Affected
                        	;   a0,r3
                        	; Returns
                        	;	r8 = pointing to end of text in buffer
                        	;
                        	TOUPBUF:
FFFC42B4 FFC70713		sub		$sp,$sp,#4
FFFC42B8 00172023		sw		$ra,[$sp]
FFFC42BC 71C06E13		ldi		$t2,#BUFFER	; set up text pointer
FFFC42C0 000061B3		mov		r3,x0		; clear quote flag
                        	TOUPB1:
FFFC42C4 000E4903		lbu		a0,[$t2]		; get the next text char.
FFFC42C8 001E0E13		add		$t2,$t2,#1
FFFC42CC 00D06D93		ldi		$t1,#CR
FFFC42D0 03B90E63		beq		a0,$t1,TOUPBRT		; is it end of line?
FFFC42D4 02206D93		ldi		$t1,#'"'
FFFC42D8 01B90E63		beq		a0,$t1,DOQUO	; a double quote?
FFFC42DC 02706D93		ldi		$t1,#'\''
FFFC42E0 01B90A63		beq		a0,$t1,DOQUO	; or a single quote?
FFFC42E4 FE0190E3		bne		r3,x0,TOUPB1	; inside quotes?
FFFC42E8 030000EF		call	toUpper 	; convert to upper case
FFFC42EC FF0E0FA3		sb		v0,-1[$t2]	; store it
FFFC42F0 FC000AE3		bra		TOUPB1		; and go back for more
                        	DOQUO:
FFFC42F4 00019663		bne		r3,x0,DOQUO1; are we inside quotes?
FFFC42F8 000961B3		mov		r3,a0		; if not, toggle inside-quotes flag
FFFC42FC FC0004E3		bra		TOUPB1
                        	DOQUO1:
FFFC4300 FD2192E3		bne		r3,a0,TOUPB1; make sure we're ending proper quote
FFFC4304 000061B3		mov		r3,r0		; else clear quote flag
FFFC4308 FA000EE3		bra		TOUPB1
                        	TOUPBRT:
FFFC430C 00072083		lw		$ra,[$sp]
FFFC4310 00470713		add		$sp,$sp,#4
FFFC4314 00008067		ret
                        	
                        	
                        	; ===== Convert the character in a0 to upper case
                        	;
                        	toUpper:
FFFC4318 00096833		mov		$v0,$a0
FFFC431C 06182D93		slt		$t1,$v0,#'a'
FFFC4320 000D9863		bne   $t1,$x0,TOUPRET	; is it < 'a'?
FFFC4324 07A06D93		ldi		$t1,#'z'
FFFC4328 010DC463		bgt		$v0,$t1,TOUPRET	; or > 'z'?
FFFC432C FE080813		sub		$v0,$v0,#32	  ; if not, make it upper case
                        	TOUPRET:
FFFC4330 00008067		ret
                        	
                        	; 'CHKIO' checks the input. If there's no input, it will return
                        	; to the caller with the a0=0. If there is input, the input byte is in a0.
                        	; However, if a control-C is read, 'CHKIO' will warm-start BASIC and will
                        	; not return to the caller.
                        	;
                        	//message "CHKIO"
                        	CHKIO:
FFFC4334 FFC70713		sub		$sp,$sp,#4
FFFC4338 00172023		sw		$ra,[$sp]
FFFC433C 228000EF		call	INCH		; get input if possible
FFFC4340 00080863		beq		$v0,$x0,CHKRET	; if Zero, no input
FFFC4344 00384893		xor		$v1,$v0,#CTRLC
FFFC4348 00089463		bne		$v1,$x0,CHKRET; is it control-C?
FFFC434C D74FE06F		jmp		WSTART		; if so, do a warm start
                        	CHKRET:
FFFC4350 00072083		lw		$ra,[$sp]
FFFC4354 00470713		add		$sp,$sp,#4
FFFC4358 00008067		ret
                        	
                        	; ===== Display a CR-LF sequence
                        	;
                        	CRLF:
FFFC435C FFFC4937		ldi		a0,#CLMSG
FFFC4360 5E590913
                        	
                        	; ===== Display a zero-ended string pointed to by register a0
                        	; Registers Affected
                        	;   a0,a1,r4
                        	;
                        	PRMESG:
FFFC4364 FFC70713		sub		$sp,$sp,#4
FFFC4368 00172023		sw		$ra,[$sp]
FFFC436C B88FC0EF		call	PutString
FFFC4370 00072083		lw		$ra,[$sp]
FFFC4374 00470713		add		$sp,$sp,#4
FFFC4378 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;	erc = ALLOCMBX (<handle var>)
                        	;------------------------------------------------------------------------------
                        	
                        	ALLOCMBX:
FFFC437C E49FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC4380 00000028		dw		'('
FFFC4384 04000E63		bra		.paren
FFFC4388 00106913		ldi		a0,#1
FFFC438C D7CFF0EF		call	TSTV
FFFC4390 00081863		bne		v0,x0,.0001
FFFC4394 FFFC4937		ldi		a0,#msgVar
FFFC4398 67A90913
FFFC439C 985FF06F		jmp		ERROR
                        	.0001:
FFFC43A0 E25FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC43A4 00000029		dw		')'
FFFC43A8 02000C63		bra		.paren
FFFC43AC 00086233		mov		s1,v0
FFFC43B0 00E06913		ldi		a0,#14			; get current tid
FFFC43B4 00000073		ecall
FFFC43B8 0008E9B3		mov		a1,v1
FFFC43BC 00026A33		mov		a2,s1
FFFC43C0 00606913		ldi		a0,#6
FFFC43C4 00000073		ecall
FFFC43C8 00081463		bne		v0,x0,.0002
FFFC43CC 01122023		sw		v1,[s1]				; save handle in variable
                        	.0002:
FFFC43D0 000068B3		mov		v1,x0
FFFC43D4 00072083		lw		$ra,[$sp]
FFFC43D8 00470713		add		$sp,$sp,#4
FFFC43DC 00008067		ret
                        	.paren:
FFFC43E0 FFFC4937		ldi		a0,#msgParen
FFFC43E4 78790913
FFFC43E8 939FF06F		jmp		ERROR
                        	
                        	;------------------------------------------------------------------------------
                        	; erc = SENDMSG (<handle var>, <msg data 1>, <msg data 2>, <msg data 3>)
                        	;------------------------------------------------------------------------------
                        	
                        	SENDMSG:
FFFC43EC DD9FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC43F0 00000028		dw		'('
FFFC43F4 08000463		bra		.paren
FFFC43F8 8D0FF0EF		call	OREXPR	; get the mailbox handle
FFFC43FC 00086233		mov		s1,v0
FFFC4400 DC5FF0EF		call	TSTC		; it must be followed by a comma
FFFC4404 0000002C		dw		','
FFFC4408 06000463		bra		.err
FFFC440C 8BCFF0EF		call	OREXPR	; get the memory address
FFFC4410 000862B3		mov		s2,v0
FFFC4414 DB1FF0EF		call	TSTC		; it must be followed by a comma
FFFC4418 0000002C		dw		','
FFFC441C 04000A63		bra		.err
FFFC4420 8A8FF0EF		call	OREXPR	; get the memory address
FFFC4424 00086333		mov		s3,v0
FFFC4428 D9DFF0EF		call	TSTC		; it must be followed by a comma
FFFC442C 0000002C		dw		','
FFFC4430 04000063		bra		.err
FFFC4434 894FF0EF		call	OREXPR	; get the memory address
FFFC4438 000863B3		mov		s4,v0
FFFC443C D89FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC4440 00000029		dw		')'
FFFC4444 02000C63		bra		.paren
FFFC4448 00906913		ldi		a0,#9		; SendMsg
FFFC444C 000269B3		mov		a1,s1
FFFC4450 0002EA33		mov		a2,s2
FFFC4454 00036AB3		mov		a3,s3
FFFC4458 0003EB33		mov		a4,s4
FFFC445C 00000073		ecall
FFFC4460 000068B3		mov		v1,x0
FFFC4464 00072083		lw		$ra,[$sp]
FFFC4468 00470713		add		$sp,$sp,#4
FFFC446C 00008067		ret
                        	.err:
FFFC4470 FFFC4937		ldi		a0,#msgComma
FFFC4474 65290913
FFFC4478 8A9FF06F		jmp		ERROR
                        	.paren:
FFFC447C FFFC4937		ldi		a0,#msgParen
FFFC4480 78790913
FFFC4484 89DFF06F		jmp		ERROR
                        	
                        	;------------------------------------------------------------------------------
                        	; WAITMSG <handle var>, <var for data 1>, <var for data 2>, <var for data 3>,
                        	;		<expr>
                        	;------------------------------------------------------------------------------
                        	
                        	WAITMSG:
FFFC4488 D3DFF0EF		call	TSTC		; else look for ( OREXPR )
FFFC448C 00000028		dw		'('
FFFC4490 0C000263		bra		.paren
FFFC4494 834FF0EF		call	OREXPR	; get the mailbox handle
FFFC4498 00086233		mov		s1,v0
FFFC449C D29FF0EF		call	TSTC		; it must be followed by a comma
FFFC44A0 0000002C		dw		','
FFFC44A4 0A000263		bra		.err
FFFC44A8 00106913		ldi		a0,#1
FFFC44AC C5CFF0EF		call	TSTV
FFFC44B0 00081863		bne		v0,x0,.0001
                        	.0002:
FFFC44B4 FFFC4937		ldi		a0,#msgVar
FFFC44B8 67A90913
FFFC44BC 865FF06F		jmp		ERROR
                        	.0001:
FFFC44C0 D05FF0EF		call	TSTC		; it must be followed by a comma
FFFC44C4 0000002C		dw		','
FFFC44C8 08000063		bra		.err
FFFC44CC 000862B3		mov		s2,v0
FFFC44D0 00106913		ldi		a0,#1
FFFC44D4 C34FF0EF		call	TSTV
FFFC44D8 FC080EE3		beq		v0,x0,.0002
FFFC44DC CE9FF0EF		call	TSTC		; it must be followed by a comma
FFFC44E0 0000002C		dw		','
FFFC44E4 06000263		bra		.err
FFFC44E8 00086333		mov		s3,v0
FFFC44EC 00106913		ldi		a0,#1
FFFC44F0 C18FF0EF		call	TSTV
FFFC44F4 FC0800E3		beq		v0,x0,.0002
FFFC44F8 000863B3		mov		s4,v0
FFFC44FC CC9FF0EF		call	TSTC		; it must be followed by a comma
FFFC4500 0000002C		dw		','
FFFC4504 04000263		bra		.err
FFFC4508 FC1FE0EF		call	OREXPR	; get queue remove flag
FFFC450C 00086BB3		mov		a5,v0
FFFC4510 000863B3		mov		s4,v0
FFFC4514 CB1FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC4518 00000029		dw		')'
FFFC451C 02000C63		bra		.paren
FFFC4520 00A06913		ldi		a0,#10		; WaitMsg
FFFC4524 000269B3		mov		a1,s1
FFFC4528 0002EA33		mov		a2,s2
FFFC452C 00036AB3		mov		a3,s3
FFFC4530 0003EB33		mov		a4,s4
FFFC4534 00000073		ecall
FFFC4538 000068B3		mov		v1,x0
FFFC453C 00072083		lw		$ra,[$sp]
FFFC4540 00470713		add		$sp,$sp,#4
FFFC4544 00008067		ret
                        	.err:
FFFC4548 FFFC4937		ldi		a0,#msgComma
FFFC454C 65290913
FFFC4550 FD0FF06F		jmp		ERROR
                        	.paren:
FFFC4554 FFFC4937		ldi		a0,#msgParen
FFFC4558 78790913
FFFC455C FC4FF06F		jmp		ERROR
                        	
                        	;*****************************************************
                        	; The following routines are the only ones that need *
                        	; to be changed for a different I/O environment.     *
                        	;*****************************************************
                        	
                        	; ===== Output character to the console (Port 1) from register a0
                        	;	(Preserves all registers.)
                        	;
                        	OUTC:
FFFC4560 C95FB06F		jmp		Putch
                        	
                        	; ===== Input a character from the console into register v0 (or
                        	;	return Zero status if there's no character available).
                        	;
                        	INCH:
FFFC4564 FFC70713		sub 	$sp,$sp,#4
FFFC4568 00172023		sw		$ra,[$sp]
FFFC456C C4DFB0EF		call	Getch
FFFC4570 00180813		add		$v0,$v0,#1				; prepare test -1
FFFC4574 00080A63		beq		$v0,$x0,INCH1			; was = -1
FFFC4578 FFF80813		sub		$v0,$v0,#1				; get char back
FFFC457C 00072083		lw		$ra,[$sp]
FFFC4580 00470713		add		$sp,$sp,#4
FFFC4584 00008067		ret
                        	INCH1:
FFFC4588 00072083		lw		$ra,[$sp]		; return a zero for no-char
FFFC458C 00470713		add		$sp,$sp,#4
FFFC4590 00008067		ret
                        	
                        	; ===== Return to the resident monitor, operating system, etc.
                        	;
                        	//message "BYEBYE"
                        	BYEBYE:
                        	//	call	ReleaseIOFocus
FFFC4594 70002703		lw		$sp,OSSP
FFFC4598 D09FB06F		jmp		Monitor
                        	 
                        	
FFFC459C 53430A0D	msgInit	db	CR,LINEFD,"CS01 Tiny BASIC v1.0",CR,LINEFD,"(C) 2017-2020  Robert Finch",CR,CR,0
FFFC45A0 54203130
FFFC45A4 20796E69
FFFC45A8 49534142
FFFC45AC 31762043
FFFC45B0 0A0D302E
FFFC45B4 20294328
FFFC45B8 37313032
FFFC45BC 3230322D
FFFC45C0 52202030
FFFC45C4 7265626F
FFFC45C8 69462074
FFFC45CC 0D68636E
FFFC45D0 0A0D000D
FFFC45D2 4B4F0A0D	OKMSG	db	CR,LINEFD,"OK",CR,0
FFFC45D6 6857000D
FFFC45D8 74616857	msgWhat	db	"What?",CR,0
FFFC45DC 53000D3F
FFFC45DF 72726F53	SRYMSG	db	"Sorry."
FFFC45E3 000D2E79
FFFC45E5 6F43000D	CLMSG	db	CR,0
FFFC45E7 706D6F43	msgReadError	db	"Compact FLASH read error",CR,0
FFFC45EB 20746361
FFFC45EF 53414C46
FFFC45F3 65722048
FFFC45F7 65206461
FFFC45FB 726F7272
FFFC45FF 754E000D
FFFC4601 626D754E	msgNumTooBig	db	"Number is too big",CR,0
FFFC4605 69207265
FFFC4609 6F742073
FFFC460D 6962206F
FFFC4611 44000D67
FFFC4614 69766944	msgDivZero		db	"Division by zero",CR,0
FFFC4618 6E6F6973
FFFC461C 20796220
FFFC4620 6F72657A
FFFC4624 754F000D
FFFC4626 2074754F	msgVarSpace     db  "Out of variable space",CR,0
FFFC462A 7620666F
FFFC462E 61697261
FFFC4632 20656C62
FFFC4636 63617073
FFFC463A 20000D65
FFFC463D 74796220	msgBytesFree	db	" bytes free",CR,0
FFFC4641 66207365
FFFC4645 0D656572
FFFC4649 65520D00
FFFC464A 6165520D	msgReady		db	CR,"Ready",CR,0
FFFC464E 000D7964
FFFC4652 65707845	msgComma		db	"Expecting a comma",CR,0
FFFC4656 6E697463
FFFC465A 20612067
FFFC465E 6D6D6F63
FFFC4662 4C000D61
FFFC4665 656E694C	msgLineRange	db	"Line number too big",CR,0
FFFC4669 6D756E20
FFFC466D 20726562
FFFC4671 206F6F74
FFFC4675 0D676962
FFFC4679 70784500
FFFC467A 65707845	msgVar			db "Expecting a variable",CR,0
FFFC467E 6E697463
FFFC4682 20612067
FFFC4686 69726176
FFFC468A 656C6261
FFFC468E 4E52000D
FFFC4690 20444E52	msgRNDBad		db	"RND bad parameter",CR,0
FFFC4694 20646162
FFFC4698 61726170
FFFC469C 6574656D
FFFC46A0 53000D72
FFFC46A3 20535953	msgSYSBad		db	"SYS bad address",CR,0
FFFC46A7 20646162
FFFC46AB 72646461
FFFC46AF 0D737365
FFFC46B3 504E4900
FFFC46B4 55504E49	msgInputVar		db	"INPUT expecting a variable",CR,0
FFFC46B8 78652054
FFFC46BC 74636570
FFFC46C0 20676E69
FFFC46C4 61762061
FFFC46C8 62616972
FFFC46CC 000D656C
FFFC46D0 5458454E	msgNextFor		db	"NEXT without FOR",CR,0
FFFC46D4 74697720
FFFC46D8 74756F68
FFFC46DC 524F4620
FFFC46E0 454E000D
FFFC46E2 5458454E	msgNextVar		db	"NEXT expecting a defined variable",CR,0
FFFC46E6 70786520
FFFC46EA 69746365
FFFC46EE 6120676E
FFFC46F2 66656420
FFFC46F6 64656E69
FFFC46FA 72617620
FFFC46FE 6C626169
FFFC4702 47000D65
FFFC4705 4F544F47	msgBadGotoGosub	db	"GOTO/GOSUB bad line number",CR,0
FFFC4709 534F472F
FFFC470D 62204255
FFFC4711 6C206461
FFFC4715 20656E69
FFFC4719 626D756E
FFFC471D 000D7265
FFFC4721 55544552	msgRetWoGosub   db	"RETURN without GOSUB",CR,0
FFFC4725 77204E52
FFFC4729 6F687469
FFFC472D 47207475
FFFC4731 4255534F
FFFC4735 7250000D
FFFC4737 676F7250	msgTooBig		db	"Program is too big",CR,0
FFFC473B 206D6172
FFFC473F 74207369
FFFC4743 62206F6F
FFFC4747 000D6769
FFFC474B 72747845	msgExtraChars	db	"Extra characters on line ignored",CR,0
FFFC474F 68632061
FFFC4753 63617261
FFFC4757 73726574
FFFC475B 206E6F20
FFFC475F 656E696C
FFFC4763 6E676920
FFFC4767 6465726F
FFFC476B 4520000D
FFFC476D 766E4520	msgEnvFail		db	" Environment call failed",CR,0
FFFC4771 6E6F7269
FFFC4775 746E656D
FFFC4779 6C616320
FFFC477D 6166206C
FFFC4781 64656C69
FFFC4785 7845000D
FFFC4787 65707845	msgParen		db	"Expecting parenthesis",CR,0
FFFC478B 6E697463
FFFC478F 61702067
FFFC4793 746E6572
FFFC4797 69736568
FFFC479B 00000D73
                        	
                        	LSTROM	equ	*		; end of possible ROM area
;	END
                        	
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	.file "cs01rom.asm",1
                        	
                        		rodata
                        		align 8                        	
                        	begin_init_data:
                        	_begin_init_data:
                        	
                        		rodata
                        		align 8                        	
                        	end_init_data:
                        	_end_init_data:
886 symbols
  Symbol Name                              seg     address bits
  ABS                                        code  fffc3b9c 18
  ABS1                                       code  fffc3bb0 18
  ADDEXPR                                    code  fffc3744 18
  ALLOCMBX                                   code  fffc437c 18
  ALLOCMBX.0001                              code  fffc43a0 18
  ALLOCMBX.0002                              code  fffc43d0 18
  ALLOCMBX.paren                             code  fffc43e0 18
  ANDEXPR                                    code  fffc3530 18
  AUXIN                                      code  8000000000000214 32
  AUXIN_INIT                                 code  80000000000002d2 32
  AUXOCRLF                                   code  fffc337c 18
  AUXOUT                                     code  8000000000000212 32
  AUXOUT_FLUSH                               code  80000000000002df 32
  AUXOUT_INIT                                code  80000000000002d6 32
  AccountTime                                code  fffc1b20 18
  AccountTime.again                          code  fffc1b20 18
  Alloc                                      code  fffc0fa8 18
  Alloc.0001                                 code  fffc1024 18
  Alloc.enough                               code  fffc0fe0 18
  Alloc.noRun                                code  fffc1048 18
  Alloc.noRun2                               code  fffc0fd8 18
  Alloc.xit                                  code  fffc104c 18
  AllocPage                                  code  fffc0d20 18
  AllocPage.0001                             code  fffc0eb0 18
  AllocPage.chkPam12                         code  fffc0dbc 18
  AllocPage.chkPam16                         code  fffc0dec 18
  AllocPage.chkPam20                         code  fffc0e1c 18
  AllocPage.chkPam24                         code  fffc0e4c 18
  AllocPage.chkPam28                         code  fffc0e7c 18
  AllocPage.chkPam4                          code  fffc0d5c 18
  AllocPage.chkPam8                          code  fffc0d8c 18
  AllocPage.chkPamDone                       code  fffc0eac 18
  AllocStack                                 code  fffc1064 18
  AllocStack.0001                            code  fffc1080 18
  AllocStack.xit                             code  fffc108c 18
  AllocTCB                                   code  fffc1d50 18
  AllocTCB.0001                              code  fffc1d64 18
  AllocTCB.0002                              code  fffc1d9c 18
  AllocTCB.0003                              code  fffc1dac 18
  AllocTCB.allocTid                          code  fffc1d90 18
  BASPRMPT                                   code  fffc28e0 18
  BS                                        const  000008 5
  BUFFER                                    const  00071c 12
  BUFLEN                                    const  000054 8
  BYEBYE                                     code  fffc4594 18
  BitIndex                                   code  fffc0ebc 18
  BitIndex.0001                              code  fffc0ec0 18
  BitIndex.0003                              code  fffc0efc 18
  BitIndex.0004                              code  fffc0eec 18
  BitIndex.foundFree                         code  fffc0ee0 18
  CHKIO                                      code  fffc4334 18
  CHKRET                                     code  fffc4350 18
  CLMSG                                      code  fffc45e5 18
  CR                                        const  00000d 5
  CRLF                                       code  fffc435c 18
  CSTART                                     code  fffc2830 32
  CTRLC                                     const  000003 3
  CTRLH                                     const  000008 5
  CTRLI                                     const  000009 5
  CTRLJ                                     const  00000a 5
  CTRLK                                     const  00000b 5
  CTRLM                                     const  00000d 5
  CTRLS                                     const  000013 6
  CTRLX                                     const  000018 6
  CURRNT                                    const  000718 12
  CopyDevFuncTbl                             code  fffc26dc 18
  CopyDevFuncTbl.again                       code  fffc26f0 18
  CursorFlash                               const  0007b0 12
  DCB_LastErc                               const  000018 6
  DCB_Mbx                                   const  000048 8
  DCB_Name                                  const  000000 1
  DCB_ReentCount                            const  000038 7
  DCB_Resv1                                 const  000058 8
  DCB_Resv2                                 const  000060 8
  DCB_Size                                  const  000068 8
  DCB_StartBlock                            const  000020 7
  DCB_Type                                  const  00000c 5
  DCB_fSingleUser                           const  000039 7
  DCB_hJob                                  const  000040 8
  DCB_nBPB                                  const  000010 6
  DCB_nBlocks                               const  000028 7
  DCB_pCmdProc                              const  000030 7
  DCB_pSema                                 const  000050 8
  DEFLT                                      code  fffc30f4 18
  DEL                                       const  00007f 8
  DIRECT                                     code  fffc2ba0 18
  DOQUO                                      code  fffc42f4 18
  DOQUO1                                     code  fffc4300 18
  DRSP_DONE                                 const  000001 2
  DVC_BuildBPB                              const  000005 4
  DVC_Close                                 const  000007 4
  DVC_FlushInput                            const  000014 6
  DVC_FlushOutput                           const  000015 6
  DVC_GetChar                               const  000008 5
  DVC_GetCharDirect                         const  00000a 5
  DVC_IOCTRL_READ                           const  000018 6
  DVC_IOCTRL_WRITE                          const  000019 6
  DVC_IRQ                                   const  000016 6
  DVC_Initialize                            const  000002 3
  DVC_InputStatus                           const  00000c 5
  DVC_IsRemoveable                          const  000017 6
  DVC_MediaCheck                            const  000004 4
  DVC_Nop                                   const  000000 1
  DVC_Open                                  const  000006 4
  DVC_OutputStatus                          const  000013 6
  DVC_OutputUntilBusy                       const  00001a 6
  DVC_PeekChar                              const  000009 5
  DVC_PeekCharDirect                        const  00000b 5
  DVC_PutChar                               const  00000d 5
  DVC_ReadBlock                             const  000010 6
  DVC_SetPosition                           const  00000f 5
  DVC_Setup                                 const  000001 2
  DVC_Status                                const  000003 3
  DVC_VerifyBlock                           const  000012 6
  DVC_WriteBlock                            const  000011 6
  DVF_Base                                  const  00a000 17
  DVF_Limit                                 const  00b000 17
  DeleteLine                                 code  fffc2994 18
  DeleteLine.0001                            code  fffc29b4 18
  DeleteLine.0002                            code  fffc29a0 18
  DeleteLine.0003                            code  fffc29b8 18
  DumpReadyQueue                             code  fffc23f4 18
  DumpReadyQueue.0001                        code  fffc246c 18
  DumpReadyQueue.0002                        code  fffc2418 18
  DumpReadyQueue.nxt                         code  fffc2488 18
  ENDCHK                                     code  fffc3cd0 18
  ENDMEM                                    const  008000 17
  ERETx                                      code  fffc1c10 18
  ERROR                                      code  fffc3d20 18
  ERROR1                                     code  fffc3d60 18
  EX1                                        code  fffc2bec 18
  EXEC                                       code  fffc2bb0 18
  EXGO                                       code  fffc2c14 18
  EXLP                                       code  fffc2bbc 18
  EXMAT                                      code  fffc2c00 18
  EXNGO                                      code  fffc2bd4 18
  EXPR                                       code  fffc3620 18
  E_Arg                                     const  000001 2
  E_BadAlarm                                const  000011 6
  E_BadBlockNum                             const  000025 7
  E_BadDevNum                               const  000020 7
  E_BadDevOp                                const  000022 7
  E_BadMbx                                  const  000004 4
  E_DCBInUse                                const  000019 6
  E_NoDev                                   const  000021 7
  E_NoMem                                   const  00000c 5
  E_NoMoreAlarmBlks                         const  000044 8
  E_NoMoreMbx                               const  000040 8
  E_NoMoreMsgBlks                           const  000041 8
  E_NoMoreTCBs                              const  000045 8
  E_NoMsg                                   const  00000b 5
  E_NoThread                                const  000006 4
  E_NotAlloc                                const  000009 5
  E_NotOwner                                const  000012 6
  E_Ok                                      const  000000 1
  E_QueFull                                 const  000005 4
  E_QueStrategy                             const  000013 6
  E_ReadError                               const  000023 7
  E_Timeout                                 const  000010 6
  E_TooManyBlocks                           const  000026 7
  E_WriteError                              const  000024 7
  EditMem                                    code  fffc0544 18
  FI1                                        code  fffc3cb0 18
  FI2                                        code  fffc3cc4 18
  FILEBUF                                   const  07f600 20
  FILENAME                                  const  0006c0 12
  FIN                                        code  fffc3c94 18
  FINISH                                     code  fffc2e60 18
  FMTKInit                                   code  fffc165c 18
  FMTKInit.0001                              code  fffc1708 18
  FMTKInit.0002                              code  fffc1738 18
  FMTKInit.0003                              code  fffc16ec 18
  FMTK_AllocMbx                              code  fffc1ee0 18
  FMTK_AllocMbx.badArg                       code  fffc1f3c 18
  FMTK_AllocMbx.noOwner                      code  fffc1f10 18
  FMTK_AllocMbx.nxt                          code  fffc1eec 18
  FMTK_ExitTask                              code  fffc1e88 18
  FMTK_ForceReleaseIOFocus                   code  fffc25fc 18
  FMTK_ForceReleaseIOFocus.0001              code  fffc268c 18
  FMTK_ForceReleaseIOFocus.done              code  fffc2698 18
  FMTK_ForceReleaseIOFocus.noFocus           code  fffc2698 18
  FMTK_ForceReleaseIOFocus.notSame           code  fffc2650 18
  FMTK_ForceReleaseIOFocus.pjSame            code  fffc2678 18
  FMTK_FreeMbx                               code  fffc1f48 18
  FMTK_FreeMbx.0001                          code  fffc1fa4 18
  FMTK_FreeMbx.0002                          code  fffc1f6c 18
  FMTK_FreeMbx.0003                          code  fffc1f94 18
  FMTK_FreeMbx.badMbx                        code  fffc1fbc 18
  FMTK_GetCurrentTid                         code  fffc175c 18
  FMTK_HasIOFocus                            code  fffc24b8 18
  FMTK_HasIOFocus.hasFocus                   code  fffc24e4 18
  FMTK_HasIOFocus.xit                        code  fffc24e8 18
  FMTK_IO                                    code  fffc26a4 18
  FMTK_IO.badFunc                            code  fffc26d4 18
  FMTK_IO.xit                                code  fffc26c8 18
  FMTK_Initialize                            code  8000000000000164 32
  FMTK_KillTask                              code  fffc1e90 18
  FMTK_KillTask.immortal                     code  fffc1edc 18
  FMTK_PeekMsg                               code  fffc2168 18
  FMTK_PostMsg                               code  800000000000016c 32
  FMTK_ReleaseIOFocus                        code  fffc25f4 18
  FMTK_RequestIOFocus                        code  fffc2560 18
  FMTK_RequestIOFocus.notEmpty               code  fffc25cc 18
  FMTK_RequestIOFocus.ret                    code  fffc25e8 18
  FMTK_Reschedule                            code  80000000000001c1 32
  FMTK_SchedulerIRQ                          code  fffc1c14 18
  FMTK_SchedulerIRQ.0001                     code  fffc1c5c 18
  FMTK_SchedulerIRQ.noCtxSwitch              code  fffc1d30 18
  FMTK_SchedulerIRQ.noException              code  fffc1cd8 18
  FMTK_SchedulerIRQ.noMsg                    code  fffc1d18 18
  FMTK_SchedulerIRQ.noTimeouts               code  fffc1cc0 18
  FMTK_SchedulerIRQ.timeoutNotDone           code  fffc1c94 18
  FMTK_SendMsg                               code  fffc1fc8 18
  FMTK_SendMsg.0001                          code  fffc1fec 18
  FMTK_SendMsg.badMbx                        code  fffc20a8 18
  FMTK_SendMsg.mbxEmpty                      code  fffc2090 18
  FMTK_SendMsg.noMsg                         code  fffc20a0 18
  FMTK_SendMsg.noWaiters                     code  fffc2044 18
  FMTK_SendMsg.nxtTid                        code  fffc2028 18
  FMTK_SendMsg.xit                           code  fffc20ac 18
  FMTK_SetTaskPriority                       code  8000000000000168 32
  FMTK_Sleep                                 code  fffc1b4c 18
  FMTK_Sleep.0001                            code  fffc1b70 18
  FMTK_Sleep.noCtxSwitch                     code  fffc1bfc 18
  FMTK_Sleep.noException                     code  fffc1ba8 18
  FMTK_Sleep.noMsg                           code  fffc1be8 18
  FMTK_StartApp                              code  8000000000000170 32
  FMTK_StartTask                             code  fffc1dc8 18
  FMTK_StartTask.err                         code  fffc1e78 18
  FMTK_SwitchIOFocus                         code  fffc2554 18
  FMTK_WaitMsg                               code  fffc2174 18
  FMTK_WaitMsg.noTimelimit                   code  fffc21e0 18
  FMTK_WaitMsg.qt                            code  fffc2190 18
  FNDLN                                      code  fffc3e58 18
  FNDLNP                                     code  fffc3e78 18
  FNDNXT                                     code  fffc3ed4 18
  FNDRET                                     code  fffc3ea8 18
  FNDRET.0001                                code  fffc3eac 18
  FNDRET1                                    code  fffc3ec4 18
  FNDRET2                                    code  fffc3ecc 18
  FNDSKP                                     code  fffc3ed8 18
  FOR                                        code  fffc2ef0 18
  FORCEFIT                                   code  fffc35f8 18
  FORCEFIT.0001                              code  fffc361c 18
  FORCEFIT.intAnd                            code  fffc360c 18
  FR1                                        code  fffc2f10 18
  FR2                                        code  fffc2f2c 18
  FR3                                        code  fffc2f34 18
  FR4                                        code  fffc2f38 18
  FR5                                        code  fffc2f3c 18
  FR6                                        code  fffc2f54 18
  FR7                                        code  fffc2f58 18
  FR8                                        code  fffc2f78 18
  FUNCEXPR                                   code  fffc3878 18
  FillMem                                    code  fffc055c 18
  FillMem.0001                               code  fffc0578 18
  FindRun                                    code  fffc0f4c 18
  FindRun.0001                               code  fffc0f68 18
  FindRun.empty0                             code  fffc0f80 18
  FindRun.empty1                             code  fffc0f84 18
  FindRun.foundEnough                        code  fffc0fa0 18
  FreeAll                                    code  fffc1090 18
  FreeAll.0001                               code  fffc10f0 18
  FreeAll.nxt                                code  fffc1098 18
  FreeMsg                                   const  008c00 17
  FreePage                                   code  fffc0f00 18
  FreePage.xit                               code  fffc0f48 18
  GCHAR                                      code  fffc3178 18
  GCHAR1                                     code  fffc3190 18
  GETLN                                      code  fffc3d64 18
  GETLN.GL1                                  code  fffc3d84 18
  GETLN.GL2                                  code  fffc3dac 18
  GETLN.GL3                                  code  fffc3ddc 18
  GETLN.GL4                                  code  fffc3e04 18
  GETLN.GL5                                  code  fffc3e14 18
  GETLN.GL6                                  code  fffc3e34 18
  GETLN.GL7                                  code  fffc3e3c 18
  GOAUXI                                     code  fffc2818 18
  GOAUXO                                     code  fffc2810 18
  GOBYE                                      code  fffc2820 18
  GOIN                                       code  fffc280c 18
  GOOUT                                      code  fffc2808 18
  GOSTART                                    code  fffc2800 18
  GOSUB                                      code  fffc2e68 18
  GOTO                                       code  fffc2ce4 18
  GOWARM                                     code  fffc2804 18
  GetBuflen                                  code  fffc29fc 18
  GetBuflen.0001                             code  fffc2a24 18
  GetBuflen.0002                             code  fffc2a08 18
  GetBuflen.0004                             code  fffc2a20 18
  GetCurrentTid                              code  fffc1750 18
  GetFilename                                code  fffc31dc 18
  GetHexNum                                  code  fffc05b4 18
  GetHexNum.0001                             code  fffc0604 18
  GetHexNum.isDigit                          code  fffc0640 18
  GetHexNum.isHexLower                       code  fffc0628 18
  GetHexNum.isHexUpper                       code  fffc0610 18
  GetHexNum.next                             code  fffc05c4 18
  Getch                                      code  fffc01b8 18
  Getch.0001                                 code  fffc01e4 18
  Getch.0002                                 code  fffc01c4 18
  Getch.hasFocus                             code  fffc01d0 18
  HRDY0                                     const  004308 16
  HRDY1                                     const  004309 16
  HRDY2                                     const  00430a 16
  HRDY3                                     const  00430b 16
  IF0                                        code  fffc2ff4 18
  IF1                                        code  fffc2ff8 18
  IF2                                        code  fffc3000 18
  IF3                                        code  fffc3014 18
  IGB1                                       code  fffc42a0 18
  IGB2                                       code  fffc428c 18
  IGBRET                                     code  fffc42a8 18
  IGNBLK                                     code  fffc4284 18
  INBUF                                     const  004100 16
  INCH                                       code  fffc4564 18
  INCH1                                      code  fffc4588 18
  INPERR                                     code  fffc3018 18
  INPPTR                                    const  0007ac 12
  INPUT                                      code  fffc3034 18
  INSLINE                                    code  fffc2954 18
  INSLINE.0001                               code  fffc2980 18
  IOF_NEXT                                  const  0002e8 11
  IOF_PREV                                  const  0002f0 11
  IOFocusNdx                                const  008c08 17
  IOFocusTbl                                const  008c10 17
  IP2                                        code  fffc305c 18
  IP3                                        code  fffc3098 18
  IP4                                        code  fffc30d8 18
  IP5                                        code  fffc30e8 18
  IP6                                        code  fffc303c 18
  IP7                                        code  fffc307c 18
  IRQFlag                                   const  0007b4 12
  IRQROUT                                   const  0007a4 12
  IRQRout                                    code  fffc0728 18
  IRQRout.isIRQ                              code  fffc0740 18
  IRQRout.noIRQ                              code  fffc0760 18
  InsertIntoTimeoutList                      code  fffc2288 18
  InsertIntoTimeoutList.0001                 code  fffc22c8 18
  InsertIntoTimeoutList.0002                 code  fffc2328 18
  InsertIntoTimeoutList.0003                 code  fffc2338 18
  InsertIntoTimeoutList.beginWhile           code  fffc22e0 18
  InsertIntoTimeoutList.endWhile             code  fffc22fc 18
  InsertLine                                 code  fffc29dc 18
  InsertLine.0001                            code  fffc29e0 18
  InsertLine.done                            code  fffc29f8 18
  InsertTask                                 code  fffc21e8 18
  InsertTask.badTid                          code  fffc2270 18
  InsertTask.qfull                           code  fffc2278 18
  InsertTask.xit                             code  fffc227c 18
  LET                                        code  fffc3100 18
  LINEFD                                    const  00000a 5
  LISTX                                      code  fffc2d80 18
  LOAD                                       code  fffc3118 18
  LOAD3                                      code  fffc3248 18
  LOAD4                                      code  fffc3274 18
  LOAD5                                      code  fffc32ac 18
  LOD1                                       code  fffc3128 18
  LOD2                                       code  fffc3154 18
  LODEND                                     code  fffc3170 18
  LOPINC                                    const  000778 12
  LOPLMT                                    const  00077c 12
  LOPLN                                     const  000774 12
  LOPPT                                     const  000770 12
  LOPVAR                                    const  000710 12
  LS1                                        code  fffc2d94 18
  LS2                                        code  fffc2dbc 18
  LS3                                        code  fffc2dc4 18
  LS4                                        code  fffc2da0 18
  LS5                                        code  fffc2d98 18
  LSTROM                                    const  000000 1
  LT1                                        code  fffc3114 18
  LoadWord                                   code  fffc413c 18
  MAX_DEV_OP                                const  00001f 6
  MAX_TID                                   const  00000f 5
  MBX_MQHEAD                                const  000008 5
  MBX_MQTAIL                                const  00000c 5
  MBX_OWNER                                 const  000000 1
  MBX_SIZE                                  const  000010 6
  MBX_WTIDS                                 const  000004 4
  MMUInit                                    code  fffc0c28 18
  MMUInit.0001                               code  fffc0cdc 18
  MMUInit.0002                               code  fffc0d0c 18
  MMUInit.0003                               code  fffc0cf0 18
  MSG_D1                                    const  000004 4
  MSG_D2                                    const  000008 5
  MSG_D3                                    const  00000c 5
  MSG_LINK                                  const  000000 1
  MSG_SIZE                                  const  000010 6
  MULEXPR                                    code  fffc37dc 18
  MVDOWN                                     code  fffc3f14 18
  MVDOWN1                                    code  fffc3f04 18
  MVUP                                       code  fffc3efc 18
  MVUP1                                      code  fffc3eec 18
  MachineStart                               code  fffc0100 18
  MapOSPages                                 code  fffc176c 18
  MapOSPages.nxt                             code  fffc1778 18
  MonEntry                                   code  fffc0298 18
  Monitor                                    code  fffc02a0 18
  Monitor.0001                               code  fffc02bc 18
  Monitor.0002                               code  fffc030c 18
  Monitor.0003                               code  fffc0370 18
  Monitor.0004                               code  fffc03f8 18
  Monitor.0005                               code  fffc04b8 18
  Monitor.0006                               code  fffc0460 18
  Monitor.0007                               code  fffc0470 18
  Monitor.0008                               code  fffc047c 18
  Monitor.0009                               code  fffc0488 18
  Monitor.0010                               code  fffc049c 18
  Monitor.0011                               code  fffc04b8 18
  Monitor.doBackspace                        code  fffc035c 18
  Monitor.doDelete                           code  fffc0304 18
  Monitor.procLine                           code  fffc03c0 18
  Monitor.skip                               code  fffc03d4 18
  Monitor.skip2                              code  fffc03f0 18
  NEW                                        code  fffc2c28 18
  NEXT                                       code  fffc2f7c 18
  NPAGES                                    const  004300 16
  NR_DCB                                    const  000020 7
  NR_TCB                                    const  000010 6
  NUMWKA                                    const  000794 12
  NX0                                        code  fffc2f98 18
  NX1                                        code  fffc2fd8 18
  NX2                                        code  fffc2fb8 18
  NX3                                        code  fffc2fdc 18
  NX4                                        code  fffc2f94 18
  NX5                                        code  fffc2fac 18
  NXPurge                                    code  fffc2fec 18
  OKMSG                                      code  fffc45d2 18
  ONIRQ                                      code  fffc2d48 18
  ONIRQ1                                     code  fffc2d68 18
  OREXPR                                     code  fffc34c8 18
  OSCALL                                     code  fffc1ad8 18
  OSCallTbl                                  code  fffc1604 18
  OSPAGES                                   const  000020 7
  OSSP                                      const  000700 12
  OUTC                                       code  fffc4560 18
  OUTPTR                                    const  0007a8 12
  OpenSpace                                  code  fffc2a28 18
  OpenSpace.0003                             code  fffc2a40 18
  OpenSpace.noSpace                          code  fffc2a5c 18
  PAM                                       const  004800 16
  PARN                                       code  fffc38c8 18
  PEEK                                       code  fffc3ab8 18
  PEEKH                                      code  fffc3ae8 18
  PEEKW                                      code  fffc3ad0 18
  PIDMAP                                    const  004310 16
  PKER                                       code  fffc3490 18
  POKE                                       code  fffc340c 18
  POKEH                                      code  fffc3464 18
  POKEW                                      code  fffc3438 18
  POPA_                                      code  fffc3f1c 18
  PP1                                        code  fffc3f50 18
  PR0                                        code  fffc2df4 18
  PR1                                        code  fffc2e0c 18
  PR2                                        code  fffc2de0 18
  PR3                                        code  fffc2e2c 18
  PR4                                        code  fffc2e24 18
  PR6                                        code  fffc2e40 18
  PR8                                        code  fffc2e48 18
  PRINT                                      code  fffc2dc8 18
  PRMESG                                     code  fffc4364 18
  PRTLN                                      code  fffc4168 18
  PRTNUM                                     code  fffc4094 32
  PRTNUM.PN1                                 code  fffc40c8 18
  PRTNUM.PN2                                 code  fffc40c4 18
  PRTNUM.PN3                                 code  fffc40f0 18
  PRTNUM.PN4                                 code  fffc4100 18
  PRTNUM.PN5                                 code  fffc410c 18
  PRTNUM.PN6                                 code  fffc4110 18
  PRTNUM.PN7                                 code  fffc40d8 18
  PRTSTG                                     code  fffc3f98 18
  PRTSTG.PRTRET                              code  fffc3fdc 18
  PRTSTG.PS1                                 code  fffc3fb8 18
  PU1                                        code  fffc3f8c 18
  PUSHA_                                     code  fffc3f54 18
  PWORD                                      code  fffc33a0 18
  PeekMsg                                    code  fffc20b4 18
  PeekMsg.badMbx                             code  fffc2158 18
  PeekMsg.noMsg                              code  fffc2150 18
  PeekMsg.nod1                               code  fffc2120 18
  PeekMsg.nod2                               code  fffc2134 18
  PeekMsg.nod3                               code  fffc2148 18
  PeekMsg.nodq                               code  fffc210c 18
  PeekMsg.ret                                code  fffc215c 18
  PopTimeoutList                             code  fffc239c 18
  PopTimeoutList.done                        code  fffc23f0 18
  PutHexByte                                 code  fffc0694 18
  PutHexHalf                                 code  fffc0674 18
  PutHexNybble                               code  fffc06b4 18
  PutHexNybble.0001                          code  fffc06e4 18
  PutHexNybble.lt10                          code  fffc06dc 18
  PutHexWord                                 code  fffc0654 18
  PutString                                  code  fffc06f4 18
  PutString.0001                             code  fffc0704 18
  PutString.done                             code  fffc0718 18
  Putch                                      code  fffc01f4 18
  QNDX                                      const  004304 16
  QSORRY                                     code  fffc3d0c 18
  QT1                                        code  fffc4018 18
  QT2                                        code  fffc4058 18
  QT3                                        code  fffc4030 18
  QT4                                        code  fffc4044 18
  QT5                                        code  fffc4064 18
  QTSTG                                      code  fffc4000 18
  QWHAT                                      code  fffc3d18 18
  RDYQ0                                     const  004400 16
  RDYQ1                                     const  004500 16
  RDYQ2                                     const  004600 16
  RDYQ3                                     const  004700 16
  RETURN                                     code  fffc2eac 18
  RND                                        code  fffc3b40 18
  RUN                                        code  fffc2c50 18
  RUN1                                       code  fffc2cb0 18
  RUN2                                       code  fffc2c6c 18
  RUN3                                       code  fffc2c70 18
  RUNNXL                                     code  fffc2c64 18
  RUNSML                                     code  fffc2ccc 18
  RUNTSL                                     code  fffc2cc4 18
  RemoveFromTimeoutList                      code  fffc234c 18
  RemoveFromTimeoutList.0001                 code  fffc2374 18
  RemoveFromTimeoutList.0002                 code  fffc2388 18
  SAVE                                       code  fffc331c 18
  SAVE1                                      code  fffc3328 18
  SAVE2                                      code  fffc3344 18
  SAVE3                                      code  fffc32b0 18
  SAVE4                                      code  fffc32e0 18
  SAVEND                                     code  fffc335c 18
  SDReadSector                               code  80000000000002d3 32
  SDWriteSector                              code  80000000000002d8 32
  SENDMSG                                    code  fffc43ec 18
  SENDMSG.err                                code  fffc4470 18
  SENDMSG.paren                              code  fffc447c 18
  SETVAL                                     code  fffc3c2c 18
  SETVAL.sv2                                 code  fffc3c50 18
  SGN                                        code  fffc3bd4 18
  SGN1                                       code  fffc3c04 18
  SGN2                                       code  fffc3bf4 18
  SIZEX                                      code  fffc3c10 18
  SRYMSG                                     code  fffc45df 18
  ST2                                        code  fffc2930 18
  STACKOFFS                                 const  07fffc 20
  STKBOT                                    const  00079c 12
  STKGOS                                    const  000714 12
  STKINP                                    const  000798 12
  STOP                                       code  fffc2c3c 18
  STRTMP                                    const  000200 11
  SV1                                        code  fffc3c8c 18
  SYSX                                       code  fffc349c 18
  SelectTaskToRun                            code  fffc178c 18
  SelectTaskToRun.dq                         code  fffc180c 18
  SelectTaskToRun.goodTid                    code  fffc1848 18
  SelectTaskToRun.nxtQ                       code  fffc17d0 18
  SerHeadRcv                                const  009800 17
  SerHeadXmit                               const  009808 17
  SerRcvBuf                                 const  009000 17
  SerRcvXon                                 const  009810 17
  SerTailRcv                                const  009804 17
  SerTailXmit                               const  00980c 17
  SerXmitBuf                                const  009400 17
  SerialFinishCmd                            code  fffc128c 18
  SerialFinishCmd.0001                       code  fffc12b0 18
  SerialFuncTbl                              code  fffc1138 18
  SerialIRQ                                  code  fffc1428 18
  SerialIRQ.0001                             code  fffc14a4 18
  SerialIRQ.notRxInt                         code  fffc14b8 18
  SerialIRQ.nxtByte                          code  fffc1428 18
  SerialIRQ.rxFull                           code  fffc14b8 18
  SerialInit                                 code  fffc11b8 18
  SerialPeekChar                             code  fffc12b4 18
  SerialPeekChar.0001                        code  fffc130c 18
  SerialPeekChar.0002                        code  fffc12c0 18
  SerialPeekChar.noChars                     code  fffc130c 18
  SerialPeekChar.xit                         code  fffc1310 18
  SerialPeekCharDirect                       code  fffc1320 18
  SerialPeekCharDirect.0001                  code  fffc1358 18
  SerialPeekCharDirect.xit                   code  fffc135c 18
  SerialPutChar                              code  fffc136c 18
  SerialPutChar.0001                         code  fffc1380 18
  SerialPutChar.0002                         code  fffc137c 18
  SerialPutChar.goSleep                      code  fffc13c4 18
  SerialRcvCount                             code  fffc13ec 18
  SerialRcvCount.xit                         code  fffc1420 18
  SerialService                              code  fffc1234 18
  SerialServiceInit                          code  fffc121c 18
  SerialServiceLoop                          code  fffc1250 18
  SkipSpaces                                 code  fffc0588 18
  SkipSpaces.skip1                           code  fffc05ac 18
  SkipSpaces.skip2                           code  fffc0588 18
  SwapContext                                code  fffc1888 18
  SwapContext.rsseg                          code  fffc19b8 18
  SwapContext.svseg                          code  fffc198c 18
  SwitchIOFocusHelper                        code  fffc2500 18
  SwitchIOFocusHelper.noFocus                code  fffc2540 18
  SwitchIOFocusHelper.sameFocus              code  fffc2540 18
  TAB                                       const  000009 5
  TAB1                                       code  fffc2a64 18
  TAB10                                      code  fffc2b1e 18
  TAB10_1                                    code  fffc2b8e 18
  TAB1_1                                     code  fffc2b22 18
  TAB2                                       code  fffc2a76 18
  TAB2_1                                     code  fffc2b2c 18
  TAB4                                       code  fffc2acf 18
  TAB4_1                                     code  fffc2b5a 18
  TAB5                                       code  fffc2b08 18
  TAB5_1                                     code  fffc2b74 18
  TAB6                                       code  fffc2b0b 18
  TAB6_1                                     code  fffc2b78 18
  TAB8                                       code  fffc2b10 18
  TAB8_1                                     code  fffc2b7c 18
  TAB9                                       code  fffc2b1a 18
  TAB9_1                                     code  fffc2b8a 18
  TC1                                        code  fffc41f8 18
  TCBEndTick                                const  0002b8 11
  TCBException                              const  0002c8 11
  TCBMsgD1                                  const  000298 11
  TCBMsgD2                                  const  0002a0 11
  TCBMsgD3                                  const  0002a8 11
  TCBName                                   const  0002f8 11
  TCBNext                                   const  0002d0 11
  TCBPrev                                   const  0002d8 11
  TCBPriority                               const  000289 11
  TCBStackBot                               const  000290 11
  TCBStartTick                              const  0002b0 11
  TCBStatus                                 const  000288 11
  TCBTicks                                  const  0002c0 11
  TCBTimeout                                const  0002e0 11
  TCBWaitMbx                                const  00028a 11
  TCBepc                                    const  000280 11
  TCBsegs                                   const  000200 11
  TICKX                                      code  fffc3bc0 18
  TN1                                        code  fffc4228 18
  TN2                                        code  fffc4254 18
  TOOBIG                                     code  fffc3d00 18
  TOUPB1                                     code  fffc42c4 18
  TOUPBRT                                    code  fffc430c 18
  TOUPBUF                                    code  fffc42b4 18
  TOUPRET                                    code  fffc4330 18
  TRDY0                                     const  00430c 16
  TRDY1                                     const  00430d 16
  TRDY2                                     const  00430e 16
  TRDY3                                     const  00430f 16
  TSNMRET                                    code  fffc4274 18
  TSTC                                       code  fffc41c4 18
  TSTNUM                                     code  fffc4210 18
  TSTV                                       code  fffc3908 18
  TSTVRT                                     code  fffc3978 18
  TS_DEAD                                   const  000002 3
  TS_MSGRDY                                 const  000004 4
  TS_NONE                                   const  000000 1
  TS_PREEMPT                                const  000020 7
  TS_READY                                  const  000001 2
  TS_RUNNING                                const  000080 9
  TS_TIMEOUT                                const  000010 6
  TS_WAITMSG                                const  000008 5
  TV1                                        code  fffc3964 18
  TV2                                        code  fffc3958 18
  TV3                                        code  fffc3938 18
  TXTBGN                                    const  001800 14
  TXTUNF                                    const  000704 12
  Tick                                      const  004330 16
  TimeoutList                               const  004328 16
  TinyBasic                                  code  fffc2800 18
  UART                                      const  ffdc0a00 33
  UART_CMD                                  const  000008 5
  UART_STAT                                 const  000004 4
  UART_TRB                                  const  000000 1
  USRX                                       code  fffc3b00 18
  UserStart                                  code  fffc0138 18
  UserStart.0002                             code  fffc017c 18
  UserStart.0003                             code  fffc01a4 18
  UserStart.0004                             code  fffc0170 18
  VARBGN                                    const  000708 12
  VAREND                                    const  00070c 12
  VIA                                       const  ffdc0600 33
  VIA_ACR                                   const  00002c 7
  VIA_DDRA                                  const  00000c 5
  VIA_IER                                   const  000038 7
  VIA_IFR                                   const  000034 7
  VIA_PA                                    const  000004 4
  VIA_PARAW                                 const  00003c 7
  VIA_PCR                                   const  000030 7
  VIA_T1CH                                  const  000014 6
  VIA_T1CL                                  const  000010 6
  ViaFuncTbl                                 code  fffc14c8 18
  ViaIRQ                                     code  fffc15a4 18
  ViaIRQ.0003                                code  fffc1600 18
  ViaInit                                    code  fffc1548 18
  VirtToPhys                                 code  fffc10f4 18
  VirtToPhys.notMapped                       code  fffc112c 18
  WAITIRQ                                    code  fffc2d70 18
  WAITMSG                                    code  fffc4488 18
  WAITMSG.0001                               code  fffc44c0 18
  WAITMSG.0002                               code  fffc44b4 18
  WAITMSG.err                                code  fffc4548 18
  WAITMSG.paren                              code  fffc4554 18
  WSTART                                     code  fffc28c0 18
  XOFF                                      const  000013 6
  XON                                       const  000011 6
  XP11                                       code  fffc364c 18
  XP12                                       code  fffc3664 18
  XP13                                       code  fffc367c 18
  XP14                                       code  fffc3694 18
  XP15                                       code  fffc36ac 18
  XP16                                       code  fffc36c4 18
  XP17                                       code  fffc3704 18
  XP18                                       code  fffc371c 18
  XP21                                       code  fffc376c 18
  XP22                                       code  fffc3778 18
  XP23                                       code  fffc377c 18
  XP24                                       code  fffc3798 18
  XP25                                       code  fffc37ac 18
  XP26                                       code  fffc37b8 18
  XP31                                       code  fffc37e8 18
  XP34                                       code  fffc3818 18
  XP35                                       code  fffc383c 18
  XP40                                       code  fffc3894 18
  XP41                                       code  fffc38b0 18
  XP42                                       code  fffc38ec 18
  XP43                                       code  fffc38f8 18
  XP45                                       code  fffc37c4 18
  XP46                                       code  fffc38bc 18
  XP47                                       code  fffc3860 18
  XPRT0                                      code  fffc36dc 18
  XPRT1                                      code  fffc36f0 18
  XP_AND                                     code  fffc355c 18
  XP_AND1                                    code  fffc353c 18
  XP_ANDX                                    code  fffc3570 18
  XP_OR                                      code  fffc34fc 18
  XP_OR1                                     code  fffc34dc 18
  XP_ORX                                     code  fffc3510 18
  YIELD0                                     code  fffc2c44 18
  _clr                                       code  fffc2d08 18
  _cls                                       code  8000000000000257 32
  _end_init_data                           rodata  fffc5000 32
  _rdcf                                      code  8000000000000259 32
  a2h1                                       code  fffc31d0 18
  asciiToHex                                 code  fffc31c4 18
  begin_init_data                          rodata  fffc5000 32
  clearVars                                  code  fffc2d10 18
  clearVars.cv1                              code  fffc2d24 18
  doMem                                      code  fffc04bc 18
  doMem.loop                                 code  fffc0520 18
  doMem.loop2                                code  fffc04f8 18
  ec1                                        code  fffc3cf4 18
  end_init_data                            rodata  fffc5000 32
  entry                                      code  fffc239c 18
  findVar                                    code  fffc3a48 18
  fl1                                        code  fffc3e70 18
  flt10                                      code  fffc084d 18
  flt20                                      code  fffc083d 18
  flt50                                      code  fffc082d 18
  fltMillion                                 code  fffc0c24 18
  fltOne                                     code  fffc0c1c 18
  fltTen                                     code  fffc0c20 18
  fltToString                                code  fffc085d 18
  fltToString.0001                           code  fffc08be 18
  fltToString.0002                           code  fffc093e 18
  fltToString.0003                           code  fffc092a 18
  fltToString.0004                           code  fffc098a 18
  fltToString.0005                           code  fffc0982 18
  fltToString.0006                           code  fffc096a 18
  fltToString.0007                           code  fffc09a6 18
  fltToString.0008                           code  fffc09ba 18
  fltToString.0009                           code  fffc09b6 18
  fltToString.0010                           code  fffc09da 18
  fltToString.0011                           code  fffc0a66 18
  fltToString.0012                           code  fffc0a1e 18
  fltToString.0013                           code  fffc0a0a 18
  fltToString.0014                           code  fffc0a3a 18
  fltToString.0015                           code  fffc0a56 18
  fltToString.0016                           code  fffc09f2 18
  fltToString.0017                           code  fffc0a5e 18
  fltToString.0018                           code  fffc0a66 18
  fltToString.0019                           code  fffc0a9a 18
  fltToString.0020                           code  fffc0aa6 18
  fltToString.0021                           code  fffc0aca 18
  fltToString.0022                           code  fffc0ad6 18
  fltToString.0023                           code  fffc0ae6 18
  fltToString.0024                           code  fffc0af2 18
  fltToString.0025                           code  fffc0ade 18
  fltToString.0026                           code  fffc0b06 18
  fltToString.0027                           code  fffc0b0e 18
  fltToString.0028                           code  fffc0b16 18
  fltToString.0029                           code  fffc0b22 18
  fltToString.0030                           code  fffc0b2e 18
  fltToString.0031                           code  fffc0b3a 18
  fltToString.0032                           code  fffc0b42 18
  fltToString.0034                           code  fffc0b4a 18
  fltToString.0035                           code  fffc0b56 18
  fltToString.0036                           code  fffc0b66 18
  fltToString.0037                           code  fffc0b72 18
  fltToString.0038                           code  fffc0b7a 18
  fltToString.0039                           code  fffc0b8e 18
  fltToString.0040                           code  fffc0b82 18
  fltToString.0041                           code  fffc0bea 18
  fltToString.0042                           code  fffc0bae 18
  fltToString.0043                           code  fffc0bbe 18
  fltToString.0044                           code  fffc0bd2 18
  fltToString.0045                           code  fffc0bb6 18
  fltToString.0046                           code  fffc0bde 18
  fltToString.0047                           code  fffc0bea 18
  fltToString.0048                           code  fffc0bd6 18
  fltToString.0050                           code  fffc0c0a 18
  fltToString.0051                           code  fffc0c06 18
  fltToString.0052                           code  fffc0bf6 18
  fltToString.inf                            code  fffc08a6 18
  fltToString.notZero                        code  fffc08fa 18
  fltToString.pos                            code  fffc08e6 18
  fltToString.prt                            code  fffc0b9e 18
  fputc                                      code  fffc0234 18
  fputc.0001                                 code  fffc0250 18
  fputc.hasFocus                             code  fffc026c 18
  fv1                                        code  fffc3a90 18
  fv2                                        code  fffc3aa4 18
  fv3                                        code  fffc3a88 18
  fv4                                        code  fffc3a58 18
  gen_rand                                   code  8000000000000321 32
  getVarName                                 code  fffc399c 18
  gfn1                                       code  fffc3244 18
  gfn2                                       code  fffc31f4 18
  gfn3                                       code  fffc3224 18
  gosub1                                     code  fffc2e88 18
  gvn1                                       code  fffc3a34 18
  gvn2                                       code  fffc39f8 18
  gvn3                                       code  fffc3a14 18
  gvn4                                       code  fffc39bc 18
  gvn6                                       code  fffc39e8 18
  isAlnum                                    code  fffc35d8 18
  isAlpha                                    code  fffc35a8 18
  isAlphaFalse                               code  fffc35d0 18
  isAlphaTrue                                code  fffc35c8 18
  isDigit                                    code  fffc3588 18
  isDigitFalse                               code  fffc35a0 18
  isDigitx                                   code  fffc35ec 18
  mbxs                                      const  008800 17
  mbxs_end                                  const  008a00 17
  milliseconds                              const  004208 16
  missed_ticks                              const  004320 16
  msgBadGotoGosub                            code  fffc4705 18
  msgBytesFree                               code  fffc463d 18
  msgCRLF                                    code  fffc082a 18
  msgComma                                   code  fffc4652 18
  msgDivZero                                 code  fffc4614 18
  msgEnvFail                                 code  fffc476d 18
  msgExtraChars                              code  fffc474b 18
  msgInf                                     code  fffc0c14 18
  msgInit                                    code  fffc459c 18
  msgInputVar                                code  fffc46b4 18
  msgLineRange                               code  fffc4665 18
  msgMonHelp                                 code  fffc077a 18
  msgNan                                     code  fffc0c18 18
  msgNextFor                                 code  fffc46d0 18
  msgNextVar                                 code  fffc46e2 18
  msgNumTooBig                               code  fffc4601 18
  msgParen                                   code  fffc4787 18
  msgRNDBad                                  code  fffc4690 18
  msgReadError                               code  fffc45e7 18
  msgReady                                   code  fffc464a 18
  msgRetWoGosub                              code  fffc4721 18
  msgSYSBad                                  code  fffc46a3 18
  msgStart                                   code  fffc0764 18
  msgTaskStart                               code  fffc081c 18
  msgTooBig                                  code  fffc4737 18
  msgVar                                     code  fffc467a 18
  msgVarSpace                                code  fffc4626 18
  msgWhat                                    code  fffc45d8 18
  msgs                                      const  004800 16
  nmeSerial                                  code  fffc14bc 18
  prCRLF                                     code  fffc4070 18
  pword1                                     code  fffc33b4 18
  pword2                                     code  fffc33d0 18
  qToChk                                     code  fffc163a 18
  return1                                    code  fffc2ec4 18
  rnd1                                       code  fffc3b74 18
  rnd2                                       code  fffc3b84 18
  switchflag                                const  004200 16
  sysx1                                      code  fffc34b0 18
  tah1                                       code  fffc3404 18
  tid                                        code  fffc239c 18
  timeout                                    code  80000000000001cc 32
  toAsciiHex                                 code  fffc33f4 18
  toUpper                                    code  fffc4318 18
  tstv_notfound                              code  fffc3988 18
  usrJmp                                    const  0007a0 12
  v0                                        const  80000000000001cc 64

Undefined Symbols
  AUXIN                                      code  8000000000000214 32
  AUXIN_INIT                                 code  80000000000002d2 32
  AUXOUT                                     code  8000000000000212 32
  AUXOUT_FLUSH                               code  80000000000002df 32
  AUXOUT_INIT                                code  80000000000002d6 32
  FMTK_Initialize                            code  8000000000000164 32
  FMTK_PostMsg                               code  800000000000016c 32
  FMTK_Reschedule                            code  80000000000001c1 32
  FMTK_SetTaskPriority                       code  8000000000000168 32
  FMTK_StartApp                              code  8000000000000170 32
  SDReadSector                               code  80000000000002d3 32
  SDWriteSector                              code  80000000000002d8 32
  _cls                                       code  8000000000000257 32
  _rdcf                                      code  8000000000000259 32
  gen_rand                                   code  8000000000000321 32
  timeout                                    code  80000000000001cc 32

  Macro Name
0 compressable instructions
The top 1024 are:
Comp  Opcode  Count
