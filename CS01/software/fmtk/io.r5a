; ============================================================================
;        __
;   \\__/ o\    (C) 2020  Robert Finch, Stratford
;    \  __ /    All rights reserved.
;     \/_//     robfinch<remove>@finitron.ca
;       ||
;  
;
; This source file is free software: you can redistribute it and/or modify 
; it under the terms of the GNU Lesser General Public License as published 
; by the Free Software Foundation, either version 3 of the License, or     
; (at your option) any later version.                                      
;                                                                          
; This source file is distributed in the hope that it will be useful,      
; but WITHOUT ANY WARRANTY; without even the implied warranty of           
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
; GNU General Public License for more details.                             
;                                                                          
; You should have received a copy of the GNU General Public License        
; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
;
; ============================================================================

;Standard Devices are:

;#		Device					Standard name

;0		NULL device 			NUL		(OS built-in)
;1		Keyboard (sequential)	KBD		(OS built-in)
;2		Video (sequential)		VID		(OS built-in)
;3		Printer (parallel 1)	LPT
;4		Printer (parallel 2)	LPT2
;5		RS-232 1				COM1	(OS built-in)
;6		RS-232 2				COM2
;7		RS-232 3				COM3
;8		RS-232 4				COM4
;9		Parallel xfer	  PTI
;10		Floppy					FD0
;11		Floppy					FD1
;12		Hard disk				HD0
;13		Hard disk				HD1
;14
;15   VIA							VIA1
;16		SDCard					CARD1 	(OS built-in)
;17
;18
;19
;20
;21
;22
;23
;24
;25
;26
;27
;28		Audio						PSG1	(OS built-in)
;29
;30   Random Number		PRNG
;31		Debug						DBG

; The following must be at least 128 byte aligned
DVF_Base		EQU		$A000
DVF_Limit		EQU		$B000
DCB_Base    EQU   $B000
DCB_Limit   EQU   $BC00

;------------------------------------------------------------------------------
; Parameters:
;		a1 = I/O channel
;		a2 = function
;		a3 = data
;------------------------------------------------------------------------------

FMTK_IO:
	ldi		$v0,#32
	bgeu	$a1,$v0,.badDev
	ldi		$v1,#32
	bgeu	$a2,$v1,.badFunc
	sll		$v0,$a1,#7					; each device allowed 32 functions (*128)
	sll		$v1,$a2,#2					; function number *4
	add		$v0,$v0,#DVF_Base		; base address of function table
	or		$v0,$v0,$v1
	ldt		$v0,[$v0]
	beq		$v0,$x0,.badFunc
	call	[$v0]
.xit:
	jmp		ERETx
.badFunc:
	ldi		$v0,#E_BadDevOp
	bra		.xit
.badDev:
	ldi		$v0,#E_BadDevNum
	bra		.xit

;------------------------------------------------------------------------------
; Parameters:
;		a1 = I/O channel
;		a2 = field offset
;   a3 = 0 = get word, 1 = get byte
;------------------------------------------------------------------------------

FMTK_GetDCBField:
	ldi		$v0,#32
	bgeu	$a1,$v0,.badDev
	ldi		$v1,#DCB_Size
	bgeu	$a2,$v1,.badFunc
	mul		$v0,$a1,$v1		      ; each device allowed (96 bytes)
	add		$v0,$v0,#DCB_Base		; base address of function table
	add   $v0,$v0,$a2         ; add field offset
	beqz  $a3,.ldWord
	ldb   $v1,[$v0]
	bra   .ok
.ldWord:
  ldt   $v1,[$v0]
.ok:
  ldi   $v0,#E_Ok
.xit:
	jmp		ERETx
.badFunc:
	ldi		$v0,#E_BadDevOp
	bra		.xit
.badDev:
	ldi		$v0,#E_BadDevNum
	bra		.xit

;------------------------------------------------------------------------------
; Parameters:
;		a1 = I/O channel
;		a2 = field offset
;   a3 = 0 = get word, 1 = get byte
;   a4 = value to set
;------------------------------------------------------------------------------

FMTK_SetDCBField:
	ldi		$v0,#32
	bgeu	$a1,$v0,.badDev
	ldi		$v1,#DCB_Size
	bgeu	$a2,$v1,.badFunc
	mul		$v0,$a1,$v1		      ; each device allowed (96 bytes)
	add		$v0,$v0,#DCB_Base		; base address of function table
	add   $v0,$v0,$a2         ; add field offset
	beqz  $a3,.stWord
	stb   $a4,[$v0]
	bra   .ok
.stWord:
  stt   $a4,[$v0]
.ok:
  ldi   $v0,#E_Ok
.xit:
	jmp		ERETx
.badFunc:
	ldi		$v0,#E_BadDevOp
	bra		.xit
.badDev:
	ldi		$v0,#E_BadDevNum
	bra		.xit

;------------------------------------------------------------------------------
; Parameters:
;		a0 = I/O channel
;		a1 = points to function table
;------------------------------------------------------------------------------

CopyDevFuncTbl:
	sll		$v0,$a0,#7					; each device allowed 32 functions (*128)
	add		$v0,$v0,#DVF_Base		; base address of function table
	ldi		$t0,#32							; 32 functions to copy
.again:
	ldt		$t2,[$a1]
	stt		$t2,[$v0]
	add		$a1,$a1,#4
	add		$v0,$v0,#4
	sub		$t0,$t0,#1
	bgt		$t0,$x0,.again
	ret

;------------------------------------------------------------------------------

CopyDevDCB:
  ldi   $v0,#DCB_Size
  mul   $v0,$a0,$v0
  add   $v0,$v0,#DCB_Base
	ldi		$t0,#24							; 24 words to copy
.again:
	ldt		$t2,[$a1]
	stt		$t2,[$v0]
	add		$a1,$a1,#4
	add		$v0,$v0,#4
	sub		$t0,$t0,#1
	bgt		$t0,$x0,.again
	ret


;------------------------------------------------------------------------------
;    Compare the current TID against the device owner to see if the device
; is owned.
;------------------------------------------------------------------------------

CheckDevOwner:
  sub   $sp,$sp,#4
  stt   $s1,[$sp]
  ldi   $a0,#14             ; FMTK: GetCurrentTid
  ecall
  mov   $s1,$v1
  ldi   $a0,#27             ; FMTK Get DCB Field
  ldi   $a2,#DCB_hJob
  ldi   $a3,#1              ; get byte
  ecall
  and   $v1,$v1,#15
  xor   $v1,$v1,$s1
  bnez  $v1,.notOwner
  ldi   $v0,#E_Ok
.xit:
  ldt   $s1,[$sp]
  add   $sp,$sp,#4
  ret
.notOwner:
  ldi   $v0,#E_NotOwner
  ldi   $a0,#28             ; FMTK Set DCB field
  ldi   $a2,#DCB_LastErc
  ldi   $a3,#0              ; word
  mov   $a4,$v0             
  ecall                     
  bra   .xit

