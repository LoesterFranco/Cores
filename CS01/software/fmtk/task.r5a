; ============================================================================
;        __
;   \\__/ o\    (C) 2020  Robert Finch, Stratford
;    \  __ /    All rights reserved.
;     \/_//     robfinch<remove>@finitron.ca
;       ||
;  
;
; This source file is free software: you can redistribute it and/or modify 
; it under the terms of the GNU Lesser General Public License as published 
; by the Free Software Foundation, either version 3 of the License, or     
; (at your option) any later version.                                      
;                                                                          
; This source file is distributed in the hope that it will be useful,      
; but WITHOUT ANY WARRANTY; without even the implied warranty of           
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
; GNU General Public License for more details.                             
;                                                                          
; You should have received a copy of the GNU General Public License        
; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
;
; ============================================================================

	code
	align	4
OSCallTbl:
	dh		FMTK_Initialize					; 0
	dh		FMTK_StartTask					; 1
	dh		FMTK_ExitTask
	dh		FMTK_KillTask
	dh		FMTK_SetTaskPriority
	dh		FMTK_Sleep							; 5
	dh		FMTK_AllocMbx
	dh		FMTK_FreeMbx
	dh		FMTK_PostMsg
	dh		FMTK_SendMsg
	dh		FMTK_WaitMsg						; 10
	dh		FMTK_PeekMsg
	dh		FMTK_StartApp           ; 12
	dh		FMTK_ExitApp            ; 13
	dh		FMTK_GetCurrentTid
	dh		FMTK_TCBFinalizerExit   ; 15
	dh		FMTK_KillApp
	dh		0
	dh		0
	dh		0
	dh		FMTK_HasIOFocus					; 20
	dh		FMTK_SwitchIOFocus			; 21
	dh		FMTK_ReleaseIOFocus			; 22
	dh		FMTK_ForceReleaseIOFocus	; 23
	dh		FMTK_RequestIOFocus			; 24
	dh		0
	dh		FMTK_IO									; 26
	dh    FMTK_GetDCBField        ; 27
	dh    FMTK_SetDCBField        ; 28
	dh    0
	dh    0
	dh    0
	dh    GetPamBit               ; 32
	dh    FetchMemoryWord         ; 33
	dh    Monitor                 ; 34
	dh    GetIRQFlag              ; 35
	dh    SetIRQFlag              ; 36

qToChk:
	db	0,0,0,1,0,0,2,1
	db	0,0,3,1,0,0,2,1
	db	0,0,0,1,0,0,2,1
	db	0,0,3,1,0,0,2,1

	align	4

;------------------------------------------------------------------------------
;------------------------------------------------------------------------------

FMTKInit:
	stt		$x0,QNDX
	stt		$x0,TID_POOL
	stt   $x0,APPID_POOL
	stt   $x0,CHAINA0
	stt		$x0,missed_ticks
	ldi   $t0,#0
	csrrw $x0,#CSR_TASKID,$t0   ; task id = 0
	stt		$x0,TimeoutList
	stt		$x0,READYQ
	stt		$x0,READYQ+4
	stt		$x0,READYQ+8
	stt		$x0,READYQ+12
	
	stt		$x0,IOFocusTbl
	stt		$x0,IOFocusNdx
	
	; zero out device function table
	ldi		$t0,#DVF_Base
	ldi		$t1,#32*32
.0003:
	stt		$x0,[$t0]
	add		$t0,$t0,#4
	sub		$t1,$t1,#1
	bgtz	$t1,.0003

	; Initialize free message list
	stt		$x0,FreeMsg

	; Initialize mailboxes
	ldi   $t0,#MBX_BLOCKPTR_BUFSZ
.0001:
	stt   $x0,MbxBlockPtr[$t1]
	add   $t1,$t1,#4
	sub   $t0,$t0,#1
	bnez  $t0,.0001

	; unlock the system semaphore	
	mUnlockSemaphore(SysSema)
	ret

FMTK_Initialize:
  mEI
  call  FMTKInit
  jmp   OSExit
 
;------------------------------------------------------------------------------
; Get the task id for the currently running task.
;
; Returns:
;		v0 = task id
;------------------------------------------------------------------------------

GetCurrentTid:
	mGetCurrentTid
	ret

FMTK_GetCurrentTid:
  mEI
	mGetCurrentTid
	mov		$a1,$a0
	ldi		$a0,#E_Ok
	jmp		OSExit

GetIRQFlag:
  mEI
  ldt   $a1,IRQFlag
  ldi   $a0,#E_Ok
  jmp   OSExit

SetIRQFlag:
  mEI
  stt   $a1,IRQFlag
  ldi   $a0,#E_Ok
  jmp   OSExit

;------------------------------------------------------------------------------
; Setting the task priority will take effect the next time the task is
; scheduled.
;
; Parameters:
;   $a1 = new priority to set
; Returns:
;   $a0 = E_Ok
;------------------------------------------------------------------------------

FMTK_SetTaskPriority:
  mGetCurrentTid
  slt   $t0,$a0,#NTASK
  beqz  $t0,.badTid
  sll   $t0,$a0,#2
  ldt   $t0,TidTcbMap[$t0]
  and   $t1,$t0,#TCBPTR_MASK
  bnez  $t1,.badPtr
  stb   $a1,TCBPriority[$t0]
  ldi   $a0,#E_Ok
  jmp   OSExit
.badTid:
  ldi   $a0,#E_BadTid
  jmp   OSExit
.badPtr:
  call  FreeTID
  ldi   $a0,#E_BadTcbPointer
  jmp   OSExit
 
;------------------------------------------------------------------------------
; Parameters:
;		a0 = task id
;------------------------------------------------------------------------------

MapOSPages:
  mov     $s3,$a0
	ldi			$a0,#OSPAGES	; number of pages pre-mapped
	ldi			$a1,#0
	sll			$a1,$s3,#16		; put ASID in proper spot
.nxt:
	mvmap		$x0,$a1,$a1
	add			$a1,$a1,#1
	sub			$a0,$a0,#1
	bgtz		$a0,.nxt
	ret

;------------------------------------------------------------------------------
; Select the next task to run. The ready lists are searched in a circular
; fashion beginning with the list identified indirectly by QNDX. There are
; four ready lists to hold tasks of four different priorities. 
;
; Parameters:
;		none
; Modifies:
;		v1, t0, t1, t2, t3, t4
;	Returns:
;		$v0 = task id of task to run
;------------------------------------------------------------------------------
  align 16
SelectTaskToRun:
	; Pick the first queue to check, occasionally the queue
	; chosen isn't the highest priority one in order to 
	; prevent starvation of lower priority tasks.
	ldbu	$a1,QNDX						; get index into que check table
	add		$a1,$a1,#1					; increment it, and limit
	and		$a1,$a1,#31
	stb		$a1,QNDX						; store back
	ldbu	$a1,qToChk[$a1]			; assume this will be valid
	ldi		$t2,#4							; 4 queues to check
.nxtQ:
  popq  $a0,$a1
;  bltz  $a0,.dq             ; valid queue entry?
  and   $t0,$a0,#$4000      ; queue empty?
  bnez  $t0,.nxtQa
  srl   $t0,$a0,#8
  bnez  $t0,.dq
.nxtQa:
	add		$a1,$a1,#1					; no, advance to next queue
	and		$a1,$a1,#3					; 4 max
	sub		$t2,$t2,#1					;
	bgtz	$t2,.nxtQ				    ; go back to check next queue
	; Here, nothing else is actually ready to run?
	; Switch to idle task
	ldi   $a0,#0
	ldi   $a1,#3
  pushq $a0,$a1
	ret
.dq:
  ; If we got a task but it isn't actually ready anymore go back
  ; and get another task. This is how tasks get removed from the
  ; queue.
;  and   $t2,$v0,#$4000      ; empty flag?
;  bnez  $t2,.nxtQa
  and   $a0,$a0,#$FF
  sll   $t2,$a0,#2
  ldt   $t2,TidTcbMap[$t2]
	and   $a1,$t2,#TCBPTR_MASK  ; is it a valid pointer?
	bnez  $a1,.nxtQ
  ldb   $t0,TCBStatus[$t2]  ;
  and   $t0,$t0,#TS_READY
  beqz  $t0,.nxtQ
  ; The task was ready and we removed it from the queue by popping
  ; it so push it back on the queue.
  ; The task's priority level may have been changed, so update accordingly.
  ldbu  $a1,TCBPriority[$t2]
  pushq $a0,$a1
	ret

;------------------------------------------------------------------------------
; Swap from outgoing context to incoming context.
;
; Parameters:
;		s1 = pointer to TCB of outgoing context
;		s2 = pointer to TCB of incoming context
; Must not modify:
;   $t2
; Modifies:
;   $t0,$t1,$t3
;------------------------------------------------------------------------------
  align 16
SwapContext:
	; Save outgoing register set in TCB
	csrrs	$x0,#$7C0,#4	; select prior register set for Rs2
	stt		$x1,TCBxRA[$s1]
	stt		$x2,TCBxSP[$s1]
	stt		$x3,TCBxGP[$s1]
	stt		$x4,TCBxTP[$s1]
	stt		$x5,TCBxT0[$s1]
	stt		$x6,TCBxT1[$s1]
	stt		$x7,TCBxT2[$s1]
	stt		$x8,TCBxFP[$s1]
	stt		$x9,TCBxS1[$s1]
	stt		$x10,TCBxA0[$s1]
	stt		$x11,TCBxA1[$s1]
	stt		$x12,TCBxA2[$s1]
	stt		$x13,TCBxA3[$s1]
	stt		$x14,TCBxA4[$s1]
	stt		$x15,TCBxA5[$s1]
	stt		$x16,TCBxA6[$s1]
	stt		$x17,TCBxA7[$s1]
	stt		$x18,TCBxS2[$s1]
	stt		$x19,TCBxS3[$s1]
	stt		$x20,TCBxS4[$s1]
	stt		$x21,TCBxS5[$s1]
	stt		$x22,TCBxS6[$s1]
	stt		$x23,TCBxS7[$s1]
	stt		$x24,TCBxS8[$s1]
	stt		$x25,TCBxS9[$s1]
	stt		$x26,TCBxS10[$s1]
	stt		$x27,TCBxS11[$s1]
	stt		$x28,TCBxT3[$s1]
	stt		$x29,TCBxT4[$s1]
	stt		$x30,TCBxT5[$s1]
	stt		$x31,TCBxT6[$s1]
	csrrc	$x0,#$7C0,#4				; select machine register set for Rs2
	csrrw	$t3,#$341,$x0				; save off mepc
	stt		$t3,TCBepc[$s1]
	; Now save off segment registers
	ldi		$t1,#0
.svseg:
	mvseg	$t0,$x0,$t1
	sll		$t3,$t1,#2
	add		$t3,$t3,$s1
	stt		$t0,TCBbases[$t3]
	add		$t1,$t1,#1
	and		$t1,$t1,#15
	bnez	$t1,.svseg

	; Switch memory maps
;	srl		$v0,$a1,#10					; convert pointer to tid
;	and		$v0,$v0,#$F					; mask to 16 task
  ldbu  $a0,TCBmid[$s2]
	csrrw	$x0,#$181,$a0				; set ASID
  ldbu  $a0,TCBtid[$s2]
	csrrw $x0,#CSR_TASKID,$a0
	; User map has now been switched

	; Restore segment register set
	ldi		$t1,#0
.rsseg:
	sll		$t3,$t1,#2
	add		$t3,$t3,$s2
	ldt		$t0,TCBbases[$t3]
	mvseg	$x0,$t0,$t1
	add		$t1,$t1,#1
	and		$t1,$t1,#15
	bnez	$t1,.rsseg

	ldt		$t3,TCBepc[$s2]			; restore epc
	csrrw	$x0,#$341,$t3
	; Restore incoming registers
	csrrs	$x0,#$7C0,#1				; select user regset for Rd
	ldt		$x1,TCBxRA[$s2]
	ldt		$x2,TCBxSP[$s2]
	ldt		$x3,TCBxGP[$s2]
	ldt		$x4,TCBxTP[$s2]
	ldt		$x5,TCBxT0[$s2]
	ldt		$x6,TCBxT1[$s2]
	ldt		$x7,TCBxT2[$s2]
	ldt		$x8,TCBxFP[$s2]
	ldt		$x9,TCBxS1[$s2]
	ldt		$x10,TCBxA0[$s2]
	ldt		$x11,TCBxA1[$s2]
	ldt		$x12,TCBxA2[$s2]
	ldt		$x13,TCBxA3[$s2]
	ldt		$x14,TCBxA4[$s2]
	ldt		$x15,TCBxA5[$s2]
	ldt		$x16,TCBxA6[$s2]
	ldt		$x17,TCBxA7[$s2]
	ldt		$x18,TCBxS2[$s2]
	ldt		$x19,TCBxS3[$s2]
	ldt		$x20,TCBxS4[$s2]
	ldt		$x21,TCBxS5[$s2]
	ldt		$x22,TCBxS6[$s2]
	ldt		$x23,TCBxS7[$s2]
	ldt		$x24,TCBxS8[$s2]
	ldt		$x25,TCBxS9[$s2]
	ldt		$x26,TCBxS10[$s2]
	ldt		$x27,TCBxS11[$s2]
	ldt		$x28,TCBxT3[$s2]
	ldt		$x29,TCBxT4[$s2]
	ldt		$x30,TCBxT5[$s2]
	ldt		$x31,TCBxT6[$s2]
	csrrc	$x0,#$7C0,#1				; select machine regset for Rd
	ret

;------------------------------------------------------------------------------
; Operating system call dispatcher.
; On entry machine registers are selected.
;------------------------------------------------------------------------------
  align 16
OSCALL:
  mEI
  csrrs $x0,#$7C1,#1    ; set OS running semaphore
	csrrs	$t1,#$7C0,#2		; select user regs for Rs1		
	mov		$a0,$a0					; move user to machine
	mov		$a1,$a1
	mov		$a2,$a2
	mov		$a3,$a3
	mov		$a4,$a4
	mov		$a5,$a5
	csrrc	$x0,#$7C0,#15		; get back machine registers for all
;OSCALL2:
	and		$a0,$a0,#63     ; limit 64 functions
	; The function address table is compressed by assuming all the code is
	; located within the same 64kB block of memory. We're really saving bytes
	; here.
	add		$a0,$a0,$a0     ; shift left one bit, assume add might be faster
	ldwu  $t0,OSCallTbl[$a0]  ; get the low order 16 bits of the address
	or    $t0,$t0,#$FFFC0000  ; add in the high order address bits
	beqz  $t0,OSExit
	jmp		[$t0]

;------------------------------------------------------------------------------
; Exit from the operating system. All operating system routines use this
; fragment of code to return. Return values are transferred to the previously
; active register set.
;------------------------------------------------------------------------------

OSExit:
  mDI
	csrrs	$x0,#$7C0,#1				; select user for destination
	mov		$a1,$a1							; move return values to user registers
	mov		$a0,$a0
	csrrc $x0,#$7C1,#1        ; clear OS running semaphore
	jmp   ERETx2

;------------------------------------------------------------------------------
; Time accounting.
; Update the length of time the task has been running.
;
; Parameters:
;		s1 = pointer to TCB
; Modifies:
;		t2,t3,t4,t5
;------------------------------------------------------------------------------

AccountTime:
.again:
;	csrrw	$t3,#$741,$x0					; get high time
;	csrrw	$t2,#$701,$x0					; get low time
;	csrrw	$t4,#$741,$x0
;	bne		$t3,$t4,.again
	ldt		$t2,Tick
	stt		$t2,TCBEndTick[$s1]
	ldt		$t3,TCBStartTick[$s1]
	sub		$t4,$t2,$t3						; end - start
	ldt		$t5,TCBTicks[$s1]
	add		$t5,$t5,$t4						; ticks + (end - start)
	stt		$t5,TCBTicks[$s1]
	ret

;------------------------------------------------------------------------------
; UpdateMsgFields
;    Place message data in target address by calling PeekMsg().
;
; Parameters:
;   $a0 = target tid
;   $t2 = TCB status
;   $s2 = target TCB to update
; Modifies:
;   $a1,$t3,$v0
;------------------------------------------------------------------------------
  align 16
UpdateMsgFields:
  gcsub $sp,$sp,#4
  stt   $ra,[$sp]
  and   $t3,$t2,#TS_WAITMSG
  beqz  $t3,.notWaiting
	; If a message is ready, update status to ready and put
	; message in target memory. The task will be returning
	; from a WaitMsg so a return status of E_Ok is also set.
	ldi		$t3,#E_NoMsg						; setup to return E_NoMsg
	stt		$t3,TCBxA0[$s2]					; in v0
	and		$t3,$t2,#TS_MSGRDY
	beqz	$t3,.noMsg
	mov   $t4,$a1                 ; save $a1
	ldt		$a1,TCBxA1[$s2]					; user a1 (x20)
	ldt		$a2,TCBxA2[$s2]					; user a2 (x20)
	ldt		$a3,TCBxA3[$s2]					; user a3 (x20)
	ldt		$a4,TCBxA4[$s2]					; user a4 (x20)
	ldt		$a5,TCBxA5[$s2]					; user a5 (x20)
	call  PeekMsg
	mov   $a1,$t4                 ; restore $a1
	ldi		$t3,#E_Ok						    ; setup to return E_Ok
	stt		$t3,TCBxA0[$s2]					; in v0
.noMsg:
	and		$t2,$t2,#~(TS_WAITMSG|TS_MSGRDY)  ; mask out message ready status
	stb		$t2,TCBStatus[$s2]
.notWaiting:
  ldt   $ra,[$sp]
  add   $sp,$sp,#4
  ret

;------------------------------------------------------------------------------
; Sleep for a number of ticks. Tick interval determined by the VIA timer #3.
; Passing a time of zero or less causes the function to return right away.
;
; Parameters:
;		$a1 = length of time to sleep (must be >= 0)
; Returns:
;		$v0 = E_Ok
;   $v1 = 1 = context switched, 0 = same context
;------------------------------------------------------------------------------
  align 16
FMTK_Sleep:
  mEI
	bltz	$a1,OSExit
	mDI
	mGetCurrentTid
	slt   $s1,$a0,#NTASK
	beqz  $s1,.badCurTid
	sll   $a0,$a0,#2
	ldt   $s1,TidTcbMap[$a0]
	and   $t2,$s1,#TCBPTR_MASK
	mov   $s2,$s1               ; for bad ppinter processing
	bnez  $t2,.badPtr
	beqz	$a1,.0001
	srl		$a0,$a0,#2						; a0 = current tid
	call	RemoveFromReadyQueue
	call	InsertIntoTimeoutList	; a1 = timeout
.0001:
	ldbu	$a0,TCBStatus[$s1]		; flag task as no longer running
	and		$a0,$a0,#~TS_RUNNING
	stb		$a0,TCBStatus[$s1]

	call	AccountTime						; uses s1
	call	SelectTaskToRun
  slt   $t2,$a0,#NTASK
  beqz  $t2,.badTid
  sll   $a0,$a0,#2            ; $a0 = tid
	ldt		$s2,TidTcbMap[$a0]		; s2 = pointer to incoming TCB
	and   $t2,$s2,#TCBPTR_MASK  ; is it a valid pointer?
	bnez  $t2,.badPtr
	ldbu	$t2,TCBStatus[$s2]		; x2 = incoming status
	or		$t2,$t2,#TS_RUNNING|TS_READY	; set status = running
	stb   $t2,TCBStatus[$s2]
	ldt		$t3,TCBException[$s2]	;
	beqz	$t3,.noException
	; set link register to catch handler address
	;{
	;	t->regs[29] = t->regs[28];   // set link register to catch handler
	;	t->epc = t->regs[28];        // and the PC register
	;	t->regs[1] = t->exception;    // r1 = exception value
	;	t->exception = 0;
	;	t->regs[2] = 45;              // r2 = exception type
	;}
	stt		$t3,TCBxA0[$s2]						; r1 = exception
	stt		$x0,TCBException[$s2]	; tcb->exception = 0
	ldi		$t3,#45
	stt		$t3,TCBxA1[$s2]						; r2 = 45
.noException:
	ldi   $a1,#0
	beq		$s1,$s2,.noCtxSwitch	; incoming and outgoing contexts the same?
	call	SwapContext
	ldi   $a1,#1
.noCtxSwitch:
	call  UpdateMsgFields       ; must be after context is set
	ldt		$t2,Tick						; get tick
	stt		$t2,TCBStartTick[$s1]
	mEI
	ldi   $a0,#E_Ok
	jmp		OSExit
.badCurTid:
  ldi   $a0,#0
  csrrw $x0,#CSR_TASKID,$a0 ; force the tid to a good value
.badTid:
	mEI
  ldi   $a0,E_BadTid
  jmp   OSExit
.badPtr:
  srl   $a0,$a0,#2
  call  FreeTID
	mEI
  ldi   $a0,E_BadTcbPointer
  jmp   OSExit

;------------------------------------------------------------------------------
; SchedulerIRQ meant to be called from the timer ISR. This routine will not
; be invoked if the operating system is active.
; Does not return anything.
; The user mode task may be switched to the highest priority task.
;------------------------------------------------------------------------------
  align 16
FMTK_SchedulerIRQ:
	; See if the OS was interrupted. Done by getting the register set stacking
	; depth.
	csrrw $a0,#$7C1,$x0   ; Is the OS running?
	and   $a0,$a0,#1
	beqz  $a0,.noOS
	ret                   ; refuse to continue this function
.noOS:
	decto                 ; decrement timeouts for tasks on timeout list
	gcsub	$sp,$sp,#4
	stt		$ra,[$sp]
  mDI
	mGetCurrentTid
	slt   $s1,$a0,#NTASK
	beqz  $s1,.badTid
	sll   $a0,$a0,#2
	ldt   $s1,TidTcbMap[$a0]
	and   $t5,$s1,#$FFF803BF    ; pointer legal bits
	bnez  $t5,.badPtr
; Might need the following if the external timer isn't used.
;	csrrw	$v0,#$701,$x0					; get the time
;	add		$v0,$v0,#600000				; wait 600,000 cycles @20MHz (30ms)
;	csrrw	$x0,#$321,$v0					; set next interrupt time
	ldt		$t5,Tick							; update tick count
	add		$t5,$t5,#1
	stt		$t5,Tick
	call	AccountTime
	ldbu	$t5,TCBStatus[$s1]
	or		$t5,$t5,#TS_PREEMPT
	and		$t5,$t5,#~TS_RUNNING	; no longer running, but may still be ready
	stb		$t5,TCBStatus[$s1]
	; Keep popping the timeout list as long as there are tasks on it with
	; expired timeouts.
	ldi		$s5,#0
	ldi		$s3,#1
	; There should be at least 64 clock cycles between the time the decto
	; instruction is used to decrement timeouts and the getzl instruction
	; is used to pop tasks that have timed out. The decto instruction runs
	; in the background.
.0001:
	getzl	$s4           ; pop task with timeout finished
	and   $a1,$s4,#$4000  ; empty queue?
	bnez  $a1,.qEmpty
	bge   $s4,$x0,.0001 ; valid info?
.0002:
  and   $s4,$s4,#$1F        ; mask off queue address bits
	sll   $s4,$s4,#2          ; $s4 = index
	ldt   $t4,TidTcbMap[$s4]
	and   $a0,$t4,#TCBPTR_MASK  ; is it a valid pointer?
	bnez  $a0,.0001
	ldbu	$t2,TCBStatus[$t4]
	and		$t2,$t2,#~(TS_TIMEOUT|TS_WAITMSG) ; no longer timing out or waiting
	stb		$t2,TCBStatus[$t4]
	srl   $a0,$s4,#2
	mMbxRemoveTask
	call	InsertIntoReadyQueue
	bra   .0001
.qEmpty:
.bypass2:
	; The ready queue was just updated, there could be new tasks
	; ready to run.
	call	SelectTaskToRun
	slt   $t3,$a0,#NTASK
	beqz  $t3,.badTid
  sll   $a0,$a0,#2
	ldt		$s2,TidTcbMap[$a0]	; s2 = pointer to incoming TCB
	and   $t3,$s2,#TCBPTR_MASK
	bnez  $t3,.badPtr
	lbu		$t3,TCBStatus[$s2]	; t3 = incoming status
	or		$t2,$t3,#TS_RUNNING|TS_READY	; status = running
	ldt		$t3,TCBException[$s2]	;
	beqz	$t3,.noException
	; set link register to catch handler address
	;{
	;	t->regs[29] = t->regs[28];   // set link register to catch handler
	;	t->epc = t->regs[28];        // and the PC register
	;	t->regs[1] = t->exception;    // r1 = exception value
	;	t->exception = 0;
	;	t->regs[2] = 45;              // r2 = exception type
	;}
.noException:
	beq		$s1,$s2,.noCtxSwitch
	call	SwapContext
.noCtxSwitch:
	call  UpdateMsgFields       ; must be after context set
	ldt		$ra,[$sp]
	add		$sp,$sp,#4
	ldt		$t2,Tick					; get tick
	stt		$t2,TCBStartTick[$s1] ;[$s1]
  mEI
	ret
.badPtr:
  call  FreeTID
	ldt		$ra,[$sp]
	add		$sp,$sp,#4
	mEI
  ret
.badTid:
	ldt		$ra,[$sp]
	add		$sp,$sp,#4
	mEI
  ret

;------------------------------------------------------------------------------
; Start a task.
;	Task status is set to ready, priority normal, and the task is inserted into
; the ready queue. Segment registers are setup for a flat memory model.
; 
;	Parameters:
;   $a1 = app id
;		$a2 = memory required (task's local memory)
;		$a3 = start pc (usually $400)
;	Modifies:
;	Returns:
;		$a0 = E_Ok if successful
;		$a1 = tid of started task if successful
;------------------------------------------------------------------------------
  align 16
FMTK_StartTask:
  mEI
  mov   $s3,$a1       ; $s3 = mid
  mov   $s2,$a2       ; $s2 = memory required
  mov   $s5,$a3       ; $s5 = start address
  ldi   $a0,#1024     ; TCB is 1kB
  mDI
  call  PAMAlloc      ; allocate storage for the TCB
	bltz	$a0,.err
	add   $s4,$a0,#64     ; TCB is 64 bytes into allocated memory
  call  AllocTID
	bnez	$a0,.err
  stb   $a1,TCBtid[$s4]
  stb   $s3,TCBmid[$s4] ; record the app id (mid)
  sll   $a1,$a1,#2          ; convert Tid to map index
  mov   $s1,$s4             ; $s1 = pointer to TCB
  stt   $s4,TidTcbMap[$a1]  ; store the TCB pointer in the map
;	call	FreeAll
;	call	MapOSPages			; Map OS pages into address space
  mov   $a0,$s3         ; $a0 = mid
	call	AllocStack
	or		$t0,$a0,#$0FFC	; set stack pointer
	stt		$t0,TCBxSP[$s1]
	stt		$s5,TCBepc[$s1]	; address task will begin at
	ldi		$t0,#TS_READY
	stb		$t0,TCBStatus[$s1]
	ldi		$t0,#2					; normal execution priority
	stb		$t0,TCBPriority[$s1]
	stt   $x0,TCBTimeout[$s1]
	; leave segment base at $0, flat memory model
	ldi		$t0,#6							; read,write
	stt		$t0,TCBbases[$s1]		; bases 0 to 11
	stt		$t0,TCBbases+4[$s1]
	stt		$t0,TCBbases+8[$s1]
	stt		$t0,TCBbases+12[$s1]
	stt		$t0,TCBbases+16[$s1]
	stt		$t0,TCBbases+20[$s1]
	stt		$t0,TCBbases+24[$s1]
	stt		$t0,TCBbases+28[$s1]
	stt		$t0,TCBbases+32[$s1]
	stt		$t0,TCBbases+36[$s1]
	stt		$t0,TCBbases+40[$s1]
	stt		$t0,TCBbases+44[$s1]
	ldi		$t0,#5							; read,execute
	stt		$t0,TCBbases+48[$s1]	; segs 12 to 15
	stt		$t0,TCBbases+52[$s1]
	stt		$t0,TCBbases+56[$s1]
	stt		$t0,TCBbases+60[$s1]
;	srl		$a0,$s1,#LOG_TCBSZ	; need the tid again
  stt   $x0,TCBMbxNext[$s1]
  stt   $x0,TCBMbxPrev[$s1]
  ldbu  $a0,TCBtid[$s1]
  ; Don't add the idle task to the queue.
  beqz  $a0,.idleTask
	call	InsertIntoReadyQueue
.idleTask:
	mEI
	mov		$a1,$a0
	ldi   $a0,#E_Ok
  jmp   OSExit
.err:
	mEI
  jmp   OSExit

;------------------------------------------------------------------------------
; Exit the current task.
;
; Parameters:
;		none
; Modifies:
;		a1 = task id
;------------------------------------------------------------------------------

FMTK_ExitTask:
	mGetCurrentTid
	mov		$a1,$a0
	; fall through to KillTask
	
;------------------------------------------------------------------------------
; Parameters:
;		a1 = tid of task to kill
;------------------------------------------------------------------------------
  align 16
FMTK_KillTask:
  mEI
	beqz	$a1,.immortal		    ; tid #0 is immortal (the system)
	ldi		$t0,#TS_UNDEAD			; flag task as undead
	sll		$a1,$a1,#2	        
	mDI
	ldt   $a1,TidTcbMap[$a1]  ; convert TID to TCB address
	stb		$t0,TCBStatus[$a1]
	; Move the task to the undead queue, it will no longer be selected by the
	; scheduler.
	ldi   $t0,#UNDEADQ
	stb   $t0,TCBPriority[$a1]
;	ldbu  $a0,TCBmid[$a1]
;	call	FreeAll							; free all the memory associated with the task
	; Now make task ID available for reuse
	ldbu  $a0,TCBtid[$a1]
	call  FreeTID
	mEI
.immortal:
	ldi		$a0,#E_Ok
	jmp		OSExit

	