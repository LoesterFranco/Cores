                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/const.r5a",1
                        	.file "../fmtk/const.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	; First 256 bytes are for integer register set
                        	; Second 256 bytes are for float register set
                        	; Leave some room for 64-bit regs
                        	TCBsegs			EQU		$200		; segment register storage
                        	TCBepc			EQU		$280
                        	TCBStatus		EQU		$288
                        	TCBPriority	EQU		$289
                        	TCBContextSaved	EQU		$28A
                        	TCBWaitMbx	EQU		$28C
                        	TCBStackBot	EQU		$290
                        	TCBMsgD1		EQU		$298
                        	TCBMsgD2		EQU		$2A0
                        	TCBMsgD3		EQU		$2A8
                        	TCBStartTime	EQU		$2B0
                        	TCBEndTime		EQU		$2B8
                        	TCBElapsedTime		EQU		$2C0
                        	TCBException	EQU	$2C8
                        	TCBNext			EQU		$2D0
                        	TCBPrev			EQU		$2D8
                        	TCBTimeout	EQU		$2E0
                        	IOF_NEXT		EQU		$2E8
                        	IOF_PREV		EQU		$2F0
                        	TCBName			EQU		$2F8
                        	TCBKbdHead	EQU		$300
                        	TCBKbdTail	EQU		$301
                        	TCBKbdBuf		EQU		$308
                        	; 328 end of keyboard buffer
                        	TCBResource	EQU		$328
                        	TCBVideoMem	EQU		$330
                        	TCBpVideo		EQU		$338
                        	
                        	TS_NONE			EQU		0
                        	TS_READY		EQU		1
                        	TS_DEAD			EQU		2
                        	TS_MSGRDY		EQU		4
                        	TS_WAITMSG	EQU		8
                        	TS_TIMEOUT	EQU		16
                        	TS_PREEMPT	EQU		32
                        	TS_RUNNING	EQU		128
                        	
                        	; error codes
                        	E_Ok		=		0x00
                        	E_Arg		=		0x01
                        	E_BadMbx	=		0x04
                        	E_QueFull	=		0x05
                        	E_NoThread	=		0x06
                        	E_NotAlloc	=		0x09
                        	E_NoMsg		=		0x0b
                        	E_Timeout	=		0x10
                        	E_BadAlarm	=		0x11
                        	E_NotOwner	=		0x12
                        	E_QueStrategy =		0x13
                        	E_BadDevNum	=		0x18
                        	E_DCBInUse	=		0x19
                        	E_BadCallno	=  0x1A
                        	; Device driver errors
                        	E_BadDevNum	=		0x20
                        	E_NoDev		=		0x21
                        	E_BadDevOp	=		0x22
                        	E_ReadError	=		0x23
                        	E_WriteError =		0x24
                        	E_BadBlockNum	=	0x25
                        	E_TooManyBlocks	=	0x26
                        	
                        	; resource errors
                        	E_NoMoreMbx	=		0x40
                        	E_NoMoreMsgBlks	=	0x41
                        	E_NoMoreAlarmBlks	=0x44
                        	E_NoMoreTCBs	=	0x45
                        	E_NoMem		= 12
                        	
                        	CSR_REGSET	equ		$790
                        	SYS_MUTEX		equ		$FFDBFF00
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/config.r5a",1
                        	.file "../fmtk/config.r5a",1
                        	MAX_TID		EQU		63
                        	MAX_MID		EQU		63
                        	MAX_ASID	EQU		63
                        	NR_TCB		EQU		64
                        	NR_MBX		EQU		256
                        	NR_MSG		EQU		2048
                        	LOG_TCBSZ	EQU		10
                        	LOG_PGSZ	EQU		16
                        	PAGESZ		EQU		65536
                        	PAGES_PER_TASK	EQU		4096	; maximum number of pages per task
                        	PAGES_PER_MAP		EQU		4096
                        	OSPAGES		EQU		3			; pages of memory dedicated to OS
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/device.r5a",1
                        	.file "../fmtk/device.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2014-2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; DeviceDriver.inc
                        	; - Device driver structures and constants                                                                         
                        	; ============================================================================
                        	
                        	;	.global			; global constants
                        	
                        	; Device Control Block
                        	;
                        	DCB_Name			EQU		0		; string: first byte is length, 11 chars max
                        	DCB_Type			EQU		0x0C
                        	DCB_nBPB			EQU		0x10
                        	DCB_LastErc			EQU		0x18		; last error code
                        	DCB_StartBlock		EQU		0x20		; starting block number (partitioned devices)
                        	DCB_nBlocks			EQU		0x28		; number of blocks on device
                        	DCB_pCmdProc		EQU		0x30		; pointer to command processor routine
                        	DCB_ReentCount		EQU		0x38		; re-entrancy count (1 to 255)
                        	DCB_fSingleUser		EQU		0x39
                        	DCB_hJob			EQU		0x40		; handle to associated job
                        	DCB_Mbx				EQU		0x48
                        	DCB_pSema			EQU		0x50		; pointer to device semaphore
                        	DCB_Resv1			EQU		0x58		; reserved
                        	DCB_Resv2			EQU		0x60		; reserved
                        	DCB_Size			EQU		0x68
                        	
                        	; Device command opcodes
                        	;
                        	DVC_Nop				EQU		0
                        	DVC_Setup			EQU		1
                        	DVC_Initialize		EQU		2
                        	DVC_Status			EQU		3
                        	DVC_MediaCheck		EQU		4
                        	DVC_BuildBPB		EQU		5
                        	DVC_Open			EQU		6
                        	DVC_Close			EQU		7
                        	DVC_GetChar			EQU		8
                        	DVC_PeekChar		EQU		9
                        	DVC_GetCharDirect	EQU		10
                        	DVC_PeekCharDirect	EQU		11
                        	DVC_InputStatus		EQU		12
                        	DVC_PutChar			EQU		13
                        	DVC_SetPosition		EQU		15
                        	DVC_ReadBlock		EQU		16
                        	DVC_WriteBlock		EQU		17
                        	DVC_VerifyBlock		EQU		18
                        	DVC_OutputStatus	EQU		19
                        	DVC_FlushInput		EQU		20
                        	DVC_FlushOutput		EQU		21
                        	DVC_IRQ				EQU		22
                        	DVC_IsRemoveable	EQU		23
                        	DVC_IOCTRL_READ		EQU		24
                        	DVC_IOCTRL_WRITE	EQU		25
                        	DVC_OutputUntilBusy	EQU		26
                        	
                        	MAX_DEV_OP			EQU		31
                        	
                        	
                        	DRSP_DONE			EQU		1
                        	
                        	;Standard Devices are:
                        	
                        	;#		Device					Standard name
                        	
                        	;0		NULL device 			NUL		(OS built-in)
                        	;1		Keyboard (sequential)	KBD		(OS built-in)
                        	;2		Video (sequential)		VID		(OS built-in)
                        	;3		Printer (parallel 1)	LPT
                        	;4		Printer (parallel 2)	LPT2
                        	;5		RS-232 1				COM1	(OS built-in)
                        	;6		RS-232 2				COM2
                        	;7		RS-232 3				COM3
                        	;8		RS-232 4				COM4
                        	;9		Parallel xfer	  PTI
                        	;10		Floppy					FD0
                        	;11		Floppy					FD1
                        	;12		Hard disk				HD0
                        	;13		Hard disk				HD1
                        	;14
                        	;15
                        	;16		SDCard					CARD1 	(OS built-in)
                        	;17
                        	;18
                        	;19
                        	;20
                        	;21
                        	;22
                        	;23
                        	;24
                        	;25
                        	;26
                        	;27
                        	;28		Audio						PSG1	(OS built-in)
                        	;29
                        	;30   Random Number		PRNG
                        	;31		Debug						DBG
                        	
                        	NR_DCB			EQU		32
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/macro.r5a",1
                        	.file "../fmtk/macro.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	; macros have to be defined before they are encountered.
                        	
                        	; unlock the a semaphore	
                        	macro mUnlockSemaphore (adr)
	ldi		v0,#-1
	sw		v0,adr
endm
                        	
                        	; Look at the asid register for task id
                        	macro mGetCurrentTid
	csrrw	v0,#$181,x0
	and		v0,v0,#MAX_TID
endm
                        	
                        	macro	mHasFocus
	ldi		$a0,#20
	ecall
endm
                        	
                        	macro mSleep(tm)
	ldi		$a0,#5
	ldi		$a1,#tm
	ecall
endm
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	macro mWaitForFocus
.WFF1@:
	
	ldi		$a0,#20
	ecall
bne		v1,x0,.HasFocus@
	call	SerialPeekChar	;Direct
	ldi		a0,#$14							; CTRL-T
	bne		$v0,$a0,.WFF2@
	call	SerialGetChar
	ldi		$a0,#21							; switch IO Focus
	ecall
	bra		.WFF1@
.WFF2@:
	
	ldi		$a0,#5
	ldi		$a1,#1
	ecall

	bra		.WFF1@
.HasFocus@:
endm
                        	
                        	;------------------------------------------------------------------------------
                        	; Pop an entry off the timeout list. It is assumed the entry is popped when
                        	; its timeout reached zero. Hence there is no adjustment of the following
                        	; timeout made. Routine used only in the schedulerIRQ, so written as a macro.
                        	;
                        	; Parameters:
                        	;		v0 = top timeout list
                        	; Modifies:
                        	;		v1,t0,t1,t2,t3
                        	;	Returns:
                        	;		v0 = timeout list entry tid
                        	;------------------------------------------------------------------------------
                        	
                        	macro mPopTimeoutList
	sll		$t0,$v0,#LOG_TCBSZ		; tid to pointer
	lbu		$v1,TCBStatus[$t0]		; no longer a waiting status
	and		$t1,$v1,#TS_WAITMSG		; check if waiting for a message
	beqz	$t1,.noWait@
	mMbxRemoveTask							; remove task from mailbox list
.noWait@:
	and		$v1,$v1,#~(TS_WAITMSG|TS_TIMEOUT)
	stb		$v1,TCBStatus[$t0]
	ldw		$v1,TCBNext[$t0]			; get next task on timeout list
	stw		$v1,TimeoutList				; update list head
	ldi		$t1,#NR_TCB						; check valid handle
	bgeu	$v1,$t1,.done@
	ldi		$t1,#-1								;
	sll		$v1,$v1,#LOG_TCBSZ		; v1 = tid to pointer
	stw		$t1,TCBPrev[$v1]			; TimeoutList->prev = -1
.done@:
	ldi		$t1,#-1								; reset next and prev indexes
	stw		$t1,TCBNext[$t0]			; on popped task
	stw		$t1,TCBPrev[$t0]
endm
                        	
                        	
                        	macro mGetVideoPtr:
	
	csrrw	v0,#$181,x0
	and		v0,v0,#MAX_TID
sll		$v0,$v0,#LOG_TCBSZ
	ldo		$v0,TCBpVideo[$v0]
	ldi		$v0,#$FFD00000
endm
                        	
                        	macro mDispIRQLive
	ldo      $v0,$FFD00000+440
	add     	$v0,$v0,#1
	sto      $v0,$FFD00000+440
endm
                        	
                        	macro mLockSysMutex
	
	csrrw	v0,#$181,x0
	and		v0,v0,#MAX_TID
sll		$v0,$v0,#1
	or		$v0,$v0,#1
	ldi		$t0,#$FFDBFF00
.lock@:
	sto		$v0,[$t0]
	ldo		$v1,[$t0]
	bne		$v0,$v1,.lock@
endm
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/global.r5a",1
                        	.file "../fmtk/global.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	;
                        	; 00000000	+-----------------------------------
                        	;						| Task Control Blocks (64 x 1kB)
                        	; 00010000	+-----------------------------------
                        	;						| Message Array (2048 x 32b)
                        	; 00020000	+-----------------------------------
                        	;						| Mailbox Array (256 x 32b)
                        	; 00022000	+-----------------------------------
                        	;						| Device Control Blocks (32 x 256b)
                        	; 00024000	+-----------------------------------
                        	
                        	msgs		EQU		$10000
                        	mbxs		EQU		$20000
                        	mbxs_end	EQU	$22000
                        	; The following must be at least 256 byte aligned
                        	DVF_Base		EQU		$22000
                        	DVF_Limit		EQU		$24000
                        	QNDX		EQU		$24304
                        	READYQ	EQU		$24308
                        	PIDMAP	EQU		$24310
                        	missed_ticks	equ		$24320
                        	TimeoutList		equ		$24328
                        	Tick		EQU		$24330
                        	SysSema	EQU		$24340
                        	FreeMsg	EQU		$24350
                        	RDYQ0		EQU		$24400
                        	RDYQ1		EQU		$24500
                        	RDYQ2		EQU		$24600
                        	RDYQ3		EQU		$24700
                        	CursorX		equ		$24800
                        	CursorY		equ		$24801
                        	DispAttr	equ		$24808
                        	IOFocusNdx		EQU		$24810
                        	IOFocusTbl		EQU		$24818
                        	SwitchIOFocus	EQU		$24820
                        	hKeybdMbx	equ		$24822
                        	_KeyState1	equ		$24824
                        	_KeyState2 equ		$24825
                        	_KeyLED			equ		$24826
                        	NPAGES	equ		$24828
                        	_randStream	equ		$24830
                        	
                        	SerRcvBuf		EQU		$25000
                        	SerXmitBuf	EQU		$25400
                        	SerHeadRcv	EQU		$25800
                        	SerTailRcv	EQU		$25804
                        	SerHeadXmit	EQU		$25808
                        	SerTailXmit	EQU		$2580C
                        	SerRcvXon		EQU		$25810
                        	SerRcvXoff	EQU		$25811
                        	
                        	
                        	
                        	
                        	
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	
                        	CTRLC				equ		$03
                        	BS					equ		$08
                        	LNFD				equ		$0A
                        	CR					equ		$0D
                        	XON					equ		$11
                        	XOFF				equ		$13
                        	DEL					equ		$7F
                        	LEDS				equ		$FFDC0600
                        	BUTTONS			equ		$FFDC0600
                        	VIA					equ		$FFDC0600
                        	VIA_PA			equ		$04
                        	VIA_DDRA		equ		$0C
                        	VIA_T1CL		equ		$10
                        	VIA_T1CH		equ		$14
                        	VIA_ACR			equ		$2C
                        	VIA_PCR			equ		$30
                        	VIA_IFR			equ		$34
                        	VIA_IER			equ		$38
                        	VIA_PARAW		equ		$3C
                        	UART				equ		$FFDC0A00
                        	UART_TRB		equ		$00
                        	UART_STAT		equ		$04
                        	UART_CMD		equ		$08
                        			; First 16kB is for TCB's
                        	INBUF				equ		$14100
                        	switchflag	equ		$14200
                        	milliseconds	equ		$14208
                        	
                        	
                        	.file "boot.r5a",32
                        		code	18 bits
                        	;------------------------------------------------------------------------------
                        	; Exception vector table.
                        	;------------------------------------------------------------------------------
                        		org		$FFFC0000				; user mode exception
FFFC0000 0D50006F		jmp		IRQRout
FFFC0004 00000000		org		$FFFC0040				; supervisor mode exception (not possible)
FFFC0008 00000000
FFFC000C 00000000
FFFC0010 00000000
FFFC0014 00000000
FFFC0018 00000000
FFFC001C 00000000
FFFC0020 00000000
FFFC0024 00000000
FFFC0028 00000000
FFFC002C 00000000
FFFC0030 00000000
FFFC0034 00000000
FFFC0038 00000000
FFFC003C 00000000
FFFC0040 0950006F		jmp		IRQRout
FFFC0044 00000000		org		$FFFC0080				; hypervisor mode exception (not possible)
FFFC0048 00000000
FFFC004C 00000000
FFFC0050 00000000
FFFC0054 00000000
FFFC0058 00000000
FFFC005C 00000000
FFFC0060 00000000
FFFC0064 00000000
FFFC0068 00000000
FFFC006C 00000000
FFFC0070 00000000
FFFC0074 00000000
FFFC0078 00000000
FFFC007C 00000000
FFFC0080 0550006F		jmp		IRQRout
FFFC0084 00000000		org 	$FFFC00C0				; machine mode exception
FFFC0088 00000000
FFFC008C 00000000
FFFC0090 00000000
FFFC0094 00000000
FFFC0098 00000000
FFFC009C 00000000
FFFC00A0 00000000
FFFC00A4 00000000
FFFC00A8 00000000
FFFC00AC 00000000
FFFC00B0 00000000
FFFC00B4 00000000
FFFC00B8 00000000
FFFC00BC 00000000
FFFC00C0 0150006F		jmp		IRQRout
FFFC00C4 00000000		org		$FFFC00FC				; non-maskable interrupt
FFFC00C8 00000000
FFFC00CC 00000000
FFFC00D0 00000000
FFFC00D4 00000000
FFFC00D8 00000000
FFFC00DC 00000000
FFFC00E0 00000000
FFFC00E4 00000000
FFFC00E8 00000000
FFFC00EC 00000000
FFFC00F0 00000000
FFFC00F4 00000000
FFFC00F8 00000000
FFFC00FC 0040006F		jmp		MachineStart
                        	
                        	;------------------------------------------------------------------------------
                        	; User mode code starts here
                        	;------------------------------------------------------------------------------
                        		org		$FFFC0100
                        	MachineStart:
FFFC0100 1FFFC737		ldi		$sp,#$1FFFBFF8		; setup machine mode stack pointer
FFFC0104 FF870713
FFFC0108 FFFC0D37		ldi		$t0,#$FFFC0000
FFFC010C 000D0D13
FFFC0110 301D1073		csrrw $x0,#$301,$t0			; set tvec
                        		; The dram needs a bit of time before it's ready for access. along with
                        		; the video screen which also needs some time. So the first thing done is
                        		; to delay for about 3 seconds.
FFFC0114 FFDC0DB7		ldi		$t1,#VIA
FFFC0118 600D8D93
FFFC011C 0FF06D13		ldi		$t0,#$000000FF		; set via so we can see output on LEDs
FFFC0120 01ADA623		stt		$t0,VIA_DDRA[$t1]
FFFC0124 03938937		ldi		$a0,#60000000			; 3s in 50ns intervals
FFFC0128 70090913
FFFC012C 704000EF		call	_MicroDelay
FFFC0130 551000EF		call	MMUInit					; initialize MMU for address space zero.
FFFC0134 571010EF		call	FMTKInit
FFFC0138 0D1010EF		call	VideoInit
FFFC013C 714010EF		call	ViaInit
FFFC0140 198010EF		call	SerialInit
                        	;	call	_KeybdInit
FFFC0144 064010EF		call	PicInit
FFFC0148 745030EF		call	_PRNGInit
FFFC014C 00006D13		ldi		$t0,#0
FFFC0150 181D1073		csrrw	$x0,#$181,$t0		; set ASID
FFFC0154 FFFC0D37		ldi		$t0,#UserStart
FFFC0158 168D0D13
FFFC015C 341D1073		csrrw	$x0,#$341,$t0		; set mepc
FFFC0160 30047073		csrrc	$x0,#$300,#8		; disable interrupts (on eret)
FFFC0164 10000073		eret									; switch to user mode
                        	UserStart:
FFFC0168 00106913		ldi		$a0,#1
FFFC016C 000069B7		ldi		$a1,#24000
FFFC0170 DC098993
FFFC0174 FFFC0A37		ldi		$a2,#UserStart2
FFFC0178 180A0A13
FFFC017C 00000073		ecall
                        	;	ldi		$a0,#1					; start TinyBasic
                        	;	ldi		$a1,#32000
                        	;	ldi		$a2,#CSTART
                        	;	ecall
                        	.0001:
                        	;	wfi
                        	;	bra		.0001
                        	UserStart2:
FFFC0180 AFFF8737		ldi		$sp,#$AFFF7FF8			; setup user mode stack pointer
FFFC0184 FF870713
FFFC0188 399060EF		call	_SpriteDemo
FFFC018C 03938937		ldi		$a0,#60000000				; 3s in 50ns intervals
FFFC0190 70090913
FFFC0194 69C000EF		call	_MicroDelay
FFFC0198 40006913		ldi		$a0,#$400						; clear screen
FFFC019C 00000073		ecall
FFFC01A0 40106913		ldi		$a0,#$401						; home cursor
FFFC01A4 00000073		ecall
FFFC01A8 00E06913		ldi		$a0,#14							; Get current tid
FFFC01AC 00000073		ecall
FFFC01B0 0008E9B3		mov		$a1,$v1
FFFC01B4 01806913		ldi		$a0,#24							; RequestIOFocus
FFFC01B8 00000073		ecall
                        	;	ldi		$sp,#$1FFF7FF8			; setup user mode stack pointer
                        	;	ldi		$sp,#$AFFFFFFC
FFFC01BC 00406D13		ldi		$t0,#$04						; turn on the LED
FFFC01C0 FFDC0637		stt		$t0,VIA+VIA_PARAW
FFFC01C4 63C60613
FFFC01C8 00060633
FFFC01CC 01A62023
FFFC01D0 01006E13		ldi		$t2,#16							; send an XON just in case
                        	;	ldi		$a3,#XON
                        	;.0004:
                        	;	call	SerialPutChar
                        	;	sub		$t2,$t2,#1
                        	;	bnez	$t2,.0004
                        	.0002:
                        	;	ldi		$a0,#msgStart				; spit out a startup message
                        	;	ldi		$t0,#$FFD00000
                        	;	ldo		$t1,datAttr
                        	.0005:
                        	;	ldbu	$a1,[$a0]
                        	;	add		$a0,$a0,#1
                        	;	beqz	$a1,.0004
                        	;	or		$a1,$a1,$t1
                        	;	sto		$a1,[$t0]
                        	;	add		$t0,$t0,#8
                        	;	bra		.0005
                        	.0004:
FFFC01D4 10300073		pfi
FFFC01D8 40306913		ldi		$a0,#$403						; video putstring()
FFFC01DC FFFC19B7		ldi		$a1,#msgStart
FFFC01E0 9A498993
FFFC01E4 00000073		ecall
                        	;		ldi		a0,#1
                        	;		ldi		a1,#24000
                        	;		ldi		a2,#Monitor
                        	;		ecall
FFFC01E8 10300073		pfi
FFFC01EC 160030EF		call	DumpReadyList
FFFC01F0 10000A63		bra		MonEntry
                        	
                        			; Now a loop to recieve and echo back characters
                        	.0003:
FFFC01F4 310010EF		call	SerialPeekChar
FFFC01F8 FE084EE3		blt		$v0,$x0,.0003
FFFC01FC 00086933		mov		$a0,$v0
FFFC0200 3C8010EF		call	SerialPutChar
FFFC0204 FE0008E3		bra		.0003
                        	
                        		align	8                        	
                        	datAttr:
FFFC0208 001F0000		dco		$FFFF001F0000
FFFC020C 0000FFFF
                        	
                        		align	8                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	IdleTask:
FFFC0210 00000063		bra		IdleTask
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a character from input device. Checks for a CTRL-T which indicates to
                        	; switch the I/O focus.
                        	;
                        	; Parameters:
                        	;		none
                        	; Returns:
                        	;		v0 = character, -1 if none available
                        	;------------------------------------------------------------------------------
                        	
                        	Getch:
FFFC0214 FE870713		sub		$sp,$sp,#24
FFFC0218 00173023		sto		$ra,[$sp]
FFFC021C 01273423		sto		$a0,8[$sp]
FFFC0220 01373823		sto		$a1,16[$sp]
                        	;	mWaitForFocus
                        	;	call	SerialGetChar
FFFC0224 10300073		pfi
FFFC0228 00006913		ldi		$a0,#0					; don't block
FFFC022C 775030EF		call	_DBGGetKey
FFFC0230 00073083		ldo		$ra,[$sp]
FFFC0234 00873903		ldo		$a0,8[$sp]
FFFC0238 01073983		ldo		$a1,16[$sp]
FFFC023C 01870713		add		$sp,$sp,#24
FFFC0240 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	Putch:
FFFC0244 FA870713		sub		$sp,$sp,#88
FFFC0248 00173023		sto		$ra,[$sp]
FFFC024C 01073423		sto		$v0,8[$sp]
FFFC0250 01573823		sto		$a3,16[$sp]
FFFC0254 01173C23		sto		$v1,24[$sp]
FFFC0258 03373023		sto		$a1,32[$sp]
FFFC025C 03A73423		sto		$t0,40[$sp]
FFFC0260 03B73823		sto		$t1,48[$sp]
FFFC0264 03C73C23		sto		$t2,56[$sp]
FFFC0268 05D73023		sto		$t3,64[$sp]
FFFC026C 05E73423		sto		$t4,72[$sp]
FFFC0270 05F73823		sto		$t5,80[$sp]
FFFC0274 00096AB3		mov		$a3,$a0
                        	;	call	SerialPutChar
                        	;	call	VideoPutChar
FFFC0278 10300073		pfi
FFFC027C 40206913		ldi		$a0,#$402
FFFC0280 00000073		ecall
                        	;	ldi		$a1,#5							; serial port = 5
                        	;	call	fputc
                        	;	ldi		$a1,#2							; video = 2
                        	;	call	fputc
FFFC0284 00073083		ldo		$ra,[$sp]
FFFC0288 00873803		ldo		$v0,8[$sp]
FFFC028C 01073A83		ldo		$a3,16[$sp]
FFFC0290 01873883		ldo		$v1,24[$sp]
FFFC0294 02073983		ldo		$a1,32[$sp]
FFFC0298 02873D03		ldo		$t0,40[$sp]
FFFC029C 03073D83		ldo		$t1,48[$sp]
FFFC02A0 03873E03		ldo		$t2,56[$sp]
FFFC02A4 04073E83		ldo		$t3,64[$sp]
FFFC02A8 04873F03		ldo		$t4,72[$sp]
FFFC02AC 05073F83		ldo		$t5,80[$sp]
FFFC02B0 05870713		add		$sp,$sp,#88
FFFC02B4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; fputc - put a character to an I/O device. If the task doesn't have the I/O
                        	; focus then it is rescheduled, allowing another task to run.
                        	;
                        	; Stack Space:
                        	;		6 words
                        	; Register Usage:
                        	;		a0 = FMTK_IO specify
                        	;		a2 = device putchar function
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a3 = character to put
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	fputc:
FFFC02B8 FD070713		sub		$sp,$sp,#48
FFFC02BC 00173023		sto		$ra,[$sp]
FFFC02C0 01073423		sto		$v0,8[$sp]
FFFC02C4 01273823		sto		$a0,16[$sp]
FFFC02C8 01173C23		sto		$v1,24[$sp]
FFFC02CC 03373023		sto		$a1,32[$sp]
FFFC02D0 03473423		sto		$a2,40[$sp]
                        	;	mWaitForFocus
FFFC02D4 10300073		pfi
FFFC02D8 01A06913		ldi		$a0,#26							; FMTK_IO
FFFC02DC 00D06A13		ldi		$a2,#13							; putchar function
FFFC02E0 00000073		ecall
FFFC02E4 00073083		ldo		$ra,[$sp]
FFFC02E8 00873803		ldo		$v0,8[$sp]
FFFC02EC 01073903		ldo		$a0,16[$sp]
FFFC02F0 01873883		ldo		$v1,24[$sp]
FFFC02F4 02073983		ldo		$a1,32[$sp]
FFFC02F8 02873A03		ldo		$a2,40[$sp]
FFFC02FC 03070713		add		$sp,$sp,#48
FFFC0300 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	MonEntry:
                        	;		flw			$f2,fltTen
                        	;		fsw			$f2,f2Save
                        	;		flw			$f1,fltTen
                        	;		fsw			$f1,f1Save
                        	;		fadd		$f18,$f2,$f1
                        	;		fsw			$f18,f18Save
FFFC0304 00A06913			ldi		$a0,#10
FFFC0308 00606A13			ldi		$a2,#6
                        	;		call	fltToString
                        	;		ldi		$a0,#STRTMP
                        	;		call	PutString
                        	
                        	Monitor:
FFFC030C B0000737		ldi		$sp,#$AFFFFFFC
FFFC0310 FFC70713
FFFC0314 10300073		pfi
FFFC0318 3000F073		csrrc	$x0,#$300,#1
                        	;		call	DumpReadyList
                        	;		call	DumpTimeoutList
FFFC031C 3000E073		csrrs	$x0,#$300,#1
FFFC0320 00006213		ldi		$s1,#0					; s1 = input pointer
FFFC0324 00D06913		ldi		$a0,#CR
FFFC0328 F1DFF0EF		call	Putch
FFFC032C 00A06913		ldi		$a0,#LNFD
FFFC0330 F15FF0EF		call	Putch
FFFC0334 03E06913		ldi		$a0,#'>'
FFFC0338 F0DFF0EF		call	Putch
                        	.0001:
FFFC033C ED9FF0EF			call	Getch						; wait until character pressed
FFFC0340 FE084EE3			blt		$v0,$x0,.0001
FFFC0344 00A84D13			xor		$t0,$v0,#LNFD			; ignore line feed
FFFC0348 0E0D0C63			beq		$t0,$x0,.procLine
FFFC034C 00D84D13			xor		$t0,$v0,#CR
FFFC0350 0E0D0863			beq		$t0,$x0,.procLine
FFFC0354 00884D13			xor		$t0,$v0,#BS
FFFC0358 080D0263			beq		$t0,$x0,.doBackspace
FFFC035C 07F84D13			xor		$t0,$v0,#DEL
FFFC0360 020D0263			beq		$t0,$x0,.doDelete
FFFC0364 00014637			sb		$v0,INBUF[$s1]
FFFC0368 10060613
FFFC036C 00460633
FFFC0370 01060023
FFFC0374 00120213			add		$s1,$s1,#1
FFFC0378 00086933			mov		$a0,$v0
FFFC037C EC9FF0EF			call	Putch
FFFC0380 FA000EE3			bra		.0001
                        	.doDelete:
FFFC0384 000262B3			mov		$s2,$s1
FFFC0388 00128293			add		$s2,$s2,#1
                        	.0002:
FFFC038C 00014637			lb		$t0,INBUF[$s2]
FFFC0390 10060613
FFFC0394 00560633
FFFC0398 00060D03
FFFC039C 00014637			sb		$t0,INBUF-1[$s2]
FFFC03A0 0FF60613
FFFC03A4 00560633
FFFC03A8 01A60023
FFFC03AC 00128293			add		$s2,$s2,#1
FFFC03B0 00014637			add		$t0,$s2,#INBUF
FFFC03B4 10060613
FFFC03B8 00560D33
FFFC03BC 00014637			slt		$t0,$t0,#INBUF+$7F
FFFC03C0 17F60613
FFFC03C4 FC0D14E3			bne		$t0,$x0,.0002
FFFC03C8 00014637			sb		$x0,INBUF[$s2]
FFFC03CC 10060613
FFFC03D0 00560633
FFFC03D4 00060023
FFFC03D8 F60002E3			bra		.0001
                        	.doBackspace:
FFFC03DC F60200E3			beq		$s1,$x0,.0001		; can't backspace anymore
FFFC03E0 00086933			mov		$a0,$v0					; show the backspace
FFFC03E4 E61FF0EF			call	Putch
FFFC03E8 FFF20213			sub		$s1,$s1,#1
FFFC03EC 000262B3			mov		$s2,$s1
                        	.0003:
FFFC03F0 00014637			lb		$t0,INBUF+1[$s2]
FFFC03F4 10160613
FFFC03F8 00560633
FFFC03FC 00060D03
FFFC0400 00014637			sb		$t0,INBUF[$s2]
FFFC0404 10060613
FFFC0408 00560633
FFFC040C 01A60023
FFFC0410 00128293			add		$s2,$s2,#1
FFFC0414 00014637			add		$t0,$s2,#INBUF
FFFC0418 10060613
FFFC041C 00560D33
FFFC0420 00014637			slt		$t0,$t0,#INBUF+$7F
FFFC0424 17F60613
FFFC0428 FC0D14E3			bne		$t0,$x0,.0003
FFFC042C 00014637			sb		$x0,INBUF[$s2]
FFFC0430 10060613
FFFC0434 00560633
FFFC0438 00060023
FFFC043C F00000E3			bra		.0001
                        	.procLine:
FFFC0440 00014637			sb		$x0,INBUF[$s1]
FFFC0444 10060613
FFFC0448 00460633
FFFC044C 00060023
FFFC0450 00006213			ldi		$s1,#0
                        	.skip:
FFFC0454 00014637			lb		$t0,INBUF[$s1]
FFFC0458 10060613
FFFC045C 00460633
FFFC0460 00060D03
FFFC0464 100D0663			beq		$t0,$x0,.0005
FFFC0468 03ED4D93			xor		$t1,$t0,#'>'
FFFC046C 000D9663			bne		$t1,$x0,.0004
                        	.skip2:
FFFC0470 00120213			add		$s1,$s1,#1
FFFC0474 FE0000E3			bra		.skip
                        	.0004:
FFFC0478 020D4D93			xor		$t1,$t0,#' '
FFFC047C FE0D8AE3			beq		$t1,$x0,.skip2
FFFC0480 009D4D93			xor		$t1,$t0,#'\t'
FFFC0484 FE0D86E3			beq		$t1,$x0,.skip2
FFFC0488 04DD4D93			xor		$t1,$t0,#'M'
FFFC048C 0E0D8463			beq		$t1,$x0,doMem
FFFC0490 04206D93			ldi		$t1,#'B'
FFFC0494 05BD1463			bne		$t0,$t1,.0006
FFFC0498 00106913			ldi		$a0,#1					; Start task
FFFC049C 000089B7			ldi		$a1,#32000			; 32 kB
FFFC04A0 D0098993
FFFC04A4 FFFC4A37			ldi		$a2,#CSTART			; start address
FFFC04A8 730A0A13
FFFC04AC 00000073			ecall
FFFC04B0 0008E233			mov		$s1,$v1					; save v1
FFFC04B4 FFFC1937			ldi		$a0,#msgCRLF
FFFC04B8 A6A90913
FFFC04BC 33C000EF			call	PutString
FFFC04C0 00026933			mov		$a0,$s1					; get back v1
FFFC04C4 2CC000EF			call	PutHexByte
FFFC04C8 FFFC1937			ldi		$a0,#msgTaskStart
FFFC04CC A5C90913
FFFC04D0 328000EF			call	PutString
FFFC04D4 679020EF			call  DumpReadyList
                        			;ldi		$a0,#5					; Reschedule task
                        			;ldi		$a1,#1					; sleep(0)
                        			;ecall
FFFC04D8 E35FF06F			jmp		Monitor
                        	.0006:
FFFC04DC 04406D93			ldi		$t1,#'D'
FFFC04E0 03BD1663			bne		$t0,$t1,.0007
FFFC04E4 00014637			lb		$t0,INBUF+1[$s1]
FFFC04E8 10160613
FFFC04EC 00460633
FFFC04F0 00060D03
FFFC04F4 05406D93			ldi		$t1,#'T'
FFFC04F8 01BD1663			bne		$t0,$t1,.noT
FFFC04FC 741020EF			call	DumpTimeoutList
FFFC0500 E0DFF06F			jmp		Monitor
                        	.noT:
FFFC0504 649020EF			call 	DumpReadyList
                        			;ldi		$a0,#15
                        			;ecall
FFFC0508 E05FF06F			jmp		Monitor
                        	.0007:
FFFC050C 04506D93			ldi		$t1,#'E'
FFFC0510 01BD1463			bne		$t0,$t1,.0008
FFFC0514 0F00006F			jmp		EditMem
                        	.0008:
FFFC0518 04606D93			ldi		$t1,#'F'
FFFC051C 01BD1463			bne		$t0,$t1,.0009
FFFC0520 0FC0006F			jmp		FillMem
                        	.0009:
FFFC0524 05306D93			ldi		$t1,#'S'
FFFC0528 01BD1A63			bne		$t0,$t1,.0010
FFFC052C 00506913			ldi		$a0,#5					; sleep(0)
FFFC0530 00106993			ldi		$a1,#1
FFFC0534 00000073			ecall
FFFC0538 DD5FF06F			jmp		Monitor
                        	.0010:
FFFC053C 04B06D93			ldi		$t1,#'K'
FFFC0540 01BD1C63			bne		$t0,$t1,.0011
FFFC0544 138000EF			call	GetHexNum
FFFC0548 00306913			ldi		$a0,#3					; kill task
FFFC054C 000869B3			mov		$a1,$v0					; a0 = pid
FFFC0550 00000073			ecall
FFFC0554 DB9FF06F			jmp		Monitor
                        	.0011:
FFFC0558 03F06D93			ldi		$t1,#'?'
FFFC055C 01BD1A63			bne		$t0,$t1,.0012
FFFC0560 FFFC1937			ldi		$a0,#msgMonHelp
FFFC0564 9BD90913
FFFC0568 290000EF			call	PutString
FFFC056C DA1FF06F			jmp		Monitor
                        	.0012:
                        	.0005:
FFFC0570 D8000EE3			bra		Monitor
                        	
                        	doMem:
FFFC0574 FF870713			sub		$sp,$sp,#8
FFFC0578 00120213			add		$s1,$s1,#1
FFFC057C 00473023			sto		$s1,[$sp]
FFFC0580 00D06913			ldi		$a0,#CR
FFFC0584 CC1FF0EF			call	Putch
FFFC0588 00014937			ldi		$a0,INBUF
FFFC058C 10090913
FFFC0590 268000EF			call	PutString
FFFC0594 00073203			ldo		$s1,[$sp]
FFFC0598 00870713			add		$sp,$sp,#8
FFFC059C 0E0000EF			call	GetHexNum
FFFC05A0 00086333			mov		$s3,$v0
FFFC05A4 00120213			add		$s1,$s1,#1
FFFC05A8 0D4000EF			call	GetHexNum
FFFC05AC 006803B3			add		$s4,$v0,$s3
                        	.loop2:
FFFC05B0 C65FF0EF			call	Getch						; check for ctrl-c
FFFC05B4 00384813			xor		$v0,$v0,#3
FFFC05B8 D4080AE3			beq		$v0,$x0,Monitor
FFFC05BC 00D06913			ldi		$a0,#CR
FFFC05C0 C85FF0EF			call	Putch
FFFC05C4 00036933			mov		$a0,$s3
FFFC05C8 10300073			pfi
FFFC05CC 184000EF			call	PutHexWord
FFFC05D0 03A06913			ldi		$a0,#':'
FFFC05D4 C71FF0EF			call	Putch
FFFC05D8 00706293			ldi		$s2,#7
                        	.loop:
FFFC05DC 02006913			ldi		$a0,#' '
FFFC05E0 C65FF0EF			call	Putch
FFFC05E4 00030903			ldb		$a0,[$s3]
FFFC05E8 10300073			pfi
FFFC05EC 1A4000EF			call	PutHexByte
FFFC05F0 00130313			add		$s3,$s3,#1
FFFC05F4 FFF28293			sub		$s2,$s2,#1
FFFC05F8 FE02D2E3			bge		$s2,$x0,.loop
FFFC05FC FA736AE3			bltu	$s3,$s4,.loop2
FFFC0600 D00006E3			bra		Monitor		
                        	
                        	EditMem:
FFFC0604 078000EF			call	GetHexNum			; get address to edit
FFFC0608 00086333			mov		$s3,$v0
FFFC060C 00120213			add		$s1,$s1,#1
FFFC0610 06C000EF			call	GetHexNum			; get value to set
FFFC0614 00680023			stb		$s3,[$v0]			; update mem
FFFC0618 CF5FF06F			jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	;	>F 1000 800 EE
                        	; Fills memory beginning at address $1000 for $800 bytes with the value $EE
                        	;------------------------------------------------------------------------------
                        	
                        	FillMem:
FFFC061C 060000EF			call	GetHexNum			; get address
FFFC0620 00086333			mov		$s3,$v0
FFFC0624 00120213			add		$s1,$s1,#1
FFFC0628 054000EF			call	GetHexNum			; get length
FFFC062C 000863B3			mov		$s4,$v0
FFFC0630 00120213			add		$s1,$s1,#1
FFFC0634 048000EF			call	GetHexNum			; get byte to use
                        	.0001:
FFFC0638 01030023			stb		$v0,[$s3]
FFFC063C FFF38393			sub		$s4,$s4,#1
FFFC0640 10300073			pfi
FFFC0644 FE704AE3			bgt		$s4,$x0,.0001
FFFC0648 CC5FF06F			jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; Skip over spaces and tabs in the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	SkipSpaces:
                        	.skip2:
FFFC064C 00014637			ldb		$t0,INBUF[$s1]
FFFC0650 10060613
FFFC0654 00460633
FFFC0658 00060D03
FFFC065C 020D4D93			xor		$t1,$t0,#' '
FFFC0660 000D8863			beq		$t1,$x0,.skip1
FFFC0664 009D4D93			xor		$t1,$t0,#'\t'
FFFC0668 000D8463			beq		$t1,$x0,.skip1
FFFC066C 00008067			ret
                        	.skip1:
FFFC0670 00120213			add		$s1,$s1,#1
FFFC0674 10300073			pfi
FFFC0678 FC000AE3			bra		.skip2
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a hex number from the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	GetHexNum:
FFFC067C 00006813			ldi		$v0,#0							; v0 = num
FFFC0680 FF870713			sub		$sp,$sp,#8
FFFC0684 00173023			sto		$ra,[$sp]
FFFC0688 10300073			pfi
FFFC068C FC1FF0EF			call	SkipSpaces
                        	.next:
FFFC0690 00014637			lb		$t0,INBUF[$s1]
FFFC0694 10060613
FFFC0698 00460633
FFFC069C 00060D03
FFFC06A0 03006E13			ldi		$t2,#'0'
FFFC06A4 03CD4663			blt		$t0,$t2,.0001
FFFC06A8 03A06E13			ldi		$t2,#'9'+1
FFFC06AC 07CD4663			blt		$t0,$t2,.isDigit
FFFC06B0 04106E13			ldi		$t2,#'A'
FFFC06B4 01CD4E63			blt		$t0,$t2,.0001
FFFC06B8 04706E13			ldi		$t2,#'F'+1
FFFC06BC 03CD4263			blt		$t0,$t2,.isHexUpper
FFFC06C0 06106E13			ldi		$t2,#'a'
FFFC06C4 01CD4663			blt		$t0,$t2,.0001
FFFC06C8 06706E13			ldi		$t2,#'f'+1
FFFC06CC 03CD4863			blt		$t0,$t2,.isHexLower
                        	.0001:
FFFC06D0 10300073			pfi
FFFC06D4 00073083			ldo		$ra,[$sp]
FFFC06D8 00870713			add		$sp,$sp,#8
FFFC06DC 00008067			ret
                        	.isHexUpper:
FFFC06E0 10300073			pfi
FFFC06E4 00481813			sll		$v0,$v0,#4
FFFC06E8 FBFD0D13			sub		$t0,$t0,#'A'
FFFC06EC 00AD0D13			add		$t0,$t0,#10
FFFC06F0 01A86833			or		$v0,$v0,$t0
FFFC06F4 00120213			add		$s1,$s1,#1
FFFC06F8 F8000CE3			bra		.next
                        	.isHexLower:
FFFC06FC 10300073			pfi
FFFC0700 00481813			sll		$v0,$v0,#4
FFFC0704 F9FD0D13			sub		$t0,$t0,#'a'
FFFC0708 00AD0D13			add		$t0,$t0,#10
FFFC070C 01A86833			or		$v0,$v0,$t0
FFFC0710 00120213			add		$s1,$s1,#1
FFFC0714 F6000EE3			bra		.next
                        	.isDigit:
FFFC0718 10300073			pfi
FFFC071C 00481813			sll		$v0,$v0,#4
FFFC0720 FD0D0D13			sub		$t0,$t0,#'0'
FFFC0724 01A86833			or		$v0,$v0,$t0
FFFC0728 00120213			add		$s1,$s1,#1
FFFC072C F60002E3			bra		.next
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a word as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexDword:
FFFC0730 FF070713			sub		$sp,$sp,#16
FFFC0734 00173023			sto		$ra,[$sp]
FFFC0738 01273423			sto		$a0,8[$sp]
FFFC073C 00095913			srl		$a0,$a0,#32
FFFC0740 010000EF			call	PutHexWord
FFFC0744 00073083			ldo		$ra,[$sp]
FFFC0748 00873903			ldo		$a0,8[$sp]
FFFC074C 01070713			add		$sp,$sp,#16	; fall through to PutHexWord
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a word as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexWord:
FFFC0750 FF070713			sub		$sp,$sp,#16
FFFC0754 00173023			sto		$ra,[$sp]
FFFC0758 01273423			sto		$a0,8[$sp]
FFFC075C 01095913			srl		$a0,$a0,#16
FFFC0760 010000EF			call	PutHexHalf
FFFC0764 00073083			ldo		$ra,[$sp]
FFFC0768 00873903			ldo		$a0,8[$sp]
FFFC076C 01070713			add		$sp,$sp,#16	; fall through to PutHexHalf
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a half-word (16 bits) as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexHalf:
FFFC0770 FF070713			sub		$sp,$sp,#16
FFFC0774 00173023			sto		$ra,[$sp]
FFFC0778 01273423			sto		$a0,8[$sp]
FFFC077C 00895913			srl		$a0,$a0,#8
FFFC0780 010000EF			call	PutHexByte
FFFC0784 00073083			ldo		$ra,[$sp]
FFFC0788 00873903			ldo		$a0,8[$sp]		
FFFC078C 01070713			add		$sp,$sp,#16	; fall through to PutHexByte
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a byte as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexByte:
FFFC0790 FF070713			sub		$sp,$sp,#16
FFFC0794 00173023			sto		$ra,[$sp]
FFFC0798 01273423			sto		$a0,8[$sp]
FFFC079C 00495913			srl		$a0,$a0,#4		; put the high order nybble first
FFFC07A0 010000EF			call	PutHexNybble
FFFC07A4 00073083			ldo		$ra,[$sp]
FFFC07A8 00873903			ldo		$a0,8[$sp]
FFFC07AC 01070713			add		$sp,$sp,#16		; fall through to PutHexNybble
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a nybble as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexNybble:
FFFC07B0 FF070713			sub		$sp,$sp,#16
FFFC07B4 00173023			sto		$ra,[$sp]
FFFC07B8 01273423			sto		$a0,8[$sp]
FFFC07BC 00F97913			and		$a0,$a0,#15		; strip off high order bits
FFFC07C0 00A06D13			ldi		$t0,#10
FFFC07C4 10300073			pfi
FFFC07C8 01A94A63			blt		$a0,$t0,.lt10
FFFC07CC FF690913			sub		$a0,$a0,#10
FFFC07D0 04190913			add		$a0,$a0,#'A'
FFFC07D4 A71FF0EF			call	Putch
FFFC07D8 00000863			bra		.0001
                        	.lt10:
FFFC07DC 10300073			pfi
FFFC07E0 03090913			add		$a0,$a0,#'0'
FFFC07E4 A61FF0EF			call	Putch
                        	.0001:
FFFC07E8 00073083			ldo		$ra,[$sp]
FFFC07EC 00873903			ldo		$a0,8[$sp]
FFFC07F0 01070713			add		$sp,$sp,#16
FFFC07F4 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; PutString
                        	;    Put a string of characters to output device. Calls the 
                        	; Putch routine, so this routine also blocks if the transmitter is not
                        	; empty.
                        	;
                        	; Parameters:
                        	;		$a0 = pointer to null terminated string to put
                        	; Modifies:
                        	;		$t0 and $t1
                        	; Stack Space:
                        	;		2 words
                        	;------------------------------------------------------------------------------
                        	
                        	PutString:
FFFC07F8 FF070713		sub		$sp,$sp,#16				; save link register
FFFC07FC 00173023		sto		$ra,[$sp]
FFFC0800 01273423		sto		$a0,8[$sp]				; and argument
FFFC0804 00096DB3		mov		$t1,$a0						; t1 = pointer to string
                        	.0001:
FFFC0808 000DC903		ldbu	$a0,[$t1]
FFFC080C 001D8D93		add		$t1,$t1,#1				; advance pointer to next byte
FFFC0810 00090863		beqz	$a0,.done			; branch if done
FFFC0814 10300073		pfi
FFFC0818 A2DFF0EF		call	Putch							; output character
FFFC081C FE0006E3		bra		.0001
                        	.done:
FFFC0820 00073083		ldo		$ra,[$sp]					; restore return address
FFFC0824 00873903		ldo		$a0,8[$sp]				; and argument
FFFC0828 01070713		add		$sp,$sp,#16
FFFC082C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; MicroDelay - delay for a few clock ticks
                        	;
                        	; Parameters:
                        	;		a0 = wait in ticks (50 ns intervals)
                        	;------------------------------------------------------------------------------
                        	
                        	_MicroDelay:
FFFC0830 C0001EF3		csrrw	$t3,#$C00,$x0
                        	.0001:
FFFC0834 C0001F73		csrrw	$t4,#$C00,$x0
FFFC0838 41DF0F33		sub		$t4,$t4,$t3
FFFC083C 011F5F93		srl		$t5,$t4,#17
FFFC0840 FFDC0637		stt		$t5,VIA+VIA_PARAW
FFFC0844 63C60613
FFFC0848 00060633
FFFC084C 01F62023
FFFC0850 10300073		pfi
FFFC0854 012F2F33		slt		$t4,$t4,$a0
FFFC0858 FC0F1EE3		bnez	$t4,.0001
FFFC085C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	DumpMemmap:
FFFC0860 FE870713		sub			$sp,$sp,#24
FFFC0864 00173023		sto			$ra,[$sp]
FFFC0868 01073823		sto			$v0,16[$sp]
                        		;mGetCurrentTid
FFFC086C 00096833		mov			$v0,$a0
FFFC0870 01081D93		sll			$t1,$v0,#16
                        	.again:
FFFC0874 03B0090D		mvmap		$a0,$x0,$t1
FFFC0878 01B73423		sto			$t1,8[$sp]
FFFC087C EF5FF0EF		call		PutHexHalf
FFFC0880 00D06913		ldi			$a0,#CR
FFFC0884 9C1FF0EF		call		Putch
FFFC0888 00A06913		ldi			$a0,#LNFD
FFFC088C 9B9FF0EF		call		Putch
FFFC0890 00873D83		ldo			$t1,8[$sp]
FFFC0894 001D8D93		add			$t1,$t1,#1
FFFC0898 00FDFD13		and			$t0,$t1,#$F
FFFC089C FC0D1CE3		bnez		$t0,.again
FFFC08A0 00001637		or			$t1,$t1,#$FFF
FFFC08A4 FFF60613
FFFC08A8 01B66DB3
FFFC08AC 03B0090D		mvmap		$a0,$x0,$t1
FFFC08B0 EC1FF0EF		call		PutHexHalf
FFFC08B4 00D06913		ldi			$a0,#CR
FFFC08B8 98DFF0EF		call		Putch
FFFC08BC 00A06913		ldi			$a0,#LNFD
FFFC08C0 985FF0EF		call		Putch
FFFC08C4 00073083		ldo			$ra,[$sp]
FFFC08C8 01073803		ldo			$v0,16[$sp]
FFFC08CC 01870713		add			$sp,$sp,#24
FFFC08D0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Exception processing code starts here.
                        	; As per the RISCV privilege spec, the MSB indicates an external interrupt.
                        	; The system uses cause codes 32 to 63 for external devices. This cause code
                        	; range is reserved in the RISCV spec.
                        	;------------------------------------------------------------------------------
                        	.file "boot.r5a",727
                        		code
                        		align	4                        	
                        	IRQRout:
FFFC08D4 7907ED73		csrrs	$t0,#CSR_REGSET,#15	; get regset,  ensure current regset is selected for all
FFFC08D8 004D5D13		srl		$t0,$t0,#4
FFFC08DC 003D7D13		and		$t0,$t0,#3
FFFC08E0 00AD1D13		sll		$t0,$t0,#10				; 1k stack area
FFFC08E4 20000737		ldi		$sp,#$20000000-8	; setup machine mode stack pointer (top of ram)
FFFC08E8 FF870713
FFFC08EC 41A70733		sub		$sp,$sp,$t0				; set stack pointer for register set
FFFC08F0 34201D73		csrrw	$t0,#$342,$x0			; get cause code
FFFC08F4 000D4C63		blt		$t0,$x0,.isIRQ		; irq or ecall?
FFFC08F8 00806D93		ldi		$t1,#8
FFFC08FC 09BD6E63		bltu	$t0,$t1,.cause0to7
FFFC0900 00B06D93		ldi		$t1,#11
FFFC0904 09ADEA63		bgtu	$t0,$t1,.cause12plus
FFFC0908 2890106F		jmp		OSCALL						; goto operating system call dispatcher
                        	.isIRQ:
FFFC090C FFD00637		ldo		$v0,$FFD00000+432	; Display IRQ live indicator
FFFC0910 1B060613
FFFC0914 00060633
FFFC0918 00063803
FFFC091C 00180813		add		$v0,$v0,#1
FFFC0920 FFD00637		sto		$v0,$FFD00000+432
FFFC0924 1B060613
FFFC0928 00060633
FFFC092C 01063023
FFFC0930 792168F3		csrrs	$v1,#$792,#2			; check and set interrupt semaphore
FFFC0934 0028F893		and		$v1,$v1,#2
FFFC0938 00088463		beqz	$v1,.doIRQ
FFFC093C 10000073		eret
                        	.doIRQ:
FFFC0940 01FD7D93		and		$t1,$t0,#31				; interrupting device # is low order 5 bits of cause code
FFFC0944 008D9D93		sll		$t1,$t1,#8				; 256 bytes per device func table
FFFC0948 00022637		add		$t1,$t1,#DVF_Base+22*8	; load IRQ routine vector from device func table
FFFC094C 0B060613
FFFC0950 01B60DB3
FFFC0954 000DBD83		ldo		$t1,[$t1]
FFFC0958 000D8463		beq		$t1,$x0,.noIRQ		; make sure there's an address to go to
FFFC095C 000D8067		jmp		[$t1]							; call to the IRQ routine
                        	.noIRQ:
                        		; For now, clear all interrupt sources
                        		; Otherwise the system will hang on an unknown interrupt.
FFFC0960 FFDC0637		stt		$t0,VIA+VIA_PARAW
FFFC0964 63C60613
FFFC0968 00060633
FFFC096C 01A62023
FFFC0970 FFDC1637		ldt		$a1,UART+UART_TRB		; get data from Rx buffer to clear interrupt
FFFC0974 A0060613
FFFC0978 00060633
FFFC097C 00062983
FFFC0980 FFDC0637		ldt		$t0,VIA+VIA_T1CL		; clear interrupt
FFFC0984 61060613
FFFC0988 00060633
FFFC098C 00062D03
FFFC0990 79217073		csrrc	$x0,#$792,#2			; clear interrupt semaphore
FFFC0994 10000073		eret
                        	.cause0to7:
                        	.cause12plus:
FFFC0998 3000F073		csrrc	$x0,#$300,#1			; disable ints
FFFC099C 10100073		wfi
FFFC09A0 FE000CE3		bra		.cause0to7				; and loop
                        	
                        	;------------------------------------------------------------------------------
                        	; Message strings
                        	;------------------------------------------------------------------------------
                        	
                        	msgStart:
FFFC09A4 61746550			db		"Petajon System Starting.",13
FFFC09A8 206E6F6A
FFFC09AC 74737953
FFFC09B0 53206D65
FFFC09B4 74726174
FFFC09B8 2E676E69
FFFC09BC 6E6F4D0D
                        	msgMonHelp:
FFFC09BD 696E6F4D			db		"Monitor Commands",13
FFFC09C1 20726F74
FFFC09C5 6D6D6F43
FFFC09C9 73646E61
FFFC09CD 2D20420D
FFFC09CE 202D2042			db		"B - start tiny basic",13
FFFC09D2 72617473
FFFC09D6 69742074
FFFC09DA 6220796E
FFFC09DE 63697361
FFFC09E2 2D20440D
FFFC09E3 202D2044			db		"D - dump ready que",13
FFFC09E7 706D7564
FFFC09EB 61657220
FFFC09EF 71207964
FFFC09F3 450D6575
FFFC09F6 202D2045			db		"E - edit memory",13
FFFC09FA 74696465
FFFC09FE 6D656D20
FFFC0A02 0D79726F
FFFC0A06 202D2046			db		"F - fill memory",13
FFFC0A0A 6C6C6966
FFFC0A0E 6D656D20
FFFC0A12 0D79726F
FFFC0A16 743C204B			db		"K <tid> - kill task", 13
FFFC0A1A 203E6469
FFFC0A1E 696B202D
FFFC0A22 74206C6C
FFFC0A26 0D6B7361
FFFC0A2A 733C204D			db		"M <start> <length>	- dump memory",13
FFFC0A2E 74726174
FFFC0A32 6C3C203E
FFFC0A36 74676E65
FFFC0A3A 2D093E68
FFFC0A3E 6D756420
FFFC0A42 656D2070
FFFC0A46 79726F6D
FFFC0A4A 2D20530D
FFFC0A4B 202D2053			db		"S - switch task",13
FFFC0A4F 74697773
FFFC0A53 74206863
FFFC0A57 0D6B7361
FFFC0A5B 61742000			db		0
                        			align 4                        	
                        	msgTaskStart:
FFFC0A5C 73617420			db		" task started."
FFFC0A60 7473206B
FFFC0A64 65747261
FFFC0A68 0A0D2E64
                        	msgCRLF:
FFFC0A6A 00000A0D			db		13,10,0
FFFC0A6D 00000000			align		
                        	
                        	flt50:
FFFC0A70 00000000		dw	0x00000000,0x00000000,0x00000000,0x40049000
FFFC0A74 00000000
FFFC0A78 00000000
FFFC0A7C 40049000
                        	flt20:
FFFC0A80 00000000		dw	0x00000000,0x00000000,0x00000000,0x40034000
FFFC0A84 00000000
FFFC0A88 00000000
FFFC0A8C 40034000
                        	flt10:
FFFC0A90 00000000		dw	0x00000000,0x00000000,0x00000000,0x40024000
FFFC0A94 00000000
FFFC0A98 00000000
FFFC0A9C 40024000
                        	
                        			align		8                        	
                        	
                        	.file "fltToString.r5a",1
                        	.file "fltToString.r5a",1
                        	STRTMP		equ		$0200
                        	
                        	; -----------------------------------------------------------------------------
                        	;		$fa0 = number to convert (f18)
                        	;		$a1	= width
                        	;		$a2 = precision
                        	;		$a3 = E
                        	;		$t2 = ndx
                        	;		$s9 = exp
                        	; -----------------------------------------------------------------------------
                        	
                        	fltToString:
FFFC0AA0 00006E13			ldi		$t2,#0				; $t2 = 0
FFFC0AA4 E0090953			fmv		$a0,$f18
FFFC0AA8 7F800637			and		$t0,$a0,#$7F800000
FFFC0AAC 00060613
FFFC0AB0 01267D33
FFFC0AB4 7F800DB7			ldi		$t1,#$7F800000
FFFC0AB8 000D8D93
FFFC0ABC 05BD1263			bne		$t0,$t1,.0001
FFFC0AC0 00800637			and		$t0,$a0,#$007FFFFF
FFFC0AC4 FFF60613
FFFC0AC8 01267D33
FFFC0ACC 000D0E63			beq		$t0,$x0,.inf
FFFC0AD0 FFFC1637			ldt		$t0,msgNan
FFFC0AD4 E5860613
FFFC0AD8 00060633
FFFC0ADC 00062D03
FFFC0AE0 21A02023			stt		$t0,STRTMP
FFFC0AE4 2E000E63			bra		.prt
                        	.inf:
FFFC0AE8 FFFC1637			ldt		$t0,msgInf
FFFC0AEC E5460613
FFFC0AF0 00060633
FFFC0AF4 00062D03
FFFC0AF8 21A02023			stt		$t0,STRTMP
FFFC0AFC 2E000263			bra		.prt
                        	.0001:
FFFC0B00 80000637			and		$t0,$a0,#$80000000
FFFC0B04 00060613
FFFC0B08 01267D33
FFFC0B0C 000D0E63			beq		$t0,$x0,.pos
FFFC0B10 02D06D13			ldi		$t0,#'-'
FFFC0B14 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0B18 001E0E13			add		$t2,$t2,#1
FFFC0B1C 80000637			and		$a0,$a0,#$7FFFFFFF
FFFC0B20 FFF60613
FFFC0B24 01267933
                        	.pos:
FFFC0B28 00091A63			bne		$a0,$x0,.notZero
FFFC0B2C 03006D13			ldi		$t0,#'0'
FFFC0B30 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0B34 200E00A3			stb		$x0,STRTMP+1[$t2]
FFFC0B38 2A000463			bra		.prt		
                        	.notZero:
FFFC0B3C 00006633			mov		$s9,$x0			; exp = 0.0
                        	;	// Make a small number > 0 so we can get at the digits.
                        	;	if (dbl < 1.0) {
                        	;		while (dbl < 1.0) {
                        	;			dbl *= 1000000.0;
                        	;			exp -= 6;  
                        	;		}
                        	;	}
FFFC0B40 FFFC1637			flw		$f3,fltOne
FFFC0B44 E5C60613
FFFC0B48 00060633
FFFC0B4C 00062187
FFFC0B50 F0090053			fmv		$f0,$a0
FFFC0B54 A0391D53			flt		$t0,$f18,$f3
FFFC0B58 020D0463			beq		$t0,$x0,.0002
FFFC0B5C FFFC1637			flw		$f4,fltMillion
FFFC0B60 E6460613
FFFC0B64 00060633
FFFC0B68 00062207
                        	.0003:
FFFC0B6C A0391D53			flt		$t0,$f18,$f3
FFFC0B70 000D0863			beq		$t0,$x0,.0002
FFFC0B74 10490953			fmul	$f18,$f18,$f4
FFFC0B78 FFA60613			sub		$s9,$s9,#6
FFFC0B7C FE0008E3			bra		.0003
                        	.0002:
                        	;	// The following is similar to using log10() and pow() functions.
                        	;	// Now dbl is >= 1.0
                        	;	// Create a number dbl2 on the same order of magnitude as dbl, but
                        	;	// less than dbl.
                        	;	dbl2 = 1.0;
                        	;	dbla = dbl2;
                        	;	if (dbl > dbl2) {	// dbl > 1.0 ?
                        	;		while (dbl2 <= dbl) {
                        	;			dbla = dbl2;
                        	;			dbl2 *= 10.0;	// increase power of 10
                        	;			exp++;
                        	;		}
                        	;		// The above loop goes one too far, we want the last value less
                        	;		// than dbl.
                        	;		dbl2 = dbla;
                        	;		exp--;
                        	;	}
FFFC0B80 FFFC1637			flw		$f1,fltOne				; $f1 = dbl2 = 1.0
FFFC0B84 E5C60613
FFFC0B88 00060633
FFFC0B8C 00062087
FFFC0B90 38008153			fmov	$f2,$f1						; $f2 = dbla = dbl2
FFFC0B94 A1209D53			flt		$t0,$f1,$f18				; if (dbl2 < dbl)
FFFC0B98 020D0A63			beq		$t0,$x0,.0004
FFFC0B9C FFFC1637			flw		$f5,fltTen				; $f5 = 10.0
FFFC0BA0 E6060613
FFFC0BA4 00060633
FFFC0BA8 00062287
                        	.0006:
FFFC0BAC A1208D53			fle		$t0,$f1,$f18				; while ($f1 <= $f18)
FFFC0BB0 000D0A63			beq		$t0,$x0,.0005
FFFC0BB4 38008153			fmov	$f2,$f1						; dbla = dbl2
FFFC0BB8 105080D3			fmul	$f1,$f1,$f5				; dbl2 *= 10.0
FFFC0BBC 00160613			add		$s9,$s9,#1				; exp++;
FFFC0BC0 FE0006E3			bra		.0006
                        	.0005:
FFFC0BC4 380100D3			fmov	$f1,$f2						; dbl2 = dbla
FFFC0BC8 FFF60613			sub		$s9,$s9,#1				; exp--;
                        	.0004:
                        	;	// For small constants < 1000000 try and spit out a whole number
                        	;    if (exp >= 0 && exp < 6) {
                        	;        digits_before_decpt = exp+1;
                        	;		exp = 0;
                        	;	}
                        	;	else if (exp >= -6)
                        	;		digits_before_decpt = 1;
                        	;	else
                        	;		digits_before_decpt = -1;
FFFC0BCC 00064E63			blt		$s9,$x0,.0007
FFFC0BD0 00606413			ldi		$s5,#6
FFFC0BD4 00865A63			bge		$s9,$s5,.0007
FFFC0BD8 FFFFE233			mov		$s1,#s0						; s1 = digits before decpt
FFFC0BDC 00120213			add		$s1,$s1,#1
FFFC0BE0 00006613			ldi		$s9,#0						; exp = 0
FFFC0BE4 00000C63			bra		.0008
                        	.0007:
FFFC0BE8 FF906413			ldi		$s5,#-7
FFFC0BEC 00864663			blt		$s9,$s5,.0009
FFFC0BF0 00106213			ldi		$s1,#1
FFFC0BF4 00000463			bra		.0008
                        	.0009:
FFFC0BF8 FFF06213			ldi		$s1,#-1
                        	.0008:
                        	;	// Spit out a leading zero before the decimal point for a small number.
                        	;    if (exp < -6) {
                        	;		buf[ndx] = '0';
                        	;		ndx++;
                        	;        buf[ndx] = '.';
                        	;        ndx++;
                        	;    }
FFFC0BFC FFA06413			ldi		$s5,#-6
FFFC0C00 00865E63			bge		$s9,$s5,.0010
FFFC0C04 03006D13			ldi		$t0,#'0'
FFFC0C08 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0C0C 001E0E13			add		$t2,$t2,#1
FFFC0C10 02E06D13			ldi		$t0,#'.'
FFFC0C14 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0C18 001E0E13			add		$t2,$t2,#1
                        	.0010:
                        	;	// Now loop processing one digit at a time.
                        	;    for (nn = 0; nn < 30 && precision > 0; nn++) {
                        	;        digit = 0;
                        	;		dbla = dbl;
                        	;		// dbl is on the same order of magnitude as dbl2 so
                        	;		// a repeated subtract can be used to find the digit.
                        	;        while (dbl >= dbl2) {
                        	;            dbl -= dbl2;
                        	;            digit++;
                        	;        }
                        	;        buf[ndx] = digit + '0';
                        	;		// Now go back and perform just a single subtract and
                        	;		// a multiply to find out how much to reduce dbl by.
                        	;		// This should improve the accuracy
                        	;		if (digit > 2)
                        	;			dbl = dbla - dbl2 * digit;
                        	;        ndx++;
                        	;        digits_before_decpt--;
                        	;        if (digits_before_decpt==0) {
                        	;           buf[ndx] = '.';
                        	;           ndx++;
                        	;        }
                        	;        else if (digits_before_decpt < 0)
                        	;            precision--;
                        	;		// Shift the next digit to be tested into position.
                        	;        dbl *= 10.0;
                        	;    }
FFFC0C1C 00006313			ldi		$s3,#0						; s3 = nn = 0
FFFC0C20 01E06413			ldi		$s5,#30
FFFC0C24 FFFC1637			flw		$f7,fltTen				; f7 = 10.0
FFFC0C28 E6060613
FFFC0C2C 00060633
FFFC0C30 00062387
                        	.0016:
FFFC0C34 00832D33			slt		$t0,$s3,$s5
FFFC0C38 060D0863			beq		$t0,$x0,.0011
FFFC0C3C 00006413			ldi		$s5,#0
FFFC0C40 07445463			bge		$s5,$a2,.0011			; (0 < precision)
FFFC0C44 00006393			ldi		$s4,#0						; s4 = digit = 0
FFFC0C48 38090153			fmov	$f2,$f18						; dbla = dbl
                        	.0013:
FFFC0C4C A1208D53			fle		$t0,$f1,$f18						; while (dbl2 <= dbl)
FFFC0C50 000D0863			beq		$t0,$x0,.0012
FFFC0C54 08190953			fsub	$f18,$f18,$f1						; dbl -= dbl2
FFFC0C58 00138393			add		$s4,$s4,#1						; digit++
FFFC0C5C FE0008E3			bra		.0013
                        	.0012:
FFFC0C60 03038413			add		$s5,$s4,#'0'			; buf[ndx] = digit + '0'
FFFC0C64 208E0023			stb		$s5,STRTMP[$t2]
FFFC0C68 00206413			ldi		$s5,#2						; if (2 < digit)
FFFC0C6C 00745863			bge		$s5,$s4,.0014
FFFC0C70 D00382D3			fcvt.s.w	$f5,$s4				; f5 = digit as float
FFFC0C74 10508353			fmul	$f6,$f1,$f5				; f6 = dbl2 * digit
FFFC0C78 08610953			fsub	$f18,$f2,$f6				; dbl = dbla - dbl2 * digit
                        	.0014:
FFFC0C7C 001E0E13			add		$t2,$t2,#1				; ndx++
FFFC0C80 FFF20213			sub		$s1,$s1,#1				; digits_before_decpt--;
FFFC0C84 00021A63			bne		$s1,$x0,.0015			; if (digits_before_decpt==0)
FFFC0C88 02E06D13			ldi		$t0,#'.'
FFFC0C8C 21AE0023			stb		$t0,STRTMP[$t2]		; buf[ndx] = '.'
FFFC0C90 001E0E13			add		$t2,$t2,#1				; ndx++
FFFC0C94 00000663			bra		.0017
                        	.0015:
FFFC0C98 00025463			bge		$s1,$x0,.0017			; else if (digits_before_decpt < 0)
FFFC0C9C FFFA0A13			sub		$a2,$a2,#1				; 	precision--
                        	.0017:
FFFC0CA0 10790953			fmul	$f18,$f18,$f7				; dbl *= 10.0
FFFC0CA4 F80008E3			bra		.0016
                        	.0011:
                        	;	// Trim trailing zeros from the number
                        	;    do {
                        	;        ndx--;
                        	;    } while(buf[ndx]=='0');
                        	;    ndx++;
                        	.0018:
FFFC0CA8 FFFE0E13			sub		$t2,$t2,#1				; ndx--
FFFC0CAC 200E0D03			ldb		$t0,STRTMP[$t2]
FFFC0CB0 030D4D13			xor		$t0,$t0,#'0'
FFFC0CB4 FE0D0AE3			beq		$t0,$x0,.0018
FFFC0CB8 001E0E13			add		$t2,$t2,#1				; ndx++
                        	;	// Make sure we have at least one digit after the decimal point.
                        	;	if (buf[ndx]=='.') {
                        	;		ndx++;
                        	;		buf[ndx]='0';
                        	;		ndx++;
                        	;        buf[ndx]='\0';
                        	;	}
FFFC0CBC 200E0D03			ldb		$t0,STRTMP[$t2]
FFFC0CC0 02ED4D13			xor		$t0,$t0,#'.'
FFFC0CC4 000D1C63			bne		$t0,$x0,.0019
FFFC0CC8 001E0E13			add		$t2,$t2,#1
FFFC0CCC 03006D13			ldi		$t0,#'0'
FFFC0CD0 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0CD4 001E0E13			add		$t2,$t2,#1
FFFC0CD8 200E0023			stb		$x0,STRTMP[$t2]
                        	.0019:
                        	;	// If the number is times 10^0 don't output the exponent
                        	;   if (exp==0) {
                        	;        buf[ndx]='\0';
                        	;        goto prt;
                        	;    }
FFFC0CDC 00061663			bne		$s9,$x0,.0020
FFFC0CE0 200E0023			stb		$x0,STRTMP[$t2]
FFFC0CE4 0E000E63			bra		.prt
                        	.0020:
                        	;	// Spit out +/-E
                        	;    buf[ndx] = E;
                        	;    ndx++;
                        	;    if (exp < 0) {
                        	;        buf[ndx]='-';
                        	;        ndx++;
                        	;        exp = -exp;
                        	;    }
                        	;    else {
                        	;         buf[ndx]='+';
                        	;         ndx++;
                        	;    }
FFFC0CE8 04506D13			ldi		$t0,#'E'
FFFC0CEC 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0CF0 001E0E13			add		$t2,$t2,#1
FFFC0CF4 00065C63			bge		$s9,$x0,.0021
FFFC0CF8 02D06D13			ldi		$t0,#'-'
FFFC0CFC 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0D00 001E0E13			add		$t2,$t2,#1
FFFC0D04 40C00633			sub		$s9,$x0,$s9			; exp = -exp
FFFC0D08 00000863			bra		.0022
                        	.0021:
FFFC0D0C 02B06D13			ldi		$t0,#'+'
FFFC0D10 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0D14 001E0E13			add		$t2,$t2,#1
                        	.0022:
                        	;	// now process the exponent
                        	;    digit = 0;
                        	;    while (exp >= 1000) {
                        	;        exp -= 1000;
                        	;        digit++;
                        	;    }
FFFC0D18 00006393			ldi		$s4,#0
FFFC0D1C 3E806D13			ldi		$t0,#1000
                        	.0025:
FFFC0D20 01A65463			bge		$s9,$t0,.0023
FFFC0D24 00000863			bra		.0024
                        	.0023:
FFFC0D28 41A60633			sub		$s9,$s9,$t0
FFFC0D2C 00138393			add		$s4,$s4,#1
FFFC0D30 FE0008E3			bra		.0025
                        	.0024:
                        	;	d1 = digit;
                        	;	if (digit) {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0D34 0003E4B3			mov		$s6,$s4					; s6 = d1 = s4 = digit
FFFC0D38 00039863			bne		$s4,$x0,.0026
FFFC0D3C 03038D13			add		$t0,$s4,#'0'
FFFC0D40 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0D44 001E0E13			add		$t2,$t2,#1
                        	.0026:
                        	;	digit = 0;
                        	;    while (exp >= 100) {
                        	;        exp -= 100;
                        	;        digit++;
                        	;    }
FFFC0D48 00006393			ldi		$s4,#0
FFFC0D4C 06406D13			ldi		$t0,#100
                        	.0027:
FFFC0D50 01A65463			bge		$s9,$t0,.0028
FFFC0D54 00000863			bra		.0029
                        	.0028:
FFFC0D58 41A60633			sub		$s9,$s9,$t0
FFFC0D5C 00138393			add		$s4,$s4,#1
FFFC0D60 FE0008E3			bra		.0027
                        	.0029:	
                        	;	d2 = digit;
                        	;	if (digit==0 && d1==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0D64 0003E533			mov		$s7,$s4				; $s7 = d2
FFFC0D68 00049463			bne		$s6,$x0,.0030
FFFC0D6C 00038863			beq		$s4,$x0,.0031
                        	.0030:
FFFC0D70 03038D13			add		$t0,$s4,#'0'
FFFC0D74 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0D78 001E0E13			add		$t2,$t2,#1
                        	.0031:
                        	;	digit = 0;
                        	;    while (exp >= 10) {
                        	;        exp -= 10;
                        	;        digit++;
                        	;    }
FFFC0D7C 00006393			ldi		$s4,#0
FFFC0D80 00A06D13			ldi		$t0,#10
                        	.0032:
FFFC0D84 01A65463			bge		$s9,$t0,.0034
FFFC0D88 00000863			bra		.0035
                        	.0034:
FFFC0D8C 41A60633			sub		$s9,$s9,$t0
FFFC0D90 00138393			add		$s4,$s4,#1
FFFC0D94 FE0008E3			bra		.0032
                        	.0035:	
                        	;	d3 = digit;
                        	;	if (digit==0 && d1==0 && d2==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0D98 0003E5B3			mov		$s8,$s4
FFFC0D9C 00039663			bne		$s4,$x0,.0036
FFFC0DA0 00049463			bne		$s6,$x0,.0036
FFFC0DA4 00050863			beq		$s7,$x0,.0037
                        	.0036:
FFFC0DA8 03038D13			add		$t0,$s4,#'0'
FFFC0DAC 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0DB0 001E0E13			add		$t2,$t2,#1
                        	.0037:
                        	;	digit = 0;
                        	;    while (exp >= 1) {
                        	;        exp -= 1;
                        	;        digit++;
                        	;    }
FFFC0DB4 00006393			ldi		$s4,#0
FFFC0DB8 00106D13			ldi		$t0,#1
                        	.0038:
FFFC0DBC 01A65463			bge		$s9,$t0,.0040
FFFC0DC0 00000863			bra		.0039
                        	.0040:
FFFC0DC4 41A60633			sub		$s9,$s9,$t0
FFFC0DC8 00138393			add		$s4,$s4,#1
FFFC0DCC FE0008E3			bra		.0038
                        	.0039:	
                        	;    buf[ndx] = digit + '0';
                        	;    ndx++;
                        	;    buf[ndx] = '\0';
FFFC0DD0 03038D13			add		$t0,$s4,#'0'
FFFC0DD4 21AE0023			sb		$t0,STRTMP[$t2]
FFFC0DD8 001E0E13			add		$t2,$t2,#1
FFFC0DDC 200E0023			sb		$x0,STRTMP[$t2]
                        	;	// Now pad the number on the left or right as requested.
                        	.prt:
                        	;    // pad left
                        	;    if (width > 0) {
                        	;        if (ndx < width) {
                        	;            for (nn = 39; nn >= width-ndx; nn--)
                        	;                buf[nn] = buf[nn-(width-ndx)];
                        	;            for (; nn >= 0; nn--)
                        	;                buf[nn] = ' ';
                        	;        }
                        	;    }
FFFC0DE0 0409C663			blt		$a1,$x0,.0041
FFFC0DE4 04098463			beq		$a1,$x0,.0041
FFFC0DE8 013E4463			blt		$t2,$a1,.0042
FFFC0DEC 04000063			bra		.0041
                        	.0042:
FFFC0DF0 02706313			ldi		$s3,#39					; s3 = nn
FFFC0DF4 41C98D33			sub		$t0,$a1,$t2			; width-ndx
                        	.0045:
FFFC0DF8 01A35463			bge		$s3,$t0,.0043
FFFC0DFC 00000C63			bra		.0044
                        	.0043:
FFFC0E00 41A304B3			sub		$s6,$s3,$t0			; nn-(width-ndx)
FFFC0E04 20030D83			ldb		$t1,STRTMP[$s3]
FFFC0E08 21B48023			stb		$t1,STRTMP[$s6]
FFFC0E0C FFF30313			sub		$s3,$s3,#1
FFFC0E10 FE0004E3			bra		.0045
                        	.0044:
FFFC0E14 02006D13			ldi		$t0,#' '
                        	.0048:
FFFC0E18 00035463			bge		$s3,$x0,.0046
FFFC0E1C 00000863			bra		.0047
                        	.0046:
FFFC0E20 21A30023			stb		$t0,STRTMP[$s3]
FFFC0E24 FFF30313			sub		$s3,$s3,#1
FFFC0E28 FE0008E3			bra		.0048
                        	.0047:
                        	.0041:
                        	;    // pad right
                        	;    if (width < 0) {
                        	;        width = -width;
                        	;        while (ndx < width) {
                        	;            buf[ndx]=' ';
                        	;            ndx++;
                        	;        }
                        	;        buf[ndx]='\0';
                        	;    }
                        	;    return (ndx);
FFFC0E2C 0209D063			bge		$a1,$x0,.0050
FFFC0E30 413009B3			sub		$a1,$x0,$a1
FFFC0E34 02006D13			ldi		$t0,#' '
                        	.0052:
FFFC0E38 013E5863			bge		$t2,$a1,.0051
FFFC0E3C 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0E40 001E0E13			add		$t2,$t2,#1
FFFC0E44 FE000AE3			bra		.0052
                        	.0051:
FFFC0E48 200E0023			stb		$x0,STRTMP[$t2]
                        	.0050:
FFFC0E4C 000E6833			mov		$v0,$t2
FFFC0E50 00008067			ret
                        	
                        			align	4                        	
                        	msgInf:
FFFC0E54 00666E49			db	"Inf",0
                        	msgNan:
FFFC0E58 006E614E			db	"Nan",0
                        	fltOne:
FFFC0E5C 3F800000			dw		$3F800000					; 1.0
                        	fltTen:
FFFC0E60 41200000			dw		$41200000					; 10.0
                        	fltMillion:
FFFC0E64 49742400			dw		$49742400					; 1,000,000
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../bios/bios.r5a",1
                        	.file "../bios/bios.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../bios/bios.r5a",25
                        		code
                        		align	2                        	
                        	BIOSCallTbl:
FFFC0E68 0E740E70		dh		BIOS_ClearScreen
FFFC0E6A 0E780E74		dh		BIOS_HomeCursor
FFFC0E6C 0E7C0E78		dh		BIOS_VideoPutChar
FFFC0E6E 006F0E7C		dh		BIOS_VideoPutString
                        	
                        		align	4                        	
                        	BIOS_ClearScreen:
FFFC0E70 4110006F		jmp		VideoClearScreen
                        	BIOS_HomeCursor:
FFFC0E74 4510006F		jmp		VideoHomeCursor
                        	BIOS_VideoPutChar:
FFFC0E78 4AD0006F		jmp		VideoPutChar
                        	BIOS_VideoPutString:
FFFC0E7C 7950006F		jmp		VideoPutString
                        	
                        	
                        	
                        	
                        	
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../bios/mem.r5a",1
                        	.file "../bios/mem.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../bios/mem.r5a",25
                        			code	18 bits
                        			align	4                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	MMUInit:
FFFC0E80 FF870713			sub		$sp,$sp,#8
FFFC0E84 00173023			sto		$ra,[$sp]
FFFC0E88 00002D37			ldi		$t0,#8192				; set number of available pages in system
FFFC0E8C 000D0D13
FFFC0E90 00025637			stw		$t0,NPAGES
FFFC0E94 82860613
FFFC0E98 00060633
FFFC0E9C 01A61023
                        			; Free all memory for all maps
FFFC0EA0 00006D13			ldi		$t0,#$00
FFFC0EA4 03F06F13			ldi		$t4,#MAX_MID		; map id
                        	.0004:
FFFC0EA8 00006D93			ldi		$t1,#$000				; regno
FFFC0EAC 00001E37			ldi		$t2,#PAGES_PER_MAP	; number of registers to update
FFFC0EB0 000E0E13
                        	.0001:
FFFC0EB4 010F1213			sll		$s1,$t4,#16			; put mid in place
FFFC0EB8 01B26233			or		$s1,$s1,$t1			; or in page number
FFFC0EBC 024D000D			mvmap	$x0,$t0,$s1
FFFC0EC0 001D8D93			add		$t1,$t1,#$01		; increment page number
FFFC0EC4 FFFE0E13			sub		$t2,$t2,#1
FFFC0EC8 FE0E16E3			bnez	$t2,.0001
FFFC0ECC FFFF0F13			sub		$t4,$t4,#1
FFFC0ED0 FC0F5CE3			bge		$t4,$x0,.0004
                        			; Now ensure all pages in PAM are marked free
FFFC0ED4 00002D37			ldi		$t0,#8191
FFFC0ED8 FFFD0D13
                        	.0006:
FFFC0EDC 0A0D000D			pfree	$t0
FFFC0EE0 FFFD0D13			sub		$t0,$t0,#1
FFFC0EE4 FE0D5CE3			bge		$t0,$x0,.0006
                        			; Allocate three pages for OS data.
                        			; These will end up being the first three pages of memory
FFFC0EE8 0800000D			palloc	$x0
FFFC0EEC 0800000D			palloc	$x0
FFFC0EF0 0800000D			palloc	$x0
                        			; allocate last page for system stack
FFFC0EF4 00001DB7			ldi		$t1,#$FFF				
FFFC0EF8 FFFD8D93
FFFC0EFC 00002D37			ldi		$t0,#$1FFF
FFFC0F00 FFFD0D13
FFFC0F04 080D000D			palloc	$x0,$t0				; specifically allocate page 8191
FFFC0F08 03BD000D			mvmap	$x0,$t0,$t1
                        	
                        			; Now setup segment registers
FFFC0F0C 00006D13			ldi		$t0,#$0
FFFC0F10 00706D93			ldi		$t1,#$07				; t1 = value to load RWX=111, base = 0
                        	.0002:
FFFC0F14 01AD800D			mvseg	$x0,$t1,$t0			; move to the segment register identifed by t0
FFFC0F18 001D0D13			add		$t0,$t0,#1			; pick next segment register
FFFC0F1C 010D2E13			slt		$t2,$t0,#16			; 16 segment regs
FFFC0F20 FE0E1AE3			bne		$t2,$x0,.0002
FFFC0F24 00073083			ldo		$ra,[$sp]
FFFC0F28 00870713			add		$sp,$sp,#8
FFFC0F2C 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Find a run of buckets available for mapping virtual to physical addresses.
                        	;
                        	; Parameters:
                        	;		a0 = mid
                        	;		a1 = number of pages required.
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		v0 = starting bucket number (includes ASID), -1 if no run found
                        	;------------------------------------------------------------------------------
                        	
                        	FindRun:
FFFC0F30 03F97E93		and			$t3,$a0,#MAX_MID	; t3 = mid
FFFC0F34 010E9E93		sll			$t3,$t3,#16				; shift into usable position
FFFC0F38 000EEE33		mov			$t2,$t3						; t2 = map entry number
FFFC0F3C 003E6E13		or			$t2,$t2,#OSPAGES	; start looking at page 3 (others are for OS)
FFFC0F40 00002FB7		ldi			$t5,#8191					; max number of pages - 1
FFFC0F44 FFFF8F93
FFFC0F48 01DFEFB3		or			$t5,$t5,$t3				; t5 = max in ASID
                        	.0003:
FFFC0F4C 00006D93		ldi			$t1,#0						; t1 = count of consecutive empty buckets
                        	.0001:
FFFC0F50 03C0080D		mvmap		$v0,$x0,$t2				; get map entry into v0
FFFC0F54 00080A63		beqz		$v0,.empty0				; is it empty?
FFFC0F58 001E0E13		add			$t2,$t2,#1
FFFC0F5C FFFE6AE3		bltu		$t2,$t5,.0001
                        	.0002:
FFFC0F60 FFF06813		ldi			$v0,#-1						; got here so no run was found
FFFC0F64 00008067		ret
                        	.empty0:
FFFC0F68 000E6EB3		mov			$t3,$t2						; save first empty bucket
                        	.empty1:
FFFC0F6C FFFE7AE3		bgeu		$t2,$t5,.0002
FFFC0F70 001D8D93		add			$t1,$t1,#1
FFFC0F74 013DFA63		bgeu		$t1,$a1,.foundEnough
FFFC0F78 001E0E13		add			$t2,$t2,#1				; next bucket
FFFC0F7C 03C0080D		mvmap		$v0,$x0,$t2				; get map entry
FFFC0F80 FE0806E3		beqz		$v0,.empty1
FFFC0F84 FC0004E3		bra			.0003							; go back and find another run
                        	.foundEnough:
FFFC0F88 000EE833		mov			$v0,$t3						; v0 = start of run
FFFC0F8C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Find a run of buckets available for mapping virtual to physical addresses.
                        	; This search starts at the top of the virtual address space and works its
                        	; way downwards. This is usually used for allocating stack space.
                        	;
                        	; Parameters:
                        	;		a0 = mid
                        	;		a1 = number of pages required.
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		v0 = starting bucket number (includes ASID), -1 if no run found
                        	;------------------------------------------------------------------------------
                        	
                        	FindStackRun:
FFFC0F90 03F97E93		and			$t3,$a0,#MAX_MID	; t3 = mid
FFFC0F94 010E9E93		sll			$t3,$t3,#16				; shift into usable position
FFFC0F98 000EEE33		mov			$t2,$t3						; t2 = map entry number
FFFC0F9C 00001637		or			$t2,$t2,#PAGES_PER_MAP-1	; start looking at last page
FFFC0FA0 FFF60613
FFFC0FA4 01C66E33
FFFC0FA8 000EEFB3		mov			$t5,$t3						; t5 = min in ASID
                        	.0003:
FFFC0FAC 00006D93		ldi			$t1,#0						; t1 = count of consecutive empty buckets
                        	.0001:
FFFC0FB0 03C0080D		mvmap		$v0,$x0,$t2				; get map entry into v0
FFFC0FB4 00080A63		beqz		$v0,.empty0				; is it empty?
FFFC0FB8 FFFE0E13		sub			$t2,$t2,#1
FFFC0FBC FFFE7AE3		bgeu		$t2,$t5,.0001
                        	.0002:
FFFC0FC0 FFF06813		ldi			$v0,#-1						; got here so no run was found
FFFC0FC4 00008067		ret
                        	.empty0:
                        	.empty1:
FFFC0FC8 FFFE6CE3		bltu		$t2,$t5,.0002
FFFC0FCC 001D8D93		add			$t1,$t1,#1
FFFC0FD0 013DFA63		bgeu		$t1,$a1,.foundEnough
FFFC0FD4 FFFE0E13		sub			$t2,$t2,#1				; next bucket
FFFC0FD8 03C0080D		mvmap		$v0,$x0,$t2				; get map entry
FFFC0FDC FE0806E3		beqz		$v0,.empty1
FFFC0FE0 FC0006E3		bra			.0003							; go back and find another run
                        	.foundEnough:
FFFC0FE4 000E6833		mov			$v0,$t2						; v0 = start of run
FFFC0FE8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = mid
                        	;		a1 = amount of memory to allocate
                        	; Modifies:
                        	;		a1,t0
                        	; Returns:
                        	;		v1 = pointer to allocated memory in virtual address space.
                        	;		v0 = E_Ok for success, E_NotAlloc otherwise
                        	;------------------------------------------------------------------------------
                        	;
                        	AllocInCurrentAS:
                        		
FFFC0FEC 18101873		csrrw	v0,#$181,x0
FFFC0FF0 03F87813		and		v0,v0,#MAX_TID
FFFC0FF4 00086933	mov			$a0,$v0
                        	Alloc:
FFFC0FF8 FE070713		sub			$sp,$sp,#32
FFFC0FFC 00173023		sto			$ra,[$sp]
FFFC1000 00473423		sto			$s1,8[$sp]				; these regs must be saved
FFFC1004 00573823		sto			$s2,16[$sp]
FFFC1008 00673C23		sto			$s3,24[$sp]
                        		; First check if there are enough pages available in the system.
FFFC100C 00010637		add			$v0,$a1,#PAGESZ-1	; v0 = round memory request
FFFC1010 FFF60613
FFFC1014 01360833
FFFC1018 01085813		srl			$v0,$v0,#LOG_PGSZ	; v0 = convert to pages required
FFFC101C 00025637		ldwu		$t0,NPAGES				; check number of pages available
FFFC1020 82860613
FFFC1024 00060633
FFFC1028 00065D03
FFFC102C 010D7663		bleu		$v0,$t0,.enough
                        	.noRun2:
FFFC1030 00006893		ldi			$v1,#0						; not enough, return null
FFFC1034 06000263		bra			.noRun
                        	.enough:
                        		; There are enough pages, but is there a run long enough in map space?
FFFC1038 000862B3		mov			$s2,$v0						; save required # pages
FFFC103C 000869B3		mov			$a1,$v0
FFFC1040 EF1FF0EF		call		FindRun						; find a run of available slots
FFFC1044 FE0846E3		blt			$v0,$x0,.noRun2
                        		; Now there are enough pages, and a run available, so allocate
FFFC1048 00086233		mov			$s1,$v0						; s1 = start of run
FFFC104C 00025637		ldwu		$s3,NPAGES				; decrease number of pages available in system
FFFC1050 82860613
FFFC1054 00060633
FFFC1058 00065303
FFFC105C 40530333		sub			$s3,$s3,$s2
FFFC1060 00025637		stw			$s3,NPAGES
FFFC1064 82860613
FFFC1068 00060633
FFFC106C 00661023
FFFC1070 00086333		mov			$s3,$v0						; s3 = start of run
                        	.0001:
FFFC1074 0800080D		palloc	$v0								; allocate a page (cheat and use hardware)
FFFC1078 02080063		beqz		$v0,.noRun
FFFC107C 0268000D		mvmap		$x0,$v0,$s3				; map the page
FFFC1080 00130313		add			$s3,$s3,#1				; next bucket
FFFC1084 FFF28293		sub			$s2,$s2,#1
FFFC1088 FE5046E3		bgt			$s2,$x0,.0001
FFFC108C 01021893		sll			$v1,$s1,#LOG_PGSZ	; v1 = virtual address of allocated mem.
FFFC1090 00006813		ldi			$v0,#E_Ok
FFFC1094 00000463		bra			.xit
                        	.noRun:
FFFC1098 00906813		ldi			$v0,#E_NotAlloc
                        	.xit
FFFC109C 00073083		ldo			$ra,[$sp]					; restore saved regs
FFFC10A0 00873203		ldo			$s1,8[$sp]
FFFC10A4 01073283		ldo			$s2,16[$sp]
FFFC10A8 01873303		ldo			$s3,24[$sp]
FFFC10AC 02070713		add			$sp,$sp,#32
FFFC10B0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Allocate the stack page for a map. The stack is located at the highest
                        	; virtual address ($7FC00).
                        	;
                        	; Parameters:
                        	;		a0 = mid to allocate for
                        	;	Returns:
                        	;		v0 = physical address, 0 if unsuccessful
                        	;		v1 = virtual address, not valid unless successful
                        	;------------------------------------------------------------------------------
                        	
                        	AllocStack:
FFFC10B4 FF070713		sub			$sp,$sp,#16
FFFC10B8 00173023		sto			$ra,[$sp]
FFFC10BC 01273423		sto			$a0,8[$sp]
FFFC10C0 01091893		sll			$v1,$a0,#16			; 
FFFC10C4 00001637		or			$v1,$v1,#PAGES_PER_MAP-1	; last page of memory is for stack
FFFC10C8 FFF60613
FFFC10CC 011668B3
FFFC10D0 0310080D		mvmap		$v0,$x0,$v1			; check if stack already allocated
FFFC10D4 00081A63		bnez		$v0,.0001
FFFC10D8 0800080D		palloc	$v0							; allocate a page
                        	;	mov			$a0,$v0
                        	;	call		PutHexHalf
FFFC10DC 00873903		ldo			$a0,8[$sp]
FFFC10E0 00080E63		beqz		$v0,.xit		; success?
FFFC10E4 0318000D		mvmap		$x0,$v0,$v1
                        	.0001:
FFFC10E8 00001637		and			$v1,$v1,#4095
FFFC10EC FFF60613
FFFC10F0 011678B3
FFFC10F4 01081813		sll			$v0,$v0,#LOG_PGSZ			; convert pages to addresses
FFFC10F8 01089893		sll			$v1,$v1,#LOG_PGSZ
                        	.xit:
FFFC10FC 00073083		ldo			$ra,[$sp]
FFFC1100 01070713		add			$sp,$sp,#16
FFFC1104 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; This routine will de-allocate all the pages associated with a map including
                        	; the stack.
                        	;
                        	; Parameters:
                        	;		a0 = mid to free memory for
                        	;	Modifies:
                        	;		t0,t1,t3,t4
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	FreeAll:
FFFC1108 00006E93		ldi			$t3,#0
FFFC110C 01091F13		sll			$t4,$a0,#16
                        	.nxt:
FFFC1110 00001637		slt			$t1,$t3,#PAGES_PER_MAP		; number of buckets to check
FFFC1114 00060613
FFFC1118 040D8863		beqz		$t1,.0001
FFFC111C 003F0637		and			$t4,$t4,#$3F0000
FFFC1120 00060613
FFFC1124 01E67F33
FFFC1128 01DF6F33		or			$t4,$t4,$t3			; combine mid and bucket number
FFFC112C 00006D13		ldi			$t0,#0					; new page number to set (indicates free)
FFFC1130 03ED0D0D		mvmap		$t0,$t0,$t4			; get page mapping and set to zero
FFFC1134 001E8E93		add			$t3,$t3,#1			; advance to next bucket
FFFC1138 FC0D0CE3		beqz		$t0,.nxt				; 0 = no map in this bucket
FFFC113C 0A0D000D		pfree		$t0							; free the page
FFFC1140 00025637		ldwu		$t0,NPAGES			; update the number of available pages
FFFC1144 82860613
FFFC1148 00060633
FFFC114C 00065D03
FFFC1150 001D0D13		add			$t0,$t0,#1
FFFC1154 00025637		stw			$t0,NPAGES
FFFC1158 82860613
FFFC115C 00060633
FFFC1160 01A61023
FFFC1164 FA0006E3		bra			.nxt
                        	.0001:
FFFC1168 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Convert a virtual address to a physical one
                        	;
                        	; Parameters:
                        	;		a0 = map id
                        	;		a1 = virtual address to convert
                        	; Modifies:
                        	;		t0
                        	; Returns:
                        	;		v0 = physical address
                        	;------------------------------------------------------------------------------
                        	
                        	VirtToPhys:
FFFC116C FF000837		ldi		$v0,#$FF000000
FFFC1170 00080813
FFFC1174 0309F663		bgeu	$a1,$v0,.notMapped
FFFC1178 0109DD13		srl		$t0,$a1,#LOG_PGSZ		; convert virt to page
FFFC117C 01091813		sll		$v0,$a0,#16
FFFC1180 01A86833		or		$v0,$v0,$t0					; and in mid
FFFC1184 0300080D		mvmap	$v0,$x0,$v0					; get the translation
FFFC1188 01081813		sll		$v0,$v0,#LOG_PGSZ		; convert page to address
FFFC118C 00010637		and		$t0,$a1,#$FFFF			; insert LSB's
FFFC1190 FFF60613
FFFC1194 01367D33
FFFC1198 01A86833		or		$v0,$v0,$t0
FFFC119C 00008067		ret
                        	.notMapped:
FFFC11A0 0009E833		mov		$v0,$a1
FFFC11A4 00008067		ret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/pic.r5a",1
                        	.file "../fmtk/pic.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	;
                        	;  0x80    - irq control for irq #0
                        	;  0x84    - irq control for irq #1
                        	;            bits 0 to 7  = cause code to issue
                        	;            bits 13 to 15 = irq level to issue
                        	;            bit 16 = irq enable
                        	;            bit 17 = edge sensitivity
                        	
                        	PIC				equ		$FFDC0F00
                        	PIC_CH16	equ		$C0
                        	PIC_CH28	equ		$F0
                        	PIC_CH31	equ		$FC
                        	
                        	PicInit:
FFFC11A8 FFDC1DB7		ldi		$t1,#PIC					; t1 = address of pic
FFFC11AC F00D8D93
FFFC11B0 0001ED37		ldi		$t0,#$0001E025		; level sensitive cause 37, interrupt enabled
FFFC11B4 025D0D13
FFFC11B8 0DADA023		stt		$t0,PIC_CH16[$t1]
FFFC11BC 0001ED37		ldi		$t0,#$0001E021		; level sensitive cause 33, interrupt enabled
FFFC11C0 021D0D13
FFFC11C4 0FADA823		stt		$t0,PIC_CH28[$t1]
FFFC11C8 0001ED37		ldi		$t0,#$0001E02F		; level sensitive cause 47, interrupt enabled
FFFC11CC 02FD0D13
FFFC11D0 0FADAE23		stt		$t0,PIC_CH31[$t1]
FFFC11D4 00008067		ret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/serial.r5a",1
                        	.file "../fmtk/serial.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
                        	.file "../fmtk/serial.r5a",29
                        		code
                        		align	8                        	
                        	SerialFuncTbl:
FFFC11D8 00000000		dco		0							; no operation
FFFC11DC 00000000
FFFC11E0 00000000		dco		0							; setup
FFFC11E4 00000000
FFFC11E8 00000000		dco		0							; initialize
FFFC11EC 00000000
FFFC11F0 00000000		dco		0							; status
FFFC11F4 00000000
FFFC11F8 00000000		dco		0							; media check
FFFC11FC 00000000
FFFC1200 00000000		dco		0							; build BPB
FFFC1204 00000000
FFFC1208 00000000		dco		0							; open
FFFC120C 00000000
FFFC1210 00000000		dco		0							; close
FFFC1214 00000000
FFFC1218 FFFC1434		dco		SerialGetChar	; get char
FFFC121C 00000000
FFFC1220 FFFC1504		dco		SerialPeekChar
FFFC1224 00000000
FFFC1228 00000000		dco		0							; get char direct
FFFC122C 00000000
FFFC1230 FFFC156C		dco		SerialPeekCharDirect	; peek char direct
FFFC1234 00000000
FFFC1238 00000000		dco		0							; input status
FFFC123C 00000000
FFFC1240 FFFC15C8		dco		SerialPutChar
FFFC1244 00000000
FFFC1248 00000000		dco		0							; reserved
FFFC124C 00000000
FFFC1250 00000000		dco		0							; set position
FFFC1254 00000000
FFFC1258 00000000		dco		0							; read block
FFFC125C 00000000
FFFC1260 00000000		dco		0							; write block
FFFC1264 00000000
FFFC1268 00000000		dco		0							; verify block
FFFC126C 00000000
FFFC1270 00000000		dco		0							; output status
FFFC1274 00000000
FFFC1278 00000000		dco		0							; flush input
FFFC127C 00000000
FFFC1280 00000000		dco		0							; flush output
FFFC1284 00000000
FFFC1288 FFFC167C		dco		SerialIRQ			; IRQ routine
FFFC128C 00000000
FFFC1290 00000000		dco		0							; Is removable
FFFC1294 00000000
FFFC1298 00000000		dco		0							; ioctrl read
FFFC129C 00000000
FFFC12A0 00000000		dco		0							; ioctrl write
FFFC12A4 00000000
FFFC12A8 00000000		dco		0							; output until busy
FFFC12AC 00000000
FFFC12B0 00000000		dco		0							; 27
FFFC12B4 00000000
FFFC12B8 00000000		dco		0
FFFC12BC 00000000
FFFC12C0 00000000		dco		0
FFFC12C4 00000000
FFFC12C8 00000000		dco		0
FFFC12CC 00000000
FFFC12D0 00000000		dco		0							; 31
FFFC12D4 00000000
                        	
                        	MAX_DEV_OP			EQU		31
                        	
                        	;------------------------------------------------------------------------------
                        	; Initialize serial port.
                        	;
                        	; Modifies:
                        	;		$t0
                        	;------------------------------------------------------------------------------
                        	
                        	SerialInit:
FFFC12D8 FF870713		sub		$sp,$sp,#8
FFFC12DC 00173023		sto		$ra,[$sp]
FFFC12E0 00506913		ldi		$a0,#5							; serial device
FFFC12E4 FFFC19B7		ldi		$a1,#SerialFuncTbl
FFFC12E8 1D898993
FFFC12EC 530020EF		call	CopyDevFuncTbl
FFFC12F0 00026637		stt		$x0,SerHeadRcv
FFFC12F4 80060613
FFFC12F8 00060633
FFFC12FC 00062023
FFFC1300 00026637		stt		$x0,SerTailRcv
FFFC1304 80460613
FFFC1308 00060633
FFFC130C 00062023
FFFC1310 00026637		stt		$x0,SerHeadXmit
FFFC1314 80860613
FFFC1318 00060633
FFFC131C 00062023
FFFC1320 00026637		stt		$x0,SerTailXmit
FFFC1324 80C60613
FFFC1328 00060633
FFFC132C 00062023
FFFC1330 00026637		stb		$x0,SerRcvXon
FFFC1334 81060613
FFFC1338 00060633
FFFC133C 00060023
FFFC1340 00026637		stb		$x0,SerRcvXoff
FFFC1344 81160613
FFFC1348 00060633
FFFC134C 00060023
FFFC1350 00906D13		ldi		$t0,#$09						; dtr,rts active, rxint enabled, no parity
FFFC1354 FFDC1637		stt		$t0,UART+8
FFFC1358 A0860613
FFFC135C 00060633
FFFC1360 01A62023
FFFC1364 00060D37		ldi		$t0,#$0006001E			; reset the fifo's
FFFC1368 01ED0D13
FFFC136C FFDC1637		stt		$t0,UART+12
FFFC1370 A0C60613
FFFC1374 00060633
FFFC1378 01A62023
FFFC137C 01E06D13		ldi		$t0,#$0000001E			; baud 9600, 1 stop bit, 8 bit, internal baud gen
FFFC1380 FFDC1637		stt		$t0,UART+12
FFFC1384 A0C60613
FFFC1388 00060633
FFFC138C 01A62023
FFFC1390 00073083		ldo		$ra,[$sp]
FFFC1394 00870713		add		$sp,$sp,#8
FFFC1398 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	SerialServiceInit:
FFFC139C 00106913		ldi		$a0,#1			; start task
FFFC13A0 40006993		ldi		$a1,#1024		; memory required
FFFC13A4 FFFC1A37		ldi		$a2,#SerialService
FFFC13A8 3B4A0A13
FFFC13AC 00000073		ecall
FFFC13B0 00008067		ret
                        	SerialService:
FFFC13B4 DE870713		sub		$sp,$sp,#512+24
FFFC13B8 00E06913		ldi		$a0,#14			; get current tid
FFFC13BC 00000073		ecall
FFFC13C0 20470A13		add		$a2,$sp,#516
FFFC13C4 000869B3		mov		$a1,$v0
FFFC13C8 00606913		ldi		$a0,#6			; alloc mailbox
FFFC13CC 00000073		ecall
                        	
                        	SerialServiceLoop:
FFFC13D0 00A06913		ldi		$a0,#10			; waitmsg
FFFC13D4 20470993		add		$a1,$sp,#516
FFFC13D8 20870A13		add		$a2,$sp,#520
FFFC13DC 20C70A93		add		$a3,$sp,#524
FFFC13E0 21070B13		add		$a4,$sp,#528
FFFC13E4 FFF06B93		ldi		$a5,#-1
FFFC13E8 00000073		ecall
                        	
FFFC13EC 00072D03		lw		$t0,[$sp]
FFFC13F0 01FD7D13		and		$t0,$t0,#31
FFFC13F4 001D1D13		sll		$t0,$t0,#1
FFFC13F8 FFFC1637		lw		$t0,SerialFuncTbl[$t0]
FFFC13FC 1D860613
FFFC1400 01A60633
FFFC1404 00062D03
FFFC1408 000D0067		jmp		[$t0]
                        	
                        	SerialFinishCmd:
FFFC140C 00C72983		lw		$a1,12[$sp]		; reply mbx
FFFC1410 00198993		add		$a1,$a1,#1		; -1 = no reply requested
FFFC1414 01298E63		beq		$a1,$a0,.0001
FFFC1418 FFF98993		sub		$a1,$a1,#1
FFFC141C 00906913		ldi		$a0,#9				; sendmsg
FFFC1420 FFF06A13		ldi		$a2,#-1
FFFC1424 FFF06A93		ldi		$a3,#-1
FFFC1428 FFF06B13		ldi		$a4,#-1
FFFC142C 00000073		ecall
                        	.0001:
FFFC1430 FA1FF06F		jmp		SerialServiceLoop
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialGetChar
                        	;
                        	; Check the serial port buffer to see if there's a char available. If there's
                        	; a char available then return it. If the buffer is almost empty then send an
                        	; XON.
                        	;
                        	; Stack Space:
                        	;		3 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$v0 = character or -1
                        	;------------------------------------------------------------------------------
                        	
                        	SerialGetChar:
FFFC1434 FE870713			sub		$sp,$sp,#24
FFFC1438 00173023			sto		$ra,[$sp]
FFFC143C 01173423			sto		$v1,8[$sp]
FFFC1440 00473823			sto		$s1,16[$sp]
FFFC1444 00026637			lb		$s1,SerRcvXon				; skip sending XON if already sent
FFFC1448 81060613
FFFC144C 00060633
FFFC1450 00060203
FFFC1454 3000F273			csrrc	$s1,#$300,#1				; disable interrupts
FFFC1458 04021263			bne		$s1,$x0,.0002
FFFC145C 1E4000EF			call	SerialRcvCount			; check number of chars in receive buffer
FFFC1460 00882813			slt		$v0,$v0,#8					; less than 8?
FFFC1464 02080C63			beq		$v0,$x0,.0002
FFFC1468 01106813			ldi		$v0,#XON						; if <8 send an XON
FFFC146C 00026637			sb		$x0,SerRcvXoff			; clear XOFF status
FFFC1470 81160613
FFFC1474 00060633
FFFC1478 00060023
FFFC147C 00026637			sb		$v0,SerRcvXon				; flag so we don't send it multiple times
FFFC1480 81060613
FFFC1484 00060633
FFFC1488 01060023
FFFC148C FFDC1637			sb		$v0,UART+UART_TRB
FFFC1490 A0060613
FFFC1494 00060633
FFFC1498 01060023
                        	.0002:
FFFC149C 00026637			lbu		$v1,SerHeadRcv			; check if anything is in buffer
FFFC14A0 80060613
FFFC14A4 00060633
FFFC14A8 00064883
FFFC14AC 00026637			lbu		$v0,SerTailRcv
FFFC14B0 80460613
FFFC14B4 00060633
FFFC14B8 00064803
FFFC14BC 03180663			beq		$v0,$v1,.noChars		; no?
FFFC14C0 00025637			lb		$v0,SerRcvBuf[$v1]	; get byte from buffer
FFFC14C4 00060613
FFFC14C8 01160633
FFFC14CC 00060803
FFFC14D0 00188893			add		$v1,$v1,#1					; update head index
FFFC14D4 00026637			sb		$v1,SerHeadRcv				
FFFC14D8 80060613
FFFC14DC 00060633
FFFC14E0 01160023
FFFC14E4 00000463			bra		.xit
                        	.noChars:
                        	.0001:
FFFC14E8 FFF06813			ldi		$v0,#-1
                        	.xit
FFFC14EC 30021073			csrrw	$x0,#$300,$s1				; restore interrupts
FFFC14F0 00073083			ldo		$ra,[$sp]
FFFC14F4 00873883			ldo		$v1,8[$sp]
FFFC14F8 01073203			ldo		$s1,16[$sp]
FFFC14FC 01870713			add		$sp,$sp,#24
FFFC1500 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPeekChar
                        	;
                        	; Check the serial port buffer to see if there's a char available. If there's
                        	; a char available then return it. But don't update the buffer indexes. No need
                        	; to send an XON here.
                        	;
                        	; Stack Space:
                        	;		3 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$v0 = character or -1
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPeekChar:
FFFC1504 FE870713		sub		$sp,$sp,#24
FFFC1508 00173023		sto		$ra,[$sp]
FFFC150C 01173423		sto		$v1,8[$sp]
FFFC1510 00473823		sto		$s1,16[$sp]
FFFC1514 3000F273		csrrc	$s1,#$300,#1				; disable interrupts
FFFC1518 00026637		ldbu	$v1,SerHeadRcv			; check if anything is in buffer
FFFC151C 80060613
FFFC1520 00060633
FFFC1524 00064883
FFFC1528 00026637		ldbu	$v0,SerTailRcv
FFFC152C 80460613
FFFC1530 00060633
FFFC1534 00064803
FFFC1538 01180C63		beq		$v0,$v1,.noChars		; no?
FFFC153C 00025637		ldb		$v0,SerRcvBuf[$v1]	; get byte from buffer
FFFC1540 00060613
FFFC1544 01160633
FFFC1548 00060803
FFFC154C 00000463		bra		.xit
                        	.noChars:
                        	.0001:
FFFC1550 FFF06813		ldi		$v0,#-1
                        	.xit
FFFC1554 30021073		csrrw	$x0,#$300,$s1				; restore interrupts
FFFC1558 00073083		ldo		$ra,[$sp]
FFFC155C 00873883		ldo		$v1,8[$sp]
FFFC1560 01073203		ldo		$s1,16[$sp]
FFFC1564 01870713		add		$sp,$sp,#24
FFFC1568 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPeekChar
                        	;		Get a character directly from the I/O port. This bypasses the input
                        	; buffer.
                        	;
                        	; Stack Space:
                        	;		3 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$v0 = character or -1
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPeekCharDirect:
FFFC156C FE870713		sub		$sp,$sp,#24
FFFC1570 00173023		sto		$ra,[$sp]
FFFC1574 01173423		sto		$v1,8[$sp]
FFFC1578 00473823		sto		$s1,16[$sp]
FFFC157C 3000F273		csrrc	$s1,#$300,#1				; disable interrupts
FFFC1580 FFDC1637		ldb		$v0,UART+UART_STAT
FFFC1584 A0460613
FFFC1588 00060633
FFFC158C 00060803
FFFC1590 00887813		and		$v0,$v0,#8					; look for Rx not empty
FFFC1594 00080C63		beq		$v0,$x0,.0001
FFFC1598 FFDC1637		ldb		$v0,UART+UART_TRB
FFFC159C A0060613
FFFC15A0 00060633
FFFC15A4 00060803
FFFC15A8 00000463		bra		.xit
                        	.0001:
FFFC15AC FFF06813		ldi		$v0,#-1
                        	.xit
FFFC15B0 30021073		csrrw	$x0,#$300,$s1				; restore interrupts
FFFC15B4 00073083		ldo		$ra,[$sp]
FFFC15B8 00873883		ldo		$v1,8[$sp]
FFFC15BC 01073203		ldo		$s1,16[$sp]
FFFC15C0 01870713		add		$sp,$sp,#24
FFFC15C4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPutChar
                        	;    Put a character to the serial transmitter. This routine blocks until the
                        	; transmitter is empty. The routine will attempt to transmit the char up to 
                        	; 10 times. If it still can't transmit the char then sleep is called and the
                        	; task is put to sleep for a tick. When it wakes up the routine continues to
                        	; try and send a character.
                        	;
                        	; Stack Space
                        	;		5 words
                        	; Parameters:
                        	;		$a3 = character to put
                        	; Modifies:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPutChar:
FFFC15C8 FE870713		sub		$sp,$sp,#24
FFFC15CC 01073023		sto		$v0,[$sp]
FFFC15D0 00173423		sto		$ra,8[$sp]
FFFC15D4 01173823		sto		$v1,16[$sp]
                        	.0002:
FFFC15D8 00A06893		ldi		$v1,#10
                        	.0001:
                        	;	sub		$v1,$v1,#1
                        	;	beq		$v1,$x0,.goSleep
FFFC15DC FFDC1637		ldb		$v0,UART+UART_STAT	; wait until the uart indicates tx empty
FFFC15E0 A0460613
FFFC15E4 00060633
FFFC15E8 00060803
FFFC15EC 01087813		and		$v0,$v0,#16					; bit #4 of the status reg
FFFC15F0 FE0806E3		beqz	$v0,.0001						; branch if transmitter is not empty
FFFC15F4 FFDC1637		stb		$a3,UART+UART_TRB		; send the byte
FFFC15F8 A0060613
FFFC15FC 00060633
FFFC1600 01560023
FFFC1604 00073803		ldo		$v0,[$sp]
FFFC1608 00873083		ldo		$ra,8[$sp]
FFFC160C 01073883		ldo		$v1,16[$sp]
FFFC1610 01870713		add		$sp,$sp,#24
FFFC1614 00008067		ret
                        	.goSleep:
FFFC1618 FF070713		sub		$sp,$sp,#16
FFFC161C 01273023		sto		$a0,[$sp]
FFFC1620 01373423		sto		$a1,8[$sp]
FFFC1624 00506913		ldi		$a0,#5							; sleep function
FFFC1628 00106993		ldi		$a1,#1							; 1 tick
FFFC162C 00000073		ecall
FFFC1630 00073903		ldo		$a0,[$sp]
FFFC1634 00873983		ldo		$a1,8[$sp]
FFFC1638 01070713		add		$sp,$sp,#16
FFFC163C F8000EE3		bra		.0002
                        	
                        	;------------------------------------------------------------------------------
                        	; Calculate number of character in input buffer
                        	;------------------------------------------------------------------------------
                        	
                        	SerialRcvCount:
FFFC1640 00026637		ldbu	$v0,SerTailRcv	; v0 = tail index
FFFC1644 80460613
FFFC1648 00060633
FFFC164C 00064803
FFFC1650 00026637		ldbu	$v1,SerHeadRcv	; v1 = head index
FFFC1654 80060613
FFFC1658 00060633
FFFC165C 00064883
FFFC1660 41180D33		sub		$t0,$v0,$v1
FFFC1664 000D5863		bge		$t0,$x0,.xit
FFFC1668 10006D13		ldi		$t0,#256
FFFC166C 411D0D33		sub		$t0,$t0,$v1
FFFC1670 010D0D33		add		$t0,$t0,$v0
                        	.xit:
FFFC1674 000D6833		mov		$v0,$t0
FFFC1678 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	SerialIRQ:
                        	.nxtByte:
FFFC167C 00897D13		and		$t0,$a0,#$08				; bit 3 = rx full
FFFC1680 0C0D0063		beq		$t0,$x0,.notRxInt
FFFC1684 FFDC1637		ldt		$a1,UART+UART_TRB		; get data from Rx buffer to clear interrupt
FFFC1688 A0060613
FFFC168C 00060633
FFFC1690 00062983
FFFC1694 00026637		ldbu	$t2,SerHeadRcv			; get buffer indexes
FFFC1698 80060613
FFFC169C 00060633
FFFC16A0 00064E03
FFFC16A4 00026637		ldbu	$t3,SerTailRcv
FFFC16A8 80460613
FFFC16AC 00060633
FFFC16B0 00064E83
FFFC16B4 001E8E93		add		$t3,$t3,#1					; see if buffer full
FFFC16B8 0FFEFE93		and		$t3,$t3,#255
FFFC16BC 09DE0263		beq		$t2,$t3,.rxFull
FFFC16C0 00026637		stb		$t3,SerTailRcv			; update tail pointer
FFFC16C4 80460613
FFFC16C8 00060633
FFFC16CC 01D60023
FFFC16D0 FFFE8E93		sub		$t3,$t3,#1
FFFC16D4 0FFEFE13		and		$t2,$t3,#255
FFFC16D8 00025637		stb		$a1,SerRcvBuf[$t2]	; store recieved byte in buffer
FFFC16DC 00060613
FFFC16E0 01C60633
FFFC16E4 01360023
FFFC16E8 00026637		ldb		$v0,SerRcvXoff			; check if xoff already sent
FFFC16EC 81160613
FFFC16F0 00060633
FFFC16F4 00060803
FFFC16F8 02081A63		bne		$v0,$x0,.0001
FFFC16FC F45FF0EF		call	SerialRcvCount			; if more than 240 chars in buffer
FFFC1700 0F082813		slt		$v0,$v0,#240				; send an XOFF
FFFC1704 02081463		bne		$v0,$x0,.0001
FFFC1708 01306913		ldi		$a0,#XOFF
FFFC170C 00026637		stb		$x0,SerRcvXon				; clear XON status
FFFC1710 81060613
FFFC1714 00060633
FFFC1718 00060023
FFFC171C 00026637		stb		$a0,SerRcvXoff			; set XOFF status
FFFC1720 81160613
FFFC1724 00060633
FFFC1728 01260023
                        		stb		UART+UART_TRB
                        	.0001:
FFFC172C FFDC1637		ldt		$a0,UART+UART_STAT	; check the status for another byte
FFFC1730 A0460613
FFFC1734 00060633
FFFC1738 00062903
FFFC173C F40000E3		bra		.nxtByte
                        	;	ldi		$a0,#$0B						; dtr,rts active, rxint disabled, no parity
                        	;	sw		$a0,UART+UART_CMD
                        	.rxFull:
                        	.notRxInt:
FFFC1740 79217073		csrrc	$x0,#$792,#2			; clear IRQ semaphore
FFFC1744 10000073		eret
                        	
                        	nmeSerial:
FFFC1748 69726553		db		"Serial",0
FFFC174C 00006C61
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/via.r5a",1
                        	.file "../fmtk/via.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
FFFC174F 00000000		align	
                        	
                        	ViaFuncTbl:
FFFC1750 00000000		dco		0							; no operation
FFFC1754 00000000
FFFC1758 00000000		dco		0							; setup
FFFC175C 00000000
FFFC1760 00000000		dco		0							; initialize
FFFC1764 00000000
FFFC1768 00000000		dco		0							; status
FFFC176C 00000000
FFFC1770 00000000		dco		0							; media check
FFFC1774 00000000
FFFC1778 00000000		dco		0							; build BPB
FFFC177C 00000000
FFFC1780 00000000		dco		0							; open
FFFC1784 00000000
FFFC1788 00000000		dco		0							; close
FFFC178C 00000000
FFFC1790 00000000		dco		0							; get char
FFFC1794 00000000
FFFC1798 00000000		dco		0							; Peek char
FFFC179C 00000000
FFFC17A0 00000000		dco		0							; get char direct
FFFC17A4 00000000
FFFC17A8 00000000		dco		0							; peek char direct
FFFC17AC 00000000
FFFC17B0 00000000		dco		0							; input status
FFFC17B4 00000000
FFFC17B8 00000000		dco		0							; Put char
FFFC17BC 00000000
FFFC17C0 00000000		dco		0							; reserved
FFFC17C4 00000000
FFFC17C8 00000000		dco		0							; set position
FFFC17CC 00000000
FFFC17D0 00000000		dco		0							; read block
FFFC17D4 00000000
FFFC17D8 00000000		dco		0							; write block
FFFC17DC 00000000
FFFC17E0 00000000		dco		0							; verify block
FFFC17E4 00000000
FFFC17E8 00000000		dco		0							; output status
FFFC17EC 00000000
FFFC17F0 00000000		dco		0							; flush input
FFFC17F4 00000000
FFFC17F8 00000000		dco		0							; flush output
FFFC17FC 00000000
FFFC1800 FFFC18AC		dco		ViaIRQ				; IRQ routine
FFFC1804 00000000
FFFC1808 00000000		dco		0							; Is removable
FFFC180C 00000000
FFFC1810 00000000		dco		0							; ioctrl read
FFFC1814 00000000
FFFC1818 00000000		dco		0							; ioctrl write
FFFC181C 00000000
FFFC1820 00000000		dco		0							; output until busy
FFFC1824 00000000
FFFC1828 00000000		dco		0							; 27
FFFC182C 00000000
FFFC1830 00000000		dco		0
FFFC1834 00000000
FFFC1838 00000000		dco		0
FFFC183C 00000000
FFFC1840 00000000		dco		0
FFFC1844 00000000
FFFC1848 00000000		dco		0							; 31
FFFC184C 00000000
                        	
                        	;------------------------------------------------------------------------------
                        	; ViaInit
                        	;
                        	; Initialize the versatile interface adapter.
                        	;------------------------------------------------------------------------------
                        	
                        	ViaInit:
FFFC1850 FF870713		sub		$sp,$sp,#8
FFFC1854 00173023		sto		$ra,[$sp]
FFFC1858 00F06913		ldi		$a0,#15							; VIA device
FFFC185C FFFC19B7		ldi		$a1,#ViaFuncTbl
FFFC1860 75098993
FFFC1864 7B9010EF		call	CopyDevFuncTbl
                        		; Initialize port A low order eight bits as output, the remaining bits as
                        		; input.
FFFC1868 FFDC0DB7		ldi		$t1,#VIA
FFFC186C 600D8D93
FFFC1870 0FF06D13		ldi		$t0,#$000000FF
FFFC1874 01ADA623		stt		$t0,VIA_DDRA[$t1]
FFFC1878 00106D13		ldi		$t0,#1							; select timer 3 access
FFFC187C 03AD88A3		stb		$t0,VIA_PCR+1[$t1]
FFFC1880 01F06D13		ldi		$t0,#$1F
FFFC1884 03AD86A3		stb		$t0,VIA_ACR+1[$t1]		; set timer 3 mode, timer 1/2 = 64 bit
FFFC1888 0016ED37		ldi		$t0,#$0016E360			;	divider value for 33.333Hz (30 ms)
FFFC188C 360D0D13
FFFC1890 01ADA823		stt		$t0,VIA_T1CL[$t1]
FFFC1894 000DAA23		stt		$x0,VIA_T1CH[$t1]		; trigger transfer to count registers
FFFC1898 18006D13		ldi		$t0,#$180						; enable timer3 interrupts
FFFC189C 03ADAC23		stt		$t0,VIA_IER[$t1]
FFFC18A0 00073083		ldo		$ra,[$sp]
FFFC18A4 00870713		add		$sp,$sp,#8
FFFC18A8 00008067		ret
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	ViaIRQ:
                        		; Was it the VIA that caused the interrupt?
FFFC18AC FFDC0DB7		ldi		$t1,#VIA
FFFC18B0 600D8D93
FFFC18B4 034D8D03		ldb		$t0,VIA_IFR[$t1]
FFFC18B8 040D5463		bge		$t0,$x0,.0003				; no
FFFC18BC 00106D13		ldi		$t0,#1							; select timer 3 access
FFFC18C0 03AD88A3		stb		$t0,VIA_PCR+1[$t1]
FFFC18C4 010DAD03		ldt		$t0,VIA_T1CL[$t1]		; yes, clear interrupt
FFFC18C8 00014637		ldo		$t0,milliseconds
FFFC18CC 20860613
FFFC18D0 00060633
FFFC18D4 00063D03
FFFC18D8 01ED0D13		add		$t0,$t0,#30
FFFC18DC 00014637		sto		$t0,milliseconds
FFFC18E0 20860613
FFFC18E4 00060633
FFFC18E8 01A63023
FFFC18EC 00014637		stt		$t0,switchflag
FFFC18F0 20060613
FFFC18F4 00060633
FFFC18F8 01A62023
FFFC18FC 4B1000EF		call	FMTK_SchedulerIRQ
                        	.0003:
FFFC1900 79217073		csrrc	$x0,#$792,#2			; clear IRQ semaphore
FFFC1904 10000073		eret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/video.r5a",1
                        	.file "../fmtk/video.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	TC64CursorAddr	equ		$FFD1DF1C
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
                        		align	8                        	
                        	VideoFuncTbl:
FFFC1908 00000000		dco		0							; no operation
FFFC190C 00000000
FFFC1910 00000000		dco		0							; setup
FFFC1914 00000000
FFFC1918 00000000		dco		0							; initialize
FFFC191C 00000000
FFFC1920 00000000		dco		0							; status
FFFC1924 00000000
FFFC1928 00000000		dco		0							; media check
FFFC192C 00000000
FFFC1930 00000000		dco		0							; build BPB
FFFC1934 00000000
FFFC1938 00000000		dco		0							; open
FFFC193C 00000000
FFFC1940 00000000		dco		0							; close
FFFC1944 00000000
FFFC1948 00000000		dco		0							; get char
FFFC194C 00000000
FFFC1950 00000000		dco		0							; Peek char
FFFC1954 00000000
FFFC1958 00000000		dco		0							; get char direct
FFFC195C 00000000
FFFC1960 00000000		dco		0							; peek char direct
FFFC1964 00000000
FFFC1968 00000000		dco		0							; input status
FFFC196C 00000000
FFFC1970 FFFC1B24		dco		VideoPutChar	; Put char
FFFC1974 00000000
FFFC1978 00000000		dco		0							; reserved
FFFC197C 00000000
FFFC1980 00000000		dco		0							; set position
FFFC1984 00000000
FFFC1988 00000000		dco		0							; read block
FFFC198C 00000000
FFFC1990 00000000		dco		0							; write block
FFFC1994 00000000
FFFC1998 00000000		dco		0							; verify block
FFFC199C 00000000
FFFC19A0 00000000		dco		0							; output status
FFFC19A4 00000000
FFFC19A8 00000000		dco		0							; flush input
FFFC19AC 00000000
FFFC19B0 00000000		dco		0							; flush output
FFFC19B4 00000000
FFFC19B8 FFFC1E48		dco		VideoIRQ			; IRQ routine
FFFC19BC 00000000
FFFC19C0 00000000		dco		0							; Is removable
FFFC19C4 00000000
FFFC19C8 00000000		dco		0							; ioctrl read
FFFC19CC 00000000
FFFC19D0 00000000		dco		0							; ioctrl write
FFFC19D4 00000000
FFFC19D8 00000000		dco		0							; output until busy
FFFC19DC 00000000
FFFC19E0 00000000		dco		0							; 27
FFFC19E4 00000000
FFFC19E8 00000000		dco		0
FFFC19EC 00000000
FFFC19F0 00000000		dco		0
FFFC19F4 00000000
FFFC19F8 00000000		dco		0
FFFC19FC 00000000
FFFC1A00 00000000		dco		0							; 31
FFFC1A04 00000000
                        	
                        	;------------------------------------------------------------------------------
                        	; VideoInit
                        	;
                        	; Initialize the versatile interface adapter.
                        	;------------------------------------------------------------------------------
                        	
                        	VideoInit:
FFFC1A08 FF870713		sub		$sp,$sp,#8
FFFC1A0C 00173023		sto		$ra,[$sp]
FFFC1A10 00206913		ldi		$a0,#2							; Video device
FFFC1A14 FFFC29B7		ldi		$a1,#VideoFuncTbl
FFFC1A18 90898993
FFFC1A1C 601010EF		call	CopyDevFuncTbl
FFFC1A20 00025637		stb		$x0,CursorX
FFFC1A24 80060613
FFFC1A28 00060633
FFFC1A2C 00060023
FFFC1A30 00025637		stb		$x0,CursorY
FFFC1A34 80160613
FFFC1A38 00060633
FFFC1A3C 00060023
FFFC1A40 000F0D37		ldi		$t0,#$000F0000
FFFC1A44 000D0D13
FFFC1A48 00025637		stt		$t0,DispAttr
FFFC1A4C 80860613
FFFC1A50 00060633
FFFC1A54 01A62023
FFFC1A58 00210D37		ldi		$t0,#$0020FFFF
FFFC1A5C FFFD0D13
FFFC1A60 00025637		stt		$t0,DispAttr+4
FFFC1A64 80C60613
FFFC1A68 00060633
FFFC1A6C 01A62023
FFFC1A70 010000EF		call	VideoClearScreen
FFFC1A74 00073083		ldo		$ra,[$sp]
FFFC1A78 00870713		add		$sp,$sp,#8
FFFC1A7C 00008067		ret
                        	
                        	VideoClearScreen:
                        	;	csrrs	$x0,#$300,#1				; interrupts on
FFFC1A80 65806D13		ldi		$t0,#56*29
FFFC1A84 00025637		ldo		$t1,DispAttr
FFFC1A88 80860613
FFFC1A8C 00060633
FFFC1A90 00063D83
FFFC1A94 020DED93		or		$t1,$t1,#' '
                        		
                        		
FFFC1A98 18101873		csrrw	v0,#$181,x0
FFFC1A9C 03F87813		and		v0,v0,#MAX_TID
FFFC1AA0 00A81813	sll		$v0,$v0,#LOG_TCBSZ
FFFC1AA4 33883803		ldo		$v0,TCBpVideo[$v0]
FFFC1AA8 FFD00837		ldi		$v0,#$FFD00000
FFFC1AAC 00080813
                        	.0001:
FFFC1AB0 01B83023		sto		$t1,[$v0]	
FFFC1AB4 00880813		add		$v0,$v0,#8
FFFC1AB8 FFFD0D13		sub		$t0,$t0,#1
FFFC1ABC FFA04AE3		bgt		$t0,$x0,.0001
FFFC1AC0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	VideoHomeCursor:
FFFC1AC4 00025637		stb		$x0,CursorX
FFFC1AC8 80060613
FFFC1ACC 00060633
FFFC1AD0 00060023
FFFC1AD4 00025637		stb		$x0,CursorY
FFFC1AD8 80160613
FFFC1ADC 00060633
FFFC1AE0 00060023
                        		; fall through into update cursor pos.
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	UpdateCursorPos:
FFFC1AE4 00025637		ldbu	$t0,CursorY
FFFC1AE8 80160613
FFFC1AEC 00060633
FFFC1AF0 00064D03
FFFC1AF4 03806D93		ldi		$t1,#56
FFFC1AF8 03BD0D33		mul		$t0,$t0,$t1
FFFC1AFC 00025637		ldbu	$t1,CursorX
FFFC1B00 80060613
FFFC1B04 00060633
FFFC1B08 00064D83
FFFC1B0C 01BD0D33		add		$t0,$t0,$t1
FFFC1B10 FFD1E637		stw		$t0,TC64CursorAddr
FFFC1B14 F1C60613
FFFC1B18 00060633
FFFC1B1C 01A61023
FFFC1B20 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a3 = character to display
                        	;------------------------------------------------------------------------------
                        	
                        	VideoPutChar:
FFFC1B24 FF070713		sub		$sp,$sp,#16
FFFC1B28 00173023		sto		$ra,[$sp]
FFFC1B2C 00473423		sto		$s1,8[$sp]
FFFC1B30 00D06D13		ldi		$t0,#CR
FFFC1B34 15AA8063		beq		$a3,$t0,.doCR
FFFC1B38 00A06D13		ldi		$t0,#$0A				; line feed
FFFC1B3C 15AA8863		beq		$a3,$t0,.doLF
FFFC1B40 00C06D13		ldi		$t0,#$0C				; CTRL-L
FFFC1B44 21AA8C63		beq		$a3,$t0,.doCls
FFFC1B48 09106D13		ldi		$t0,#$91
FFFC1B4C 15AA8A63		beq		$a3,$t0,.cursorRight
FFFC1B50 09306D13		ldi		$t0,#$93
FFFC1B54 19AA8063		beq		$a3,$t0,.cursorLeft
FFFC1B58 09006D13		ldi		$t0,#$90
FFFC1B5C 1BAA8263		beq		$a3,$t0,.cursorUp
FFFC1B60 09206D13		ldi		$t0,#$92
FFFC1B64 1DAA8463		beq		$a3,$t0,.cursorDown
FFFC1B68 00806D13		ldi		$t0,#BS
FFFC1B6C 1FAA8E63		beq		$a3,$t0,.backspace
FFFC1B70 09906D13		ldi		$t0,#$99
FFFC1B74 29AA8463		beq		$a3,$t0,.delete
                        		
                        		
FFFC1B78 18101873		csrrw	v0,#$181,x0
FFFC1B7C 03F87813		and		v0,v0,#MAX_TID
FFFC1B80 00A81813	sll		$v0,$v0,#LOG_TCBSZ
FFFC1B84 33883803		ldo		$v0,TCBpVideo[$v0]
FFFC1B88 FFD00837		ldi		$v0,#$FFD00000
FFFC1B8C 00080813
FFFC1B90 00086D33	mov		$t0,$v0
FFFC1B94 00025637		ldbu	$t1,CursorX
FFFC1B98 80060613
FFFC1B9C 00060633
FFFC1BA0 00064D83
FFFC1BA4 003D9D93		sll		$t1,$t1,#3						; *8 bytes per display cell
FFFC1BA8 01BD6D33		or		$t0,$t0,$t1						; add in base address
FFFC1BAC 00025637		ldbu	$t1,CursorY
FFFC1BB0 80160613
FFFC1BB4 00060633
FFFC1BB8 00064D83
FFFC1BBC 1C006E13		ldi		$t2,#56*8
FFFC1BC0 03CD8DB3		mul		$t1,$t1,$t2
FFFC1BC4 01BD0D33		add		$t0,$t0,$t1
FFFC1BC8 00025637		ldo		$t1,DispAttr
FFFC1BCC 80860613
FFFC1BD0 00060633
FFFC1BD4 00063D83
FFFC1BD8 015DEDB3		or		$t1,$t1,$a3
FFFC1BDC 01BD3023		sto		$t1,[$t0]							; store to screen memory
FFFC1BE0 00025637		ldbu	$t0,CursorX						; increment cursor position
FFFC1BE4 80060613
FFFC1BE8 00060633
FFFC1BEC 00064D03
FFFC1BF0 001D0D13		add		$t0,$t0,#1
FFFC1BF4 03806D93		ldi		$t1,#56
FFFC1BF8 07BD4263		blt		$t0,$t1,.saveX
FFFC1BFC 00006D13		ldi		$t0,#0
                        	.doLF1:
FFFC1C00 00025637		ldbu	$t2,CursorY
FFFC1C04 80160613
FFFC1C08 00060633
FFFC1C0C 00064E03
FFFC1C10 001E0E13		add		$t2,$t2,#1
FFFC1C14 01D06D93		ldi		$t1,#29
FFFC1C18 03BE4A63		blt		$t2,$t1,.saveY
                        		; scroll up
FFFC1C1C 65806E93		ldi		$t3,#56*29
FFFC1C20 FFD00F37		ldi		$t4,#$FFD00000
FFFC1C24 000F0F13
                        	.0001:
FFFC1C28 1C0F3F83		ldo		$t5,56*8[$t4]
FFFC1C2C 01FF3023		sto		$t5,[$t4]
FFFC1C30 008F0F13		add		$t4,$t4,#8
FFFC1C34 FFFE8E93		sub		$t3,$t3,#1
FFFC1C38 FFD048E3		bgt		$t3,$x0,.0001
                        	.xit:
FFFC1C3C 00073083		ldo		$ra,[$sp]
FFFC1C40 00873203		ldo		$s1,8[$sp]
FFFC1C44 01070713		add		$sp,$sp,#16
FFFC1C48 00008067		ret
                        	.saveY:
FFFC1C4C 00025637		stb		$t2,CursorY
FFFC1C50 80160613
FFFC1C54 00060633
FFFC1C58 01C60023
                        	.saveX:
FFFC1C5C 00025637		stb		$t0,CursorX
FFFC1C60 80060613
FFFC1C64 00060633
FFFC1C68 01A60023
FFFC1C6C E79FF0EF		call	UpdateCursorPos
FFFC1C70 FC0006E3		bra		.xit
                        	.doCR:
FFFC1C74 00025637		stb		$x0,CursorX
FFFC1C78 80060613
FFFC1C7C 00060633
FFFC1C80 00060023
FFFC1C84 E61FF0EF		call	UpdateCursorPos
FFFC1C88 FA000AE3		bra		.xit
                        	.doLF:
FFFC1C8C 00025637		ldbu	$t0,CursorX
FFFC1C90 80060613
FFFC1C94 00060633
FFFC1C98 00064D03
FFFC1C9C F60002E3		bra		.doLF1
                        	.cursorRight:
FFFC1CA0 00025637		ldbu	$t0,CursorX
FFFC1CA4 80060613
FFFC1CA8 00060633
FFFC1CAC 00064D03
FFFC1CB0 001D0D13		add		$t0,$t0,#1
FFFC1CB4 03706D93		ldi		$t1,#55
FFFC1CB8 01BD5C63		bge		$t0,$t1,.cr1
FFFC1CBC 00025637		stb		$t0,CursorX
FFFC1CC0 80060613
FFFC1CC4 00060633
FFFC1CC8 01A60023
                        	.cr2:
FFFC1CCC E19FF0EF		call	UpdateCursorPos
                        	.cr1:
FFFC1CD0 F60006E3		bra		.xit
                        	.cursorLeft:
FFFC1CD4 00025637		ldbu	$t0,CursorX
FFFC1CD8 80060613
FFFC1CDC 00060633
FFFC1CE0 00064D03
FFFC1CE4 FFFD0D13		sub		$t0,$t0,#1
FFFC1CE8 FE0D44E3		blt		$t0,$x0,.cr1
FFFC1CEC 00025637		stb		$t0,CursorX
FFFC1CF0 80060613
FFFC1CF4 00060633
FFFC1CF8 01A60023
FFFC1CFC FC0008E3		bra		.cr2
                        	.cursorUp:
FFFC1D00 00025637		ldbu	$t0,CursorY
FFFC1D04 80160613
FFFC1D08 00060633
FFFC1D0C 00064D03
FFFC1D10 FFFD0D13		sub		$t0,$t0,#1
FFFC1D14 FA0D4EE3		blt		$t0,$x0,.cr1
FFFC1D18 00025637		stb		$t0,CursorY
FFFC1D1C 80160613
FFFC1D20 00060633
FFFC1D24 01A60023
FFFC1D28 FA0002E3		bra		.cr2
                        	.cursorDown:
FFFC1D2C 00025637		ldbu	$t0,CursorY
FFFC1D30 80160613
FFFC1D34 00060633
FFFC1D38 00064D03
FFFC1D3C 001D0D13		add		$t0,$t0,#1
FFFC1D40 01D06D93		ldi		$t1,#29
FFFC1D44 F9BD56E3		bge		$t0,$t1,.cr1
FFFC1D48 00025637		stb		$t0,CursorY
FFFC1D4C 80160613
FFFC1D50 00060633
FFFC1D54 01A60023
FFFC1D58 F6000AE3		bra		.cr2
                        	.doCls:
FFFC1D5C D25FF0EF		call	VideoClearScreen
FFFC1D60 D65FF0EF		call	VideoHomeCursor
FFFC1D64 F60006E3		bra		.cr1
                        	.backspace:
FFFC1D68 00025637		ldbu	$t0,CursorX
FFFC1D6C 80060613
FFFC1D70 00060633
FFFC1D74 00064D03
FFFC1D78 F40D0CE3		beqz	$t0,.cr1
FFFC1D7C FFFD0D13		sub		$t0,$t0,#1
FFFC1D80 00025637		stb		$t0,CursorX
FFFC1D84 80060613
FFFC1D88 00060633
FFFC1D8C 01A60023
                        	.del0001:
FFFC1D90 03706213		ldi		$s1,#55
FFFC1D94 41A20233		sub		$s1,$s1,$t0
FFFC1D98 D4DFF0EF		call	UpdateCursorPos
FFFC1D9C 00025637		ldbu	$t1,CursorY
FFFC1DA0 80160613
FFFC1DA4 00060633
FFFC1DA8 00064D83
FFFC1DAC 1C006E93		ldi		$t3,#56*8
FFFC1DB0 03DD8DB3		mul		$t1,$t1,$t3
FFFC1DB4 003D1D13		sll		$t0,$t0,#3
FFFC1DB8 01AD8EB3		add		$t3,$t1,$t0
FFFC1DBC FFD00637		add		$t3,$t3,#$FFD00000
FFFC1DC0 00060613
FFFC1DC4 01D60EB3
FFFC1DC8 00020C63		beqz	$s1,.bs0001
                        	.bs0002:
FFFC1DCC 008EBF03		ldo		$t4,8[$t3]
FFFC1DD0 01EEB023		sto		$t4,[$t3]
FFFC1DD4 008E8E93		add		$t3,$t3,#8
FFFC1DD8 FFF20213		sub		$s1,$s1,#1
FFFC1DDC FFFFC8E3		bgt		$s1,.bs0002
                        	.bs0001:
FFFC1DE0 00025637		ldo		$t4,DispAttr
FFFC1DE4 80860613
FFFC1DE8 00060633
FFFC1DEC 00063F03
FFFC1DF0 020F6F13		or		$t4,$t4,#' '
FFFC1DF4 01EEB423		sto		$t4,8[$t3]
FFFC1DF8 E40002E3		bra		.xit
                        	.delete:
FFFC1DFC 00025637		ldbu	$t0,CursorX
FFFC1E00 80060613
FFFC1E04 00060633
FFFC1E08 00064D03
FFFC1E0C F80002E3		bra		.del0001	
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1  = pointer to null terminated string
                        	;------------------------------------------------------------------------------
                        	
                        	VideoPutString:
FFFC1E10 FF870713		sub		$sp,$sp,#8
FFFC1E14 00173023		sto		$ra,[$sp]
FFFC1E18 00010D37		ldi		$t0,#$10000
FFFC1E1C 000D0D13
                        	.again:
FFFC1E20 300D2073		csrrs	$x0,#$300,$t0		; set mprv
FFFC1E24 0009CA83		ldbu	$a3,[$a1]				; access using passed in memory space
FFFC1E28 300D3073		csrrc	$x0,#$300,$t0		; clear mprv
FFFC1E2C 00198993		add		$a1,$a1,#1
FFFC1E30 000A8663		beqz	$a3,.done
FFFC1E34 CF1FF0EF		call	VideoPutChar
FFFC1E38 FE0004E3		bra		.again
                        	.done:
FFFC1E3C 00073083		ldo		$ra,[$sp]
FFFC1E40 00870713		add		$sp,$sp,#8
FFFC1E44 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	VideoIRQ:
                        		; Was it the Video that caused the interrupt?
                        	.0003:
FFFC1E48 10000073		eret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/task.r5a",1
                        	.file "../fmtk/task.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../fmtk/task.r5a",25
                        		code
                        		align	2                        	
                        	OSCallTbl:
FFFC1E4C 277801BF		dh		FMTK_Initialize					; 0
FFFC1E4E 29082778		dh		FMTK_StartTask					; 1
FFFC1E50 29342908		dh		FMTK_ExitTask
FFFC1E52 01C32934		dh		FMTK_KillTask
FFFC1E54 244001C3		dh		FMTK_SetTaskPriority
FFFC1E56 2A942440		dh		FMTK_Sleep							; 5
FFFC1E58 2B642A94		dh		FMTK_AllocMbx
FFFC1E5A 01C72B64		dh		FMTK_FreeMbx
FFFC1E5C 2C4801C7		dh		FMTK_PostMsg
FFFC1E5E 2EEC2C48		dh		FMTK_SendMsg
FFFC1E60 2DBC2EEC		dh		FMTK_WaitMsg						; 10
FFFC1E62 01CB2DBC		dh		FMTK_PeekMsg
FFFC1E64 208801CB		dh		FMTK_StartApp
FFFC1E66 1FDC2088		dh		FMTK_SaveContext				; 13
FFFC1E68 334C1FDC		dh		FMTK_GetCurrentTid
FFFC1E6A 0000334C		dh		DumpReadyList
FFFC1E6C 00000000		dh		0
FFFC1E6E 00000000		dh		0
FFFC1E70 00000000		dh		0
FFFC1E72 353C0000		dh		0
FFFC1E74 359C353C		dh		FMTK_HasIOFocus					; 20
FFFC1E76 36EC359C		dh		FMTK_SwitchIOFocus			; 21
FFFC1E78 36F836EC		dh		FMTK_ReleaseIOFocus			; 22
FFFC1E7A 365436F8		dh		FMTK_ForceReleaseIOFocus	; 23
FFFC1E7C 00003654		dh		FMTK_RequestIOFocus			; 24
FFFC1E7E 37D40000		dh		0
FFFC1E80 000037D4		dh		FMTK_IO									; 26
                        	
                        	qToChk:
FFFC1E82 01000000		db	0,0,0,1,0,0,2,1
FFFC1E86 01020000
FFFC1E8A 01030000		db	0,0,3,1,0,0,2,1
FFFC1E8E 01020000
FFFC1E92 01000000		db	0,0,0,1,0,0,2,1
FFFC1E96 01020000
FFFC1E9A 01030000		db	0,0,3,1,0,0,2,1
FFFC1E9E 01020000
                        	
FFFC1EA2 46370000		align	
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FMTKInit:
FFFC1EA4 00024637		stt		$x0,QNDX
FFFC1EA8 30460613
FFFC1EAC 00060633
FFFC1EB0 00062023
FFFC1EB4 00024637		sto		$x0,PIDMAP
FFFC1EB8 31060613
FFFC1EBC 00060633
FFFC1EC0 00063023
FFFC1EC4 00024637		stt		$x0,missed_ticks
FFFC1EC8 32060613
FFFC1ECC 00060633
FFFC1ED0 00062023
FFFC1ED4 FFF06D13		ldi		$t0,#-1
FFFC1ED8 00024637		stt		$t0,TimeoutList
FFFC1EDC 32860613
FFFC1EE0 00060633
FFFC1EE4 01A62023
FFFC1EE8 00024637		stt		$t0,READYQ
FFFC1EEC 30860613
FFFC1EF0 00060633
FFFC1EF4 01A62023
FFFC1EF8 00024637		stt		$t0,READYQ+4
FFFC1EFC 30C60613
FFFC1F00 00060633
FFFC1F04 01A62023
FFFC1F08 00025637		stw		$t0,hKeybdMbx
FFFC1F0C 82260613
FFFC1F10 00060633
FFFC1F14 01A61023
                        	
FFFC1F18 00025637		stb		$x0,SwitchIOFocus	
FFFC1F1C 82060613
FFFC1F20 00060633
FFFC1F24 00060023
FFFC1F28 00025637		stt		$x0,IOFocusTbl
FFFC1F2C 81860613
FFFC1F30 00060633
FFFC1F34 00062023
FFFC1F38 00025637		stt		$t0,IOFocusNdx
FFFC1F3C 81060613
FFFC1F40 00060633
FFFC1F44 01A62023
                        	
                        		; zero out device function table
FFFC1F48 00022D37		ldi		$t0,#DVF_Base
FFFC1F4C 000D0D13
FFFC1F50 40006D93		ldi		$t1,#32*32
                        	.0003:
FFFC1F54 000D3023		sto		$x0,[$t0]
FFFC1F58 008D0D13		add		$t0,$t0,#8
FFFC1F5C FFFD8D93		sub		$t1,$t1,#1
FFFC1F60 FFB04AE3		bgt		$t1,$x0,.0003
                        	
                        		; Initialize mailboxes
FFFC1F64 00020D37		ldi		$t0,#mbxs
FFFC1F68 000D0D13
FFFC1F6C 08006D93		ldi		$t1,#4*32
                        	.0001:
FFFC1F70 000D3023		sto		$x0,[$t0]
FFFC1F74 008D0D13		add		$t0,$t0,#8
FFFC1F78 FFFD8D93		sub		$t1,$t1,#1
FFFC1F7C FFB04AE3		bgt		$t1,$x0,.0001
                        	
                        		; Initialize free message list
FFFC1F80 00010D37		ldi		$t0,#msgs
FFFC1F84 000D0D13
FFFC1F88 00024637		sto		$t0,FreeMsg
FFFC1F8C 35060613
FFFC1F90 00060633
FFFC1F94 01A63023
FFFC1F98 00006D93		ldi		$t1,#0
FFFC1F9C 00001E37		ldi		$t2,#NR_MSG
FFFC1FA0 800E0E13
                        	.0002:
FFFC1FA4 001D8D93		add		$t1,$t1,#1
FFFC1FA8 01BD3023		sto		$t1,MSG_LINK[$t0]
FFFC1FAC 020D0D13		add		$t0,$t0,#32
FFFC1FB0 FFFE0E13		sub		$t2,$t2,#1
FFFC1FB4 FFC048E3		bgt		$t2,$x0,.0002
                        	
                        		; unlock the system semaphore	
                        		
FFFC1FB8 FFF06813		ldi		v0,#-1
FFFC1FBC 00024637		sw		v0,SysSema
FFFC1FC0 34060613
FFFC1FC4 00060633
FFFC1FC8 01062023
                        	
FFFC1FCC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Get the task id for the currently running task.
                        	;
                        	; Returns:
                        	;		v0 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	GetCurrentTid:
FFFC1FD0 18101873		csrrw	$v0,#$181,$x0				; get current asid
FFFC1FD4 03F87813		and		$v0,$v0,#MAX_TID		; mask off extra bits
FFFC1FD8 00008067		ret
                        	
                        	FMTK_GetCurrentTid:
FFFC1FDC 3000E073		csrrs	$x0,#$300,#1				; enable ints
                        		
FFFC1FE0 18101873		csrrw	v0,#$181,x0
FFFC1FE4 03F87813		and		v0,v0,#MAX_TID
FFFC1FE8 000868B3	mov		$v1,$v0
FFFC1FEC 00006813		ldi		$v0,#E_Ok
FFFC1FF0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	MapOSPages:
FFFC1FF4 00306813		ldi			$v0,#OSPAGES	; number of pages pre-mapped
FFFC1FF8 00006893		ldi			$v1,#0
FFFC1FFC 01091893		sll			$v1,$a0,#16		; put ASID in proper spot
                        	.nxt:
FFFC2000 0318800D		mvmap		$x0,$v1,$v1
FFFC2004 00188893		add			$v1,$v1,#1
FFFC2008 FFF80813		sub			$v0,$v0,#1
FFFC200C FF004AE3		bgt			$v0,$x0,.nxt
FFFC2010 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Select the next task to run. The ready lists are searched in a circular
                        	; fashion beginning with the list identified indirectly by QNDX. There are
                        	; four ready lists to hold tasks of four different priorities. 
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		v1, t0, t1, t2, t3, t4
                        	;	Returns:
                        	;		v0 = task id of task to run
                        	;------------------------------------------------------------------------------
                        	
                        	SelectTaskToRun:
                        		; Pick the first queue to check, occasionally the queue
                        		; chosen isn't the highest priority one in order to 
                        		; prevent starvation of lower priority tasks.
                        	.searchQ:
FFFC2014 00024637		ldbu	$v1,QNDX						; get index into que check table
FFFC2018 30460613
FFFC201C 00060633
FFFC2020 00064883
FFFC2024 00188893		add		$v1,$v1,#1					; increment it, and limit
FFFC2028 01F8F893		and		$v1,$v1,#31
FFFC202C 00024637		stb		$v1,QNDX						; store back
FFFC2030 30460613
FFFC2034 00060633
FFFC2038 01160023
FFFC203C FFFC2637		ldbu	$v1,qToChk[$v1]			; assume this will be valid
FFFC2040 E8260613
FFFC2044 01160633
FFFC2048 00064883
FFFC204C 00406E13		ldi		$t2,#4							; 4 queues to check
                        	.nxtQ:
FFFC2050 10300073		pfi
FFFC2054 1C08880D		getrdy	$v0,$v1
;	ldw		$v0,READYQ[$v1]			; check queue to see if contains any
FFFC2058 02085463		bge		$v0,$x0,.dq					; yes, go dequeue
                        	.0001:
FFFC205C 00188893		add		$v1,$v1,#1					; no, advance to next queue
FFFC2060 0038F893		and		$v1,$v1,#3					; 4 max
FFFC2064 FFFE0E13		sub		$t2,$t2,#1					;
FFFC2068 FFC044E3		bgt		$t2,$x0,.nxtQ				; go back to check next queue
                        		; Here, nothing else is actually ready to run
FFFC206C 10100073		wfi
FFFC2070 FA0002E3		bra		.searchQ
                        		; just go back to what we were doing.
                        		
FFFC2074 18101873		csrrw	v0,#$181,x0
FFFC2078 03F87813		and		v0,v0,#MAX_TID
FFFC207C 00008067	ret
                        	.dq:
                        	;	ldi		$t3,#MAX_TID				; ensure we have a valid tid
                        	;	bleu	$v0,$t3,.goodTid
                        		; If the tid isn't valid the readyq was screwed up
                        	;	ldi		$t3,#-1							; indicate queue empty
                        	;	stw		$t3,READYQ[$v1]
                        	;	bra		.0001								; and try next queue
                        	.goodTid:
FFFC2080 18181073		csrrw	$x0,#$181,$v0
                        		;sll		$t1,$v0,#LOG_TCBSZ
                        		;ldw		$t0,TCBNext[$t1]		; update head of ready queue
                        		;stw		$t0,READYQ[$v1]
FFFC2084 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_SaveContext:
                        		
FFFC2088 18101873		csrrw	v0,#$181,x0
FFFC208C 03F87813		and		v0,v0,#MAX_TID
FFFC2090 00A81213	sll		$s1,$v0,#LOG_TCBSZ
                        	SaveContext:
FFFC2094 28A20D03		ldb		$t0,TCBContextSaved[$s1]
FFFC2098 0A0D1C63		bnez	$t0,.xit
                        		; Save outgoing register set in TCB
FFFC209C 79027073		csrrc	$x0,#CSR_REGSET,#4	; select previous (user) register set for Rs2
FFFC20A0 00123423		sto		$x1,8[$s1]
FFFC20A4 00223823		sto		$x2,16[$s1]
FFFC20A8 00323C23		sto		$x3,24[$s1]
FFFC20AC 02423023		sto		$x4,32[$s1]
FFFC20B0 02523423		sto		$x5,40[$s1]
FFFC20B4 02623823		sto		$x6,48[$s1]
FFFC20B8 02723C23		sto		$x7,56[$s1]
FFFC20BC 04823023		sto		$x8,64[$s1]
FFFC20C0 04923423		sto		$x9,72[$s1]
FFFC20C4 04A23823		sto		$x10,80[$s1]
FFFC20C8 04B23C23		sto		$x11,88[$s1]
FFFC20CC 06C23023		sto		$x12,96[$s1]
FFFC20D0 06D23423		sto		$x13,104[$s1]
FFFC20D4 06E23823		sto		$x14,112[$s1]
FFFC20D8 06F23C23		sto		$x15,120[$s1]
FFFC20DC 09023023		sto		$x16,128[$s1]
FFFC20E0 09123423		sto		$x17,136[$s1]
FFFC20E4 09223823		sto		$x18,144[$s1]
FFFC20E8 09323C23		sto		$x19,152[$s1]
FFFC20EC 0B423023		sto		$x20,160[$s1]
FFFC20F0 0B523423		sto		$x21,168[$s1]
FFFC20F4 0B623823		sto		$x22,176[$s1]
FFFC20F8 0B723C23		sto		$x23,184[$s1]
FFFC20FC 0D823023		sto		$x24,192[$s1]
FFFC2100 0D923423		sto		$x25,200[$s1]
FFFC2104 0DA23823		sto		$x26,208[$s1]
FFFC2108 0DB23C23		sto		$x27,216[$s1]
FFFC210C 0FC23023		sto		$x28,224[$s1]
FFFC2110 0FD23423		sto		$x29,232[$s1]
FFFC2114 0FE23823		sto		$x30,240[$s1]
FFFC2118 0FF23C23		sto		$x31,248[$s1]
FFFC211C 79026073		csrrs	$x0,#CSR_REGSET,#4				; select current register set for Rs2
FFFC2120 34101173		csrrw	$x2,#$341,$x0				; save off mepc
FFFC2124 28223023		sto		$x2,TCBepc[$s1]
                        		; Now save off segment registers
FFFC2128 00006D93		ldi		$t1,#0
                        	.svseg:
FFFC212C 01B00D0D		mvseg	$t0,$x0,$t1
FFFC2130 003D9113		sll		$x2,$t1,#3
FFFC2134 00410133		add		$x2,$x2,$s1
FFFC2138 21A13023		sto		$t0,TCBsegs[$x2]
FFFC213C 001D8D93		add		$t1,$t1,#1
FFFC2140 00FDFD93		and		$t1,$t1,#15
FFFC2144 FE0D94E3		bne		$t1,$x0,.svseg
FFFC2148 00106D13		ldi		$t0,#1
FFFC214C 29A20523		stb		$t0,TCBContextSaved[$s1]
                        	.xit:
FFFC2150 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	RestoreContext:
                        		; Switch memory maps
FFFC2154 00A2D813		srl		$v0,$s2,#10					; convert pointer to tid
FFFC2158 03F87813		and		$v0,$v0,#$3F				; mask to 64 task
FFFC215C 181818F3		csrrw	$v1,#$181,$v0				; set ASID
                        	
                        		; Restore segment register set
FFFC2160 00006D93		ldi		$t1,#0
                        	.rsseg:
FFFC2164 003D9113		sll		$x2,$t1,#3
FFFC2168 00510133		add		$x2,$x2,$s2
FFFC216C 20013D03		ldo		$t0,TCBsegs[$x2]
FFFC2170 01BD000D		mvseg	$x0,$t0,$t1
FFFC2174 001D8D93		add		$t1,$t1,#1
FFFC2178 00FDFD93		and		$t1,$t1,#15
FFFC217C FE0D94E3		bne		$t1,$x0,.rsseg
                        	
FFFC2180 2802B103		ldo		$x2,TCBepc[$s2]			; restore epc
FFFC2184 34111073		csrrw	$x0,#$341,$x2
                        		; Restore incoming registers
FFFC2188 7900F073		csrrc	$x0,#CSR_REGSET,#1				; select previous regset for Rd
FFFC218C 0082B083		ldo		$x1,8[$s2]
FFFC2190 0102B103		ldo		$x2,16[$s2]
FFFC2194 0182B183		ldo		$x3,24[$s2]
FFFC2198 0202B203		ldo		$x4,32[$s2]
FFFC219C 0282B283		ldo		$x5,40[$s2]
FFFC21A0 0302B303		ldo		$x6,48[$s2]
FFFC21A4 0382B383		ldo		$x7,56[$s2]
FFFC21A8 0402B403		ldo		$x8,64[$s2]
FFFC21AC 0482B483		ldo		$x9,72[$s2]
FFFC21B0 0502B503		ldo		$x10,80[$s2]
FFFC21B4 0582B583		ldo		$x11,88[$s2]
FFFC21B8 0602B603		ldo		$x12,96[$s2]
FFFC21BC 0682B683		ldo		$x13,104[$s2]
FFFC21C0 0702B703		ldo		$x14,112[$s2]
FFFC21C4 0782B783		ldo		$x15,120[$s2]
FFFC21C8 0802B803		ldo		$x16,128[$s2]
FFFC21CC 0882B883		ldo		$x17,136[$s2]
FFFC21D0 0902B903		ldo		$x18,144[$s2]
FFFC21D4 0982B983		ldo		$x19,152[$s2]
FFFC21D8 0A02BA03		ldo		$x20,160[$s2]
FFFC21DC 0A82BA83		ldo		$x21,168[$s2]
FFFC21E0 0B02BB03		ldo		$x22,176[$s2]
FFFC21E4 0B82BB83		ldo		$x23,184[$s2]
FFFC21E8 0C02BC03		ldo		$x24,192[$s2]
FFFC21EC 0C82BC83		ldo		$x25,200[$s2]
FFFC21F0 0D02BD03		ldo		$x26,208[$s2]
FFFC21F4 0D82BD83		ldo		$x27,216[$s2]
FFFC21F8 0E02BE03		ldo		$x28,224[$s2]
FFFC21FC 0E82BE83		ldo		$x29,232[$s2]
FFFC2200 0F02BF03		ldo		$x30,240[$s2]
FFFC2204 0F82BF83		ldo		$x31,248[$s2]
FFFC2208 7900E073		csrrs	$x0,#CSR_REGSET,#1				; select current regset for Rd
FFFC220C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Swap from outgoing context to incoming context.
                        	;
                        	; Parameters:
                        	;		s1 = pointer to TCB of outgoing context
                        	;		s2 = pointer to TCB of incoming context
                        	;------------------------------------------------------------------------------
                        	
                        	SwapContext:
FFFC2210 16520E63		beq		$s1,$s2,.noCtxSwitch@
FFFC2214 3000FE73		csrrc	$t2,#$300,#1							; interrupts off
FFFC2218 79001873		csrrw	$v0,#CSR_REGSET,$x0				; get register set
FFFC221C F3F87893		and		$v1,$v0,#$FFFFFF3F				; set previous to user regset
FFFC2220 79089073		csrrw	$x0,#CSR_REGSET,$v1	
FFFC2224 28A20883		ldb		$v1,TCBContextSaved[$s1]
FFFC2228 0A089863		bnez	$v1,.savedAlready
                        		; Save outgoing register set in TCB
FFFC222C 79027073		csrrc	$x0,#CSR_REGSET,#4				; select previous (user) register set for Rs2
FFFC2230 00123423		sto		$x1,8[$s1]
FFFC2234 00223823		sto		$x2,16[$s1]
FFFC2238 00323C23		sto		$x3,24[$s1]
FFFC223C 02423023		sto		$x4,32[$s1]
FFFC2240 02523423		sto		$x5,40[$s1]
FFFC2244 02623823		sto		$x6,48[$s1]
FFFC2248 02723C23		sto		$x7,56[$s1]
FFFC224C 04823023		sto		$x8,64[$s1]
FFFC2250 04923423		sto		$x9,72[$s1]
FFFC2254 04A23823		sto		$x10,80[$s1]
FFFC2258 04B23C23		sto		$x11,88[$s1]
FFFC225C 06C23023		sto		$x12,96[$s1]
FFFC2260 06D23423		sto		$x13,104[$s1]
FFFC2264 06E23823		sto		$x14,112[$s1]
FFFC2268 06F23C23		sto		$x15,120[$s1]
FFFC226C 09023023		sto		$x16,128[$s1]
FFFC2270 09123423		sto		$x17,136[$s1]
FFFC2274 09223823		sto		$x18,144[$s1]
FFFC2278 09323C23		sto		$x19,152[$s1]
FFFC227C 0B423023		sto		$x20,160[$s1]
FFFC2280 0B523423		sto		$x21,168[$s1]
FFFC2284 0B623823		sto		$x22,176[$s1]
FFFC2288 0B723C23		sto		$x23,184[$s1]
FFFC228C 0D823023		sto		$x24,192[$s1]
FFFC2290 0D923423		sto		$x25,200[$s1]
FFFC2294 0DA23823		sto		$x26,208[$s1]
FFFC2298 0DB23C23		sto		$x27,216[$s1]
FFFC229C 0FC23023		sto		$x28,224[$s1]
FFFC22A0 0FD23423		sto		$x29,232[$s1]
FFFC22A4 0FE23823		sto		$x30,240[$s1]
FFFC22A8 0FF23C23		sto		$x31,248[$s1]
FFFC22AC 79026073		csrrs	$x0,#CSR_REGSET,#4				; select current register set for Rs2
FFFC22B0 34101173		csrrw	$x2,#$341,$x0				; save off mepc
FFFC22B4 28223023		sto		$x2,TCBepc[$s1]
                        		; Now save off segment registers
FFFC22B8 00006D93		ldi		$t1,#0
                        	.svseg:
FFFC22BC 01B00D0D		mvseg	$t0,$x0,$t1
FFFC22C0 003D9113		sll		$x2,$t1,#3
FFFC22C4 00410133		add		$x2,$x2,$s1
FFFC22C8 21A13023		sto		$t0,TCBsegs[$x2]
FFFC22CC 001D8D93		add		$t1,$t1,#1
FFFC22D0 00FDFD93		and		$t1,$t1,#15
FFFC22D4 FE0D94E3		bne		$t1,$x0,.svseg
                        	
                        	.savedAlready:
                        		; Restore segment register set
FFFC22D8 00006D93		ldi		$t1,#0
                        	.rsseg:
FFFC22DC 003D9113		sll		$x2,$t1,#3
FFFC22E0 00510133		add		$x2,$x2,$s2
FFFC22E4 20013D03		ldo		$t0,TCBsegs[$x2]
FFFC22E8 01BD000D		mvseg	$x0,$t0,$t1
FFFC22EC 001D8D93		add		$t1,$t1,#1
FFFC22F0 00FDFD93		and		$t1,$t1,#15
FFFC22F4 FE0D94E3		bne		$t1,$x0,.rsseg
                        	
FFFC22F8 2802B103		ldo		$x2,TCBepc[$s2]			; restore epc
FFFC22FC 34111073		csrrw	$x0,#$341,$x2
                        		; Restore incoming registers
FFFC2300 7900F073		csrrc	$x0,#CSR_REGSET,#1				; select previous regset for Rd
FFFC2304 0082B083		ldo		$x1,8[$s2]
FFFC2308 0102B103		ldo		$x2,16[$s2]
FFFC230C 0182B183		ldo		$x3,24[$s2]
FFFC2310 0202B203		ldo		$x4,32[$s2]
FFFC2314 0282B283		ldo		$x5,40[$s2]
FFFC2318 0302B303		ldo		$x6,48[$s2]
FFFC231C 0382B383		ldo		$x7,56[$s2]
FFFC2320 0402B403		ldo		$x8,64[$s2]
FFFC2324 0482B483		ldo		$x9,72[$s2]
FFFC2328 0502B503		ldo		$x10,80[$s2]
FFFC232C 0582B583		ldo		$x11,88[$s2]
FFFC2330 0602B603		ldo		$x12,96[$s2]
FFFC2334 0682B683		ldo		$x13,104[$s2]
FFFC2338 0702B703		ldo		$x14,112[$s2]
FFFC233C 0782B783		ldo		$x15,120[$s2]
FFFC2340 0802B803		ldo		$x16,128[$s2]
FFFC2344 0882B883		ldo		$x17,136[$s2]
FFFC2348 0902B903		ldo		$x18,144[$s2]
FFFC234C 0982B983		ldo		$x19,152[$s2]
FFFC2350 0A02BA03		ldo		$x20,160[$s2]
FFFC2354 0A82BA83		ldo		$x21,168[$s2]
FFFC2358 0B02BB03		ldo		$x22,176[$s2]
FFFC235C 0B82BB83		ldo		$x23,184[$s2]
FFFC2360 0C02BC03		ldo		$x24,192[$s2]
FFFC2364 0C82BC83		ldo		$x25,200[$s2]
FFFC2368 0D02BD03		ldo		$x26,208[$s2]
FFFC236C 0D82BD83		ldo		$x27,216[$s2]
FFFC2370 0E02BE03		ldo		$x28,224[$s2]
FFFC2374 0E82BE83		ldo		$x29,232[$s2]
FFFC2378 0F02BF03		ldo		$x30,240[$s2]
FFFC237C 0F82BF83		ldo		$x31,248[$s2]
FFFC2380 28028523		stb		$x0,TCBContextSaved[$s2]
FFFC2384 79081073		csrrw	$x0,#CSR_REGSET,$v0				; restore register set selections
FFFC2388 300E1073		csrrw	$x0,#$300,$t2							; restore interrupts
                        	.noCtxSwitch:
FFFC238C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Operating system call dispatcher.
                        	;------------------------------------------------------------------------------
                        	
                        	OSCALL:
FFFC2390 10300073		pfi													; check for interrupt
FFFC2394 79017073		csrrc	$x0,#CSR_REGSET,#2		; select previous regs for Rs1		
FFFC2398 00096933		mov		$a0,$a0								; move previous to current
FFFC239C 0009E9B3		mov		$a1,$a1
FFFC23A0 000A6A33		mov		$a2,$a2
FFFC23A4 000AEAB3		mov		$a3,$a3
FFFC23A8 000B6B33		mov		$a4,$a4
FFFC23AC 000BEBB3		mov		$a5,$a5
FFFC23B0 79016073		csrrs	$x0,#CSR_REGSET,#2		; get back current registers for all
FFFC23B4 40006D13		ldi		$t0,#1024
FFFC23B8 03A96C63		bltu	$a0,$t0,.oscall
FFFC23BC 01F97913		and		$a0,$a0,#31
FFFC23C0 00191913		sll		$a0,$a0,#1
FFFC23C4 FFFC1637		lhu		$t0,BIOSCallTbl[$a0]
FFFC23C8 E6860613
FFFC23CC 01260633
FFFC23D0 00065D03
FFFC23D4 060D0263		beqz	$t0,.zero
FFFC23D8 FFFC0637		or		$t0,$t0,#$FFFC0000
FFFC23DC 00060613
FFFC23E0 01A66D33
FFFC23E4 10300073		pfi
FFFC23E8 000D00E7		call	[$t0]									; call the BIOS Function
FFFC23EC 02000A63		bra		.xit
                        	.oscall:
FFFC23F0 01F97913		and		$a0,$a0,#31
FFFC23F4 04090263		beqz	$a0,.zero
FFFC23F8 00191913		sll		$a0,$a0,#1
FFFC23FC FFFC2637		lhu		$t0,OSCallTbl[$a0]
FFFC2400 E4C60613
FFFC2404 01260633
FFFC2408 00065D03
FFFC240C 020D0663		beqz	$t0,.zero
FFFC2410 FFFC0637		or		$t0,$t0,#$FFFC0000
FFFC2414 00060613
FFFC2418 01A66D33
FFFC241C 000D00E7		call	[$t0]									; call the OS Function
                        	.xit:
FFFC2420 10300073		pfi
FFFC2424 7900F073		csrrc	$x0,#CSR_REGSET,#1		; select previous regs for Rd
FFFC2428 00086833		mov		$v0,$v0
FFFC242C 0008E8B3		mov		$v1,$v1
FFFC2430 7900E073		csrrs	$x0,#CSR_REGSET,#1		; select current regs for Rd
FFFC2434 10000073		eret
                        	.zero:
FFFC2438 01A06813		ldi		$v0,#E_BadCallno
FFFC243C FE0002E3		bra		.xit
                        	
                        	;------------------------------------------------------------------------------
                        	; Sleep for a number of ticks. Tick interval determined by the VIA timer #3.
                        	; Passing a time of zero or less causes the function to return right away.
                        	;
                        	; Parameters:
                        	;		a1 = length of time to sleep (must be >= 0)
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_Sleep:
FFFC2440 FF870713		sub		$sp,$sp,#8
FFFC2444 00173023		sto		$ra,[$sp]
FFFC2448 1409C263		bltz	$a1,.xit
                        		
FFFC244C 18101873		csrrw	v0,#$181,x0
FFFC2450 03F87813		and		v0,v0,#MAX_TID
FFFC2454 000864B3	mov		$s6,$v0
FFFC2458 00A81213		sll		$s1,$v0,#LOG_TCBSZ
                        		; Lock system mutex
FFFC245C 00181D13		sll		$t0,$v0,#1
FFFC2460 001D6D13		or		$t0,$t0,#1
                        	.lock:
FFFC2464 10300073		pfi
FFFC2468 FFDC0637		sto		$t0,SYS_MUTEX
FFFC246C F0060613
FFFC2470 00060633
FFFC2474 01A63023
FFFC2478 FFDC0637		ldo		$t2,SYS_MUTEX
FFFC247C F0060613
FFFC2480 00060633
FFFC2484 00063E03
FFFC2488 FDCD1EE3		bne		$t0,$t2,.lock
                        	
FFFC248C 10300073		pfi
                        		; First thing: set end time. We don't want to include time spent in the OS in
                        		; the time accounting, so we set the end time as soon as possible.
FFFC2490 70101E73		csrrw	$t2,#$701,$x0					; get time
FFFC2494 2BC23C23		sto		$t2,TCBEndTime[$s1]
FFFC2498 00098A63		beqz	$a1,.0001
FFFC249C 00086933		mov		$a0,$v0								; a0 = current tid
FFFC24A0 10300073		pfi
FFFC24A4 3C1000EF		call	RemoveFromReadyList
FFFC24A8 475000EF		call	InsertIntoTimeoutList	; a1 = timeout
                        	.0001:
FFFC24AC 28824803		ldbu	$v0,TCBStatus[$s1]		; flag task as no longer running
FFFC24B0 F7F87813		and		$v0,$v0,#~TS_RUNNING
FFFC24B4 29020423		stb		$v0,TCBStatus[$s1]
                        	
                        		;	AccountTime
FFFC24B8 10300073		pfi
FFFC24BC 2B823E03		ldo		$t2,TCBEndTime[$s1]		; get back end time
FFFC24C0 2B023E83		ldo		$t3,TCBStartTime[$s1]
FFFC24C4 41DE0F33		sub		$t4,$t2,$t3						; end - start
FFFC24C8 2C023F83		ldo		$t5,TCBElapsedTime[$s1]
FFFC24CC 01EF8FB3		add		$t5,$t5,$t4						; ticks + (end - start)
FFFC24D0 2DF23023		sto		$t5,TCBElapsedTime[$s1]
                        		; Will switch to target memory map.
FFFC24D4 10300073		pfi
FFFC24D8 B3DFF0EF		call	SelectTaskToRun
                        	
FFFC24DC 00A81293		sll		$s2,$v0,#LOG_TCBSZ		; s2 = pointer to incoming TCB
FFFC24E0 2882C103		ldbu	$x2,TCBStatus[$s2]		; x2 = incoming status
FFFC24E4 08116E13		or		$t2,$x2,#TS_RUNNING|TS_READY	; set status = running
FFFC24E8 2C82A103		ldt		$x2,TCBException[$s2]	;
FFFC24EC 00010C63		beqz	$x2,.noException
FFFC24F0 10300073		pfi
                        		; set link register to catch handler address
                        		;{
                        		;	t->regs[29] = t->regs[28];   // set link register to catch handler
                        		;	t->epc = t->regs[28];        // and the PC register
                        		;	t->regs[1] = t->exception;    // r1 = exception value
                        		;	t->exception = 0;
                        		;	t->regs[2] = 45;              // r2 = exception type
                        		;}
FFFC24F4 0022B423		sto		$x2,8[$s2]						; r1 = exception
FFFC24F8 2C02A423		stt		$x0,TCBException[$s2]	; tcb->exception = 0
FFFC24FC 02D06113		ldi		$x2,#45
FFFC2500 0022B823		sto		$x2,16[$s2]						; r2 = 45
                        	.noException:
FFFC2504 10300073		pfi
                        	
                        		; If a message is ready, update status to ready and put
                        		; message in target memory. The task will be returning
                        		; from a WaitMsg so a return status of E_Ok is also set.
FFFC2508 004E7113		and		$x2,$t2,#TS_MSGRDY
FFFC250C 06010463		beqz	$x2,.noMsg
FFFC2510 00010D37		ldi		$t0,#$10000						; mprv bit
FFFC2514 000D0D13
FFFC2518 0A02B903		ldo		$a0,160[$s2]					; user a2 (x20)
FFFC251C 00090A63		beqz	$a0,.0002
FFFC2520 2982B103		ldo		$x2,TCBMsgD1[$s2]
FFFC2524 300D2073		csrrs	$x0,#$300,$t0					; set mprv
FFFC2528 00293023		sto		$x2,[$a0]							; store to user space
FFFC252C 300D3073		csrrc	$x0,#$300,$t0					; clear mprv
                        	.0002:
FFFC2530 10300073		pfi
FFFC2534 0A82B903		ldo		$a0,168[$s2]
FFFC2538 00090A63		beqz	$a0,.0003
FFFC253C 2A02B103		ldo		$x2,TCBMsgD2[$s2]
FFFC2540 300D2073		csrrs	$x0,#$300,$t0					; set mprv
FFFC2544 00293023		sto		$x2,[$a0]
FFFC2548 300D3073		csrrc	$x0,#$300,$t0					; set mprv
                        	.0003:
FFFC254C 10300073		pfi
FFFC2550 0B02B903		ldo		$a0,176[$s2]
FFFC2554 00090A63		beqz	$a0,.0004
FFFC2558 2A82B103		ldo		$x2,TCBMsgD3[$s2]
FFFC255C 300D2073		csrrs	$x0,#$300,$t0					; set mprv
FFFC2560 00293023		sto		$x2,[$a0]
FFFC2564 300D3073		csrrc	$x0,#$300,$t0					; set mprv
                        	.0004:
FFFC2568 10300073		pfi
FFFC256C 00006113		ldi		$x2,#E_Ok						; setup to return E_Ok
FFFC2570 0822B023		sto		$x2,128[$s2]					; in v0
                        	
                        	.noMsg:
FFFC2574 FFBE7E13		and		$t2,$t2,#~TS_MSGRDY		; mask out message ready status
FFFC2578 29C28423		stb		$t2,TCBStatus[$s2]
                        	
FFFC257C 10300073		pfi
FFFC2580 C91FF0EF		call	SwapContext
                        	
                        		; As above, we want to minimize the impact of the OS on the tasks scheduled
                        		; time. So we set the start time as late as possible.
FFFC2584 70101E73		csrrw	$t2,#$701,$x0					; get time
FFFC2588 2BC23823		sto		$t2,TCBStartTime[$s1]
                        	.xit:
                        		; unlock system mutex
FFFC258C 00149D13		sll		$t0,$s6,#1
FFFC2590 FFDC0637		sto		$t0,SYS_MUTEX
FFFC2594 F0060613
FFFC2598 00060633
FFFC259C 01A63023
FFFC25A0 00073083		ldo		$ra,[$sp]
FFFC25A4 00870713		add		$sp,$sp,#8
FFFC25A8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SchedulerIRQ meant to be called from the timer ISR.
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_SchedulerIRQ:
                        		
FFFC25AC 18101873		csrrw	v0,#$181,x0
FFFC25B0 03F87813		and		v0,v0,#MAX_TID
FFFC25B4 000864B3	mov		$s6,$v0
FFFC25B8 00A81213		sll		$s1,$v0,#LOG_TCBSZ		; compute pointer to TCB
                        		; Lock system mutex
FFFC25BC 00181D13		sll		$t0,$v0,#1
FFFC25C0 001D6D13		or		$t0,$t0,#1
FFFC25C4 FFDC0637		sto		$t0,SYS_MUTEX
FFFC25C8 F0060613
FFFC25CC 00060633
FFFC25D0 01A63023
FFFC25D4 FFDC0637		ldo		$v1,SYS_MUTEX
FFFC25D8 F0060613
FFFC25DC 00060633
FFFC25E0 00063883
FFFC25E4 191D1463		bne		$t0,$v1,.noLock
                        	
FFFC25E8 70101E73		csrrw	$t2,#$701,$x0					; get time
FFFC25EC 2BC23C23		sto		$t2,TCBEndTime[$s1]
FFFC25F0 1600000D		decto												; decrement timeouts (takes 64 clock cycles async)
FFFC25F4 FF870713		sub		$sp,$sp,#8
FFFC25F8 00173023		sto		$ra,[$sp]
                        	; Might need the following if the external timer isn't used.
                        	;	csrrw	$v0,#$701,$x0					; get the time
                        	;	add		$v0,$v0,#300000				; wait 300,000 cycles @40MHz (30ms)
                        	;	csrrw	$x0,#$321,$v0					; set next interrupt time
                        		;	AccountTime
FFFC25FC 2B023E83		ldo		$t3,TCBStartTime[$s1]
FFFC2600 41DE0F33		sub		$t4,$t2,$t3						; end - start
FFFC2604 2C023F83		ldo		$t5,TCBElapsedTime[$s1]
FFFC2608 01EF8FB3		add		$t5,$t5,$t4						; ticks + (end - start)
FFFC260C 2DF23023		sto		$t5,TCBElapsedTime[$s1]
                        	
FFFC2610 28824F83		ldbu	$t5,TCBStatus[$s1]
FFFC2614 020FEF93		or		$t5,$t5,#TS_PREEMPT
FFFC2618 F7FFFF93		and		$t5,$t5,#~TS_RUNNING	; no longer running, but may still be ready
FFFC261C 29F20423		stb		$t5,TCBStatus[$s1]
                        		; Keep popping the timeout list as long as there are tasks on it with
                        		; expired timeouts.
FFFC2620 00006913		ldi		$a0,#0
FFFC2624 1400038D		getzl	$s4		; Get list of tasks whose timeout is zero
                        	.0001:
FFFC2628 00A91F13		sll		$t4,$a0,#10
FFFC262C 288F4E03		lbu		$t2,TCBStatus[$t4]
FFFC2630 010E7E13		and		$t2,$t2,#TS_TIMEOUT
FFFC2634 020E0063		beqz	$t2,.noTimeout
FFFC2638 0013FE13		and		$t2,$s4,#1					; is zero bit set?
FFFC263C 000E0C63		beqz	$t2,.notZero
FFFC2640 288F4E03		lbu		$t2,TCBStatus[$t4]
FFFC2644 FE7E7E13		and		$t2,$t2,#~(TS_TIMEOUT|TS_WAITMSG)
	sb		$t2,TCBStatus[$t4]
FFFC2648 29CF0423
FFFC264C 3DC000EF		call	MbxRemoveTask
FFFC2650 171000EF		call	InsertIntoReadyList
                        	.notZero:
                        	.noTimeout:
FFFC2654 00190913		add		$a0,$a0,#1
FFFC2658 0013D393		srl		$s4,$s4,#1	
FFFC265C FC0396E3		bnez	$s4,.0001
                        	
                        		; The ready list was just updated, there could be new tasks
                        		; ready to run. Will switch to target memory map.
                        	.searchQ:
FFFC2660 00024637		ldbu	$v1,QNDX						; get index into que check table
FFFC2664 30460613
FFFC2668 00060633
FFFC266C 00064883
FFFC2670 00188893		add		$v1,$v1,#1					; increment it, and limit
FFFC2674 01F8F893		and		$v1,$v1,#31
FFFC2678 00024637		stb		$v1,QNDX						; store back
FFFC267C 30460613
FFFC2680 00060633
FFFC2684 01160023
FFFC2688 FFFC2637		ldbu	$v1,qToChk[$v1]			; assume this will be valid
FFFC268C E8260613
FFFC2690 01160633
FFFC2694 00064883
FFFC2698 00406E13		ldi		$t2,#4							; 4 queues to check
                        	.nxtQ:
FFFC269C 1C08880D		getrdy	$v0,$v1
;	ldw		$v0,READYQ[$v1]			; check queue to see if contains any
FFFC26A0 00085E63		bge		$v0,$x0,.dq					; yes, go dequeue
FFFC26A4 00188893		add		$v1,$v1,#1					; no, advance to next queue
FFFC26A8 0038F893		and		$v1,$v1,#3					; 4 max
FFFC26AC FFFE0E13		sub		$t2,$t2,#1					;
FFFC26B0 FFC046E3		bgt		$t2,$x0,.nxtQ				; go back to check next queue
                        		; Here, nothing else is actually ready to run
                        		; just go back to what we were doing.
                        		
FFFC26B4 18101873		csrrw	v0,#$181,x0
FFFC26B8 03F87813		and		v0,v0,#MAX_TID
                        	.dq:
                        	.goodTid:
FFFC26BC 18181073		csrrw	$x0,#$181,$v0
                        	
FFFC26C0 00A81293		sll		$s2,$v0,#LOG_TCBSZ	; s2 = pointer to incoming TCB
FFFC26C4 2882C103		lbu		$x2,TCBStatus[$s2]	; x2 = incoming status
FFFC26C8 08116E13		or		$t2,$x2,#TS_RUNNING|TS_READY	; status = running
FFFC26CC 2C82B103		ldo		$x2,TCBException[$s2]	;
FFFC26D0 00010263		beqz	$x2,.noException
                        		; set link register to catch handler address
                        		;{
                        		;	t->regs[29] = t->regs[28];   // set link register to catch handler
                        		;	t->epc = t->regs[28];        // and the PC register
                        		;	t->regs[1] = t->exception;    // r1 = exception value
                        		;	t->exception = 0;
                        		;	t->regs[2] = 45;              // r2 = exception type
                        		;}
                        	.noException:
                        	
                        		; If a message is ready, update status to ready and put
                        		; message in target memory. The task will be returning
                        		; from a WaitMsg so a return status of E_Ok is also set.
FFFC26D4 06000263		bra		.noMsg
FFFC26D8 004E7113		and		$x2,$t2,#TS_MSGRDY
FFFC26DC 04010E63		beq		$x2,$x0,.noMsg
FFFC26E0 00010D37		ldi		$t0,#$10000						; mprv bit
FFFC26E4 000D0D13
FFFC26E8 0A02B903		ldo		$a0,160[$s2]					; user a2 (x20)
FFFC26EC 00090A63		beq		$a0,$x0,.0002
FFFC26F0 2982B103		ldo		$x2,TCBMsgD1[$s2]
FFFC26F4 300D2073		csrrs	$x0,#$300,$t0					; set mprv
FFFC26F8 00293023		sto		$x2,[$a0]
FFFC26FC 300D3073		csrrc	$x0,#$300,$t0					; set mprv
                        	.0002:
FFFC2700 0A82B903		ldo		$a0,168[$s2]
FFFC2704 00090A63		beq		$a0,$x0,.0003
FFFC2708 2A02B103		ldo		$x2,TCBMsgD2[$s2]
FFFC270C 300D2073		csrrs	$x0,#$300,$t0					; set mprv
FFFC2710 00293023		sto		$x2,[$a0]
FFFC2714 300D3073		csrrc	$x0,#$300,$t0					; set mprv
                        	.0003:
FFFC2718 0B02B903		ldo		$a0,176[$s2]
FFFC271C 00090A63		beq		$a0,$x0,.0004
FFFC2720 2A82B103		ldo		$x2,TCBMsgD3[$s2]
FFFC2724 300D2073		csrrs	$x0,#$300,$t0					; set mprv
FFFC2728 00293023		sto		$x2,[$a0]
FFFC272C 300D3073		csrrc	$x0,#$300,$t0					; set mprv
                        	.0004:
FFFC2730 00006113		ldi		$x2,#E_Ok						; setup to return E_Ok
FFFC2734 0822B023		sto		$x2,128[$s2]				; in v0
                        	
                        	.noMsg:
FFFC2738 FFBE7E13		and		$t2,$t2,#~TS_MSGRDY		; mask out message ready status
FFFC273C 29C28423		stb		$t2,TCBStatus[$s2]
                        	
FFFC2740 AD1FF0EF		call	SwapContext
FFFC2744 00073083		ldo		$ra,[$sp]
FFFC2748 00870713		add		$sp,$sp,#8
FFFC274C 70101E73		csrrw	$t2,#$701,$x0					; get time
FFFC2750 2BC2B823		sto		$t2,TCBStartTime[$s2]
                        		; Unlock system mutex
FFFC2754 00149E13		sll		$t2,$s6,#1
FFFC2758 FFDC0637		sto		$t2,SYS_MUTEX
FFFC275C F0060613
FFFC2760 00060633
FFFC2764 01C63023
FFFC2768 00008067		ret
                        	.noLock:
FFFC276C 70101E73		csrrw	$t2,#$701,$x0					; get time
FFFC2770 2BC23823		sto		$t2,TCBStartTime[$s1]
FFFC2774 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Start a task.
                        	;	Task status is set to ready, priority normal, and the task is inserted into
                        	; the ready list. Segment registers are setup for a flat memory model.
                        	; 
                        	;	Parameters:
                        	;		a1 = memory required
                        	;		a2 = start pc (usually $100)
                        	;	Modifies:
                        	;		a0 = mid
                        	;	Returns:
                        	;		v0 = E_Ok if successful
                        	;		v1 = tid of started task if successful
                        	;------------------------------------------------------------------------------
                        	;
                        	FMTK_StartTask:
FFFC2778 FF070713		sub		$sp,$sp,#16
FFFC277C 00173023		sto		$ra,[$sp]
FFFC2780 10300073		pfi
                        		
FFFC2784 18101873		csrrw	v0,#$181,x0
FFFC2788 03F87813		and		v0,v0,#MAX_TID
FFFC278C 000864B3	mov		$s6,$v0						; save tid in s6
                        		; Lock system mutex
FFFC2790 00181813		sll		$v0,$v0,#1
FFFC2794 00186813		or		$v0,$v0,#1
                        	.lock:
FFFC2798 10300073		pfi
FFFC279C FFDC0637		sto		$v0,SYS_MUTEX
FFFC27A0 F0060613
FFFC27A4 00060633
FFFC27A8 01063023
FFFC27AC FFDC0637		ldo		$v1,SYS_MUTEX
FFFC27B0 F0060613
FFFC27B4 00060633
FFFC27B8 00063883
FFFC27BC FD181EE3		bne		$v0,$v1,.lock
                        	
FFFC27C0 01003023		sto		$v0,
	call	AllocTCB
FFFC27C4 2DD000EF
FFFC27C8 00004637		stb		$v1,$4321
FFFC27CC 32160613
FFFC27D0 00060633
FFFC27D4 01160023
FFFC27D8 12081263		bnez	$v0,.err
FFFC27DC 0008E933		mov		$a0,$v1
FFFC27E0 10300073		pfi
FFFC27E4 925FE0EF		call	FreeAll
FFFC27E8 10300073		pfi
FFFC27EC 809FF0EF		call	MapOSPages			; Map OS pages into address space
FFFC27F0 00A91213		sll		$s1,$a0,#LOG_TCBSZ	; compute TCB address
FFFC27F4 10300073		pfi
FFFC27F8 8BDFE0EF		call	AllocStack
FFFC27FC 00096333		mov		$s3,$a0
FFFC2800 0008E933		mov		$a0,$v1
FFFC2804 10300073		pfi
FFFC2808 F69FD0EF		call	PutHexHalf
FFFC280C 00036933		mov		$a0,$s3
FFFC2810 A0010637		add		$t0,$v1,#$A000FFFC	; set stack pointer
FFFC2814 FFC60613
FFFC2818 01160D33
FFFC281C 07A23823		sto		$t0,112[$s1]
FFFC2820 29423023		sto		$a2,TCBepc[$s1]	; address task will begin at
FFFC2824 10300073		pfi
FFFC2828 FD0FE0EF		call	Alloc
FFFC282C 00004637		stb		$v0,$4320
FFFC2830 32060613
FFFC2834 00060633
FFFC2838 01060023
FFFC283C 0C081063		bnez	$v0,.err
FFFC2840 00106D13		ldi		$t0,#TS_READY
FFFC2844 29A20423		stb		$t0,TCBStatus[$s1]
FFFC2848 00206D13		ldi		$t0,#2					; normal execution priority
FFFC284C 29A204A3		stb		$t0,TCBPriority[$s1]
                        		; leave segment base at $0, flat memory model
FFFC2850 10300073		pfi
FFFC2854 00606D13		ldi		$t0,#6							; read,write
FFFC2858 21A23023		sto		$t0,TCBsegs[$s1]			; segs 0 to 11
FFFC285C 21A23423		sto		$t0,TCBsegs+8[$s1]
FFFC2860 21A23823		sto		$t0,TCBsegs+16[$s1]
FFFC2864 21A23C23		sto		$t0,TCBsegs+24[$s1]
FFFC2868 23A23023		sto		$t0,TCBsegs+32[$s1]
FFFC286C 23A23423		sto		$t0,TCBsegs+40[$s1]
FFFC2870 10300073		pfi
FFFC2874 23A23823		sto		$t0,TCBsegs+48[$s1]
FFFC2878 23A23C23		sto		$t0,TCBsegs+56[$s1]
FFFC287C 25A23023		sto		$t0,TCBsegs+64[$s1]
FFFC2880 25A23423		sto		$t0,TCBsegs+72[$s1]
FFFC2884 25A23823		sto		$t0,TCBsegs+80[$s1]
FFFC2888 25A23C23		sto		$t0,TCBsegs+88[$s1]
FFFC288C 10300073		pfi
FFFC2890 00506D13		ldi		$t0,#5							; read,execute
FFFC2894 27A23023		sto		$t0,TCBsegs+96[$s1]	; segs 12 to 15
FFFC2898 27A23423		sto		$t0,TCBsegs+104[$s1]
FFFC289C 27A23823		sto		$t0,TCBsegs+112[$s1]
FFFC28A0 27A23C23		sto		$t0,TCBsegs+120[$s1]
FFFC28A4 00106993		ldi		$a1,#1
FFFC28A8 10300073		pfi
FFFC28AC F4CFE0EF		call	Alloc
FFFC28B0 33123823		sto		$v1,TCBVideoMem[$s1]
FFFC28B4 FFD00D37		ldi		$t0,#$FFD00000
FFFC28B8 000D0D13
FFFC28BC 33A23C23		sto		$t0,TCBpVideo[$s1]
FFFC28C0 00A25913		srl		$a0,$s1,#LOG_TCBSZ	; need the tid again
FFFC28C4 3000F073		csrrc	$x0,#$300,#1				; disable ints
FFFC28C8 10300073		pfi
FFFC28CC 6F4000EF		call	InsertIntoReadyList
FFFC28D0 000968B3		mov		$v1,$a0
FFFC28D4 10300073		pfi
                        		; Unlock mutex
FFFC28D8 00149D13		sll		$t0,$s6,#1
FFFC28DC FFDC0637		sto		$t0,SYS_MUTEX
FFFC28E0 F0060613
FFFC28E4 00060633
FFFC28E8 01A63023
FFFC28EC F75FD0EF		call	DumpMemmap
                        	.xit:
FFFC28F0 00073083		ldo		$ra,[$sp]
FFFC28F4 01070713		add		$sp,$sp,#16
FFFC28F8 00008067		ret
                        	.err:
FFFC28FC 00000013		nop
FFFC2900 00000013		nop
FFFC2904 FE000CE3		bra		.err
                        	
                        	;------------------------------------------------------------------------------
                        	; Exit the current task.
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		a1 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_ExitTask:
FFFC2908 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC290C FF870713		sub		$sp,$sp,#8
FFFC2910 00173023		sto		$ra,[$sp]
                        		
FFFC2914 18101873		csrrw	v0,#$181,x0
FFFC2918 03F87813		and		v0,v0,#MAX_TID
FFFC291C 000869B3	mov		a1,v0
FFFC2920 00000637		call	KillTask
FFFC2924 20C600E7
                        	.xit:
FFFC2928 00073083		ldo		$ra,[$sp]
FFFC292C 00870713		add		$sp,$sp,#8
FFFC2930 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = tid of task to kill
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_KillTask:
FFFC2934 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC2938 FF870713		sub		$sp,$sp,#8
FFFC293C 00173023		sto		$ra,[$sp]
FFFC2940 0A098263		beqz	$a1,.immortal		; tid #0 is immortal (the system)
                        	
                        		; Lock system mutex
                        		
FFFC2944 18101873		csrrw	v0,#$181,x0
FFFC2948 03F87813		and		v0,v0,#MAX_TID
FFFC294C 000864B3	mov		$s6,$v0
FFFC2950 00181813		sll		$v0,$v0,#1
FFFC2954 00186813		or		$v0,$v0,#1
                        	.lock:
FFFC2958 10300073		pfi
FFFC295C FFDC0637		sto		$v0,SYS_MUTEX
FFFC2960 F0060613
FFFC2964 00060633
FFFC2968 01063023
FFFC296C FFDC0637		ldo		$v1,SYS_MUTEX
FFFC2970 F0060613
FFFC2974 00060633
FFFC2978 00063883
FFFC297C FD181EE3		bne		$v0,$v1,.lock
                        	
FFFC2980 00206D13		ldi		$t0,#TS_DEAD				; flag task as dead (prevents it from being re-queued)
FFFC2984 03F9FD93		and		$t1,$a1,#MAX_TID		; limit tid
FFFC2988 00AD9D93		sll		$t1,$t1,#LOG_TCBSZ	; convert to TCB address
FFFC298C 29AD8423		stb		$t0,TCBStatus[$t1]
FFFC2990 0009E933		mov		$a0,$a1								; a0 = pid
FFFC2994 3000F073		csrrc	$x0,#$300,#1				; disable ints
FFFC2998 6CC000EF		call	RemoveFromReadyList
FFFC299C F6CFE0EF		call	FreeAll							; free all the memory associated with the task
                        		; Now make process ID available for reuse
FFFC29A0 00024637		ldo		$t1,PIDMAP
FFFC29A4 31060613
FFFC29A8 00060633
FFFC29AC 00063D83
FFFC29B0 00106D13		ldi		$t0,#1							; generate bit "off" mask
FFFC29B4 013D1D33		sll		$t0,$t0,$a1
FFFC29B8 FFFD4D13		xor		$t0,$t0,#-1					; complment for inverted mask
FFFC29BC 01ADFDB3		and		$t1,$t1,$t0
FFFC29C0 00024637		sto		$t1,PIDMAP
FFFC29C4 31060613
FFFC29C8 00060633
FFFC29CC 01B63023
                        		; Unlock system mutex
FFFC29D0 00149D93		sll		$t1,$s6,#1
FFFC29D4 FFDC0637		sto		$t1,SYS_MUTEX
FFFC29D8 F0060613
FFFC29DC 00060633
FFFC29E0 01B63023
                        	.immortal:
FFFC29E4 00006813		ldi		$v0,#E_Ok
FFFC29E8 00073083		ldo		$ra,[$sp]
FFFC29EC 00870713		add		$sp,$sp,#8
FFFC29F0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_AllocVideoBuf:
                        		
FFFC29F4 18101873		csrrw	v0,#$181,x0
FFFC29F8 03F87813		and		v0,v0,#MAX_TID
FFFC29FC 00086933	mov		$a0,$v0
FFFC2A00 00106993		ldi		$a1,#1			; request 1 byte to get 1 page (64kB)
FFFC2A04 DF4FE0EF		call	Alloc
FFFC2A08 00081E63		bnez	$v0,.err
FFFC2A0C 00A91213		sll		$s1,$a0,#LOG_TCBSZ
FFFC2A10 00000637		sto		$v1,TCBVidMem[$s1]
FFFC2A14 21260613
FFFC2A18 00460633
FFFC2A1C 01163023
FFFC2A20 33123C23		sto		$v1,TCBpVideo[$s1]
                        	.err:
FFFC2A24 00008067		ret
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/msg.r5a",1
                        	.file "../fmtk/msg.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	MBX_OWNER			equ		0		; tid of owning task
                        	MBX_WTIDS			equ		8		; tasks waiting at mailbox
                        	MBX_MQHEAD		equ		16		
                        	MBX_MQTAIL		equ		24
                        	MBX_SIZE			equ		32
                        	LOG_MBXSZ			equ		5
                        	
                        	MSG_LINK	equ		0
                        	MSG_D1		equ		8
                        	MSG_D2		equ		16
                        	MSG_D3		equ		24
                        	MSG_SIZE	equ		32
                        	LOG_MSGSZ	equ		5
                        	
                        	;	bss
                        	;	align 4
                        	;FreeMsg	dw	0
                        	;msgs:
                        	;	fill.b	MSG_SIZE*1024,0
                        	;mbxs:
                        	;	fill.b	MBX_SIZE*32,0
                        	;mbxs_end:
                        	
                        	.file "../fmtk/msg.r5a",48
                        		code
                        		align	4                        	
                        	
                        	;------------------------------------------------------------------------------
                        	; Remove the task from the list of tasks waiting at the mailbox.
                        	; This routine is only called from a couple of places and it is convenient
                        	; not to stack the return address. So, it is implemented as a macro.
                        	;
                        	; Parameters:
                        	;		a0 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	MbxRemoveTask:
FFFC2A28 FE070713		sub		$sp,$sp,#32
FFFC2A2C 00473023		sto		$s1,[$sp]
FFFC2A30 01A73423		sto		$t0,8[$sp]
FFFC2A34 01B73823		sto		$t1,16[$sp]
FFFC2A38 01C73C23		sto		$t2,24[$sp]
FFFC2A3C 10300073		pfi
FFFC2A40 00A91213		sll		$s1,$a0,#LOG_TCBSZ		; tid to pointer
FFFC2A44 28C21D03		ldw		$t0,TCBWaitMbx[$s1]		; get mailbox handle
FFFC2A48 020D4863		blt		$t0,$x0,.xit					; handle good?
FFFC2A4C 005D1D13		sll		$t0,$t0,#LOG_MBXSZ		; convert to pointer
FFFC2A50 00020637		add		$t0,$t0,#mbxs					; by adding base address
FFFC2A54 00060613
FFFC2A58 01A60D33
FFFC2A5C 10300073		pfi
FFFC2A60 008D3D83		ldo		$t1,MBX_WTIDS[$t0]		; get waiting task list
FFFC2A64 00106E13		ldi		$t2,#1								; create a mask for given task id
FFFC2A68 012E1E33		sll		$t2,$t2,$a0
FFFC2A6C FFFE4E13		xor		$t2,$t2,#-1
FFFC2A70 01CDFDB3		and		$t1,$t1,$t2						; clear bit
FFFC2A74 01BD3423		sto		$t1,MBX_WTIDS[$t0]		; update waiting task list
                        	.xit:
FFFC2A78 10300073		pfi
FFFC2A7C 00073203		ldo		$s1,[$sp]
FFFC2A80 00873D03		ldo		$t0,8[$sp]
FFFC2A84 01073D83		ldo		$t1,16[$sp]
FFFC2A88 01873E03		ldo		$t2,24[$sp]
FFFC2A8C 02070713		add		$sp,$sp,#32
FFFC2A90 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Allocate a mailbox.
                        	;
                        	; Parameters:
                        	;		a1 = task id of owner
                        	;		a2 = pointer where to store handle
                        	; Returns:
                        	;		v0 = E_Ok
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_AllocMbx:
FFFC2A94 FF870713		sub		$sp,$sp,#8
FFFC2A98 00173023		sto		$ra,[$sp]
FFFC2A9C 0A0A0063		beq		$a2,$x0,.badArg
FFFC2AA0 00020D37		ldi		$t0,#mbxs
FFFC2AA4 000D0D13
                        		; Lock system mutex
                        		
FFFC2AA8 18101873		csrrw	v0,#$181,x0
FFFC2AAC 03F87813		and		v0,v0,#MAX_TID
FFFC2AB0 000864B3	mov		$s6,$v0
FFFC2AB4 00181813		sll		$v0,$v0,#1
FFFC2AB8 00186813		or		$v0,$v0,#1
                        	.lock:
FFFC2ABC 10300073		pfi
FFFC2AC0 FFDC0637		sto		$v0,SYS_MUTEX
FFFC2AC4 F0060613
FFFC2AC8 00060633
FFFC2ACC 01063023
FFFC2AD0 FFDC0637		ldo		$v1,SYS_MUTEX
FFFC2AD4 F0060613
FFFC2AD8 00060633
FFFC2ADC 00063883
FFFC2AE0 FD181EE3		bne		$v0,$v1,.lock
                        	.nxt:
FFFC2AE4 10300073		pfi
FFFC2AE8 000D4D83		ldbu	$t1,MBX_OWNER[$t0]
FFFC2AEC 000D8E63		beq		$t1,$x0,.noOwner
FFFC2AF0 020D0D13		add		$t0,$t0,#MBX_SIZE
FFFC2AF4 00022637		slt		$t1,$t0,#mbxs_end
FFFC2AF8 00060613
FFFC2AFC FE0D94E3		bne		$t1,$x0,.nxt
FFFC2B00 04006813		ldi		$v0,#E_NoMoreMbx
FFFC2B04 02000E63		bra		.xit
                        	.noOwner:
FFFC2B08 10300073		pfi
FFFC2B0C 013D0023		stb		$a1,MBX_OWNER[$t0]
FFFC2B10 FFFE0637		sub		$t5,$t0,#mbxs				; convert pointer to handle
FFFC2B14 00060613
FFFC2B18 41A60FB3
FFFC2B1C 005FDF93		srl		$t5,$t5,#LOG_MBXSZ
FFFC2B20 0009E933		mov		$a0,$a1
FFFC2B24 000A69B3		mov		$a1,$a2
FFFC2B28 10300073		pfi
FFFC2B2C E40FE0EF		call	VirtToPhys
FFFC2B30 01F83023		sto		$t5,[$v0]
FFFC2B34 00006813		ldi		$v0,#E_Ok
FFFC2B38 00000463		bra		.xit
                        	.badArg:
FFFC2B3C 00106813		ldi		$v0,#E_Arg
                        	.xit:
FFFC2B40 10300073		pfi
                        		; Unlock system mutex
FFFC2B44 00149D13		sll		$t0,$s6,#1
FFFC2B48 FFDC0637		sto		$t0,SYS_MUTEX
FFFC2B4C F0060613
FFFC2B50 00060633
FFFC2B54 01A63023
FFFC2B58 00073083		ldo		$ra,[$sp]
FFFC2B5C 00870713		add		$sp,$sp,#8
FFFC2B60 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Free a mailbox
                        	;
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_FreeMbx:
FFFC2B64 FF870713		sub		$sp,$sp,#8
FFFC2B68 00173023		sto		$ra,[$sp]
FFFC2B6C 1009A213		slt		$s1,$a1,#NR_MBX
FFFC2B70 0A020863		beq		$s1,$x0,.badMbx
FFFC2B74 00599213		sll		$s1,$a1,#LOG_MBXSZ		; convert handle to pointer
FFFC2B78 00020637		add		$s1,$s1,#mbxs
FFFC2B7C 00060613
FFFC2B80 00460233
FFFC2B84 00006293		ldi		$s2,#0
FFFC2B88 04006393		ldi		$s4,#NR_TCB						; possibly 64 tasks
                        		; Lock system mutex
                        		
FFFC2B8C 18101873		csrrw	v0,#$181,x0
FFFC2B90 03F87813		and		v0,v0,#MAX_TID
FFFC2B94 00086533	mov		$s7,$v0
FFFC2B98 00181813		sll		$v0,$v0,#1
FFFC2B9C 00186813		or		$v0,$v0,#1
                        	.lock:
FFFC2BA0 10300073		pfi
FFFC2BA4 FFDC0637		sto		$v0,SYS_MUTEX
FFFC2BA8 F0060613
FFFC2BAC 00060633
FFFC2BB0 01063023
FFFC2BB4 FFDC0637		ldo		$v1,SYS_MUTEX
FFFC2BB8 F0060613
FFFC2BBC 00060633
FFFC2BC0 00063883
FFFC2BC4 FD181EE3		bne		$v0,$v1,.lock
                        	
FFFC2BC8 00823483		ldo		$s6,MBX_WTIDS[$s1]
                        	.0002:
FFFC2BCC 10300073		pfi
FFFC2BD0 0014F313		and		$s3,$s6,#1
FFFC2BD4 02030A63		beq		$s3,$x0,.0001
FFFC2BD8 00A29413		sll		$s5,$s2,#LOG_TCBSZ		; tid to pointer
FFFC2BDC 28844803		lbu		$v0,TCBStatus[$s5]
FFFC2BE0 FF787813		and		$v0,$v0,#~TS_WAITMSG	; no longer waiting
FFFC2BE4 29040423		stb		$v0,TCBStatus[$s5]
FFFC2BE8 01087813		and		$v0,$v0,#TS_TIMEOUT
FFFC2BEC 0002E933		mov		$a0,$s2
FFFC2BF0 00080663		beqz	$v0,.0003
FFFC2BF4 10300073		pfi
FFFC2BF8 608000EF		call	RemoveFromTimeoutList
                        	.0003:
FFFC2BFC 3C4000EF		call	InsertIntoReadyList
FFFC2C00 00B06813		ldi		$v0,#E_NoMsg					; but no message
FFFC2C04 09043023		sto		$v0,128[$s5]					; v0 = E_NoMsg
                        	.0001:
FFFC2C08 10300073		pfi
FFFC2C0C 0014D493		srl		$s6,$s6,#1
FFFC2C10 00128293		add		$s2,$s2,#1
FFFC2C14 FA72ECE3		bltu	$s2,$s4,.0002
FFFC2C18 00006813		ldi		$v0,#E_Ok
FFFC2C1C 00000463		bra		.xit
                        	.badMbx:
FFFC2C20 00406813		ldi		$v0,#E_BadMbx				; return null pointer if bad mailbox
                        	.xit:
FFFC2C24 10300073		pfi
                        		; Unlock system mutex
FFFC2C28 00151D13		sll		$t0,$s7,#1
FFFC2C2C FFDC0637		sto		$t0,SYS_MUTEX
FFFC2C30 F0060613
FFFC2C34 00060633
FFFC2C38 01A63023
FFFC2C3C 00073083		ldo		$ra,[$sp]
FFFC2C40 00870713		add		$sp,$sp,#8
FFFC2C44 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Send a message to a mailbox.
                        	; The message will be broadcast to any waiting tasks. Waiting tasks will then
                        	; be moved to the ready list. If there are no waiting tasks then the message
                        	; is queued at the mailbox.
                        	;
                        	; Register Usage:
                        	;		t0 = mailbox pointer
                        	;		t1 = message pointer
                        	;		s1 = task id of waiting task
                        	; Modifies:
                        	;		a0
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = message d1
                        	;		a3 = message d2
                        	;		a4 = message d3
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_SendMsg:
FFFC2C48 FF870713		sub		$sp,$sp,#8
FFFC2C4C 00173023		sto		$ra,[$sp]
FFFC2C50 1009BD13		sltu	$t0,$a1,#NR_MBX
FFFC2C54 140D0063		beq		$t0,$x0,.badMbx
FFFC2C58 00599D13		sll		$t0,$a1,#LOG_MBXSZ	; convert handle to pointer
FFFC2C5C 00020637		add		$t0,$t0,#mbxs
FFFC2C60 00060613
FFFC2C64 01A60D33
                        		; Lock system mutex
                        		
FFFC2C68 18101873		csrrw	v0,#$181,x0
FFFC2C6C 03F87813		and		v0,v0,#MAX_TID
FFFC2C70 000864B3	mov		$s6,$v0
FFFC2C74 00181813		sll		$v0,$v0,#1
FFFC2C78 00186813		or		$v0,$v0,#1
                        	.lock:
FFFC2C7C 10300073		pfi
FFFC2C80 FFDC0637		sto		$v0,SYS_MUTEX
FFFC2C84 F0060613
FFFC2C88 00060633
FFFC2C8C 01063023
FFFC2C90 FFDC0637		ldo		$v1,SYS_MUTEX
FFFC2C94 F0060613
FFFC2C98 00060633
FFFC2C9C 00063883
FFFC2CA0 FD181EE3		bne		$v0,$v1,.lock
                        	
FFFC2CA4 008D3F83		ldo		$t5,MBX_WTIDS[$t0]
FFFC2CA8 060F8C63		beq		$t5,$x0,.noWaiters	; no waiters = go queue message
FFFC2CAC 00006213		ldi		$s1,#0
                        	.0001:
FFFC2CB0 10300073		pfi
FFFC2CB4 001FF313		and		$s3,$t5,#1					; is tid waiting?
FFFC2CB8 04030463		beq		$s3,$x0,.nxtTid
FFFC2CBC 00A21313		sll		$s3,$s1,#LOG_TCBSZ	; convert tid to TCB pointer
FFFC2CC0 29433C23		sto		$a2,TCBMsgD1[$s3]		; copy message to TCB
FFFC2CC4 2B533023		sto		$a3,TCBMsgD2[$s3]
FFFC2CC8 2B633423		sto		$a4,TCBMsgD3[$s3]
FFFC2CCC 10300073		pfi
FFFC2CD0 28834E03		ldbu	$t2,TCBStatus[$s3]
FFFC2CD4 004E6E13		or		$t2,$t2,#TS_MSGRDY
FFFC2CD8 29C30423		stb		$t2,TCBStatus[$s3]
FFFC2CDC 00026933		mov		$a0,$s1
FFFC2CE0 FF070713		sub		$sp,$sp,#16
FFFC2CE4 00173023		sto		$ra,[$sp]
FFFC2CE8 01A73423		sto		$t0,8[$sp]						; push t0
FFFC2CEC 10300073		pfi
FFFC2CF0 2D0000EF		call	InsertIntoReadyList
FFFC2CF4 00073083		ldo		$ra,[$sp]
FFFC2CF8 00873D03		ldo		$t0,8[$sp]						; pop t0
FFFC2CFC 01070713		add		$sp,$sp,#16
                        	.nxtTid:
FFFC2D00 10300073		pfi
FFFC2D04 001FDF93		srl		$t5,$t5,#1					; check next task
FFFC2D08 00120213		add		$s1,$s1,#1
FFFC2D0C 03F27213		and		$s1,$s1,#63
FFFC2D10 FA0210E3		bne		$s1,$x0,.0001
FFFC2D14 000D3423		sto		$x0,MBX_WTIDS[$t0]	; clear waiters
FFFC2D18 00006813		ldi		$v0,#E_Ok
FFFC2D1C 06000E63		bra		.xit
                        	.noWaiters:
FFFC2D20 10300073		pfi
FFFC2D24 00024637		ldo		$t1,FreeMsg
FFFC2D28 35060613
FFFC2D2C 00060633
FFFC2D30 00063D83
FFFC2D34 040D8A63		beq		$t1,$x0,.noMsg			; message available?
FFFC2D38 000DBE03		ldo		$t2,MSG_LINK[$t1]
FFFC2D3C 00024637		sto		$t2,FreeMsg
FFFC2D40 35060613
FFFC2D44 00060633
FFFC2D48 01C63023
FFFC2D4C 014DB423		sto		$a2,MSG_D1[$t1]
FFFC2D50 015DB823		sto		$a3,MSG_D2[$t1]
FFFC2D54 016DBC23		sto		$a4,MSG_D3[$t1]
FFFC2D58 10300073		pfi
FFFC2D5C 018D3E83		ldo		$t3,MBX_MQTAIL[$t0]
FFFC2D60 000E8A63		beq		$t3,$x0,.mbxEmpty
FFFC2D64 01BEB023		sto		$t1,MSG_LINK[$t3]
FFFC2D68 01BD3C23		sto		$t1,MBX_MQTAIL[$t0]
FFFC2D6C 00006813		ldi		$v0,#E_Ok
FFFC2D70 02000463		bra		.xit
                        	.mbxEmpty:
FFFC2D74 10300073		pfi
FFFC2D78 01BD3823		sto		$t1,MBX_MQHEAD[$t0]
FFFC2D7C 01BD3C23		sto		$t1,MBX_MQTAIL[$t0]
FFFC2D80 00006813		ldi		$v0,#E_Ok
FFFC2D84 00000A63		bra		.xit
                        	.noMsg:
FFFC2D88 10300073		pfi
FFFC2D8C 00B06813		ldi		$v0,#E_NoMsg
FFFC2D90 00000463		bra		.xit
                        	.badMbx:
FFFC2D94 00406813		ldi		$v0,#E_BadMbx				; return null pointer if bad mailbox
                        	.xit:
                        		; Unlock system mutex
FFFC2D98 00149D13		sll		$t0,$s6,#1
FFFC2D9C FFDC0637		sto		$t0,SYS_MUTEX
FFFC2DA0 F0060613
FFFC2DA4 00060633
FFFC2DA8 01A63023
FFFC2DAC 10300073		pfi
FFFC2DB0 00073083		ldo		$ra,[$sp]
FFFC2DB4 00870713		add		$sp,$sp,#8
FFFC2DB8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; PeekMsg will check for a message at a mailbox optionally dequeuing it.
                        	; If no message is available PeekMsg returns to the caller with a E_NoMsg
                        	; status.
                        	;
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = pointer where to put message D1
                        	;		a3 = pointer where to put message D2
                        	;		a4 = pointer where to put message D3
                        	;		a5 = 1 = remove from queue
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_PeekMsg:
FFFC2DBC FF870713		sub		$sp,$sp,#8
FFFC2DC0 00173023		sto		$ra,[$sp]
FFFC2DC4 FF870713		sub		$sp,$sp,#8
FFFC2DC8 00173023		sto		$ra,[$sp]
FFFC2DCC 0209AD13		slt		$t0,$a1,#32
FFFC2DD0 10300073		pfi
FFFC2DD4 0E0D0863		beq		$t0,$x0,.badMbx
                        		; Lock system mutex
                        		
FFFC2DD8 18101873		csrrw	v0,#$181,x0
FFFC2DDC 03F87813		and		v0,v0,#MAX_TID
FFFC2DE0 000864B3	mov		$s6,$v0
FFFC2DE4 00181813		sll		$v0,$v0,#1
FFFC2DE8 00186813		or		$v0,$v0,#1
                        	.lock:
FFFC2DEC 10300073		pfi
FFFC2DF0 FFDC0637		sto		$v0,SYS_MUTEX
FFFC2DF4 F0060613
FFFC2DF8 00060633
FFFC2DFC 01063023
FFFC2E00 FFDC0637		ldo		$v1,SYS_MUTEX
FFFC2E04 F0060613
FFFC2E08 00060633
FFFC2E0C 00063883
FFFC2E10 FD181EE3		bne		$v0,$v1,.lock
                        	
FFFC2E14 00599E13		sll		$t2,$a1,#LOG_MBXSZ	; convert handle to pointer
FFFC2E18 00020637		add		$t2,$t2,#mbxs
FFFC2E1C 00060613
FFFC2E20 01C60E33
FFFC2E24 010E3D83		ldo		$t1,MBX_MQHEAD[$t2]
FFFC2E28 080D8863		beq		$t1,$x0,.noMsg
FFFC2E2C 020B8863		beq		$a5,$x0,.nodq
FFFC2E30 000DBE83		ldo		$t3,MSG_LINK[$t1]
FFFC2E34 01DE3823		sto		$t3,MBX_MQHEAD[$t2]
FFFC2E38 00024637		ldo		$t3,FreeMsg
FFFC2E3C 35060613
FFFC2E40 00060633
FFFC2E44 00063E83
FFFC2E48 01DDB023		sto		$t3,MSG_LINK[$t1]
FFFC2E4C 00024637		sto		$t1,FreeMsg
FFFC2E50 35060613
FFFC2E54 00060633
FFFC2E58 01B63023
                        	.nodq:
FFFC2E5C 10300073		pfi
FFFC2E60 00010D37		ldi		$t0,#$10000
FFFC2E64 000D0D13
FFFC2E68 000A0A63		beqz	$a2,.nod1
FFFC2E6C 008DBE83		ldo		$t3,MSG_D1[$t1]
FFFC2E70 300D2073		csrrs	$x0,#$300,$t0				; set mprv
FFFC2E74 01DA3023		sto		$t3,[$a2]
FFFC2E78 300D3073		csrrc	$x0,#$300,$t0				; clear mprv
                        	.nod1:
FFFC2E7C 10300073		pfi
FFFC2E80 000A8A63		beqz	$a3,.nod2
FFFC2E84 010DBE83		ldo		$t3,MSG_D2[$t1]
FFFC2E88 300D2073		csrrs	$x0,#$300,$t0				; set mprv
FFFC2E8C 01DAB023		sto		$t3,[$a3]
FFFC2E90 300D3073		csrrc	$x0,#$300,$t0				; clear mprv
                        	.nod2:
FFFC2E94 10300073		pfi
FFFC2E98 000B0A63		beqz	$a4,.nod3
FFFC2E9C 018DBE83		ldo		$t3,MSG_D3[$t1]
FFFC2EA0 300D2073		csrrs	$x0,#$300,$t0				; set mprv
FFFC2EA4 01DB3023		sto		$t3,[$a4]
FFFC2EA8 300D3073		csrrc	$x0,#$300,$t0				; clear mprv
                        	.nod3:
FFFC2EAC 10300073		pfi
FFFC2EB0 00006813		ldi		$v0,#E_Ok
FFFC2EB4 00000A63		bra		.ret
                        	.noMsg:
FFFC2EB8 10300073		pfi
FFFC2EBC 00B06813		ldi		$v0,#E_NoMsg
FFFC2EC0 00000463		bra		.ret
                        	.badMbx:
FFFC2EC4 00406813		ldi		$v0,#E_BadMbx				; return null pointer if bad mailbox
                        	.ret:
FFFC2EC8 10300073		pfi
                        		; Unlock system mutex
FFFC2ECC 00149D13		sll		$t0,$s6,#1
FFFC2ED0 FFDC0637		sto		$t0,SYS_MUTEX
FFFC2ED4 F0060613
FFFC2ED8 00060633
FFFC2EDC 01A63023
FFFC2EE0 00073083		ldo		$ra,[$sp]
FFFC2EE4 00870713		add		$sp,$sp,#8
FFFC2EE8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Calling WaitMsg will cause the task to be queued at the mailbox and a task
                        	; switch to occur if there are no messages at the mailbox.
                        	;
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = pointer where to put message D1
                        	;		a3 = pointer where to put message D2
                        	;		a4 = pointer where to put message D3
                        	;		a5 = time limit
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_WaitMsg:
FFFC2EEC FF870713		sub		$sp,$sp,#8
FFFC2EF0 00173023		sto		$ra,[$sp]
FFFC2EF4 000BE433		mov		$s5,$a5
FFFC2EF8 00106B93		ldi		$a5,#1
FFFC2EFC 10300073		pfi
FFFC2F00 EBDFF0EF		call	FMTK_PeekMsg				; check for a message, return if available
FFFC2F04 00B06D93		ldi		$t1,#E_NoMsg
FFFC2F08 01B80463		beq		$v0,$t1,.qt					; no message? Then go queue task
FFFC2F0C 0A000263		bra		.xit
                        	.qt:
FFFC2F10 10300073		pfi
                        		; Lock system mutex
                        		
FFFC2F14 18101873		csrrw	v0,#$181,x0
FFFC2F18 03F87813		and		v0,v0,#MAX_TID
FFFC2F1C 000864B3	mov		$s6,$v0
FFFC2F20 00181813		sll		$v0,$v0,#1
FFFC2F24 00186813		or		$v0,$v0,#1
                        	.lock:
FFFC2F28 10300073		pfi
FFFC2F2C FFDC0637		sto		$v0,SYS_MUTEX
FFFC2F30 F0060613
FFFC2F34 00060633
FFFC2F38 01063023
FFFC2F3C FFDC0637		ldo		$v1,SYS_MUTEX
FFFC2F40 F0060613
FFFC2F44 00060633
FFFC2F48 00063883
FFFC2F4C FD181EE3		bne		$v0,$v1,.lock
                        	
FFFC2F50 00106E13		ldi		$t2,#1
FFFC2F54 010E1E33		sll		$t2,$t2,$v0
FFFC2F58 00599E93		sll		$t3,$a1,#LOG_MBXSZ	; convert handle to pointer
FFFC2F5C 00020637		add		$t3,$t3,#mbxs
FFFC2F60 00060613
FFFC2F64 01D60EB3
FFFC2F68 10300073		pfi
FFFC2F6C 008EBF03		ldo		$t4,MBX_WTIDS[$t3]	; get waiting task list
FFFC2F70 01CF6F33		or		$t4,$t4,$t2					; set bit for tid
FFFC2F74 01EEB423		sto		$t4,MBX_WTIDS[$t3]	; save task list
FFFC2F78 00A81F13		sll		$t4,$v0,#LOG_TCBSZ	; convert tid to TCB pointer
FFFC2F7C 288F4E83		ldbu	$t3,TCBStatus[$t4]
FFFC2F80 008EEE93		or		$t3,$t3,#TS_WAITMSG	; set waiting for message status
FFFC2F84 FFEEFE93		and		$t3,$t3,#~TS_READY	; not ready
FFFC2F88 10300073		pfi
FFFC2F8C 29DF0423		stb		$t3,TCBStatus[$t4]
FFFC2F90 293F0623		stb		$a1,TCBWaitMbx[$t4]	; set mailbox task is waiting for
FFFC2F94 000BE9B3		mov		$a1,$a5
                        		; Unlock system mutex
FFFC2F98 00149D13		sll		$t0,$s6,#1
FFFC2F9C FFDC0637		sto		$t0,SYS_MUTEX
FFFC2FA0 F0060613
FFFC2FA4 00060633
FFFC2FA8 01A63023
                        		; Continue by switching tasks
FFFC2FAC C94FF0EF		call		FMTK_Sleep
                        	.xit:
FFFC2FB0 10300073		pfi
FFFC2FB4 00073083		ldo		$ra,[$sp]
FFFC2FB8 00870713		add		$sp,$sp,#8
FFFC2FBC 00008067		ret
                        	
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/tcb.r5a",1
                        	.file "../fmtk/tcb.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../fmtk/tcb.r5a",25
                        		code
                        		align	4                        	
                        	;------------------------------------------------------------------------------
                        	; Insert task into ready list. The list is a doubly linked circular list.
                        	;
                        	; Parameters:
                        	;		a0 = tid to insert
                        	; Modifies:
                        	;		v1,t0,t1,t2
                        	; Returns:
                        	;		v0 = 1 for success, 0 if failed
                        	;------------------------------------------------------------------------------
                        	
                        	InsertIntoReadyList:
FFFC2FC0 00006813		ldi		$v0,#E_Ok						; setup for ok
FFFC2FC4 03F06893		ldi		$v1,#MAX_TID				; check argument
FFFC2FC8 0928EA63		bgtu	$a0,$v1,.badTid
FFFC2FCC 00A91E93		sll		$t3,$a0,#LOG_TCBSZ	; tid to pointer
FFFC2FD0 288ECD03		ldbu	$t0,TCBStatus[$t3]	; set status to ready
FFFC2FD4 001D6D13		or		$t0,$t0,#TS_READY
FFFC2FD8 29AE8423		sb		$t0,TCBStatus[$t3]
FFFC2FDC 289E8D03		ldb		$t0,TCBPriority[$t3]
FFFC2FE0 19A9000D		insrdy	$a0,$t0
	ret
FFFC2FE4 00008067
FFFC2FE8 003D7D13		and		$t0,$t0,#3					; limit to four
FFFC2FEC 001D1D13		sll		$t0,$t0,#1					; *2 for indexing
FFFC2FF0 00024637		ldw		$t1,READYQ[$t0]			; get head of queue for that priority
FFFC2FF4 30860613
FFFC2FF8 01A60633
FFFC2FFC 00061D83
FFFC3000 020DD063		bge		$t1,$x0,.insert			; Is there a head?
                        		; level 0 insert - nothing in list, create a ring to self
FFFC3004 00024637		stw		$a0,READYQ[$t0]			; no head, simple to insert
FFFC3008 30860613
FFFC300C 01A60633
FFFC3010 01261023
FFFC3014 2D2E9823		stw		$a0,TCBNext[$t3]		; remember it's a ring
FFFC3018 2D2E9C23		stw		$a0,TCBPrev[$t3]
FFFC301C 00008067		ret
                        		; Insert at tail of list, which is just before the head.
                        	.insert:
FFFC3020 00AD9F13		sll		$t4,$t1,#LOG_TCBSZ	; tid to pointer
FFFC3024 2D8F1E03		ldw		$t2,TCBPrev[$t4]		; t2 = head->prev
FFFC3028 01BE1C63		bne		$t2,$t1,.level2
                        		;level 1 insert - only 1 item currently in list, items point to each other
                        		; This bit probably redundant code as normal insertion should work as well.
FFFC302C 2D2F1C23		stw		$a0,TCBPrev[$t4]		; simple to insert
FFFC3030 2D2F1823		stw		$a0,TCBNext[$t4]		; head->prev = head->next = arg
FFFC3034 2DBE9C23		stw		$t1,TCBPrev[$t3]		; arg->prev = arg->next = head
FFFC3038 2DBE9823		stw		$t1,TCBNext[$t3]
FFFC303C 00008067		ret
                        		; Here there will be three or more entries in the list. Arg is inserted
                        		; between head and head->prev to make it the last on the list.
                        	.level2:
FFFC3040 2DCE9C23		stw		$t2,TCBPrev[$t3]		; arg->prev = head->prev
FFFC3044 2DBE9823		stw		$t1,TCBNext[$t3]		; arg->next = head, arg links are now set
                        		; If there's a head there should be a head->prev and head->next at least pointing to the head
FFFC3048 000E4663		bltz	$t2,.0001						; head->prev valid?
FFFC304C 00AE1E93		sll		$t3,$t2,#LOG_TCBSZ	; t3 = head->prev (as a pointer)
FFFC3050 2D2E9823		stw		$a0,TCBNext[$t3]		; head->prev->next = arg
                        	.0001:
FFFC3054 2D2F1C23		stw		$a0,TCBPrev[$t4]		; head->prev = arg
FFFC3058 00008067		ret
                        	.badTid:
FFFC305C 00106813		ldi		$v0,#E_Arg
FFFC3060 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; The ready list is a doubly linked list to make it easier and faster to
                        	; remove items from the list. There's no need to search the list for the item
                        	; to remove.
                        	;
                        	; Parameters:
                        	;		a0 = tid to remove
                        	; Modifies:
                        	;		t0,t1,t2,t3,t4,t5
                        	; Returns:
                        	;		v0 = E_Ok for success
                        	;------------------------------------------------------------------------------
                        	
                        	RemoveFromReadyList:
FFFC3064 03F06893		ldi		$v1,#MAX_TID					; check arg
FFFC3068 0128F863		bleu	$a0,$v1,.tidOk
FFFC306C 00106813		ldi		$v0,#E_Arg
FFFC3070 00000637		jmp		ERETx
FFFC3074 24360067
                        	.tidOk:
FFFC3078 1A09000D		rmvrdy	$a0									; cheat and use hardware
FFFC307C 00A91F13		sll		$t4,$a0,#LOG_TCBSZ		; s1 = pointer to tcb
FFFC3080 288F0D03		ldb		$t0,TCBStatus[$t4]		; set status no longer ready or running
FFFC3084 F7ED7D13		and		$t0,$t0,#~(TS_READY|TS_RUNNING)
	stb		$t0,TCBStatus[$t4]
FFFC3088 29AF0423
FFFC308C 00008067		ret
                        	
                        	RemoveFromReadyList2:
FFFC3090 03F06893		ldi		$v1,#MAX_TID					; check arg
FFFC3094 0928E063		bgtu	$a0,$v1,.badTid
FFFC3098 00A91F13		sll		$t4,$a0,#LOG_TCBSZ		; s1 = pointer to tcb
FFFC309C 288F0D03		ldb		$t0,TCBStatus[$t4]		; set status no longer ready or running
FFFC30A0 F7ED7D13		and		$t0,$t0,#~(TS_READY|TS_RUNNING)
	stb		$t0,TCBStatus[$t4]
FFFC30A4 29AF0423
FFFC30A8 289F0D03		ldb		$t0,TCBPriority[$t4]	; t0 = priority
FFFC30AC 003D7D13		and		$t0,$t0,#3						; limit to 0-3
FFFC30B0 001D1D13		sll		$t0,$t0,#1						; *2 for indexing
FFFC30B4 00024637		ldw		$t1,READYQ[$t0]				; get head tid
FFFC30B8 30860613
FFFC30BC 01A60633
FFFC30C0 00061D83
FFFC30C4 2D0F1E03		ldw		$t2,TCBNext[$t4]			; get arg->next
FFFC30C8 012D9E63		bne		$t1,$a0,.0001					; removing head of list?
FFFC30CC 012E1463		bne		$t2,$a0,.0003					; list emptying? (if arg->next points back to arg)
FFFC30D0 FFF06E13		ldi		$t2,#-1
                        	.0003:
FFFC30D4 00024637		stw		$t2,READYQ[$t0]				; yes, set new head to arg->next
FFFC30D8 30860613
FFFC30DC 01A60633
FFFC30E0 01C61023
                        	.0001:
FFFC30E4 000E4E63		bltz	$t2,.0002							; validate t2 (arg->next)
FFFC30E8 011E7C63		bgeu	$t2,$v1,.0002					; there should always be an arg->next, arg->prev
FFFC30EC 2D8F1E83		ldw		$t3,TCBPrev[$t4]			; because the list is circular t3=arg->prev
FFFC30F0 00AE9F93		sll		$t5,$t3,#LOG_TCBSZ		; t5 = arg->prev as a pointer
FFFC30F4 2DCF9823		stw		$t2,TCBNext[$t5]			; arg->prev->next = arg->next
FFFC30F8 00AE1F93		sll		$t5,$t2,#LOG_TCBSZ		; t5 = arg->next as a pointer
FFFC30FC 2DDF9C23		stw		$t3,TCBPrev[$t5]			; arg->next->prev = arg->prev
                        		; Now indicate links in TCB are not in use.
                        	.0002:
FFFC3100 FFF06813		ldi		$v0,#-1
FFFC3104 2D0F1823		stw		$v0,TCBNext[$t4]
FFFC3108 2D0F1C23		stw		$v0,TCBPrev[$t4]
FFFC310C 00006813		ldi		$v0,#E_Ok							; we're ok
FFFC3110 00008067		ret
                        	.badTid:
FFFC3114 00106813		ldi		$v0,#E_Arg
FFFC3118 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = task id to insert
                        	;		a1 = timeout value
                        	; Modifies:
                        	;		t0,t1,t2,t3,t4,t5
                        	;------------------------------------------------------------------------------
                        	
                        	InsertIntoTimeoutList:
FFFC311C 1139000D		setto	$a0,$a1
	sll		$t5,$a0,#LOG_TCBSZ		; tid to pointer
FFFC3120 00A91F93
FFFC3124 288FCE03		ldbu	$t2,TCBStatus[$t5]		; set status to timing out
FFFC3128 010E6E13		or		$t2,$t2,#TS_TIMEOUT
FFFC312C 29CF8423		stb		$t2,TCBStatus[$t5]
FFFC3130 00006813		ldi		$v0,#E_Ok
FFFC3134 00008067		ret
FFFC3138 FFF06D13		ldi		$t0,#-1						
FFFC313C 2DAF9823		stw		$t0,TCBNext[$t5]			; initialize indexes to -1
FFFC3140 2DAF9C23		stw		$t0,TCBPrev[$t5]
FFFC3144 00024637		ldw		$t0,TimeoutList
FFFC3148 32860613
FFFC314C 00060633
FFFC3150 00061D03
FFFC3154 020D5063		bge		$t0,$x0,.0001
                        		; Here the timeout list was empty, easy to insert.
FFFC3158 2F3FA023		stt		$a1,TCBTimeout[$t5]		; set timeout for task
FFFC315C 00024637		stw		$a0,TimeoutList				; set head of list
FFFC3160 32860613
FFFC3164 00060633
FFFC3168 01261023
FFFC316C 00006813		ldi		$v0,#E_Ok							; and return
FFFC3170 00008067		ret
                        	.0001:
FFFC3174 FFF06D93		ldi		$t1,#-1								; t1 used as previous index
FFFC3178 000D6E33		mov		$t2,$t0								; t2 = head of timeout list index
FFFC317C 00AE1E93		sll		$t3,$t2,#LOG_TCBSZ		; t3 = head of timeout list as a pointer
                        		; Search the timeout list for the proper insertion point. The timeouts are
                        		; relative, so the requested amount is decremented by the amounts in the
                        		; list as it is searched.
                        	.beginWhile:
FFFC3180 2E0EAF03		ldt		$t4,TCBTimeout[$t3]		; get the timeout
FFFC3184 033F5663		ble		$a1,$t4,.endWhile			; is it greater than the requested timeout ?
FFFC3188 41E989B3		sub		$a1,$a1,$t4						; decrement by list amount
FFFC318C 000EEDB3		mov		$t1,$t3								; t1 = pointer to previous entry
FFFC3190 2D0E9E83		ldw		$t3,TCBNext[$t3]			; get the next entry in list
FFFC3194 000EC663		bltz	$t3,.endOfList					; end of list?
FFFC3198 00AE9E93		sll		$t3,$t3,#LOG_TCBSZ		; no, set pointer to current entry
FFFC319C FFBE92E3		bne		$t3,$t1,.beginWhile		; list screwed up? (This test should always be true)
                        	.endOfList:
                        		; Here the end of the list was reached, insert as last entry
FFFC31A0 2D2D9823		stw		$a0,TCBNext[$t1]			; entry->next = arg
FFFC31A4 2DBF9C23		stw		$t1,TCBPrev[$t5]			; arg->prev = entry
FFFC31A8 2F3FA023		stt		$a1,TCBTimeout[$t5]
FFFC31AC 04000063		bra		.0003
                        	.endWhile:
                        		; Here we found a timeout greater than the requested amount. Insert before.
FFFC31B0 20AEDE13		sra		$t2,$t3,#LOG_TCBSZ		; pointer to tid
FFFC31B4 2DCF9823		stw		$t2,TCBNext[$t5]			; arg->next = entry
FFFC31B8 20ADDE13		sra		$t2,$t1,#LOG_TCBSZ
FFFC31BC 2DCF9C23		stw		$t2,TCBPrev[$t5]			; arg->prev = prev entry
FFFC31C0 2E0EAE03		ldt		$t2,TCBTimeout[$t3]		; update timeout of entry by subtracting off
FFFC31C4 413E0E33		sub		$t2,$t2,$a1						; the arg's timeout
FFFC31C8 2FCEA023		stt		$t2,TCBTimeout[$t3]
FFFC31CC 2D2E9C23		stw		$a0,TCBPrev[$t3]			; entry->prev = arg
FFFC31D0 000DC663		bltz	$t1,.0002							; previous entry? no - go update list head
FFFC31D4 2D2D9823		stw		$a0,TCBNext[$t1]			; prev entry->next = arg
FFFC31D8 00000A63		bra		.0003
                        	.0002:
FFFC31DC 00024637		stw		$a0,TimeoutList				; list head = arg
FFFC31E0 32860613
FFFC31E4 00060633
FFFC31E8 01261023
                        	.0003:
FFFC31EC 288FCE03		ldbu	$t2,TCBStatus[$t5]		; set status to timing out
FFFC31F0 010E6E13		or		$t2,$t2,#TS_TIMEOUT
FFFC31F4 29CF8423		stb		$t2,TCBStatus[$t5]
FFFC31F8 00006813		ldi		$v0,#E_Ok
FFFC31FC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Remove a task from the timeout list. The timeouts of following tasks are
                        	; adjusted. Called when a mailbox is freed and a task is waiting at the
                        	; mailbox. From within scheduling code mPopTimeoutList is used instead.
                        	;
                        	; Parameters:
                        	;		a0 = task id to remove
                        	; Modifies:
                        	;		t0,t3,t4
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	RemoveFromTimeoutList:
FFFC3200 00A91E93		sll		$t3,$a0,#LOG_TCBSZ		; tid to pointer
FFFC3204 288ECD03		ldbu	$t0,TCBStatus[$t3]		; check if waiting at a mailbox
FFFC3208 008D7D13		and		$t0,$t0,#TS_WAITMSG
FFFC320C 000D0463		beqz	$t0,.noWait				
FFFC3210 819FF0EF		call	MbxRemoveTask					; remove task from mailbox
                        	.noWait:
FFFC3214 FE7D7D13		and		$t0,$t0,#~(TS_TIMEOUT|TS_WAITMSG)
	stb		$t0,TCBStatus[$t3]
FFFC3218 29AE8423
FFFC321C 1009000D		setto	$a0,$x0
	ldi		$v0,#E_Ok
FFFC3220 00006813
FFFC3224 00008067		ret
                        	
FFFC3228 00024637		ldw		$t1,TimeoutList
FFFC322C 32860613
FFFC3230 00060633
FFFC3234 00061D83
FFFC3238 2D0E9D03		ldw		$t0,TCBNext[$t3]			; t0 = arg->next
FFFC323C 01B91A63		bne		$a0,$t1,.0001					; check removing head of list
FFFC3240 00024637		stw		$t0,TimeoutList				; set new head = arg->next
FFFC3244 32860613
FFFC3248 00060633
FFFC324C 01A61023
                        	.0001:
FFFC3250 020D4063		bltz	$t0,.noNext
FFFC3254 00AD1F13		sll		$t4,$t0,#LOG_TCBSZ
FFFC3258 2D8E9D83		ldw		$t1,TCBPrev[$t3]			; next->prev = arg->prev
FFFC325C 2DBF1C23		stw		$t1,TCBPrev[$t4]			
FFFC3260 2E0F2D83		ldt		$t1,TCBTimeout[$t4]		; next->timeout += arg->timeout
FFFC3264 2E0EAE03		ldt		$t2,TCBTimeout[$t3]
FFFC3268 01CD8DB3		add		$t1,$t1,$t2
FFFC326C 2FBF2023		stt		$t1,TCBTimeout[$t4]
                        	.noNext:
FFFC3270 2D8E9D03		ldw		$t0,TCBPrev[$t3]			; check for previous
FFFC3274 000D4863		bltz	$t0,.noPrev
FFFC3278 00AD1F13		sll		$t4,$t0,#LOG_TCBSZ
FFFC327C 2D0E9D03		ldw		$t0,TCBNext[$t3]			; prev->next = arg->next
FFFC3280 2DAF1823		stw		$t0,TCBNext[$t4]
                        	.noPrev:
FFFC3284 288E8D03		ldb		$t0,TCBStatus[$t3]		; no longer timing out
FFFC3288 FE7D7D13		and		$t0,$t0,#~(TS_TIMEOUT|TS_WAITMSG)
	stb		$t0,TCBStatus[$t3]
FFFC328C 29AE8423
FFFC3290 FFF06D13		ldi		$t0,#-1								; reset links
FFFC3294 2DAE9823		stw		$t0,TCBNext[$t3]
FFFC3298 2DAE9C23		stw		$t0,TCBPrev[$t3]
FFFC329C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Returns:
                        	;		v1 = process id
                        	;------------------------------------------------------------------------------
                        	
                        	AllocTCB:
FFFC32A0 00006D93		ldi		$t1,#0
FFFC32A4 00024637		ldwu	$v1,PIDMAP
FFFC32A8 31060613
FFFC32AC 00060633
FFFC32B0 00065883
                        	.0001:
FFFC32B4 0018FD13		and		$t0,$v1,#1
FFFC32B8 020D0463		beqz	$t0,.allocTid
FFFC32BC 0018D893		srl		$v1,$v1,#1
FFFC32C0 00008637		or		$v1,$v1,#$8000
FFFC32C4 00060613
FFFC32C8 011668B3
FFFC32CC 001D8D93		add		$t1,$t1,#1
FFFC32D0 00FDFD93		and		$t1,$t1,#15
FFFC32D4 FE0D90E3		bne		$t1,$x0,.0001
                        	; here no tcbs available
FFFC32D8 04506813		ldi		$v0,#E_NoMoreTCBs
FFFC32DC 00008067		ret
                        	.allocTid:
FFFC32E0 000DE833		mov		$v0,$t1
FFFC32E4 0018E893		or		$v1,$v1,#1
FFFC32E8 000D8A63		beqz	$t1,.0003
                        	.0002:
FFFC32EC 00189893		sll		$v1,$v1,#1
FFFC32F0 0018E893		or		$v1,$v1,#1
FFFC32F4 FFFD8D93		sub		$t1,$t1,#1
FFFC32F8 FE0D9AE3		bnez	$t1,.0002
                        	.0003:
FFFC32FC 00024637		stw		$v1,PIDMAP
FFFC3300 31060613
FFFC3304 00060633
FFFC3308 01161023
FFFC330C 000868B3		mov		$v1,$v0
FFFC3310 00006813		ldi		$v0,#E_Ok
FFFC3314 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FreeTCB:
FFFC3318 00106D13		ldi		$t0,#1
FFFC331C 012D1D33		sll		$t0,$t0,$a0
FFFC3320 FFFD4D13		xor		$t0,$t0,#-1
FFFC3324 00024637		lhu		$t1,PIDMAP
FFFC3328 31060613
FFFC332C 00060633
FFFC3330 00065D83
FFFC3334 01ADFDB3		and		$t1,$t1,$t0
FFFC3338 00024637		stw		$t1,PIDMAP
FFFC333C 31060613
FFFC3340 00060633
FFFC3344 01B61023
FFFC3348 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Diagnostics
                        	;------------------------------------------------------------------------------
                        	
                        	DumpReadyList:
FFFC334C FC070713		sub		$sp,$sp,#64
FFFC3350 00173023		sto		$ra,[$sp]
FFFC3354 01273423		sto		$a0,8[$sp]
FFFC3358 01473823		sto		$a2,16[$sp]
FFFC335C 01573C23		sto		$a3,24[$sp]
FFFC3360 03B73023		sto		$t1,32[$sp]
FFFC3364 03C73423		sto		$t2,40[$sp]
FFFC3368 03D73823		sto		$t3,48[$sp]
FFFC336C 02473C23		sto		$s1,56[$sp]
FFFC3370 FFFC3937		ldi		$a0,#msgReadyList
FFFC3374 4DC90913
FFFC3378 C80FD0EF		call	PutString
FFFC337C 00006D93		ldi		$t1,#0
FFFC3380 3000F273		csrrc	$s1,#$300,#1
                        	.0002:
FFFC3384 9E8FE0EF		call	SerialPeekCharDirect
FFFC3388 00384813		xor		$v0,$v0,#CTRLC
FFFC338C 08080263		beqz	$v0,.brk
FFFC3390 00D06913		ldi		$a0,#CR
FFFC3394 EB1FC0EF		call	Putch
FFFC3398 05106913		ldi		$a0,#'Q'
FFFC339C EA9FC0EF		call	Putch
FFFC33A0 001DD913		srl		$a0,$t1,#1
FFFC33A4 C0CFD0EF		call	PutHexNybble
FFFC33A8 03A06913		ldi		$a0,#':'
FFFC33AC E99FC0EF		call	Putch
FFFC33B0 00024637		ldw		$a2,READYQ[$t1]
FFFC33B4 30860613
FFFC33B8 01B60633
FFFC33BC 00061A03
FFFC33C0 040A4263		blt		$a2,$x0,.nxt
FFFC33C4 000A6AB3		mov		$a3,$a2
                        	.0001:
FFFC33C8 000AE933		mov		$a0,$a3
FFFC33CC BA4FD0EF		call	PutHexHalf
FFFC33D0 02006913		ldi		$a0,#' '
FFFC33D4 E71FC0EF		call	Putch
FFFC33D8 00AA9A93		sll		$a3,$a3,#LOG_TCBSZ
FFFC33DC 2D0A9903		ldw		$a0,TCBNext[$a3]
FFFC33E0 B90FD0EF		call	PutHexHalf
FFFC33E4 02006913		ldi		$a0,#' '
FFFC33E8 E5DFC0EF		call	Putch
FFFC33EC 2D8A9903		ldw		$a0,TCBPrev[$a3]
FFFC33F0 B80FD0EF		call	PutHexHalf
FFFC33F4 00D06913		ldi		$a0,#CR
FFFC33F8 E4DFC0EF		call	Putch
FFFC33FC 2D0A9A83		ldw		$a3,TCBNext[$a3]
FFFC3400 FD5A14E3		bne		$a2,$a3,.0001
                        	.nxt:
FFFC3404 002D8D93		add		$t1,$t1,#2
FFFC3408 008DAE13		slt		$t2,$t1,#8
FFFC340C F60E1CE3		bnez	$t2,.0002
                        	.brk:
FFFC3410 30021073		csrrw	$x0,#$300,$s1
FFFC3414 00073083		ldo		$ra,[$sp]
FFFC3418 00873903		ldo		$a0,8[$sp]
FFFC341C 01073A03		ldo		$a2,16[$sp]
FFFC3420 01873A83		ldo		$a3,24[$sp]
FFFC3424 02073D83		ldo		$t1,32[$sp]
FFFC3428 02873E03		ldo		$t2,40[$sp]
FFFC342C 03073E83		ldo		$t3,48[$sp]
FFFC3430 03873203		ldo		$s1,56[$sp]
FFFC3434 04070713		add		$sp,$sp,#64
FFFC3438 00008067		ret
                        	
                        	DumpTimeoutList:
FFFC343C FE070713		sub		$sp,$sp,#32
FFFC3440 00172023		stt		$ra,[$sp]
FFFC3444 01272223		stt		$a0,4[$sp]
FFFC3448 01472423		stt		$a2,8[$sp]
FFFC344C 01572623		stt		$a3,12[$sp]
FFFC3450 01B72823		stt		$t1,16[$sp]
FFFC3454 01C72A23		stt		$t2,20[$sp]
FFFC3458 01D72C23		stt		$t3,24[$sp]
FFFC345C 00472E23		stt		$s1,28[$sp]
FFFC3460 FFFC3937		ldi		$a0,#msgTimeoutList
FFFC3464 50D90913
FFFC3468 B90FD0EF		call	PutString
FFFC346C 00006D93		ldi		$t1,#0
FFFC3470 3000F273		csrrc	$s1,#$300,#1
FFFC3474 00006A93		ldi		$a3,#0
                        	.0002:
FFFC3478 8F4FE0EF		call	SerialPeekCharDirect
FFFC347C 00384813		xor		$v0,$v0,#CTRLC
FFFC3480 02080863		beqz	$v0,.brk
FFFC3484 00D06913		ldi		$a0,#CR
FFFC3488 DBDFC0EF		call	Putch
                        	;	ldw		$a2,TimeoutList
                        	;	bltz	$a2,.brk
                        	;	mov		$a3,$a2
                        	;.0001:
FFFC348C 000AE933		mov		$a0,$a3
FFFC3490 AE0FD0EF		call	PutHexHalf
FFFC3494 02D06913		ldi		$a0,#'-'
FFFC3498 DADFC0EF		call	Putch
FFFC349C 120D890D		getto	$a0,$t1
;	sll		$a3,$a3,#LOG_TCBSZ
                        	;	ldt		$a0,TCBTimeout[$a3]
FFFC34A0 AB0FD0EF		call	PutHexWord
                        	;	ldi		$a0,#CR
                        	;	call	Putch
FFFC34A4 001A8A93		add		$a3,$a3,#1
FFFC34A8 00FAFA93		and		$a3,$a3,#15
FFFC34AC FD5046E3		bgt		$a3,$x0,.0002
                        	;	ldw		$a3,TCBNext[$a3]
                        	;	bge		$a3,$x0,.0001
                        	.brk:
FFFC34B0 30021073		csrrw	$x0,#$300,$s1
FFFC34B4 00072083		ldt		$ra,[$sp]
FFFC34B8 00472903		ldt		$a0,4[$sp]
FFFC34BC 00872A03		ldt		$a2,8[$sp]
FFFC34C0 00C72A83		ldt		$a3,12[$sp]
FFFC34C4 01072D83		ldt		$t1,16[$sp]
FFFC34C8 01472E03		ldt		$t2,20[$sp]
FFFC34CC 01872E83		ldt		$t3,24[$sp]
FFFC34D0 01C72203		ldt		$s1,28[$sp]
FFFC34D4 02070713		add		$sp,$sp,#32
FFFC34D8 00008067		ret
                        	
                        	msgReadyList:
FFFC34DC 6165520D		db	CR,"Ready List",CR
FFFC34E0 4C207964
FFFC34E4 0D747369
FFFC34E8 20657551		db	"Que Tid  Prv  Nxt",CR
FFFC34EC 20646954
FFFC34F0 76725020
FFFC34F4 784E2020
FFFC34F8 2D2D0D74
FFFC34FA 2D2D2D2D		db	"-----------------",CR,0
FFFC34FE 2D2D2D2D
FFFC3502 2D2D2D2D
FFFC3506 2D2D2D2D
FFFC350A 0D000D2D
                        	
                        	msgTimeoutList:
FFFC350D 6D69540D		db	CR,"Timeout List",CR
FFFC3511 74756F65
FFFC3515 73694C20
FFFC3519 54200D74
FFFC351B 64695420		db	" Tid - Timeout",CR
FFFC351F 54202D20
FFFC3523 6F656D69
FFFC3527 2D0D7475
FFFC352A 2D2D2D2D		db	"--------------",CR,0
FFFC352E 2D2D2D2D
FFFC3532 2D2D2D2D
FFFC3536 000D2D2D
                        	
FFFC353A E0730000		align 
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/iofocus.r5a",1
                        	.file "../fmtk/iofocus.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;-----------------------------------------------------------------------------
                        	; IO Focus routines complicated by the fact that the base address of TCB
                        	; zero is zero (looks like a null pointer but isn't). So the value -1 is 
                        	; used to indicate no focus index.
                        	;-----------------------------------------------------------------------------
                        	
                        	.file "../fmtk/iofocus.r5a",31
                        		code
                        		align	4                        	
                        	
                        	;-----------------------------------------------------------------------------
                        	; Determine if the currently running task has the I/O focus.
                        	;
                        	; Stack Space:
                        	;		2 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		v0 = E_Ok
                        	;		v1 = 1 if task has IO focus, 0 otherwise
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_HasIOFocus:
                        		; Enable interrupts
FFFC353C 3000E073		csrrs	$x0,#$300,#1				
FFFC3540 00025637		ldb		$v0,SwitchIOFocus
FFFC3544 82060613
FFFC3548 00060633
FFFC354C 00060803
FFFC3550 00080C63		beqz	$v0,.noSwitch
FFFC3554 00025637		stb		$x0,SwitchIOFocus
FFFC3558 82060613
FFFC355C 00060633
FFFC3560 00060023
FFFC3564 038000EF		call	FMTK_SwitchIOFocus
                        	.noSwitch:
                        		
FFFC3568 18101873		csrrw	v0,#$181,x0
FFFC356C 03F87813		and		v0,v0,#MAX_TID
FFFC3570 00A81813	sll		$v0,$v0,#LOG_TCBSZ
FFFC3574 3000F073		csrrc	$x0,#$300,#1				; disable ints
FFFC3578 2400088D		nxtiof	$v1
FFFC357C 2600088D		prviof	$v1
FFFC3580 3000E073		csrrs	$x0,#$300,#1				
                        	;	ldo		$v1,IOFocusNdx
FFFC3584 01180663		beq		$v0,$v1,.hasFocus
FFFC3588 00006893		ldi		$v1,#0
FFFC358C 00000463		bra		.xit
                        	.hasFocus:
FFFC3590 00106893		ldi		$v1,#1
                        	.xit:
FFFC3594 00006813		ldi		$v0,#E_Ok
FFFC3598 00008067		ret
                        	
                        	;-----------------------------------------------------------------------------
                        	; First check if it's even possible to switch the focus to another
                        	; task. The I/O focus list could be empty or there may be only a
                        	; single task in the list. In either case it's not possible to
                        	; switch.
                        	;
                        	;	Parameters:
                        	;		none
                        	;	Modifies:
                        	;		a0,a1,t0,t1,t2,t3
                        	;	Returns:
                        	;		v0 = E_Ok
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_SwitchIOFocus:
FFFC359C FF870713		sub		$sp,$sp,#8
FFFC35A0 00173023		sto		$ra,[$sp]
FFFC35A4 24000D0D		nxtiof	$t0
FFFC35A8 26000D8D		prviof	$t1
FFFC35AC 09BD0C63		beq		$t0,$t1,.sameFocus
FFFC35B0 080D4A63		bltz	$t0,.noFocus
FFFC35B4 24000D0D		nxtiof	$t0
                        	
                        	;	ldo		$t0,IOFocusNdx			; get focus pointer
                        	;	bltz	$t0,.noFocus				; is it -1?
                        	;	ldo		$t1,IOF_NEXT[$t0]
                        	;	beq		$t1,$t0,.sameFocus
                        	;	bltz	$t1,.noFocus
FFFC35B8 3000E073		csrrs	$x0,#$300,#1				; enable interrupts
                        		; swap virtual text screens
FFFC35BC 65806213		ldi		$s1,#56*29
FFFC35C0 330D3E03		ldo		$t2,TCBVideoMem[$t0]
FFFC35C4 020E0A63		beqz	$t2,.0002
FFFC35C8 33CD3C23		sto		$t2,TCBpVideo[$t0]
FFFC35CC FFD00EB7		ldi		$t3,#$FFD00000
FFFC35D0 000E8E93
FFFC35D4 00AD5913		srl		$a0,$t0,#LOG_TCBSZ
FFFC35D8 000E69B3		mov		$a1,$t2
FFFC35DC B91FD0EF		call	VirtToPhys
                        	.0001:
FFFC35E0 000EBF03		ldo		$t4,[$t3]
FFFC35E4 01E83023		sto		$t4,[$v0]
FFFC35E8 008E8E93		add		$t3,$t3,#8
FFFC35EC 00880813		add		$v0,$v0,#8
FFFC35F0 FFF20213		sub		$s1,$s1,#1
FFFC35F4 FE4046E3		bgt		$s1,$x0,.0001
                        	.0002:
FFFC35F8 65806213		ldi		$s1,#56*29
FFFC35FC 330DBE03		ldo		$t2,TCBVideoMem[$t1]
FFFC3600 020E0A63		beqz	$t2,.0004
FFFC3604 FFD00EB7		ldi		$t3,#$FFD00000
FFFC3608 000E8E93
FFFC360C 33DDBC23		sto		$t3,TCBpVideo[$t1]
FFFC3610 00ADD913		srl		$a0,$t1,#LOG_TCBSZ
FFFC3614 000E69B3		mov		$a1,$t2
FFFC3618 B55FD0EF		call	VirtToPhys
                        	.0003:
FFFC361C 00083F03		ldo		$t4,[$v0]
FFFC3620 01EEB023		sto		$t4,[$t3]
FFFC3624 008E8E93		add		$t3,$t3,#8
FFFC3628 00880813		add		$v0,$v0,#8
FFFC362C FFF20213		sub		$s1,$s1,#1
FFFC3630 FE4046E3		bgt		$s1,$x0,.0003
                        	.0004:
FFFC3634 00025637		sto		$t1,IOFocusNdx
FFFC3638 81060613
FFFC363C 00060633
FFFC3640 01B63023
                        	.sameFocus:
                        	.noFocus:
FFFC3644 00006813		ldi		$v0,#E_Ok
FFFC3648 00073083		ldo		$ra,[$sp]
FFFC364C 00870713		add		$sp,$sp,#8
FFFC3650 00008067		ret
                        	
                        	;-----------------------------------------------------------------------------
                        	; The I/O focus list is an array indicating which jobs are requesting the
                        	; I/O focus. The I/O focus is user controlled by pressing CNTRL-T on the
                        	; keyboard.
                        	;
                        	; Parameters:
                        	;		a1 = task id requesting focus for
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_RequestIOFocus:
FFFC3654 2009800D		insiof	$a1
FFFC3658 00006813		ldi		$v0,#E_Ok
FFFC365C 00008067		ret
                        	
FFFC3660 00106D13		ldi		$t0,#1
FFFC3664 013D1D33		sll		$t0,$t0,$a1
FFFC3668 00025637		ldo		$t1,IOFocusTbl			; Is the task already included in the IO focus?
FFFC366C 81860613
FFFC3670 00060633
FFFC3674 00063D83
FFFC3678 01ADFE33		and		$t2,$t1,$t0					; test bit
FFFC367C 060E1463		bnez	$t2,.ret						; If so, don't add again
FFFC3680 01ADEDB3		or		$t1,$t1,$t0					; set bit indicator
FFFC3684 00025637		sto		$t1,IOFocusTbl
FFFC3688 81860613
FFFC368C 00060633
FFFC3690 01B63023
                        		; Disable interrupts while manipulating IO focus list
FFFC3694 3000F073		csrrc	$x0,#$300,#1				
FFFC3698 00025637		ldo		$t0,IOFocusNdx			; get current index
FFFC369C 81060613
FFFC36A0 00060633
FFFC36A4 00063D03
FFFC36A8 00A99D93		sll		$t1,$a1,#LOG_TCBSZ	; t1 = pointer to TCB
FFFC36AC 020D5063		bge		$t0,$x0,.notEmpty		; is there one? (!= -1)
FFFC36B0 00025637		sto		$t1,IOFocusNdx			; no current index, so set equal to requester
FFFC36B4 81060613
FFFC36B8 00060633
FFFC36BC 01B63023
FFFC36C0 2FBDB423		sto		$t1,IOF_NEXT[$t1]		; and loop back to self
FFFC36C4 2FBDB823		sto		$t1,IOF_PREV[$t1]
FFFC36C8 00000E63		bra		.ret
                        	.notEmpty:
FFFC36CC 2F0D3E03		ldo		$t2,IOF_PREV[$t0]		; insert t1 into focus ring
FFFC36D0 2FCDB823		sto		$t2,IOF_PREV[$t1]
FFFC36D4 2FADB423		sto		$t0,IOF_NEXT[$t1]
FFFC36D8 2F0D3E03		ldo		$t2,IOF_PREV[$t0]
FFFC36DC 2FBE3423		sto		$t1,IOF_NEXT[$t2]
FFFC36E0 2FBD3823		sto		$t1,IOF_PREV[$t0]
                        	.ret:
FFFC36E4 00006813		ldi		$v0,#E_Ok
FFFC36E8 00008067		ret
                        	
                        	;-----------------------------------------------------------------------------
                        	; ReleaseIOFocus called when the task no longer desires to be on the I/O
                        	; focus list.
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_ReleaseIOFocus:
                        		
FFFC36EC 18101873		csrrw	v0,#$181,x0
FFFC36F0 03F87813		and		v0,v0,#MAX_TID
FFFC36F4 000869B3	mov		$a1,$v0
                        		; fall into ForceReleaseIOFocus
                        	
                        	;-----------------------------------------------------------------------------
                        	; Releasing the I/O focus causes the focus to switch if the running job
                        	; had the I/O focus.
                        	; ForceReleaseIOFocus forces the release of the IO focus for a job
                        	; different than the one currently running.
                        	; 
                        	; Stack Space:
                        	;		2 words
                        	; Parameters:
                        	;		a1 = task id to release
                        	; Returns:
                        	;		v0 = E_Ok
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_ForceReleaseIOFocus:
FFFC36F8 FF870713		sub		$sp,$sp,#8
FFFC36FC 00173023		sto		$ra,[$sp]
FFFC3700 2209880D		rmviof	$v0,$a1
	beqz	$v0,.noSwitch
FFFC3704 00080463
FFFC3708 E95FF0EF		call	FMTK_SwitchIOFocus
                        	.noSwitch:
FFFC370C 00073083		ldo		$ra,[$sp]
FFFC3710 00870713		add		$sp,$sp,#8
FFFC3714 00006813		ldi		$v0,#E_Ok
FFFC3718 00008067		ret
                        	
FFFC371C 3000E073		csrrs	$x0,#$300,#1				; enable interrupts
FFFC3720 00106D13		ldi		$t0,#1
FFFC3724 013D1D33		sll		$t0,$t0,$a1
FFFC3728 00025637		ldo		$t1,IOFocusTbl
FFFC372C 81860613
FFFC3730 00060633
FFFC3734 00063D83
FFFC3738 01ADFE33		and		$t2,$t1,$t0				; test bit for task
FFFC373C 080E0863		beq		$t2,$x0,.noFocus	; does it even have the focus?
FFFC3740 FFFD4D13		xor		$t0,$t0,#-1				; get inverted mask
FFFC3744 01ADFDB3		and		$t1,$t1,$t0				; clear bit for task
FFFC3748 00025637		sto		$t1,IOFocusTbl
FFFC374C 81860613
FFFC3750 00060633
FFFC3754 01B63023
FFFC3758 00025637		ldo		$t1,IOFocusNdx		; check if the focus being released is the current
FFFC375C 81060613
FFFC3760 00060633
FFFC3764 00063D83
FFFC3768 00A99D13		sll		$t0,$a1,#LOG_TCBSZ	; io focus. If so, switch focus
FFFC376C 03BD1063		bne		$t0,$t1,.notSame
FFFC3770 FF070713		sub		$sp,$sp,#16
FFFC3774 01A73023		sto		$t0,[$sp]
FFFC3778 01B73423		sto		$t1,8[$sp]
FFFC377C E21FF0EF		call	FMTK_SwitchIOFocus
FFFC3780 00073D03		ldo		$t0,[$sp]
FFFC3784 00873D83		ldo		$t1,8[$sp]
FFFC3788 01070713		add		$sp,$sp,#16
                        	.notSame:
                        		; Disable interrupts while manipulating IO focus list
FFFC378C 3000F073		csrrc	$x0,#$300,#1				
FFFC3790 2E8D3E03		ldo		$t2,IOF_NEXT[$t0]
FFFC3794 020E4C63		blt		$t2,$x0,.done
FFFC3798 01AE0A63		beq		$t2,$t0,.pjSame
FFFC379C 2F0D3D83		ldo		$t1,IOF_PREV[$t0]
FFFC37A0 2FBE3823		sto		$t1,IOF_PREV[$t2]
FFFC37A4 2FCDB423		sto		$t2,IOF_NEXT[$t1]
FFFC37A8 00000C63		bra		.0001
                        	.pjSame:
FFFC37AC FFF06D93		ldi		$t1,#-1
FFFC37B0 00025637		sto		$t1,IOFocusNdx
FFFC37B4 81060613
FFFC37B8 00060633
FFFC37BC 01B63023
                        	.0001:
FFFC37C0 FFF06D93		ldi		$t1,#-1
FFFC37C4 2FBD3423		sto		$t1,IOF_NEXT[$t0]	
FFFC37C8 2FBD3823		sto		$t1,IOF_PREV[$t0]	
                        	.done:
                        	.noFocus:
FFFC37CC 00006813		ldi		$v0,#E_Ok
FFFC37D0 00008067		ret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/io.r5a",1
                        	.file "../fmtk/io.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;Standard Devices are:
                        	
                        	;#		Device					Standard name
                        	
                        	;0		NULL device 			NUL		(OS built-in)
                        	;1		Keyboard (sequential)	KBD		(OS built-in)
                        	;2		Video (sequential)		VID		(OS built-in)
                        	;3		Printer (parallel 1)	LPT
                        	;4		Printer (parallel 2)	LPT2
                        	;5		RS-232 1				COM1	(OS built-in)
                        	;6		RS-232 2				COM2
                        	;7		RS-232 3				COM3
                        	;8		RS-232 4				COM4
                        	;9		Parallel xfer	  PTI
                        	;10		Floppy					FD0
                        	;11		Floppy					FD1
                        	;12		Hard disk				HD0
                        	;13		Hard disk				HD1
                        	;14
                        	;15   VIA							VIA1
                        	;16		SDCard					CARD1 	(OS built-in)
                        	;17
                        	;18
                        	;19
                        	;20
                        	;21
                        	;22
                        	;23
                        	;24
                        	;25
                        	;26
                        	;27
                        	;28		Audio						PSG1	(OS built-in)
                        	;29
                        	;30   Random Number		PRNG
                        	;31		Debug						DBG
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a2 = function
                        	;		a3 = data
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_IO:
FFFC37D4 02006813		ldi		$v0,#32
FFFC37D8 0309FE63		bgeu	$a1,$v0,.badDev
FFFC37DC 02006893		ldi		$v1,#32
FFFC37E0 031A7663		bgeu	$a2,$v1,.badFunc
FFFC37E4 00899813		sll		$v0,$a1,#8					; each device allowed 32 functions (*256)
FFFC37E8 003A1893		sll		$v1,$a2,#3					; function number *8
FFFC37EC 00022637		add		$v0,$v0,#DVF_Base		; base address of function table
FFFC37F0 00060613
FFFC37F4 01060833
FFFC37F8 01186833		or		$v0,$v0,$v1
FFFC37FC 00083803		ldo		$v0,[$v0]
FFFC3800 00080663		beq		$v0,$x0,.badFunc
FFFC3804 000800E7		call	[$v0]
                        	.xit:
FFFC3808 00008067		ret
                        	.badFunc:
FFFC380C 02206813		ldi		$v0,#E_BadDevOp
FFFC3810 FE000CE3		bra		.xit
                        	.badDev:
FFFC3814 02006813		ldi		$v0,#E_BadDevNum
FFFC3818 FE0008E3		bra		.xit
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = I/O channel
                        	;		a1 = points to function table
                        	;------------------------------------------------------------------------------
                        	
                        	CopyDevFuncTbl:
FFFC381C 00891813		sll		$v0,$a0,#8					; each device allowed 32 functions (*256)
FFFC3820 00022637		add		$v0,$v0,#DVF_Base		; base address of function table
FFFC3824 00060613
FFFC3828 01060833
FFFC382C 02006D13		ldi		$t0,#32							; 32 functions to copy
                        	.again:
FFFC3830 0009BE03		ldo		$t2,[$a1]
FFFC3834 01C83023		sto		$t2,[$v0]
FFFC3838 00898993		add		$a1,$a1,#8
FFFC383C 00880813		add		$v0,$v0,#8
FFFC3840 FFFD0D13		sub		$t0,$t0,#1
FFFC3844 FFA046E3		bgt		$t0,$x0,.again
FFFC3848 00008067		ret
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/scancodes.r5a",1
                        	.file "../fmtk/scancodes.r5a",1
                        		;--------------------------------------------------------------------------
                        		; PS2 scan codes to ascii conversion tables.
                        		;--------------------------------------------------------------------------
                        		;
FFFC384C 00000000		align	
                        	
                        	_unshiftedScanCodes:
FFFC3850 A52EA92E		.byte	$2e,$a9,$2e,$a5,$a3,$a1,$a2,$ac
FFFC3854 ACA2A1A3
FFFC3858 A6A8AA2E		.byte	$2e,$aa,$a8,$a6,$a4,$09,$60,$2e
FFFC385C 2E6009A4
FFFC3860 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$71,$31,$2e
FFFC3864 2E31712E
FFFC3868 737A2E2E		.byte	$2e,$2e,$7a,$73,$61,$77,$32,$2e
FFFC386C 2E327761
FFFC3870 6478632E		.byte	$2e,$63,$78,$64,$65,$34,$33,$2e
FFFC3874 2E333465
FFFC3878 6676202E		.byte	$2e,$20,$76,$66,$74,$72,$35,$2e
FFFC387C 2E357274
FFFC3880 68626E2E		.byte	$2e,$6e,$62,$68,$67,$79,$36,$2e
FFFC3884 2E367967
FFFC3888 6A6D2E2E		.byte	$2e,$2e,$6d,$6a,$75,$37,$38,$2e
FFFC388C 2E383775
FFFC3890 696B2C2E		.byte	$2e,$2c,$6b,$69,$6f,$30,$39,$2e
FFFC3894 2E39306F
FFFC3898 6C2F2E2E		.byte	$2e,$2e,$2f,$6c,$3b,$70,$2d,$2e
FFFC389C 2E2D703B
FFFC38A0 2E272E2E		.byte	$2e,$2e,$27,$2e,$5b,$3d,$2e,$2e
FFFC38A4 2E2E3D5B
FFFC38A8 5D0D2EAD		.byte	$ad,$2e,$0d,$5d,$2e,$5c,$2e,$2e
FFFC38AC 2E2E5C2E
FFFC38B0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
FFFC38B4 2E082E2E
FFFC38B8 932E952E		.byte	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
FFFC38BC 2E2E2E94
FFFC38C0 2E927F98		.byte	$98,$7f,$92,$2e,$91,$90,$1b,$af
FFFC38C4 AF1B9091
FFFC38C8 2E972EAB		.byte	$ab,$2e,$97,$2e,$2e,$96,$ae,$2e
FFFC38CC 2EAE962E
                        	
FFFC38D0 A72E2E2E		.byte	$2e,$2e,$2e,$a7,$2e,$2e,$2e,$2e
FFFC38D4 2E2E2E2E
FFFC38D8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC38DC 2E2E2E2E
FFFC38E0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC38E4 2E2E2E2E
FFFC38E8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC38EC 2E2E2E2E
FFFC38F0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC38F4 2E2E2E2E
FFFC38F8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC38FC 2E2E2E2E
FFFC3900 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3904 2E2E2E2E
FFFC3908 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC390C 2E2E2E2E
FFFC3910 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3914 2E2E2E2E
FFFC3918 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC391C 2E2E2E2E
FFFC3920 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3924 2E2E2E2E
FFFC3928 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC392C 2E2E2E2E
FFFC3930 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3934 2E2E2E2E
FFFC3938 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC393C 2E2E2E2E
FFFC3940 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3944 2E2E2E2E
FFFC3948 2EFA2E2E		.byte	$2e,$2e,$fa,$2e,$2e,$2e,$2e,$2e
FFFC394C 2E2E2E2E
                        	
                        	_shiftedScanCodes:
FFFC3950 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3954 2E2E2E2E
FFFC3958 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
FFFC395C 2E7E092E
FFFC3960 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$51,$21,$2e
FFFC3964 2E21512E
FFFC3968 535A2E2E		.byte	$2e,$2e,$5a,$53,$41,$57,$40,$2e
FFFC396C 2E405741
FFFC3970 4458432E		.byte	$2e,$43,$58,$44,$45,$24,$23,$2e
FFFC3974 2E232445
FFFC3978 4656202E		.byte	$2e,$20,$56,$46,$54,$52,$25,$2e
FFFC397C 2E255254
FFFC3980 48424E2E		.byte	$2e,$4e,$42,$48,$47,$59,$5e,$2e
FFFC3984 2E5E5947
FFFC3988 4A4D2E2E		.byte	$2e,$2e,$4d,$4a,$55,$26,$2a,$2e
FFFC398C 2E2A2655
FFFC3990 494B3C2E		.byte	$2e,$3c,$4b,$49,$4f,$29,$28,$2e
FFFC3994 2E28294F
FFFC3998 4C3F3E2E		.byte	$2e,$3e,$3f,$4c,$3a,$50,$5f,$2e
FFFC399C 2E5F503A
FFFC39A0 2E222E2E		.byte	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
FFFC39A4 2E2E2B7B
FFFC39A8 7D0D2E2E		.byte	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
FFFC39AC 2E2E7C2E
FFFC39B0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
FFFC39B4 2E082E2E
FFFC39B8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC39BC 2E2E2E2E
FFFC39C0 2E2E7F2E		.byte	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
FFFC39C4 2E1B2E2E
FFFC39C8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC39CC 2E2E2E2E
                        	
FFFC39D0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC39D4 2E2E2E2E
FFFC39D8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC39DC 2E2E2E2E
FFFC39E0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC39E4 2E2E2E2E
FFFC39E8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC39EC 2E2E2E2E
FFFC39F0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC39F4 2E2E2E2E
FFFC39F8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC39FC 2E2E2E2E
FFFC3A00 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3A04 2E2E2E2E
FFFC3A08 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3A0C 2E2E2E2E
FFFC3A10 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3A14 2E2E2E2E
FFFC3A18 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3A1C 2E2E2E2E
FFFC3A20 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3A24 2E2E2E2E
FFFC3A28 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3A2C 2E2E2E2E
FFFC3A30 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3A34 2E2E2E2E
FFFC3A38 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3A3C 2E2E2E2E
FFFC3A40 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3A44 2E2E2E2E
FFFC3A48 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3A4C 2E2E2E2E
                        	
                        	; control
                        	_keybdControlCodes:
FFFC3A50 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3A54 2E2E2E2E
FFFC3A58 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
FFFC3A5C 2E7E092E
FFFC3A60 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$11,$21,$2e
FFFC3A64 2E21112E
FFFC3A68 131A2E2E		.byte	$2e,$2e,$1a,$13,$01,$17,$40,$2e
FFFC3A6C 2E401701
FFFC3A70 0418032E		.byte	$2e,$03,$18,$04,$05,$24,$23,$2e
FFFC3A74 2E232405
FFFC3A78 0616202E		.byte	$2e,$20,$16,$06,$14,$12,$25,$2e
FFFC3A7C 2E251214
FFFC3A80 08020E2E		.byte	$2e,$0e,$02,$08,$07,$19,$5e,$2e
FFFC3A84 2E5E1907
FFFC3A88 0A0D2E2E		.byte	$2e,$2e,$0d,$0a,$15,$26,$2a,$2e
FFFC3A8C 2E2A2615
FFFC3A90 090B3C2E		.byte	$2e,$3c,$0b,$09,$0f,$29,$28,$2e
FFFC3A94 2E28290F
FFFC3A98 0C3F3E2E		.byte	$2e,$3e,$3f,$0c,$3a,$10,$5f,$2e
FFFC3A9C 2E5F103A
FFFC3AA0 2E222E2E		.byte	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
FFFC3AA4 2E2E2B7B
FFFC3AA8 7D0D2E2E		.byte	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
FFFC3AAC 2E2E7C2E
FFFC3AB0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
FFFC3AB4 2E082E2E
FFFC3AB8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3ABC 2E2E2E2E
FFFC3AC0 2E2E7F2E		.byte	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
FFFC3AC4 2E1B2E2E
FFFC3AC8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3ACC 2E2E2E2E
                        	
                        	_keybdExtendedCodes:
FFFC3AD0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$a3,$a1,$a2,$2e
FFFC3AD4 2EA2A1A3
FFFC3AD8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3ADC 2E2E2E2E
FFFC3AE0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3AE4 2E2E2E2E
FFFC3AE8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3AEC 2E2E2E2E
FFFC3AF0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3AF4 2E2E2E2E
FFFC3AF8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3AFC 2E2E2E2E
FFFC3B00 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3B04 2E2E2E2E
FFFC3B08 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3B0C 2E2E2E2E
FFFC3B10 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3B14 2E2E2E2E
FFFC3B18 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3B1C 2E2E2E2E
FFFC3B20 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3B24 2E2E2E2E
FFFC3B28 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3B2C 2E2E2E2E
FFFC3B30 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3B34 2E2E2E2E
FFFC3B38 932E952E		.byte	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
FFFC3B3C 2E2E2E94
FFFC3B40 2E929998		.byte	$98,$99,$92,$2e,$91,$90,$2e,$2e
FFFC3B44 2E2E9091
FFFC3B48 2E972E2E		.byte	$2e,$2e,$97,$2e,$2e,$96,$2e,$2e
FFFC3B4C 2E2E962E
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/keybd_driver_asm.r5a",1
                        	.file "../fmtk/keybd_driver_asm.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
                        		align	8                        	
                        	KeybdFuncTbl:
FFFC3B50 00000000		dco		0							; no operation
FFFC3B54 00000000
FFFC3B58 00000000		dco		0							; setup
FFFC3B5C 00000000
FFFC3B60 00000000		dco		0							; initialize
FFFC3B64 00000000
FFFC3B68 00000000		dco		0							; status
FFFC3B6C 00000000
FFFC3B70 00000000		dco		0							; media check
FFFC3B74 00000000
FFFC3B78 00000000		dco		0							; build BPB
FFFC3B7C 00000000
FFFC3B80 00000000		dco		0							; open
FFFC3B84 00000000
FFFC3B88 00000000		dco		0							; close
FFFC3B8C 00000000
FFFC3B90 00000000		dco		0							; get char
FFFC3B94 00000000
FFFC3B98 00000000		dco		0							; Peek char
FFFC3B9C 00000000
FFFC3BA0 FFFC3F08		dco		_KeybdGetScancode		; get char direct
FFFC3BA4 00000000
FFFC3BA8 FFFC3EF4		dco		_KeybdPeekScancode	; Peek char direct
FFFC3BAC 00000000
FFFC3BB0 00000000		dco		0							; input status
FFFC3BB4 00000000
FFFC3BB8 00000000		dco		0							; Put char
FFFC3BBC 00000000
FFFC3BC0 FFFC3E78		dco		_KeybdSendByte	; reserved
FFFC3BC4 00000000
FFFC3BC8 00000000		dco		0							; set position
FFFC3BCC 00000000
FFFC3BD0 00000000		dco		0							; read block
FFFC3BD4 00000000
FFFC3BD8 00000000		dco		0							; write block
FFFC3BDC 00000000
FFFC3BE0 00000000		dco		0							; verify block
FFFC3BE4 00000000
FFFC3BE8 00000000		dco		0							; output status
FFFC3BEC 00000000
FFFC3BF0 00000000		dco		0							; flush input
FFFC3BF4 00000000
FFFC3BF8 00000000		dco		0							; flush output
FFFC3BFC 00000000
FFFC3C00 FFFC3F2C		dco		KeybdIRQ			; IRQ routine
FFFC3C04 00000000
FFFC3C08 00000000		dco		0							; Is removable
FFFC3C0C 00000000
FFFC3C10 00000000		dco		0							; ioctrl read
FFFC3C14 00000000
FFFC3C18 00000000		dco		0							; ioctrl write
FFFC3C1C 00000000
FFFC3C20 00000000		dco		0							; output until busy
FFFC3C24 00000000
FFFC3C28 00000000		dco		0							; 27
FFFC3C2C 00000000
FFFC3C30 00000000		dco		0
FFFC3C34 00000000
FFFC3C38 00000000		dco		0
FFFC3C3C 00000000
FFFC3C40 00000000		dco		0
FFFC3C44 00000000
FFFC3C48 00000000		dco		0							; 31
FFFC3C4C 00000000
                        	
                        	;===============================================================================
                        	; Keyboard routines
                        	;===============================================================================
                        	
                        	SC_C		equ		$21
                        	SC_Z		equ		$1A
                        	SC_TAB	equ		$0D
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Initialize the keyboard.
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        		align	4                        			; we don't know what was before
                        	_KeybdInit:
FFFC3C50 FF070713		sub		$sp,$sp,#16
FFFC3C54 00173023		sto		$ra,[$sp]
FFFC3C58 00106913		ldi		$a0,#1					; Keyboard device
FFFC3C5C FFFC49B7		ldi		$a1,#KeybdFuncTbl
FFFC3C60 B5098993
FFFC3C64 BB9FF0EF		call	CopyDevFuncTbl
FFFC3C68 00006993		ldi		$a1,#0
FFFC3C6C 00025A37		ldi		$a2,#hKeybdMbx
FFFC3C70 822A0A13
FFFC3C74 E21FE0EF		call	FMTK_AllocMbx
FFFC3C78 0E000C63		bra		.xit
FFFC3C7C 00506E93		ldi		$t3,#5
                        	.0002:
FFFC3C80 00031937		ldi		$a0,#200000			; 10ms wait
FFFC3C84 D4090913
FFFC3C88 01D73423		sto		$t3,8[$sp]
FFFC3C8C BA5FC0EF		call	_MicroDelay
FFFC3C90 FFF06913		ldi		$a0,#-1					; send reset code to keyboard
FFFC3C94 00000637		stb		$a0,KEYBD+1			; write $FF to status reg to clear TX state
FFFC3C98 28560613
FFFC3C9C 00060633
FFFC3CA0 01260023
FFFC3CA4 1D4000EF		call	_KeybdSendByte	; now write to transmit register
FFFC3CA8 1E4000EF		call	_KeybdWaitTx		; wait until no longer busy
FFFC3CAC 178000EF		call	_KeybdRecvByte	; look for an ACK ($FA)
FFFC3CB0 0FA84E13		xor		$t2,$v0,#$FA
FFFC3CB4 040E1863		bnez	$t2,.tryAgain
FFFC3CB8 16C000EF		call	_KeybdRecvByte	; look for BAT completion code ($AA)
FFFC3CBC 0FC84E13		xor		$t2,$v0,#$FC		; reset error ?
FFFC3CC0 040E0263		beqz	$t2,.tryAgain
FFFC3CC4 0AA84813		xor		$v0,$v0,#$AA	; reset complete okay ?
FFFC3CC8 02081E63		bnez	$v0,.tryAgain
                        	
                        		; After a reset, scan code set #2 should be active
                        	.config:
FFFC3CCC 0F006913		ldi		$a0,#$F0			; send scan code select
FFFC3CD0 FFDC0637		stb		$a0,LEDS
FFFC3CD4 60060613
FFFC3CD8 00060633
FFFC3CDC 01260023
FFFC3CE0 198000EF		call	_KeybdSendByte
FFFC3CE4 1A8000EF		call	_KeybdWaitTx
FFFC3CE8 08087813		and		$v0,$v0,#$80
FFFC3CEC 00081C63		bnez	$v0,.tryAgain
FFFC3CF0 134000EF		call	_KeybdRecvByte	; wait for response from keyboard
FFFC3CF4 08087893		and		$v1,$v0,#$80
FFFC3CF8 00089663		bnez	$v1,.tryAgain
FFFC3CFC 0FA84E13		xor		$t2,$v0,#$FA
FFFC3D00 020E0463		beqz	$t2,.0004
                        	.tryAgain:
FFFC3D04 00873E83		ldo		$t3,8[$sp]
FFFC3D08 FFFE8E93	  sub   $t3,$t3,#1
FFFC3D0C F60E9AE3		bnez	$t3,.0002
                        	.keybdErr:
FFFC3D10 00000937		ldi		$a0,#msgBadKeybd
FFFC3D14 28B90913
FFFC3D18 FF870713		sub		$sp,$sp,#8
FFFC3D1C 01273023		sto		$a0,[$sp]
FFFC3D20 AD9FC0EF		call	PutString		; _DBGDisplayAsciiStringCRLF
FFFC3D24 02000863		bra		.ledxit
                        	.0004:
FFFC3D28 00206913		ldi		$a0,#2			; select scan code set #2
FFFC3D2C 14C000EF		call	_KeybdSendByte
FFFC3D30 15C000EF		call	_KeybdWaitTx
FFFC3D34 08087813		and		$v0,$v0,#$80
FFFC3D38 FC0816E3		bnez	$v0,.tryAgain
FFFC3D3C 0E8000EF		call	_KeybdRecvByte	; wait for response from keyboard
FFFC3D40 08087893		and		$v1,$v0,#$80
FFFC3D44 FC0890E3		bnez	$v1,.tryAgain
FFFC3D48 0FA84E13		xor		$t2,$v0,#$FA
FFFC3D4C FA0E1CE3		bnez	$t2,.tryAgain
FFFC3D50 06C000EF		call	_KeybdGetID
                        	.ledxit:
FFFC3D54 00706913		ldi		$a0,#$07
FFFC3D58 024000EF		call	_KeybdSetLED
FFFC3D5C 005B9937		ldi		$a0,#6000000	; 300 ms
FFFC3D60 D8090913
FFFC3D64 ACDFC0EF		call	_MicroDelay
FFFC3D68 00006913		ldi		$a0,#$00
FFFC3D6C 010000EF		call	_KeybdSetLED
                        	.xit:
FFFC3D70 00073083		ldo		$ra,[$sp]
FFFC3D74 01070713		add		$sp,$sp,#16
FFFC3D78 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Set the LEDs on the keyboard.
                        	;
                        	; Parameters: $a0 LED status to set
                        	; Returns: none
                        	; Modifies: none
                        	; Stack Space: 2 words
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdSetLED:
FFFC3D7C FF070713		sub		$sp,$sp,#16
FFFC3D80 00173023		sto		$ra,[$sp]
FFFC3D84 00096E33		mov		$t2,$a0
FFFC3D88 0ED06913		ldi		$a0,#$ED
FFFC3D8C 01C73423		sto		$t2,8[$sp]
FFFC3D90 0E8000EF		call	_KeybdSendByte
FFFC3D94 0F8000EF		call	_KeybdWaitTx
FFFC3D98 08C000EF		call	_KeybdRecvByte	; should be an ack
FFFC3D9C 00873E03		ldo		$t2,8[$sp]
FFFC3DA0 000E6933		mov		$a0,$t2
FFFC3DA4 0D4000EF		call	_KeybdSendByte
FFFC3DA8 0E4000EF		call	_KeybdWaitTx
FFFC3DAC 078000EF		call	_KeybdRecvByte	; should be an ack
FFFC3DB0 00073083		ldo		$ra,[$sp]
FFFC3DB4 01070713		add		$sp,$sp,#16
FFFC3DB8 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Get ID - get the keyboards identifier code.
                        	;
                        	; Parameters: none
                        	; Returns: r1 = $AB83, $00 on fail
                        	; Modifies: r1, KeybdID updated
                        	; Stack Space: 2 words
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdGetID:
FFFC3DBC FF870713		sub		$sp,$sp,#8
FFFC3DC0 00173023		sto		$ra,[$sp]
FFFC3DC4 0F206913		ldi		$a0,#$F2
FFFC3DC8 0B0000EF		call	_KeybdSendByte
FFFC3DCC 0C0000EF		call	_KeybdWaitTx
FFFC3DD0 054000EF		call	_KeybdRecvByte
FFFC3DD4 08087893		and		$v1,$v0,#$80
FFFC3DD8 04089263		bnez	$v1,.notKbd
FFFC3DDC 0AB84E13		xor		$t2,$v0,#$AB
FFFC3DE0 020E1E63		bnez	$t2,.notKbd
FFFC3DE4 040000EF		call	_KeybdRecvByte
FFFC3DE8 08087893		and		$v1,$v0,#$80
FFFC3DEC 02089863		bnez	$v1,.notKbd
FFFC3DF0 08384E13		xor		$t2,$v0,#$83
FFFC3DF4 020E1463		bnez	$t2,.notKbd
FFFC3DF8 0000B837		ldi		$v0,#$AB83
FFFC3DFC B8380813
                        	.0001:
FFFC3E00 00000637		stt		$v0,_KeybdID
FFFC3E04 29160613
FFFC3E08 00060633
FFFC3E0C 01062023
FFFC3E10 00073083		ldo		$ra,[$sp]
FFFC3E14 00870713		add		$sp,$sp,#8
FFFC3E18 00008067		ret
                        	.notKbd:
FFFC3E1C 00006813		ldi		$v0,#$00
FFFC3E20 FE0000E3		bra		.0001
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Recieve a byte from the keyboard, used after a command is sent to the
                        	; keyboard in order to wait for a response.
                        	;
                        	; Parameters: none
                        	; Returns: r1 = recieved byte ($00 to $FF), -1 on timeout
                        	; Modifies: r1
                        	; Stack Space: 2 words
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdRecvByte:
FFFC3E24 FF070713		sub		$sp,$sp,#16
FFFC3E28 00173023		sto		$ra,[$sp]
FFFC3E2C 06406E93		ldi		$t3,#100				; wait up to 1s
                        	.0003:
FFFC3E30 0B0000EF		call	_KeybdGetStatus	; wait for response from keyboard
FFFC3E34 08087813		and		$v0,$v0,#$80		; is input buffer full ? yes, branch
FFFC3E38 02081863		bnez	$v0,.0004
FFFC3E3C 00031937		ldi		$a0,#200000
FFFC3E40 D4090913
FFFC3E44 01D73423		sto		$t3,8[$sp]
FFFC3E48 9E9FC0EF		call	_MicroDelay
FFFC3E4C 00873E83		ldo		$t3,8[$sp]
FFFC3E50 FFFE8E93		sub   $t3,$t3,#1
FFFC3E54 FC0E9EE3		bnez	$t3,.0003				; go back and try again
FFFC3E58 FFF06813		ldi		$v0,#-1				; return -1
FFFC3E5C 00073083		ldo		$ra,[$sp]
FFFC3E60 01070713		add		$sp,$sp,#16
FFFC3E64 00008067		ret
                        	.0004:
FFFC3E68 0A0000EF		call	_KeybdGetScancode
FFFC3E6C 00073083		ldo		$ra,[$sp]
FFFC3E70 01070713		add		$sp,$sp,#16
FFFC3E74 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Send a byte to the keyboard.
                        	;
                        	; Parameters: $a0 byte to send
                        	; Returns: none
                        	; Modifies: none
                        	; Stack Space: 0 words
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdSendByte:
FFFC3E78 00000637		stb		$a0,KEYBD
FFFC3E7C 28460613
FFFC3E80 00060633
FFFC3E84 01260023
FFFC3E88 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Wait until the keyboard transmit is complete
                        	;
                        	; Parameters: none
                        	; Returns: r1 = 0 if successful, r1 = -1 timeout
                        	; Modifies: v0,t3
                        	; Stack Space: 1 words
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdWaitTx:
FFFC3E8C FF070713		sub		$sp,$sp,#16
FFFC3E90 00173023		sto		$ra,[$sp]
FFFC3E94 06406E93		ldi		$t3,#100			; wait a max of 1s
                        	.0001:
FFFC3E98 048000EF		call	_KeybdGetStatus
FFFC3E9C 04087813		and		$v0,$v0,#$40	; check for transmit complete bit; branch if bit set
FFFC3EA0 02081863		bnez	$v0,.0002
FFFC3EA4 01D73423		sto		$t3,8[$sp]
FFFC3EA8 00031937		ldi		$a0,#200000		; 10 ms @20MHz
FFFC3EAC D4090913
FFFC3EB0 981FC0EF		call	_MicroDelay		; delay a little bit
FFFC3EB4 00873E83		ldo		$t3,8[$sp]
FFFC3EB8 FFFE8E93		sub		$t3,$t3,#1
FFFC3EBC FC0E9EE3		bnez	$t3,.0001
FFFC3EC0 00073083		ldo		$ra,[$sp]			; timed out
FFFC3EC4 00870713		add		$sp,$sp,#8
FFFC3EC8 FFF06813		ldi		$v0,#-1
FFFC3ECC 00008067		ret		
                        	.0002:
FFFC3ED0 00073083		ldo		$ra,[$sp]			; timed out
FFFC3ED4 01070713		add		$sp,$sp,#16
FFFC3ED8 00006813		ldi		$v0,#0
FFFC3EDC 00008067		ret		
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Get the keyboard status
                        	;
                        	; Parameters: none
                        	; Returns: r1 = status
                        	; Modifies: r1
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdGetStatus:
FFFC3EE0 00000637		ldb		$v0,KEYBD+1
FFFC3EE4 28560613
FFFC3EE8 00060633
FFFC3EEC 00060803
FFFC3EF0 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Get the scancode from the keyboard port. Getting the scancode clears the
                        	; interrupt status.
                        	;
                        	; Parameters: none
                        	; Returns: r1 = scancode
                        	; Modifies: r1
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdPeekScancode:
FFFC3EF4 00000637		ldbu		$v0,KEYBD			; get the scan code
FFFC3EF8 28460613
FFFC3EFC 00060633
FFFC3F00 00064803
FFFC3F04 00008067		ret
                        	
                        	_KeybdGetScancode:
FFFC3F08 00000637		ldbu		$v0,KEYBD			; get the scan code
FFFC3F0C 28460613
FFFC3F10 00060633
FFFC3F14 00064803
FFFC3F18 00000637		stb			$x0,KEYBD+1		; clear receive register
FFFC3F1C 28560613
FFFC3F20 00060633
FFFC3F24 00060023
FFFC3F28 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	KeybdIRQ:
FFFC3F2C FB5FF0EF		call	_KeybdGetStatus
FFFC3F30 0E085263		bge		$v0,$x0,.notKbd
FFFC3F34 FD5FF0EF		call	_KeybdGetScancode
FFFC3F38 00025637		ldo		$s1,IOFocusNdx
FFFC3F3C 81060613
FFFC3F40 00060633
FFFC3F44 00063203
FFFC3F48 0C020663		beqz	$s1,.notKbd
FFFC3F4C 30024D03		ldbu	$t0,TCBKbdHead[$s1]
FFFC3F50 30124D83		ldbu	$t1,TCBKbdTail[$s1]
FFFC3F54 001D0D13		add		$t0,$t0,#1
FFFC3F58 01FD7D13		and		$t0,$t0,#31
FFFC3F5C 01BD0663		beq		$t0,$t1,.noRoom
FFFC3F60 31A20023		stb		$t0,TCBKbdHead[$s1]
FFFC3F64 31020423		stb		$v0,TCBKbdBuf[$s1]
                        	.noRoom:
                        		; check trigger debugger
                        		; check CTRL-C
FFFC3F68 00000637		lbu		$t0,TCBKbdState2
FFFC3F6C 29960613
FFFC3F70 00060633
FFFC3F74 00064D03
FFFC3F78 004D7D93		and		$t1,$t0,#4
FFFC3F7C 020D8E63		beqz	$t1,.notCtrl
FFFC3F80 02106D13		ldi		$t0,#SC_C
FFFC3F84 01A81863		bne		$v0,$t0,.notCtrlC
FFFC3F88 00306D13		ldi		$t0,#3
FFFC3F8C 2DA23423		sto		$t0,TCBException[$s1]
FFFC3F90 02000463		bra		.0001
                        	.notCtrlC:
FFFC3F94 01A06D13		ldi		$t0,#SC_Z
FFFC3F98 03A81063		bne		$v0,$t0,.notCtrlZ
FFFC3F9C 01A06D13		ldi		$t0,#26
                        		
FFFC3FA0 18101873		csrrw	v0,#$181,x0
FFFC3FA4 03F87813		and		v0,v0,#MAX_TID
FFFC3FA8 00081813	sll		$v0,$v0,#32
FFFC3FAC 01A86833		or		$v0,$v0,$t0
FFFC3FB0 2D023423		sto		$v0,TCBException[$s1]
FFFC3FB4 00000263		bra		.0001
                        	.notCtrlZ:
                        	.0001:
                        	.notCtrl:
FFFC3FB8 002D7D93		and		$t1,$t0,#2
FFFC3FBC 2E0D8163		beqz	$t1,.notAlt
FFFC3FC0 00D06D13		ldi		$t0,#SC_TAB
FFFC3FC4 01A81A63		bne		$v0,$t0,.notAltTab
FFFC3FC8 00025637		stb		$t0,SwitchIOFocus
FFFC3FCC 82060613
FFFC3FD0 00060633
FFFC3FD4 01A60023
                        	.notAltTab:
                        		; Send a message indicating a key is available
                        		; Keyboard mailbox setup yet?
FFFC3FD8 00025637		ldw		$a1,hKeybdMbx
FFFC3FDC 82260613
FFFC3FE0 00060633
FFFC3FE4 00061983
FFFC3FE8 0209C663		blt		$a1,$x0,.notKbd
                        		; If there's already a keyboard message, don't send another one.
FFFC3FEC 00599213		sll		$s1,$a1,#LOG_MBXSZ
FFFC3FF0 00020637		add		$s1,$s1,#mbxs
FFFC3FF4 00060613
FFFC3FF8 00460233
FFFC3FFC 01823D03		ldo		$t0,MBX_MQTAIL[$s1]
FFFC4000 000D1A63		bnez	$t0,.notKbd
FFFC4004 FFF06A13		ldi		$a2,#-1
FFFC4008 FFF06A93		ldi		$a3,#-1
FFFC400C FFF06B13		ldi		$a4,#-1
FFFC4010 C39FE0EF		call	FMTK_SendMsg
                        	.notKbd:
FFFC4014 79217073		csrrc	$x0,#$792,#2			; clear IRQ semaphore
FFFC4018 10000073		eret
                        	
                        	; Return -1 if there is a scancode available in the buffer.
                        	
                        	_KeybdGetBufferStatus:
                        		
FFFC401C 18101873		csrrw	v0,#$181,x0
FFFC4020 03F87813		and		v0,v0,#MAX_TID
FFFC4024 00A81213	sll		$s1,$v0,#LOG_TCBSZ
FFFC4028 3000F2F3		csrrc	$s2,#$300,#1						; disable interrupts
FFFC402C 30024D03		ldbu	$t0,TCBKbdHead[$s1]
FFFC4030 30124D83		ldbu	$t1,TCBKbdTail[$s1]
FFFC4034 30029073		csrrw	$x0,#$300,$s2						; restore interrupts
FFFC4038 01BD0663		beq		$t0,$t1,.empty
FFFC403C FFF06813		ldi		$v0,#-1
FFFC4040 00008067		ret
                        	.empty:
FFFC4044 00006813		ldi		$v0,#0
FFFC4048 00008067		ret
                        	
                        	_KeybdGetBufferedScancode:	
                        		
FFFC404C 18101873		csrrw	v0,#$181,x0
FFFC4050 03F87813		and		v0,v0,#MAX_TID
FFFC4054 00A81213	sll		$s1,$v0,#LOG_TCBSZ
FFFC4058 00006813		ldi		$v0,#0									; $v0 = scancode
FFFC405C 3000F2F3		csrrc	$s2,#$300,#1						; disable interrupts
FFFC4060 30024D03		ldbu	$t0,TCBKbdHead[$s1]
FFFC4064 30124D83		ldbu	$t1,TCBKbdTail[$s1]
FFFC4068 01BD0C63		beq		$t0,$t1,.empty					; return 0 if empty
FFFC406C 004D8D33		add		$t0,$t1,$s1							; calc pointer to buffer entry
FFFC4070 308D4803		ldbu	$v0,TCBKbdBuf[$t0]			; get buffer entry
FFFC4074 001D8D93		add		$t1,$t1,#1							; increment tail pointer
FFFC4078 01FDFD93		and		$t1,$t1,#31
FFFC407C 31B200A3		stb		$t1,TCBKbdTail[$s1]			; store tail pointer
                        	.empty:
FFFC4080 30029073		csrrw	$x0,#$300,$s2						; restore interrupts
FFFC4084 00008067		ret
                        	
                        	; Parameters:
                        	;		a0 = scancode
                        	
                        	_XlatScancode:
FFFC4088 00008067		ret
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/source/drivers/prng_driver_asm.r5a",1
                        	.file "../fmtk/source/drivers/prng_driver_asm.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2018-2020  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;
                        	;	prng_driver_asm.r5a
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	;
                        	;
                        	;------------------------------------------------------------------------------
                        	
                        	PRNGL					equ		$FFDC0C00
                        	PRNG_VALUE		equ		$00
                        	PRNG_STREAM		equ		$08
                        	
                        	.file "../fmtk/source/drivers/prng_driver_asm.r5a",33
                        			code	18
                        	;------------------------------------------------------------------------------
                        	; Initialize PRNG
                        	;------------------------------------------------------------------------------
                        	_PRNGInit:
FFFC408C 00025637			sto		$x0,_randStream
FFFC4090 83060613
FFFC4094 00060633
FFFC4098 00063023
FFFC409C FFDC1D37			ldi		$t0,#$FFDC0C00
FFFC40A0 C00D0D13
FFFC40A4 000D3423			sto		$x0,$08[$t0]			; select stream #0
FFFC40A8 88889837			ldi		$v0,#$88888888
FFFC40AC 88880813
FFFC40B0 010D3823			sto		$v0,$10[$t0]			; set initial m_z
FFFC40B4 01234837			ldi		$v0,#$01234567
FFFC40B8 56780813
FFFC40BC 010D3C23			sto		$v0,$18[$t0]			; set initial m_w
FFFC40C0 00008067			ret
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	; Seed random number generator.
                        	;
                        	; Parameters:
                        	;		$a0 - stream to seed
                        	;		$a1 - value to use as seed
                        	;		$a2 - value to use as seed
                        	; Modifies:
                        	;		$t0
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	_SeedRand:
FFFC40C4 FFDC1D37			ldi		$t0,#PRNGL
FFFC40C8 C00D0D13
FFFC40CC 00001637			sto		$a0,$0C08[$t0]		; select stream #
FFFC40D0 C0860613
FFFC40D4 01A60633
FFFC40D8 01263023
FFFC40DC 00001637			sto		$a1,$0C10[$t0]		; set initial m_z
FFFC40E0 C1060613
FFFC40E4 01A60633
FFFC40E8 01363023
FFFC40EC 00001637			sto		$a2,$0C18[$t0]		; set initial m_w
FFFC40F0 C1860613
FFFC40F4 01A60633
FFFC40F8 01463023
FFFC40FC 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a random number, and generate the next number.
                        	;
                        	; Parameters:
                        	;		$a0 = random stream number.
                        	; Returns:
                        	;		$v0 = random 32 bit number.
                        	;------------------------------------------------------------------------------
                        	
                        	_PeekRand:
FFFC4100 FFDC1637			sto		$a0,PRNGL+PRNG_STREAM	; set the stream
FFFC4104 C0860613
FFFC4108 00060633
FFFC410C 01263023
FFFC4110 FFDC1637			ldo		$v0,PRNGL+PRNG_VALUE		; get a number
FFFC4114 C0060613
FFFC4118 00060633
FFFC411C 00063803
FFFC4120 00008067			ret
                        	
                        	_GetRand:
FFFC4124 FFDC1637			sto		$a0,PRNGL+PRNG_STREAM	; set the stream
FFFC4128 C0860613
FFFC412C 00060633
FFFC4130 01263023
FFFC4134 FFDC1637			ldo		$v0,PRNGL+PRNG_VALUE		; get a number
FFFC4138 C0060613
FFFC413C 00060633
FFFC4140 00063803
FFFC4144 FFDC1637			sto		$x0,PRNGL+PRNG_VALUE		; generate next number
FFFC4148 C0060613
FFFC414C 00060633
FFFC4150 00063023
FFFC4154 00008067			ret
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/source/kernel/DBGKeybd.s",1
                        	.file "../fmtk/source/kernel/DBGKeybd.s",1
                        	.file "../fmtk/source/kernel/DBGKeybd.s",94
                        		code
FFFC4158 00000000		align	1
FFFC415C 00000000
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC4160 FE070713	public code _DBGCheckForKey:
	      	sub      	$sp,$sp,#32
FFFC4164 00273023		      	sto      	$fp,[$sp]
FFFC4168 00073423		      	sto      	$x0,8[$sp]
FFFC416C 00173C23		      	sto      	$ra,24[$sp]
FFFC4170 00076133		      	mov      	$fp,$sp
FFFC4174 D6DFF0EF		      	call     	_KeybdGetStatus
FFFC4178 00086D33		      	mov      	$t0,$v0
FFFC417C 000D6833		      	mov      	$v0,$t0
                        	DBGKeybd_5:
                        	DBGKeybd_8:
FFFC4180 00016733		      	mov      	$sp,$fp
FFFC4184 00073103		      	ldo      	$fp,[$sp]
FFFC4188 01873083		      	ldo      	$ra,24[$sp]
FFFC418C 02070713		      	add      	$sp,$sp,#32
FFFC4190 00008067		      	ret      
                        	endpublic
                        	
                        	.file "../fmtk/source/kernel/DBGKeybd.s",119
                        		code
FFFC4194 00000000		align	1
FFFC4198 00000000
FFFC419C 00000000
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC41A0 FE070713	public code _DBGGetKey:
	      	sub      	$sp,$sp,#32
FFFC41A4 00273023		      	sto      	$fp,[$sp]
FFFC41A8 00073423		      	sto      	$x0,8[$sp]
FFFC41AC 00173C23		      	sto      	$ra,24[$sp]
FFFC41B0 00076133		      	mov      	$fp,$sp
FFFC41B4 FC270713		      	sub      	$sp,$sp,#62
FFFC41B8 00473023		      	sto      	$s1,0[$sp]
FFFC41BC 00573423		      	sto      	$s2,8[$sp]
FFFC41C0 00673823		      	sto      	$s3,16[$sp]
FFFC41C4 00773C23		      	sto      	$s4,24[$sp]
FFFC41C8 FEE13203		      	ldo      	$s1,-18[$fp]
FFFC41CC FF710283		      	ldb      	$s2,-9[$fp]
FFFC41D0 FF813303		      	ldo      	$s3,-8[$fp]
FFFC41D4 0000A3B7		      	ldi      	$s4,#40000
FFFC41D8 C4038393
                        	DBGKeybd_66:
                        	; 		for (count = 0; (KeybdGetStatus() & 0x40) != 0 && count < 40000; count++);
FFFC41DC 00006233		      	mov      	$s1,$x0
FFFC41E0 D01FF0EF		      	call     	_KeybdGetStatus
FFFC41E4 00086DB3		      	mov      	$t1,$v0
FFFC41E8 040DFD13		      	and      	$t0,$t1,#64
FFFC41EC 020D0063		      	beq      	$t0,$x0,DBGKeybd_69
FFFC41F0 00725E63		      	bge      	$s1,$s4,DBGKeybd_69
                        	DBGKeybd_68:
FFFC41F4 00120213		      	add      	$s1,$s1,#1
FFFC41F8 CE9FF0EF		      	call     	_KeybdGetStatus
FFFC41FC 00086DB3		      	mov      	$t1,$v0
FFFC4200 040DFD13		      	and      	$t0,$t1,#64
FFFC4204 000D0463		      	beq      	$t0,$x0,DBGKeybd_71
FFFC4208 FE7246E3		      	blt      	$s1,$s4,DBGKeybd_68
                        	DBGKeybd_71:
                        	DBGKeybd_69:
                        	; 		while ((KeybdGetStatus() & 0x80) == 0) {
FFFC420C CD5FF0EF		      	call     	_KeybdGetStatus
FFFC4210 00086DB3		      	mov      	$t1,$v0
FFFC4214 080DFD13		      	and      	$t0,$t1,#128
FFFC4218 040D1063		      	bne      	$t0,$x0,DBGKeybd_73
                        	DBGKeybd_72:
                        	; 			if (!block)
FFFC421C 02091663		      	bne      	$a0,$x0,DBGKeybd_74
                        	; 				return (-1);
FFFC4220 FFF06813		      	ldi      	$v0,#-1
                        	DBGKeybd_62:
                        	DBGKeybd_65:
FFFC4224 00073203		      	ldo      	$s1,0[$sp]
FFFC4228 00873283		      	ldo      	$s2,8[$sp]
FFFC422C 01073303		      	ldo      	$s3,16[$sp]
FFFC4230 01873383		      	ldo      	$s4,24[$sp]
FFFC4234 00016733		      	mov      	$sp,$fp
FFFC4238 00073103		      	ldo      	$fp,[$sp]
FFFC423C 01873083		      	ldo      	$ra,24[$sp]
FFFC4240 02070713		      	add      	$sp,$sp,#32
FFFC4244 00008067		      	ret      
                        	DBGKeybd_74:
FFFC4248 C99FF0EF		      	call     	_KeybdGetStatus
FFFC424C 00086DB3		      	mov      	$t1,$v0
FFFC4250 080DFD13		      	and      	$t0,$t1,#128
FFFC4254 FC0D04E3		      	beq      	$t0,$x0,DBGKeybd_72
                        	DBGKeybd_73:
                        	; 		sc = KeybdGetScancode() & 0xff;
FFFC4258 CB1FF0EF		      	call     	_KeybdGetScancode
FFFC425C 00086DB3		      	mov      	$t1,$v0
FFFC4260 0FFDFD13		      	and      	$t0,$t1,#255
FFFC4264 000D6333		      	mov      	$s3,$t0
                        	; 		for (count = 0; count < 20; count++)
FFFC4268 00006233		      	mov      	$s1,$x0
FFFC426C 01422D13		      	slt      	$t0,$s1,#20
FFFC4270 000D0863		      	beqz     	$t0,DBGKeybd_77
                        	DBGKeybd_76:
                        	; 			;
FFFC4274 00120213		      	add      	$s1,$s1,#1
FFFC4278 01422D13		      	slt      	$t0,$s1,#20
FFFC427C FE0D1CE3		      	bnez     	$t0,DBGKeybd_76
                        	DBGKeybd_77:
                        	; 	  case 0xF0:
FFFC4280 0F034D13		      	xor      	$t0,$s3,#240
FFFC4284 040D0063		      	beq      	$t0,$x0,DBGKeybd_90
                        	; 	  case 0xE0:
FFFC4288 0E034D13		      	xor      	$t0,$s3,#224
FFFC428C 040D0863		      	beq      	$t0,$x0,DBGKeybd_91
                        	; 	  case 0x14:
FFFC4290 01434D13		      	xor      	$t0,$s3,#20
FFFC4294 060D0863		      	beq      	$t0,$x0,DBGKeybd_92
                        	; 	  case 0x59:
FFFC4298 05934D13		      	xor      	$t0,$s3,#89
FFFC429C 0C0D0E63		      	beq      	$t0,$x0,DBGKeybd_93
                        	; 	  case 0x77:
FFFC42A0 07734D13		      	xor      	$t0,$s3,#119
FFFC42A4 140D0463		      	beq      	$t0,$x0,DBGKeybd_94
                        	; 	  case 0x58:
FFFC42A8 05834D13		      	xor      	$t0,$s3,#88
FFFC42AC 1A0D0063		      	beq      	$t0,$x0,DBGKeybd_95
                        	; 	  case 0x7E:
FFFC42B0 07E34D13		      	xor      	$t0,$s3,#126
FFFC42B4 1E0D0C63		      	beq      	$t0,$x0,DBGKeybd_96
                        	; 	  case 0x11:
FFFC42B8 01134D13		      	xor      	$t0,$s3,#17
FFFC42BC 240D0863		      	beq      	$t0,$x0,DBGKeybd_97
                        	; 	  default:
FFFC42C0 2C000063		      	bra      	DBGKeybd_98
                        	DBGKeybd_90:
                        	;       KeyState1 = -1;
FFFC42C4 FFF06D13		      	ldi      	$t0,#-1
FFFC42C8 00025637		      	stb      	$t0,_KeyState1
FFFC42CC 82460613
FFFC42D0 00060633
FFFC42D4 01A60023
                        	;       break;
FFFC42D8 3C000663		      	bra      	DBGKeybd_79
                        	DBGKeybd_91:
                        	;       KeyState2 |= 0x80;
FFFC42DC 00025637		      	ldb      	$t0,_KeyState2
FFFC42E0 82560613
FFFC42E4 00060633
FFFC42E8 00060D03
FFFC42EC 080D6D13		      	or       	$t0,$t0,#128
FFFC42F0 00025637		      	stb      	$t0,_KeyState2
FFFC42F4 82560613
FFFC42F8 00060633
FFFC42FC 01A60023
                        	;       break;
FFFC4300 3A000263		      	bra      	DBGKeybd_79
                        	DBGKeybd_92:
                        	;       if (KeyState1 >= 0)
FFFC4304 00025637		      	ldb      	$t0,_KeyState1
FFFC4308 82460613
FFFC430C 00060633
FFFC4310 00060D03
FFFC4314 020D4663		      	blt      	$t0,$x0,DBGKeybd_99
                        	;         KeyState2 |= 4;
FFFC4318 00025637		      	ldb      	$t0,_KeyState2
FFFC431C 82560613
FFFC4320 00060633
FFFC4324 00060D03
FFFC4328 004D6D13		      	or       	$t0,$t0,#4
FFFC432C 00025637		      	stb      	$t0,_KeyState2
FFFC4330 82560613
FFFC4334 00060633
FFFC4338 01A60023
FFFC433C 02000463		      	bra      	DBGKeybd_100
                        	DBGKeybd_99:
                        	;         KeyState2 &= ~4;
FFFC4340 00025637		      	ldb      	$t0,_KeyState2
FFFC4344 82560613
FFFC4348 00060633
FFFC434C 00060D03
FFFC4350 FFBD7D13		      	and      	$t0,$t0,#-5
FFFC4354 00025637		      	stb      	$t0,_KeyState2
FFFC4358 82560613
FFFC435C 00060633
FFFC4360 01A60023
                        	DBGKeybd_100:
                        	;       KeyState1 = 0;
FFFC4364 00025637		      	stb      	$x0,_KeyState1
FFFC4368 82460613
FFFC436C 00060633
FFFC4370 00060023
                        	;       break;
FFFC4374 32000863		      	bra      	DBGKeybd_79
                        	DBGKeybd_93:
                        	;       if (KeyState1 >= 0)
FFFC4378 00025637		      	ldb      	$t0,_KeyState1
FFFC437C 82460613
FFFC4380 00060633
FFFC4384 00060D03
FFFC4388 020D4663		      	blt      	$t0,$x0,DBGKeybd_101
                        	;         KeyState2 |= 1;
FFFC438C 00025637		      	ldb      	$t0,_KeyState2
FFFC4390 82560613
FFFC4394 00060633
FFFC4398 00060D03
FFFC439C 001D6D13		      	or       	$t0,$t0,#1
FFFC43A0 00025637		      	stb      	$t0,_KeyState2
FFFC43A4 82560613
FFFC43A8 00060633
FFFC43AC 01A60023
FFFC43B0 02000463		      	bra      	DBGKeybd_102
                        	DBGKeybd_101:
                        	;         KeyState2 &= ~1;
FFFC43B4 00025637		      	ldb      	$t0,_KeyState2
FFFC43B8 82560613
FFFC43BC 00060633
FFFC43C0 00060D03
FFFC43C4 FFED7D13		      	and      	$t0,$t0,#-2
FFFC43C8 00025637		      	stb      	$t0,_KeyState2
FFFC43CC 82560613
FFFC43D0 00060633
FFFC43D4 01A60023
                        	DBGKeybd_102:
                        	;       KeyState1 = 0;
FFFC43D8 00025637		      	stb      	$x0,_KeyState1
FFFC43DC 82460613
FFFC43E0 00060633
FFFC43E4 00060023
                        	;       break;
FFFC43E8 2A000E63		      	bra      	DBGKeybd_79
                        	DBGKeybd_94:
                        	;       KeyState2 ^= 16;
FFFC43EC 00025637		      	ldb      	$t0,_KeyState2
FFFC43F0 82560613
FFFC43F4 00060633
FFFC43F8 00060D03
FFFC43FC 010D4D13		      	xor      	$t0,$t0,#16
FFFC4400 00025637		      	stb      	$t0,_KeyState2
FFFC4404 82560613
FFFC4408 00060633
FFFC440C 01A60023
                        	;       KeyLED ^= 2;
FFFC4410 00025637		      	ldb      	$t0,_KeyLED
FFFC4414 82660613
FFFC4418 00060633
FFFC441C 00060D03
FFFC4420 002D4D13		      	xor      	$t0,$t0,#2
FFFC4424 00025637		      	stb      	$t0,_KeyLED
FFFC4428 82660613
FFFC442C 00060633
FFFC4430 01A60023
                        	;       KeybdSetLED(KeyLED);
FFFC4434 00025637		      	ldb      	$a0,_KeyLED
FFFC4438 82660613
FFFC443C 00060633
FFFC4440 00060903
FFFC4444 939FF0EF		      	call     	_KeybdSetLED
                        	;       break;
FFFC4448 24000E63		      	bra      	DBGKeybd_79
                        	DBGKeybd_95:
                        	;       KeyState2 ^= 32;
FFFC444C 00025637		      	ldb      	$t0,_KeyState2
FFFC4450 82560613
FFFC4454 00060633
FFFC4458 00060D03
FFFC445C 020D4D13		      	xor      	$t0,$t0,#32
FFFC4460 00025637		      	stb      	$t0,_KeyState2
FFFC4464 82560613
FFFC4468 00060633
FFFC446C 01A60023
                        	;       KeyLED ^= 4;
FFFC4470 00025637		      	ldb      	$t0,_KeyLED
FFFC4474 82660613
FFFC4478 00060633
FFFC447C 00060D03
FFFC4480 004D4D13		      	xor      	$t0,$t0,#4
FFFC4484 00025637		      	stb      	$t0,_KeyLED
FFFC4488 82660613
FFFC448C 00060633
FFFC4490 01A60023
                        	;       KeybdSetLED(KeyLED);
FFFC4494 00025637		      	ldb      	$a0,_KeyLED
FFFC4498 82660613
FFFC449C 00060633
FFFC44A0 00060903
FFFC44A4 8D9FF0EF		      	call     	_KeybdSetLED
                        	;       break;
FFFC44A8 1E000E63		      	bra      	DBGKeybd_79
                        	DBGKeybd_96:
                        	;       KeyState2 ^= 64;
FFFC44AC 00025637		      	ldb      	$t0,_KeyState2
FFFC44B0 82560613
FFFC44B4 00060633
FFFC44B8 00060D03
FFFC44BC 040D4D13		      	xor      	$t0,$t0,#64
FFFC44C0 00025637		      	stb      	$t0,_KeyState2
FFFC44C4 82560613
FFFC44C8 00060633
FFFC44CC 01A60023
                        	;       KeyLED ^= 1;
FFFC44D0 00025637		      	ldb      	$t0,_KeyLED
FFFC44D4 82660613
FFFC44D8 00060633
FFFC44DC 00060D03
FFFC44E0 001D4D13		      	xor      	$t0,$t0,#1
FFFC44E4 00025637		      	stb      	$t0,_KeyLED
FFFC44E8 82660613
FFFC44EC 00060633
FFFC44F0 01A60023
                        	;       KeybdSetLED(KeyLED);
FFFC44F4 00025637		      	ldb      	$a0,_KeyLED
FFFC44F8 82660613
FFFC44FC 00060633
FFFC4500 00060903
FFFC4504 879FF0EF		      	call     	_KeybdSetLED
                        	;       break;
FFFC4508 18000E63		      	bra      	DBGKeybd_79
                        	DBGKeybd_97:
                        	;       if (KeyState1 >= 0)
FFFC450C 00025637		      	ldb      	$t0,_KeyState1
FFFC4510 82460613
FFFC4514 00060633
FFFC4518 00060D03
FFFC451C 020D4663		      	blt      	$t0,$x0,DBGKeybd_103
                        	;         KeyState2 |= 2;
FFFC4520 00025637		      	ldb      	$t0,_KeyState2
FFFC4524 82560613
FFFC4528 00060633
FFFC452C 00060D03
FFFC4530 002D6D13		      	or       	$t0,$t0,#2
FFFC4534 00025637		      	stb      	$t0,_KeyState2
FFFC4538 82560613
FFFC453C 00060633
FFFC4540 01A60023
FFFC4544 02000463		      	bra      	DBGKeybd_104
                        	DBGKeybd_103:
                        	;         KeyState2 &= ~2;
FFFC4548 00025637		      	ldb      	$t0,_KeyState2
FFFC454C 82560613
FFFC4550 00060633
FFFC4554 00060D03
FFFC4558 FFDD7D13		      	and      	$t0,$t0,#-3
FFFC455C 00025637		      	stb      	$t0,_KeyState2
FFFC4560 82560613
FFFC4564 00060633
FFFC4568 01A60023
                        	DBGKeybd_104:
                        	;       KeyState1 = 0;
FFFC456C 00025637		      	stb      	$x0,_KeyState1
FFFC4570 82460613
FFFC4574 00060633
FFFC4578 00060023
                        	;       break;
FFFC457C 12000463		      	bra      	DBGKeybd_79
                        	DBGKeybd_98:
                        	; 				if (KeyState1) {
FFFC4580 00025637		      	ldb      	$t0,_KeyState1
FFFC4584 82460613
FFFC4588 00060633
FFFC458C 00060D03
FFFC4590 000D0C63		      	beq      	$t0,$x0,DBGKeybd_105
                        	; 					KeyState1 = 0;
FFFC4594 00025637		      	stb      	$x0,_KeyState1
FFFC4598 82460613
FFFC459C 00060633
FFFC45A0 00060023
FFFC45A4 10000063		      	bra      	DBGKeybd_106
                        	DBGKeybd_105:
                        	; 					if (((KeyState2 & 0x06)==0x06) && sc==0x71) {
FFFC45A8 00025637		      	ldb      	$t1,_KeyState2
FFFC45AC 82560613
FFFC45B0 00060633
FFFC45B4 00060D83
FFFC45B8 006DFD13		      	and      	$t0,$t1,#6
FFFC45BC 006D4D93		      	xor      	$t1,$t0,#6
FFFC45C0 000D9C63		      	bnez     	$t1,DBGKeybd_107
FFFC45C4 07134D13		      	xor      	$t0,$s3,#113
FFFC45C8 000D1863		      	bnez     	$t0,DBGKeybd_107
                        	; 						__asm {
                        		      	;asm     	
FFFC45CC 00000637				jmp		$FFFC0100
FFFC45D0 2CB60067
                        	; 						}
FFFC45D4 0C000863		      	bra      	DBGKeybd_108
                        	DBGKeybd_107:
                        	; 					else if (KeyState2 & 0x80) { // Extended code ?
FFFC45D8 00025637		      	ldb      	$t1,_KeyState2
FFFC45DC 82560613
FFFC45E0 00060633
FFFC45E4 00060D83
FFFC45E8 080DFD13		      	and      	$t0,$t1,#128
FFFC45EC 040D0063		      	beq      	$t0,$x0,DBGKeybd_109
                        	; 						KeyState2 &= ~0x80;
FFFC45F0 00025637		      	ldb      	$t0,_KeyState2
FFFC45F4 82560613
FFFC45F8 00060633
FFFC45FC 00060D03
FFFC4600 F7FD7D13		      	and      	$t0,$t0,#-129
FFFC4604 00025637		      	stb      	$t0,_KeyState2
FFFC4608 82560613
FFFC460C 00060633
FFFC4610 01A60023
                        	; 						ch = keybdExtendedCodes[sc];
FFFC4614 FFFC4637		      	ldb      	$s2,_keybdExtendedCodes[$s3]
FFFC4618 AD060613
FFFC461C 00660633
FFFC4620 00060283
                        	; 						return (ch);
FFFC4624 0002E833		      	mov      	$v0,$s2
FFFC4628 BE000EE3		      	bra      	DBGKeybd_65
                        	DBGKeybd_109:
                        	; 					else if (KeyState2 & 0x04) { // control ?
FFFC462C 00025637		      	ldb      	$t1,_KeyState2
FFFC4630 82560613
FFFC4634 00060633
FFFC4638 00060D83
FFFC463C 004DFD13		      	and      	$t0,$t1,#4
FFFC4640 000D0E63		      	beq      	$t0,$x0,DBGKeybd_111
                        	; 						ch = keybdControlCodes[sc];
FFFC4644 FFFC4637		      	ldb      	$s2,_keybdControlCodes[$s3]
FFFC4648 A5060613
FFFC464C 00660633
FFFC4650 00060283
                        	; 						return (ch);
FFFC4654 0002E833		      	mov      	$v0,$s2
FFFC4658 BC0006E3		      	bra      	DBGKeybd_65
                        	DBGKeybd_111:
                        	; 					else if (KeyState2 & 0x01) { // shifted ?
FFFC465C 00025637		      	ldb      	$t1,_KeyState2
FFFC4660 82560613
FFFC4664 00060633
FFFC4668 00060D83
FFFC466C 001DFD13		      	and      	$t0,$t1,#1
FFFC4670 000D0E63		      	beq      	$t0,$x0,DBGKeybd_113
                        	; 						ch = shiftedScanCodes[sc];
FFFC4674 FFFC4637		      	ldb      	$s2,_shiftedScanCodes[$s3]
FFFC4678 95060613
FFFC467C 00660633
FFFC4680 00060283
                        	; 						return (ch);
FFFC4684 0002E833		      	mov      	$v0,$s2
FFFC4688 B8000EE3		      	bra      	DBGKeybd_65
                        	DBGKeybd_113:
                        	; 						ch = unshiftedScanCodes[sc];
FFFC468C FFFC4637		      	ldb      	$s2,_unshiftedScanCodes[$s3]
FFFC4690 85060613
FFFC4694 00660633
FFFC4698 00060283
                        	; 						return (ch);
FFFC469C 0002E833		      	mov      	$v0,$s2
FFFC46A0 B80002E3		      	bra      	DBGKeybd_65
                        	DBGKeybd_108:
                        	DBGKeybd_106:
                        	DBGKeybd_79:
FFFC46A4 B2000CE3		      	bra      	DBGKeybd_66
                        	endpublic
                        	
                        	.file "TinyBasic.r5a",84
                        			code
FFFC46A8 00000000			align	25
FFFC46AC 00000000
FFFC46B0 00000000
FFFC46B4 00000000
FFFC46B8 00000000
FFFC46BC 00000000
FFFC46C0 00000000
FFFC46C4 00000000
FFFC46C8 00000000
FFFC46CC 00000000
FFFC46D0 00000000
FFFC46D4 00000000
FFFC46D8 00000000
FFFC46DC 00000000
FFFC46E0 00000000
FFFC46E4 00000000
FFFC46E8 00000000
FFFC46EC 00000000
FFFC46F0 00000000
FFFC46F4 00000000
FFFC46F8 00000000
FFFC46FC 00000000
                        	
                        	;
                        	; Standard jump table. You can change these addresses if you are
                        	; customizing this interpreter for a different environment.
                        	;
                        	TinyBasic:
                        	GOSTART:	
FFFC4700 0300006F			jmp	CSTART	;	Cold Start entry point
                        	GOWARM:	
FFFC4704 1200006F			jmp	WSTART	;	Warm Start entry point
                        	GOOUT:	
FFFC4708 17C0206F			jmp	OUTC	;	Jump to character-out routine
                        	GOIN:	
FFFC470C 17C0206F			jmp	INCH	;Jump to character-in routine
                        	GOAUXO:	
FFFC4710 00000637			jmp	AUXOUT	;	Jump to auxiliary-out routine
FFFC4714 2D960067
                        	GOAUXI:	
FFFC4718 00000637			jmp	AUXIN	;	Jump to auxiliary-in routine
FFFC471C 2DB60067
                        	GOBYE:	
FFFC4720 1980206F			jmp	BYEBYE	;	Jump to monitor, DOS, etc.
                        	
FFFC4724 00000000		align	1
FFFC4728 00000000
FFFC472C 00000000
                        	
                        	//message "CSTART"
FFFC4730 930FC0EF	public CSTART:
	call	DumpMemmap
                        		; First save off the link register and OS sp value
FFFC4734 00030637		sto		$sp,OSSP
FFFC4738 00060613
FFFC473C 00060633
FFFC4740 00E63023
FFFC4744 AFFFC737		ldi		$sp,#STACKOFFS	; initialize stack pointer
FFFC4748 00070713
FFFC474C 00E06913		ldi		$a0,#14							; Get current tid
FFFC4750 00000073		ecall
FFFC4754 0008E9B3		mov		$a1,$v1
FFFC4758 01806913		ldi		$a0,#24							; RequestIOFocus
FFFC475C 00000073		ecall
                        	;	call	_DBGHomeCursor[pc]
FFFC4760 00006933		mov		a0,r0			; turn off keyboard echoing
                        	//	call	SetKeyboardEcho
                        	//	stz		CursorFlash
                        	//	ldx		#0x10000020	; black chars, yellow background
                        	;	stx		charToPrint
                        	;	call	_DBGClearScreen[pc]
FFFC4764 FFFC7937		ldi		a0,#msgInit	;	tell who we are
FFFC4768 8CC90913
FFFC476C 71D010EF		call	PRMESG
FFFC4770 00032937		ldi		a0,#TXTBGN	;	init. end-of-program pointer
FFFC4774 80090913
FFFC4778 00030637		sw		a0,TXTUNF
FFFC477C 00460613
FFFC4780 00060633
FFFC4784 01262023
FFFC4788 00040937		ldi		a0,#ENDMEM	;	get address of end of memory
FFFC478C FFC90913
FFFC4790 00080937		ldi		a0,#$7F800
FFFC4794 80090913
FFFC4798 00030637		sw		a0,STKBOT
FFFC479C 09C60613
FFFC47A0 00060633
FFFC47A4 01262023
FFFC47A8 00040937		ldi		a0,#ENDMEM
FFFC47AC FFC90913
FFFC47B0 00030637		sw		a0,VAREND
FFFC47B4 00C60613
FFFC47B8 00060633
FFFC47BC 01262023
FFFC47C0 CE090913		sub		a0,a0,#800 	;   100 vars
FFFC47C4 00030637		sw    a0,VARBGN
FFFC47C8 00860613
FFFC47CC 00060633
FFFC47D0 01262023
FFFC47D4 598000EF		call  clearVars   ; clear the variable area
FFFC47D8 00030637		sw		r0,IRQROUT
FFFC47DC 0A460613
FFFC47E0 00060633
FFFC47E4 00062023
FFFC47E8 00030637		lw    a0,VARBGN   ; calculate number of bytes free
FFFC47EC 00860613
FFFC47F0 00060633
FFFC47F4 00062903
FFFC47F8 00030637		lw		a1,TXTUNF
FFFC47FC 00460613
FFFC4800 00060633
FFFC4804 00062983
FFFC4808 41390933		sub   a0,a0,a1
FFFC480C 00606993		ldi		a1,#6		; max 6 digits
FFFC4810 00A06A13		ldi		a2,#10	; base 10
FFFC4814 399010EF		call  PRTNUM
FFFC4818 FFFC7937		ldi		a0,#msgBytesFree
FFFC481C 96D90913
FFFC4820 669010EF		call	PRMESG
                        	WSTART:
FFFC4824 00030637		sw		x0,LOPVAR   ; initialize internal variables
FFFC4828 01060613
FFFC482C 00060633
FFFC4830 00062023
FFFC4834 00030637		sw		x0,STKGOS
FFFC4838 01460613
FFFC483C 00060633
FFFC4840 00062023
FFFC4844 00030637		sw		x0,CURRNT	;	current line number pointer = 0
FFFC4848 01860613
FFFC484C 00060633
FFFC4850 00062023
FFFC4854 AFFFC737		ldi		$sp,#STACKOFFS	;	init S.P. again, just in case
FFFC4858 00070713
FFFC485C FFFC7937		ldi		a0,#msgReady	;	display "Ready"
FFFC4860 97A90913
FFFC4864 625010EF		call	PRMESG
                        	BASPRMPT:
FFFC4868 00E06913		ldi		a0,#14		; get current tid
FFFC486C 00000073		ecall
FFFC4870 0008E933		mov		a0,v1
FFFC4874 F1DFB0EF		call	PutHexByte
FFFC4878 03E06913		ldi		a0,#'>'		; Prompt with a '>' and
FFFC487C 758010EF		call	GETLN		; read a line.
FFFC4880 555010EF		call	TOUPBUF 	; convert to upper case
FFFC4884 000E64B3		mov		$s6,$t2		; save pointer to end of line
FFFC4888 00030E37		ldi		$t2,#BUFFER	; point to the beginning of line
FFFC488C 01CE0E13
FFFC4890 4A1010EF		call	TSTNUM		; is there a number there?
FFFC4894 511010EF		call	IGNBLK		; skip trailing blanks
FFFC4898 000E4483		lbu		$s6,[$t2]
FFFC489C 00D4C493		xor		$s6,$s6,#CR	; s6 = flag empty line
                        	; does line no. exist? (or nonzero?)
FFFC48A0 2C088063		beq		v1,x0,DIRECT		; if not, it's a direct statement
FFFC48A4 00100DB7		ldi		$t1,#$FFFFF
FFFC48A8 FFFD8D93
FFFC48AC 010DD863		ble		v0,$t1,ST2	; see if line no. is <= 16 bits
FFFC48B0 FFFC7937		ldi		a0,#msgLineRange	; if not, we've overflowed
FFFC48B4 99590913
FFFC48B8 6C00106F		jmp		ERROR
                        	ST2:
FFFC48BC 00086933	  mov		$a0,$v0		; a0 = line number
FFFC48C0 000E6433	  mov		$s5,$t2			; save line buffer pointer
FFFC48C4 FFCE0E13		sub		$t2,$t2,#4
FFFC48C8 012E2023	  sw		$a0,[$t2]		;	This will end up in buffer
FFFC48CC 015010EF		call	FNDLN		; find this line in save area
FFFC48D0 000EE533		mov		$s7,$t3		; save possible line pointer
FFFC48D4 00080663		beq		$v0,$x0,INSLINE	; if not found, insert
FFFC48D8 000EE933		mov		$a0,$t3
FFFC48DC 044000EF		call	DeleteLine
                        	INSLINE:
FFFC48E0 F80484E3		beq		$s6,$x0,BASPRMPT	; line was empty
FFFC48E4 00046933		mov		$a0,$s5			; a0 = buffer pointer	
                        		; GetBuflen just get the length of the text.
                        		; A line number is stuffed just before the text
                        		; so length needs to be adjusted by 4.
FFFC48E8 0B8000EF		call	GetBuflen
FFFC48EC 00480393		add		$s4,$v0,#4
FFFC48F0 00056933		mov		$a0,$s7
FFFC48F4 0003E9B3		mov		$a1,$s4
FFFC48F8 0D4000EF		call	OpenSpace
FFFC48FC 00081863		bne		$v0,$x0,.0001	; space available?
FFFC4900 FFFC7937		ldi		a0,#msgTooBig	; no space available
FFFC4904 A6790913
FFFC4908 6700106F		jmp		ERROR
                        	.0001:
FFFC490C 00056933		mov		$a0,$s7			; target
FFFC4910 FFC40993		sub		$a1,$s5,#4	; source (incl lineno)
FFFC4914 0003EA33		mov		$a2,$s4			; length
FFFC4918 068000EF		call	InsertLine
FFFC491C F40006E3		bra		BASPRMPT
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = pointer to line to delete
                        	; Modifies:
                        	;		t0,t1,t2,t3
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	DeleteLine:
                        		; Find the end of the line to delete
FFFC4920 00490D13		add		$t0,$a0,#4		; t0 = pointer to line past line number
FFFC4924 00D06E13		ldi		$t2,#CR
FFFC4928 00030637		lw		$t3,TXTUNF		; last text address
FFFC492C 00460613
FFFC4930 00060633
FFFC4934 00062E83
                        	.0002:
FFFC4938 000D4D83		lbu		$t1,[$t0]
FFFC493C 000D8A63		beq		$t1,$x0,.0003	; might be null
FFFC4940 01CD8663		beq		$t1,$t2,.0001	; lines end with CR
FFFC4944 001D0D13		add		$t0,$t0,#1
FFFC4948 FFDD68E3		bltu	$t0,$t3,.0002	; end of program?
                        	.0001:
FFFC494C 001D0D13		add		$t0,$t0,#1
                        	.0003:
                        		; pull text after eol overtop
FFFC4950 000D4F03		lbu		$t4,[$t0]			; copy from next line
FFFC4954 01E90023		sb		$t4,[$a0]			; overtop deleted line
FFFC4958 001D0D13		add		$t0,$t0,#1		; increment pointers
FFFC495C 00190913		add		$a0,$a0,#1
FFFC4960 FFAEF8E3		bleu	$t0,$t3,.0003	; to end of program
                        		; update end of text
FFFC4964 412D0933		sub		$a0,$t0,$a0		; difference of pointers = length
FFFC4968 412E8EB3		sub		$t3,$t3,$a0		
FFFC496C 00030637		sw		$t3,TXTUNF
FFFC4970 00460613
FFFC4974 00060633
FFFC4978 01D62023
FFFC497C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = insertion point
                        	; 	a1 = source buffer
                        	; 	a2 = length
                        	; Modifies:
                        	;		a0,a1,a2,t1
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	InsertLine:
FFFC4980 000A0E63		beq		$a2,$x0,.done		; zero length? Probably a SW error
                        	.0001:
FFFC4984 0009CD83		lbu		$t1,[$a1]				; get from source text
FFFC4988 01B90023		sb		$t1,[$a0]				; store to insertion point
FFFC498C 00198993		add		$a1,$a1,#1			; increment pointers
FFFC4990 00190913		add		$a0,$a0,#1
FFFC4994 FFFA0A13		sub		$a2,$a2,#1			; decrement length
FFFC4998 FF4066E3		bgtu	$a2,$x0,.0001
                        	.done:
FFFC499C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; GetBuflen - get the length of text in a buffer. The length is taken up to
                        	; the first null character or carriage return character encountered.
                        	;
                        	; Parameters:
                        	;		a0 = pointer to buffer
                        	; Modifies:
                        	;		t2,t3,t5
                        	; Returns:
                        	;		v0 = length of data in buffer
                        	;------------------------------------------------------------------------------
                        	
                        	GetBuflen:
FFFC49A0 00006813		ldi		$v0,#0
FFFC49A4 00D06E93		ldi		$t3,#CR
FFFC49A8 00096FB3		mov		$t5,$a0
                        	.0002:
FFFC49AC 000FCE03		lbu		$t2,[$t5]
FFFC49B0 001F8F93		add		$t5,$t5,#1
FFFC49B4 000E0A63		beq		$t2,$x0,.0001
FFFC49B8 01DE0663		beq		$t2,$t3,.0004
FFFC49BC 00180813		add		$v0,$v0,#1
FFFC49C0 FE0006E3		bra		.0002
                        	.0004:
FFFC49C4 00180813		add		$v0,$v0,#1
                        	.0001:
FFFC49C8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = place to insert line
                        	; 	a1 = buffer length
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		v0 = 1 if successful, 0 if not enough room available
                        	;------------------------------------------------------------------------------
                        	
                        	OpenSpace:
FFFC49CC 00030637		lw		$t2,TXTUNF
FFFC49D0 00460613
FFFC49D4 00060633
FFFC49D8 00062E03
FFFC49DC 000E6EB3		mov		$t3,$t2				; t3 = old end of text
FFFC49E0 013E0E33		add		$t2,$t2,$a1		; increment end of text by buffer length
FFFC49E4 00030637		lw		$t1,VARBGN		; compare to start of variables
FFFC49E8 00860613
FFFC49EC 00060633
FFFC49F0 00062D83
FFFC49F4 03BE7863		bgeu	$t2,$t1,.noSpace	; enough room?
FFFC49F8 00030637		sw		$t2,TXTUNF		; yes, set new end of text
FFFC49FC 00460613
FFFC4A00 00060633
FFFC4A04 01C62023
                        	.0003:
FFFC4A08 000ECF83		lbu		$t5,[$t3]			; copy old text
FFFC4A0C 01FE0023		sb		$t5,[$t2]			; to new text loc
FFFC4A10 FFFE8E93		sub		$t3,$t3,#1		; decrement pointers
FFFC4A14 FFFE0E13		sub		$t2,$t2,#1
FFFC4A18 FF2EF8E3		bgeu	$t3,$a0,.0003	; until insert point reached
FFFC4A1C 00106813		ldi		$v0,#1				; return success
FFFC4A20 00008067		ret
                        	.noSpace:
FFFC4A24 00006813		ldi		$v0,#0
FFFC4A28 00008067		ret	
                        	
                        	;******************************************************************
                        	;
                        	; *** Tables *** DIRECT *** EXEC ***
                        	;
                        	; This section of the code tests a string against a table. When
                        	; a match is found, control is transferred to the section of
                        	; code according to the table.
                        	;
                        	; At 'EXEC', r8 should point to the string, r9 should point to
                        	; the character table, and r10 should point to the execution
                        	; table. At 'DIRECT', r8 should point to the string, r9 and
                        	; r10 will be set up to point to TAB1 and TAB1_1, which are
                        	; the tables of all direct and statement commands.
                        	;
                        	; A '.' in the string will terminate the test and the partial
                        	; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                        	; 'PRIN.', or 'PRINT' will all match 'PRINT'.
                        	;
                        	; There are two tables: the character table and the execution
                        	; table. The character table consists of any number of text items.
                        	; Each item is a string of characters with the last character's
                        	; high bit set to one. The execution table holds a 32-bit
                        	; execution addresses that correspond to each entry in the
                        	; character table.
                        	;
                        	; The end of the character table is a 0 byte which corresponds
                        	; to the default routine in the execution table, which is
                        	; executed if none of the other table items are matched.
                        	;
                        	; Character-matching tables:
                        	TAB1:
FFFC4A2C D453494C		db	"LIS",'T'+0x80        ; Direct commands
FFFC4A30 C4414F4C		db	"LOA",'D'+0x80
FFFC4A34 52D7454E		db	"NE",'W'+0x80
FFFC4A37 53CE5552		db	"RU",'N'+0x80
FFFC4A3A C5564153		db	"SAV",'E'+0x80
                        	TAB2:
FFFC4A3E D458454E		db	"NEX",'T'+0x80         ; Direct / statement
FFFC4A42 49D4454C		db	"LE",'T'+0x80
FFFC4A45 4F47C649		db	"I",'F'+0x80
FFFC4A47 CF544F47		db	"GOT",'O'+0x80
FFFC4A4B 55534F47		db	"GOSU",'B'+0x80
FFFC4A4F 544552C2
FFFC4A50 55544552		db	"RETUR",'N'+0x80
FFFC4A54 4552CE52
FFFC4A56 46CD4552		db	"RE",'M'+0x80
FFFC4A59 49D24F46		db	"FO",'R'+0x80
FFFC4A5C 55504E49		db	"INPU",'T'+0x80
FFFC4A60 495250D4
FFFC4A61 4E495250		db	"PRIN",'T'+0x80
FFFC4A65 4B4F50D4
FFFC4A66 C54B4F50		db	"POK",'E'+0x80
FFFC4A6A 454B4F50		db	"POKE",'W'+0x80
FFFC4A6E 4B4F50D7
FFFC4A6F 454B4F50		db	"POKE",'H'+0x80
FFFC4A73 454959C8
FFFC4A74 4C454959		db	"YIEL",'D'+0x80
FFFC4A78 4F5453C4
FFFC4A79 D04F5453		db	"STO",'P'+0x80
FFFC4A7D 53C55942		db	"BY",'E'+0x80
FFFC4A80 43D35953		db	"SY",'S'+0x80
FFFC4A83 43D34C43		db	"CL",'S'+0x80
FFFC4A86 52D24C43	    db  "CL",'R'+0x80
FFFC4A89 C6434452	    db	"RDC",'F'+0x80
FFFC4A8D 52494E4F	    db	"ONIR",'Q'+0x80
FFFC4A91 494157D1
FFFC4A92 D4494157	    db	"WAI",'T'+0x80
FFFC4A96 45455000		db	0
                        	TAB4:
FFFC4A97 CB454550		db	"PEE",'K'+0x80         ;Functions
FFFC4A9B 4B454550		db	"PEEK",'W'+0x80
FFFC4A9F 454550D7
FFFC4AA0 4B454550		db	"PEEK",'H'+0x80
FFFC4AA4 C44E52C8
FFFC4AA5 41C44E52		db	"RN",'D'+0x80
FFFC4AA8 53D34241		db	"AB",'S'+0x80
FFFC4AAB 54CE4753		db  "SG",'N'+0x80
FFFC4AAE CB434954		db	"TIC",'K'+0x80
FFFC4AB2 C55A4953		db	"SIZ",'E'+0x80
FFFC4AB6 41D25355		db  "US",'R'+0x80
FFFC4AB9 4F4C4C41	  db	"ALLOCMB",'X'+0x80
FFFC4ABD D8424D43
FFFC4AC1 444E4553	  db	"SENDMS",'G'+0x80
FFFC4AC5 57C7534D
FFFC4AC8 54494157	  db	"WAITMS",'G'+0x80
FFFC4ACC 00C7534D
FFFC4ACF 00CF5400		db	0
                        	TAB5:
FFFC4AD0 5300CF54		db	"T",'O'+0x80           ;"TO" in "FOR"
FFFC4AD2 45545300		db	0
                        	TAB6:
FFFC4AD3 D0455453		db	"STE",'P'+0x80         ;"STEP" in "FOR"
FFFC4AD7 3CBD3E00		db	0
                        	TAB8:
FFFC4AD8 BE3CBD3E		db	'>','='+0x80           ;Relational operators
FFFC4ADA BDBEBE3C		db	'<','>'+0x80
FFFC4ADC BD3CBDBE		db	'>'+0x80
FFFC4ADD BCBD3CBD		db	'='+0x80
FFFC4ADE 00BCBD3C		db	'<','='+0x80
FFFC4AE0 4E4100BC		db	'<'+0x80
FFFC4AE1 C44E4100		db	0
                        	TAB9:
FFFC4AE2 00C44E41	    db  "AN",'D'+0x80
FFFC4AE5 00D24F00	    db  0
                        	TAB10:
FFFC4AE6 0000D24F	    db  "O",'R'+0x80
FFFC4AE8 4E0C0000	    db  0
                        	
                        	;* Execution address tables:
                        	; We save some bytes by specifiying only the low order 16 bits of the address
                        	;
FFFC4AE9 404E0C00		align	
                        	
                        	TAB1_1:
FFFC4AEA 54404E0C		dh	LISTX			;Direct commands
FFFC4AEC 4BE85440		dh	LOAD3
FFFC4AEE 4C1C4BE8		dh	NEW
FFFC4AF0 54A84C1C		dh	RUN
FFFC4AF2 50BC54A8		dh	SAVE3
                        	TAB2_1:
FFFC4AF4 52D450BC		dh	NEXT		;	Direct / statement
FFFC4AF6 517C52D4		dh	LET
FFFC4AF8 4D40517C		dh	IF0
FFFC4AFA 4F004D40		dh	GOTO
FFFC4AFC 4F744F00		dh	GOSUB
FFFC4AFE 51884F74		dh	RETURN
FFFC4B00 4FDC5188		dh	IF2			; REM
FFFC4B02 51D44FDC		dh	FOR
FFFC4B04 4E6051D4		dh	INPUT
FFFC4B06 561C4E60		dh	PRINT
FFFC4B08 5648561C		dh	POKE
FFFC4B0A 56745648		dh	POKEW
FFFC4B0C 4C105674		dh	POKEH
FFFC4B0E 4C084C10		dh	YIELD0
FFFC4B10 47204C08		dh	STOP
FFFC4B12 56AC4720		dh	GOBYE
FFFC4B14 032B56AC		dh	SYSX
FFFC4B16 4D64032B		dh	_cls
FFFC4B18 032D4D64		dh  _clr
FFFC4B1A 4DB0032D		dh	_rdcf
FFFC4B1C 4DF04DB0		dh  ONIRQ
FFFC4B1E 52C84DF0		dh	WAITIRQ
FFFC4B20 5CEC52C8		dh	DEFLT
                        	TAB4_1:
FFFC4B22 5D045CEC		dh	PEEK			;Functions
FFFC4B24 5D1C5D04		dh	PEEKW
FFFC4B26 5D805D1C		dh	PEEKH
FFFC4B28 00005D80		dh	RND
FFFC4B2A 5E140000		dh	ABS
FFFC4B2C 5E005E14		dh  SGN
FFFC4B2E 5E505E00		dh	TICKX
FFFC4B30 5D345E50		dh	SIZEX
FFFC4B32 66A05D34		dh  USRX
FFFC4B34 671066A0		dh	ALLOCMBX
FFFC4B36 67AC6710		dh	SENDMSG
FFFC4B38 5AA467AC		dh	WAITMSG
FFFC4B3A 50085AA4		dh	XP40
                        	TAB5_1
FFFC4B3C 5F705008		dh	FR1			;"TO" in "FOR"
FFFC4B3E 50305F70		dh	QWHAT
                        	TAB6_1
FFFC4B40 50385030		dh	FR2			;"STEP" in "FOR"
FFFC4B42 585C5038		dh	FR3
                        	TAB8_1
FFFC4B44 5874585C		dh	XP11	;>=		Relational operators
FFFC4B46 588C5874		dh	XP12	;<>
FFFC4B48 58BC588C		dh	XP13	;>
FFFC4B4A 58A458BC		dh	XP15	;=
FFFC4B4C 58D458A4		dh	XP14	;<=
FFFC4B4E 591458D4		dh	XP16	;<
FFFC4B50 576C5914		dh	XP17
                        	TAB9_1
FFFC4B52 5780576C	    dh  XP_AND
FFFC4B54 570C5780	    dh  XP_ANDX
                        	TAB10_1
FFFC4B56 5720570C	    dh  XP_OR
FFFC4B58 00005720	    dh  XP_ORX
                        	
                        	;*
                        	; r3 = match flag (trashed)
                        	; r9 = text table
                        	; r10 = exec table
                        	; r11 = trashed
FFFC4B5A 00000000		align	1
FFFC4B5E 5EB70000
                        	
                        	//message "DIRECT"
                        	DIRECT:
FFFC4B60 FFFC5EB7		ldi		$t3,#TAB1
FFFC4B64 A2CE8E93
FFFC4B68 FFFC5F37		ldi		$t4,#TAB1_1
FFFC4B6C AEAF0F13
                        	EXEC:
FFFC4B70 235010EF		call	IGNBLK		; ignore leading blanks
FFFC4B74 000E6FB3		mov		$t5,$t2		; save the pointer
FFFC4B78 000061B3		mov		r3,r0		; clear match flag
                        	EXLP:
FFFC4B7C 000E4903		lbu		a0,[$t2]		; get the program character
FFFC4B80 001E0E13		add		$t2,$t2,#1
FFFC4B84 000EC983		lbu		a1,[$t3]		; get the table character
FFFC4B88 00099663		bne		a1,x0,EXNGO		; If end of table,
FFFC4B8C 000FEE33		mov		$t2,$t5		;	restore the text pointer and...
FFFC4B90 04000263		bra		EXGO		;   execute the default.
                        	EXNGO:
FFFC4B94 04390063		beq		a0,r3,EXGO	; Else check for period... if so, execute
FFFC4B98 07F9F993		and		a1,a1,#0x7f	; ignore the table's high bit
FFFC4B9C 03298263		beq		a1,a0,EXMAT	;		is there a match?
FFFC4BA0 002F0F13		add		$t4,$t4,#2	;if not, try the next entry
FFFC4BA4 000FEE33		mov		$t2,$t5		; reset the program pointer
FFFC4BA8 000061B3		mov		r3,x0		; sorry, no match
                        	EX1:
FFFC4BAC 000EC903		lbu		a0,[$t3]		; get to the end of the entry
FFFC4BB0 001E8E93		add		$t3,$t3,#1
FFFC4BB4 08097D93		and		$t1,$a0,#$80
FFFC4BB8 FE0D8AE3		beq		$t1,$r0,EX1	; test for bit 7 set
FFFC4BBC FC0000E3		bra		EXLP		; back for more matching
                        	EXMAT:
FFFC4BC0 02E06193		ldi		r3,#'.'		; we've got a match so far
FFFC4BC4 000EC903		lbu		a0,[$t3]		; end of table entry?
FFFC4BC8 001E8E93		add		$t3,$t3,#1
FFFC4BCC 08097D93		and		$t1,$a0,#$80
FFFC4BD0 FA0D86E3		beq		$t1,$r0,EXLP		; test for bit 7 set, if not, go back for more
                        	EXGO:
                        		; execute the appropriate routine
FFFC4BD4 000F5903		lhu		a0,[$t4]	; get the low mid order byte
FFFC4BD8 FFFC0637		or		a0,a0,#$FFFC0000	; add in ROM base
FFFC4BDC 00060613
FFFC4BE0 01266933
FFFC4BE4 00090067		jmp		[a0]
                        	
                        	    
                        	;******************************************************************
                        	;
                        	; What follows is the code to execute direct and statement
                        	; commands. Control is transferred to these points via the command
                        	; table lookup code of 'DIRECT' and 'EXEC' in the last section.
                        	; After the command is executed, control is transferred to other
                        	; sections as follows:
                        	;
                        	; For 'LISTX', 'NEW', and 'STOP': go back to the warm start point.
                        	; For 'RUN': go execute the first stored line if any; else go
                        	; back to the warm start point.
                        	; For 'GOTO' and 'GOSUB': go execute the target line.
                        	; For 'RETURN' and 'NEXT'; go back to saved return line.
                        	; For all others: if 'CURRNT' is 0, go to warm start; else go
                        	; execute next command. (This is done in 'FINISH'.)
                        	;
                        	;******************************************************************
                        	;
                        	; *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                        	;
                        	; 'NEW<CR>' sets TXTUNF to point to TXTBGN
                        	;
                        	
                        	NEW:
FFFC4BE8 340010EF		call	ENDCHK
FFFC4BEC 00032837		ldi		v0,#TXTBGN
FFFC4BF0 80080813
FFFC4BF4 00030637		sw		v0,TXTUNF	;	set the end pointer
FFFC4BF8 00460613
FFFC4BFC 00060633
FFFC4C00 01062023
FFFC4C04 168000EF		call  clearVars
                        	
                        	; 'STOP<CR>' goes back to WSTART
                        	;
                        	STOP:
FFFC4C08 320010EF		call	ENDCHK
FFFC4C0C C19FF06F		jmp		WSTART		; WSTART will reset the stack
                        	
                        	;------------------------------------------------------------------------------
                        	; YIELD suspends execution of TinyBasic by switching to the next ready task.
                        	;------------------------------------------------------------------------------
                        	
                        	YIELD0:
FFFC4C10 00D06913		ldi		a0,#13
FFFC4C14 00000073		ecall
FFFC4C18 2E00006F		jmp		FINISH
                        	
                        	;------------------------------------------------------------------------------
                        	; 'RUN<CR>' finds the first stored line, stores its address
                        	; in CURRNT, and starts executing it. Note that only those
                        	; commands in TAB2 are legal for a stored program.
                        	;
                        	; There are 3 more entries in 'RUN':
                        	; 'RUNNXL' finds next line, stores it's address and executes it.
                        	; 'RUNTSL' stores the address of this line and executes it.
                        	; 'RUNSML' continues the execution on same line.
                        	;
                        	RUN:
FFFC4C1C 30C010EF		call	ENDCHK
FFFC4C20 00032E37		ldi		$t2,#TXTBGN	;	set pointer to beginning
FFFC4C24 800E0E13
FFFC4C28 00030637		sw		$t2,CURRNT
FFFC4C2C 01860613
FFFC4C30 00060633
FFFC4C34 01C62023
FFFC4C38 134000EF		call  clearVars
                        	
                        	RUNNXL:					; RUN <next line>
FFFC4C3C 00030637		lw		$t2,CURRNT	; executing a program?
FFFC4C40 01860613
FFFC4C44 00060633
FFFC4C48 00062E03
FFFC4C4C 000E1463		bne		$t2,x0,RUN3	; if not, we've finished a direct stat.
                        	RUN2:
FFFC4C50 BD5FF06F		jmp		WSTART
                        	RUN3:
FFFC4C54 00030637		lw		a0,IRQROUT		; are we handling IRQ's ?
FFFC4C58 0A460613
FFFC4C5C 00060633
FFFC4C60 00062903
FFFC4C64 08090863		beq		a0,x0,RUN1
FFFC4C68 00030637		lw		$t1,IRQFlag		; was there an IRQ ?
FFFC4C6C 0B460613
FFFC4C70 00060633
FFFC4C74 00062D83
FFFC4C78 060D8E63		beq		$t1,x0,RUN1
FFFC4C7C 00030637		sw		x0,IRQFlag
FFFC4C80 0B460613
FFFC4C84 00060633
FFFC4C88 00062023
FFFC4C8C 598010EF		call	PUSHA_		; the same code as a GOSUB
FFFC4C90 FF470713		sub		$sp,$sp,#12
FFFC4C94 00030637		lw		a0,STKGOS
FFFC4C98 01460613
FFFC4C9C 00060633
FFFC4CA0 00062903
FFFC4CA4 01272023		sw		a0,[$sp]
FFFC4CA8 00030637		lw		a0,CURRNT
FFFC4CAC 01860613
FFFC4CB0 00060633
FFFC4CB4 00062903
FFFC4CB8 01272223		sw		a0,4[$sp]
FFFC4CBC 01C72423		sw		$t2,8[$sp]
FFFC4CC0 00030637		sw		x0,LOPVAR		; load new values
FFFC4CC4 01060613
FFFC4CC8 00060633
FFFC4CCC 00062023
FFFC4CD0 00030637		sw		$sp,STKGOS
FFFC4CD4 01460613
FFFC4CD8 00060633
FFFC4CDC 00E62023
FFFC4CE0 00030637		lw		$t3,IRQROUT
FFFC4CE4 0A460613
FFFC4CE8 00060633
FFFC4CEC 00062E83
FFFC4CF0 02000263		bra		RUNTSL
                        	RUN1:
FFFC4CF4 000E6EB3		mov		$t3,$t2
FFFC4CF8 00006933		mov		a0,x0
FFFC4CFC 404010EF		call	FNDLNP		; else find the next line number
FFFC4D00 00030637		lw		$t1,TXTUNF	; if we've fallen off the end, stop
FFFC4D04 00460613
FFFC4D08 00060633
FFFC4D0C 00062D83
FFFC4D10 F5BEF0E3		bgeu	$t3,$t1,RUN2
                        	
                        	RUNTSL:					; RUN <this line>
FFFC4D14 00030637		sw		$t3,CURRNT	; set CURRNT to point to the line no.
FFFC4D18 01860613
FFFC4D1C 00060633
FFFC4D20 01D62023
FFFC4D24 004E8E13		add		$t2,$t3,#4	; set the text pointer to
                        	
                        	RUNSML:                 ; RUN <same line>
FFFC4D28 131010EF		call	CHKIO		; see if a control-C was pressed
FFFC4D2C FFFC5EB7		ldi		$t3,#TAB2		; find command in TAB2
FFFC4D30 A3EE8E93
FFFC4D34 FFFC5F37		ldi		$t4,#TAB2_1
FFFC4D38 AF4F0F13
FFFC4D3C E35FF06F		jmp		EXEC		; and execute it
                        	
                        	
                        	;******************************************************************
                        	; 'GOTO expr<CR>' evaluates the expression, finds the target
                        	; line, and jumps to 'RUNTSL' to do it.
                        	;******************************************************************
                        	;
                        	GOTO:
FFFC4D40 199000EF		call	OREXPR		;evaluate the following expression
FFFC4D44 000862B3		mov   r5,v0
FFFC4D48 1E0010EF		call 	ENDCHK		;must find end of line
FFFC4D4C 0002E933		mov   a0,r5
FFFC4D50 390010EF		call 	FNDLN		; find the target line
FFFC4D54 FC0810E3		bne		v0,x0,RUNTSL; go do it
FFFC4D58 FFFC7937		ldi		a0,#msgBadGotoGosub
FFFC4D5C A3590913
FFFC4D60 2180106F		jmp		ERROR		; no such line no.
                        	
                        	_clr:
FFFC4D64 008000EF	    call    clearVars
FFFC4D68 1900006F	    jmp     FINISH
                        	
                        	; Clear the variable area of memory
                        	clearVars:
FFFC4D6C FF870713		sub		$sp,$sp,#8
FFFC4D70 00672023		sw		r6,[$sp]
FFFC4D74 00172223		sw		$ra,4[$sp]
FFFC4D78 06406313	  ldi   r6,#100    	; number of word pairs to clear
FFFC4D7C 00030637	  lw    v0,VARBGN
FFFC4D80 00860613
FFFC4D84 00060633
FFFC4D88 00062803
                        	.cv1:
FFFC4D8C 00082023	  sw		x0,[$v0]		; variable name
FFFC4D90 00082223	  sw		x0,4[$v0]		; and value
FFFC4D94 00880813	  add		v0,v0,#8
FFFC4D98 FFF30313	  sub		r6,r6,#1
FFFC4D9C FE6048E3		bgt		r6,x0,.cv1
FFFC4DA0 00072303	  lw		r6,[$sp]
FFFC4DA4 00472083	  lw		$ra,4[$sp]
FFFC4DA8 00870713	  add		$sp,$sp,#8
FFFC4DAC 00008067	  ret
                        	
                        	;******************************************************************
                        	; ONIRQ <line number>
                        	; ONIRQ sets up an interrupt handler which acts like a specialized
                        	; subroutine call. ONIRQ is coded like a GOTO that never executes.
                        	;******************************************************************
                        	;
                        	ONIRQ:
FFFC4DB0 129000EF		call	OREXPR		;evaluate the following expression
FFFC4DB4 000862B3		mov   r5,v0
FFFC4DB8 170010EF		call 	ENDCHK		;must find end of line
FFFC4DBC 0002E933		mov   a0,r5
FFFC4DC0 320010EF		call 	FNDLN		; find the target line
FFFC4DC4 00081C63		bne		v0,r0,ONIRQ1
FFFC4DC8 00030637		sw		x0,IRQROUT
FFFC4DCC 0A460613
FFFC4DD0 00060633
FFFC4DD4 00062023
FFFC4DD8 1200006F		jmp		FINISH
                        	ONIRQ1:
FFFC4DDC 00030637		sw		$t3,IRQROUT
FFFC4DE0 0A460613
FFFC4DE4 00060633
FFFC4DE8 01D62023
FFFC4DEC 10C0006F		jmp		FINISH
                        	
                        	WAITIRQ:
FFFC4DF0 069010EF		call	CHKIO		; see if a control-C was pressed
FFFC4DF4 00030637		lw		$t1,IRQFlag
FFFC4DF8 0B460613
FFFC4DFC 00060633
FFFC4E00 00062D83
FFFC4E04 FE0D86E3		beq		$t1,x0,WAITIRQ
FFFC4E08 0F00006F		jmp		FINISH
                        	
                        	
                        	;******************************************************************
                        	; LIST
                        	;
                        	; LISTX has two forms:
                        	; 'LIST<CR>' lists all saved lines
                        	; 'LIST #<CR>' starts listing at the line #
                        	; Control-S pauses the listing, control-C stops it.
                        	;******************************************************************
                        	;
                        	LISTX:
FFFC4E0C 724010EF		call		TSTNUM		; see if there's a line no.
FFFC4E10 000862B3		mov      r5,v0
FFFC4E14 114010EF		call		ENDCHK		; if not, we get a zero
FFFC4E18 0002E933		mov      a0,r5
FFFC4E1C 2C4010EF		call		FNDLN		; find this or next line
                        	LS1:
FFFC4E20 00081C63		bne		v0,r0,LS4
                        	LS5:
FFFC4E24 00030637		lw		$t1,TXTUNF
FFFC4E28 00460613
FFFC4E2C 00060633
FFFC4E30 00062D83
FFFC4E34 9FBEF8E3		bgeu	$t3,$t1,WSTART	; warm start if we passed the end
                        	LS4:
FFFC4E38 000EE933		mov		a0,$t3
FFFC4E3C 64C010EF		call	PRTLN		; print the line
FFFC4E40 00086EB3		mov		$t3,$v0		; set pointer for next
FFFC4E44 015010EF		call	CHKIO		; check for listing halt request
FFFC4E48 00080A63		beq		v0,x0,LS3
FFFC4E4C 01306D93		ldi		$t1,#CTRLS
FFFC4E50 01B81663		bne		v0,$t1,LS3; pause the listing?
                        	LS2:
FFFC4E54 005010EF		call 	CHKIO		; if so, wait for another keypress
FFFC4E58 FE080EE3		beq		v0,r0,LS2
                        	LS3:
                        	;	mov		$v0,$x0
FFFC4E5C FC0004E3		bra		LS5
                        	;	mov		a0,r0
                        	;	call	FNDSKP	;FNDLNP		; find the next line
                        	;	bra		LS1
                        	
                        	
                        	;******************************************************************
                        	; PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                        	; where '....' is a list of expressions, formats, back-arrows,
                        	; and strings.	These items a separated by commas.
                        	;
                        	; A format is a pound sign followed by a number.  It controls
                        	; the number of spaces the value of an expression is going to
                        	; be printed in.  It stays effective for the rest of the print
                        	; command unless changed by another format.  If no format is
                        	; specified, 11 positions will be used.
                        	;
                        	; A string is quoted in a pair of single- or double-quotes.
                        	;
                        	; An underline (back-arrow) means generate a <CR> without a <LF>
                        	;
                        	; A <CR LF> is generated after the entire list has been printed
                        	; or if the list is empty.  If the list ends with a semicolon,
                        	; however, no <CR LF> is generated.
                        	;******************************************************************
                        	;
                        	PRINT:
FFFC4E60 00B06293		ldi		r5,#11		; D4 = number of print spaces
FFFC4E64 680010EF		call	TSTC		; if null list and ":"
FFFC4E68 0000003A		dw		':'
FFFC4E6C 00000663		bra		PR2
FFFC4E70 011010EF		call	CRLF		; give CR-LF and continue
FFFC4E74 EB5FF06F		jmp		RUNSML		;		execution on the same line
                        	PR2:
FFFC4E78 66C010EF		call	TSTC		;if null list and <CR>
FFFC4E7C 0000000D		dw		CR
FFFC4E80 00000663		bra		PR0
FFFC4E84 7FC010EF		call	CRLF		;also give CR-LF and
FFFC4E88 DB5FF06F		jmp		RUNNXL		;execute the next line
                        	PR0:
FFFC4E8C 658010EF		call	TSTC		;else is it a format?
FFFC4E90 00000023		dw		'#'
FFFC4E94 00000863		bra		PR1
FFFC4E98 041000EF		call	OREXPR		; yes, evaluate expression
FFFC4E9C 000862B3		mov		r5,v0	; and save it as print width
FFFC4EA0 02000263		bra		PR3		; look for more to print
                        	PR1:
FFFC4EA4 640010EF		call	TSTC	;	is character expression? (MRL)
FFFC4EA8 00000024		dw		'$'
FFFC4EAC 00000863		bra		PR4
FFFC4EB0 029000EF		call	OREXPR	;	yep. Evaluate expression (MRL)
FFFC4EB4 855FF0EF		call	GOOUT	;	print low byte (MRL)
FFFC4EB8 00000663		bra		PR3		;look for more. (MRL)
                        	PR4:
FFFC4EBC 45C010EF		call	QTSTG	;	is it a string?
                        		; the following branch must occupy only 1 word!
FFFC4EC0 02000063		bra		PR8		;	if not, must be an expression
                        	PR3:
FFFC4EC4 620010EF		call		TSTC	;	if ",", go find next
FFFC4EC8 0000002C		dw		','
FFFC4ECC 00000663		bra		PR6
FFFC4ED0 01C010EF		call		FIN		;in the list.
FFFC4ED4 FA000CE3		bra		PR0
                        	PR6:
FFFC4ED8 7A8010EF		call		CRLF		;list ends here
FFFC4EDC 01C0006F		jmp		FINISH
                        	PR8:
FFFC4EE0 7F8000EF		call	OREXPR		; evaluate the expression
FFFC4EE4 00086933		mov		a0,v0
FFFC4EE8 00506993		ldi		a1,#5		; set the width
FFFC4EEC 00A06A13		ldi		a2,#10
FFFC4EF0 4BC010EF		call	PRTNUM		; print its value
FFFC4EF4 FC0008E3		bra		PR3			; more to print?
                        	
                        	
                        	FINISH:
FFFC4EF8 7F5000EF		call	FIN		; Check end of command
FFFC4EFC 0740106F		jmp		QWHAT	; print "What?" if wrong
                        	
                        	
                        	;*******************************************************************
                        	;
                        	; *** GOSUB *** & RETURN ***
                        	;
                        	; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                        	; except that the current text pointer, stack pointer, etc. are
                        	; saved so that execution can be continued after the subroutine
                        	; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                        	; recursive), the save area must be stacked.  The stack pointer
                        	; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                        	; If we are in the main routine, 'STKGOS' is zero (this was done
                        	; in the initialization section of the interpreter), but we still
                        	; save it as a flag for no further 'RETURN's.
                        	;******************************************************************
                        	;
                        	GOSUB:
FFFC4F00 324010EF		call	PUSHA_		; save the current 'FOR' parameters
FFFC4F04 7D4000EF		call	OREXPR		; get line number
FFFC4F08 00086933		mov		$a0,$v0
FFFC4F0C 1D4010EF		call	FNDLN		; find the target line
FFFC4F10 00081863		bne		v0,r0,gosub1
FFFC4F14 FFFC7937		ldi		a0,#msgBadGotoGosub
FFFC4F18 A3590913
FFFC4F1C 05C0106F		jmp		ERROR		; if not there, say "How?"
                        	gosub1:
FFFC4F20 FF470713		sub		$sp,$sp,#12
FFFC4F24 00030637		lw		a0,STKGOS	; 'STKGOS'
FFFC4F28 01460613
FFFC4F2C 00060633
FFFC4F30 00062903
FFFC4F34 01272023		sw		a0,[$sp]
FFFC4F38 00030637		lw		a0,CURRNT	; found it, save old 'CURRNT'...
FFFC4F3C 01860613
FFFC4F40 00060633
FFFC4F44 00062903
FFFC4F48 01272223		sw		a0,4[$sp]
FFFC4F4C 01C72423		sw		$t2,8[$sp]
FFFC4F50 00030637		sw		$x0,LOPVAR		; load new values
FFFC4F54 01060613
FFFC4F58 00060633
FFFC4F5C 00062023
FFFC4F60 00030637		sw		$sp,STKGOS
FFFC4F64 01460613
FFFC4F68 00060633
FFFC4F6C 00E62023
FFFC4F70 DA5FF06F		jmp		RUNTSL
                        	
                        	
                        	;******************************************************************
                        	; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                        	; returns the execution to the command after the most recent
                        	; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                        	; a 'GOSUB' and is thus an error.
                        	;******************************************************************
                        	;
                        	RETURN:
FFFC4F74 7B5000EF		call	ENDCHK		; there should be just a <CR>
FFFC4F78 00030637		lw		a1,STKGOS		; get old stack pointer
FFFC4F7C 01460613
FFFC4F80 00060633
FFFC4F84 00062983
FFFC4F88 00099863		bne		a1,x0,return1
FFFC4F8C FFFC7937		ldi		a0,#msgRetWoGosub
FFFC4F90 A5190913
FFFC4F94 7E50006F		jmp		ERROR		; if zero, it doesn't exist
                        	return1:
FFFC4F98 0009E733		mov		$sp,a1		; else restore it
FFFC4F9C 00072903		lw		a0,[$sp]
FFFC4FA0 00470713		add		$sp,$sp,#4
FFFC4FA4 00030637		sw		a0,STKGOS	; and the old 'STKGOS'
FFFC4FA8 01460613
FFFC4FAC 00060633
FFFC4FB0 01262023
FFFC4FB4 00072903		lw		a0,[$sp]
FFFC4FB8 00470713		add		$sp,$sp,#4
FFFC4FBC 00030637		sw		a0,CURRNT	; and the old 'CURRNT'
FFFC4FC0 01860613
FFFC4FC4 00060633
FFFC4FC8 01262023
FFFC4FCC 00072E03		lw		$t2,[$sp]	; and the old text pointer
FFFC4FD0 00470713		add		$sp,$sp,#4
FFFC4FD4 1DC010EF		call	POPA_		;and the old 'FOR' parameters
FFFC4FD8 F21FF06F		jmp		FINISH		;and we are back home
                        	
                        	;******************************************************************
                        	; *** FOR *** & NEXT ***
                        	;
                        	; 'FOR' has two forms:
                        	; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                        	; The second form means the same thing as the first form with a
                        	; STEP of positive 1.  The interpreter will find the variable 'var'
                        	; and set its value to the current value of 'exp1'.  It also
                        	; evaluates 'exp2' and 'exp1' and saves all these together with
                        	; the text pointer, etc. in the 'FOR' save area, which consists of
                        	; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                        	; already something in the save area (indicated by a non-zero
                        	; 'LOPVAR'), then the old save area is saved on the stack before
                        	; the new values are stored.  The interpreter will then dig in the
                        	; stack and find out if this same variable was used in another
                        	; currently active 'FOR' loop.  If that is the case, then the old
                        	; 'FOR' loop is deactivated. (i.e. purged from the stack)
                        	;******************************************************************
                        	;
                        	FOR:
FFFC4FDC 248010EF		call	PUSHA_		; save the old 'FOR' save area
FFFC4FE0 6A5000EF		call	SETVAL		; set the control variable
FFFC4FE4 00030637		sw		v0,LOPVAR		; save its address
FFFC4FE8 01060613
FFFC4FEC 00060633
FFFC4FF0 01062023
FFFC4FF4 FFFC5EB7		ldi		$t3,#TAB5
FFFC4FF8 AD0E8E93
FFFC4FFC FFFC5F37		ldi		$t4,#TAB5_1	; use 'EXEC' to test for 'TO'
FFFC5000 B3CF0F13
FFFC5004 B6DFF06F		jmp		EXEC
                        	FR1:
FFFC5008 6D0000EF		call	OREXPR		; evaluate the limit
FFFC500C 00030637		sw		v0,LOPLMT	; save that
FFFC5010 07C60613
FFFC5014 00060633
FFFC5018 01062023
FFFC501C FFFC5EB7		ldi		$t3,#TAB6
FFFC5020 AD3E8E93
FFFC5024 FFFC5F37		ldi		$t4,#TAB6_1	; use 'EXEC' to test for the word 'STEP
FFFC5028 B40F0F13
FFFC502C B45FF06F		jmp		EXEC
                        	FR2:
FFFC5030 6A8000EF		call	OREXPR		; found it, get the step value
FFFC5034 00000463		bra		FR4
                        	FR3:
FFFC5038 00106813		ldi		v0,#1		; not found, step defaults to 1
                        	FR4:
FFFC503C 00030637		sw		v0,LOPINC	; save that too
FFFC5040 07860613
FFFC5044 00060633
FFFC5048 01062023
                        	FR5:
FFFC504C 00030637		lw		a1,CURRNT
FFFC5050 01860613
FFFC5054 00060633
FFFC5058 00062983
FFFC505C 00030637		sw		a1,LOPLN	; save address of current line number
FFFC5060 07460613
FFFC5064 00060633
FFFC5068 01362023
FFFC506C 00030637		sw		$t2,LOPPT	; and text pointer
FFFC5070 07060613
FFFC5074 00060633
FFFC5078 01C62023
FFFC507C 000761B3		mov		r3,$sp		; dig into the stack to find 'LOPVAR'
FFFC5080 00030637		lw		r6,LOPVAR
FFFC5084 01060613
FFFC5088 00060633
FFFC508C 00062303
FFFC5090 00000463		bra		FR7
                        	FR6:
FFFC5094 01418193		add		r3,r3,#20	; look at next stack frame
                        	FR7:
FFFC5098 0001A983		lw		a1,[r3]		; is it zero?
FFFC509C 00098E63		beq		a1,x0,FR8	; if so, we're done
FFFC50A0 FE699AE3		bne		a1,r6,FR6	; same as current LOPVAR? nope, look some more
                        	
FFFC50A4 0001E933	  mov		a0,r3	   ; Else remove 5 words from...
FFFC50A8 000769B3		mov		a1,$sp
FFFC50AC 01418A13		add		a2,r3,#20  ; inside the stack.
FFFC50B0 0F8010EF		call	MVDOWN
FFFC50B4 01470713		add		$sp,$sp,#20	; set the SP 5 long words up
                        	;	lw		a0,[$sp]		; ???
                        	;	add		$sp,$sp,#4
                        	FR8:
FFFC50B8 E41FF06F	  jmp	    FINISH		; and continue execution
                        	
                        	
                        	;******************************************************************
                        	; 'NEXT var' serves as the logical (not necessarily physical) end
                        	; of the 'FOR' loop.  The control variable 'var' is checked with
                        	; the 'LOPVAR'.  If they are not the same, the interpreter digs in
                        	; the stack to find the right one and purges all those that didn't
                        	; match.  Either way, it then adds the 'STEP' to that variable and
                        	; checks the result with against the limit value.  If it is within
                        	; the limit, control loops back to the command following the
                        	; 'FOR'.  If it's outside the limit, the save area is purged and
                        	; execution continues.
                        	;******************************************************************
                        	;
                        	NEXT:
FFFC50BC 00006933		mov		a0,x0		; don't allocate it
FFFC50C0 259000EF		call	TSTV		; get address of variable
FFFC50C4 00081863		bne		v0,x0,NX4
FFFC50C8 FFFC7937		ldi		a0,#msgNextVar
FFFC50CC A1290913
FFFC50D0 6A0004E3		bra		ERROR		; if no variable, say "What?"
                        	NX4:
FFFC50D4 00086EB3		mov		$t3,v0	; save variable's address
                        	NX0:
FFFC50D8 00030637		lw		a0,LOPVAR	; If 'LOPVAR' is zero, we never...
FFFC50DC 01060613
FFFC50E0 00060633
FFFC50E4 00062903
FFFC50E8 00091863		bne		a0,x0,NX5	; had a FOR loop
FFFC50EC FFFC7937		ldi		a0,#msgNextFor
FFFC50F0 A0090913
FFFC50F4 680002E3		bra		ERROR
                        	NX5:
FFFC50F8 01D90663		beq		a0,$t3,NX2	; else we check them OK, they agree
FFFC50FC 0B4010EF		call	POPA_		; nope, let's see the next frame
FFFC5100 FC000CE3		bra		NX0
                        	NX2:
FFFC5104 000EA903		lw		a0,[$t3]		; get control variable's value
FFFC5108 00030637		lw		a1,LOPINC
FFFC510C 07860613
FFFC5110 00060633
FFFC5114 00062983
FFFC5118 01390933		add		a0,a0,a1	; add in loop increment
                        	;	BVS.L	QHOW		say "How?" for 32-bit overflow
FFFC511C 012EA023		sw		a0,[$t3]		; save control variable's new value
FFFC5120 00030637		lw		r3,LOPLMT	; get loop's limit value
FFFC5124 07C60613
FFFC5128 00060633
FFFC512C 00062183
FFFC5130 0009D663		bge		a1,x0,NX1	; check loop increment, branch if loop increment is positive
FFFC5134 04394063		blt		a0,r3,NXPurge	; test against limit
FFFC5138 00000463		bra     NX3
                        	NX1:
FFFC513C 0321CC63		bgt		a0,r3,NXPurge
                        	NX3:
FFFC5140 00030637		lw		$t2,LOPLN	; Within limit, go back to the...
FFFC5144 07460613
FFFC5148 00060633
FFFC514C 00062E03
FFFC5150 00030637		sw		$t2,CURRNT
FFFC5154 01860613
FFFC5158 00060633
FFFC515C 01C62023
FFFC5160 00030637		lw		$t2,LOPPT	; saved 'CURRNT' and text pointer.
FFFC5164 07060613
FFFC5168 00060633
FFFC516C 00062E03
FFFC5170 D89FF06F		jmp		FINISH
                        	NXPurge:
FFFC5174 03C010EF	  call    POPA_        ; purge this loop
FFFC5178 D81FF06F	  jmp     FINISH
                        	
                        	
                        	;******************************************************************
                        	; *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                        	;
                        	; 'REM' can be followed by anything and is ignored by the
                        	; interpreter.
                        	;
                        	;REM
                        	;    br	    IF2		    ; skip the rest of the line
                        	; 'IF' is followed by an expression, as a condition and one or
                        	; more commands (including other 'IF's) separated by colons.
                        	; Note that the word 'THEN' is not used.  The interpreter evaluates
                        	; the expression.  If it is non-zero, execution continues.  If it
                        	; is zero, the commands that follow are ignored and execution
                        	; continues on the next line.
                        	;******************************************************************
                        	;
                        	IF0:
FFFC517C 55C000EF	  call	OREXPR		; evaluate the expression
                        	IF1:
FFFC5180 00080463	  beq	  v0,x0,IF2	; is it zero? if not, continue
FFFC5184 BA5FF06F	  jmp		RUNSML
                        	IF2:
FFFC5188 000E6EB3	  mov		$t3,$t2	; set lookup pointer
FFFC518C 00006933		mov		a0,x0		; find line #0 (impossible)
FFFC5190 7DD000EF		call	FNDSKP		; if so, skip the rest of the line
FFFC5194 00081463		bne		v0,x0,IF3; if no next line, do a warm start
FFFC5198 E8CFF06F		jmp		WSTART
                        	IF3:
FFFC519C B79FF06F		jmp		RUNTSL		; run the next line
                        	
                        	
                        	;******************************************************************
                        	; INPUT is called first and establishes a stack frame
                        	INPERR:
FFFC51A0 00030637		lw		$sp,STKINP		; restore the old stack pointer
FFFC51A4 09860613
FFFC51A8 00060633
FFFC51AC 00062703
FFFC51B0 00072903		lw		a0,[$sp]
FFFC51B4 00470713		add		$sp,$sp,#4
FFFC51B8 00030637		sw		a0,CURRNT		; and old 'CURRNT'
FFFC51BC 01860613
FFFC51C0 00060633
FFFC51C4 01262023
FFFC51C8 00072E03		lw		$t2,[$sp]		; and old text pointer
FFFC51CC 00470713		add		$sp,$sp,#4
FFFC51D0 01470713		add		$sp,$sp,#20	; fall through will subtract 20
                        	
                        	; 'INPUT' is like the 'PRINT' command, and is followed by a list
                        	; of items.  If the item is a string in single or double quotes,
                        	; or is an underline (back arrow), it has the same effect as in
                        	; 'PRINT'.  If an item is a variable, this variable name is
                        	; printed out followed by a colon, then the interpreter waits for
                        	; an expression to be typed in.  The variable is then set to the
                        	; value of this expression.  If the variable is preceeded by a
                        	; string (again in single or double quotes), the string will be
                        	; displayed followed by a colon.  The interpreter the waits for an
                        	; expression to be entered and sets the variable equal to the
                        	; expression's value.  If the input expression is invalid, the
                        	; interpreter will print "What?", "How?", or "Sorry" and reprint
                        	; the prompt and redo the input.  The execution will not terminate
                        	; unless you press control-C.  This is handled in 'INPERR'.
                        	;
                        	INPUT:
FFFC51D4 FEC70713		sub		$sp,$sp,#20	; allocate five words on stack
FFFC51D8 00572823		sw		r5,16[$sp]	; save off r5 into stack var
                        	IP6:
FFFC51DC 01C72023		sw		$t2,[$sp]	; save in case of error
FFFC51E0 138010EF		call	QTSTG		; is next item a string?
FFFC51E4 00000C63		bra		IP2			; nope - this branch must take only 1 word
FFFC51E8 00106913		ldi		a0,#1		; allocate var
FFFC51EC 12D000EF		call	TSTV		; yes, but is it followed by a variable?
FFFC51F0 0A090E63		beq    a0,r0,IP4   ; if not, brnch
FFFC51F4 00096F33		mov		$t4,a0		; put away the variable's address
FFFC51F8 04000063		bra		IP3			; if so, input to variable
                        	IP2:
FFFC51FC 01C72223		sw		$t2,4[$sp]	; save off in stack var for 'PRTSTG'
FFFC5200 00106913		ldi		a0,#1
FFFC5204 115000EF		call	TSTV		; must be a variable now
FFFC5208 00091A63		bne		a0,r0,IP7
FFFC520C FFFC7937		ldi		a0,#msgInputVar
FFFC5210 9E490913
FFFC5214 01470713		add		$sp,$sp,#20	; cleanup stack
FFFC5218 560000E3		bra		ERROR		; "What?" it isn't?
                        	IP7:
FFFC521C 00096F33		mov		$t4,a0		; put away the variable's address
FFFC5220 000E4283		lbu		r5,[$t2]		; get ready for 'PRTSTG' by null terminating
FFFC5224 000E0023		sb		x0,[$t2]
FFFC5228 000069B3		mov		a1,x0
FFFC522C 00472903		lw		a0,4[$sp]	; get back text pointer
FFFC5230 080010EF		call	PRTSTG		; print string as prompt
FFFC5234 005E0023		sb		r5,[$t2]		; un-null terminate
                        	IP3
FFFC5238 01C72223		sw		$t2,4[$sp]	; save in case of error
FFFC523C 00030637		lw		a0,CURRNT
FFFC5240 01860613
FFFC5244 00060633
FFFC5248 00062903
FFFC524C 01272423		sw		a0,8[$sp]	; also save 'CURRNT'
FFFC5250 FFF06913		ldi		a0,#-1
FFFC5254 00030637		sw		a0,CURRNT	; flag that we are in INPUT
FFFC5258 01860613
FFFC525C 00060633
FFFC5260 01262023
FFFC5264 00030637		sw		$sp,STKINP	; save the stack pointer too
FFFC5268 09860613
FFFC526C 00060633
FFFC5270 00E62023
FFFC5274 01E72623		sw		$t4,12[$sp]	; save the variable address
FFFC5278 03A06913		ldi		a0,#':'		; print a colon first
FFFC527C 559000EF		call	GETLN		; then get an input line
FFFC5280 00030E37		ldi		$t2,#BUFFER	; point to the buffer
FFFC5284 01CE0E13
FFFC5288 450000EF		call	OREXPR		; evaluate the input
FFFC528C 00C72F03		lw		$t4,12[$sp]	; restore the variable address
FFFC5290 012F2023		sw		a0,[$t4]	; save value in variable
FFFC5294 00872903		lw		a0,8[$sp]	; restore old 'CURRNT'
FFFC5298 00030637		sw		a0,CURRNT
FFFC529C 01860613
FFFC52A0 00060633
FFFC52A4 01262023
FFFC52A8 00472E03		lw		$t2,4[$sp]	; and the old text pointer
                        	IP4:
FFFC52AC 238010EF		call	TSTC
FFFC52B0 0000002C		dw		','
FFFC52B4 00000463		bra		IP5
FFFC52B8 F20002E3		bra		IP6			; yes, more items
                        	IP5:
FFFC52BC 01072283		lw		r5,16[$sp]
FFFC52C0 01470713		add		$sp,$sp,#20	; cleanup stack
FFFC52C4 C35FF06F	 	jmp		FINISH
                        	
                        	
                        	DEFLT:
FFFC52C8 000E4903	  lbu    	a0,[$t2]
FFFC52CC 00D06D93	  ldi			$t1,#CR
FFFC52D0 C3B904E3		beq	    a0,$t1,FINISH	    ; empty line is OK else it is 'LET'
                        	
                        	
                        	;******************************************************************
                        	; 'LET' is followed by a list of items separated by commas.
                        	; Each item consists of a variable, an equals sign, and an
                        	; expression.  The interpreter evaluates the expression and sets
                        	; the variable to that value.  The interpreter will also handle
                        	; 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                        	;******************************************************************
                        	;
                        	LET:
FFFC52D4 3B1000EF	  call	SETVAL		; do the assignment
FFFC52D8 20C010EF		call	TSTC		; check for more 'LET' items
FFFC52DC 0000002C		dw		','
FFFC52E0 C19FF06F		jmp		FINISH
FFFC52E4 FE0008E3		bra	    LET
                        	LT1:
FFFC52E8 C11FF06F	  jmp	    FINISH		; until we are finished.
                        	
                        	
                        	;******************************************************************
                        	; *** LOAD *** & SAVE ***
                        	;
                        	; These two commands transfer a program to/from an auxiliary
                        	; device such as a cassette, another computer, etc.  The program
                        	; is converted to an easily-stored format: each line starts with
                        	; a colon, the line no. as 4 hex digits, and the rest of the line.
                        	; At the end, a line starting with an '@' sign is sent.  This
                        	; format can be read back with a minimum of processing time by
                        	; the RTF65002
                        	;******************************************************************
                        	;
                        	LOAD
FFFC52EC 00032E37		ldi		$t2,#TXTBGN	; set pointer to start of prog. area
FFFC52F0 800E0E13
FFFC52F4 00D06913		ldi		a0,#CR		; For a CP/M host, tell it we're ready...
FFFC52F8 C18FF0EF		call	GOAUXO		; by sending a CR to finish PIP command.
                        	LOD1:
FFFC52FC C1CFF0EF		call	GOAUXI		; look for start of line
FFFC5300 FF205EE3		ble		a0,r0,LOD1
FFFC5304 04006D93		ldi		$t1,#'@'
FFFC5308 03B90E63		beq		a0,$t1,LODEND	; end of program?
FFFC530C 01A06D93		ldi		$t1,#$1A
FFFC5310 03B90A63		beq		a0,$t1,LODEND	; or EOF marker
FFFC5314 03A06D93		ldi		$t1,#':'
FFFC5318 FFB912E3		bne		a0,$t1,LOD1	; if not, is it start of line? if not, wait for it
FFFC531C 03C000EF		call	GCHAR		; get line number
FFFC5320 012E2023		sw		a0,[$t2]		; store it
FFFC5324 004E0E13		add		$t2,$t2,#4
                        	LOD2:
FFFC5328 BF0FF0EF		call	GOAUXI		; get another text char.
FFFC532C FF205EE3		ble		a0,r0,LOD2
FFFC5330 012E0023		sb		a0,[$t2]		; store it
FFFC5334 001E0E13		add		$t2,$t2,#1
FFFC5338 00D06D93		ldi		$t1,#CR
FFFC533C FFB916E3		bne		a0,$t1,LOD2		; is it the end of the line? if not, go back for more
FFFC5340 FA000EE3		bra		LOD1		; if so, start a new line
                        	LODEND:
FFFC5344 00030637		sw		$t2,TXTUNF	; set end-of program pointer
FFFC5348 00460613
FFFC534C 00060633
FFFC5350 01C62023
FFFC5354 CD0FF06F		jmp		WSTART		; back to direct mode
                        	
                        	
                        	; get character from input (32 bit value)
                        	GCHAR:
FFFC5358 FF470713		sub		$sp,$sp,#12
FFFC535C 00572023		sw		r5,[$sp]
FFFC5360 00672223		sw		r6,4[$sp]
FFFC5364 00172423		sw		$ra,8[$sp]
FFFC5368 00806313		ldi		r6,#8       ; repeat ten times
FFFC536C 00006293		ldi		r5,#0
                        	GCHAR1:
FFFC5370 BA8FF0EF		call	GOAUXI		; get a char
FFFC5374 FF205EE3		ble		a0,r0,GCHAR1
FFFC5378 02C000EF		call	asciiToHex
FFFC537C 00429293		sll		r5,r5,#4
FFFC5380 0122E2B3		or		r5,r5,a0
FFFC5384 FFF30313		sub		r6,r6,#1
FFFC5388 FE6064E3		bgtu	r6,r0,GCHAR1
FFFC538C 0002E933		mov		a0,r5
FFFC5390 00072283		lw		r5,[$sp]
FFFC5394 00472303		lw		r6,4[$sp]
FFFC5398 00872083		lw		$ra,8[$sp]
FFFC539C 00C70713		add		$sp,$sp,#12
FFFC53A0 00008067		ret
                        	
                        	; convert an ascii char to hex code
                        	; input
                        	;	a0 = char to convert
                        	
                        	asciiToHex:
FFFC53A4 03906D93		ldi		$t1,#'9'
FFFC53A8 012DF463		bleu	a0,$t1,a2h1; less than '9'
FFFC53AC FF990913		sub		a0,a0,#7	; shift 'A' to '9'+1
                        	a2h1:
FFFC53B0 FD090913		sub		a0,a0,#'0'
FFFC53B4 00F97913		and		a0,a0,#15	; make sure a nybble
FFFC53B8 00008067		ret
                        	
                        	GetFilename:
FFFC53BC FFC70713		sub		$sp,$sp,#4
FFFC53C0 00172023		sw		$ra,[$sp]
FFFC53C4 120010EF		call	TSTC
FFFC53C8 00000022		dw		'"'
FFFC53CC 06000863		bra		gfn1
FFFC53D0 000061B3		mov		r3,r0
                        	gfn2:
FFFC53D4 000E4903		lbu		a0,[$t2]		; get text character
FFFC53D8 001E0E13		add		$t2,$t2,#1
FFFC53DC 02206D93		ldi		$t1,#'"'
FFFC53E0 03B90863		beq		a0,$t1,gfn3
FFFC53E4 02090663		beq		a0,r0,gfn3
FFFC53E8 0003F637		sb		a0,FILENAME[r3]
FFFC53EC 6C060613
FFFC53F0 00360633
FFFC53F4 01260023
FFFC53F8 00118193		add		r3,r3,#1
FFFC53FC 04006D93		ldi		$t1,#64
FFFC5400 FDB1EAE3		bltu	r3,$t1,gfn2
FFFC5404 00072083		lw		$ra,[$sp]
FFFC5408 00470713		add		$sp,$sp,#4
FFFC540C 00008067		ret
                        	gfn3:
FFFC5410 02006913		ldi		a0,#' '
FFFC5414 0003F637		sb		a0,FILENAME[r3]
FFFC5418 6C060613
FFFC541C 00360633
FFFC5420 01260023
FFFC5424 00118193		add		r3,r3,#1
FFFC5428 04006D93		ldi		$t1,#64
FFFC542C FFB1E2E3		bltu	r3,$t1,gfn3
FFFC5430 00072083		lw		$ra,[$sp]
FFFC5434 00470713		add		$sp,$sp,#4
FFFC5438 00008067		ret
                        	gfn1:
FFFC543C BE8FF06F		jmp		WSTART
                        	
                        	LOAD3:
FFFC5440 F7DFF0EF		call	GetFilename
FFFC5444 00000637		call	AUXIN_INIT
FFFC5448 3AE600E7
FFFC544C EA1FF06F		jmp		LOAD
                        	
                        	;	call		OREXPR		;evaluate the following expression
                        	;	ld		a0,#5000
FFFC5450 000019B7		ldi		a1,#$E00
FFFC5454 E0098993
FFFC5458 00000637		call	SDReadSector
FFFC545C 3AF600E7
FFFC5460 00190913		add		a0,a0,#1
FFFC5464 000329B7		ldi		a1,#TXTBGN
FFFC5468 80098993
                        	LOAD4:
FFFC546C FFC70713		sub		$sp,$sp,#4
FFFC5470 01272023		sw		a0,[$sp]
FFFC5474 00000637		call	SDReadSector
FFFC5478 3AF600E7
FFFC547C 20098993		add		a1,a1,#512
FFFC5480 00072903		lw		a0,[$sp]
FFFC5484 00470713		add		$sp,$sp,#4
FFFC5488 00190913		add		a0,a0,#1
FFFC548C 00032237		ldi		r4,#TXTBGN
FFFC5490 80020213
FFFC5494 00010637		add		r4,r4,#65536
FFFC5498 00060613
FFFC549C 00460233
FFFC54A0 FC49C6E3		blt		a1,r4,LOAD4
                        	LOAD5:
FFFC54A4 B8000063		bra		WSTART
                        	
                        	
                        	SAVE3:
FFFC54A8 F15FF0EF		call	GetFilename
FFFC54AC 00000637		call	AUXOUT_INIT
FFFC54B0 3B2600E7
FFFC54B4 0600006F		jmp		SAVE
                        	
FFFC54B8 220000EF		call	OREXPR		;evaluate the following expression
                        	;	lda		#5000		; starting sector
FFFC54BC 000019B7		ldi		a1,#$E00	; starting address to write
FFFC54C0 E0098993
FFFC54C4 00000637		call	SDWriteSector
FFFC54C8 3B4600E7
FFFC54CC 00190913		add		a0,a0,#1
FFFC54D0 000329B7		ldi		a1,#TXTBGN
FFFC54D4 80098993
                        	SAVE4:
FFFC54D8 FFC70713		sub		$sp,$sp,#4
FFFC54DC 01272023		sw		a0,[$sp]
FFFC54E0 00000637		call	SDWriteSector
FFFC54E4 3B4600E7
FFFC54E8 20098993		add		a1,a1,#512
FFFC54EC 00072903		lw		a0,[$sp]
FFFC54F0 00470713		add		$sp,$sp,#4
FFFC54F4 00190913		add		a0,a0,#1
FFFC54F8 00032237		ldi		r4,#TXTBGN
FFFC54FC 80020213
FFFC5500 00010637		add		r4,r4,#65536
FFFC5504 00060613
FFFC5508 00460233
FFFC550C FC49C6E3		blt		a1,r4,SAVE4
FFFC5510 B0000A63		bra		WSTART
                        	
                        	SAVE:
FFFC5514 00032E37		ldi		$t2,#TXTBGN	;set pointer to start of prog. area
FFFC5518 800E0E13
FFFC551C 00030637		lw		$t3,TXTUNF	;set pointer to end of prog. area
FFFC5520 00460613
FFFC5524 00060633
FFFC5528 00062E83
                        	SAVE1:
FFFC552C 054000EF		call	AUXOCRLF    ; send out a CR & LF (CP/M likes this)
FFFC5530 03CEC863		bgt		$t2,$t3,SAVEND; are we finished?
FFFC5534 03A06913		ldi		a0,#':'		; if not, start a line
FFFC5538 9D8FF0EF		call	GOAUXO
FFFC553C 000E2903		lw		a0,[$t2]		; get line number
FFFC5540 004E0E13		add		$t2,$t2,#4
FFFC5544 060000EF		call	PWORD       ; output line number as 5-digit hex
                        	SAVE2:
FFFC5548 000E4903		lbu		a0,[$t2]		; get a text char.
FFFC554C 001E0E13		add		$t2,$t2,#1
FFFC5550 00D06D93		ldi		$t1,#CR
FFFC5554 FDB90CE3		beq		a0,$t1,SAVE1	; is it the end of the line? if so, send CR & LF and start new line
FFFC5558 9B8FF0EF		call	GOAUXO		; send it out
FFFC555C FE0006E3		bra		SAVE2		; go back for more text
                        	SAVEND:
FFFC5560 04006913		ldi		a0,#'@'		; send end-of-program indicator
FFFC5564 9ACFF0EF		call	GOAUXO
FFFC5568 018000EF		call	AUXOCRLF    ; followed by a CR & LF
FFFC556C 01A06913		ldi		a0,#$1A		; and a control-Z to end the CP/M file
FFFC5570 9A0FF0EF		call	GOAUXO
FFFC5574 00000637		call	AUXOUT_FLUSH
FFFC5578 3BB600E7
FFFC557C AA000463		bra		WSTART		; then go do a warm start
                        	
                        	; output a CR LF sequence to auxillary output
                        	; Registers Affected
                        	;   r3 = LF
                        	AUXOCRLF:
FFFC5580 FFC70713		sub		$sp,$sp,#4
FFFC5584 00172023		sw		$ra,[$sp]
FFFC5588 00D06913	  ldi		a0,#CR
FFFC558C 984FF0EF	  call	GOAUXO
FFFC5590 00A06913	  ldi		a0,#LINEFD
FFFC5594 97CFF0EF	  call	GOAUXO
FFFC5598 00072083	  lw		$ra,[$sp]
FFFC559C 00470713	  add		$sp,$sp,#4
FFFC55A0 00008067	  ret
                        	
                        	
                        	; output a word in hex format
                        	; tricky because of the need to reverse the order of the chars
                        	PWORD:
FFFC55A4 FF870713		sub		$sp,$sp,#8
FFFC55A8 00572023		sw		r5,[$sp]
FFFC55AC 00172223		sw		$ra,4[$sp]
FFFC55B0 000302B7		ldi		r5,#NUMWKA+14
FFFC55B4 0A228293
FFFC55B8 00096233		mov		r4,a0		; r4 = value
                        	pword1:
FFFC55BC 00026933	  mov   a0,r4	    ; a0 = value
FFFC55C0 00425213	  srl		r4,r4,#4	; shift over to next nybble
FFFC55C4 040000EF	  call	toAsciiHex  ; convert LS nybble to ascii hex
FFFC55C8 01228023	  sb    a0,[r5]		; save in work area
FFFC55CC FFF28293	  sub		r5,r5,#1
FFFC55D0 00030DB7	  ldi		$t1,#NUMWKA
FFFC55D4 094D8D93
FFFC55D8 FFB2D2E3		bge		r5,$t1,pword1
                        	pword2:
FFFC55DC 00128293	  add		r5,r5,#1
FFFC55E0 0002C903	  lbu   a0,[r5]     ; get char to output
FFFC55E4 92CFF0EF		call	GOAUXO		; send it
FFFC55E8 00030DB7		ldi		$t1,#NUMWKA+14
FFFC55EC 0A2D8D93
FFFC55F0 FFB2C6E3		blt		r5,$t1,pword2
FFFC55F4 00072283		lw		r5,[$sp]
FFFC55F8 00472083		lw		$ra,4[$sp]
FFFC55FC 00870713		add		$sp,$sp,#8
FFFC5600 00008067		ret
                        	
                        	; convert nybble in a1 to ascii hex chaa1
                        	; a1 = character to convert
                        	
                        	toAsciiHex:
FFFC5604 00F97913		and		a0,a0,#15	; make sure it's a nybble
FFFC5608 00A06D93		ldi		$t1,#10
FFFC560C 01B94463		blt		a0,$t1,tah1	; > 10 ?
FFFC5610 00790913		add		a0,a0,#7	; bump it up to the letter 'A'
                        	tah1:
FFFC5614 03090913		add		a0,a0,#'0'	; bump up to ascii '0'
FFFC5618 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	; *** POKE ***
                        	;
                        	; 'POKE expr1,expa1' stores the byte from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEW expr1,expa1' stores the word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEH expr1,expa1' stores the half-word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	;******************************************************************
                        	;
                        	POKE:
FFFC561C 0BC000EF		call	OREXPR		; get the memory address
FFFC5620 6C5000EF		call	TSTC		; it must be followed by a comma
FFFC5624 0000002C		dw		','
FFFC5628 06000C63		bra		PKER
FFFC562C FFC70713		sub		$sp,$sp,#4
FFFC5630 01272023		sw		a0,[$sp]	; save the address
FFFC5634 0A4000EF		call	OREXPR		; get the byte to be POKE'd
FFFC5638 00072983		lw		a1,[$sp]	; get the address back
FFFC563C 00470713		add		$sp,$sp,#4
FFFC5640 01298023		sb		a0,[a1]		; store the byte in memory
FFFC5644 8B5FF06F		jmp		FINISH
                        	
                        	POKEW:
FFFC5648 090000EF		call	OREXPR		; get the memory address
FFFC564C 699000EF		call	TSTC		; it must be followed by a comma
FFFC5650 0000002C		dw		','
FFFC5654 04000663		bra		PKER
FFFC5658 FFC70713		sub		$sp,$sp,#4
FFFC565C 01272023		sw		a0,[$sp]	; save the address
FFFC5660 078000EF		call	OREXPR		; get the byte to be POKE'd
FFFC5664 00072983		lw		a1,[$sp]	; get the address back
FFFC5668 00470713		add		$sp,$sp,#4
FFFC566C 0129A023		sw		a0,[a1]		; store the byte in memory
FFFC5670 889FF06F		jmp		FINISH
                        	
                        	POKEH:
FFFC5674 064000EF		call	OREXPR		; get the memory address
FFFC5678 66D000EF		call	TSTC		; it must be followed by a comma
FFFC567C 0000002C		dw		','
FFFC5680 02000063		bra		PKER
FFFC5684 FFC70713		sub		$sp,$sp,#4
FFFC5688 01272023		sw		a0,[$sp]	; save the address
FFFC568C 04C000EF		call	OREXPR		; get the byte to be POKE'd
FFFC5690 00072983		lw		a1,[$sp]	; get the address back
FFFC5694 00470713		add		$sp,$sp,#4
FFFC5698 01299023		sh		a0,[a1]		; store the byte in memory
FFFC569C 85DFF06F		jmp		FINISH
                        	
                        	PKER:
FFFC56A0 FFFC7937		ldi		a0,#msgComma
FFFC56A4 98290913
FFFC56A8 0D10006F		jmp		ERROR		; if no comma, say "What?"
                        	
                        	;******************************************************************
                        	; 'SYSX expr' jumps to the machine language subroutine whose
                        	; starting address is specified by 'expr'.  The subroutine can use
                        	; all registers but must leave the stack the way it found it.
                        	; The subroutine returns to the interpreter by executing an RTS.
                        	;******************************************************************
                        	
                        	SYSX:
FFFC56AC 02C000EF		call	OREXPR		; get the subroutine's address
FFFC56B0 00081863		bne		v0,r0,sysx1; make sure we got a valid address
FFFC56B4 FFFC7937		ldi		a0,#msgSYSBad
FFFC56B8 9D390913
FFFC56BC 0BD0006F		jmp		ERROR
                        	sysx1:
FFFC56C0 FFC70713		sub		$sp,$sp,#4
FFFC56C4 01C72023		stt		$t2,[$sp]	; save the text pointer
FFFC56C8 000800E7		call	[v0]			; jump to the subroutine
FFFC56CC 00072E03		ldt		$t2,[$sp]	; restore the text pointer
FFFC56D0 00470713		add		$sp,$sp,#4
FFFC56D4 825FF06F		jmp		FINISH
                        	
                        	;******************************************************************
                        	; *** EXPR ***
                        	;
                        	; 'EXPR' evaluates arithmetical or logical expressions.
                        	; <OREXPR>::= <ANDEXPR> OR <ANDEXPR> ...
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	; <EXPR>::=<ADDEXPR>
                        	;	   <ADDEXPR><rel.op.><ADDEXPR>
                        	; where <rel.op.> is one of the operators in TAB8 and the result
                        	; of these operations is 1 if true and 0 if false.
                        	; <ADDEXPR>::=(+ or -)<MULEXPR>(+ or -)<MULEXPR>(...
                        	; where () are optional and (... are optional repeats.
                        	; <MULEXPR>::=<FUNCEXPR>( <* or /><FUNCEXPR> )(...
                        	; <FUNCEXPR>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                        	; as an index, functions can have an <EXPR> as arguments, and
                        	; <FUNCEXPR> can be an <EXPR> in parenthesis.
                        	;
                        	
                        	; <OREXPR>::=<ANDEXPR> OR <ANDEXPR> ...
                        	;
                        	OREXPR:
FFFC56D8 FF470713		sub		$sp,$sp,#12
FFFC56DC 00172023		sw		$ra,[$sp]
FFFC56E0 00372223		sw		r3,4[$sp]
FFFC56E4 00472423		sw		r4,8[$sp]
FFFC56E8 058000EF		call	ANDEXPR		; get first <ANDEXPR>
                        	XP_OR1:
FFFC56EC FF870713		sub		$sp,$sp,#8
FFFC56F0 01072023		sw		$v0,[$sp]		; save <ANDEXPR> value
FFFC56F4 01172223		sw		$v1,4[$sp]	; save type
FFFC56F8 FFFC5EB7		ldi		$t3,#TAB10	; look up a logical operator
FFFC56FC AE6E8E93
FFFC5700 FFFC5F37		ldi		$t4,#TAB10_1
FFFC5704 B56F0F13
FFFC5708 C68FF06F		jmp		EXEC		; go do it
                        	XP_OR:
FFFC570C 034000EF	  call	ANDEXPR
FFFC5710 00072903	  lw		$a0,[$sp]
FFFC5714 00870713	  add		$sp,$sp,#8
FFFC5718 01286833	  or    v0,v0,a0
FFFC571C FC0008E3	  bra   XP_OR1
                        	XP_ORX:
FFFC5720 00072803	  lw		$v0,[$sp]
FFFC5724 00472883	  lw		$v1,4[$sp]
FFFC5728 00870713	  add		$sp,$sp,#8
FFFC572C 00072083		lw		$ra,[$sp]
FFFC5730 00472183		lw		r3,4[$sp]
FFFC5734 00872203		lw		r4,8[$sp]
FFFC5738 00C70713		add		$sp,$sp,#12
FFFC573C 00008067	  ret
                        	
                        	
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	;
                        	ANDEXPR:
FFFC5740 FFC70713		sub		$sp,$sp,#4
FFFC5744 00172023		sw		$ra,[$sp]
FFFC5748 0E8000EF		call	EXPR		; get first <EXPR>
                        	XP_AND1:
FFFC574C FF870713		sub		$sp,$sp,#8
FFFC5750 01072023		sw		$v0,[$sp]		; save <EXPR> value
FFFC5754 01172223		sw		$v1,4[$sp]	; save type
FFFC5758 FFFC5EB7		ldi		$t3,#TAB9		; look up a logical operator
FFFC575C AE2E8E93
FFFC5760 FFFC5F37		ldi		$t4,#TAB9_1
FFFC5764 B52F0F13
FFFC5768 C08FF06F		jmp		EXEC		; go do it
                        	XP_AND:
FFFC576C 0C4000EF	  call	EXPR
FFFC5770 00072903	  lw		$a0,[$sp]
FFFC5774 00870713	  add		$sp,$sp,#8
FFFC5778 01287833	  and   v0,v0,a0
FFFC577C FC0008E3	  bra   XP_AND1
                        	XP_ANDX:
FFFC5780 00072803	  lw		$v0,[$sp]
FFFC5784 00472883	  lw		$v1,4[$sp]
FFFC5788 00870713	  add		$sp,$sp,#8
FFFC578C 00072083		lw		$ra,[$sp]
FFFC5790 00470713		add		$sp,$sp,#4
FFFC5794 00008067	  ret
                        	
                        	
                        	; Determine if the character is a digit
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if digit, otherwise 0
                        	;
                        	isDigit:
FFFC5798 03006D93		ldi		$t1,#'0'
FFFC579C 01B94A63		blt		a0,$t1,isDigitFalse
FFFC57A0 03906D93		ldi		$t1,#'9'
FFFC57A4 012DC663		bgt		a0,$t1,isDigitFalse
FFFC57A8 00106813		ldi		v0,#1
FFFC57AC 00008067	  ret
                        	isDigitFalse:
FFFC57B0 00006833	  mov		v0,r0
FFFC57B4 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphabetic
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlpha:
FFFC57B8 04106D93		ldi		$t1,#'A'
FFFC57BC 03B94263		blt		a0,$t1,isAlphaFalse
FFFC57C0 05A06D93		ldi		$t1,#'Z'
FFFC57C4 012DDA63		ble		a0,$t1,isAlphaTrue
FFFC57C8 06106D93		ldi		$t1,#'a'
FFFC57CC 01B94A63		blt		a0,$t1,isAlphaFalse
FFFC57D0 07A06D93		ldi		$t1,#'z'
FFFC57D4 012DC663		bgt		a0,$t1,isAlphaFalse
                        	isAlphaTrue:
FFFC57D8 00106813	  ldi		v0,#1
FFFC57DC 00008067	  ret
                        	isAlphaFalse:
FFFC57E0 00006833	  mov		v0,r0
FFFC57E4 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphanumeric
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlnum:
FFFC57E8 FFC70713		sub		$sp,$sp,#4
FFFC57EC 00172023		sw		$ra,[$sp]
FFFC57F0 FA9FF0EF	  call	isDigit
FFFC57F4 00081463		bne		v0,r0,isDigitx	; if it is a digit
FFFC57F8 FC1FF0EF	  call  isAlpha
                        	isDigitx:
FFFC57FC 00072083		lw		$ra,[$sp]
FFFC5800 00470713		add		$sp,$sp,#4
FFFC5804 00008067	  ret
                        	
                        	FORCEFIT:
FFFC5808 03198263		beq		a1,v1,.0001				; types match
FFFC580C 00006D13		ldi		$t0,#0
FFFC5810 01A98663		beq		a1,$t0,.intAnd
                        	;	itof	$f1,$v0
FFFC5814 00106913		ldi		a0,#1
FFFC5818 00008067		ret
                        	.intAnd:
FFFC581C 00106D13		ldi		$t0,#1
FFFC5820 01A89663		bne		$v1,$t0,.0001
                        	;	itof	$f2,$a1
FFFC5824 00106993		ldi		$a1,#1
FFFC5828 00008067		ret
                        	.0001:
FFFC582C 00008067		ret
                        	
                        	EXPR:
FFFC5830 FFC70713		sub		$sp,$sp,#4
FFFC5834 00172023		sw		$ra,[$sp]
FFFC5838 11C000EF		call	ADDEXPR
FFFC583C FF870713		sub		$sp,$sp,#8				; save <ADDEXPR> value
FFFC5840 01072023		sw		v0,[$sp]
FFFC5844 01172223		sw		v1,4[$sp]					; save type
FFFC5848 FFFC5EB7		ldi		$t3,#TAB8		; look up a relational operator
FFFC584C AD8E8E93
FFFC5850 FFFC5F37		ldi		$t4,#TAB8_1
FFFC5854 B44F0F13
FFFC5858 B18FF06F		jmp		EXEC		; go do it
                        	XP11:
FFFC585C 00072903		lw		a0,[$sp]
FFFC5860 00472983		lw		a1,4[$sp]
FFFC5864 00870713		add		$sp,$sp,#8
FFFC5868 0C4000EF		call	XP18	; is it ">="?
FFFC586C 09095A63		bge		a0,v0,XPRT1	; no, return v0=1
FFFC5870 06000E63		bra		XPRT0	; else return v0=0
                        	XP12:
FFFC5874 00072903		lw		a0,[$sp]
FFFC5878 00472983		lw		a1,4[$sp]
FFFC587C 00870713		add		$sp,$sp,#8
FFFC5880 0AC000EF		call	XP18	; is it "<>"?
FFFC5884 07091E63		bne		a0,v0,XPRT1	; no, return a1=1
FFFC5888 06000263		bra		XPRT0	; else return a1=0
                        	XP13:
FFFC588C 00072903		lw		a0,[$sp]
FFFC5890 00472983		lw		a1,4[$sp]
FFFC5894 00870713		add		$sp,$sp,#8
FFFC5898 094000EF		call	XP18	; is it ">"?
FFFC589C 07284263		bgt		a0,v0,XPRT1	; no, return a1=1
FFFC58A0 04000663		bra		XPRT0	; else return a1=0
                        	XP14:
FFFC58A4 00072903		lw		a0,[$sp]
FFFC58A8 00472983		lw		a1,4[$sp]
FFFC58AC 00870713		add		$sp,$sp,#8
FFFC58B0 07C000EF		call	XP18	; is it "<="?
FFFC58B4 05285663		ble		a0,v0,XPRT1	; no, return a1=1
FFFC58B8 02000A63		bra		XPRT0	; else return a1=0
                        	XP15:
FFFC58BC 00072903		lw		a0,[$sp]
FFFC58C0 00472983		lw		a1,4[$sp]
FFFC58C4 00870713		add		$sp,$sp,#8
FFFC58C8 064000EF		call	XP18	; is it "="?
FFFC58CC 03090A63		beq		a0,v0,XPRT1	; if not, return a1=1
FFFC58D0 00000E63		bra		XPRT0	; else return a1=0
                        	XP16:
FFFC58D4 00072903		lw		a0,[$sp]
FFFC58D8 00472983		lw		a1,4[$sp]
FFFC58DC 00870713		add		$sp,$sp,#8
FFFC58E0 04C000EF		call	XP18	; is it "<"?
FFFC58E4 01094E63		blt		a0,v0,XPRT1	; if not, return a1=1
FFFC58E8 00000263		bra		XPRT0	; else return a1=0
                        	XPRT0:
FFFC58EC 00006833		mov		v0,x0   ; return a0=0 (false)
FFFC58F0 000068B3		mov		v1,x0		; type = int
FFFC58F4 00072083		lw		$ra,[$sp]
FFFC58F8 00470713		add		$sp,$sp,#4
FFFC58FC 00008067		ret
                        	XPRT1:
FFFC5900 00106813		ldi		v0,#1	; return a0=1 (true)
FFFC5904 00006893		ldi		v1,#0	; type = int
FFFC5908 00072083		lw		$ra,[$sp]
FFFC590C 00470713		add		$sp,$sp,#4
FFFC5910 00008067		ret
                        	
                        	XP17:				; it's not a rel. operator
FFFC5914 00072803		lw		v0,[$sp]; return a1=<ADDEXPR>
FFFC5918 00472883		lw		v1,4[$sp]
FFFC591C 00870713		add		$sp,$sp,#8
FFFC5920 00072083		lw		$ra,[$sp]
FFFC5924 00470713		add		$sp,$sp,#4
FFFC5928 00008067		ret
                        	
                        	XP18:
FFFC592C FF470713		sub		$sp,$sp,#12
FFFC5930 00172023		sw		$ra,[$sp]
FFFC5934 01072223		sw		v0,4[$sp]
FFFC5938 01172423		sw		v1,8[$sp]
FFFC593C 018000EF		call	ADDEXPR		; do a second <ADDEXPR>
FFFC5940 00472903		lw		a0,4[$sp]
FFFC5944 00872983		lw		a1,8[$sp]
FFFC5948 00072083		lw		$ra,[$sp]
FFFC594C 00C70713		add		$sp,$sp,#12
FFFC5950 00008067		ret
                        	
                        	; <ADDEXPR>::=(+ or -)<MULEXPR>(+ or -)<MULEXPR>(...
                        	//message "ADDEXPR"
                        	ADDEXPR:
FFFC5954 FFC70713		sub		$sp,$sp,#4
FFFC5958 00172023		sw		$ra,[$sp]
FFFC595C 389000EF		call	TSTC		; negative sign?
FFFC5960 0000002D		dw		'-'
FFFC5964 00000C63		bra		XP21
FFFC5968 00006833		mov		v0,r0		; yes, fake '0-'
FFFC596C FF870713		sub		$sp,$sp,#8
FFFC5970 01072023		sw		v0,[$sp]
FFFC5974 01172223		sw		v1,4[$sp]
FFFC5978 04000863		bra		XP26
                        	XP21:
FFFC597C 369000EF		call	TSTC		; positive sign? ignore it
FFFC5980 0000002B		dw		'+'
FFFC5984 00000263		bra		XP22
                        	XP22:
FFFC5988 064000EF		call	MULEXPR		; first <MULEXPR>
                        	XP23:
FFFC598C FF870713		sub		$sp,$sp,#8; yes, save the value
FFFC5990 01072023		sw		v0,[$sp]
FFFC5994 01172223		sw		v1,4[$sp]	; and type
FFFC5998 34D000EF		call	TSTC		; add?
FFFC599C 0000002B		dw		'+'
FFFC59A0 00000E63		bra		XP25
FFFC59A4 048000EF		call	MULEXPR		; get the second <MULEXPR>
                        	XP24:
FFFC59A8 00072903		lw		a0,[$sp]
FFFC59AC 00472983		lw		a1,4[$sp]
FFFC59B0 00870713		add		$sp,$sp,#8
FFFC59B4 01280833		add		v0,v0,a0	; add it to the first <MULEXPR>
                        	;	BVS.L	QHOW		brnch if there's an overflow
FFFC59B8 FC000AE3		bra		XP23		; else go back for more operations
                        	XP25:
FFFC59BC 329000EF		call	TSTC		; subtract?
FFFC59C0 0000002D		dw		'-'
FFFC59C4 00000863		bra		XP45
                        	XP26:
FFFC59C8 024000EF		call	MULEXPR		; get second <MULEXPR>
FFFC59CC 41000833		sub		v0,r0,v0	; change its sign
FFFC59D0 FC000CE3		bra		XP24		; and do an addition
                        	XP45:
FFFC59D4 00072803		lw		v0,[$sp]
FFFC59D8 00472883		lw		v1,4[$sp]
FFFC59DC 00870713		add		$sp,$sp,#8
FFFC59E0 00072083		lw		$ra,[$sp]
FFFC59E4 00470713		add		$sp,$sp,#4
FFFC59E8 00008067		ret
                        	
                        	
                        	; <MULEXPR>::=<FUNCEXPR>( <* or /><FUNCEXPR> )(...
                        	
                        	MULEXPR:
FFFC59EC FFC70713		sub		$sp,$sp,#4
FFFC59F0 00172023		sw		$ra,[$sp]
FFFC59F4 094000EF		call	FUNCEXPR		; get first <FUNCEXPR>
                        	XP31:
FFFC59F8 FF870713		sub		$sp,$sp,#8
FFFC59FC 01072023		sw		v0,[$sp]; yes, save that first result
FFFC5A00 01172223		sw		v1,4[$sp]
FFFC5A04 2E1000EF		call	TSTC		; multiply?
FFFC5A08 0000002A		dw		'*'
FFFC5A0C 00000E63		bra		XP34
FFFC5A10 078000EF		call	FUNCEXPR		; get second <FUNCEXPR>
FFFC5A14 00072903		lw		a0,[$sp]
FFFC5A18 00472983		lw		a1,4[$sp]
FFFC5A1C 00870713		add		$sp,$sp,#8
FFFC5A20 03280833		mul		v0,v0,a0	; multiply the two
FFFC5A24 FC000AE3		bra		XP31        ; then look for more terms
                        	XP34:
FFFC5A28 2BD000EF		call	TSTC		; divide?
FFFC5A2C 0000002F		dw		'/'
FFFC5A30 00000E63		bra		XP35
FFFC5A34 054000EF		call	FUNCEXPR		; get second <FUNCEXPR>
FFFC5A38 00072903		lw		a0,[$sp]
FFFC5A3C 00472983		lw		a1,4[$sp]
FFFC5A40 00870713		add		$sp,$sp,#8
FFFC5A44 03284833		div		v0,v0,a0	; do the division
FFFC5A48 FA0008E3		bra		XP31		; go back for any more terms
                        	XP35:
FFFC5A4C 299000EF		call	TSTC
FFFC5A50 00000025		dw		'%'
FFFC5A54 00000E63		bra		XP47
FFFC5A58 030000EF		call	FUNCEXPR
FFFC5A5C 00072903		lw		a0,[$sp]
FFFC5A60 00472983		lw		a1,4[$sp]
FFFC5A64 00870713		add		$sp,$sp,#8
FFFC5A68 03286833		rem		v0,v0,a0
FFFC5A6C F80006E3		bra		XP31
                        	XP47:
FFFC5A70 00072803		lw		v0,[$sp]
FFFC5A74 00472883		lw		v1,4[$sp]
FFFC5A78 00870713		add		$sp,$sp,#8
FFFC5A7C 00072083		lw		$ra,[$sp]
FFFC5A80 00470713		add		$sp,$sp,#4
FFFC5A84 00008067		ret
                        	
                        	
                        	; Functions are called through FUNCEXPR
                        	; <FUNCEXPR>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	
                        	FUNCEXPR:
FFFC5A88 FFC70713		sub		$sp,$sp,#4
FFFC5A8C 00172023		sw		$ra,[$sp]
FFFC5A90 FFFC5EB7	  ldi		$t3,#TAB4		; find possible function
FFFC5A94 A97E8E93
FFFC5A98 FFFC5F37	  ldi		$t4,#TAB4_1
FFFC5A9C B22F0F13
FFFC5AA0 8D0FF06F		jmp		EXEC        ; branch to function which does subsequent ret for FUNCEXPR
                        	XP40:                   ; we get here if it wasn't a function
FFFC5AA4 00006933		mov		a0,x0
FFFC5AA8 070000EF		call	TSTV
FFFC5AAC 00080A63		beq   v0,x0,XP41	; not a variable
FFFC5AB0 00082803		lw		$v0,[$v0]		; if a variable, return its value in v0
FFFC5AB4 00072083		lw		$ra,[$sp]
FFFC5AB8 00470713		add		$sp,$sp,#4
FFFC5ABC 00008067		ret
                        	XP41:
FFFC5AC0 271000EF		call	TSTNUM		; or is it a number?
FFFC5AC4 00089463		bne		v1,x0,XP46	; (if not, # of digits will be zero) if so, return it in v0
FFFC5AC8 010000EF		call	PARN        ; check for (EXPR)
                        	XP46:
FFFC5ACC 00072083		lw		$ra,[$sp]
FFFC5AD0 00470713		add		$sp,$sp,#4
FFFC5AD4 00008067		ret
                        	
                        	
                        	; Check for a parenthesized expression
                        	PARN:
FFFC5AD8 FFC70713		sub		$sp,$sp,#4
FFFC5ADC 00172023		sw		$ra,[$sp]	
FFFC5AE0 205000EF		call	TSTC		; else look for ( OREXPR )
FFFC5AE4 00000028		dw		'('
FFFC5AE8 02000063		bra		XP43
FFFC5AEC BEDFF0EF		call	OREXPR
FFFC5AF0 1F5000EF		call	TSTC
FFFC5AF4 00000029		dw		')'
FFFC5AF8 00000863		bra		XP43
                        	XP42:
FFFC5AFC 00072083		lw		$ra,[$sp]
FFFC5B00 00470713		add		$sp,$sp,#4
FFFC5B04 00008067		ret
                        	XP43:
FFFC5B08 00470713		add		$sp,$sp,#4		; get rid of return address
FFFC5B0C FFFC7937		ldi		a0,#msgWhat
FFFC5B10 90890913
FFFC5B14 4640006F		jmp		ERROR
                        	
                        	
                        	; ===== Test for a valid variable name.  Returns Z=1 if not
                        	;	found, else returns Z=0 and the address of the
                        	;	variable in a0.
                        	; Parameters
                        	;		a0 = 1 = allocate if not found
                        	; Returns
                        	;		v0 = address of variable, zero if not found
                        	
                        	TSTV:
FFFC5B18 FF870713		sub		$sp,$sp,#8
FFFC5B1C 00572023		sw		r5,[$sp]
FFFC5B20 00172223		sw		$ra,4[$sp]
FFFC5B24 000962B3		mov		r5,a0		; r5=allocate flag
FFFC5B28 27D000EF		call	IGNBLK
FFFC5B2C 000E4903		lbu		a0,[$t2]		; look at the program text
FFFC5B30 04006D93		ldi		$t1,#'@'
FFFC5B34 07B94863		blt		a0,$t1,tstv_notfound	; C=1: not a variable
FFFC5B38 05B91463		bne		a0,$t1,TV1				; brnch if not "@" array
FFFC5B3C 001E0E13		add		$t2,$t2,#1	; If it is, it should be
FFFC5B40 F99FF0EF		call	PARN		; followed by (EXPR) as its index.
                        	;	BCS.L	QHOW		say "How?" if index is too big
FFFC5B44 00000263		bra		TV3
                        	TV3:
FFFC5B48 FFC70713		sub		$sp,$sp,#4	; save the index
FFFC5B4C 01072023		sw		v0,[$sp]
FFFC5B50 300000EF		call	SIZEX		; get amount of free memory
FFFC5B54 00072983		lw		a1,[$sp]
FFFC5B58 00470713		add		$sp,$sp,#4	; get back the index
FFFC5B5C 0109C663		blt		a1,v0,TV2		; see if there's enough memory
FFFC5B60 00870713		add		$sp,$sp,#8
FFFC5B64 4000006F		jmp   QSORRY		; if not, say "Sorry"
                        	TV2:
FFFC5B68 00030637		lw		a0,VARBGN	; put address of array element...
FFFC5B6C 00860613
FFFC5B70 00060633
FFFC5B74 00062903
FFFC5B78 41390833		sub   v0,a0,a1    ; into a0 (neg. offset is used)
FFFC5B7C 00000C63		bra   TSTVRT
                        	TV1:	
FFFC5B80 038000EF	  call	getVarName      ; get variable name
FFFC5B84 00080863	  beq   v0,x0,TSTVRT    ; if not, return v0=0
FFFC5B88 00086933	  mov		a0,v0
FFFC5B8C 0002E9B3	  mov		a1,r5
FFFC5B90 0D4000EF	  call	findVar     ; find or allocate
                        	TSTVRT:
FFFC5B94 00072283		lw		r5,[$sp]
FFFC5B98 00472083		lw		$ra,4[$sp]
FFFC5B9C 00870713		add		$sp,$sp,#8
FFFC5BA0 00008067		ret								; v0<>0 (if found)
                        	tstv_notfound:
FFFC5BA4 00072283		lw		r5,[$sp]
FFFC5BA8 00472083		lw		$ra,4[$sp]
FFFC5BAC 00870713		add		$sp,$sp,#8
FFFC5BB0 00006833		mov		v0,x0				; v0=0 if not found
FFFC5BB4 00008067	  ret
                        	
                        	; Get a variable name. Called after blanks have been ignored.
                        	;
                        	; Returns
                        	;   v0 = 3 character variable name + type
                        	;
                        	getVarName:
FFFC5BB8 FF470713		sub		$sp,$sp,#12
FFFC5BBC 00572023		sw		r5,[$sp]
FFFC5BC0 00172223		sw		$ra,4[$sp]
FFFC5BC4 000E4903	  lbu   a0,[$t2]		; get first character
FFFC5BC8 01272423	  sw		a0,8[$sp]		; save off current name
FFFC5BCC BEDFF0EF	  call	isAlpha
FFFC5BD0 08080063	  beq   v0,r0,gvn1
FFFC5BD4 00206293	  ldi	  r5,#2       ; loop two more times
                        	
                        		; check for second/third character
                        	gvn4:
FFFC5BD8 001E0E13		add		$t2,$t2,#1
FFFC5BDC 000E4903		lbu   a0,[$t2]		; do we have another char ?
FFFC5BE0 C09FF0EF		call	isAlnum
FFFC5BE4 02080863		beq   v0,x0,gvn2	; nope
FFFC5BE8 00872903		lw		a0,8[$sp]		; get varname
FFFC5BEC 00891913		sll		a0,a0,#8
FFFC5BF0 000E4983		lbu   a1,[$t2]
FFFC5BF4 01396933		or    a0,a0,a1   	; add in new char
FFFC5BF8 01272423	  sw		a0,8[$sp]		; save off current name again
FFFC5BFC FFF28293	  sub		r5,r5,#1
FFFC5C00 FC504CE3	  bgt		r5,x0,gvn4
                        	
                        	 	; now ignore extra variable name characters
                        	gvn6:
FFFC5C04 001E0E13		add		$t2,$t2,#1
FFFC5C08 000E4903		lbu   a0,[$t2]		; do we have another char ?
FFFC5C0C BDDFF0EF	  call  isAlnum
FFFC5C10 FE081AE3	  bne   v0,x0,gvn6	; keep looping as long as we have identifier chars
                        	
                        	  ; check for a variable type
                        	gvn2:
FFFC5C14 000E4983		lbu   a1,[$t2]
FFFC5C18 02506D93		ldi		$t1,#'%'
FFFC5C1C 01B98A63		beq		a1,$t1,gvn3
FFFC5C20 02406D93		ldi		$t1,#'$'
FFFC5C24 01B98663		beq		a1,$t1,gvn3
FFFC5C28 FFFE0E13	  sub		$t2,$t2,#1
FFFC5C2C 02E06993	  ldi		$a1,#'.'		; if no variable type assume float
                        	
                        	  ; insert variable type indicator and return
                        	gvn3:
FFFC5C30 001E0E13		add		$t2,$t2,#1
FFFC5C34 00872903		lw		a0,8[$sp]		; get varname
FFFC5C38 00891913		sll		a0,a0,#8
FFFC5C3C 01396833	  or    v0,a0,a1    ; add in variable type
FFFC5C40 00072283	  lw		r5,[$sp]
FFFC5C44 00472083	  lw		$ra,4[$sp]
FFFC5C48 00C70713	  add		$sp,$sp,#12
FFFC5C4C 00008067	  ret								; return a0 = varname
                        	
                        	  ; not a variable name
                        	gvn1:
FFFC5C50 00072283		lw		r5,[$sp]
FFFC5C54 00472083	  lw		$ra,4[$sp]
FFFC5C58 00C70713		add		$sp,$sp,#12
FFFC5C5C 00006833	  mov		v0,x0       ; return v0 = 0 if not a varname
FFFC5C60 00008067	  ret
                        	
                        	
                        	; Find variable
                        	;   a0 = varname
                        	;		a1 = allocate flag
                        	; Returns
                        	;   v0 = variable address, Z =0 if found / allocated, Z=1 if not found
                        	
                        	findVar:
FFFC5C64 FF870713		sub		$sp,$sp,#8
FFFC5C68 00772023		sw		x7,[$sp]
FFFC5C6C 00372223		sw		x3,4[$sp]
FFFC5C70 00030637	  lw    x3,VARBGN
FFFC5C74 00860613
FFFC5C78 00060633
FFFC5C7C 00062183
                        	fv4:
FFFC5C80 0001A383	  lw    x7,[x3]     ; get varname / type
FFFC5C84 02038C63	  beq   x7,x0,fv3		; no more vars ?
FFFC5C88 02790E63	  beq   a0,x7,fv1		; match ?
FFFC5C8C 00818193		add		x3,x3,#8		; move to next var
FFFC5C90 00030637	  lw    x7,VAREND		; 
FFFC5C94 00C60613
FFFC5C98 00060633
FFFC5C9C 00062383
FFFC5CA0 FE71C0E3	  blt   x3,x7,fv4		; loop back to look at next var
                        	
                        	  ; variable not found
                        	  ; no more memory
FFFC5CA4 00072383	  lw		x7,[$sp]
FFFC5CA8 00472183	  lw		x3,4[$sp]
FFFC5CAC 00870713	  add		$sp,$sp,#8
FFFC5CB0 FFFC7937	  ldi		a0,#msgVarSpace
FFFC5CB4 95690913
FFFC5CB8 2C00006F	  jmp   ERROR
                        	
                        	  ; variable not found
                        	  ; allocate new ?
                        	fv3:
FFFC5CBC 00098E63		beq		a1,x0,fv2
FFFC5CC0 0121A023	  sw    a0,[x3]     ; save varname / type
                        	  ; found variable
                        	  ; return address
                        	fv1:
FFFC5CC4 00418813	  add		v0,x3,#4
FFFC5CC8 00072383	  lw		x7,[$sp]
FFFC5CCC 00472183	  lw		x3,4[$sp]
FFFC5CD0 00870713	  add		$sp,$sp,#8
FFFC5CD4 00008067	  ret			    			; v0 = address
                        	
                        	  ; didn't find var and not allocating
                        	fv2:
FFFC5CD8 00072383	  lw		x7,[$sp]
FFFC5CDC 00472183	  lw		x3,4[$sp]
FFFC5CE0 00870713	  add		$sp,$sp,#8
FFFC5CE4 00006833		mov		v0,x0				; v0 = nullptr
FFFC5CE8 00008067	  ret
                        	
                        	; The following functions are entered via a jump instruction with
                        	; the return address already saved.
                        	
                        	; ===== The PEEK function returns the byte stored at the address
                        	;	contained in the following expression.
                        	;
                        	PEEK:
FFFC5CEC DEDFF0EF		call	PARN		; get the memory address
FFFC5CF0 00080803		lb		v0,[v0]		; get the addressed byte
FFFC5CF4 000068B3		mov		v1,x0			; type = int
FFFC5CF8 00072083		lw		$ra,[$sp]
FFFC5CFC 00470713		add		$sp,$sp,#4
FFFC5D00 00008067		ret
                        	PEEKW:
FFFC5D04 DD5FF0EF		call	PARN		; get the memory address
FFFC5D08 00082803		lw		v0,[v0]		; get the addressed word
FFFC5D0C 000068B3		mov		v1,x0			; type = int
FFFC5D10 00072083		lw		$ra,[$sp]
FFFC5D14 00470713		add		$sp,$sp,#4
FFFC5D18 00008067		ret
                        	PEEKH:
FFFC5D1C DBDFF0EF		call	PARN		; get the memory address
FFFC5D20 00081803		lh		v0,[v0]		; get the addressed byte
FFFC5D24 000068B3		mov		v1,x0			; type = int
FFFC5D28 00072083		lw		$ra,[$sp]
FFFC5D2C 00470713		add		$sp,$sp,#4
FFFC5D30 00008067		ret
                        	
                        	
                        	; user function call
                        	; call the user function with argument in a0, type in a1
                        	USRX:
FFFC5D34 FFC70713		sub		$sp,$sp,#4
FFFC5D38 01A72023		sw		$t0,[$sp]
FFFC5D3C D9DFF0EF		call	PARN		; get expression value
FFFC5D40 00086933		mov		a0,v0
FFFC5D44 0008E9B3		mov		a1,v1
FFFC5D48 FFC70713		sub		$sp,$sp,#4	; save the text pointer
FFFC5D4C 01C72023		sw		$t2,[$sp]
FFFC5D50 00030637		lw		$t0,usrJmp
FFFC5D54 0A060613
FFFC5D58 00060633
FFFC5D5C 00062D03
FFFC5D60 000D00E7		call	[$t0]			; get usr vector, jump to the subroutine
FFFC5D64 00072E03		lw		$t2,[$sp]	; restore the text pointer
FFFC5D68 00470713		add		$sp,$sp,#4
FFFC5D6C 00072D03		lw		$t0,[$sp]
FFFC5D70 00470713		add		$sp,$sp,#4
FFFC5D74 00072083		lw		$ra,[$sp]
FFFC5D78 00470713		add		$sp,$sp,#4
FFFC5D7C 00008067		ret
                        	
                        	
                        	; ===== The RND function returns a random number from 1 to
                        	;	the value of the following expression in D0.
                        	;
                        	RND:
FFFC5D80 D59FF0EF		call	PARN		; get the upper limit
FFFC5D84 04080063		beq		v0,r0,rnd2	; it must be positive and non-zero
FFFC5D88 02084663		blt		v0,r0,rnd1
FFFC5D8C 000869B3		mov		a1,v0
FFFC5D90 000868B3		mov		v1,v0
FFFC5D94 00000637		call	gen_rand	; generate a random number
FFFC5D98 400600E7
FFFC5D9C 03186833		rem		v0,v0,v1
FFFC5DA0 00180813		add		v0,v0,#1
FFFC5DA4 000068B3		mov		v1,x0
FFFC5DA8 00072083		lw		$ra,[$sp]
FFFC5DAC 00470713		add		$sp,$sp,#4
FFFC5DB0 00008067		ret
                        	rnd1:
FFFC5DB4 FFFC7937		ldi		a0,#msgRNDBad
FFFC5DB8 9C090913
FFFC5DBC 00470713		add		$sp,$sp,#4
FFFC5DC0 1B80006F		jmp		ERROR
                        	rnd2:
FFFC5DC4 00000637		call	gen_rand	; generate a random number
FFFC5DC8 400600E7
FFFC5DCC 000068B3		mov		v1,x0
FFFC5DD0 00072083		lw		$ra,[$sp]
FFFC5DD4 00470713		add		$sp,$sp,#4
FFFC5DD8 00008067		ret
                        	
                        	; ===== The ABS function returns an absolute value in a1.
                        	;
                        	ABS:
FFFC5DDC CFDFF0EF		call	PARN		; get the following expr.'s value
FFFC5DE0 00084863		blt		v0,r0,ABS1
FFFC5DE4 00072083		lw		$ra,[$sp]
FFFC5DE8 00470713		add		$sp,$sp,#4
FFFC5DEC 00008067		ret
                        	ABS1:
FFFC5DF0 41000833		sub		v0,x0,v0
FFFC5DF4 00072083		lw		$ra,[$sp]
FFFC5DF8 00470713		add		$sp,$sp,#4
FFFC5DFC 00008067		ret
                        	
                        	
                        	;==== The TICK function returns the cpu tick value in a0.
                        	;
                        	TICKX:
FFFC5E00 C0001873		csrrw	v0,#$C00,x0
FFFC5E04 000068B3		mov		v1,x0
FFFC5E08 00072083		lw		$ra,[$sp]
FFFC5E0C 00470713		add		$sp,$sp,#4
FFFC5E10 00008067		ret
                        	
                        	; ===== The SGN function returns the sign in a0. +1,0, or -1
                        	;
                        	SGN:
FFFC5E14 CC5FF0EF		call	PARN		; get the following expr.'s value
FFFC5E18 000068B3		mov		v1,x0
FFFC5E1C 02080463		beq		v0,r0,SGN1
FFFC5E20 00084A63		blt		v0,r0,SGN2
FFFC5E24 00106813		ldi		v0,#1
FFFC5E28 00072083		lw		$ra,[$sp]
FFFC5E2C 00470713		add		$sp,$sp,#4
FFFC5E30 00008067		ret
                        	SGN2:
FFFC5E34 FFF06813		ldi		v0,#-1
FFFC5E38 00072083		lw		$ra,[$sp]
FFFC5E3C 00470713		add		$sp,$sp,#4
FFFC5E40 00008067		ret
                        	SGN1:
FFFC5E44 00072083		lw		$ra,[$sp]
FFFC5E48 00470713		add		$sp,$sp,#4
FFFC5E4C 00008067		ret	
                        	
                        	; ===== The SIZE function returns the size of free memory in v0.
                        	; does not consider memory used by @()
                        	;
                        	SIZEX:
FFFC5E50 00030637		lw		v0,VARBGN	; get the number of free bytes...
FFFC5E54 00860613
FFFC5E58 00060633
FFFC5E5C 00062803
FFFC5E60 00030637		lw		v1,TXTUNF	; between 'TXTUNF' and 'VARBGN'
FFFC5E64 00460613
FFFC5E68 00060633
FFFC5E6C 00062883
FFFC5E70 41180833		sub		v0,v0,v1
FFFC5E74 000068B3		mov		v1,x0			; type = int
FFFC5E78 00072083		lw		$ra,[$sp]
FFFC5E7C 00470713		add		$sp,$sp,#4
FFFC5E80 00008067		ret					; return the number in v0
                        	
                        	
                        	;******************************************************************
                        	;
                        	; *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                        	;
                        	; 'SETVAL' expects a variable, followed by an equal sign and then
                        	; an expression.  It evaluates the expression and sets the variable
                        	; to that value.
                        	;
                        	; returns
                        	; a1 = variable's address
                        	;
                        	SETVAL:
FFFC5E84 FFC70713		sub		$sp,$sp,#4
FFFC5E88 00172023		sw		$ra,[$sp]
FFFC5E8C 00106913	  ldi		a0,#1		; allocate var
FFFC5E90 C89FF0EF	  call	TSTV		; variable name?
FFFC5E94 00081A63	  bne		v0,x0,.sv2
FFFC5E98 FFFC7937	 	ldi		a0,#msgVar
FFFC5E9C 9AA90913
FFFC5EA0 00470713		add		$sp,$sp,#4
FFFC5EA4 0D40006F	 	jmp		ERROR 
                        	.sv2:
FFFC5EA8 FFC70713		sub		$sp,$sp,#4
FFFC5EAC 01072023		sw		v0,[$sp]	; save the variable's address
FFFC5EB0 634000EF		call	TSTC			; get past the "=" sign
FFFC5EB4 0000003D		dw		'='
FFFC5EB8 02000663		bra		SV1
FFFC5EBC 81DFF0EF		call	OREXPR		; evaluate the expression
FFFC5EC0 00072983		lw		a1,[$sp]	; get back the variable's address
FFFC5EC4 00470713		add		$sp,$sp,#4
FFFC5EC8 0109A023		sw    v0,[a1]   ; and save value in the variable
FFFC5ECC 0009E833		mov		v0,a1			; return v0 = variable address
FFFC5ED0 FFC9A883		lw		v1,-4[a1]
FFFC5ED4 0FF8F893		and		v1,v1,#$FF
FFFC5ED8 00072083		lw		$ra,[$sp]
FFFC5EDC 00470713		add		$sp,$sp,#4
FFFC5EE0 00008067		ret
                        	SV1:
FFFC5EE4 00470713		add		$sp,$sp,#4
FFFC5EE8 0880006F	  jmp	  QWHAT		; if no "=" sign
                        	
                        	
                        	; 'FIN' checks the end of a command.  If it ended with ":",
                        	; execution continues.	If it ended with a CR, it finds the
                        	; the next line and continues from there.
                        	;
                        	FIN:
FFFC5EEC FFC70713		sub		$sp,$sp,#4
FFFC5EF0 00172023		sw		$ra,[$sp]
FFFC5EF4 5F0000EF		call	TSTC		; *** FIN ***
FFFC5EF8 0000003A		dw		':'
FFFC5EFC 00000663		bra		FI1
FFFC5F00 00470713		add		$sp,$sp,#4	; if ":", discard return address
FFFC5F04 E25FE06F		jmp		RUNSML		; continue on the same line
                        	FI1:
FFFC5F08 5DC000EF		call	TSTC		; not ":", is it a CR?
FFFC5F0C 0000000D		dw		CR
FFFC5F10 00000663		bra		FI2
                        							; else return to the caller
FFFC5F14 00470713		add		$sp,$sp,#4	; yes, purge return address
FFFC5F18 D25FE06F		jmp		RUNNXL		; execute the next line
                        	FI2:
FFFC5F1C 00072083		lw		$ra,[$sp]
FFFC5F20 00470713		add		$sp,$sp,#4
FFFC5F24 00008067		ret					; else return to the caller
                        	
                        	
                        	; 'ENDCHK' checks if a command is ended with a CR. This is
                        	; required in certain commands, such as GOTO, RETURN, STOP, etc.
                        	;
                        	; Check that there is nothing else on the line
                        	; Registers Affected
                        	;   a0
                        	;
                        	ENDCHK:
FFFC5F28 FFC70713		sub		$sp,$sp,#4
FFFC5F2C 00172023		sw		$ra,[$sp]
FFFC5F30 674000EF		call	IGNBLK
FFFC5F34 000E4903		lbu		a0,[$t2]
FFFC5F38 00D06D93		ldi		$t1,#CR
FFFC5F3C 01B90863		beq		a0,$t1,ec1	; does it end with a CR?
FFFC5F40 FFFC7937		ldi		a0,#msgExtraChars
FFFC5F44 A7B90913
FFFC5F48 0300006F		jmp		ERROR
                        	ec1:
FFFC5F4C 00072083		lw		$ra,[$sp]
FFFC5F50 00470713		add		$sp,$sp,#4
FFFC5F54 00008067		ret
                        	
                        	; 'ERROR' prints the string pointed to by a0. It then prints the
                        	; line pointed to by CURRNT with a "?" inserted at where the
                        	; old text pointer (should be on top of the stack) points to.
                        	; Execution of Tiny BASIC is stopped and a warm start is done.
                        	; If CURRNT is zero (indicating a direct command), the direct
                        	; command is not printed. If CURRNT is -1 (indicating
                        	; 'INPUT' command in progress), the input line is not printed
                        	; and execution is not terminated but continues at 'INPERR'.
                        	;
                        	; Related to 'ERROR' are the following:
                        	; 'QWHAT' saves text pointer on stack and gets "What?" message.
                        	; 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                        	; 'QSORRY' and 'ASORRY' do the same kind of thing.
                        	; 'QHOW' and 'AHOW' also do this for "How?".
                        	;
                        	TOOBIG:
FFFC5F58 FFFC7937		ldi		a0,#msgTooBig
FFFC5F5C A6790913
FFFC5F60 00000C63		bra		ERROR
                        	QSORRY:
FFFC5F64 FFFC7937	  ldi		a0,#SRYMSG
FFFC5F68 90F90913
FFFC5F6C 00000663		bra	    ERROR
                        	QWHAT:
FFFC5F70 FFFC7937		ldi		a0,#msgWhat
FFFC5F74 90890913
                        	ERROR:
FFFC5F78 710000EF		call	PRMESG		; display the error message
FFFC5F7C 00030637		lw		a0,CURRNT	; get the current line pointer
FFFC5F80 01860613
FFFC5F84 00060633
FFFC5F88 00062903
FFFC5F8C 04090263		beq		a0,r0,ERROR1	; if zero, do a warm start
FFFC5F90 FFF06D93		ldi		$t1,#-1
FFFC5F94 A1B90663		beq		a0,$t1,INPERR	; is the line no. pointer = -1? if so, redo input
FFFC5F98 000E4283		lbu		r5,[$t2]		; save the char. pointed to
FFFC5F9C 000E0023		sb		x0,[$t2]		; put a zero where the error is
FFFC5FA0 00030637		lw		a0,CURRNT	; point to start of current line
FFFC5FA4 01860613
FFFC5FA8 00060633
FFFC5FAC 00062903
FFFC5FB0 4D8000EF		call	PRTLN		; display the line in error up to the 0
FFFC5FB4 00096333		mov     r6,a0	    ; save off end pointer
FFFC5FB8 005E0023		sb		r5,[$t2]		; restore the character
FFFC5FBC 03F06913		ldi		a0,#'?'		; display a "?"
FFFC5FC0 F48FE0EF		call	GOOUT
FFFC5FC4 000069B3		mov		a1,r0		; stop char = 0
FFFC5FC8 FFF30913		sub		a0,r6,#1	; point back to the error char.
FFFC5FCC 2E4000EF		call	PRTSTG		; display the rest of the line
                        	ERROR1:
FFFC5FD0 855FE06F		jmp	    WSTART		; and do a warm start
                        	
                        	;******************************************************************
                        	;
                        	; *** GETLN *** FNDLN (& friends) ***
                        	;
                        	; 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                        	; the character in r3 (given by the caller), then it fills the
                        	; buffer and echos. It ignores LF's but still echos
                        	; them back. Control-H is used to delete the last character
                        	; entered (if there is one), and control-X is used to delete the
                        	; whole line and start over again. CR signals the end of a line,
                        	; and causes 'GETLN' to return.
                        	;
                        	;
                        	GETLN:
FFFC5FD4 FF870713		sub		$sp,$sp,#8
FFFC5FD8 00572023		sw		r5,[$sp]
FFFC5FDC 00172223		sw		$ra,4[$sp]
FFFC5FE0 F28FE0EF		call	GOOUT		; display the prompt
FFFC5FE4 00106913		ldi		a0,#1
                        	;	sw		a0,CursorFlash	; turn on cursor flash
FFFC5FE8 02006913		ldi		a0,#' '		; and a space
FFFC5FEC F1CFE0EF		call	GOOUT
FFFC5FF0 00030E37		ldi		$t2,#BUFFER	; $t2 is the buffer pointer
FFFC5FF4 01CE0E13
                        	.GL1:
FFFC5FF8 660000EF		call	CHKIO		; check keyboard
FFFC5FFC FE080EE3		beq		v0,x0,.GL1	; wait for a char. to come in
FFFC6000 00806D93		ldi		$t1,#CTRLH
FFFC6004 05B80863		beq		v0,$t1,.GL3	; delete last character? if so
FFFC6008 01806D93		ldi		$t1,#CTRLX
FFFC600C 07B80A63		beq		v0,$t1,.GL4	; delete the whole line?
FFFC6010 00D06D93		ldi		$t1,#CR
FFFC6014 01B80663		beq		v0,$t1,.GL2		; accept a CR
FFFC6018 02006D93		ldi		$t1,#' '
FFFC601C FDB84EE3		blt		v0,$t1,.GL1	; if other control char., discard it
                        	.GL2:
FFFC6020 010E0023		sb		v0,[$t2]		; save the char.
FFFC6024 001E0E13		add		$t2,$t2,#1
FFFC6028 FFC70713		sub		$sp,$sp,#4
FFFC602C 01072023		sw		v0,[$sp]
FFFC6030 00086933		mov		$a0,$v0
FFFC6034 ED4FE0EF		call	GOOUT		; echo the char back out
FFFC6038 00072803		lw		v0,[$sp]; get char back (GOOUT destroys a0)
FFFC603C 00470713		add		$sp,$sp,#4
FFFC6040 00D06D93		ldi		$t1,#CR
FFFC6044 09B80063		beq		v0,$t1,.GL7			; if it's a CR, end the line
FFFC6048 00030DB7		ldi		$t1,#BUFFER+BUFLEN-1
FFFC604C 06FD8D93
FFFC6050 FBBE44E3		blt		$t2,$t1,.GL1		; any more room? ; yes: get some more, else delete last char.
                        	.GL3:
FFFC6054 00806913		ldi		a0,#CTRLH	; delete a char. if possible
FFFC6058 EB0FE0EF		call	GOOUT
FFFC605C 02006913		ldi		a0,#' '
FFFC6060 EA8FE0EF		call	GOOUT
FFFC6064 00030DB7		ldi		$t1,#BUFFER
FFFC6068 01CD8D93
FFFC606C F9CDD6E3		ble		$t2,$t1,.GL1	; any char.'s left?	; if not
FFFC6070 00806913		ldi		a0,#CTRLH		; if so, finish the BS-space-BS sequence
FFFC6074 E94FE0EF		call	GOOUT
FFFC6078 FFFE0E13		sub		$t2,$t2,#1	; decrement the text pointer
FFFC607C F6000EE3		bra		.GL1		; back for more
                        	.GL4:
FFFC6080 000E6933		mov		a0,$t2		; delete the whole line
FFFC6084 FFFD0637		sub		r5,a0,#BUFFER   ; figure out how many backspaces we need
FFFC6088 FE460613
FFFC608C 412602B3
FFFC6090 02028463		beq		r5,r0,.GL6		; if none needed, brnch
FFFC6094 FFF28293		sub		r5,r5,#1		; loop count is one less
                        	.GL5:
FFFC6098 00806913		ldi		a0,#CTRLH		; and display BS-space-BS sequences
FFFC609C E6CFE0EF		call	GOOUT
FFFC60A0 02006913		ldi		a0,#' '
FFFC60A4 E64FE0EF		call	GOOUT
FFFC60A8 00806913		ldi		a0,#CTRLH
FFFC60AC E5CFE0EF		call	GOOUT
FFFC60B0 FFF28293		sub		r5,r5,#1
FFFC60B4 FE0292E3		bne		r5,r0,.GL5
                        	.GL6:
FFFC60B8 00030E37		ldi		$t2,#BUFFER	; reinitialize the text pointer
FFFC60BC 01CE0E13
FFFC60C0 F2000CE3		bra		.GL1		; and go back for more
                        	.GL7:
FFFC60C4 000E0023		sb		x0,[$t2]		; null terminate line
                        	;	sw		x0,CursorFlash	; turn off cursor flash
FFFC60C8 00A06913		ldi		a0,#LINEFD	; echo a LF for the CR
FFFC60CC E3CFE0EF		call	GOOUT
FFFC60D0 00072283		lw		r5,[$sp]
FFFC60D4 00472083		lw		$ra,4[$sp]
FFFC60D8 00870713		add		$sp,$sp,#8
FFFC60DC 00008067		ret
                        	
                        	
                        	; 'FNDLN' finds a line with a given line no. (in a0) in the
                        	; text save area.  $t3 is used as the text pointer. If the line
                        	; is found, $t3 will point to the beginning of that line
                        	; (i.e. the high byte of the line no.), and $v0 = 1.
                        	; If that line is not there and a line with a higher line no.
                        	; is found, $t3 points there and $v0 = 0. If we reached
                        	; the end of the text save area and cannot find the line, flags
                        	; $t3 = 0, $v0 = 0.
                        	; $v0=1 if line found
                        	; r0 = 1	<= line is found
                        	;	$t3 = pointer to line
                        	; r0 = 0    <= line is not found
                        	;	r9 = zero, if end of text area
                        	;	r9 = otherwise higher line number
                        	;
                        	; 'FNDLN' will initialize $t3 to the beginning of the text save
                        	; area to start the search. Some other entries of this routine
                        	; will not initialize $t3 and do the search.
                        	; 'FNDLNP' will start with $t3 and search for the line no.
                        	; 'FNDNXT' will bump $t3 by 4, find a CR and then start search.
                        	; 'FNDSKP' uses $t3 to find a CR, and then starts the search.
                        	; return Z=1 if line is found, r9 = pointer to line
                        	;
                        	; Parameters
                        	;	a0 = line number to find
                        	;
                        	FNDLN:
FFFC60E0 00100DB7		ldi		$t1,#$FFFFF
FFFC60E4 FFFD8D93
FFFC60E8 01B94863		blt		a0,$t1,fl1	; line no. must be < 65535
FFFC60EC FFFC7937		ldi		a0,#msgLineRange
FFFC60F0 99590913
FFFC60F4 E85FF06F		jmp		ERROR
                        	fl1:
FFFC60F8 00032EB7		ldi		$t3,#TXTBGN	; init. the text save pointer
FFFC60FC 800E8E93
                        	
                        	FNDLNP:
FFFC6100 00030637		lw		$t4,TXTUNF	; check if we passed the end
FFFC6104 00460613
FFFC6108 00060633
FFFC610C 00062F03
FFFC6110 05EEF463		bgeu	$t3,$t4,FNDRET1; if so, return with r9=0,a0=0
FFFC6114 FF870713		sub		$sp,$sp,#8	; push a0
FFFC6118 01272023		sw		a0,[$sp]
FFFC611C 00172223		sw		ra,4[$sp]
FFFC6120 000EE933		mov		a0,t3
FFFC6124 338000EF		call	LoadWord		; get line number
FFFC6128 00072903		lw		a0,[$sp]		; pop a0
FFFC612C 00472083		lw		ra,4[$sp]
FFFC6130 00870713		add		$sp,$sp,#8
FFFC6134 03280663		beq		v0,a0,FNDRET2
FFFC6138 03286863		bltu	v0,a0,FNDNXT	; is this the line we want? no, not there yet
                        	FNDRET:
FFFC613C 004E8E93		add		$t3,$t3,#4	; find the next line, skip over line number
                        	.0001:
FFFC6140 000EC883		lbu		v1,[$t3]
FFFC6144 001E8E93		add		$t3,$t3,#1
FFFC6148 00D06D93		ldi		$t1,#CR
FFFC614C FFB89AE3		bne		v1,$t1,.0001	; try to find a CR, keep looking
FFFC6150 00006833		mov		v0,x0	; line not found, but $t3=next line pointer
FFFC6154 00008067		ret
                        	FNDRET1:
                        	;	eor		r9,r9,r9	; no higher line
FFFC6158 00006833		mov		v0,x0	; line not found
FFFC615C 00008067		ret
                        	FNDRET2:
FFFC6160 00106813		ldi		v0,#1	; line found
FFFC6164 00008067		ret
                        	
                        	FNDNXT:
FFFC6168 004E8E93		add		$t3,$t3,#4	; find the next line
                        	
                        	FNDSKP:
FFFC616C 000EC883		lbu		v1,[$t3]
FFFC6170 001E8E93		add		$t3,$t3,#1
FFFC6174 00D06D93		ldi		$t1,#CR
FFFC6178 FFB89AE3		bne		v1,$t1,FNDSKP	; try to find a CR, keep looking
FFFC617C F80002E3		bra		FNDLNP		; check if end of text
                        	
                        	
                        	;******************************************************************
                        	; 'MVUP' moves a block up from where a0 points to where a1 points
                        	; until a0=a2
                        	;
                        	MVUP1:
FFFC6180 00090203		lb		r4,[a0]
FFFC6184 00498023		sb		r4,[a1]
FFFC6188 00190913		add		a0,a0,#1
FFFC618C 00198993		add		a1,a1,#1
                        	MVUP:
FFFC6190 FF4918E3		bne		a0,a2,MVUP1
FFFC6194 00008067		ret
                        	
                        	
                        	; 'MVDOWN' moves a block down from where a0 points to where a1
                        	; points until a0=a2
                        	;
                        	MVDOWN1:
FFFC6198 FFF90913		sub		a0,a0,#1
FFFC619C FFF98993		sub		a1,a1,#1
FFFC61A0 00090203		lb		r4,[a0]
FFFC61A4 00498023		sb		r4,[a1]
                        	MVDOWN:
FFFC61A8 FF4918E3		bne		a0,a2,MVDOWN1
FFFC61AC 00008067		ret
                        	
                        	
                        	; 'POPA_' restores the 'FOR' loop variable save area from the stack
                        	;
                        	; 'PUSHA_' stacks for 'FOR' loop variable save area onto the stack
                        	;
                        	; Note: a single zero word is stored on the stack in the
                        	; case that no FOR loops need to be saved. This needs to be
                        	; done because PUSHA_ / POPA_ is called all the time.
                        	//message "POPA_"
                        	POPA_:
FFFC61B0 00072903		lw		a0,[$sp]
FFFC61B4 00470713		add		$sp,$sp,#4
FFFC61B8 00030637		sw		a0,LOPVAR	; restore LOPVAR, but zero means no more
FFFC61BC 01060613
FFFC61C0 00060633
FFFC61C4 01262023
FFFC61C8 04090C63		beq		a0,x0,PP1
FFFC61CC 00072903		lw		a0,[$sp]
FFFC61D0 00030637		sw		a0,LOPPT
FFFC61D4 07060613
FFFC61D8 00060633
FFFC61DC 01262023
FFFC61E0 00472903		lw		a0,4[$sp]
FFFC61E4 00030637		sw		a0,LOPLN
FFFC61E8 07460613
FFFC61EC 00060633
FFFC61F0 01262023
FFFC61F4 00872903		lw		a0,8[$sp]
FFFC61F8 00030637		sw		a0,LOPLMT
FFFC61FC 07C60613
FFFC6200 00060633
FFFC6204 01262023
FFFC6208 00C72903		lw		a0,12[$sp]
FFFC620C 00030637		sw		a0,LOPINC
FFFC6210 07860613
FFFC6214 00060633
FFFC6218 01262023
FFFC621C 01070713		add		$sp,$sp,#16
                        	PP1:
FFFC6220 00008067		ret
                        	
                        	
                        	PUSHA_:
FFFC6224 00030637		lw		a0,STKBOT	; Are we running out of stack room?
FFFC6228 09C60613
FFFC622C 00060633
FFFC6230 00062903
FFFC6234 01490913		add		a0,a0,#20	; we might need this many bytes
FFFC6238 D32746E3		blt		$sp,a0,QSORRY	; out of stack space
FFFC623C 00030637		lw		a1,LOPVAR		; save loop variables
FFFC6240 01060613
FFFC6244 00060633
FFFC6248 00062983
FFFC624C 04098C63		beq		a1,x0,PU1		; if LOPVAR is zero, that's all
FFFC6250 FF070713		sub		$sp,$sp,#16
FFFC6254 00030637		lw		a0,LOPPT
FFFC6258 07060613
FFFC625C 00060633
FFFC6260 00062903
FFFC6264 01272023		sw		a0,[$sp]
FFFC6268 00030637		lw		a0,LOPLN
FFFC626C 07460613
FFFC6270 00060633
FFFC6274 00062903
FFFC6278 01272223		sw		a0,4[$sp]
FFFC627C 00030637		lw		a0,LOPLMT
FFFC6280 07C60613
FFFC6284 00060633
FFFC6288 00062903
FFFC628C 01272423		sw		a0,8[$sp]
FFFC6290 00030637		lw		a0,LOPINC
FFFC6294 07860613
FFFC6298 00060633
FFFC629C 00062903
FFFC62A0 01272623		sw		a0,12[$sp]
                        	PU1:
FFFC62A4 FFC70713		sub		$sp,$sp,#4
FFFC62A8 01372023		sw		a1,[$sp]
FFFC62AC 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	;
                        	; 'PRTSTG' prints a string pointed to by a0. It stops printing
                        	; and returns to the caller when either a CR is printed or when
                        	; the next byte is the same as what was passed in a1 by the
                        	; caller.
                        	;
                        	; 'PRTLN' prints the saved text line pointed to by r3
                        	; with line no. and all.
                        	;
                        	
                        	; a0 = pointer to string
                        	; a1 = stop character
                        	; return v0 = pointer to end of line + 1
                        	
                        	PRTSTG:
FFFC62B0 FEC70713		sub		$sp,$sp,#20
FFFC62B4 00572023		sw		r5,[$sp]
FFFC62B8 00672223		sw		r6,4[$sp]
FFFC62BC 00772423		sw		r7,8[$sp]
FFFC62C0 00172623		sw		$ra,12[$sp]
FFFC62C4 01272823		sw		$a0,16[$sp]
FFFC62C8 000962B3		mov   r5,a0	    ; r5 = pointer
FFFC62CC 0009E333		mov   r6,a1	    ; r6 = stop char
                        	.PS1:
FFFC62D0 0002C383	  lbu   r7,[r5]     ; get a text character
FFFC62D4 00128293		add		r5,r5,#1
FFFC62D8 00638E63		beq	  r7,r6,.PRTRET	; same as stop character? if so, return
FFFC62DC 0003E933		mov   a0,r7
FFFC62E0 C28FE0EF		call	GOOUT		; display the char.
FFFC62E4 00D06D93		ldi		$t1,#CR
FFFC62E8 FFB394E3		bne   r7,$t1,.PS1	; is it a C.R.? no, go back for more
FFFC62EC 00A06913		ldi		a0,#LINEFD  ; yes, add a L.F.
FFFC62F0 C18FE0EF		call	GOOUT
                        	.PRTRET:
FFFC62F4 0003E8B3	  mov   v1,r7	    ; return a1 = stop char
FFFC62F8 0002E833		mov		v0,r5		; return a0 = line pointer
FFFC62FC 00072283		lw		$r5,[$sp]
FFFC6300 00472303		lw		$r6,4[$sp]
FFFC6304 00872383		lw		$r7,8[$sp]
FFFC6308 00C72083		lw		$ra,12[$sp]
FFFC630C 01072903		lw		$a0,16[$sp]
FFFC6310 01470713		add		$sp,$sp,#20
FFFC6314 00008067	  ret					; then return
                        	
                        	
                        	; 'QTSTG' looks for an underline (back-arrow on some systems),
                        	; single-quote, or double-quote.  If none of these are found, returns
                        	; to the caller.  If underline, outputs a CR without a LF.  If single
                        	; or double quote, prints the quoted string and demands a matching
                        	; end quote.  After the printing, the next i-word of the caller is
                        	; skipped over (usually a branch instruction).
                        	;
                        	QTSTG:
FFFC6318 FFC70713		sub		$sp,$sp,#4
FFFC631C 00172023		sw		$ra,[$sp]
FFFC6320 1C4000EF		call	TSTC		; *** QTSTG ***
FFFC6324 00000022		dw		'"'
FFFC6328 02000063		bra		QT3
FFFC632C 02206993		ldi		a1,#'"'		; it is a "
                        	QT1:
FFFC6330 000E6933		mov		a0,$t2
FFFC6334 F7DFF0EF		call	PRTSTG		; print until another
FFFC6338 00086E33		mov		$t2,v0
FFFC633C 00D06D93		ldi		$t1,#CR
FFFC6340 03B89863		bne		v1,$t1,QT2	; was last one a CR?
FFFC6344 8F9FE06F		jmp		RUNNXL		; if so run next line
                        	QT3:
FFFC6348 19C000EF		call	TSTC		; is it a single quote?
FFFC634C 0000005C		dw		'\''
FFFC6350 00000663		bra		QT4
FFFC6354 02706993		ldi		a1,#'\''	; if so, do same as above
FFFC6358 FC000CE3		bra		QT1
                        	QT4:
FFFC635C 188000EF		call	TSTC		; is it an underline?
FFFC6360 0000005F		dw		'_'
FFFC6364 00000C63		bra		QT5
FFFC6368 00D06913		ldi		a0,#CR		; if so, output a CR without LF
FFFC636C B9CFE0EF		call	GOOUT
                        	QT2:
FFFC6370 00072083		lw		$ra,[$sp]		; get return address
FFFC6374 00470713		add		$sp,$sp,#4
FFFC6378 00408067		jmp		4[$ra]		; skip following branch
                        	QT5:					; not " ' or _
FFFC637C 00072083		lw		$ra,[$sp]		; get return address
FFFC6380 00470713		add		$sp,$sp,#4
FFFC6384 00008067		ret
                        	
                        	; Output a CR LF sequence
                        	;
                        	prCRLF:
FFFC6388 FFC70713		sub		$sp,$sp,#4
FFFC638C 00172023		sw		$ra,[$sp]
FFFC6390 00D06913		ldi		a0,#CR
FFFC6394 B74FE0EF		call	GOOUT
FFFC6398 00A06913		ldi		a0,#LINEFD
FFFC639C B6CFE0EF		call	GOOUT
FFFC63A0 00072083		lw		$ra,[$sp]
FFFC63A4 00470713		add		$sp,$sp,#4
FFFC63A8 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; 'PRTNUM' prints the 32 bit number in a0, leading blanks are added if
                        	; needed to pad the number of spaces to the number in a1.
                        	; However, if the number of digits is larger than the no. in
                        	; a1, all digits are printed anyway. Negative sign is also
                        	; printed and counted in, positive sign is not.
                        	;
                        	; Parameters
                        	; 	a0 = number to print
                        	; 	a1 = number of digits
                        	;		a2 = base (eg 10, 16)
                        	; Register Usage
                        	;		s2 = number of padding spaces
                        	; Modifies:
                        	;		a0,a1,t1
                        	; Returns:
                        	;		none
                        	;-------------------------------------------------------------------------------
                        	
FFFC63AC FEC70713	public PRTNUM:
	sub		$sp,$sp,#20
FFFC63B0 00472023		sw		$s1,[$sp]
FFFC63B4 00572223		sw		$s2,4[$sp]
FFFC63B8 00672423		sw		$s3,8[$sp]
FFFC63BC 00772623		sw		$s4,12[$sp]
FFFC63C0 00172823		sw		$ra,16[$sp]
FFFC63C4 000303B7		ldi		s4,#NUMWKA	; r7 = pointer to numeric work area
FFFC63C8 09438393
FFFC63CC 00096333		mov		s3,a0		; save number for later
FFFC63D0 0009E2B3		mov		s2,a1		; s2 = min number of chars
FFFC63D4 00095663		bge		a0,x0,.PN2	; is it negative? if not
FFFC63D8 41200933		sub		a0,x0,a0	; else make it positive
FFFC63DC FFF28293		sub		s2,s2,#1	; one less for width count
                        	.PN2:
FFFC63E0 00A06D93		ldi		$t1,#10
                        	.PN1:
FFFC63E4 034969B3		rem		a1,a0,a2	; a1 = a0 mod 10
FFFC63E8 03494933		div		a0,a0,a2	; a0 /= 10 divide by 10
FFFC63EC 013A7463		bleu	a1,a2,.PN7
FFFC63F0 00798993		add		a1,a1,#'A'-10-'0'
                        	.PN7:
FFFC63F4 03098993		add		a1,a1,#'0'	; convert remainder to ascii
FFFC63F8 01338023		sb		a1,[$s4]		; and store in buffer
FFFC63FC 00138393		add		s4,s4,#1
FFFC6400 FFF28293		sub		s2,s2,#1	; decrement width
FFFC6404 FE0910E3		bne		a0,x0,.PN1
FFFC6408 00505A63		ble		$s2,$x0,.PN4	; test pad count, skip padding if not needed
                        	.PN3:
FFFC640C 02006913		ldi		$a0,#' '		; display the required leading spaces
FFFC6410 AF8FE0EF		call	GOOUT
FFFC6414 FFF28293		sub		$s2,$s2,#1
FFFC6418 FE504AE3		bgt		$s2,$x0,.PN3
                        	.PN4:
FFFC641C 00035663		bge		$s3,$x0,.PN5	; is number negative?
FFFC6420 02D06913		ldi		$a0,#'-'		; if so, display the sign
FFFC6424 AE4FE0EF		call	GOOUT
                        	.PN5:
FFFC6428 00030DB7		ldi		$t1,#NUMWKA
FFFC642C 094D8D93
                        	.PN6:
FFFC6430 FFF38393		sub		$s4,$s4,#1
FFFC6434 0003C903		lbu		$a0,[$s4]		; now unstack the digits and display
FFFC6438 AD0FE0EF		call	GOOUT
FFFC643C FE7DEAE3		bgtu	$s4,$t1,.PN6
                        	
FFFC6440 00072203		lw		$s1,[$sp]
FFFC6444 00472283		lw		$s2,4[$sp]
FFFC6448 00872303		lw		$s3,8[$sp]
FFFC644C 00C72383		lw		$s4,12[$sp]
FFFC6450 01072083		lw		$ra,16[$sp]
FFFC6454 01470713		add		$sp,$sp,#20
FFFC6458 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; Load a word from memory using unaligned access.
                        	; Moves forwards through memory
                        	;
                        	; Parameters:
                        	;		a0 = pointer to word
                        	; Returns:
                        	;		v0 = word loaded
                        	;-------------------------------------------------------------------------------
                        	LoadWord:
FFFC645C 00094803	  lbu		$v0,[$a0]	
FFFC6460 00194883	  lbu		$v1,1[$a0]
FFFC6464 00889893	  sll		$v1,$v1,#8
FFFC6468 01186833	  or		$v0,$v0,$v1
FFFC646C 00294883	  lbu		$v1,2[$a0]
FFFC6470 01089893	  sll		$v1,$v1,#16
FFFC6474 01186833	  or		$v0,$v0,$v1
FFFC6478 00394883	  lbu		$v1,3[$a0]
FFFC647C 01889893	  sll		$v1,$v1,#24
FFFC6480 01186833	  or		$v0,$v0,$v1
FFFC6484 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = pointer to line
                        	; Returns:
                        	;		v0 = pointer to end of line + 1
                        	;-------------------------------------------------------------------------------
                        	
                        	PRTLN:
FFFC6488 FF070713		sub		$sp,$sp,#16
FFFC648C 00572023		sw		$r5,[$sp]
FFFC6490 00172223		sw		$ra,4[$sp]
FFFC6494 01272423		sw		$a0,8[$sp]
FFFC6498 01372623		sw		$a1,12[$sp]
FFFC649C 000962B3	  mov		$r5,$a0		; r5 = pointer
                        	  ; get the line number stored as binary
                        	  ; assume unaligned loads not allowed
FFFC64A0 FBDFF0EF	  call	LoadWord
FFFC64A4 00086933	  mov		a0,v0
                        	
FFFC64A8 00428293		add		r5,r5,#4
FFFC64AC 00506993	  ldi		a1,#5       ; display a 0 or more digit line no.
FFFC64B0 00A06A13	  ldi		a2,#10
FFFC64B4 EF9FF0EF		call	PRTNUM
FFFC64B8 02006913		ldi		a0,#' '     ; followed by a blank
FFFC64BC A4CFE0EF		call	GOOUT
FFFC64C0 000069B3		mov		a1,r0       ; stop char. is a zero
FFFC64C4 0002E933		mov		a0,r5
FFFC64C8 DE9FF0EF		call  PRTSTG		; display the rest of the line
FFFC64CC 00072283		lw		$r5,[$sp]
FFFC64D0 00472083		lw		$ra,4[$sp]
FFFC64D4 00872903		lw		$a0,8[$sp]
FFFC64D8 00C72983		lw		$a1,12[$sp]
FFFC64DC 01070713		add		$sp,$sp,#16
FFFC64E0 00008067		ret
                        	
                        	
                        	; ===== Test text byte following the call to this subroutine. If it
                        	;	equals the byte pointed to by t2, return to the code following
                        	;	the call. 
                        	;
                        	; Parameters:
                        	;		<static> word byte to look for
                        	;		<static> branch if not found
                        	; Registers Affected
                        	;   none
                        	; Returns
                        	;		t2 = updated text pointer
                        	;
                        	TSTC:
FFFC64E4 FF470713		sub		$sp,$sp,#12
FFFC64E8 01272023		sw		$a0,[$sp]
FFFC64EC 00172223		sw		$ra,4[$sp]
FFFC64F0 01372423		sw		$a1,8[$sp]
FFFC64F4 0B0000EF		call	IGNBLK		; ignore leading blanks
FFFC64F8 00472083		lw		$ra,4[$sp]	; get return address, it's needed for a reference
FFFC64FC 000E4903		lbu		$a0,[$t2]
FFFC6500 0000C983		lbu		$a1,[$ra]
FFFC6504 01298A63		beq		$a1,$a0,TC1	; is it = to what t2 points to? if so
FFFC6508 00072903		lw		$a0,[$sp]		; restore a0
FFFC650C 00872983		lw		$a1,8[$sp]
FFFC6510 00C70713		add		$sp,$sp,#12	;
FFFC6514 00408067		jmp		4[$ra]			; jump to the routine skip param
                        	TC1:
FFFC6518 001E0E13		add		$t2,$t2,#1	; if equal, bump text pointer
FFFC651C 00072903		lw		$a0,[$sp]
FFFC6520 00472083		lw		$ra,4[$sp]
FFFC6524 00872983		lw		$a1,8[$sp]
FFFC6528 00C70713		add		$sp,$sp,#12
FFFC652C 00808067		jmp		8[$ra]			; jump back, skip parm and branch
                        	
                        	
                        	; ===== See if the text pointed to by $t2 is a number. If so,
                        	;	return the number in $v0 and the number of digits in $v1,
                        	;	else return zero in $v0 and $v1.
                        	; Registers Affected
                        	;   a0,a1,r3,r4
                        	; Returns
                        	; 	v0 = number
                        	;		v1 = number of digits in number
                        	;	t2 = updated text pointer
                        	;
                        	TSTNUM:
FFFC6530 FF870713		sub		$sp,$sp,#8
FFFC6534 00172223		sw		$ra,4[$sp]
FFFC6538 00372023		sw		r3,[$sp]
FFFC653C 068000EF		call	IGNBLK		; skip over blanks
FFFC6540 00006833		mov		$v0,$x0		; initialize return parameters
FFFC6544 000068B3		mov		$v1,$x0
                        	TN1:
FFFC6548 000E4183		lbu		r3,[$t2]
FFFC654C 03006D93		ldi		$t1,#'0'
FFFC6550 05B1C263		blt		r3,$t1,TSNMRET; is it less than zero?
FFFC6554 03906D93		ldi		$t1,#'9'
FFFC6558 023DCE63		bgt		r3,$t1,TSNMRET; is it greater than nine?
FFFC655C 00000DB7		ldi		$t1,#$7FFFFFFFFFFFFFF
FFFC6560 FFFD8D93
FFFC6564 010DF863		bleu	$v0,$t1,TN2; see if there's room for new digit
FFFC6568 FFFC7937		ldi		$a0,#msgNumTooBig
FFFC656C 93190913
FFFC6570 A09FF06F		jmp		ERROR		; if not, we've overflowd
                        	TN2:
FFFC6574 001E0E13		add		$t2,$t2,#1	; adjust text pointer
FFFC6578 00181E93		sll		$t3,$v0,#1	; quickly multiply result by 10
FFFC657C 00381813		sll		$v0,$v0,#3	; *8
FFFC6580 01D80833		add		$v0,$v0,$t3	; *8 + *2
FFFC6584 00F1F193		and		r3,r3,#$0F	; add in the new digit
FFFC6588 00380833		add		$v0,$v0,r3
FFFC658C 00188893		add		$v1,$v1,#1	; increment the no. of digits
FFFC6590 FA000CE3		bra		TN1
                        	TSNMRET:
FFFC6594 00072183		lw		r3,[$sp]
FFFC6598 00472083		lw		$ra,4[$sp]
FFFC659C 00870713		add		$sp,$sp,#8
FFFC65A0 00008067		ret
                        	
                        	
                        	;===== Skip over blanks in the text pointed to by $t2.
                        	;
                        	; Registers Affected:
                        	;	$t2
                        	; Returns
                        	;	$t2 = pointer updateded past any spaces or tabs
                        	;
                        	IGNBLK:
FFFC65A4 FFC70713		sub		$sp,$sp,#4
FFFC65A8 01272023		sw		$a0,[$sp]
                        	IGB2:
FFFC65AC 000E4903		lbu		a0,[$t2]			; get char
FFFC65B0 02006D93		ldi		$t1,#' '
FFFC65B4 01B90663		beq		$a0,$t1,IGB1	; see if it's a space
FFFC65B8 00906D93		ldi		$t1,#'\t'
FFFC65BC 01B91663		bne		a0,$t1,IGBRET	; or a tab
                        	IGB1:
FFFC65C0 001E0E13		add		$t2,$t2,#1		; increment the text pointer
FFFC65C4 FE0004E3		bra		IGB2
                        	IGBRET:
FFFC65C8 00072903		lw		$a0,[$sp]
FFFC65CC 00470713		add		$sp,$sp,#4
FFFC65D0 00008067		ret
                        	
                        	; ===== Convert the line of text in the input buffer to upper
                        	;	case (except for stuff between quotes).
                        	;
                        	; Registers Affected
                        	;   a0,r3
                        	; Returns
                        	;	r8 = pointing to end of text in buffer
                        	;
                        	TOUPBUF:
FFFC65D4 FFC70713		sub		$sp,$sp,#4
FFFC65D8 00172023		sw		$ra,[$sp]
FFFC65DC 00030E37		ldi		$t2,#BUFFER	; set up text pointer
FFFC65E0 01CE0E13
FFFC65E4 000061B3		mov		r3,x0		; clear quote flag
                        	TOUPB1:
FFFC65E8 000E4903		lbu		a0,[$t2]		; get the next text char.
FFFC65EC 001E0E13		add		$t2,$t2,#1
FFFC65F0 00D06D93		ldi		$t1,#CR
FFFC65F4 03B90E63		beq		a0,$t1,TOUPBRT		; is it end of line?
FFFC65F8 02206D93		ldi		$t1,#'"'
FFFC65FC 01B90E63		beq		a0,$t1,DOQUO	; a double quote?
FFFC6600 02706D93		ldi		$t1,#'\''
FFFC6604 01B90A63		beq		a0,$t1,DOQUO	; or a single quote?
FFFC6608 FE0190E3		bne		r3,x0,TOUPB1	; inside quotes?
FFFC660C 030000EF		call	toUpper 	; convert to upper case
FFFC6610 FF0E0FA3		sb		v0,-1[$t2]	; store it
FFFC6614 FC000AE3		bra		TOUPB1		; and go back for more
                        	DOQUO:
FFFC6618 00019663		bne		r3,x0,DOQUO1; are we inside quotes?
FFFC661C 000961B3		mov		r3,a0		; if not, toggle inside-quotes flag
FFFC6620 FC0004E3		bra		TOUPB1
                        	DOQUO1:
FFFC6624 FD2192E3		bne		r3,a0,TOUPB1; make sure we're ending proper quote
FFFC6628 000061B3		mov		r3,r0		; else clear quote flag
FFFC662C FA000EE3		bra		TOUPB1
                        	TOUPBRT:
FFFC6630 00072083		lw		$ra,[$sp]
FFFC6634 00470713		add		$sp,$sp,#4
FFFC6638 00008067		ret
                        	
                        	
                        	; ===== Convert the character in a0 to upper case
                        	;
                        	toUpper:
FFFC663C 00096833		mov		$v0,$a0
FFFC6640 06182D93		slt		$t1,$v0,#'a'
FFFC6644 000D9863		bne   $t1,$x0,TOUPRET	; is it < 'a'?
FFFC6648 07A06D93		ldi		$t1,#'z'
FFFC664C 010DC463		bgt		$v0,$t1,TOUPRET	; or > 'z'?
FFFC6650 FE080813		sub		$v0,$v0,#32	  ; if not, make it upper case
                        	TOUPRET:
FFFC6654 00008067		ret
                        	
                        	; 'CHKIO' checks the input. If there's no input, it will return
                        	; to the caller with the a0=0. If there is input, the input byte is in a0.
                        	; However, if a control-C is read, 'CHKIO' will warm-start BASIC and will
                        	; not return to the caller.
                        	;
                        	//message "CHKIO"
                        	CHKIO:
FFFC6658 FFC70713		sub		$sp,$sp,#4
FFFC665C 00172023		sw		$ra,[$sp]
FFFC6660 228000EF		call	INCH		; get input if possible
FFFC6664 00080863		beq		$v0,$x0,CHKRET	; if Zero, no input
FFFC6668 00384893		xor		$v1,$v0,#CTRLC
FFFC666C 00089463		bne		$v1,$x0,CHKRET; is it control-C?
FFFC6670 9B4FE06F		jmp		WSTART		; if so, do a warm start
                        	CHKRET:
FFFC6674 00072083		lw		$ra,[$sp]
FFFC6678 00470713		add		$sp,$sp,#4
FFFC667C 00008067		ret
                        	
                        	; ===== Display a CR-LF sequence
                        	;
                        	CRLF:
FFFC6680 FFFC7937		ldi		a0,#CLMSG
FFFC6684 91590913
                        	
                        	; ===== Display a zero-ended string pointed to by register a0
                        	; Registers Affected
                        	;   a0,a1,r4
                        	;
                        	PRMESG:
FFFC6688 FFC70713		sub		$sp,$sp,#4
FFFC668C 00172023		sw		$ra,[$sp]
FFFC6690 968FA0EF		call	PutString
FFFC6694 00072083		lw		$ra,[$sp]
FFFC6698 00470713		add		$sp,$sp,#4
FFFC669C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;	erc = ALLOCMBX (<handle var>)
                        	;------------------------------------------------------------------------------
                        	
                        	ALLOCMBX:
FFFC66A0 E45FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC66A4 00000028		dw		'('
FFFC66A8 04000E63		bra		.paren
FFFC66AC 00106913		ldi		a0,#1
FFFC66B0 C68FF0EF		call	TSTV
FFFC66B4 00081863		bne		v0,x0,.0001
FFFC66B8 FFFC7937		ldi		a0,#msgVar
FFFC66BC 9AA90913
FFFC66C0 8B9FF06F		jmp		ERROR
                        	.0001:
FFFC66C4 E21FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC66C8 00000029		dw		')'
FFFC66CC 02000C63		bra		.paren
FFFC66D0 00086233		mov		s1,v0
FFFC66D4 00E06913		ldi		a0,#14			; get current tid
FFFC66D8 00000073		ecall
FFFC66DC 0008E9B3		mov		a1,v1
FFFC66E0 00026A33		mov		a2,s1
FFFC66E4 00606913		ldi		a0,#6
FFFC66E8 00000073		ecall
FFFC66EC 00081463		bne		v0,x0,.0002
FFFC66F0 01122023		sw		v1,[s1]				; save handle in variable
                        	.0002:
FFFC66F4 000068B3		mov		v1,x0
FFFC66F8 00072083		lw		$ra,[$sp]
FFFC66FC 00470713		add		$sp,$sp,#4
FFFC6700 00008067		ret
                        	.paren:
FFFC6704 FFFC7937		ldi		a0,#msgParen
FFFC6708 AB790913
FFFC670C 86DFF06F		jmp		ERROR
                        	
                        	;------------------------------------------------------------------------------
                        	; erc = SENDMSG (<handle var>, <msg data 1>, <msg data 2>, <msg data 3>)
                        	;------------------------------------------------------------------------------
                        	
                        	SENDMSG:
FFFC6710 DD5FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC6714 00000028		dw		'('
FFFC6718 08000463		bra		.paren
FFFC671C FBDFE0EF		call	OREXPR	; get the mailbox handle
FFFC6720 00086233		mov		s1,v0
FFFC6724 DC1FF0EF		call	TSTC		; it must be followed by a comma
FFFC6728 0000002C		dw		','
FFFC672C 06000463		bra		.err
FFFC6730 FA9FE0EF		call	OREXPR	; get the memory address
FFFC6734 000862B3		mov		s2,v0
FFFC6738 DADFF0EF		call	TSTC		; it must be followed by a comma
FFFC673C 0000002C		dw		','
FFFC6740 04000A63		bra		.err
FFFC6744 F95FE0EF		call	OREXPR	; get the memory address
FFFC6748 00086333		mov		s3,v0
FFFC674C D99FF0EF		call	TSTC		; it must be followed by a comma
FFFC6750 0000002C		dw		','
FFFC6754 04000063		bra		.err
FFFC6758 F81FE0EF		call	OREXPR	; get the memory address
FFFC675C 000863B3		mov		s4,v0
FFFC6760 D85FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC6764 00000029		dw		')'
FFFC6768 02000C63		bra		.paren
FFFC676C 00906913		ldi		a0,#9		; SendMsg
FFFC6770 000269B3		mov		a1,s1
FFFC6774 0002EA33		mov		a2,s2
FFFC6778 00036AB3		mov		a3,s3
FFFC677C 0003EB33		mov		a4,s4
FFFC6780 00000073		ecall
FFFC6784 000068B3		mov		v1,x0
FFFC6788 00072083		lw		$ra,[$sp]
FFFC678C 00470713		add		$sp,$sp,#4
FFFC6790 00008067		ret
                        	.err:
FFFC6794 FFFC7937		ldi		a0,#msgComma
FFFC6798 98290913
FFFC679C FDCFF06F		jmp		ERROR
                        	.paren:
FFFC67A0 FFFC7937		ldi		a0,#msgParen
FFFC67A4 AB790913
FFFC67A8 FD0FF06F		jmp		ERROR
                        	
                        	;------------------------------------------------------------------------------
                        	; WAITMSG <handle var>, <var for data 1>, <var for data 2>, <var for data 3>,
                        	;		<expr>
                        	;------------------------------------------------------------------------------
                        	
                        	WAITMSG:
FFFC67AC D39FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC67B0 00000028		dw		'('
FFFC67B4 0C000263		bra		.paren
FFFC67B8 F21FE0EF		call	OREXPR	; get the mailbox handle
FFFC67BC 00086233		mov		s1,v0
FFFC67C0 D25FF0EF		call	TSTC		; it must be followed by a comma
FFFC67C4 0000002C		dw		','
FFFC67C8 0A000263		bra		.err
FFFC67CC 00106913		ldi		a0,#1
FFFC67D0 B48FF0EF		call	TSTV
FFFC67D4 00081863		bne		v0,x0,.0001
                        	.0002:
FFFC67D8 FFFC7937		ldi		a0,#msgVar
FFFC67DC 9AA90913
FFFC67E0 F98FF06F		jmp		ERROR
                        	.0001:
FFFC67E4 D01FF0EF		call	TSTC		; it must be followed by a comma
FFFC67E8 0000002C		dw		','
FFFC67EC 08000063		bra		.err
FFFC67F0 000862B3		mov		s2,v0
FFFC67F4 00106913		ldi		a0,#1
FFFC67F8 B20FF0EF		call	TSTV
FFFC67FC FC080EE3		beq		v0,x0,.0002
FFFC6800 CE5FF0EF		call	TSTC		; it must be followed by a comma
FFFC6804 0000002C		dw		','
FFFC6808 06000263		bra		.err
FFFC680C 00086333		mov		s3,v0
FFFC6810 00106913		ldi		a0,#1
FFFC6814 B04FF0EF		call	TSTV
FFFC6818 FC0800E3		beq		v0,x0,.0002
FFFC681C 000863B3		mov		s4,v0
FFFC6820 CC5FF0EF		call	TSTC		; it must be followed by a comma
FFFC6824 0000002C		dw		','
FFFC6828 04000263		bra		.err
FFFC682C EADFE0EF		call	OREXPR	; get queue remove flag
FFFC6830 00086BB3		mov		a5,v0
FFFC6834 000863B3		mov		s4,v0
FFFC6838 CADFF0EF		call	TSTC		; else look for ( OREXPR )
FFFC683C 00000029		dw		')'
FFFC6840 02000C63		bra		.paren
FFFC6844 00A06913		ldi		a0,#10		; WaitMsg
FFFC6848 000269B3		mov		a1,s1
FFFC684C 0002EA33		mov		a2,s2
FFFC6850 00036AB3		mov		a3,s3
FFFC6854 0003EB33		mov		a4,s4
FFFC6858 00000073		ecall
FFFC685C 000068B3		mov		v1,x0
FFFC6860 00072083		lw		$ra,[$sp]
FFFC6864 00470713		add		$sp,$sp,#4
FFFC6868 00008067		ret
                        	.err:
FFFC686C FFFC7937		ldi		a0,#msgComma
FFFC6870 98290913
FFFC6874 F04FF06F		jmp		ERROR
                        	.paren:
FFFC6878 FFFC7937		ldi		a0,#msgParen
FFFC687C AB790913
FFFC6880 EF8FF06F		jmp		ERROR
                        	
                        	;*****************************************************
                        	; The following routines are the only ones that need *
                        	; to be changed for a different I/O environment.     *
                        	;*****************************************************
                        	
                        	; ===== Output character to the console (Port 1) from register a0
                        	;	(Preserves all registers.)
                        	;
                        	OUTC:
FFFC6884 9C1F906F		jmp		Putch
                        	
                        	; ===== Input a character from the console into register v0 (or
                        	;	return Zero status if there's no character available).
                        	;
                        	INCH:
FFFC6888 FFC70713		sub 	$sp,$sp,#4
FFFC688C 00172023		sw		$ra,[$sp]
FFFC6890 985F90EF		call	Getch
FFFC6894 00180813		add		$v0,$v0,#1				; prepare test -1
FFFC6898 00080A63		beq		$v0,$x0,INCH1			; was = -1
FFFC689C FFF80813		sub		$v0,$v0,#1				; get char back
FFFC68A0 00072083		lw		$ra,[$sp]
FFFC68A4 00470713		add		$sp,$sp,#4
FFFC68A8 00008067		ret
                        	INCH1:
FFFC68AC 00072083		lw		$ra,[$sp]		; return a zero for no-char
FFFC68B0 00470713		add		$sp,$sp,#4
FFFC68B4 00008067		ret
                        	
                        	; ===== Return to the resident monitor, operating system, etc.
                        	;
                        	//message "BYEBYE"
                        	BYEBYE:
                        	//	call	ReleaseIOFocus
FFFC68B8 00030637		lw		$sp,OSSP
FFFC68BC 00060613
FFFC68C0 00060633
FFFC68C4 00062703
FFFC68C8 A45F906F		jmp		Monitor
                        	 
                        	
FFFC68CC 53430A0D	msgInit	db	CR,LINEFD,"CS01 Tiny BASIC v1.0",CR,LINEFD,"(C) 2017-2020  Robert Finch",CR,CR,0
FFFC68D0 54203130
FFFC68D4 20796E69
FFFC68D8 49534142
FFFC68DC 31762043
FFFC68E0 0A0D302E
FFFC68E4 20294328
FFFC68E8 37313032
FFFC68EC 3230322D
FFFC68F0 52202030
FFFC68F4 7265626F
FFFC68F8 69462074
FFFC68FC 0D68636E
FFFC6900 0A0D000D
FFFC6902 4B4F0A0D	OKMSG	db	CR,LINEFD,"OK",CR,0
FFFC6906 6857000D
FFFC6908 74616857	msgWhat	db	"What?",CR,0
FFFC690C 53000D3F
FFFC690F 72726F53	SRYMSG	db	"Sorry."
FFFC6913 000D2E79
FFFC6915 6F43000D	CLMSG	db	CR,0
FFFC6917 706D6F43	msgReadError	db	"Compact FLASH read error",CR,0
FFFC691B 20746361
FFFC691F 53414C46
FFFC6923 65722048
FFFC6927 65206461
FFFC692B 726F7272
FFFC692F 754E000D
FFFC6931 626D754E	msgNumTooBig	db	"Number is too big",CR,0
FFFC6935 69207265
FFFC6939 6F742073
FFFC693D 6962206F
FFFC6941 44000D67
FFFC6944 69766944	msgDivZero		db	"Division by zero",CR,0
FFFC6948 6E6F6973
FFFC694C 20796220
FFFC6950 6F72657A
FFFC6954 754F000D
FFFC6956 2074754F	msgVarSpace     db  "Out of variable space",CR,0
FFFC695A 7620666F
FFFC695E 61697261
FFFC6962 20656C62
FFFC6966 63617073
FFFC696A 20000D65
FFFC696D 74796220	msgBytesFree	db	" bytes free",CR,0
FFFC6971 66207365
FFFC6975 0D656572
FFFC6979 65520D00
FFFC697A 6165520D	msgReady		db	CR,"Ready",CR,0
FFFC697E 000D7964
FFFC6982 65707845	msgComma		db	"Expecting a comma",CR,0
FFFC6986 6E697463
FFFC698A 20612067
FFFC698E 6D6D6F63
FFFC6992 4C000D61
FFFC6995 656E694C	msgLineRange	db	"Line number too big",CR,0
FFFC6999 6D756E20
FFFC699D 20726562
FFFC69A1 206F6F74
FFFC69A5 0D676962
FFFC69A9 70784500
FFFC69AA 65707845	msgVar			db "Expecting a variable",CR,0
FFFC69AE 6E697463
FFFC69B2 20612067
FFFC69B6 69726176
FFFC69BA 656C6261
FFFC69BE 4E52000D
FFFC69C0 20444E52	msgRNDBad		db	"RND bad parameter",CR,0
FFFC69C4 20646162
FFFC69C8 61726170
FFFC69CC 6574656D
FFFC69D0 53000D72
FFFC69D3 20535953	msgSYSBad		db	"SYS bad address",CR,0
FFFC69D7 20646162
FFFC69DB 72646461
FFFC69DF 0D737365
FFFC69E3 504E4900
FFFC69E4 55504E49	msgInputVar		db	"INPUT expecting a variable",CR,0
FFFC69E8 78652054
FFFC69EC 74636570
FFFC69F0 20676E69
FFFC69F4 61762061
FFFC69F8 62616972
FFFC69FC 000D656C
FFFC6A00 5458454E	msgNextFor		db	"NEXT without FOR",CR,0
FFFC6A04 74697720
FFFC6A08 74756F68
FFFC6A0C 524F4620
FFFC6A10 454E000D
FFFC6A12 5458454E	msgNextVar		db	"NEXT expecting a defined variable",CR,0
FFFC6A16 70786520
FFFC6A1A 69746365
FFFC6A1E 6120676E
FFFC6A22 66656420
FFFC6A26 64656E69
FFFC6A2A 72617620
FFFC6A2E 6C626169
FFFC6A32 47000D65
FFFC6A35 4F544F47	msgBadGotoGosub	db	"GOTO/GOSUB bad line number",CR,0
FFFC6A39 534F472F
FFFC6A3D 62204255
FFFC6A41 6C206461
FFFC6A45 20656E69
FFFC6A49 626D756E
FFFC6A4D 000D7265
FFFC6A51 55544552	msgRetWoGosub   db	"RETURN without GOSUB",CR,0
FFFC6A55 77204E52
FFFC6A59 6F687469
FFFC6A5D 47207475
FFFC6A61 4255534F
FFFC6A65 7250000D
FFFC6A67 676F7250	msgTooBig		db	"Program is too big",CR,0
FFFC6A6B 206D6172
FFFC6A6F 74207369
FFFC6A73 62206F6F
FFFC6A77 000D6769
FFFC6A7B 72747845	msgExtraChars	db	"Extra characters on line ignored",CR,0
FFFC6A7F 68632061
FFFC6A83 63617261
FFFC6A87 73726574
FFFC6A8B 206E6F20
FFFC6A8F 656E696C
FFFC6A93 6E676920
FFFC6A97 6465726F
FFFC6A9B 4520000D
FFFC6A9D 766E4520	msgEnvFail		db	" Environment call failed",CR,0
FFFC6AA1 6E6F7269
FFFC6AA5 746E656D
FFFC6AA9 6C616320
FFFC6AAD 6166206C
FFFC6AB1 64656C69
FFFC6AB5 7845000D
FFFC6AB7 65707845	msgParen		db	"Expecting parenthesis",CR,0
FFFC6ABB 6E697463
FFFC6ABF 61702067
FFFC6AC3 746E6572
FFFC6AC7 69736568
FFFC6ACB 00000D73
                        	
                        	LSTROM	equ	*		; end of possible ROM area
;	END
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "SpriteDemo.s",1
                        	.file "SpriteDemo.s",1
                        	.file "SpriteDemo.s",2
                        		code
FFFC6ACE 00730000		align	1
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
                        	public code _EnableSprite:
; 	pSPRCTRL[0x180] = pSPRCTRL[0x180] | (1 << spriteno);
FFFC6AD0 10300073		      	pfi      
FFFC6AD4 FFDAE637		      	ldo      	$t1,4292530176+3072
FFFC6AD8 C0060613
FFFC6ADC 00060633
FFFC6AE0 00063D83
FFFC6AE4 00106E93		      	ldi      	$t3,#1
FFFC6AE8 00073F03		      	ldo      	$t4,0[$sp]
FFFC6AEC 01EE9E33		      	sll      	$t2,$t3,$t4
FFFC6AF0 01CDED33		      	or       	$t0,$t1,$t2
FFFC6AF4 FFDAE637		      	sto      	$t0,4292530176+3072
FFFC6AF8 C0060613
FFFC6AFC 00060633
FFFC6B00 01A63023
                        	SpriteDemo_9:
FFFC6B04 02070713		      	add      	$sp,$sp,#32
FFFC6B08 00008067		      	ret      
                        	endpublic
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC6B0C FE070713	public code _RandomizeSpriteColors:
	      	sub      	$sp,$sp,#32
FFFC6B10 00273023		      	sto      	$fp,[$sp]
FFFC6B14 00073423		      	sto      	$x0,8[$sp]
FFFC6B18 00173C23		      	sto      	$ra,24[$sp]
FFFC6B1C 00076133		      	mov      	$fp,$sp
FFFC6B20 FD470713		      	sub      	$sp,$sp,#44
FFFC6B24 00473023		      	sto      	$s1,0[$sp]
FFFC6B28 10300073		      	pfi      
FFFC6B2C FF813203		      	ldo      	$s1,-8[$fp]
                        	; 	randStream = 0;
FFFC6B30 00025637		      	sto      	$x0,_randStream
FFFC6B34 83060613
FFFC6B38 00060633
FFFC6B3C 00063023
                        	; 	for (colorno = 2; colorno < 256; colorno++) {
FFFC6B40 00206213		      	ldi      	$s1,#2
FFFC6B44 10022D13		      	slt      	$t0,$s1,#256
FFFC6B48 040D0863		      	beqz     	$t0,SpriteDemo_22
                        	SpriteDemo_21:
                        	; 		pSprite[colorno] = GetRand(randStream) & 0xffffffff;
FFFC6B4C 10300073		      	pfi      
FFFC6B50 00321D13		      	sll      	$t0,$s1,#3
FFFC6B54 FFDAD637		      	add      	$t1,$t0,#4292530176
FFFC6B58 00060613
FFFC6B5C 01A60DB3
FFFC6B60 FFB13223		      	sto      	$t1,-28[$fp]
FFFC6B64 00025637		      	ldo      	$a0,_randStream
FFFC6B68 83060613
FFFC6B6C 00060633
FFFC6B70 00063903
FFFC6B74 DB0FD0EF		      	call     	_GetRand
FFFC6B78 00086E33		      	mov      	$t2,$v0
FFFC6B7C 10300073		      	pfi      
FFFC6B80 FFFE7D93		      	and      	$t1,$t2,#4294967295
FFFC6B84 01BDB023		      	sto      	$t1,[$t1]
                        	SpriteDemo_23:
FFFC6B88 00120213		      	add      	$s1,$s1,#1
FFFC6B8C 10300073		      	pfi      
FFFC6B90 10022D13		      	slt      	$t0,$s1,#256
FFFC6B94 FA0D1CE3		      	bnez     	$t0,SpriteDemo_21
                        	SpriteDemo_22:
                        	SpriteDemo_17:
                        	SpriteDemo_20:
FFFC6B98 00073203		      	ldo      	$s1,0[$sp]
FFFC6B9C 00016733		      	mov      	$sp,$fp
FFFC6BA0 00073103		      	ldo      	$fp,[$sp]
FFFC6BA4 01873083		      	ldo      	$ra,24[$sp]
FFFC6BA8 02070713		      	add      	$sp,$sp,#32
FFFC6BAC 00008067		      	ret      
                        	endpublic
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC6BB0 FE070713	public code _SetSpritePos:
	      	sub      	$sp,$sp,#32
FFFC6BB4 00273023		      	sto      	$fp,[$sp]
FFFC6BB8 00073423		      	sto      	$x0,8[$sp]
FFFC6BBC 00076133		      	mov      	$fp,$sp
FFFC6BC0 FEE70713		      	sub      	$sp,$sp,#18
FFFC6BC4 00473023		      	sto      	$s1,0[$sp]
FFFC6BC8 10300073		      	pfi      
                        	; 	__int32 *pSprite = &((unsigned __int64 *)0xFFDAD000)[0x100];
FFFC6BCC FFDAE237		      	ldi      	$s1,#4292532224
FFFC6BD0 80020213
                        	; 	pSprite[spriteno*4 + 2] = (y << 16) | x;
FFFC6BD4 02013E83		      	ldo      	$t3,32[$fp]
FFFC6BD8 002E9E13		      	sll      	$t2,$t3,#2
FFFC6BDC 002E1D93		      	sll      	$t1,$t2,#2
FFFC6BE0 004D8D33		      	add      	$t0,$t1,$s1
FFFC6BE4 10300073		      	pfi      
FFFC6BE8 03413E83		      	ldo      	$t3,52[$fp]
FFFC6BEC 010E9E13		      	sll      	$t2,$t3,#16
FFFC6BF0 02A13E83		      	ldo      	$t3,42[$fp]
FFFC6BF4 01DE6DB3		      	or       	$t1,$t2,$t3
FFFC6BF8 01BD2423		      	stt      	$t1,8[$t0]
                        	SpriteDemo_31:
FFFC6BFC 00073203		      	ldo      	$s1,0[$sp]
FFFC6C00 00016733		      	mov      	$sp,$fp
FFFC6C04 00073103		      	ldo      	$fp,[$sp]
FFFC6C08 02070713		      	add      	$sp,$sp,#32
FFFC6C0C 00008067		      	ret      
                        	endpublic
                        	
                        	.file "SpriteDemo.s",104
                        		code
                        		align	16                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC6C10 FE070713	public code _RandomizeSpritePositions:
	      	sub      	$sp,$sp,#32
FFFC6C14 00273023		      	sto      	$fp,[$sp]
FFFC6C18 00073423		      	sto      	$x0,8[$sp]
FFFC6C1C 00173C23		      	sto      	$ra,24[$sp]
FFFC6C20 00076133		      	mov      	$fp,$sp
FFFC6C24 FB870713		      	sub      	$sp,$sp,#72
FFFC6C28 00473023		      	sto      	$s1,0[$sp]
FFFC6C2C 00573423		      	sto      	$s2,8[$sp]
FFFC6C30 00673823		      	sto      	$s3,16[$sp]
FFFC6C34 00773C23		      	sto      	$s4,24[$sp]
FFFC6C38 10300073		      	pfi      
FFFC6C3C FF813203		      	ldo      	$s1,-8[$fp]
FFFC6C40 FD813283		      	ldo      	$s2,-40[$fp]
FFFC6C44 FE413303		      	ldo      	$s3,-28[$fp]
FFFC6C48 FEE13383		      	ldo      	$s4,-18[$fp]
                        	; 	int spriteno;
FFFC6C4C FFDAE2B7		      	ldi      	$s2,#4292532224
FFFC6C50 80028293
                        	; 	randStream = 0;
FFFC6C54 00025637		      	sto      	$x0,_randStream
FFFC6C58 83060613
FFFC6C5C 00060633
FFFC6C60 00063023
                        	; 	for (spriteno = 0; spriteno < 64; spriteno++) {
FFFC6C64 00006233		      	mov      	$s1,$x0
FFFC6C68 10300073		      	pfi      
FFFC6C6C 04022D13		      	slt      	$t0,$s1,#64
FFFC6C70 080D0463		      	beqz     	$t0,SpriteDemo_44
                        	SpriteDemo_43:
                        	; 		x = (GetRand(randStream) % 800) + 256;
FFFC6C74 00025637		      	ldo      	$a0,_randStream
FFFC6C78 83060613
FFFC6C7C 00060633
FFFC6C80 00063903
FFFC6C84 CA0FD0EF		      	call     	_GetRand
FFFC6C88 00086E33		      	mov      	$t2,$v0
FFFC6C8C 10300073		      	pfi      
FFFC6C90 32006E93		      	ldi      	$t3,#800
FFFC6C94 100D8D13		      	add      	$t0,$t1,#256
FFFC6C98 000D63B3		      	mov      	$s4,$t0
                        	; 		y = (GetRand(randStream) % 600) + 28;
FFFC6C9C 00025637		      	ldo      	$a0,_randStream
FFFC6CA0 83060613
FFFC6CA4 00060633
FFFC6CA8 00063903
FFFC6CAC C78FD0EF		      	call     	_GetRand
FFFC6CB0 00086E33		      	mov      	$t2,$v0
FFFC6CB4 10300073		      	pfi      
FFFC6CB8 25806E93		      	ldi      	$t3,#600
FFFC6CBC 01CD8D13		      	add      	$t0,$t1,#28
FFFC6CC0 000D6333		      	mov      	$s3,$t0
                        	; 		pSprite[1] = (2560 << 48) | (y << 16) | x;
FFFC6CC4 01031E13		      	sll      	$t2,$s3,#16
FFFC6CC8 FFFC8637		      	ldo      	$t3,SpriteDemo_longlit0
FFFC6CCC 00060613
FFFC6CD0 00060633
FFFC6CD4 00063E83
FFFC6CD8 01DE6DB3		      	or       	$t1,$t2,$t3
FFFC6CDC 10300073		      	pfi      
FFFC6CE0 007DED33		      	or       	$t0,$t1,$s4
FFFC6CE4 01A2B423		      	sto      	$t0,8[$s2]
                        	; 		pSprite += 2;
FFFC6CE8 01028293		      	add      	$s2,$s2,#16
FFFC6CEC 00120213		      	add      	$s1,$s1,#1
FFFC6CF0 04022D13		      	slt      	$t0,$s1,#64
FFFC6CF4 F80D10E3		      	bnez     	$t0,SpriteDemo_43
                        	SpriteDemo_44:
                        	SpriteDemo_39:
                        	SpriteDemo_42:
FFFC6CF8 00073203		      	ldo      	$s1,0[$sp]
FFFC6CFC 00873283		      	ldo      	$s2,8[$sp]
FFFC6D00 01073303		      	ldo      	$s3,16[$sp]
FFFC6D04 01873383		      	ldo      	$s4,24[$sp]
FFFC6D08 00016733		      	mov      	$sp,$fp
FFFC6D0C 00073103		      	ldo      	$fp,[$sp]
FFFC6D10 01873083		      	ldo      	$ra,24[$sp]
FFFC6D14 02070713		      	add      	$sp,$sp,#32
FFFC6D18 00008067		      	ret      
                        	endpublic
                        	
                        	.file "SpriteDemo.s",188
                        		code
FFFC6D1C 00000000		align	1
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC6D20 FE070713	public code _SpriteDemo:
	      	sub      	$sp,$sp,#32
FFFC6D24 00273023		      	sto      	$fp,[$sp]
FFFC6D28 00073423		      	sto      	$x0,8[$sp]
FFFC6D2C 00173C23		      	sto      	$ra,24[$sp]
FFFC6D30 00076133		      	mov      	$fp,$sp
FFFC6D34 B3E70713		      	sub      	$sp,$sp,#1218
FFFC6D38 00473023		      	sto      	$s1,0[$sp]
FFFC6D3C 00573423		      	sto      	$s2,8[$sp]
FFFC6D40 00673823		      	sto      	$s3,16[$sp]
FFFC6D44 00773C23		      	sto      	$s4,24[$sp]
FFFC6D48 02873023		      	sto      	$s5,32[$sp]
FFFC6D4C 02973423		      	sto      	$s6,40[$sp]
FFFC6D50 02A73823		      	sto      	$s7,48[$sp]
FFFC6D54 02B73C23		      	sto      	$s8,56[$sp]
FFFC6D58 04C73023		      	sto      	$s9,64[$sp]
FFFC6D5C 10300073		      	pfi      
FFFC6D60 FF813203		      	ldo      	$s1,-8[$fp]
FFFC6D64 BDE13283		      	ldo      	$s2,-1058[$fp]
FFFC6D68 BD413303		      	ldo      	$s3,-1068[$fp]
FFFC6D6C EF610393		      	lea      	$s4,-266[$fp]
FFFC6D70 DF210413		      	lea      	$s5,-526[$fp]
FFFC6D74 BEA10493		      	lea      	$s6,-1046[$fp]
FFFC6D78 BC013503		      	ldo      	$s7,-1088[$fp]
FFFC6D7C 10300073		      	pfi      
FFFC6D80 CEE10593		      	lea      	$s8,-786[$fp]
FFFC6D84 BB613603		      	ldo      	$s9,-1098[$fp]
                        	; 	int spriteno;
FFFC6D88 FFDAED37		      	ldi      	$t0,#4292532224
FFFC6D8C 800D0D13
FFFC6D90 BBA13423		      	sto      	$t0,-1112[$fp]
                        	; 	randStream = 0;
FFFC6D94 00025637		      	sto      	$x0,_randStream
FFFC6D98 83060613
FFFC6D9C 00060633
FFFC6DA0 00063023
                        	; 	RandomizeSpriteColors();
FFFC6DA4 D69FF0EF		      	call     	_RandomizeSpriteColors
                        	; 	EnableSprites(-1);
FFFC6DA8 10300073		      	pfi      
FFFC6DAC FF870713		      	sub      	$sp,$sp,#8
FFFC6DB0 FFF06D13		      	ldi      	$t0,#-1
FFFC6DB4 01A73023		      	sto      	$t0,0[$sp]
FFFC6DB8 00000637		      	call     	_EnableSprites
FFFC6DBC 000600E7
FFFC6DC0 00870713		      	add      	$sp,$sp,#8
                        	; 	for (n = 0; n < 64 * 32 * 4; n = n + 1)
FFFC6DC4 10300073		      	pfi      
FFFC6DC8 000062B3		      	mov      	$s2,$x0
FFFC6DCC 00002637		      	slt      	$t0,$s2,#8192
FFFC6DD0 00060613
FFFC6DD4 060D0C63		      	beqz     	$t0,SpriteDemo_88
                        	SpriteDemo_87:
                        	; 		pImages[n] = GetRand(randStream)|(GetRand(randStream)<<32);
FFFC6DD8 10300073		      	pfi      
FFFC6DDC 00329D13		      	sll      	$t0,$s2,#3
FFFC6DE0 1E000637		      	add      	$t1,$t0,#503316480
FFFC6DE4 00060613
FFFC6DE8 01A60DB3
FFFC6DEC B9B13723		      	sto      	$t1,-1138[$fp]
FFFC6DF0 10300073		      	pfi      
FFFC6DF4 00025637		      	ldo      	$a0,_randStream
FFFC6DF8 83060613
FFFC6DFC 00060633
FFFC6E00 00063903
FFFC6E04 B20FD0EF		      	call     	_GetRand
FFFC6E08 00086E33		      	mov      	$t2,$v0
FFFC6E0C 00025637		      	ldo      	$a0,_randStream
FFFC6E10 83060613
FFFC6E14 00060633
FFFC6E18 00063903
FFFC6E1C B08FD0EF		      	call     	_GetRand
FFFC6E20 00086F33		      	mov      	$t4,$v0
FFFC6E24 10300073		      	pfi      
FFFC6E28 000F1E93		      	sll      	$t3,$t4,#32
FFFC6E2C 01DE6DB3		      	or       	$t1,$t2,$t3
FFFC6E30 01BDB023		      	sto      	$t1,[$t1]
FFFC6E34 00128D13		      	add      	$t0,$s2,#1
FFFC6E38 000D62B3		      	mov      	$s2,$t0
FFFC6E3C 10300073		      	pfi      
FFFC6E40 00002637		      	slt      	$t0,$s2,#8192
FFFC6E44 00060613
FFFC6E48 F80D18E3		      	bnez     	$t0,SpriteDemo_87
                        	SpriteDemo_88:
                        	; 	x = 256; y = 64;
FFFC6E4C 10006513		      	ldi      	$s7,#256
FFFC6E50 04006613		      	ldi      	$s9,#64
                        	; 	for (spriteno = 0; spriteno < 64; spriteno++) {
FFFC6E54 00006233		      	mov      	$s1,$x0
FFFC6E58 10300073		      	pfi      
FFFC6E5C 04022D13		      	slt      	$t0,$s1,#64
FFFC6E60 080D0C63		      	beqz     	$t0,SpriteDemo_91
                        	SpriteDemo_90:
                        	; 		pSprite[spriteno*2] = (int)&pImages[spriteno * 128];
FFFC6E64 00121D93		      	sll      	$t1,$s1,#1
FFFC6E68 003D9D13		      	sll      	$t0,$t1,#3
FFFC6E6C BA813D83		      	ldo      	$t1,-1112[$fp]
FFFC6E70 01AD8E33		      	add      	$t2,$t1,$t0
FFFC6E74 10300073		      	pfi      
FFFC6E78 B9C13723		      	sto      	$t2,-1138[$fp]
FFFC6E7C 00721E93		      	sll      	$t3,$s1,#7
FFFC6E80 003E9E13		      	sll      	$t2,$t3,#3
FFFC6E84 1E000637		      	add      	$t1,$t2,#503316480
FFFC6E88 00060613
FFFC6E8C 01C60DB3
FFFC6E90 01BE3023		      	sto      	$t1,[$t2]
                        	; 		xpos[spriteno] = x;
FFFC6E94 10300073		      	pfi      
FFFC6E98 00221D13		      	sll      	$t0,$s1,#2
FFFC6E9C 01A38DB3		      	add      	$t1,$s4,$t0
FFFC6EA0 00ADA023		      	stt      	$s7,[$t1]
                        	; 		ypos[spriteno] = y;
FFFC6EA4 10300073		      	pfi      
FFFC6EA8 00221D13		      	sll      	$t0,$s1,#2
FFFC6EAC 01A40DB3		      	add      	$t1,$s5,$t0
FFFC6EB0 00CDA023		      	stt      	$s9,[$t1]
                        	; 		SetSpritePos(spriteno, x, y);
FFFC6EB4 10300073		      	pfi      
FFFC6EB8 FE870713		      	sub      	$sp,$sp,#24
FFFC6EBC 00473023		      	sto      	$s1,0[$sp]
FFFC6EC0 00A73423		      	sto      	$s7,8[$sp]
FFFC6EC4 00C73823		      	sto      	$s9,16[$sp]
FFFC6EC8 CE9FF0EF		      	call     	_SetSpritePos
FFFC6ECC 01870713		      	add      	$sp,$sp,#24
                        	; 		x += 20;
FFFC6ED0 10300073		      	pfi      
FFFC6ED4 01450513		      	add      	$s7,$s7,#20
                        	; 		if (x >= 800) {
FFFC6ED8 32052D13		      	slt      	$t0,$s7,#800
FFFC6EDC 000D1663		      	bnez     	$t0,SpriteDemo_93
                        	; 			x = 256;
FFFC6EE0 10006513		      	ldi      	$s7,#256
                        	; 			y += 64;
FFFC6EE4 04060613		      	add      	$s9,$s9,#64
                        	SpriteDemo_93:
FFFC6EE8 00120213		      	add      	$s1,$s1,#1
FFFC6EEC 10300073		      	pfi      
FFFC6EF0 04022D13		      	slt      	$t0,$s1,#64
FFFC6EF4 F60D18E3		      	bnez     	$t0,SpriteDemo_90
                        	SpriteDemo_91:
                        	; 	for (spriteno = 0; spriteno < 64; spriteno++) {
FFFC6EF8 00006233		      	mov      	$s1,$x0
FFFC6EFC 10300073		      	pfi      
FFFC6F00 04022D13		      	slt      	$t0,$s1,#64
FFFC6F04 060D0E63		      	beqz     	$t0,SpriteDemo_96
                        	SpriteDemo_95:
                        	; 		dx[spriteno] = (GetRand(randStream) & 15) - 8;
FFFC6F08 00221D13		      	sll      	$t0,$s1,#2
FFFC6F0C 01A58DB3		      	add      	$t1,$s8,$t0
FFFC6F10 B9B13723		      	sto      	$t1,-1138[$fp]
FFFC6F14 00025637		      	ldo      	$a0,_randStream
FFFC6F18 83060613
FFFC6F1C 00060633
FFFC6F20 00063903
FFFC6F24 A00FD0EF		      	call     	_GetRand
FFFC6F28 00086EB3		      	mov      	$t3,$v0
FFFC6F2C 10300073		      	pfi      
FFFC6F30 00FEFE13		      	and      	$t2,$t3,#15
FFFC6F34 FF8E0D93		      	sub      	$t1,$t2,#8
FFFC6F38 01BDA023		      	stt      	$t1,[$t1]
                        	; 		dy[spriteno] = (GetRand(randStream) & 15) - 8;
FFFC6F3C 00221D13		      	sll      	$t0,$s1,#2
FFFC6F40 01A48DB3		      	add      	$t1,$s6,$t0
FFFC6F44 B9B13723		      	sto      	$t1,-1138[$fp]
FFFC6F48 10300073		      	pfi      
FFFC6F4C 00025637		      	ldo      	$a0,_randStream
FFFC6F50 83060613
FFFC6F54 00060633
FFFC6F58 00063903
FFFC6F5C 9C8FD0EF		      	call     	_GetRand
FFFC6F60 00086EB3		      	mov      	$t3,$v0
FFFC6F64 00FEFE13		      	and      	$t2,$t3,#15
FFFC6F68 FF8E0D93		      	sub      	$t1,$t2,#8
FFFC6F6C 01BDA023		      	stt      	$t1,[$t1]
FFFC6F70 10300073		      	pfi      
FFFC6F74 00120213		      	add      	$s1,$s1,#1
FFFC6F78 04022D13		      	slt      	$t0,$s1,#64
FFFC6F7C F80D16E3		      	bnez     	$t0,SpriteDemo_95
                        	SpriteDemo_96:
                        	; 	for (n = 0; n < 64 * 32 * 2; n = n + 1)
FFFC6F80 000062B3		      	mov      	$s2,$x0
FFFC6F84 00001637		      	slt      	$t0,$s2,#4096
FFFC6F88 00060613
FFFC6F8C 040D0863		      	beqz     	$t0,SpriteDemo_99
                        	SpriteDemo_98:
                        	; 		pImages[n] = GetRand(randStream);
FFFC6F90 10300073		      	pfi      
FFFC6F94 00329D13		      	sll      	$t0,$s2,#3
FFFC6F98 1E000637		      	add      	$t1,$t0,#503316480
FFFC6F9C 00060613
FFFC6FA0 01A60DB3
FFFC6FA4 B9B13723		      	sto      	$t1,-1138[$fp]
FFFC6FA8 00025637		      	ldo      	$a0,_randStream
FFFC6FAC 83060613
FFFC6FB0 00060633
FFFC6FB4 00063903
FFFC6FB8 96CFD0EF		      	call     	_GetRand
FFFC6FBC 00086DB3		      	mov      	$t1,$v0
FFFC6FC0 01BDB023		      	sto      	$t1,[$t1]
FFFC6FC4 10300073		      	pfi      
FFFC6FC8 00128D13		      	add      	$t0,$s2,#1
FFFC6FCC 000D62B3		      	mov      	$s2,$t0
FFFC6FD0 00001637		      	slt      	$t0,$s2,#4096
FFFC6FD4 00060613
FFFC6FD8 FA0D1CE3		      	bnez     	$t0,SpriteDemo_98
                        	SpriteDemo_99:
                        	SpriteDemo_101:
                        	; 		btn = GetButton();
FFFC6FDC 10300073		      	pfi      
                        	; 	__asm {
                        		      	;asm     	
FFFC6FE0 FFDC0637				ldt		$v0,BUTTONS
FFFC6FE4 60060613
FFFC6FE8 00060633
FFFC6FEC 00062803
FFFC6FF0 01085813				srl		$v0,$v0,#16
FFFC6FF4 01F87813				and		$v0,$v0,#$1F
                        	; 	}
FFFC6FF8 00086D33		      	mov      	$t0,$v0
FFFC6FFC BDA13523		      	sto      	$t0,-1078[$fp]
                        	; 		for (m = 0; m < 50000; m++);	// Timing delay
FFFC7000 00006333		      	mov      	$s3,$x0
FFFC7004 0000C637		      	slt      	$t0,$s3,#50000
FFFC7008 35060613
FFFC700C 000D0C63		      	beqz     	$t0,SpriteDemo_107
                        	SpriteDemo_106:
FFFC7010 10300073		      	pfi      
FFFC7014 00130313		      	add      	$s3,$s3,#1
FFFC7018 0000C637		      	slt      	$t0,$s3,#50000
FFFC701C 35060613
FFFC7020 FE0D18E3		      	bnez     	$t0,SpriteDemo_106
                        	SpriteDemo_107:
                        	; 		for (spriteno = 0; spriteno < 64; spriteno++) {
FFFC7024 00006233		      	mov      	$s1,$x0
FFFC7028 04022D13		      	slt      	$t0,$s1,#64
FFFC702C 1A0D0C63		      	beqz     	$t0,SpriteDemo_110
                        	SpriteDemo_109:
                        	; 			xpos[spriteno] = xpos[spriteno] + dx[spriteno];
FFFC7030 10300073		      	pfi      
FFFC7034 00221D13		      	sll      	$t0,$s1,#2
FFFC7038 01A38DB3		      	add      	$t1,$s4,$t0
FFFC703C B9B13723		      	sto      	$t1,-1138[$fp]
FFFC7040 10300073		      	pfi      
FFFC7044 00221E13		      	sll      	$t2,$s1,#2
FFFC7048 01C38EB3		      	add      	$t3,$s4,$t2
FFFC704C 10300073		      	pfi      
FFFC7050 B9D13723		      	sto      	$t3,-1138[$fp]
FFFC7054 00221E93		      	sll      	$t3,$s1,#2
FFFC7058 01D58F33		      	add      	$t4,$s8,$t3
FFFC705C 01EE8DB3		      	add      	$t1,$t3,$t4
FFFC7060 01BDA023		      	stt      	$t1,[$t1]
                        	; 			ypos[spriteno] = ypos[spriteno] + dy[spriteno];
FFFC7064 10300073		      	pfi      
FFFC7068 00221D13		      	sll      	$t0,$s1,#2
FFFC706C 01A40DB3		      	add      	$t1,$s5,$t0
FFFC7070 B9B13723		      	sto      	$t1,-1138[$fp]
FFFC7074 10300073		      	pfi      
FFFC7078 00221E13		      	sll      	$t2,$s1,#2
FFFC707C 01C40EB3		      	add      	$t3,$s5,$t2
FFFC7080 10300073		      	pfi      
FFFC7084 B9D13723		      	sto      	$t3,-1138[$fp]
FFFC7088 00221E93		      	sll      	$t3,$s1,#2
FFFC708C 01D48F33		      	add      	$t4,$s6,$t3
FFFC7090 01EE8DB3		      	add      	$t1,$t3,$t4
FFFC7094 01BDA023		      	stt      	$t1,[$t1]
                        	; 			if (xpos[spriteno] < 256) {
FFFC7098 10300073		      	pfi      
FFFC709C 00221D13		      	sll      	$t0,$s1,#2
FFFC70A0 01A38DB3		      	add      	$t1,$s4,$t0
FFFC70A4 B9B13723		      	sto      	$t1,-1138[$fp]
FFFC70A8 100DAD93		      	slt      	$t1,$t1,#256
FFFC70AC 020D8E63		      	beqz     	$t1,SpriteDemo_112
                        	; 				xpos[spriteno] = 256;
FFFC70B0 10300073		      	pfi      
FFFC70B4 00221D13		      	sll      	$t0,$s1,#2
FFFC70B8 10006D93		      	ldi      	$t1,#256
                        	; 				dx[spriteno] = -dx[spriteno];
FFFC70BC 00221D13		      	sll      	$t0,$s1,#2
FFFC70C0 10300073		      	pfi      
FFFC70C4 01A58DB3		      	add      	$t1,$s8,$t0
FFFC70C8 B9B13723		      	sto      	$t1,-1138[$fp]
FFFC70CC 00221E13		      	sll      	$t2,$s1,#2
FFFC70D0 10300073		      	pfi      
FFFC70D4 01C58EB3		      	add      	$t3,$s8,$t2
FFFC70D8 001B1D01		      	neg      	$t1,$t3
FFFC70DC 1B010005
FFFC70DD 1B1B0100		      	sxh      	$t1,$t1
FFFC70E1 23000A00
FFFC70E3 BDA02300		      	stt      	$t1,[$t1]
FFFC70E7 30007301
                        	SpriteDemo_112:
                        	; 			if (xpos[spriteno] >= 816) {
FFFC70E8 10300073		      	pfi      
FFFC70EC 00221D13		      	sll      	$t0,$s1,#2
FFFC70F0 01A38DB3		      	add      	$t1,$s4,$t0
FFFC70F4 B9B13723		      	sto      	$t1,-1138[$fp]
FFFC70F8 330DAD93		      	slt      	$t1,$t1,#816
FFFC70FC 020D9C63		      	bnez     	$t1,SpriteDemo_114
                        	; 				xpos[spriteno] = 816;
FFFC7100 10300073		      	pfi      
FFFC7104 00221D13		      	sll      	$t0,$s1,#2
FFFC7108 33006D93		      	ldi      	$t1,#816
                        	; 				dx[spriteno] = -dx[spriteno];
FFFC710C 00221D13		      	sll      	$t0,$s1,#2
FFFC7110 01A58DB3		      	add      	$t1,$s8,$t0
FFFC7114 B9B13723		      	sto      	$t1,-1138[$fp]
FFFC7118 10300073		      	pfi      
FFFC711C 00221E13		      	sll      	$t2,$s1,#2
FFFC7120 01C58EB3		      	add      	$t3,$s8,$t2
FFFC7124 001B1D01		      	neg      	$t1,$t3
FFFC7128 1B010005
FFFC7129 1B1B0100		      	sxh      	$t1,$t1
FFFC712D 23000A00
FFFC712F BDA02300		      	stt      	$t1,[$t1]
FFFC7133 30007301
                        	SpriteDemo_114:
                        	; 			if (ypos[spriteno] < 28) {
FFFC7134 10300073		      	pfi      
FFFC7138 00221D13		      	sll      	$t0,$s1,#2
FFFC713C 01A40DB3		      	add      	$t1,$s5,$t0
FFFC7140 B9B13723		      	sto      	$t1,-1138[$fp]
FFFC7144 01CDAD93		      	slt      	$t1,$t1,#28
FFFC7148 020D8E63		      	beqz     	$t1,SpriteDemo_116
                        	; 				ypos[spriteno] = 28;
FFFC714C 10300073		      	pfi      
FFFC7150 00221D13		      	sll      	$t0,$s1,#2
FFFC7154 01C06D93		      	ldi      	$t1,#28
                        	; 				dy[spriteno] = -dy[spriteno];
FFFC7158 00221D13		      	sll      	$t0,$s1,#2
FFFC715C 10300073		      	pfi      
FFFC7160 01A48DB3		      	add      	$t1,$s6,$t0
FFFC7164 B9B13723		      	sto      	$t1,-1138[$fp]
FFFC7168 00221E13		      	sll      	$t2,$s1,#2
FFFC716C 10300073		      	pfi      
FFFC7170 01C48EB3		      	add      	$t3,$s6,$t2
FFFC7174 001B1D01		      	neg      	$t1,$t3
FFFC7178 1B010005
FFFC7179 1B1B0100		      	sxh      	$t1,$t1
FFFC717D 23000A00
FFFC717F BDA02300		      	stt      	$t1,[$t1]
FFFC7183 30007301
                        	SpriteDemo_116:
                        	; 			if (ypos[spriteno] >= 614)
FFFC7184 10300073		      	pfi      
FFFC7188 00221D13		      	sll      	$t0,$s1,#2
FFFC718C 01A40DB3		      	add      	$t1,$s5,$t0
FFFC7190 B9B13723		      	sto      	$t1,-1138[$fp]
FFFC7194 266DAD93		      	slt      	$t1,$t1,#614
FFFC7198 000D9863		      	bnez     	$t1,SpriteDemo_118
                        	; 				ypos[spriteno] = 614;
FFFC719C 10300073		      	pfi      
FFFC71A0 00221D13		      	sll      	$t0,$s1,#2
FFFC71A4 26606D93		      	ldi      	$t1,#614
                        	SpriteDemo_118:
                        	; 				dy[spriteno] = -dy[spriteno];
FFFC71A8 10300073		      	pfi      
FFFC71AC 00221D13		      	sll      	$t0,$s1,#2
FFFC71B0 01A48DB3		      	add      	$t1,$s6,$t0
FFFC71B4 B9B13723		      	sto      	$t1,-1138[$fp]
FFFC71B8 10300073		      	pfi      
FFFC71BC 00221E13		      	sll      	$t2,$s1,#2
FFFC71C0 01C48EB3		      	add      	$t3,$s6,$t2
FFFC71C4 001B1D01		      	neg      	$t1,$t3
FFFC71C8 1B010005
FFFC71C9 1B1B0100		      	sxh      	$t1,$t1
FFFC71CD 23000A00
FFFC71CF BDA02300		      	stt      	$t1,[$t1]
FFFC71D3 30007301
FFFC71D4 10300073		      	pfi      
FFFC71D8 00120213		      	add      	$s1,$s1,#1
FFFC71DC 04022D13		      	slt      	$t0,$s1,#64
FFFC71E0 E40D18E3		      	bnez     	$t0,SpriteDemo_109
                        	SpriteDemo_110:
                        	; 			SetSpritePos(spriteno, (int)xpos[spriteno], (int)ypos[spriteno]);
FFFC71E4 FE870713		      	sub      	$sp,$sp,#24
FFFC71E8 00473023		      	sto      	$s1,0[$sp]
FFFC71EC 00221D13		      	sll      	$t0,$s1,#2
FFFC71F0 01A38DB3		      	add      	$t1,$s4,$t0
FFFC71F4 01B73423		      	sto      	$t1,8[$sp]
FFFC71F8 10300073		      	pfi      
FFFC71FC 00221D13		      	sll      	$t0,$s1,#2
FFFC7200 01A40DB3		      	add      	$t1,$s5,$t0
FFFC7204 01B73823		      	sto      	$t1,16[$sp]
FFFC7208 9A9FF0EF		      	call     	_SetSpritePos
FFFC720C 01870713		      	add      	$sp,$sp,#24
FFFC7210 DC0006E3		      	bra      	SpriteDemo_101
                        	SpriteDemo_83:
                        	SpriteDemo_86:
FFFC7214 00073203		      	ldo      	$s1,0[$sp]
FFFC7218 00873283		      	ldo      	$s2,8[$sp]
FFFC721C 01073303		      	ldo      	$s3,16[$sp]
FFFC7220 01873383		      	ldo      	$s4,24[$sp]
FFFC7224 02073403		      	ldo      	$s5,32[$sp]
FFFC7228 02873483		      	ldo      	$s6,40[$sp]
FFFC722C 03073503		      	ldo      	$s7,48[$sp]
FFFC7230 03873583		      	ldo      	$s8,56[$sp]
FFFC7234 04073603		      	ldo      	$s9,64[$sp]
FFFC7238 00016733		      	mov      	$sp,$fp
FFFC723C 00073103		      	ldo      	$fp,[$sp]
FFFC7240 01873083		      	ldo      	$ra,24[$sp]
FFFC7244 02070713		      	add      	$sp,$sp,#32
FFFC7248 00008067		      	ret      
                        	endpublic
                        	
                        		rodata
                        		align	16                        	
                        		extern	_tcbs
	extern	_nMsgBlk
	extern	_mmu_Free512kPage
	extern	_mmu_Alloc8kPage
	extern	_mmu_alloc
	extern	_IOFocusTbl
	extern	_outb
	extern	_outc
	extern	_mmu_MapCardMemory
	extern	_FMTK_StartApp
	extern	_outh
	extern	_irq_stack
	extern	_IOFocusNdx
	extern	_DumpTaskList
;	global	_GetImLevel
                        		extern	_outw
	extern	_fmtk_irq_stack
	extern	_mmu_SetOperateKey
	extern	_keybdControlCodes
	extern	_fmtk_sys_stack
	extern	_message
	extern	_mailbox
	extern	_FMTK_Inited
;	global	_UnlockIOFSemaphore
                        		extern	_KeybdSetLED
	extern	_mmu_AllocateMap
	extern	_FMTK_StartThread
;	global	_DBGCheckForKey
                        		extern	_GetRunningACBPtr
	extern	_KeyLED
	extern	_hFocusSwitchMbx
	extern	_KeybdClearRcv
	extern	_missed_ticks
;	global	_SetVBA
                        		extern	_mmu_SetMapEntry
	extern	_LockIOFSemaphore
	extern	_chkTCB
;	global	_UnlockSemaphore
                        	;	global	_DBGGetKey
                        		extern	_mmu_Alloc512kPage
	extern	_GetVecno
	extern	_GetACBPtr
;	global	_UnlockKbdSemaphore
                        		extern	_video_bufs
	extern	_getCPU
;	global	_LEDS
                        		extern	_hasUltraHighPriorityTasks
	extern	_LockSemaphore
	extern	_keybdExtendedCodes
	extern	_iof_switch
	extern	_KeybdGetScancode
	extern	_kbd_sema
	extern	_DeviceTable
	extern	_nMailbox
	extern	_unshiftedScanCodes
	extern	_set_vector
	extern	_LockKbdSemaphore
	extern	_FMTK_SendMsg
	extern	_iof_sema
	extern	_sys_stacks
	extern	_FocusSwitcher
	extern	_BIOS_RespMbx
	extern	_FMTK_WaitMsg
	extern	_mmu_FreeMap
	extern	_mmu_Free8kPage
	extern	_mmu_free
	extern	_mmu_SetAccessKey
	extern	_shiftedScanCodes
	extern	_KeyState1
	extern	_KeyState2
	extern	_BIOS1_sema
	extern	_sys_sema
	extern	_readyQ
	extern	_LockSysSemaphore
	extern	_ACBPtrs
	extern	_sysstack
	extern	_freeTCB
	extern	_RequestIOFocus
	extern	_TimeoutList
	extern	_RemoveFromTimeoutList
	extern	_stacks
	extern	_freeMSG
	extern	_freeMBX
	extern	_SetBound50
	extern	_SetBound51
	extern	_GetAppHandle
	extern	_SetBound48
	extern	_SetBound49
	extern	_InsertIntoTimeoutList
;	global	_RestoreImLevel
                        		extern	_RemoveFromReadyList
	extern	_KeybdGetStatus
	extern	_bios_stacks
	extern	_FMTK_Reschedule
	extern	_InsertIntoReadyList
.file "boot.r5a",1
                        	.file "TinyBasic.r5a",1
                        	;****************************************************************;
                        	;                                                                ;
                        	;		Tiny BASIC for the CS01                                      ;
                        	;                                                                ;
                        	; Derived from a 68000 derivative of Palo Alto Tiny BASIC as     ;
                        	; published in the May 1976 issue of Dr. Dobb's Journal.         ;
                        	; Adapted to the 68000 by:                                       ;
                        	;	Gordon brndly						                         ;
                        	;	12147 - 51 Street					                         ;
                        	;	Edmonton AB  T5W 3G8					                     ;
                        	;	Canada							                             ;
                        	;	(updated mailing address for 1996)			                 ;
                        	;                                                                ;
                        	; Adapted to the CS01 by:                                        ;
                        	;    Robert Finch                                                ;
                        	;    Ontario, Canada                                             ;
                        	;	 robfinch<remove>@finitron.ca    	                             ;  
                        	;****************************************************************;
                        	;  Copyright (C) 2016-2020 by Robert Finch. This program may be	 ;
                        	;    freely distributed for personal use only. All commercial	 ;
                        	;		       rights are reserved.			                     ;
                        	;****************************************************************;
                        	;
                        	; Register Usage
                        	; $t2 = text pointer (global usage)
                        	; r3,r4 = inputs parameters to subroutines
                        	; a1 = return value
                        	;
                        	;* Vers. 1.0  1984/7/17	- Original version by Gordon brndly
                        	;*	1.1  1984/12/9	- Addition of '0x' print term by Marvin Lipford
                        	;*	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                        	
                        	CR		EQU	0x0D		;ASCII equates
                        	LINEFD	EQU	0x0A		; Don't use LF (same as load float instruction)
                        	TAB		EQU	0x09
                        	CTRLC	EQU	0x03
                        	CTRLH	EQU	0x08
                        	CTRLI	EQU	0x09
                        	CTRLJ	EQU	0x0A
                        	CTRLK	EQU	0x0B
                        	CTRLM   EQU 0x0D
                        	CTRLS	EQU	0x13
                        	CTRLX	EQU	0x18
                        	XON		EQU	0x11
                        	XOFF	EQU	0x13
                        	
                        	FILENAME	EQU		0x3F6C0
                        	FILEBUF		EQU		0x03F600
                        	OSSP		EQU		0x30000
                        	TXTUNF		EQU		OSSP+4
                        	VARBGN		EQU		TXTUNF+4
                        	VAREND		EQU		VARBGN+4
                        	LOPVAR		EQU		VAREND+4
                        	STKGOS		EQU		LOPVAR+4
                        	CURRNT		EQU		STKGOS+4
                        	BUFFER		EQU		CURRNT+4
                        	BUFLEN		EQU		84
                        	LOPPT		EQU		BUFFER+84
                        	LOPLN		EQU		LOPPT+4
                        	LOPINC		EQU		LOPLN+4
                        	LOPLMT		EQU		LOPINC+4
                        	NUMWKA		EQU		LOPLMT+24
                        	STKINP		EQU		NUMWKA+4
                        	STKBOT		EQU		STKINP+4
                        	usrJmp		EQU		STKBOT+4
                        	IRQROUT		EQU		usrJmp+4
                        	
                        	OUTPTR		EQU		IRQROUT+4
                        	INPPTR		EQU		OUTPTR+4
                        	CursorFlash	EQU		INPPTR+4
                        	IRQFlag		EQU		CursorFlash+4
                        	
                        	;
                        	; Modifiable system constants:
                        	;
                        	;THRD_AREA	dw	0x04000000	; threading switch area 0x04000000-0x40FFFFF
                        	;bitmap dw	0x00100000	; bitmap graphics memory 0x04100000-0x417FFFF
                        	TXTBGN		EQU		0x031800	;TXT ;beginning of program memory
                        	ENDMEM		EQU		0x03FFFC	; end of available memory
                        	STACKOFFS	EQU		0xAFFFC000	; stack offset
                        	
                        	
                        		rodata
                        		align	16                        	
                        		align	8                        	
                        	SpriteDemo_longlit0:
FFFC8000 0000048180000000		dco	A00000000000000
                        		extern	_GetRand
;	global	_EnableSprite
                        	;	global	_SetSpritePos
                        	;	global	_RandomizeSpritePositions
                        	;	global	_SpriteDemo
                        		extern	_randStream
	extern	_EnableSprites
;	global	_RandomizeSpriteColors
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	
                        		rodata
                        		align 8                        	
                        	begin_init_data:
                        	_begin_init_data:
                        		data
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9000 00000000            		fill.b	4,0x00
FFFC9004 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
FFFC9008 00000000            		fill.b	4,0x00
FFFC900C 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9010 0000000000000000		fill.b	40,0x00
FFFC9018 0000000000000000
FFFC9020 0000000000000000
FFFC9028 0000000000000000
FFFC9030 0000000000000000
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9038 0000000000000000		fill.b	6,0x00
FFFC903E 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9040 0000000000000000		fill.b	20,0x00
FFFC9048 0000000000000000
FFFC9050 00000000            
FFFC9054 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9058 0000000000000000		fill.b	8,0x00
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9060 0000000000000000		fill.b	944,0x00
FFFC9068 0000000000000000
FFFC9070 0000000000000000
FFFC9078 0000000000000000
FFFC9080 0000000000000000
FFFC9088 0000000000000000
FFFC9090 0000000000000000
FFFC9098 0000000000000000
FFFC90A0 0000000000000000
FFFC90A8 0000000000000000
FFFC90B0 0000000000000000
FFFC90B8 0000000000000000
FFFC90C0 0000000000000000
FFFC90C8 0000000000000000
FFFC90D0 0000000000000000
FFFC90D8 0000000000000000
FFFC90E0 0000000000000000
FFFC90E8 0000000000000000
FFFC90F0 0000000000000000
FFFC90F8 0000000000000000
FFFC9100 0000000000000000
FFFC9108 0000000000000000
FFFC9110 0000000000000000
FFFC9118 0000000000000000
FFFC9120 0000000000000000
FFFC9128 0000000000000000
FFFC9130 0000000000000000
FFFC9138 0000000000000000
FFFC9140 0000000000000000
FFFC9148 0000000000000000
FFFC9150 0000000000000000
FFFC9158 0000000000000000
FFFC9160 0000000000000000
FFFC9168 0000000000000000
FFFC9170 0000000000000000
FFFC9178 0000000000000000
FFFC9180 0000000000000000
FFFC9188 0000000000000000
FFFC9190 0000000000000000
FFFC9198 0000000000000000
FFFC91A0 0000000000000000
FFFC91A8 0000000000000000
FFFC91B0 0000000000000000
FFFC91B8 0000000000000000
FFFC91C0 0000000000000000
FFFC91C8 0000000000000000
FFFC91D0 0000000000000000
FFFC91D8 0000000000000000
FFFC91E0 0000000000000000
FFFC91E8 0000000000000000
FFFC91F0 0000000000000000
FFFC91F8 0000000000000000
FFFC9200 0000000000000000
FFFC9208 0000000000000000
FFFC9210 0000000000000000
FFFC9218 0000000000000000
FFFC9220 0000000000000000
FFFC9228 0000000000000000
FFFC9230 0000000000000000
FFFC9238 0000000000000000
FFFC9240 0000000000000000
FFFC9248 0000000000000000
FFFC9250 0000000000000000
FFFC9258 0000000000000000
FFFC9260 0000000000000000
FFFC9268 0000000000000000
FFFC9270 0000000000000000
FFFC9278 0000000000000000
FFFC9280 0000000000000000
FFFC9288 0000000000000000
FFFC9290 0000000000000000
FFFC9298 0000000000000000
FFFC92A0 0000000000000000
FFFC92A8 0000000000000000
FFFC92B0 0000000000000000
FFFC92B8 0000000000000000
FFFC92C0 0000000000000000
FFFC92C8 0000000000000000
FFFC92D0 0000000000000000
FFFC92D8 0000000000000000
FFFC92E0 0000000000000000
FFFC92E8 0000000000000000
FFFC92F0 0000000000000000
FFFC92F8 0000000000000000
FFFC9300 0000000000000000
FFFC9308 0000000000000000
FFFC9310 0000000000000000
FFFC9318 0000000000000000
FFFC9320 0000000000000000
FFFC9328 0000000000000000
FFFC9330 0000000000000000
FFFC9338 0000000000000000
FFFC9340 0000000000000000
FFFC9348 0000000000000000
FFFC9350 0000000000000000
FFFC9358 0000000000000000
FFFC9360 0000000000000000
FFFC9368 0000000000000000
FFFC9370 0000000000000000
FFFC9378 0000000000000000
FFFC9380 0000000000000000
FFFC9388 0000000000000000
FFFC9390 0000000000000000
FFFC9398 0000000000000000
FFFC93A0 0000000000000000
FFFC93A8 0000000000000000
FFFC93B0 0000000000000000
FFFC93B8 0000000000000000
FFFC93C0 0000000000000000
FFFC93C8 0000000000000000
FFFC93D0 0000000000000000
FFFC93D8 0000000000000000
FFFC93E0 0000000000000000
FFFC93E8 0000000000000000
FFFC93F0 0000000000000000
FFFC93F8 0000000000000000
FFFC9400 0000000000000000
FFFC9408 0000000000000000
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9410 0000000000000000		fill.b	8,0x00
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		data
                        		align	8                        	
                        		data
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		data
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        	
FFFC9418 0000000000000000		rodata
FFFC9420 0000000000000000
FFFC9428 0000000000000000
FFFC9430 0000000000000000
FFFC9438 0000000000000000
FFFC9440 0000000000000000
FFFC9448 0000000000000000
FFFC9450 0000000000000000
FFFC9458 0000000000000000
FFFC9460 0000000000000000
FFFC9468 0000000000000000
FFFC9470 0000000000000000
FFFC9478 0000000000000000
FFFC9480 0000000000000000
FFFC9488 0000000000000000
FFFC9490 0000000000000000
FFFC9498 0000000000000000
FFFC94A0 0000000000000000
FFFC94A8 0000000000000000
FFFC94B0 0000000000000000
FFFC94B8 0000000000000000
FFFC94C0 0000000000000000
FFFC94C8 0000000000000000
FFFC94D0 0000000000000000
FFFC94D8 0000000000000000
FFFC94E0 0000000000000000
FFFC94E8 0000000000000000
FFFC94F0 0000000000000000
FFFC94F8 0000000000000000
FFFC9500 0000000000000000
FFFC9508 0000000000000000
FFFC9510 0000000000000000
FFFC9518 0000000000000000
FFFC9520 0000000000000000
FFFC9528 0000000000000000
FFFC9530 0000000000000000
FFFC9538 0000000000000000
FFFC9540 0000000000000000
FFFC9548 0000000000000000
FFFC9550 0000000000000000
FFFC9558 0000000000000000
FFFC9560 0000000000000000
FFFC9568 0000000000000000
FFFC9570 0000000000000000
FFFC9578 0000000000000000
FFFC9580 0000000000000000
FFFC9588 0000000000000000
FFFC9590 0000000000000000
FFFC9598 0000000000000000
FFFC95A0 0000000000000000
FFFC95A8 0000000000000000
FFFC95B0 0000000000000000
FFFC95B8 0000000000000000
FFFC95C0 0000000000000000
FFFC95C8 0000000000000000
FFFC95D0 0000000000000000
FFFC95D8 0000000000000000
FFFC95E0 0000000000000000
FFFC95E8 0000000000000000
FFFC95F0 0000000000000000
FFFC95F8 0000000000000000
FFFC9600 0000000000000000
FFFC9608 0000000000000000
FFFC9610 0000000000000000
FFFC9618 0000000000000000
FFFC9620 0000000000000000
FFFC9628 0000000000000000
FFFC9630 0000000000000000
FFFC9638 0000000000000000
FFFC9640 0000000000000000
FFFC9648 0000000000000000
FFFC9650 0000000000000000
FFFC9658 0000000000000000
FFFC9660 0000000000000000
FFFC9668 0000000000000000
FFFC9670 0000000000000000
FFFC9678 0000000000000000
FFFC9680 0000000000000000
FFFC9688 0000000000000000
FFFC9690 0000000000000000
FFFC9698 0000000000000000
FFFC96A0 0000000000000000
FFFC96A8 0000000000000000
FFFC96B0 0000000000000000
FFFC96B8 0000000000000000
FFFC96C0 0000000000000000
FFFC96C8 0000000000000000
FFFC96D0 0000000000000000
FFFC96D8 0000000000000000
FFFC96E0 0000000000000000
FFFC96E8 0000000000000000
FFFC96F0 0000000000000000
FFFC96F8 0000000000000000
FFFC9700 0000000000000000
FFFC9708 0000000000000000
FFFC9710 0000000000000000
FFFC9718 0000000000000000
FFFC9720 0000000000000000
FFFC9728 0000000000000000
FFFC9730 0000000000000000
FFFC9738 0000000000000000
FFFC9740 0000000000000000
FFFC9748 0000000000000000
FFFC9750 0000000000000000
FFFC9758 0000000000000000
FFFC9760 0000000000000000
FFFC9768 0000000000000000
FFFC9770 0000000000000000
FFFC9778 0000000000000000
FFFC9780 0000000000000000
FFFC9788 0000000000000000
FFFC9790 0000000000000000
FFFC9798 0000000000000000
FFFC97A0 0000000000000000
FFFC97A8 0000000000000000
FFFC97B0 0000000000000000
FFFC97B8 0000000000000000
FFFC97C0 0000000000000000
FFFC97C8 0000000000000000
FFFC97D0 0000000000000000
FFFC97D8 0000000000000000
FFFC97E0 0000000000000000
FFFC97E8 0000000000000000
FFFC97F0 0000000000000000
FFFC97F8 0000000000000000
FFFC9800 0000000000000000
FFFC9808 0000000000000000
FFFC9810 0000000000000000
FFFC9818 0000000000000000
FFFC9820 0000000000000000
FFFC9828 0000000000000000
FFFC9830 0000000000000000
FFFC9838 0000000000000000
FFFC9840 0000000000000000
FFFC9848 0000000000000000
FFFC9850 0000000000000000
FFFC9858 0000000000000000
FFFC9860 0000000000000000
FFFC9868 0000000000000000
FFFC9870 0000000000000000
FFFC9878 0000000000000000
FFFC9880 0000000000000000
FFFC9888 0000000000000000
FFFC9890 0000000000000000
FFFC9898 0000000000000000
FFFC98A0 0000000000000000
FFFC98A8 0000000000000000
FFFC98B0 0000000000000000
FFFC98B8 0000000000000000
FFFC98C0 0000000000000000
FFFC98C8 0000000000000000
FFFC98D0 0000000000000000
FFFC98D8 0000000000000000
FFFC98E0 0000000000000000
FFFC98E8 0000000000000000
FFFC98F0 0000000000000000
FFFC98F8 0000000000000000
FFFC9900 0000000000000000
FFFC9908 0000000000000000
FFFC9910 0000000000000000
FFFC9918 0000000000000000
FFFC9920 0000000000000000
FFFC9928 0000000000000000
FFFC9930 0000000000000000
FFFC9938 0000000000000000
FFFC9940 0000000000000000
FFFC9948 0000000000000000
FFFC9950 0000000000000000
FFFC9958 0000000000000000
FFFC9960 0000000000000000
FFFC9968 0000000000000000
FFFC9970 0000000000000000
FFFC9978 0000000000000000
FFFC9980 0000000000000000
FFFC9988 0000000000000000
FFFC9990 0000000000000000
FFFC9998 0000000000000000
FFFC99A0 0000000000000000
FFFC99A8 0000000000000000
FFFC99B0 0000000000000000
FFFC99B8 0000000000000000
FFFC99C0 0000000000000000
FFFC99C8 0000000000000000
FFFC99D0 0000000000000000
FFFC99D8 0000000000000000
FFFC99E0 0000000000000000
FFFC99E8 0000000000000000
FFFC99F0 0000000000000000
FFFC99F8 0000000000000000
FFFC9A00 0000000000000000
FFFC9A08 0000000000000000
FFFC9A10 0000000000000000
FFFC9A18 0000000000000000
FFFC9A20 0000000000000000
FFFC9A28 0000000000000000
FFFC9A30 0000000000000000
FFFC9A38 0000000000000000
FFFC9A40 0000000000000000
FFFC9A48 0000000000000000
FFFC9A50 0000000000000000
FFFC9A58 0000000000000000
FFFC9A60 0000000000000000
FFFC9A68 0000000000000000
FFFC9A70 0000000000000000
FFFC9A78 0000000000000000
FFFC9A80 0000000000000000
FFFC9A88 0000000000000000
FFFC9A90 0000000000000000
FFFC9A98 0000000000000000
FFFC9AA0 0000000000000000
FFFC9AA8 0000000000000000
FFFC9AB0 0000000000000000
FFFC9AB8 0000000000000000
FFFC9AC0 0000000000000000
FFFC9AC8 0000000000000000
FFFC9AD0 0000000000000000
FFFC9AD8 0000000000000000
FFFC9AE0 0000000000000000
FFFC9AE8 0000000000000000
FFFC9AF0 0000000000000000
FFFC9AF8 0000000000000000
FFFC9B00 0000000000000000
FFFC9B08 0000000000000000
FFFC9B10 0000000000000000
FFFC9B18 0000000000000000
FFFC9B20 0000000000000000
FFFC9B28 0000000000000000
FFFC9B30 0000000000000000
FFFC9B38 0000000000000000
FFFC9B40 0000000000000000
FFFC9B48 0000000000000000
FFFC9B50 0000000000000000
FFFC9B58 0000000000000000
FFFC9B60 0000000000000000
FFFC9B68 0000000000000000
FFFC9B70 0000000000000000
FFFC9B78 0000000000000000
FFFC9B80 0000000000000000
FFFC9B88 0000000000000000
FFFC9B90 0000000000000000
FFFC9B98 0000000000000000
FFFC9BA0 0000000000000000
FFFC9BA8 0000000000000000
FFFC9BB0 0000000000000000
FFFC9BB8 0000000000000000
FFFC9BC0 0000000000000000
FFFC9BC8 0000000000000000
FFFC9BD0 0000000000000000
FFFC9BD8 0000000000000000
FFFC9BE0 0000000000000000
FFFC9BE8 0000000000000000
FFFC9BF0 0000000000000000
FFFC9BF8 0000000000000000
FFFC9C00 0000000000000000
FFFC9C08 0000000000000000
FFFC9C10 0000000000000000
FFFC9C18 0000000000000000
FFFC9C20 0000000000000000
FFFC9C28 0000000000000000
FFFC9C30 0000000000000000
FFFC9C38 0000000000000000
FFFC9C40 0000000000000000
FFFC9C48 0000000000000000
FFFC9C50 0000000000000000
FFFC9C58 0000000000000000
FFFC9C60 0000000000000000
FFFC9C68 0000000000000000
FFFC9C70 0000000000000000
FFFC9C78 0000000000000000
FFFC9C80 0000000000000000
FFFC9C88 0000000000000000
FFFC9C90 0000000000000000
FFFC9C98 0000000000000000
FFFC9CA0 0000000000000000
FFFC9CA8 0000000000000000
FFFC9CB0 0000000000000000
FFFC9CB8 0000000000000000
FFFC9CC0 0000000000000000
FFFC9CC8 0000000000000000
FFFC9CD0 0000000000000000
FFFC9CD8 0000000000000000
FFFC9CE0 0000000000000000
FFFC9CE8 0000000000000000
FFFC9CF0 0000000000000000
FFFC9CF8 0000000000000000
FFFC9D00 0000000000000000
FFFC9D08 0000000000000000
FFFC9D10 0000000000000000
FFFC9D18 0000000000000000
FFFC9D20 0000000000000000
FFFC9D28 0000000000000000
FFFC9D30 0000000000000000
FFFC9D38 0000000000000000
FFFC9D40 0000000000000000
FFFC9D48 0000000000000000
FFFC9D50 0000000000000000
FFFC9D58 0000000000000000
FFFC9D60 0000000000000000
FFFC9D68 0000000000000000
FFFC9D70 0000000000000000
FFFC9D78 0000000000000000
FFFC9D80 0000000000000000
FFFC9D88 0000000000000000
FFFC9D90 0000000000000000
FFFC9D98 0000000000000000
FFFC9DA0 0000000000000000
FFFC9DA8 0000000000000000
FFFC9DB0 0000000000000000
FFFC9DB8 0000000000000000
FFFC9DC0 0000000000000000
FFFC9DC8 0000000000000000
FFFC9DD0 0000000000000000
FFFC9DD8 0000000000000000
FFFC9DE0 0000000000000000
FFFC9DE8 0000000000000000
FFFC9DF0 0000000000000000
FFFC9DF8 0000000000000000
FFFC9E00 0000000000000000
FFFC9E08 0000000000000000
FFFC9E10 0000000000000000
FFFC9E18 0000000000000000
FFFC9E20 0000000000000000
FFFC9E28 0000000000000000
FFFC9E30 0000000000000000
FFFC9E38 0000000000000000
FFFC9E40 0000000000000000
FFFC9E48 0000000000000000
FFFC9E50 0000000000000000
FFFC9E58 0000000000000000
FFFC9E60 0000000000000000
FFFC9E68 0000000000000000
FFFC9E70 0000000000000000
FFFC9E78 0000000000000000
FFFC9E80 0000000000000000
FFFC9E88 0000000000000000
FFFC9E90 0000000000000000
FFFC9E98 0000000000000000
FFFC9EA0 0000000000000000
FFFC9EA8 0000000000000000
FFFC9EB0 0000000000000000
FFFC9EB8 0000000000000000
FFFC9EC0 0000000000000000
FFFC9EC8 0000000000000000
FFFC9ED0 0000000000000000
FFFC9ED8 0000000000000000
FFFC9EE0 0000000000000000
FFFC9EE8 0000000000000000
FFFC9EF0 0000000000000000
FFFC9EF8 0000000000000000
FFFC9F00 0000000000000000
FFFC9F08 0000000000000000
FFFC9F10 0000000000000000
FFFC9F18 0000000000000000
FFFC9F20 0000000000000000
FFFC9F28 0000000000000000
FFFC9F30 0000000000000000
FFFC9F38 0000000000000000
FFFC9F40 0000000000000000
FFFC9F48 0000000000000000
FFFC9F50 0000000000000000
FFFC9F58 0000000000000000
FFFC9F60 0000000000000000
FFFC9F68 0000000000000000
FFFC9F70 0000000000000000
FFFC9F78 0000000000000000
FFFC9F80 0000000000000000
FFFC9F88 0000000000000000
FFFC9F90 0000000000000000
FFFC9F98 0000000000000000
FFFC9FA0 0000000000000000
FFFC9FA8 0000000000000000
FFFC9FB0 0000000000000000
FFFC9FB8 0000000000000000
FFFC9FC0 0000000000000000
FFFC9FC8 0000000000000000
FFFC9FD0 0000000000000000
FFFC9FD8 0000000000000000
FFFC9FE0 0000000000000000
FFFC9FE8 0000000000000000
FFFC9FF0 0000000000000000
FFFC9FF8 0000000000000000
                        		align 8                        	
                        	end_init_data:
                        	_end_init_data:
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9418 00000000            		fill.b	4,0x00
FFFC941C 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
FFFC9420 00000000            		fill.b	4,0x00
FFFC9424 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9428 0000000000000000		fill.b	40,0x00
FFFC9430 0000000000000000
FFFC9438 0000000000000000
FFFC9440 0000000000000000
FFFC9448 0000000000000000
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9450 0000000000000000		fill.b	6,0x00
FFFC9456 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9458 0000000000000000		fill.b	20,0x00
FFFC9460 0000000000000000
FFFC9468 00000000            
FFFC946C 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9470 0000000000000000		fill.b	8,0x00
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9478 0000000000000000		fill.b	944,0x00
FFFC9480 0000000000000000
FFFC9488 0000000000000000
FFFC9490 0000000000000000
FFFC9498 0000000000000000
FFFC94A0 0000000000000000
FFFC94A8 0000000000000000
FFFC94B0 0000000000000000
FFFC94B8 0000000000000000
FFFC94C0 0000000000000000
FFFC94C8 0000000000000000
FFFC94D0 0000000000000000
FFFC94D8 0000000000000000
FFFC94E0 0000000000000000
FFFC94E8 0000000000000000
FFFC94F0 0000000000000000
FFFC94F8 0000000000000000
FFFC9500 0000000000000000
FFFC9508 0000000000000000
FFFC9510 0000000000000000
FFFC9518 0000000000000000
FFFC9520 0000000000000000
FFFC9528 0000000000000000
FFFC9530 0000000000000000
FFFC9538 0000000000000000
FFFC9540 0000000000000000
FFFC9548 0000000000000000
FFFC9550 0000000000000000
FFFC9558 0000000000000000
FFFC9560 0000000000000000
FFFC9568 0000000000000000
FFFC9570 0000000000000000
FFFC9578 0000000000000000
FFFC9580 0000000000000000
FFFC9588 0000000000000000
FFFC9590 0000000000000000
FFFC9598 0000000000000000
FFFC95A0 0000000000000000
FFFC95A8 0000000000000000
FFFC95B0 0000000000000000
FFFC95B8 0000000000000000
FFFC95C0 0000000000000000
FFFC95C8 0000000000000000
FFFC95D0 0000000000000000
FFFC95D8 0000000000000000
FFFC95E0 0000000000000000
FFFC95E8 0000000000000000
FFFC95F0 0000000000000000
FFFC95F8 0000000000000000
FFFC9600 0000000000000000
FFFC9608 0000000000000000
FFFC9610 0000000000000000
FFFC9618 0000000000000000
FFFC9620 0000000000000000
FFFC9628 0000000000000000
FFFC9630 0000000000000000
FFFC9638 0000000000000000
FFFC9640 0000000000000000
FFFC9648 0000000000000000
FFFC9650 0000000000000000
FFFC9658 0000000000000000
FFFC9660 0000000000000000
FFFC9668 0000000000000000
FFFC9670 0000000000000000
FFFC9678 0000000000000000
FFFC9680 0000000000000000
FFFC9688 0000000000000000
FFFC9690 0000000000000000
FFFC9698 0000000000000000
FFFC96A0 0000000000000000
FFFC96A8 0000000000000000
FFFC96B0 0000000000000000
FFFC96B8 0000000000000000
FFFC96C0 0000000000000000
FFFC96C8 0000000000000000
FFFC96D0 0000000000000000
FFFC96D8 0000000000000000
FFFC96E0 0000000000000000
FFFC96E8 0000000000000000
FFFC96F0 0000000000000000
FFFC96F8 0000000000000000
FFFC9700 0000000000000000
FFFC9708 0000000000000000
FFFC9710 0000000000000000
FFFC9718 0000000000000000
FFFC9720 0000000000000000
FFFC9728 0000000000000000
FFFC9730 0000000000000000
FFFC9738 0000000000000000
FFFC9740 0000000000000000
FFFC9748 0000000000000000
FFFC9750 0000000000000000
FFFC9758 0000000000000000
FFFC9760 0000000000000000
FFFC9768 0000000000000000
FFFC9770 0000000000000000
FFFC9778 0000000000000000
FFFC9780 0000000000000000
FFFC9788 0000000000000000
FFFC9790 0000000000000000
FFFC9798 0000000000000000
FFFC97A0 0000000000000000
FFFC97A8 0000000000000000
FFFC97B0 0000000000000000
FFFC97B8 0000000000000000
FFFC97C0 0000000000000000
FFFC97C8 0000000000000000
FFFC97D0 0000000000000000
FFFC97D8 0000000000000000
FFFC97E0 0000000000000000
FFFC97E8 0000000000000000
FFFC97F0 0000000000000000
FFFC97F8 0000000000000000
FFFC9800 0000000000000000
FFFC9808 0000000000000000
FFFC9810 0000000000000000
FFFC9818 0000000000000000
FFFC9820 0000000000000000
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9828 0000000000000000		fill.b	8,0x00
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		data
                        		align	8                        	
                        		data
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		data
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
1236 symbols
  Symbol Name                              seg     address bits
  A00000000000000                          rodata  8000000000000481 32
  ABS                                        code  fffc5ddc 18
  ABS1                                       code  fffc5df0 18
  ADDEXPR                                    code  fffc5954 18
  ALLOCMBX                                   code  fffc66a0 18
  ALLOCMBX.0001                              code  fffc66c4 18
  ALLOCMBX.0002                              code  fffc66f4 18
  ALLOCMBX.paren                             code  fffc6704 18
  ANDEXPR                                    code  fffc5740 18
  AUXIN                                      code  80000000000002db 32
  AUXIN_INIT                                 code  80000000000003ae 32
  AUXOCRLF                                   code  fffc5580 18
  AUXOUT                                     code  80000000000002d9 32
  AUXOUT_FLUSH                               code  80000000000003bb 32
  AUXOUT_INIT                                code  80000000000003b2 32
  Alloc                                      code  fffc0ff8 18
  Alloc.0001                                 code  fffc1074 18
  Alloc.enough                               code  fffc1038 18
  Alloc.noRun                                code  fffc1098 18
  Alloc.noRun2                               code  fffc1030 18
  Alloc.xit                                  code  fffc109c 18
  AllocInCurrentAS                           code  fffc0fec 18
  AllocStack                                 code  fffc10b4 18
  AllocStack.0001                            code  fffc10e8 18
  AllocStack.xit                             code  fffc10fc 18
  AllocTCB                                   code  fffc32a0 18
  AllocTCB.0001                              code  fffc32b4 18
  AllocTCB.0002                              code  fffc32ec 18
  AllocTCB.0003                              code  fffc32fc 18
  AllocTCB.allocTid                          code  fffc32e0 18
  BASPRMPT                                   code  fffc4868 18
  BIOSCallTbl                                code  fffc0e68 18
  BIOS_ClearScreen                           code  fffc0e70 18
  BIOS_HomeCursor                            code  fffc0e74 18
  BIOS_VideoPutChar                          code  fffc0e78 18
  BIOS_VideoPutString                        code  fffc0e7c 18
  BS                                        const  000008 5
  BUFFER                                    const  03001c 19
  BUFLEN                                    const  000054 8
  BUTTONS                                   const  ffdc0600 33
  BYEBYE                                     code  fffc68b8 18
  CHKIO                                      code  fffc6658 18
  CHKRET                                     code  fffc6674 18
  CLMSG                                      code  fffc6915 18
  CR                                        const  00000d 5
  CRLF                                       code  fffc6680 18
  CSR_REGSET                                const  000790 12
  CSTART                                     code  fffc4730 32
  CTRLC                                     const  000003 3
  CTRLH                                     const  000008 5
  CTRLI                                     const  000009 5
  CTRLJ                                     const  00000a 5
  CTRLK                                     const  00000b 5
  CTRLM                                     const  00000d 5
  CTRLS                                     const  000013 6
  CTRLX                                     const  000018 6
  CURRNT                                    const  030018 19
  CopyDevFuncTbl                             code  fffc381c 18
  CopyDevFuncTbl.again                       code  fffc3830 18
  CursorFlash                               const  0300b0 19
  CursorX                                   const  024800 19
  CursorY                                   const  024801 19
  DBGKeybd_100                               code  fffc4364 18
  DBGKeybd_101                               code  fffc43b4 18
  DBGKeybd_102                               code  fffc43d8 18
  DBGKeybd_103                               code  fffc4548 18
  DBGKeybd_104                               code  fffc456c 18
  DBGKeybd_105                               code  fffc45a8 18
  DBGKeybd_106                               code  fffc46a4 18
  DBGKeybd_107                               code  fffc45d8 18
  DBGKeybd_108                               code  fffc46a4 18
  DBGKeybd_109                               code  fffc462c 18
  DBGKeybd_111                               code  fffc465c 18
  DBGKeybd_113                               code  fffc468c 18
  DBGKeybd_5                                 code  fffc4180 18
  DBGKeybd_62                                code  fffc4224 18
  DBGKeybd_65                                code  fffc4224 18
  DBGKeybd_66                                code  fffc41dc 18
  DBGKeybd_68                                code  fffc41f4 18
  DBGKeybd_69                                code  fffc420c 18
  DBGKeybd_71                                code  fffc420c 18
  DBGKeybd_72                                code  fffc421c 18
  DBGKeybd_73                                code  fffc4258 18
  DBGKeybd_74                                code  fffc4248 18
  DBGKeybd_76                                code  fffc4274 18
  DBGKeybd_77                                code  fffc4280 18
  DBGKeybd_79                                code  fffc46a4 18
  DBGKeybd_8                                 code  fffc4180 18
  DBGKeybd_90                                code  fffc42c4 18
  DBGKeybd_91                                code  fffc42dc 18
  DBGKeybd_92                                code  fffc4304 18
  DBGKeybd_93                                code  fffc4378 18
  DBGKeybd_94                                code  fffc43ec 18
  DBGKeybd_95                                code  fffc444c 18
  DBGKeybd_96                                code  fffc44ac 18
  DBGKeybd_97                                code  fffc450c 18
  DBGKeybd_98                                code  fffc4580 18
  DBGKeybd_99                                code  fffc4340 18
  DCB_LastErc                               const  000018 6
  DCB_Mbx                                   const  000048 8
  DCB_Name                                  const  000000 1
  DCB_ReentCount                            const  000038 7
  DCB_Resv1                                 const  000058 8
  DCB_Resv2                                 const  000060 8
  DCB_Size                                  const  000068 8
  DCB_StartBlock                            const  000020 7
  DCB_Type                                  const  00000c 5
  DCB_fSingleUser                           const  000039 7
  DCB_hJob                                  const  000040 8
  DCB_nBPB                                  const  000010 6
  DCB_nBlocks                               const  000028 7
  DCB_pCmdProc                              const  000030 7
  DCB_pSema                                 const  000050 8
  DEFLT                                      code  fffc52c8 18
  DEL                                       const  00007f 8
  DIRECT                                     code  fffc4b60 18
  DOQUO                                      code  fffc6618 18
  DOQUO1                                     code  fffc6624 18
  DRSP_DONE                                 const  000001 2
  DVC_BuildBPB                              const  000005 4
  DVC_Close                                 const  000007 4
  DVC_FlushInput                            const  000014 6
  DVC_FlushOutput                           const  000015 6
  DVC_GetChar                               const  000008 5
  DVC_GetCharDirect                         const  00000a 5
  DVC_IOCTRL_READ                           const  000018 6
  DVC_IOCTRL_WRITE                          const  000019 6
  DVC_IRQ                                   const  000016 6
  DVC_Initialize                            const  000002 3
  DVC_InputStatus                           const  00000c 5
  DVC_IsRemoveable                          const  000017 6
  DVC_MediaCheck                            const  000004 4
  DVC_Nop                                   const  000000 1
  DVC_Open                                  const  000006 4
  DVC_OutputStatus                          const  000013 6
  DVC_OutputUntilBusy                       const  00001a 6
  DVC_PeekChar                              const  000009 5
  DVC_PeekCharDirect                        const  00000b 5
  DVC_PutChar                               const  00000d 5
  DVC_ReadBlock                             const  000010 6
  DVC_SetPosition                           const  00000f 5
  DVC_Setup                                 const  000001 2
  DVC_Status                                const  000003 3
  DVC_VerifyBlock                           const  000012 6
  DVC_WriteBlock                            const  000011 6
  DVF_Base                                  const  022000 19
  DVF_Limit                                 const  024000 19
  DeleteLine                                 code  fffc4920 18
  DeleteLine.0001                            code  fffc494c 18
  DeleteLine.0002                            code  fffc4938 18
  DeleteLine.0003                            code  fffc4950 18
  DispAttr                                  const  024808 19
  DumpMemmap                                 code  fffc0860 18
  DumpMemmap.again                           code  fffc0874 18
  DumpReadyList                              code  fffc334c 18
  DumpReadyList.0001                         code  fffc33c8 18
  DumpReadyList.0002                         code  fffc3384 18
  DumpReadyList.brk                          code  fffc3410 18
  DumpReadyList.nxt                          code  fffc3404 18
  DumpTimeoutList                            code  fffc343c 18
  DumpTimeoutList.0002                       code  fffc3478 18
  DumpTimeoutList.brk                        code  fffc34b0 18
  ENDCHK                                     code  fffc5f28 18
  ENDMEM                                    const  03fffc 19
  ERETx                                      code  8000000000000243 32
  ERROR                                      code  fffc5f78 18
  ERROR1                                     code  fffc5fd0 18
  EX1                                        code  fffc4bac 18
  EXEC                                       code  fffc4b70 18
  EXGO                                       code  fffc4bd4 18
  EXLP                                       code  fffc4b7c 18
  EXMAT                                      code  fffc4bc0 18
  EXNGO                                      code  fffc4b94 18
  EXPR                                       code  fffc5830 18
  E_Arg                                     const  000001 2
  E_BadAlarm                                const  000011 6
  E_BadBlockNum                             const  000025 7
  E_BadCallno                               const  00001a 6
  E_BadDevNum                               const  000020 7
  E_BadDevOp                                const  000022 7
  E_BadMbx                                  const  000004 4
  E_DCBInUse                                const  000019 6
  E_NoDev                                   const  000021 7
  E_NoMem                                   const  00000c 5
  E_NoMoreAlarmBlks                         const  000044 8
  E_NoMoreMbx                               const  000040 8
  E_NoMoreMsgBlks                           const  000041 8
  E_NoMoreTCBs                              const  000045 8
  E_NoMsg                                   const  00000b 5
  E_NoThread                                const  000006 4
  E_NotAlloc                                const  000009 5
  E_NotOwner                                const  000012 6
  E_Ok                                      const  000000 1
  E_QueFull                                 const  000005 4
  E_QueStrategy                             const  000013 6
  E_ReadError                               const  000023 7
  E_Timeout                                 const  000010 6
  E_TooManyBlocks                           const  000026 7
  E_WriteError                              const  000024 7
  EditMem                                    code  fffc0604 18
  FFFC0100                                   code  80000000000002cb 32
  FI1                                        code  fffc5f08 18
  FI2                                        code  fffc5f1c 18
  FILEBUF                                   const  03f600 19
  FILENAME                                  const  03f6c0 19
  FIN                                        code  fffc5eec 18
  FINISH                                     code  fffc4ef8 18
  FMTKInit                                   code  fffc1ea4 18
  FMTKInit.0001                              code  fffc1f70 18
  FMTKInit.0002                              code  fffc1fa4 18
  FMTKInit.0003                              code  fffc1f54 18
  FMTK_AllocMbx                              code  fffc2a94 18
  FMTK_AllocMbx.badArg                       code  fffc2b3c 18
  FMTK_AllocMbx.lock                         code  fffc2abc 18
  FMTK_AllocMbx.noOwner                      code  fffc2b08 18
  FMTK_AllocMbx.nxt                          code  fffc2ae4 18
  FMTK_AllocMbx.xit                          code  fffc2b40 18
  FMTK_AllocVideoBuf                         code  fffc29f4 18
  FMTK_AllocVideoBuf.err                     code  fffc2a24 18
  FMTK_ExitTask                              code  fffc2908 18
  FMTK_ExitTask.xit                          code  fffc2928 18
  FMTK_ForceReleaseIOFocus                   code  fffc36f8 18
  FMTK_ForceReleaseIOFocus.0001              code  fffc37c0 18
  FMTK_ForceReleaseIOFocus.done              code  fffc37cc 18
  FMTK_ForceReleaseIOFocus.noFocus           code  fffc37cc 18
  FMTK_ForceReleaseIOFocus.noSwitch          code  fffc370c 18
  FMTK_ForceReleaseIOFocus.notSame           code  fffc378c 18
  FMTK_ForceReleaseIOFocus.pjSame            code  fffc37ac 18
  FMTK_FreeMbx                               code  fffc2b64 18
  FMTK_FreeMbx.0001                          code  fffc2c08 18
  FMTK_FreeMbx.0002                          code  fffc2bcc 18
  FMTK_FreeMbx.0003                          code  fffc2bfc 18
  FMTK_FreeMbx.badMbx                        code  fffc2c20 18
  FMTK_FreeMbx.lock                          code  fffc2ba0 18
  FMTK_FreeMbx.xit                           code  fffc2c24 18
  FMTK_GetCurrentTid                         code  fffc1fdc 18
  FMTK_HasIOFocus                            code  fffc353c 18
  FMTK_HasIOFocus.hasFocus                   code  fffc3590 18
  FMTK_HasIOFocus.noSwitch                   code  fffc3568 18
  FMTK_HasIOFocus.xit                        code  fffc3594 18
  FMTK_IO                                    code  fffc37d4 18
  FMTK_IO.badDev                             code  fffc3814 18
  FMTK_IO.badFunc                            code  fffc380c 18
  FMTK_IO.xit                                code  fffc3808 18
  FMTK_Initialize                            code  80000000000001bf 32
  FMTK_KillTask                              code  fffc2934 18
  FMTK_KillTask.immortal                     code  fffc29e4 18
  FMTK_KillTask.lock                         code  fffc2958 18
  FMTK_PeekMsg                               code  fffc2dbc 18
  FMTK_PeekMsg.badMbx                        code  fffc2ec4 18
  FMTK_PeekMsg.lock                          code  fffc2dec 18
  FMTK_PeekMsg.noMsg                         code  fffc2eb8 18
  FMTK_PeekMsg.nod1                          code  fffc2e7c 18
  FMTK_PeekMsg.nod2                          code  fffc2e94 18
  FMTK_PeekMsg.nod3                          code  fffc2eac 18
  FMTK_PeekMsg.nodq                          code  fffc2e5c 18
  FMTK_PeekMsg.ret                           code  fffc2ec8 18
  FMTK_PostMsg                               code  80000000000001c7 32
  FMTK_ReleaseIOFocus                        code  fffc36ec 18
  FMTK_RequestIOFocus                        code  fffc3654 18
  FMTK_RequestIOFocus.notEmpty               code  fffc36cc 18
  FMTK_RequestIOFocus.ret                    code  fffc36e4 18
  FMTK_SaveContext                           code  fffc2088 18
  FMTK_SchedulerIRQ                          code  fffc25ac 18
  FMTK_SchedulerIRQ.0001                     code  fffc2628 18
  FMTK_SchedulerIRQ.0002                     code  fffc2700 18
  FMTK_SchedulerIRQ.0003                     code  fffc2718 18
  FMTK_SchedulerIRQ.0004                     code  fffc2730 18
  FMTK_SchedulerIRQ.dq                       code  fffc26bc 18
  FMTK_SchedulerIRQ.goodTid                  code  fffc26bc 18
  FMTK_SchedulerIRQ.noException              code  fffc26d4 18
  FMTK_SchedulerIRQ.noLock                   code  fffc276c 18
  FMTK_SchedulerIRQ.noMsg                    code  fffc2738 18
  FMTK_SchedulerIRQ.noTimeout                code  fffc2654 18
  FMTK_SchedulerIRQ.notZero                  code  fffc2654 18
  FMTK_SchedulerIRQ.nxtQ                     code  fffc269c 18
  FMTK_SchedulerIRQ.searchQ                  code  fffc2660 18
  FMTK_SendMsg                               code  fffc2c48 18
  FMTK_SendMsg.0001                          code  fffc2cb0 18
  FMTK_SendMsg.badMbx                        code  fffc2d94 18
  FMTK_SendMsg.lock                          code  fffc2c7c 18
  FMTK_SendMsg.mbxEmpty                      code  fffc2d74 18
  FMTK_SendMsg.noMsg                         code  fffc2d88 18
  FMTK_SendMsg.noWaiters                     code  fffc2d20 18
  FMTK_SendMsg.nxtTid                        code  fffc2d00 18
  FMTK_SendMsg.xit                           code  fffc2d98 18
  FMTK_SetTaskPriority                       code  80000000000001c3 32
  FMTK_Sleep                                 code  fffc2440 18
  FMTK_Sleep.0001                            code  fffc24ac 18
  FMTK_Sleep.0002                            code  fffc2530 18
  FMTK_Sleep.0003                            code  fffc254c 18
  FMTK_Sleep.0004                            code  fffc2568 18
  FMTK_Sleep.lock                            code  fffc2464 18
  FMTK_Sleep.noException                     code  fffc2504 18
  FMTK_Sleep.noMsg                           code  fffc2574 18
  FMTK_Sleep.xit                             code  fffc258c 18
  FMTK_StartApp                              code  80000000000001cb 32
  FMTK_StartTask                             code  fffc2778 18
  FMTK_StartTask.err                         code  fffc28fc 18
  FMTK_StartTask.lock                        code  fffc2798 18
  FMTK_StartTask.xit                         code  fffc28f0 18
  FMTK_SwitchIOFocus                         code  fffc359c 18
  FMTK_SwitchIOFocus.0001                    code  fffc35e0 18
  FMTK_SwitchIOFocus.0002                    code  fffc35f8 18
  FMTK_SwitchIOFocus.0003                    code  fffc361c 18
  FMTK_SwitchIOFocus.0004                    code  fffc3634 18
  FMTK_SwitchIOFocus.noFocus                 code  fffc3644 18
  FMTK_SwitchIOFocus.sameFocus               code  fffc3644 18
  FMTK_WaitMsg                               code  fffc2eec 18
  FMTK_WaitMsg.lock                          code  fffc2f28 18
  FMTK_WaitMsg.qt                            code  fffc2f10 18
  FMTK_WaitMsg.xit                           code  fffc2fb0 18
  FNDLN                                      code  fffc60e0 18
  FNDLNP                                     code  fffc6100 18
  FNDNXT                                     code  fffc6168 18
  FNDRET                                     code  fffc613c 18
  FNDRET.0001                                code  fffc6140 18
  FNDRET1                                    code  fffc6158 18
  FNDRET2                                    code  fffc6160 18
  FNDSKP                                     code  fffc616c 18
  FOR                                        code  fffc4fdc 18
  FORCEFIT                                   code  fffc5808 18
  FORCEFIT.0001                              code  fffc582c 18
  FORCEFIT.intAnd                            code  fffc581c 18
  FR1                                        code  fffc5008 18
  FR2                                        code  fffc5030 18
  FR3                                        code  fffc5038 18
  FR4                                        code  fffc503c 18
  FR5                                        code  fffc504c 18
  FR6                                        code  fffc5094 18
  FR7                                        code  fffc5098 18
  FR8                                        code  fffc50b8 18
  FUNCEXPR                                   code  fffc5a88 18
  FillMem                                    code  fffc061c 18
  FillMem.0001                               code  fffc0638 18
  FindRun                                    code  fffc0f30 18
  FindRun.0001                               code  fffc0f50 18
  FindRun.0002                               code  fffc0f60 18
  FindRun.0003                               code  fffc0f4c 18
  FindRun.empty0                             code  fffc0f68 18
  FindRun.empty1                             code  fffc0f6c 18
  FindRun.foundEnough                        code  fffc0f88 18
  FindStackRun                               code  fffc0f90 18
  FindStackRun.0001                          code  fffc0fb0 18
  FindStackRun.0002                          code  fffc0fc0 18
  FindStackRun.0003                          code  fffc0fac 18
  FindStackRun.empty0                        code  fffc0fc8 18
  FindStackRun.empty1                        code  fffc0fc8 18
  FindStackRun.foundEnough                   code  fffc0fe4 18
  FreeAll                                    code  fffc1108 18
  FreeAll.0001                               code  fffc1168 18
  FreeAll.nxt                                code  fffc1110 18
  FreeMsg                                   const  024350 19
  FreeTCB                                    code  fffc3318 18
  GCHAR                                      code  fffc5358 18
  GCHAR1                                     code  fffc5370 18
  GETLN                                      code  fffc5fd4 18
  GETLN.GL1                                  code  fffc5ff8 18
  GETLN.GL2                                  code  fffc6020 18
  GETLN.GL3                                  code  fffc6054 18
  GETLN.GL4                                  code  fffc6080 18
  GETLN.GL5                                  code  fffc6098 18
  GETLN.GL6                                  code  fffc60b8 18
  GETLN.GL7                                  code  fffc60c4 18
  GOAUXI                                     code  fffc4718 18
  GOAUXO                                     code  fffc4710 18
  GOBYE                                      code  fffc4720 18
  GOIN                                       code  fffc470c 18
  GOOUT                                      code  fffc4708 18
  GOSTART                                    code  fffc4700 18
  GOSUB                                      code  fffc4f00 18
  GOTO                                       code  fffc4d40 18
  GOWARM                                     code  fffc4704 18
  GetBuflen                                  code  fffc49a0 18
  GetBuflen.0001                             code  fffc49c8 18
  GetBuflen.0002                             code  fffc49ac 18
  GetBuflen.0004                             code  fffc49c4 18
  GetCurrentTid                              code  fffc1fd0 18
  GetFilename                                code  fffc53bc 18
  GetHexNum                                  code  fffc067c 18
  GetHexNum.0001                             code  fffc06d0 18
  GetHexNum.isDigit                          code  fffc0718 18
  GetHexNum.isHexLower                       code  fffc06fc 18
  GetHexNum.isHexUpper                       code  fffc06e0 18
  GetHexNum.next                             code  fffc0690 18
  Getch                                      code  fffc0214 18
  IF0                                        code  fffc517c 18
  IF1                                        code  fffc5180 18
  IF2                                        code  fffc5188 18
  IF3                                        code  fffc519c 18
  IGB1                                       code  fffc65c0 18
  IGB2                                       code  fffc65ac 18
  IGBRET                                     code  fffc65c8 18
  IGNBLK                                     code  fffc65a4 18
  INBUF                                     const  014100 18
  INCH                                       code  fffc6888 18
  INCH1                                      code  fffc68ac 18
  INPERR                                     code  fffc51a0 18
  INPPTR                                    const  0300ac 19
  INPUT                                      code  fffc51d4 18
  INSLINE                                    code  fffc48e0 18
  INSLINE.0001                               code  fffc490c 18
  IOF_NEXT                                  const  0002e8 11
  IOF_PREV                                  const  0002f0 11
  IOFocusNdx                                const  024810 19
  IOFocusTbl                                const  024818 19
  IP2                                        code  fffc51fc 18
  IP3                                        code  fffc5238 18
  IP4                                        code  fffc52ac 18
  IP5                                        code  fffc52bc 18
  IP6                                        code  fffc51dc 18
  IP7                                        code  fffc521c 18
  IRQFlag                                   const  0300b4 19
  IRQROUT                                   const  0300a4 19
  IRQRout                                    code  fffc08d4 18
  IRQRout.cause0to7                          code  fffc0998 18
  IRQRout.cause12plus                        code  fffc0998 18
  IRQRout.doIRQ                              code  fffc0940 18
  IRQRout.isIRQ                              code  fffc090c 18
  IRQRout.noIRQ                              code  fffc0960 18
  IdleTask                                   code  fffc0210 18
  InsertIntoReadyList                        code  fffc2fc0 18
  InsertIntoReadyList.0001                   code  fffc3054 18
  InsertIntoReadyList.badTid                 code  fffc305c 18
  InsertIntoReadyList.insert                 code  fffc3020 18
  InsertIntoReadyList.level2                 code  fffc3040 18
  InsertIntoTimeoutList                      code  fffc311c 18
  InsertIntoTimeoutList.0001                 code  fffc3174 18
  InsertIntoTimeoutList.0002                 code  fffc31dc 18
  InsertIntoTimeoutList.0003                 code  fffc31ec 18
  InsertIntoTimeoutList.beginWhile           code  fffc3180 18
  InsertIntoTimeoutList.endOfList            code  fffc31a0 18
  InsertIntoTimeoutList.endWhile             code  fffc31b0 18
  InsertLine                                 code  fffc4980 18
  InsertLine.0001                            code  fffc4984 18
  InsertLine.done                            code  fffc499c 18
  KEYBD                                      code  8000000000000284 32
  KeybdFuncTbl                               code  fffc3b50 18
  KeybdIRQ                                   code  fffc3f2c 18
  KeybdIRQ.0001                              code  fffc3fb8 18
  KeybdIRQ.noRoom                            code  fffc3f68 18
  KeybdIRQ.notAlt                            code  800000000000029e 32
  KeybdIRQ.notAltTab                         code  fffc3fd8 18
  KeybdIRQ.notCtrl                           code  fffc3fb8 18
  KeybdIRQ.notCtrlC                          code  fffc3f94 18
  KeybdIRQ.notCtrlZ                          code  fffc3fb8 18
  KeybdIRQ.notKbd                            code  fffc4014 18
  KillTask                                   code  800000000000020c 32
  LEDS                                      const  ffdc0600 33
  LET                                        code  fffc52d4 18
  LINEFD                                    const  00000a 5
  LISTX                                      code  fffc4e0c 18
  LNFD                                      const  00000a 5
  LOAD                                       code  fffc52ec 18
  LOAD3                                      code  fffc5440 18
  LOAD4                                      code  fffc546c 18
  LOAD5                                      code  fffc54a4 18
  LOD1                                       code  fffc52fc 18
  LOD2                                       code  fffc5328 18
  LODEND                                     code  fffc5344 18
  LOG_MBXSZ                                 const  000005 4
  LOG_MSGSZ                                 const  000005 4
  LOG_PGSZ                                  const  000010 6
  LOG_TCBSZ                                 const  00000a 5
  LOPINC                                    const  030078 19
  LOPLMT                                    const  03007c 19
  LOPLN                                     const  030074 19
  LOPPT                                     const  030070 19
  LOPVAR                                    const  030010 19
  LS1                                        code  fffc4e20 18
  LS2                                        code  fffc4e54 18
  LS3                                        code  fffc4e5c 18
  LS4                                        code  fffc4e38 18
  LS5                                        code  fffc4e24 18
  LSTROM                                    const  000000 1
  LT1                                        code  fffc52e8 18
  LoadWord                                   code  fffc645c 18
  MAX_ASID                                  const  00003f 7
  MAX_DEV_OP                                const  00001f 6
  MAX_MID                                   const  00003f 7
  MAX_TID                                   const  00003f 7
  MBX_MQHEAD                                const  000010 6
  MBX_MQTAIL                                const  000018 6
  MBX_OWNER                                 const  000000 1
  MBX_SIZE                                  const  000020 7
  MBX_WTIDS                                 const  000008 5
  MMUInit                                    code  fffc0e80 18
  MMUInit.0001                               code  fffc0eb4 18
  MMUInit.0002                               code  fffc0f14 18
  MMUInit.0004                               code  fffc0ea8 18
  MMUInit.0006                               code  fffc0edc 18
  MSG_D1                                    const  000008 5
  MSG_D2                                    const  000010 6
  MSG_D3                                    const  000018 6
  MSG_LINK                                  const  000000 1
  MSG_SIZE                                  const  000020 7
  MULEXPR                                    code  fffc59ec 18
  MVDOWN                                     code  fffc61a8 18
  MVDOWN1                                    code  fffc6198 18
  MVUP                                       code  fffc6190 18
  MVUP1                                      code  fffc6180 18
  MachineStart                               code  fffc0100 18
  MapOSPages                                 code  fffc1ff4 18
  MapOSPages.nxt                             code  fffc2000 18
  MbxRemoveTask                              code  fffc2a28 18
  MbxRemoveTask.xit                          code  fffc2a78 18
  MonEntry                                   code  fffc0304 18
  Monitor                                    code  fffc030c 18
  Monitor.0001                               code  fffc033c 18
  Monitor.0002                               code  fffc038c 18
  Monitor.0003                               code  fffc03f0 18
  Monitor.0004                               code  fffc0478 18
  Monitor.0005                               code  fffc0570 18
  Monitor.0006                               code  fffc04dc 18
  Monitor.0007                               code  fffc050c 18
  Monitor.0008                               code  fffc0518 18
  Monitor.0009                               code  fffc0524 18
  Monitor.0010                               code  fffc053c 18
  Monitor.0011                               code  fffc0558 18
  Monitor.0012                               code  fffc0570 18
  Monitor.doBackspace                        code  fffc03dc 18
  Monitor.doDelete                           code  fffc0384 18
  Monitor.noT                                code  fffc0504 18
  Monitor.procLine                           code  fffc0440 18
  Monitor.skip                               code  fffc0454 18
  Monitor.skip2                              code  fffc0470 18
  NEW                                        code  fffc4be8 18
  NEXT                                       code  fffc50bc 18
  NPAGES                                    const  024828 19
  NR_DCB                                    const  000020 7
  NR_MBX                                    const  000100 10
  NR_MSG                                    const  000800 13
  NR_TCB                                    const  000040 8
  NUMWKA                                    const  030094 19
  NX0                                        code  fffc50d8 18
  NX1                                        code  fffc513c 18
  NX2                                        code  fffc5104 18
  NX3                                        code  fffc5140 18
  NX4                                        code  fffc50d4 18
  NX5                                        code  fffc50f8 18
  NXPurge                                    code  fffc5174 18
  OKMSG                                      code  fffc6902 18
  ONIRQ                                      code  fffc4db0 18
  ONIRQ1                                     code  fffc4ddc 18
  OREXPR                                     code  fffc56d8 18
  OSCALL                                     code  fffc2390 18
  OSCALL.oscall                              code  fffc23f0 18
  OSCALL.xit                                 code  fffc2420 18
  OSCALL.zero                                code  fffc2438 18
  OSCallTbl                                  code  fffc1e4c 18
  OSPAGES                                   const  000003 3
  OSSP                                      const  030000 19
  OUTC                                       code  fffc6884 18
  OUTPTR                                    const  0300a8 19
  OpenSpace                                  code  fffc49cc 18
  OpenSpace.0003                             code  fffc4a08 18
  OpenSpace.noSpace                          code  fffc4a24 18
  PAGESZ                                    const  010000 18
  PAGES_PER_MAP                             const  001000 14
  PAGES_PER_TASK                            const  001000 14
  PARN                                       code  fffc5ad8 18
  PEEK                                       code  fffc5cec 18
  PEEKH                                      code  fffc5d1c 18
  PEEKW                                      code  fffc5d04 18
  PIC                                       const  ffdc0f00 33
  PIC_CH16                                  const  0000c0 9
  PIC_CH28                                  const  0000f0 9
  PIC_CH31                                  const  0000fc 9
  PIDMAP                                    const  024310 19
  PKER                                       code  fffc56a0 18
  POKE                                       code  fffc561c 18
  POKEH                                      code  fffc5674 18
  POKEW                                      code  fffc5648 18
  POPA_                                      code  fffc61b0 18
  PP1                                        code  fffc6220 18
  PR0                                        code  fffc4e8c 18
  PR1                                        code  fffc4ea4 18
  PR2                                        code  fffc4e78 18
  PR3                                        code  fffc4ec4 18
  PR4                                        code  fffc4ebc 18
  PR6                                        code  fffc4ed8 18
  PR8                                        code  fffc4ee0 18
  PRINT                                      code  fffc4e60 18
  PRMESG                                     code  fffc6688 18
  PRNGL                                     const  ffdc0c00 33
  PRNG_STREAM                               const  000008 5
  PRNG_VALUE                                const  000000 1
  PRTLN                                      code  fffc6488 18
  PRTNUM                                     code  fffc63ac 32
  PRTNUM.PN1                                 code  fffc63e4 18
  PRTNUM.PN2                                 code  fffc63e0 18
  PRTNUM.PN3                                 code  fffc640c 18
  PRTNUM.PN4                                 code  fffc641c 18
  PRTNUM.PN5                                 code  fffc6428 18
  PRTNUM.PN6                                 code  fffc6430 18
  PRTNUM.PN7                                 code  fffc63f4 18
  PRTSTG                                     code  fffc62b0 18
  PRTSTG.PRTRET                              code  fffc62f4 18
  PRTSTG.PS1                                 code  fffc62d0 18
  PU1                                        code  fffc62a4 18
  PUSHA_                                     code  fffc6224 18
  PWORD                                      code  fffc55a4 18
  PicInit                                    code  fffc11a8 18
  PutHexByte                                 code  fffc0790 18
  PutHexDword                                code  fffc0730 18
  PutHexHalf                                 code  fffc0770 18
  PutHexNybble                               code  fffc07b0 18
  PutHexNybble.0001                          code  fffc07e8 18
  PutHexNybble.lt10                          code  fffc07dc 18
  PutHexWord                                 code  fffc0750 18
  PutString                                  code  fffc07f8 18
  PutString.0001                             code  fffc0808 18
  PutString.done                             code  fffc0820 18
  Putch                                      code  fffc0244 18
  QNDX                                      const  024304 19
  QSORRY                                     code  fffc5f64 18
  QT1                                        code  fffc6330 18
  QT2                                        code  fffc6370 18
  QT3                                        code  fffc6348 18
  QT4                                        code  fffc635c 18
  QT5                                        code  fffc637c 18
  QTSTG                                      code  fffc6318 18
  QWHAT                                      code  fffc5f70 18
  RDYQ0                                     const  024400 19
  RDYQ1                                     const  024500 19
  RDYQ2                                     const  024600 19
  RDYQ3                                     const  024700 19
  READYQ                                    const  024308 19
  RETURN                                     code  fffc4f74 18
  RND                                        code  fffc5d80 18
  RUN                                        code  fffc4c1c 18
  RUN1                                       code  fffc4cf4 18
  RUN2                                       code  fffc4c50 18
  RUN3                                       code  fffc4c54 18
  RUNNXL                                     code  fffc4c3c 18
  RUNSML                                     code  fffc4d28 18
  RUNTSL                                     code  fffc4d14 18
  RemoveFromReadyList                        code  fffc3064 18
  RemoveFromReadyList.tidOk                  code  fffc3078 18
  RemoveFromReadyList2                       code  fffc3090 18
  RemoveFromReadyList2.0001                  code  fffc30e4 18
  RemoveFromReadyList2.0002                  code  fffc3100 18
  RemoveFromReadyList2.0003                  code  fffc30d4 18
  RemoveFromReadyList2.badTid                code  fffc3114 18
  RemoveFromTimeoutList                      code  fffc3200 18
  RemoveFromTimeoutList.0001                 code  fffc3250 18
  RemoveFromTimeoutList.noNext               code  fffc3270 18
  RemoveFromTimeoutList.noPrev               code  fffc3284 18
  RemoveFromTimeoutList.noWait               code  fffc3214 18
  RestoreContext                             code  fffc2154 18
  RestoreContext.rsseg                       code  fffc2164 18
  SAVE                                       code  fffc5514 18
  SAVE1                                      code  fffc552c 18
  SAVE2                                      code  fffc5548 18
  SAVE3                                      code  fffc54a8 18
  SAVE4                                      code  fffc54d8 18
  SAVEND                                     code  fffc5560 18
  SC_C                                      const  000021 7
  SC_TAB                                    const  00000d 5
  SC_Z                                      const  00001a 6
  SDReadSector                               code  80000000000003af 32
  SDWriteSector                              code  80000000000003b4 32
  SENDMSG                                    code  fffc6710 18
  SENDMSG.err                                code  fffc6794 18
  SENDMSG.paren                              code  fffc67a0 18
  SETVAL                                     code  fffc5e84 18
  SETVAL.sv2                                 code  fffc5ea8 18
  SGN                                        code  fffc5e14 18
  SGN1                                       code  fffc5e44 18
  SGN2                                       code  fffc5e34 18
  SIZEX                                      code  fffc5e50 18
  SRYMSG                                     code  fffc690f 18
  ST2                                        code  fffc48bc 18
  STACKOFFS                                 const  afffc000 33
  STKBOT                                    const  03009c 19
  STKGOS                                    const  030014 19
  STKINP                                    const  030098 19
  STOP                                       code  fffc4c08 18
  STRTMP                                    const  000200 11
  SV1                                        code  fffc5ee4 18
  SYSX                                       code  fffc56ac 18
  SYS_MUTEX                                 const  ffdbff00 33
  SaveContext                                code  fffc2094 18
  SaveContext.svseg                          code  fffc212c 18
  SaveContext.xit                            code  fffc2150 18
  SelectTaskToRun                            code  fffc2014 18
  SelectTaskToRun.0001                       code  fffc205c 18
  SelectTaskToRun.dq                         code  fffc2080 18
  SelectTaskToRun.goodTid                    code  fffc2080 18
  SelectTaskToRun.nxtQ                       code  fffc2050 18
  SelectTaskToRun.searchQ                    code  fffc2014 18
  SerHeadRcv                                const  025800 19
  SerHeadXmit                               const  025808 19
  SerRcvBuf                                 const  025000 19
  SerRcvXoff                                const  025811 19
  SerRcvXon                                 const  025810 19
  SerTailRcv                                const  025804 19
  SerTailXmit                               const  02580c 19
  SerXmitBuf                                const  025400 19
  SerialFinishCmd                            code  fffc140c 18
  SerialFinishCmd.0001                       code  fffc1430 18
  SerialFuncTbl                              code  fffc11d8 18
  SerialGetChar                              code  fffc1434 18
  SerialGetChar.0001                         code  fffc14e8 18
  SerialGetChar.0002                         code  fffc149c 18
  SerialGetChar.noChars                      code  fffc14e8 18
  SerialGetChar.xit                          code  fffc14ec 18
  SerialIRQ                                  code  fffc167c 18
  SerialIRQ.0001                             code  fffc172c 18
  SerialIRQ.notRxInt                         code  fffc1740 18
  SerialIRQ.nxtByte                          code  fffc167c 18
  SerialIRQ.rxFull                           code  fffc1740 18
  SerialInit                                 code  fffc12d8 18
  SerialPeekChar                             code  fffc1504 18
  SerialPeekChar.0001                        code  fffc1550 18
  SerialPeekChar.noChars                     code  fffc1550 18
  SerialPeekChar.xit                         code  fffc1554 18
  SerialPeekCharDirect                       code  fffc156c 18
  SerialPeekCharDirect.0001                  code  fffc15ac 18
  SerialPeekCharDirect.xit                   code  fffc15b0 18
  SerialPutChar                              code  fffc15c8 18
  SerialPutChar.0001                         code  fffc15dc 18
  SerialPutChar.0002                         code  fffc15d8 18
  SerialPutChar.goSleep                      code  fffc1618 18
  SerialRcvCount                             code  fffc1640 18
  SerialRcvCount.xit                         code  fffc1674 18
  SerialService                              code  fffc13b4 18
  SerialServiceInit                          code  fffc139c 18
  SerialServiceLoop                          code  fffc13d0 18
  SkipSpaces                                 code  fffc064c 18
  SkipSpaces.skip1                           code  fffc0670 18
  SkipSpaces.skip2                           code  fffc064c 18
  SpriteDemo_101                             code  fffc6fdc 18
  SpriteDemo_106                             code  fffc7010 18
  SpriteDemo_107                             code  fffc7024 18
  SpriteDemo_109                             code  fffc7030 18
  SpriteDemo_110                             code  fffc71e4 18
  SpriteDemo_112                             code  fffc70e8 18
  SpriteDemo_114                             code  fffc7134 18
  SpriteDemo_116                             code  fffc7184 18
  SpriteDemo_118                             code  fffc71a8 18
  SpriteDemo_17                              code  fffc6b98 18
  SpriteDemo_20                              code  fffc6b98 18
  SpriteDemo_21                              code  fffc6b4c 18
  SpriteDemo_22                              code  fffc6b98 18
  SpriteDemo_23                              code  fffc6b88 18
  SpriteDemo_31                              code  fffc6bfc 18
  SpriteDemo_39                              code  fffc6cf8 18
  SpriteDemo_42                              code  fffc6cf8 18
  SpriteDemo_43                              code  fffc6c74 18
  SpriteDemo_44                              code  fffc6cf8 18
  SpriteDemo_83                              code  fffc7214 18
  SpriteDemo_86                              code  fffc7214 18
  SpriteDemo_87                              code  fffc6dd8 18
  SpriteDemo_88                              code  fffc6e4c 18
  SpriteDemo_9                               code  fffc6b04 18
  SpriteDemo_90                              code  fffc6e64 18
  SpriteDemo_91                              code  fffc6ef8 18
  SpriteDemo_93                              code  fffc6ee8 18
  SpriteDemo_95                              code  fffc6f08 18
  SpriteDemo_96                              code  fffc6f80 18
  SpriteDemo_98                              code  fffc6f90 18
  SpriteDemo_99                              code  fffc6fdc 18
  SpriteDemo_longlit0                      rodata  fffc8000 32
  SwapContext                                code  fffc2210 18
  SwapContext.noCtxSwitch                    code  fffc238c 18
  SwapContext.rsseg                          code  fffc22dc 18
  SwapContext.savedAlready                   code  fffc22d8 18
  SwapContext.svseg                          code  fffc22bc 18
  SwitchIOFocus                             const  024820 19
  SysSema                                   const  024340 19
  TAB                                       const  000009 5
  TAB1                                       code  fffc4a2c 18
  TAB10                                      code  fffc4ae6 18
  TAB10_1                                    code  fffc4b56 18
  TAB1_1                                     code  fffc4aea 18
  TAB2                                       code  fffc4a3e 18
  TAB2_1                                     code  fffc4af4 18
  TAB4                                       code  fffc4a97 18
  TAB4_1                                     code  fffc4b22 18
  TAB5                                       code  fffc4ad0 18
  TAB5_1                                     code  fffc4b3c 18
  TAB6                                       code  fffc4ad3 18
  TAB6_1                                     code  fffc4b40 18
  TAB8                                       code  fffc4ad8 18
  TAB8_1                                     code  fffc4b44 18
  TAB9                                       code  fffc4ae2 18
  TAB9_1                                     code  fffc4b52 18
  TC1                                        code  fffc6518 18
  TC64CursorAddr                            const  ffd1df1c 33
  TCBContextSaved                           const  00028a 11
  TCBElapsedTime                            const  0002c0 11
  TCBEndTime                                const  0002b8 11
  TCBException                              const  0002c8 11
  TCBKbdBuf                                 const  000308 11
  TCBKbdHead                                const  000300 11
  TCBKbdState2                               code  8000000000000299 32
  TCBKbdTail                                const  000301 11
  TCBMsgD1                                  const  000298 11
  TCBMsgD2                                  const  0002a0 11
  TCBMsgD3                                  const  0002a8 11
  TCBName                                   const  0002f8 11
  TCBNext                                   const  0002d0 11
  TCBPrev                                   const  0002d8 11
  TCBPriority                               const  000289 11
  TCBResource                               const  000328 11
  TCBStackBot                               const  000290 11
  TCBStartTime                              const  0002b0 11
  TCBStatus                                 const  000288 11
  TCBTimeout                                const  0002e0 11
  TCBVidMem                                  code  8000000000000212 32
  TCBVideoMem                               const  000330 11
  TCBWaitMbx                                const  00028c 11
  TCBepc                                    const  000280 11
  TCBpVideo                                 const  000338 11
  TCBsegs                                   const  000200 11
  TICKX                                      code  fffc5e00 18
  TN1                                        code  fffc6548 18
  TN2                                        code  fffc6574 18
  TOOBIG                                     code  fffc5f58 18
  TOUPB1                                     code  fffc65e8 18
  TOUPBRT                                    code  fffc6630 18
  TOUPBUF                                    code  fffc65d4 18
  TOUPRET                                    code  fffc6654 18
  TSNMRET                                    code  fffc6594 18
  TSTC                                       code  fffc64e4 18
  TSTNUM                                     code  fffc6530 18
  TSTV                                       code  fffc5b18 18
  TSTVRT                                     code  fffc5b94 18
  TS_DEAD                                   const  000002 3
  TS_MSGRDY                                 const  000004 4
  TS_NONE                                   const  000000 1
  TS_PREEMPT                                const  000020 7
  TS_READY                                  const  000001 2
  TS_RUNNING                                const  000080 9
  TS_TIMEOUT                                const  000010 6
  TS_WAITMSG                                const  000008 5
  TV1                                        code  fffc5b80 18
  TV2                                        code  fffc5b68 18
  TV3                                        code  fffc5b48 18
  TXTBGN                                    const  031800 19
  TXTUNF                                    const  030004 19
  Tick                                      const  024330 19
  TimeoutList                               const  024328 19
  TinyBasic                                  code  fffc4700 18
  UART                                      const  ffdc0a00 33
  UART_CMD                                  const  000008 5
  UART_STAT                                 const  000004 4
  UART_TRB                                  const  000000 1
  USRX                                       code  fffc5d34 18
  UpdateCursorPos                            code  fffc1ae4 18
  UserStart                                  code  fffc0168 18
  UserStart.0001                             code  fffc0180 18
  UserStart2                                 code  fffc0180 18
  UserStart2.0002                            code  fffc01d4 18
  UserStart2.0003                            code  fffc01f4 18
  UserStart2.0004                            code  fffc01d4 18
  UserStart2.0005                            code  fffc01d4 18
  VARBGN                                    const  030008 19
  VAREND                                    const  03000c 19
  VIA                                       const  ffdc0600 33
  VIA_ACR                                   const  00002c 7
  VIA_DDRA                                  const  00000c 5
  VIA_IER                                   const  000038 7
  VIA_IFR                                   const  000034 7
  VIA_PA                                    const  000004 4
  VIA_PARAW                                 const  00003c 7
  VIA_PCR                                   const  000030 7
  VIA_T1CH                                  const  000014 6
  VIA_T1CL                                  const  000010 6
  ViaFuncTbl                                 code  fffc1750 18
  ViaIRQ                                     code  fffc18ac 18
  ViaIRQ.0003                                code  fffc1900 18
  ViaInit                                    code  fffc1850 18
  VideoClearScreen                           code  fffc1a80 18
  VideoClearScreen.0001                      code  fffc1ab0 18
  VideoFuncTbl                               code  fffc1908 18
  VideoHomeCursor                            code  fffc1ac4 18
  VideoIRQ                                   code  fffc1e48 18
  VideoIRQ.0003                              code  fffc1e48 18
  VideoInit                                  code  fffc1a08 18
  VideoPutChar                               code  fffc1b24 18
  VideoPutChar.0001                          code  fffc1c28 18
  VideoPutChar.backspace                     code  fffc1d68 18
  VideoPutChar.bs0001                        code  fffc1de0 18
  VideoPutChar.bs0002                        code  fffc1dcc 18
  VideoPutChar.cr1                           code  fffc1cd0 18
  VideoPutChar.cr2                           code  fffc1ccc 18
  VideoPutChar.cursorDown                    code  fffc1d2c 18
  VideoPutChar.cursorLeft                    code  fffc1cd4 18
  VideoPutChar.cursorRight                   code  fffc1ca0 18
  VideoPutChar.cursorUp                      code  fffc1d00 18
  VideoPutChar.del0001                       code  fffc1d90 18
  VideoPutChar.delete                        code  fffc1dfc 18
  VideoPutChar.doCR                          code  fffc1c74 18
  VideoPutChar.doCls                         code  fffc1d5c 18
  VideoPutChar.doLF                          code  fffc1c8c 18
  VideoPutChar.doLF1                         code  fffc1c00 18
  VideoPutChar.saveX                         code  fffc1c5c 18
  VideoPutChar.saveY                         code  fffc1c4c 18
  VideoPutChar.xit                           code  fffc1c3c 18
  VideoPutString                             code  fffc1e10 18
  VideoPutString.again                       code  fffc1e20 18
  VideoPutString.done                        code  fffc1e3c 18
  VirtToPhys                                 code  fffc116c 18
  VirtToPhys.notMapped                       code  fffc11a0 18
  WAITIRQ                                    code  fffc4df0 18
  WAITMSG                                    code  fffc67ac 18
  WAITMSG.0001                               code  fffc67e4 18
  WAITMSG.0002                               code  fffc67d8 18
  WAITMSG.err                                code  fffc686c 18
  WAITMSG.paren                              code  fffc6878 18
  WSTART                                     code  fffc4824 18
  XOFF                                      const  000013 6
  XON                                       const  000011 6
  XP11                                       code  fffc585c 18
  XP12                                       code  fffc5874 18
  XP13                                       code  fffc588c 18
  XP14                                       code  fffc58a4 18
  XP15                                       code  fffc58bc 18
  XP16                                       code  fffc58d4 18
  XP17                                       code  fffc5914 18
  XP18                                       code  fffc592c 18
  XP21                                       code  fffc597c 18
  XP22                                       code  fffc5988 18
  XP23                                       code  fffc598c 18
  XP24                                       code  fffc59a8 18
  XP25                                       code  fffc59bc 18
  XP26                                       code  fffc59c8 18
  XP31                                       code  fffc59f8 18
  XP34                                       code  fffc5a28 18
  XP35                                       code  fffc5a4c 18
  XP40                                       code  fffc5aa4 18
  XP41                                       code  fffc5ac0 18
  XP42                                       code  fffc5afc 18
  XP43                                       code  fffc5b08 18
  XP45                                       code  fffc59d4 18
  XP46                                       code  fffc5acc 18
  XP47                                       code  fffc5a70 18
  XPRT0                                      code  fffc58ec 18
  XPRT1                                      code  fffc5900 18
  XP_AND                                     code  fffc576c 18
  XP_AND1                                    code  fffc574c 18
  XP_ANDX                                    code  fffc5780 18
  XP_OR                                      code  fffc570c 18
  XP_OR1                                     code  fffc56ec 18
  XP_ORX                                     code  fffc5720 18
  YIELD0                                     code  fffc4c10 18
  _ACBPtrs                                 rodata  000000 32
  _BIOS1_sema                              rodata  000000 32
  _BIOS_RespMbx                            rodata  000000 32
  _DBGCheckForKey                            code  fffc4160 32
  _DBGGetKey                                 code  fffc41a0 32
  _DeviceTable                             rodata  000000 32
  _DumpTaskList                            rodata  000000 32
  _EnableSprite                              code  fffc6ad0 32
  _EnableSprites                           rodata  000000 32
  _FMTK_Inited                             rodata  000000 32
  _FMTK_Reschedule                         rodata  000000 32
  _FMTK_SendMsg                            rodata  000000 32
  _FMTK_StartApp                           rodata  000000 32
  _FMTK_StartThread                        rodata  000000 32
  _FMTK_WaitMsg                            rodata  000000 32
  _FocusSwitcher                           rodata  000000 32
  _GetACBPtr                               rodata  000000 32
  _GetAppHandle                            rodata  000000 32
  _GetRand                                 rodata  fffc4124 32
  _GetRunningACBPtr                        rodata  000000 32
  _GetVecno                                rodata  000000 32
  _IOFocusNdx                              rodata  000000 32
  _IOFocusTbl                              rodata  000000 32
  _InsertIntoReadyList                     rodata  000000 32
  _InsertIntoTimeoutList                   rodata  000000 32
  _KeyLED                                  rodata  024826 32
  _KeyState1                               rodata  024824 32
  _KeyState2                               rodata  024825 32
  _KeybdClearRcv                           rodata  000000 32
  _KeybdGetBufferStatus                      code  fffc401c 18
  _KeybdGetBufferStatus.empty                code  fffc4044 18
  _KeybdGetBufferedScancode                  code  fffc404c 18
  _KeybdGetBufferedScancode.empty            code  fffc4080 18
  _KeybdGetID                                code  fffc3dbc 18
  _KeybdGetID.0001                           code  fffc3e00 18
  _KeybdGetID.notKbd                         code  fffc3e1c 18
  _KeybdGetScancode                        rodata  fffc3f08 32
  _KeybdGetStatus                          rodata  fffc3ee0 32
  _KeybdID                                   code  8000000000000291 32
  _KeybdInit                                 code  fffc3c50 18
  _KeybdInit.0002                            code  fffc3c80 18
  _KeybdInit.0004                            code  fffc3d28 18
  _KeybdInit.config                          code  fffc3ccc 18
  _KeybdInit.keybdErr                        code  fffc3d10 18
  _KeybdInit.ledxit                          code  fffc3d54 18
  _KeybdInit.tryAgain                        code  fffc3d04 18
  _KeybdInit.xit                             code  fffc3d70 18
  _KeybdPeekScancode                         code  fffc3ef4 18
  _KeybdRecvByte                             code  fffc3e24 18
  _KeybdRecvByte.0003                        code  fffc3e30 18
  _KeybdRecvByte.0004                        code  fffc3e68 18
  _KeybdSendByte                             code  fffc3e78 18
  _KeybdSetLED                             rodata  fffc3d7c 32
  _KeybdWaitTx                               code  fffc3e8c 18
  _KeybdWaitTx.0001                          code  fffc3e98 18
  _KeybdWaitTx.0002                          code  fffc3ed0 18
  _LockIOFSemaphore                        rodata  000000 32
  _LockKbdSemaphore                        rodata  000000 32
  _LockSemaphore                           rodata  000000 32
  _LockSysSemaphore                        rodata  000000 32
  _MicroDelay                                code  fffc0830 18
  _MicroDelay.0001                           code  fffc0834 18
  _PRNGInit                                  code  fffc408c 18
  _PeekRand                                  code  fffc4100 18
  _RandomizeSpriteColors                     code  fffc6b0c 32
  _RandomizeSpritePositions                  code  fffc6c10 32
  _RemoveFromReadyList                     rodata  000000 32
  _RemoveFromTimeoutList                   rodata  000000 32
  _RequestIOFocus                          rodata  000000 32
  _SeedRand                                  code  fffc40c4 18
  _SetBound48                              rodata  000000 32
  _SetBound49                              rodata  000000 32
  _SetBound50                              rodata  000000 32
  _SetBound51                              rodata  000000 32
  _SetSpritePos                              code  fffc6bb0 32
  _SpriteDemo                                code  fffc6d20 32
  _TimeoutList                             rodata  000000 32
  _XlatScancode                              code  fffc4088 18
  _bios_stacks                             rodata  000000 32
  _chkTCB                                  rodata  000000 32
  _clr                                       code  fffc4d64 18
  _cls                                       code  800000000000032b 32
  _end_init_data                           rodata  fffc9000 32
  _fmtk_irq_stack                          rodata  000000 32
  _fmtk_sys_stack                          rodata  000000 32
  _freeMBX                                 rodata  000000 32
  _freeMSG                                 rodata  000000 32
  _freeTCB                                 rodata  000000 32
  _getCPU                                  rodata  000000 32
  _hFocusSwitchMbx                         rodata  000000 32
  _hasUltraHighPriorityTasks               rodata  000000 32
  _iof_sema                                rodata  000000 32
  _iof_switch                              rodata  000000 32
  _irq_stack                               rodata  000000 32
  _kbd_sema                                rodata  000000 32
  _keybdControlCodes                       rodata  fffc3a50 32
  _keybdExtendedCodes                      rodata  fffc3ad0 32
  _mailbox                                 rodata  000000 32
  _message                                 rodata  000000 32
  _missed_ticks                            rodata  000000 32
  _mmu_Alloc512kPage                       rodata  000000 32
  _mmu_Alloc8kPage                         rodata  000000 32
  _mmu_AllocateMap                         rodata  000000 32
  _mmu_Free512kPage                        rodata  000000 32
  _mmu_Free8kPage                          rodata  000000 32
  _mmu_FreeMap                             rodata  000000 32
  _mmu_MapCardMemory                       rodata  000000 32
  _mmu_SetAccessKey                        rodata  000000 32
  _mmu_SetMapEntry                         rodata  000000 32
  _mmu_SetOperateKey                       rodata  000000 32
  _mmu_alloc                               rodata  000000 32
  _mmu_free                                rodata  000000 32
  _nMailbox                                rodata  000000 32
  _nMsgBlk                                 rodata  000000 32
  _outb                                    rodata  000000 32
  _outc                                    rodata  000000 32
  _outh                                    rodata  000000 32
  _outw                                    rodata  000000 32
  _randStream                              rodata  024830 32
  _rdcf                                      code  800000000000032d 32
  _readyQ                                  rodata  000000 32
  _set_vector                              rodata  000000 32
  _shiftedScanCodes                        rodata  fffc3950 32
  _stacks                                  rodata  000000 32
  _sys_sema                                rodata  000000 32
  _sys_stacks                              rodata  000000 32
  _sysstack                                rodata  000000 32
  _tcbs                                    rodata  000000 32
  _unshiftedScanCodes                      rodata  fffc3850 32
  _video_bufs                              rodata  000000 32
  a2h1                                       code  fffc53b0 18
  asciiToHex                                 code  fffc53a4 18
  begin_init_data                          rodata  fffc8008 32
  clearVars                                  code  fffc4d6c 18
  clearVars.cv1                              code  fffc4d8c 18
  datAttr                                    code  fffc0208 18
  doMem                                      code  fffc0574 18
  doMem.loop                                 code  fffc05dc 18
  doMem.loop2                                code  fffc05b0 18
  ec1                                        code  fffc5f4c 18
  end_init_data                            rodata  fffc9000 32
  findVar                                    code  fffc5c64 18
  fl1                                        code  fffc60f8 18
  flt10                                      code  fffc0a90 18
  flt20                                      code  fffc0a80 18
  flt50                                      code  fffc0a70 18
  fltMillion                                 code  fffc0e64 18
  fltOne                                     code  fffc0e5c 18
  fltTen                                     code  fffc0e60 18
  fltToString                                code  fffc0aa0 18
  fltToString.0001                           code  fffc0b00 18
  fltToString.0002                           code  fffc0b80 18
  fltToString.0003                           code  fffc0b6c 18
  fltToString.0004                           code  fffc0bcc 18
  fltToString.0005                           code  fffc0bc4 18
  fltToString.0006                           code  fffc0bac 18
  fltToString.0007                           code  fffc0be8 18
  fltToString.0008                           code  fffc0bfc 18
  fltToString.0009                           code  fffc0bf8 18
  fltToString.0010                           code  fffc0c1c 18
  fltToString.0011                           code  fffc0ca8 18
  fltToString.0012                           code  fffc0c60 18
  fltToString.0013                           code  fffc0c4c 18
  fltToString.0014                           code  fffc0c7c 18
  fltToString.0015                           code  fffc0c98 18
  fltToString.0016                           code  fffc0c34 18
  fltToString.0017                           code  fffc0ca0 18
  fltToString.0018                           code  fffc0ca8 18
  fltToString.0019                           code  fffc0cdc 18
  fltToString.0020                           code  fffc0ce8 18
  fltToString.0021                           code  fffc0d0c 18
  fltToString.0022                           code  fffc0d18 18
  fltToString.0023                           code  fffc0d28 18
  fltToString.0024                           code  fffc0d34 18
  fltToString.0025                           code  fffc0d20 18
  fltToString.0026                           code  fffc0d48 18
  fltToString.0027                           code  fffc0d50 18
  fltToString.0028                           code  fffc0d58 18
  fltToString.0029                           code  fffc0d64 18
  fltToString.0030                           code  fffc0d70 18
  fltToString.0031                           code  fffc0d7c 18
  fltToString.0032                           code  fffc0d84 18
  fltToString.0034                           code  fffc0d8c 18
  fltToString.0035                           code  fffc0d98 18
  fltToString.0036                           code  fffc0da8 18
  fltToString.0037                           code  fffc0db4 18
  fltToString.0038                           code  fffc0dbc 18
  fltToString.0039                           code  fffc0dd0 18
  fltToString.0040                           code  fffc0dc4 18
  fltToString.0041                           code  fffc0e2c 18
  fltToString.0042                           code  fffc0df0 18
  fltToString.0043                           code  fffc0e00 18
  fltToString.0044                           code  fffc0e14 18
  fltToString.0045                           code  fffc0df8 18
  fltToString.0046                           code  fffc0e20 18
  fltToString.0047                           code  fffc0e2c 18
  fltToString.0048                           code  fffc0e18 18
  fltToString.0050                           code  fffc0e4c 18
  fltToString.0051                           code  fffc0e48 18
  fltToString.0052                           code  fffc0e38 18
  fltToString.inf                            code  fffc0ae8 18
  fltToString.notZero                        code  fffc0b3c 18
  fltToString.pos                            code  fffc0b28 18
  fltToString.prt                            code  fffc0de0 18
  fputc                                      code  fffc02b8 18
  fv1                                        code  fffc5cc4 18
  fv2                                        code  fffc5cd8 18
  fv3                                        code  fffc5cbc 18
  fv4                                        code  fffc5c80 18
  gen_rand                                   code  8000000000000400 32
  getVarName                                 code  fffc5bb8 18
  gfn1                                       code  fffc543c 18
  gfn2                                       code  fffc53d4 18
  gfn3                                       code  fffc5410 18
  gosub1                                     code  fffc4f20 18
  gvn1                                       code  fffc5c50 18
  gvn2                                       code  fffc5c14 18
  gvn3                                       code  fffc5c30 18
  gvn4                                       code  fffc5bd8 18
  gvn6                                       code  fffc5c04 18
  hKeybdMbx                                 const  024822 19
  isAlnum                                    code  fffc57e8 18
  isAlpha                                    code  fffc57b8 18
  isAlphaFalse                               code  fffc57e0 18
  isAlphaTrue                                code  fffc57d8 18
  isDigit                                    code  fffc5798 18
  isDigitFalse                               code  fffc57b0 18
  isDigitx                                   code  fffc57fc 18
  mbxs                                      const  020000 19
  mbxs_end                                  const  022000 19
  milliseconds                              const  014208 18
  missed_ticks                              const  024320 19
  msgBadGotoGosub                            code  fffc6a35 18
  msgBadKeybd                                code  800000000000028b 32
  msgBytesFree                               code  fffc696d 18
  msgCRLF                                    code  fffc0a6a 18
  msgComma                                   code  fffc6982 18
  msgDivZero                                 code  fffc6944 18
  msgEnvFail                                 code  fffc6a9d 18
  msgExtraChars                              code  fffc6a7b 18
  msgInf                                     code  fffc0e54 18
  msgInit                                    code  fffc68cc 18
  msgInputVar                                code  fffc69e4 18
  msgLineRange                               code  fffc6995 18
  msgMonHelp                                 code  fffc09bd 18
  msgNan                                     code  fffc0e58 18
  msgNextFor                                 code  fffc6a00 18
  msgNextVar                                 code  fffc6a12 18
  msgNumTooBig                               code  fffc6931 18
  msgParen                                   code  fffc6ab7 18
  msgRNDBad                                  code  fffc69c0 18
  msgReadError                               code  fffc6917 18
  msgReady                                   code  fffc697a 18
  msgReadyList                               code  fffc34dc 18
  msgRetWoGosub                              code  fffc6a51 18
  msgSYSBad                                  code  fffc69d3 18
  msgStart                                   code  fffc09a4 18
  msgTaskStart                               code  fffc0a5c 18
  msgTimeoutList                             code  fffc350d 18
  msgTooBig                                  code  fffc6a67 18
  msgVar                                     code  fffc69aa 18
  msgVarSpace                                code  fffc6956 18
  msgWhat                                    code  fffc6908 18
  msgs                                      const  010000 18
  nmeSerial                                  code  fffc1748 18
  prCRLF                                     code  fffc6388 18
  pword1                                     code  fffc55bc 18
  pword2                                     code  fffc55dc 18
  qToChk                                     code  fffc1e82 18
  return1                                    code  fffc4f98 18
  rnd1                                       code  fffc5db4 18
  rnd2                                       code  fffc5dc4 18
  switchflag                                const  014200 18
  sysx1                                      code  fffc56c0 18
  tah1                                       code  fffc5614 18
  toAsciiHex                                 code  fffc5604 18
  toUpper                                    code  fffc663c 18
  tstv_notfound                              code  fffc5ba4 18
  usrJmp                                    const  0300a0 19

Undefined Symbols
  A00000000000000                          rodata  8000000000000481 32
  AUXIN                                      code  80000000000002db 32
  AUXIN_INIT                                 code  80000000000003ae 32
  AUXOUT                                     code  80000000000002d9 32
  AUXOUT_FLUSH                               code  80000000000003bb 32
  AUXOUT_INIT                                code  80000000000003b2 32
  ERETx                                      code  8000000000000243 32
  FFFC0100                                   code  80000000000002cb 32
  FMTK_Initialize                            code  80000000000001bf 32
  FMTK_PostMsg                               code  80000000000001c7 32
  FMTK_SetTaskPriority                       code  80000000000001c3 32
  FMTK_StartApp                              code  80000000000001cb 32
  KEYBD                                      code  8000000000000284 32
  KeybdIRQ.notAlt                            code  800000000000029e 32
  KillTask                                   code  800000000000020c 32
  SDReadSector                               code  80000000000003af 32
  SDWriteSector                              code  80000000000003b4 32
  TCBKbdState2                               code  8000000000000299 32
  TCBVidMem                                  code  8000000000000212 32
  _ACBPtrs                                 rodata  000000 32
  _BIOS1_sema                              rodata  000000 32
  _BIOS_RespMbx                            rodata  000000 32
  _DeviceTable                             rodata  000000 32
  _DumpTaskList                            rodata  000000 32
  _EnableSprites                           rodata  000000 32
  _FMTK_Inited                             rodata  000000 32
  _FMTK_Reschedule                         rodata  000000 32
  _FMTK_SendMsg                            rodata  000000 32
  _FMTK_StartApp                           rodata  000000 32
  _FMTK_StartThread                        rodata  000000 32
  _FMTK_WaitMsg                            rodata  000000 32
  _FocusSwitcher                           rodata  000000 32
  _GetACBPtr                               rodata  000000 32
  _GetAppHandle                            rodata  000000 32
  _GetRand                                 rodata  fffc4124 32
  _GetRunningACBPtr                        rodata  000000 32
  _GetVecno                                rodata  000000 32
  _IOFocusNdx                              rodata  000000 32
  _IOFocusTbl                              rodata  000000 32
  _InsertIntoReadyList                     rodata  000000 32
  _InsertIntoTimeoutList                   rodata  000000 32
  _KeyLED                                  rodata  024826 32
  _KeyState1                               rodata  024824 32
  _KeyState2                               rodata  024825 32
  _KeybdClearRcv                           rodata  000000 32
  _KeybdGetScancode                        rodata  fffc3f08 32
  _KeybdGetStatus                          rodata  fffc3ee0 32
  _KeybdID                                   code  8000000000000291 32
  _KeybdSetLED                             rodata  fffc3d7c 32
  _LockIOFSemaphore                        rodata  000000 32
  _LockKbdSemaphore                        rodata  000000 32
  _LockSemaphore                           rodata  000000 32
  _LockSysSemaphore                        rodata  000000 32
  _RemoveFromReadyList                     rodata  000000 32
  _RemoveFromTimeoutList                   rodata  000000 32
  _RequestIOFocus                          rodata  000000 32
  _SetBound48                              rodata  000000 32
  _SetBound49                              rodata  000000 32
  _SetBound50                              rodata  000000 32
  _SetBound51                              rodata  000000 32
  _TimeoutList                             rodata  000000 32
  _bios_stacks                             rodata  000000 32
  _chkTCB                                  rodata  000000 32
  _cls                                       code  800000000000032b 32
  _fmtk_irq_stack                          rodata  000000 32
  _fmtk_sys_stack                          rodata  000000 32
  _freeMBX                                 rodata  000000 32
  _freeMSG                                 rodata  000000 32
  _freeTCB                                 rodata  000000 32
  _getCPU                                  rodata  000000 32
  _hFocusSwitchMbx                         rodata  000000 32
  _hasUltraHighPriorityTasks               rodata  000000 32
  _iof_sema                                rodata  000000 32
  _iof_switch                              rodata  000000 32
  _irq_stack                               rodata  000000 32
  _kbd_sema                                rodata  000000 32
  _keybdControlCodes                       rodata  fffc3a50 32
  _keybdExtendedCodes                      rodata  fffc3ad0 32
  _mailbox                                 rodata  000000 32
  _message                                 rodata  000000 32
  _missed_ticks                            rodata  000000 32
  _mmu_Alloc512kPage                       rodata  000000 32
  _mmu_Alloc8kPage                         rodata  000000 32
  _mmu_AllocateMap                         rodata  000000 32
  _mmu_Free512kPage                        rodata  000000 32
  _mmu_Free8kPage                          rodata  000000 32
  _mmu_FreeMap                             rodata  000000 32
  _mmu_MapCardMemory                       rodata  000000 32
  _mmu_SetAccessKey                        rodata  000000 32
  _mmu_SetMapEntry                         rodata  000000 32
  _mmu_SetOperateKey                       rodata  000000 32
  _mmu_alloc                               rodata  000000 32
  _mmu_free                                rodata  000000 32
  _nMailbox                                rodata  000000 32
  _nMsgBlk                                 rodata  000000 32
  _outb                                    rodata  000000 32
  _outc                                    rodata  000000 32
  _outh                                    rodata  000000 32
  _outw                                    rodata  000000 32
  _randStream                              rodata  024830 32
  _rdcf                                      code  800000000000032d 32
  _readyQ                                  rodata  000000 32
  _set_vector                              rodata  000000 32
  _shiftedScanCodes                        rodata  fffc3950 32
  _stacks                                  rodata  000000 32
  _sys_sema                                rodata  000000 32
  _sys_stacks                              rodata  000000 32
  _sysstack                                rodata  000000 32
  _tcbs                                    rodata  000000 32
  _unshiftedScanCodes                      rodata  fffc3850 32
  _video_bufs                              rodata  000000 32
  gen_rand                                   code  8000000000000400 32
  msgBadKeybd                                code  800000000000028b 32

  Macro Name
 mDispIRQLive                              -842150451

	ldo      $v0,$FFD00000+440
	add     	$v0,$v0,#1
	sto      $v0,$FFD00000+440

 mGetCurrentTid                            -842150451

	csrrw	v0,#$181,x0
	and		v0,v0,#MAX_TID

 mGetVideoPtr                              -842150451

	
	csrrw	v0,#$181,x0
	and		v0,v0,#MAX_TID
sll		$v0,$v0,#LOG_TCBSZ
	ldo		$v0,TCBpVideo[$v0]
	ldi		$v0,#$FFD00000

 mHasFocus                                 -842150451

	ldi		$a0,#20
	ecall

 mLockSysMutex                             -842150451

	
	csrrw	v0,#$181,x0
	and		v0,v0,#MAX_TID
sll		$v0,$v0,#1
	or		$v0,$v0,#1
	ldi		$t0,#$FFDBFF00
.lock@:
	sto		$v0,[$t0]
	ldo		$v1,[$t0]
	bne		$v0,$v1,.lock@

 mPopTimeoutList                           -842150451

	sll		$t0,$v0,#LOG_TCBSZ		; tid to pointer
	lbu		$v1,TCBStatus[$t0]		; no longer a waiting status
	and		$t1,$v1,#TS_WAITMSG		; check if waiting for a message
	beqz	$t1,.noWait@
	mMbxRemoveTask							; remove task from mailbox list
.noWait@:
	and		$v1,$v1,#~(TS_WAITMSG|TS_TIMEOUT)
	stb		$v1,TCBStatus[$t0]
	ldw		$v1,TCBNext[$t0]			; get next task on timeout list
	stw		$v1,TimeoutList				; update list head
	ldi		$t1,#NR_TCB						; check valid handle
	bgeu	$v1,$t1,.done@
	ldi		$t1,#-1								;
	sll		$v1,$v1,#LOG_TCBSZ		; v1 = tid to pointer
	stw		$t1,TCBPrev[$v1]			; TimeoutList->prev = -1
.done@:
	ldi		$t1,#-1								; reset next and prev indexes
	stw		$t1,TCBNext[$t0]			; on popped task
	stw		$t1,TCBPrev[$t0]

 mSleep                                    1

	ldi		$a0,#5
	ldi		$a1,#0
	ecall

 mUnlockSemaphore                          1

	ldi		v0,#-1
	sw		v0,0

 mWaitForFocus                             -842150451

.WFF1@:
	
	ldi		$a0,#20
	ecall
bne		v1,x0,.HasFocus@
	call	SerialPeekChar	;Direct
	ldi		a0,#$14							; CTRL-T
	bne		$v0,$a0,.WFF2@
	call	SerialGetChar
	ldi		$a0,#21							; switch IO Focus
	ecall
	bra		.WFF1@
.WFF2@:
	
	ldi		$a0,#5
	ldi		$a1,#1
	ecall

	bra		.WFF1@
.HasFocus@:

0 compressable instructions
The top 1024 are:
Comp  Opcode  Count
