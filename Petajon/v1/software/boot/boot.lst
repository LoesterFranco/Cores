                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/const.r5a",1
                        	.file "../fmtk/const.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	; First 256 bytes are for integer register set
                        	; Second 256 bytes are for float register set
                        	; Leave some room for 64-bit regs
                        	TCBsegs			EQU		$200		; segment register storage
                        	TCBepc			EQU		$280
                        	TCBStatus		EQU		$288
                        	TCBPriority	EQU		$289
                        	TCBContextSaved	EQU		$28A
                        	TCBWaitMbx	EQU		$28C
                        	TCBStackBot	EQU		$290
                        	TCBMsgD1		EQU		$298
                        	TCBMsgD2		EQU		$2A0
                        	TCBMsgD3		EQU		$2A8
                        	TCBStartTime	EQU		$2B0
                        	TCBEndTime		EQU		$2B8
                        	TCBElapsedTime		EQU		$2C0
                        	TCBException	EQU	$2C8
                        	TCBNext			EQU		$2D0
                        	TCBPrev			EQU		$2D8
                        	TCBTimeout	EQU		$2E0
                        	IOF_NEXT		EQU		$2E8
                        	IOF_PREV		EQU		$2F0
                        	TCBName			EQU		$2F8
                        	TCBKbdHead	EQU		$300
                        	TCBKbdTail	EQU		$301
                        	TCBKbdBuf		EQU		$308
                        	; 328 end of keyboard buffer
                        	TCBResource	EQU		$328
                        	TCBVideoMem	EQU		$330
                        	TCBpVideo		EQU		$338
                        	
                        	TS_NONE			EQU		0
                        	TS_READY		EQU		1
                        	TS_DEAD			EQU		2
                        	TS_MSGRDY		EQU		4
                        	TS_WAITMSG	EQU		8
                        	TS_TIMEOUT	EQU		16
                        	TS_PREEMPT	EQU		32
                        	TS_RUNNING	EQU		128
                        	
                        	; error codes
                        	E_Ok		=		0x00
                        	E_Arg		=		0x01
                        	E_BadMbx	=		0x04
                        	E_QueFull	=		0x05
                        	E_NoThread	=		0x06
                        	E_NotAlloc	=		0x09
                        	E_NoMsg		=		0x0b
                        	E_Timeout	=		0x10
                        	E_BadAlarm	=		0x11
                        	E_NotOwner	=		0x12
                        	E_QueStrategy =		0x13
                        	E_BadDevNum	=		0x18
                        	E_DCBInUse	=		0x19
                        	E_BadCallno	=  0x1A
                        	; Device driver errors
                        	E_BadDevNum	=		0x20
                        	E_NoDev		=		0x21
                        	E_BadDevOp	=		0x22
                        	E_ReadError	=		0x23
                        	E_WriteError =		0x24
                        	E_BadBlockNum	=	0x25
                        	E_TooManyBlocks	=	0x26
                        	
                        	; resource errors
                        	E_NoMoreMbx	=		0x40
                        	E_NoMoreMsgBlks	=	0x41
                        	E_NoMoreAlarmBlks	=0x44
                        	E_NoMoreTCBs	=	0x45
                        	E_NoMem		= 12
                        	
                        	CSR_REGSET	equ		$790
                        	SYS_MUTEX		equ		$FFDBFF00
                        	BIOS_MUTEX		equ		$FFDBFF08
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/config.r5a",1
                        	.file "../fmtk/config.r5a",1
                        	MAX_TID		EQU		31
                        	MAX_MID		EQU		31
                        	MAX_ASID	EQU		31
                        	NR_TCB		EQU		32
                        	NR_MBX		EQU		256
                        	NR_MSG		EQU		2048
                        	LOG_TCBSZ	EQU		10
                        	LOG_PGSZ	EQU		16
                        	PAGESZ		EQU		65536
                        	PAGES_PER_TASK	EQU		4096	; maximum number of pages per task
                        	PAGES_PER_MAP		EQU		4096
                        	OSPAGES		EQU		3			; pages of memory dedicated to OS
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/device.r5a",1
                        	.file "../fmtk/device.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2014-2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; DeviceDriver.inc
                        	; - Device driver structures and constants                                                                         
                        	; ============================================================================
                        	
                        	;	.global			; global constants
                        	
                        	; Device Control Block
                        	;
                        	DCB_Name			EQU		0		; string: first byte is length, 11 chars max
                        	DCB_Type			EQU		0x0C
                        	DCB_nBPB			EQU		0x10
                        	DCB_LastErc			EQU		0x18		; last error code
                        	DCB_StartBlock		EQU		0x20		; starting block number (partitioned devices)
                        	DCB_nBlocks			EQU		0x28		; number of blocks on device
                        	DCB_pCmdProc		EQU		0x30		; pointer to command processor routine
                        	DCB_ReentCount		EQU		0x38		; re-entrancy count (1 to 255)
                        	DCB_fSingleUser		EQU		0x39
                        	DCB_hJob			EQU		0x40		; handle to associated job
                        	DCB_Mbx				EQU		0x48
                        	DCB_pSema			EQU		0x50		; pointer to device semaphore
                        	DCB_Resv1			EQU		0x58		; reserved
                        	DCB_Resv2			EQU		0x60		; reserved
                        	DCB_Size			EQU		0x68
                        	
                        	; Device command opcodes
                        	;
                        	DVC_Nop				EQU		0
                        	DVC_Setup			EQU		1
                        	DVC_Initialize		EQU		2
                        	DVC_Status			EQU		3
                        	DVC_MediaCheck		EQU		4
                        	DVC_BuildBPB		EQU		5
                        	DVC_Open			EQU		6
                        	DVC_Close			EQU		7
                        	DVC_GetChar			EQU		8
                        	DVC_PeekChar		EQU		9
                        	DVC_GetCharDirect	EQU		10
                        	DVC_PeekCharDirect	EQU		11
                        	DVC_InputStatus		EQU		12
                        	DVC_PutChar			EQU		13
                        	DVC_SetPosition		EQU		15
                        	DVC_ReadBlock		EQU		16
                        	DVC_WriteBlock		EQU		17
                        	DVC_VerifyBlock		EQU		18
                        	DVC_OutputStatus	EQU		19
                        	DVC_FlushInput		EQU		20
                        	DVC_FlushOutput		EQU		21
                        	DVC_IRQ				EQU		22
                        	DVC_IsRemoveable	EQU		23
                        	DVC_IOCTRL_READ		EQU		24
                        	DVC_IOCTRL_WRITE	EQU		25
                        	DVC_OutputUntilBusy	EQU		26
                        	
                        	MAX_DEV_OP			EQU		31
                        	
                        	
                        	DRSP_DONE			EQU		1
                        	
                        	;Standard Devices are:
                        	
                        	;#		Device					Standard name
                        	
                        	;0		NULL device 			NUL		(OS built-in)
                        	;1		Keyboard (sequential)	KBD		(OS built-in)
                        	;2		Video (sequential)		VID		(OS built-in)
                        	;3		Printer (parallel 1)	LPT
                        	;4		Printer (parallel 2)	LPT2
                        	;5		RS-232 1				COM1	(OS built-in)
                        	;6		RS-232 2				COM2
                        	;7		RS-232 3				COM3
                        	;8		RS-232 4				COM4
                        	;9		Parallel xfer	  PTI
                        	;10		Floppy					FD0
                        	;11		Floppy					FD1
                        	;12		Hard disk				HD0
                        	;13		Hard disk				HD1
                        	;14
                        	;15
                        	;16		SDCard					CARD1 	(OS built-in)
                        	;17
                        	;18
                        	;19
                        	;20
                        	;21
                        	;22
                        	;23
                        	;24
                        	;25
                        	;26
                        	;27
                        	;28		Audio						PSG1	(OS built-in)
                        	;29
                        	;30   Random Number		PRNG
                        	;31		Debug						DBG
                        	
                        	NR_DCB			EQU		32
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/macro.r5a",1
                        	.file "../fmtk/macro.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	; macros have to be defined before they are encountered.
                        	
                        	; unlock the a semaphore	
                        	macro mUnlockSemaphore (adr)
	ldi		v0,#-1
	sw		v0,adr
endm
                        	
                        	; Look at the asid register for task id
                        	macro mGetCurrentTid
	csrrw	v0,#$181,x0
	and		v0,v0,#MAX_TID
endm
                        	
                        	macro	mHasFocus
	ldi		$a0,#20
	ecall
endm
                        	
                        	macro mSleep(tm)
	ldi		$a0,#5
	ldi		$a1,#tm
	ecall
endm
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	macro mWaitForFocus
.WFF1@:
	
	ldi		$a0,#20
	ecall
bne		v1,x0,.HasFocus@
	call	SerialPeekChar	;Direct
	ldi		a0,#$14							; CTRL-T
	bne		$v0,$a0,.WFF2@
	call	SerialGetChar
	ldi		$a0,#21							; switch IO Focus
	ecall
	bra		.WFF1@
.WFF2@:
	
	ldi		$a0,#5
	ldi		$a1,#1
	ecall

	bra		.WFF1@
.HasFocus@:
endm
                        	
                        	;------------------------------------------------------------------------------
                        	; Pop an entry off the timeout list. It is assumed the entry is popped when
                        	; its timeout reached zero. Hence there is no adjustment of the following
                        	; timeout made. Routine used only in the schedulerIRQ, so written as a macro.
                        	;
                        	; Parameters:
                        	;		v0 = top timeout list
                        	; Modifies:
                        	;		v1,t0,t1,t2,t3
                        	;	Returns:
                        	;		v0 = timeout list entry tid
                        	;------------------------------------------------------------------------------
                        	
                        	macro mPopTimeoutList
	sll		$t0,$v0,#LOG_TCBSZ		; tid to pointer
	lbu		$v1,TCBStatus[$t0]		; no longer a waiting status
	and		$t1,$v1,#TS_WAITMSG		; check if waiting for a message
	beqz	$t1,.noWait@
	mMbxRemoveTask							; remove task from mailbox list
.noWait@:
	and		$v1,$v1,#~(TS_WAITMSG|TS_TIMEOUT)
	stb		$v1,TCBStatus[$t0]
	ldw		$v1,TCBNext[$t0]			; get next task on timeout list
	stw		$v1,TimeoutList				; update list head
	ldi		$t1,#NR_TCB						; check valid handle
	bgeu	$v1,$t1,.done@
	ldi		$t1,#-1								;
	sll		$v1,$v1,#LOG_TCBSZ		; v1 = tid to pointer
	stw		$t1,TCBPrev[$v1]			; TimeoutList->prev = -1
.done@:
	ldi		$t1,#-1								; reset next and prev indexes
	stw		$t1,TCBNext[$t0]			; on popped task
	stw		$t1,TCBPrev[$t0]
endm
                        	
                        	
                        	macro mGetVideoPtr:
	
	csrrw	v0,#$181,x0
	and		v0,v0,#MAX_TID
sll		$v0,$v0,#LOG_TCBSZ
	ldo		$v0,TCBpVideo[$v0]
	ldi		$v0,#$FFD00000
endm
                        	
                        	macro mDispIRQLive
	ldo      $v0,$FFD00000+440
	add     	$v0,$v0,#1
	sto      $v0,$FFD00000+440
endm
                        	
                        	macro mLockSysMutex
	
	csrrw	v0,#$181,x0
	and		v0,v0,#MAX_TID
sll		$v0,$v0,#1
	or		$v0,$v0,#1
	ldi		$t0,#$FFDBFF00
.lock@:
	sto		$v0,[$t0]
	ldo		$v1,[$t0]
	bne		$v0,$v1,.lock@
endm
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/global.r5a",1
                        	.file "../fmtk/global.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	;
                        	; 00000000	+-----------------------------------
                        	;						| Task Control Blocks (64 x 1kB)
                        	; 00010000	+-----------------------------------
                        	;						| Message Array (2048 x 32b)
                        	; 00020000	+-----------------------------------
                        	;						| Mailbox Array (256 x 32b)
                        	; 00022000	+-----------------------------------
                        	;						| Device Control Blocks (32 x 256b)
                        	; 00024000	+-----------------------------------
                        	
                        	msgs		EQU		$10000
                        	mbxs		EQU		$20000
                        	mbxs_end	EQU	$22000
                        	; The following must be at least 256 byte aligned
                        	DVF_Base		EQU		$22000
                        	DVF_Limit		EQU		$24000
                        	QNDX		EQU		$24304
                        	READYQ	EQU		$24308
                        	PIDMAP	EQU		$24310
                        	missed_ticks	equ		$24320
                        	TimeoutList		equ		$24328
                        	Tick		EQU		$24330
                        	SysSema	EQU		$24340
                        	FreeMsg	EQU		$24350
                        	RDYQ0		EQU		$24400
                        	RDYQ1		EQU		$24500
                        	RDYQ2		EQU		$24600
                        	RDYQ3		EQU		$24700
                        	CursorX		equ		$24800
                        	CursorY		equ		$24801
                        	DispAttr	equ		$24808
                        	IOFocusNdx		EQU		$24810
                        	IOFocusTbl		EQU		$24818
                        	SwitchIOFocus	EQU		$24820
                        	hKeybdMbx	equ		$24822
                        	_KeyState1	equ		$24824
                        	_KeyState2 equ		$24825
                        	_KeyLED			equ		$24826
                        	NPAGES	equ		$24828
                        	_randStream	equ		$24830
                        	
                        	SerRcvBuf		EQU		$25000
                        	SerXmitBuf	EQU		$25400
                        	SerHeadRcv	EQU		$25800
                        	SerTailRcv	EQU		$25804
                        	SerHeadXmit	EQU		$25808
                        	SerTailXmit	EQU		$2580C
                        	SerRcvXon		EQU		$25810
                        	SerRcvXoff	EQU		$25811
                        	
                        	
                        	
                        	
                        	
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	
                        	CTRLC				equ		$03
                        	BS					equ		$08
                        	LNFD				equ		$0A
                        	CR					equ		$0D
                        	XON					equ		$11
                        	XOFF				equ		$13
                        	DEL					equ		$7F
                        	LEDS				equ		$FFDC0600
                        	BUTTONS			equ		$FFDC0600
                        	VIA					equ		$FFDC0600
                        	VIA_PA			equ		$04
                        	VIA_DDRA		equ		$0C
                        	VIA_T1CL		equ		$10
                        	VIA_T1CH		equ		$14
                        	VIA_ACR			equ		$2C
                        	VIA_PCR			equ		$30
                        	VIA_IFR			equ		$34
                        	VIA_IER			equ		$38
                        	VIA_PARAW		equ		$3C
                        	UART				equ		$FFDC0A00
                        	UART_TRB		equ		$00
                        	UART_STAT		equ		$04
                        	UART_CMD		equ		$08
                        			; First 16kB is for TCB's
                        	INBUF				equ		$14100
                        	switchflag	equ		$14200
                        	milliseconds	equ		$14208
                        	
                        	
                        	.file "boot.r5a",32
                        		code	18 bits
                        	;------------------------------------------------------------------------------
                        	; Exception vector table.
                        	;------------------------------------------------------------------------------
                        		org		$FFFC0000				; user mode exception
FFFC0000 1E10006F		jmp		IRQRout
FFFC0004 00000000		org		$FFFC0040				; supervisor mode exception (not possible)
FFFC0008 00000000
FFFC000C 00000000
FFFC0010 00000000
FFFC0014 00000000
FFFC0018 00000000
FFFC001C 00000000
FFFC0020 00000000
FFFC0024 00000000
FFFC0028 00000000
FFFC002C 00000000
FFFC0030 00000000
FFFC0034 00000000
FFFC0038 00000000
FFFC003C 00000000
FFFC0040 1A10006F		jmp		IRQRout
FFFC0044 00000000		org		$FFFC0080				; hypervisor mode exception (not possible)
FFFC0048 00000000
FFFC004C 00000000
FFFC0050 00000000
FFFC0054 00000000
FFFC0058 00000000
FFFC005C 00000000
FFFC0060 00000000
FFFC0064 00000000
FFFC0068 00000000
FFFC006C 00000000
FFFC0070 00000000
FFFC0074 00000000
FFFC0078 00000000
FFFC007C 00000000
FFFC0080 1610006F		jmp		IRQRout
FFFC0084 00000000		org 	$FFFC00C0				; machine mode exception
FFFC0088 00000000
FFFC008C 00000000
FFFC0090 00000000
FFFC0094 00000000
FFFC0098 00000000
FFFC009C 00000000
FFFC00A0 00000000
FFFC00A4 00000000
FFFC00A8 00000000
FFFC00AC 00000000
FFFC00B0 00000000
FFFC00B4 00000000
FFFC00B8 00000000
FFFC00BC 00000000
FFFC00C0 1210006F		jmp		IRQRout
FFFC00C4 00000000		org		$FFFC00FC				; non-maskable interrupt
FFFC00C8 00000000
FFFC00CC 00000000
FFFC00D0 00000000
FFFC00D4 00000000
FFFC00D8 00000000
FFFC00DC 00000000
FFFC00E0 00000000
FFFC00E4 00000000
FFFC00E8 00000000
FFFC00EC 00000000
FFFC00F0 00000000
FFFC00F4 00000000
FFFC00F8 00000000
FFFC00FC 0040006F		jmp		MachineStart
                        	
                        	;------------------------------------------------------------------------------
                        	; User mode code starts here
                        	;------------------------------------------------------------------------------
                        		org		$FFFC0100
                        	MachineStart:
FFFC0100 F1001673		csrrw	$s9,#$F10,$x0			; get hartid
FFFC0104 00061863		bnez	$s9,.hart20
FFFC0108 1FFFC737		ldi		$sp,#$1FFFBFF8		; setup machine mode stack pointer
FFFC010C FF870713
FFFC0110 00000663		bra		.hart00:
                        	.hart20:
FFFC0114 1FFF8737		ldi		$sp,#$1FFF7FF8
FFFC0118 FF870713
                        	.hart00:
FFFC011C FFFC0D37		ldi		$t0,#$FFFC0000
FFFC0120 000D0D13
FFFC0124 301D1073		csrrw $x0,#$301,$t0			; set tvec
                        		; The dram needs a bit of time before it's ready for access. along with
                        		; the video screen which also needs some time. So the first thing done is
                        		; to delay for about 3 seconds.
FFFC0128 04061263		bnez	$s9,.skipInit
FFFC012C FFDC0DB7		ldi		$t1,#VIA
FFFC0130 600D8D93
FFFC0134 0FF06D13		ldi		$t0,#$000000FF		; set via so we can see output on LEDs
FFFC0138 01ADA623		stt		$t0,VIA_DDRA[$t1]
FFFC013C 03938937		ldi		$a0,#60000000			; 3s in 50ns intervals
FFFC0140 70090913
FFFC0144 10300073		pfi
FFFC0148 7CC000EF		call	_MicroDelay
FFFC014C 655000EF		call	MMUInit					; initialize MMU for address space zero.
FFFC0150 7FD010EF		call	FMTKInit
FFFC0154 2AD010EF		call	VideoInit
FFFC0158 0D9010EF		call	ViaInit
FFFC015C 324010EF		call	SerialInit
FFFC0160 551030EF		call	_KeybdInit
FFFC0164 1E4010EF		call	PicInit
FFFC0168 1F8040EF		call	_PRNGInit
                        	.skipInit:
FFFC016C 10300073		pfi
FFFC0170 00006D13		ldi		$t0,#0
FFFC0174 181D1073		csrrw	$x0,#$181,$t0		; set ASID
FFFC0178 FFFC0D37		ldi		$t0,#UserStart
FFFC017C 18CD0D13
FFFC0180 341D1073		csrrw	$x0,#$341,$t0		; set mepc
FFFC0184 30047073		csrrc	$x0,#$300,#8		; disable interrupts (on eret)
FFFC0188 10000073		eret									; switch to user mode
                        	UserStart:
FFFC018C 00106913		ldi		$a0,#1
FFFC0190 000069B7		ldi		$a1,#24000
FFFC0194 DC098993
FFFC0198 FFFC0A37		ldi		$a2,#UserStart2
FFFC019C 1BCA0A13
FFFC01A0 00000073		ecall
FFFC01A4 00106913		ldi		$a0,#1					; start TinyBasic
FFFC01A8 000089B7		ldi		$a1,#32000
FFFC01AC D0098993
FFFC01B0 FFFC5A37		ldi		$a2,#CSTART
FFFC01B4 A30A0A13
FFFC01B8 00000073		ecall
                        	.0001:
                        	;	wfi
                        	;	bra		.0001
                        	UserStart2:
FFFC01BC AFFF8737		ldi		$sp,#$AFFF7FF8			; setup user mode stack pointer
FFFC01C0 FF870713
                        	UserStart2a:
                        	.loop:
FFFC01C4 00061063		bnez	$s9,.loop
                        	;	call	_SpriteDemo
FFFC01C8 03938937		ldi		$a0,#60000000				; 3s in 50ns intervals
FFFC01CC 70090913
FFFC01D0 10300073		pfi
FFFC01D4 740000EF		call	_MicroDelay
FFFC01D8 40006913		ldi		$a0,#$400						; clear screen
FFFC01DC 00000073		ecall
FFFC01E0 10300073		pfi
FFFC01E4 40106913		ldi		$a0,#$401						; home cursor
FFFC01E8 00000073		ecall
FFFC01EC 00E06913		ldi		$a0,#14							; Get current tid
FFFC01F0 00000073		ecall
FFFC01F4 10300073		pfi
FFFC01F8 0008E9B3		mov		$a1,$v1
FFFC01FC 01806913		ldi		$a0,#24							; RequestIOFocus
FFFC0200 00000073		ecall
                        	;	ldi		$sp,#$1FFF7FF8			; setup user mode stack pointer
                        	;	ldi		$sp,#$AFFFFFFC
FFFC0204 00406D13		ldi		$t0,#$04						; turn on the LED
FFFC0208 FFDC0637		stt		$t0,VIA+VIA_PARAW
FFFC020C 63C60613
FFFC0210 00060633
FFFC0214 01A62023
FFFC0218 01006E13		ldi		$t2,#16							; send an XON just in case
                        	;	ldi		$a3,#XON
                        	;.0004:
                        	;	call	SerialPutChar
                        	;	sub		$t2,$t2,#1
                        	;	bnez	$t2,.0004
                        	.0002:
                        	;	ldi		$a0,#msgStart				; spit out a startup message
                        	;	ldi		$t0,#$FFD00000
                        	;	ldo		$t1,datAttr
                        	.0005:
                        	;	ldbu	$a1,[$a0]
                        	;	add		$a0,$a0,#1
                        	;	beqz	$a1,.0004
                        	;	or		$a1,$a1,$t1
                        	;	sto		$a1,[$t0]
                        	;	add		$t0,$t0,#8
                        	;	bra		.0005
                        	.0004:
FFFC021C 10300073		pfi
FFFC0220 40306913		ldi		$a0,#$403						; video putstring()
FFFC0224 FFFC19B7		ldi		$a1,#msgStart
FFFC0228 AB898993
FFFC022C 00000073		ecall
                        	;		ldi		a0,#1
                        	;		ldi		a1,#24000
                        	;		ldi		a2,#Monitor
                        	;		ecall
FFFC0230 10300073		pfi
FFFC0234 00F06913		ldi		$a0,#15							; dump ready list
FFFC0238 00000073		ecall
FFFC023C 10000C63		bra		MonEntry
                        	
                        			; Now a loop to recieve and echo back characters
                        	.0003:
FFFC0240 48C010EF		call	SerialPeekChar
FFFC0244 FE084EE3		blt		$v0,$x0,.0003
FFFC0248 00086933		mov		$a0,$v0
FFFC024C 10300073		pfi
FFFC0250 540010EF		call	SerialPutChar
FFFC0254 FE0006E3		bra		.0003
                        	
                        		align	8                        	
                        	datAttr:
FFFC0258 001F0000		dco		$FFFF001F0000
FFFC025C 0000FFFF
                        	
                        		align	8                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	IdleTask:
FFFC0260 00000063		bra		IdleTask
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a character from input device. Checks for a CTRL-T which indicates to
                        	; switch the I/O focus.
                        	;
                        	; Parameters:
                        	;		none
                        	; Returns:
                        	;		v0 = character, -1 if none available
                        	;------------------------------------------------------------------------------
                        	
                        	Getch:
FFFC0264 FE870713		sub		$sp,$sp,#24
FFFC0268 00173023		sto		$ra,[$sp]
FFFC026C 01273423		sto		$a0,8[$sp]
FFFC0270 01373823		sto		$a1,16[$sp]
                        	;	mWaitForFocus
                        	;	call	SerialGetChar
FFFC0274 10300073		pfi
FFFC0278 00006913		ldi		$a0,#0					; don't block
FFFC027C 1E4040EF		call	_DBGGetKey
FFFC0280 00073083		ldo		$ra,[$sp]
FFFC0284 00873903		ldo		$a0,8[$sp]
FFFC0288 01073983		ldo		$a1,16[$sp]
FFFC028C 01870713		add		$sp,$sp,#24
FFFC0290 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	Putch:
FFFC0294 FA870713		sub		$sp,$sp,#88
FFFC0298 00173023		sto		$ra,[$sp]
FFFC029C 01073423		sto		$v0,8[$sp]
FFFC02A0 01573823		sto		$a3,16[$sp]
FFFC02A4 01173C23		sto		$v1,24[$sp]
FFFC02A8 03373023		sto		$a1,32[$sp]
FFFC02AC 03A73423		sto		$t0,40[$sp]
FFFC02B0 03B73823		sto		$t1,48[$sp]
FFFC02B4 03C73C23		sto		$t2,56[$sp]
FFFC02B8 05D73023		sto		$t3,64[$sp]
FFFC02BC 05E73423		sto		$t4,72[$sp]
FFFC02C0 05F73823		sto		$t5,80[$sp]
FFFC02C4 00096AB3		mov		$a3,$a0
                        	;	call	SerialPutChar
                        	;	call	VideoPutChar
FFFC02C8 10300073		pfi
FFFC02CC 40206913		ldi		$a0,#$402
FFFC02D0 00000073		ecall
                        	;	ldi		$a1,#5							; serial port = 5
                        	;	call	fputc
                        	;	ldi		$a1,#2							; video = 2
                        	;	call	fputc
FFFC02D4 00073083		ldo		$ra,[$sp]
FFFC02D8 00873803		ldo		$v0,8[$sp]
FFFC02DC 01073A83		ldo		$a3,16[$sp]
FFFC02E0 01873883		ldo		$v1,24[$sp]
FFFC02E4 02073983		ldo		$a1,32[$sp]
FFFC02E8 02873D03		ldo		$t0,40[$sp]
FFFC02EC 03073D83		ldo		$t1,48[$sp]
FFFC02F0 03873E03		ldo		$t2,56[$sp]
FFFC02F4 04073E83		ldo		$t3,64[$sp]
FFFC02F8 04873F03		ldo		$t4,72[$sp]
FFFC02FC 05073F83		ldo		$t5,80[$sp]
FFFC0300 05870713		add		$sp,$sp,#88
FFFC0304 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; fputc - put a character to an I/O device. If the task doesn't have the I/O
                        	; focus then it is rescheduled, allowing another task to run.
                        	;
                        	; Stack Space:
                        	;		6 words
                        	; Register Usage:
                        	;		a0 = FMTK_IO specify
                        	;		a2 = device putchar function
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a3 = character to put
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	fputc:
FFFC0308 FD070713		sub		$sp,$sp,#48
FFFC030C 00173023		sto		$ra,[$sp]
FFFC0310 01073423		sto		$v0,8[$sp]
FFFC0314 01273823		sto		$a0,16[$sp]
FFFC0318 01173C23		sto		$v1,24[$sp]
FFFC031C 03373023		sto		$a1,32[$sp]
FFFC0320 03473423		sto		$a2,40[$sp]
                        	;	mWaitForFocus
FFFC0324 10300073		pfi
FFFC0328 01A06913		ldi		$a0,#26							; FMTK_IO
FFFC032C 00D06A13		ldi		$a2,#13							; putchar function
FFFC0330 00000073		ecall
FFFC0334 00073083		ldo		$ra,[$sp]
FFFC0338 00873803		ldo		$v0,8[$sp]
FFFC033C 01073903		ldo		$a0,16[$sp]
FFFC0340 01873883		ldo		$v1,24[$sp]
FFFC0344 02073983		ldo		$a1,32[$sp]
FFFC0348 02873A03		ldo		$a2,40[$sp]
FFFC034C 03070713		add		$sp,$sp,#48
FFFC0350 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	MonEntry:
                        	;		flw			$f2,fltTen
                        	;		fsw			$f2,f2Save
                        	;		flw			$f1,fltTen
                        	;		fsw			$f1,f1Save
                        	;		fadd		$f18,$f2,$f1
                        	;		fsw			$f18,f18Save
FFFC0354 00A06913			ldi		$a0,#10
FFFC0358 00606A13			ldi		$a2,#6
                        	;		call	fltToString
                        	;		ldi		$a0,#STRTMP
                        	;		call	PutString
                        	
                        	Monitor:
FFFC035C B0000737		ldi		$sp,#$AFFFFFFC
FFFC0360 FFC70713
FFFC0364 10300073		pfi
                        	;		call	DumpReadyList
                        	;		call	DumpTimeoutList
FFFC0368 00006213		ldi		$s1,#0					; s1 = input pointer
FFFC036C 00D06913		ldi		$a0,#CR
FFFC0370 F25FF0EF		call	Putch
FFFC0374 10300073		pfi
FFFC0378 00A06913		ldi		$a0,#LNFD
FFFC037C F19FF0EF		call	Putch
FFFC0380 03E06913		ldi		$a0,#'>'
FFFC0384 F11FF0EF		call	Putch
                        	.0001:
FFFC0388 10300073		pfi
FFFC038C ED9FF0EF		call	Getch						; wait until character pressed
FFFC0390 FE084CE3		blt		$v0,$x0,.0001
FFFC0394 00A84D13		xor		$t0,$v0,#LNFD			; ignore line feed
FFFC0398 100D0663		beq		$t0,$x0,.procLine
FFFC039C 00D84D13		xor		$t0,$v0,#CR
FFFC03A0 100D0263		beq		$t0,$x0,.procLine
FFFC03A4 00884D13		xor		$t0,$v0,#BS
FFFC03A8 080D0863		beq		$t0,$x0,.doBackspace
FFFC03AC 10300073		pfi
FFFC03B0 07F84D13		xor		$t0,$v0,#DEL
FFFC03B4 020D0263		beq		$t0,$x0,.doDelete
FFFC03B8 00014637		sb		$v0,INBUF[$s1]
FFFC03BC 10060613
FFFC03C0 00460633
FFFC03C4 01060023
FFFC03C8 00120213		add		$s1,$s1,#1
FFFC03CC 00086933		mov		$a0,$v0
FFFC03D0 EC5FF0EF		call	Putch
FFFC03D4 FA000AE3		bra		.0001
                        	.doDelete:
FFFC03D8 10300073		pfi
FFFC03DC 000262B3		mov		$s2,$s1
FFFC03E0 00128293		add		$s2,$s2,#1
                        	.0002:
FFFC03E4 10300073		pfi
FFFC03E8 00014637		lb		$t0,INBUF[$s2]
FFFC03EC 10060613
FFFC03F0 00560633
FFFC03F4 00060D03
FFFC03F8 00014637		sb		$t0,INBUF-1[$s2]
FFFC03FC 0FF60613
FFFC0400 00560633
FFFC0404 01A60023
FFFC0408 00128293		add		$s2,$s2,#1
FFFC040C 00014637		add		$t0,$s2,#INBUF
FFFC0410 10060613
FFFC0414 00560D33
FFFC0418 00014637		slt		$t0,$t0,#INBUF+$7F
FFFC041C 17F60613
FFFC0420 FC0D12E3		bne		$t0,$x0,.0002
FFFC0424 00014637		sb		$x0,INBUF[$s2]
FFFC0428 10060613
FFFC042C 00560633
FFFC0430 00060023
FFFC0434 F4000AE3		bra		.0001
                        	.doBackspace:
FFFC0438 10300073		pfi
FFFC043C F40206E3		beq		$s1,$x0,.0001		; can't backspace anymore
FFFC0440 00086933		mov		$a0,$v0					; show the backspace
FFFC0444 E51FF0EF		call	Putch
FFFC0448 FFF20213		sub		$s1,$s1,#1
FFFC044C 000262B3		mov		$s2,$s1
                        	.0003:
FFFC0450 10300073		pfi
FFFC0454 00014637		lb		$t0,INBUF+1[$s2]
FFFC0458 10160613
FFFC045C 00560633
FFFC0460 00060D03
FFFC0464 00014637		sb		$t0,INBUF[$s2]
FFFC0468 10060613
FFFC046C 00560633
FFFC0470 01A60023
FFFC0474 00128293		add		$s2,$s2,#1
FFFC0478 00014637		add		$t0,$s2,#INBUF
FFFC047C 10060613
FFFC0480 00560D33
FFFC0484 00014637		slt		$t0,$t0,#INBUF+$7F
FFFC0488 17F60613
FFFC048C FC0D12E3		bne		$t0,$x0,.0003
FFFC0490 00014637		sb		$x0,INBUF[$s2]
FFFC0494 10060613
FFFC0498 00560633
FFFC049C 00060023
FFFC04A0 EE0004E3		bra		.0001
                        	.procLine:
FFFC04A4 10300073		pfi
FFFC04A8 00014637		sb		$x0,INBUF[$s1]
FFFC04AC 10060613
FFFC04B0 00460633
FFFC04B4 00060023
FFFC04B8 00006213		ldi		$s1,#0
                        	.skip:
FFFC04BC 10300073		pfi
FFFC04C0 00014637		lb		$t0,INBUF[$s1]
FFFC04C4 10060613
FFFC04C8 00460633
FFFC04CC 00060D03
FFFC04D0 140D0063		beq		$t0,$x0,.0005
FFFC04D4 03ED4D93		xor		$t1,$t0,#'>'
FFFC04D8 000D9863		bne		$t1,$x0,.0004
                        	.skip2:
FFFC04DC 10300073		pfi
FFFC04E0 00120213		add		$s1,$s1,#1
FFFC04E4 FC000CE3		bra		.skip
                        	.0004:
FFFC04E8 10300073		pfi
FFFC04EC 020D4D93		xor		$t1,$t0,#' '
FFFC04F0 FE0D86E3		beq		$t1,$x0,.skip2
FFFC04F4 009D4D93		xor		$t1,$t0,#'\t'
FFFC04F8 FE0D82E3		beq		$t1,$x0,.skip2
FFFC04FC 04DD4D93		xor		$t1,$t0,#'M'
FFFC0500 100D8A63		beq		$t1,$x0,doMem
FFFC0504 10300073		pfi
FFFC0508 04206D93		ldi		$t1,#'B'
FFFC050C 05BD1A63		bne		$t0,$t1,.0006
FFFC0510 00106913		ldi		$a0,#1					; Start task
FFFC0514 000089B7		ldi		$a1,#32000			; 32 kB
FFFC0518 D0098993
FFFC051C FFFC5A37		ldi		$a2,#CSTART			; start address
FFFC0520 A30A0A13
FFFC0524 00000073		ecall
FFFC0528 10300073		pfi
FFFC052C 0008E233		mov		$s1,$v1					; save v1
FFFC0530 FFFC1937		ldi		$a0,#msgCRLF
FFFC0534 B8A90913
FFFC0538 3A4000EF		call	PutString
FFFC053C 10300073		pfi
FFFC0540 00026933		mov		$a0,$s1					; get back v1
FFFC0544 328000EF		call	PutHexByte
FFFC0548 FFFC1937		ldi		$a0,#msgTaskStart
FFFC054C B7C90913
FFFC0550 10300073		pfi
FFFC0554 388000EF		call	PutString
FFFC0558 058030EF		call  DumpReadyList
                        		;ldi		$a0,#5					; Reschedule task
                        		;ldi		$a1,#1					; sleep(0)
                        		;ecall
FFFC055C E01FF06F		jmp		Monitor
                        	.0006:
FFFC0560 10300073		pfi
FFFC0564 04406D93		ldi		$t1,#'D'
FFFC0568 03BD1863		bne		$t0,$t1,.0007
FFFC056C 00014637		lb		$t0,INBUF+1[$s1]
FFFC0570 10160613
FFFC0574 00460633
FFFC0578 00060D03
FFFC057C 05406D93		ldi		$t1,#'T'
FFFC0580 01BD1663		bne		$t0,$t1,.noT
FFFC0584 11C030EF		call	DumpTimeoutList
FFFC0588 DD5FF06F		jmp		Monitor
                        	.noT:
FFFC058C 10300073		pfi
FFFC0590 020030EF		call 	DumpReadyList
                        		;ldi		$a0,#15
                        		;ecall
FFFC0594 DC9FF06F		jmp		Monitor
                        	.0007:
FFFC0598 10300073		pfi
FFFC059C 04506D93		ldi		$t1,#'E'
FFFC05A0 01BD1463		bne		$t0,$t1,.0008
FFFC05A4 1140006F		jmp		EditMem
                        	.0008:
FFFC05A8 10300073		pfi
FFFC05AC 04606D93		ldi		$t1,#'F'
FFFC05B0 01BD1463		bne		$t0,$t1,.0009
FFFC05B4 1240006F		jmp		FillMem
                        	.0009:
FFFC05B8 10300073		pfi
FFFC05BC 05306D93		ldi		$t1,#'S'
FFFC05C0 01BD1A63		bne		$t0,$t1,.0010
FFFC05C4 00506913		ldi		$a0,#5					; sleep(0)
FFFC05C8 00106993		ldi		$a1,#1
FFFC05CC 00000073		ecall
FFFC05D0 D8DFF06F		jmp		Monitor
                        	.0010:
FFFC05D4 10300073		pfi
FFFC05D8 04B06D93		ldi		$t1,#'K'
FFFC05DC 01BD1C63		bne		$t0,$t1,.0011
FFFC05E0 168000EF		call	GetHexNum
FFFC05E4 00306913		ldi		$a0,#3					; kill task
FFFC05E8 000869B3		mov		$a1,$v0					; a0 = pid
FFFC05EC 00000073		ecall
FFFC05F0 D6DFF06F		jmp		Monitor
                        	.0011:
FFFC05F4 10300073		pfi
FFFC05F8 03F06D93		ldi		$t1,#'?'
FFFC05FC 01BD1A63		bne		$t0,$t1,.0012
FFFC0600 FFFC1937		ldi		$a0,#msgMonHelp
FFFC0604 AD290913
FFFC0608 2D4000EF		call	PutString
FFFC060C D51FF06F		jmp		Monitor
                        	.0012:
                        	.0005:
FFFC0610 D40006E3		bra		Monitor
                        	
                        	doMem:
FFFC0614 FF870713		sub		$sp,$sp,#8
FFFC0618 00120213		add		$s1,$s1,#1
FFFC061C 00473023		sto		$s1,[$sp]
FFFC0620 10300073		pfi
FFFC0624 00D06913		ldi		$a0,#CR
FFFC0628 C6DFF0EF		call	Putch
FFFC062C 00014937		ldi		$a0,INBUF
FFFC0630 10090913
FFFC0634 10300073		pfi
FFFC0638 2A4000EF		call	PutString
FFFC063C 00073203		ldo		$s1,[$sp]
FFFC0640 00870713		add		$sp,$sp,#8
FFFC0644 10300073		pfi
FFFC0648 100000EF		call	GetHexNum
FFFC064C 00086333		mov		$s3,$v0
FFFC0650 00120213		add		$s1,$s1,#1
FFFC0654 10300073		pfi
FFFC0658 0F0000EF		call	GetHexNum
FFFC065C 006803B3		add		$s4,$v0,$s3
                        	.loop2:
FFFC0660 10300073		pfi
FFFC0664 C01FF0EF		call	Getch						; check for ctrl-c
FFFC0668 00384813		xor		$v0,$v0,#3
FFFC066C CE0808E3		beq		$v0,$x0,Monitor
FFFC0670 00D06913		ldi		$a0,#CR
FFFC0674 C21FF0EF		call	Putch
FFFC0678 00036933		mov		$a0,$s3
FFFC067C 10300073		pfi
FFFC0680 1A4000EF		call	PutHexWord
FFFC0684 03A06913		ldi		$a0,#':'
FFFC0688 C0DFF0EF		call	Putch
FFFC068C 00706293		ldi		$s2,#7
                        	.loop:
FFFC0690 02006913		ldi		$a0,#' '
FFFC0694 C01FF0EF		call	Putch
FFFC0698 00030903		ldb		$a0,[$s3]
FFFC069C 10300073		pfi
FFFC06A0 1CC000EF		call	PutHexByte
FFFC06A4 00130313		add		$s3,$s3,#1
FFFC06A8 FFF28293		sub		$s2,$s2,#1
FFFC06AC FE02D2E3		bge		$s2,$x0,.loop
FFFC06B0 FA7368E3		bltu	$s3,$s4,.loop2
FFFC06B4 CA0004E3		bra		Monitor		
                        	
                        	EditMem:
FFFC06B8 10300073		pfi
FFFC06BC 08C000EF		call	GetHexNum			; get address to edit
FFFC06C0 00086333		mov		$s3,$v0
FFFC06C4 00120213		add		$s1,$s1,#1
FFFC06C8 10300073		pfi
FFFC06CC 07C000EF		call	GetHexNum			; get value to set
FFFC06D0 00680023		stb		$s3,[$v0]			; update mem
FFFC06D4 C89FF06F		jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	;	>F 1000 800 EE
                        	; Fills memory beginning at address $1000 for $800 bytes with the value $EE
                        	;------------------------------------------------------------------------------
                        	
                        	FillMem:
FFFC06D8 10300073		pfi
FFFC06DC 06C000EF		call	GetHexNum			; get address
FFFC06E0 00086333		mov		$s3,$v0
FFFC06E4 00120213		add		$s1,$s1,#1
FFFC06E8 10300073		pfi
FFFC06EC 05C000EF		call	GetHexNum			; get length
FFFC06F0 000863B3		mov		$s4,$v0
FFFC06F4 00120213		add		$s1,$s1,#1
FFFC06F8 10300073		pfi
FFFC06FC 04C000EF		call	GetHexNum			; get byte to use
                        	.0001:
FFFC0700 01030023		stb		$v0,[$s3]
FFFC0704 FFF38393		sub		$s4,$s4,#1
FFFC0708 10300073		pfi
FFFC070C FE704AE3		bgt		$s4,$x0,.0001
FFFC0710 C4DFF06F		jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; Skip over spaces and tabs in the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	SkipSpaces:
                        	.skip2:
FFFC0714 10300073		pfi
FFFC0718 00014637		ldb		$t0,INBUF[$s1]
FFFC071C 10060613
FFFC0720 00460633
FFFC0724 00060D03
FFFC0728 020D4D93		xor		$t1,$t0,#' '
FFFC072C 000D8863		beq		$t1,$x0,.skip1
FFFC0730 009D4D93		xor		$t1,$t0,#'\t'
FFFC0734 000D8463		beq		$t1,$x0,.skip1
FFFC0738 00008067		ret
                        	.skip1:
FFFC073C 00120213		add		$s1,$s1,#1
FFFC0740 10300073		pfi
FFFC0744 FC0008E3		bra		.skip2
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a hex number from the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	GetHexNum:
FFFC0748 00006813		ldi		$v0,#0							; v0 = num
FFFC074C FF870713		sub		$sp,$sp,#8
FFFC0750 00173023		sto		$ra,[$sp]
FFFC0754 10300073		pfi
FFFC0758 FBDFF0EF		call	SkipSpaces
                        	.next:
FFFC075C 00014637		ldb		$t0,INBUF[$s1]
FFFC0760 10060613
FFFC0764 00460633
FFFC0768 00060D03
FFFC076C 03006E13		ldi		$t2,#'0'
FFFC0770 03CD4863		blt		$t0,$t2,.0001
FFFC0774 03A06E13		ldi		$t2,#'9'+1
FFFC0778 07CD4863		blt		$t0,$t2,.isDigit
FFFC077C 10300073		pfi
FFFC0780 04106E13		ldi		$t2,#'A'
FFFC0784 01CD4E63		blt		$t0,$t2,.0001
FFFC0788 04706E13		ldi		$t2,#'F'+1
FFFC078C 03CD4263		blt		$t0,$t2,.isHexUpper
FFFC0790 06106E13		ldi		$t2,#'a'
FFFC0794 01CD4663		blt		$t0,$t2,.0001
FFFC0798 06706E13		ldi		$t2,#'f'+1
FFFC079C 03CD4863		blt		$t0,$t2,.isHexLower
                        	.0001:
FFFC07A0 10300073		pfi
FFFC07A4 00073083		ldo		$ra,[$sp]
FFFC07A8 00870713		add		$sp,$sp,#8
FFFC07AC 00008067		ret
                        	.isHexUpper:
FFFC07B0 10300073		pfi
FFFC07B4 00481813		sll		$v0,$v0,#4
FFFC07B8 FBFD0D13		sub		$t0,$t0,#'A'
FFFC07BC 00AD0D13		add		$t0,$t0,#10
FFFC07C0 01A86833		or		$v0,$v0,$t0
FFFC07C4 00120213		add		$s1,$s1,#1
FFFC07C8 F8000AE3		bra		.next
                        	.isHexLower:
FFFC07CC 10300073		pfi
FFFC07D0 00481813		sll		$v0,$v0,#4
FFFC07D4 F9FD0D13		sub		$t0,$t0,#'a'
FFFC07D8 00AD0D13		add		$t0,$t0,#10
FFFC07DC 01A86833		or		$v0,$v0,$t0
FFFC07E0 00120213		add		$s1,$s1,#1
FFFC07E4 F6000CE3		bra		.next
                        	.isDigit:
FFFC07E8 10300073		pfi
FFFC07EC 00481813		sll		$v0,$v0,#4
FFFC07F0 FD0D0D13		sub		$t0,$t0,#'0'
FFFC07F4 01A86833		or		$v0,$v0,$t0
FFFC07F8 00120213		add		$s1,$s1,#1
FFFC07FC F60000E3		bra		.next
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a word as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexDword:
FFFC0800 FF070713		sub		$sp,$sp,#16
FFFC0804 00173023		sto		$ra,[$sp]
FFFC0808 01273423		sto		$a0,8[$sp]
FFFC080C 10300073		pfi
FFFC0810 00095913		srl		$a0,$a0,#32
FFFC0814 010000EF		call	PutHexWord
FFFC0818 00073083		ldo		$ra,[$sp]
FFFC081C 00873903		ldo		$a0,8[$sp]
FFFC0820 01070713		add		$sp,$sp,#16	; fall through to PutHexWord
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a word as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexWord:
FFFC0824 FF070713		sub		$sp,$sp,#16
FFFC0828 00173023		sto		$ra,[$sp]
FFFC082C 01273423		sto		$a0,8[$sp]
FFFC0830 10300073		pfi
FFFC0834 01095913		srl		$a0,$a0,#16
FFFC0838 010000EF		call	PutHexHalf
FFFC083C 00073083		ldo		$ra,[$sp]
FFFC0840 00873903		ldo		$a0,8[$sp]
FFFC0844 01070713		add		$sp,$sp,#16	; fall through to PutHexHalf
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a half-word (16 bits) as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexHalf:
FFFC0848 FF070713		sub		$sp,$sp,#16
FFFC084C 00173023		sto		$ra,[$sp]
FFFC0850 01273423		sto		$a0,8[$sp]
FFFC0854 10300073		pfi
FFFC0858 00895913		srl		$a0,$a0,#8
FFFC085C 010000EF		call	PutHexByte
FFFC0860 00073083		ldo		$ra,[$sp]
FFFC0864 00873903		ldo		$a0,8[$sp]		
FFFC0868 01070713		add		$sp,$sp,#16	; fall through to PutHexByte
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a byte as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexByte:
FFFC086C FF070713		sub		$sp,$sp,#16
FFFC0870 00173023		sto		$ra,[$sp]
FFFC0874 01273423		sto		$a0,8[$sp]
FFFC0878 10300073		pfi
FFFC087C 00495913		srl		$a0,$a0,#4		; put the high order nybble first
FFFC0880 010000EF		call	PutHexNybble
FFFC0884 00073083		ldo		$ra,[$sp]
FFFC0888 00873903		ldo		$a0,8[$sp]
FFFC088C 01070713		add		$sp,$sp,#16		; fall through to PutHexNybble
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a nybble as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexNybble:
FFFC0890 FF070713		sub		$sp,$sp,#16
FFFC0894 00173023		sto		$ra,[$sp]
FFFC0898 01273423		sto		$a0,8[$sp]
FFFC089C 10300073		pfi
FFFC08A0 00F97913		and		$a0,$a0,#15		; strip off high order bits
FFFC08A4 00A06D13		ldi		$t0,#10
FFFC08A8 10300073		pfi
FFFC08AC 01A94A63		blt		$a0,$t0,.lt10
FFFC08B0 FF690913		sub		$a0,$a0,#10
FFFC08B4 04190913		add		$a0,$a0,#'A'
FFFC08B8 9DDFF0EF		call	Putch
FFFC08BC 00000863		bra		.0001
                        	.lt10:
FFFC08C0 10300073		pfi
FFFC08C4 03090913		add		$a0,$a0,#'0'
FFFC08C8 9CDFF0EF		call	Putch
                        	.0001:
FFFC08CC 00073083		ldo		$ra,[$sp]
FFFC08D0 00873903		ldo		$a0,8[$sp]
FFFC08D4 01070713		add		$sp,$sp,#16
FFFC08D8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; PutString
                        	;    Put a string of characters to output device. Calls the 
                        	; Putch routine, so this routine also blocks if the transmitter is not
                        	; empty.
                        	;
                        	; Parameters:
                        	;		$a0 = pointer to null terminated string to put
                        	; Modifies:
                        	;		$t0 and $t1
                        	; Stack Space:
                        	;		2 words
                        	;------------------------------------------------------------------------------
                        	
                        	PutString:
FFFC08DC FF070713		sub		$sp,$sp,#16				; save link register
FFFC08E0 00173023		sto		$ra,[$sp]
FFFC08E4 01273423		sto		$a0,8[$sp]				; and argument
FFFC08E8 00096DB3		mov		$t1,$a0						; t1 = pointer to string
                        	.0001:
FFFC08EC 000DC903		ldbu	$a0,[$t1]
FFFC08F0 001D8D93		add		$t1,$t1,#1				; advance pointer to next byte
FFFC08F4 00090863		beqz	$a0,.done			; branch if done
FFFC08F8 10300073		pfi
FFFC08FC 999FF0EF		call	Putch							; output character
FFFC0900 FE0006E3		bra		.0001
                        	.done:
FFFC0904 00073083		ldo		$ra,[$sp]					; restore return address
FFFC0908 00873903		ldo		$a0,8[$sp]				; and argument
FFFC090C 01070713		add		$sp,$sp,#16
FFFC0910 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; MicroDelay - delay for a few clock ticks
                        	;
                        	; Parameters:
                        	;		a0 = wait in ticks (50 ns intervals)
                        	;------------------------------------------------------------------------------
                        	
                        	_MicroDelay:
FFFC0914 C0001EF3		csrrw	$t3,#$C00,$x0
                        	.0001:
FFFC0918 C0001F73		csrrw	$t4,#$C00,$x0
FFFC091C 41DF0F33		sub		$t4,$t4,$t3
FFFC0920 011F5F93		srl		$t5,$t4,#17
FFFC0924 FFDC0637		stt		$t5,VIA+VIA_PARAW
FFFC0928 63C60613
FFFC092C 00060633
FFFC0930 01F62023
FFFC0934 10300073		pfi
FFFC0938 012F2F33		slt		$t4,$t4,$a0
FFFC093C FC0F1EE3		bnez	$t4,.0001
FFFC0940 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	DumpMemmap:
FFFC0944 FE870713		sub			$sp,$sp,#24
FFFC0948 00173023		sto			$ra,[$sp]
FFFC094C 01073823		sto			$v0,16[$sp]
FFFC0950 10300073		pfi
                        		;mGetCurrentTid
FFFC0954 00096833		mov			$v0,$a0
FFFC0958 01081D93		sll			$t1,$v0,#16
                        	.again:
FFFC095C 10300073		pfi
FFFC0960 000DE933		mov			$a0,$t1
FFFC0964 01B73423		sto			$t1,8[$sp]
FFFC0968 EBDFF0EF		call		PutHexWord
FFFC096C 02006913		ldi			$a0,#' '
FFFC0970 925FF0EF		call		Putch
FFFC0974 03B0090D		mvmap		$a0,$x0,$t1
FFFC0978 ED1FF0EF		call		PutHexHalf
FFFC097C 00D06913		ldi			$a0,#CR
FFFC0980 10300073		pfi
FFFC0984 911FF0EF		call		Putch
FFFC0988 00A06913		ldi			$a0,#LNFD
FFFC098C 909FF0EF		call		Putch
FFFC0990 10300073		pfi
FFFC0994 00873D83		ldo			$t1,8[$sp]
FFFC0998 001D8D93		add			$t1,$t1,#1
FFFC099C 00FDFD13		and			$t0,$t1,#$F
FFFC09A0 FA0D1EE3		bnez		$t0,.again
FFFC09A4 00001637		or			$t1,$t1,#$FFF
FFFC09A8 FFF60613
FFFC09AC 01B66DB3
FFFC09B0 10300073		pfi
FFFC09B4 03B0090D		mvmap		$a0,$x0,$t1
FFFC09B8 E91FF0EF		call		PutHexHalf
FFFC09BC 00D06913		ldi			$a0,#CR
FFFC09C0 8D5FF0EF		call		Putch
FFFC09C4 00A06913		ldi			$a0,#LNFD
FFFC09C8 10300073		pfi
FFFC09CC 8C9FF0EF		call		Putch
FFFC09D0 00073083		ldo			$ra,[$sp]
FFFC09D4 01073803		ldo			$v0,16[$sp]
FFFC09D8 01870713		add			$sp,$sp,#24
FFFC09DC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Exception processing code starts here.
                        	; As per the RISCV privilege spec, the MSB indicates an external interrupt.
                        	; The system uses cause codes 32 to 63 for external devices. This cause code
                        	; range is reserved in the RISCV spec.
                        	;------------------------------------------------------------------------------
                        	.file "boot.r5a",792
                        		code
                        		align	4                        	
                        	IRQRout:
FFFC09E0 790FED73		csrrs	$t0,#CSR_REGSET,#$1F	; get regset,  ensure current regset is selected for all
FFFC09E4 014D5D13		srl		$t0,$t0,#20
FFFC09E8 003D7D13		and		$t0,$t0,#3
FFFC09EC 00AD1D13		sll		$t0,$t0,#10				; 1k stack area
FFFC09F0 20000737		ldi		$sp,#$20000000-8	; setup machine mode stack pointer (top of ram)
FFFC09F4 FF870713
FFFC09F8 41A70733		sub		$sp,$sp,$t0				; set stack pointer for register set
FFFC09FC 34201D73		csrrw	$t0,#$342,$x0			; get cause code
FFFC0A00 000D4C63		blt		$t0,$x0,.isIRQ		; irq or ecall?
FFFC0A04 00806D93		ldi		$t1,#8
FFFC0A08 0BBD6263		bltu	$t0,$t1,.cause0to7
FFFC0A0C 00B06D93		ldi		$t1,#11
FFFC0A10 09ADEE63		bgtu	$t0,$t1,.cause12plus
FFFC0A14 3490106F		jmp		OSCALL						; goto operating system call dispatcher
                        	.isIRQ:
FFFC0A18 FFD00637		ldo		$v0,$FFD00000+432	; Display IRQ live indicator
FFFC0A1C 1B060613
FFFC0A20 00060633
FFFC0A24 00063803
FFFC0A28 00010637		add		$v0,$v0,#$10001
FFFC0A2C 00160613
FFFC0A30 01060833
FFFC0A34 FFD00637		sto		$v0,$FFD00000+432
FFFC0A38 1B060613
FFFC0A3C 00060633
FFFC0A40 01063023
FFFC0A44 792168F3		csrrs	$v1,#$792,#2			; check and set interrupt semaphore
FFFC0A48 0028F893		and		$v1,$v1,#2
FFFC0A4C 00088463		beqz	$v1,.doIRQ
FFFC0A50 10000073		eret
                        	.doIRQ:
FFFC0A54 01FD7D93		and		$t1,$t0,#31				; interrupting device # is low order 5 bits of cause code
FFFC0A58 008D9D93		sll		$t1,$t1,#8				; 256 bytes per device func table
FFFC0A5C 00022637		add		$t1,$t1,#DVF_Base+22*8	; load IRQ routine vector from device func table
FFFC0A60 0B060613
FFFC0A64 01B60DB3
FFFC0A68 000DBD83		ldo		$t1,[$t1]
FFFC0A6C 000D8463		beq		$t1,$x0,.noIRQ		; make sure there's an address to go to
FFFC0A70 000D8067		jmp		[$t1]							; call to the IRQ routine
                        	.noIRQ:
                        		; For now, clear all interrupt sources
                        		; Otherwise the system will hang on an unknown interrupt.
FFFC0A74 FFDC0637		stt		$t0,VIA+VIA_PARAW
FFFC0A78 63C60613
FFFC0A7C 00060633
FFFC0A80 01A62023
FFFC0A84 FFDC1637		ldt		$a1,UART+UART_TRB		; get data from Rx buffer to clear interrupt
FFFC0A88 A0060613
FFFC0A8C 00060633
FFFC0A90 00062983
FFFC0A94 FFDC0637		ldt		$t0,VIA+VIA_T1CL		; clear interrupt
FFFC0A98 61060613
FFFC0A9C 00060633
FFFC0AA0 00062D03
FFFC0AA4 79217073		csrrc	$x0,#$792,#2			; clear interrupt semaphore
FFFC0AA8 10000073		eret
                        	.cause0to7:
                        	.cause12plus:
FFFC0AAC 3000F073		csrrc	$x0,#$300,#1			; disable ints
FFFC0AB0 10100073		wfi
FFFC0AB4 FE000CE3		bra		.cause0to7				; and loop
                        	
                        	;------------------------------------------------------------------------------
                        	; Message strings
                        	;------------------------------------------------------------------------------
                        	
                        	msgStart:
FFFC0AB8 61746550			db		"Petajon System Starting.",13,10
FFFC0ABC 206E6F6A
FFFC0AC0 74737953
FFFC0AC4 53206D65
FFFC0AC8 74726174
FFFC0ACC 2E676E69
FFFC0AD0 6F4D0A0D
                        	msgMonHelp:
FFFC0AD2 696E6F4D			db		"Monitor Commands",13,10
FFFC0AD6 20726F74
FFFC0ADA 6D6D6F43
FFFC0ADE 73646E61
FFFC0AE2 20420A0D
FFFC0AE4 202D2042			db		"B - start tiny basic",13,10
FFFC0AE8 72617473
FFFC0AEC 69742074
FFFC0AF0 6220796E
FFFC0AF4 63697361
FFFC0AF8 20440A0D
FFFC0AFA 202D2044			db		"D - dump ready que",13,10
FFFC0AFE 706D7564
FFFC0B02 61657220
FFFC0B06 71207964
FFFC0B0A 0A0D6575
FFFC0B0E 202D2045			db		"E - edit memory",13,10
FFFC0B12 74696465
FFFC0B16 6D656D20
FFFC0B1A 0D79726F
FFFC0B1E 2D20460A
FFFC0B1F 202D2046			db		"F - fill memory",13,10
FFFC0B23 6C6C6966
FFFC0B27 6D656D20
FFFC0B2B 0D79726F
FFFC0B2F 3C204B0A
FFFC0B30 743C204B			db		"K <tid> - kill task", 13,10
FFFC0B34 203E6469
FFFC0B38 696B202D
FFFC0B3C 74206C6C
FFFC0B40 0D6B7361
FFFC0B44 3C204D0A
FFFC0B45 733C204D			db		"M <start> <length>	- dump memory",13,10
FFFC0B49 74726174
FFFC0B4D 6C3C203E
FFFC0B51 74676E65
FFFC0B55 2D093E68
FFFC0B59 6D756420
FFFC0B5D 656D2070
FFFC0B61 79726F6D
FFFC0B65 20530A0D
FFFC0B67 202D2053			db		"S - switch task",13,10
FFFC0B6B 74697773
FFFC0B6F 74206863
FFFC0B73 0D6B7361
FFFC0B77 0000000A
FFFC0B78 00000000			db		0
FFFC0B79 20000000			align 
                        	
                        	msgTaskStart:
FFFC0B7C 73617420			db		" task started."
FFFC0B80 7473206B
FFFC0B84 65747261
FFFC0B88 0A0D2E64
                        	msgCRLF:
FFFC0B8A 00000A0D			db		13,10,0
FFFC0B8D 00000000			align		
                        	
                        	flt50:
FFFC0B90 00000000		dw	0x00000000,0x00000000,0x00000000,0x40049000
FFFC0B94 00000000
FFFC0B98 00000000
FFFC0B9C 40049000
                        	flt20:
FFFC0BA0 00000000		dw	0x00000000,0x00000000,0x00000000,0x40034000
FFFC0BA4 00000000
FFFC0BA8 00000000
FFFC0BAC 40034000
                        	flt10:
FFFC0BB0 00000000		dw	0x00000000,0x00000000,0x00000000,0x40024000
FFFC0BB4 00000000
FFFC0BB8 00000000
FFFC0BBC 40024000
                        	
                        			align		8                        	
                        	
                        	.file "fltToString.r5a",1
                        	.file "fltToString.r5a",1
                        	STRTMP		equ		$0200
                        	
                        	; -----------------------------------------------------------------------------
                        	;		$fa0 = number to convert (f18)
                        	;		$a1	= width
                        	;		$a2 = precision
                        	;		$a3 = E
                        	;		$t2 = ndx
                        	;		$s9 = exp
                        	; -----------------------------------------------------------------------------
                        	
                        	fltToString:
FFFC0BC0 00006E13			ldi		$t2,#0				; $t2 = 0
FFFC0BC4 E0090953			fmv		$a0,$f18
FFFC0BC8 7F800637			and		$t0,$a0,#$7F800000
FFFC0BCC 00060613
FFFC0BD0 01267D33
FFFC0BD4 7F800DB7			ldi		$t1,#$7F800000
FFFC0BD8 000D8D93
FFFC0BDC 05BD1263			bne		$t0,$t1,.0001
FFFC0BE0 00800637			and		$t0,$a0,#$007FFFFF
FFFC0BE4 FFF60613
FFFC0BE8 01267D33
FFFC0BEC 000D0E63			beq		$t0,$x0,.inf
FFFC0BF0 FFFC1637			ldt		$t0,msgNan
FFFC0BF4 F7860613
FFFC0BF8 00060633
FFFC0BFC 00062D03
FFFC0C00 21A02023			stt		$t0,STRTMP
FFFC0C04 2E000E63			bra		.prt
                        	.inf:
FFFC0C08 FFFC1637			ldt		$t0,msgInf
FFFC0C0C F7460613
FFFC0C10 00060633
FFFC0C14 00062D03
FFFC0C18 21A02023			stt		$t0,STRTMP
FFFC0C1C 2E000263			bra		.prt
                        	.0001:
FFFC0C20 80000637			and		$t0,$a0,#$80000000
FFFC0C24 00060613
FFFC0C28 01267D33
FFFC0C2C 000D0E63			beq		$t0,$x0,.pos
FFFC0C30 02D06D13			ldi		$t0,#'-'
FFFC0C34 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0C38 001E0E13			add		$t2,$t2,#1
FFFC0C3C 80000637			and		$a0,$a0,#$7FFFFFFF
FFFC0C40 FFF60613
FFFC0C44 01267933
                        	.pos:
FFFC0C48 00091A63			bne		$a0,$x0,.notZero
FFFC0C4C 03006D13			ldi		$t0,#'0'
FFFC0C50 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0C54 200E00A3			stb		$x0,STRTMP+1[$t2]
FFFC0C58 2A000463			bra		.prt		
                        	.notZero:
FFFC0C5C 00006633			mov		$s9,$x0			; exp = 0.0
                        	;	// Make a small number > 0 so we can get at the digits.
                        	;	if (dbl < 1.0) {
                        	;		while (dbl < 1.0) {
                        	;			dbl *= 1000000.0;
                        	;			exp -= 6;  
                        	;		}
                        	;	}
FFFC0C60 FFFC1637			flw		$f3,fltOne
FFFC0C64 F7C60613
FFFC0C68 00060633
FFFC0C6C 00062187
FFFC0C70 F0090053			fmv		$f0,$a0
FFFC0C74 A0391D53			flt		$t0,$f18,$f3
FFFC0C78 020D0463			beq		$t0,$x0,.0002
FFFC0C7C FFFC1637			flw		$f4,fltMillion
FFFC0C80 F8460613
FFFC0C84 00060633
FFFC0C88 00062207
                        	.0003:
FFFC0C8C A0391D53			flt		$t0,$f18,$f3
FFFC0C90 000D0863			beq		$t0,$x0,.0002
FFFC0C94 10490953			fmul	$f18,$f18,$f4
FFFC0C98 FFA60613			sub		$s9,$s9,#6
FFFC0C9C FE0008E3			bra		.0003
                        	.0002:
                        	;	// The following is similar to using log10() and pow() functions.
                        	;	// Now dbl is >= 1.0
                        	;	// Create a number dbl2 on the same order of magnitude as dbl, but
                        	;	// less than dbl.
                        	;	dbl2 = 1.0;
                        	;	dbla = dbl2;
                        	;	if (dbl > dbl2) {	// dbl > 1.0 ?
                        	;		while (dbl2 <= dbl) {
                        	;			dbla = dbl2;
                        	;			dbl2 *= 10.0;	// increase power of 10
                        	;			exp++;
                        	;		}
                        	;		// The above loop goes one too far, we want the last value less
                        	;		// than dbl.
                        	;		dbl2 = dbla;
                        	;		exp--;
                        	;	}
FFFC0CA0 FFFC1637			flw		$f1,fltOne				; $f1 = dbl2 = 1.0
FFFC0CA4 F7C60613
FFFC0CA8 00060633
FFFC0CAC 00062087
FFFC0CB0 38008153			fmov	$f2,$f1						; $f2 = dbla = dbl2
FFFC0CB4 A1209D53			flt		$t0,$f1,$f18				; if (dbl2 < dbl)
FFFC0CB8 020D0A63			beq		$t0,$x0,.0004
FFFC0CBC FFFC1637			flw		$f5,fltTen				; $f5 = 10.0
FFFC0CC0 F8060613
FFFC0CC4 00060633
FFFC0CC8 00062287
                        	.0006:
FFFC0CCC A1208D53			fle		$t0,$f1,$f18				; while ($f1 <= $f18)
FFFC0CD0 000D0A63			beq		$t0,$x0,.0005
FFFC0CD4 38008153			fmov	$f2,$f1						; dbla = dbl2
FFFC0CD8 105080D3			fmul	$f1,$f1,$f5				; dbl2 *= 10.0
FFFC0CDC 00160613			add		$s9,$s9,#1				; exp++;
FFFC0CE0 FE0006E3			bra		.0006
                        	.0005:
FFFC0CE4 380100D3			fmov	$f1,$f2						; dbl2 = dbla
FFFC0CE8 FFF60613			sub		$s9,$s9,#1				; exp--;
                        	.0004:
                        	;	// For small constants < 1000000 try and spit out a whole number
                        	;    if (exp >= 0 && exp < 6) {
                        	;        digits_before_decpt = exp+1;
                        	;		exp = 0;
                        	;	}
                        	;	else if (exp >= -6)
                        	;		digits_before_decpt = 1;
                        	;	else
                        	;		digits_before_decpt = -1;
FFFC0CEC 00064E63			blt		$s9,$x0,.0007
FFFC0CF0 00606413			ldi		$s5,#6
FFFC0CF4 00865A63			bge		$s9,$s5,.0007
FFFC0CF8 FFFFE233			mov		$s1,#s0						; s1 = digits before decpt
FFFC0CFC 00120213			add		$s1,$s1,#1
FFFC0D00 00006613			ldi		$s9,#0						; exp = 0
FFFC0D04 00000C63			bra		.0008
                        	.0007:
FFFC0D08 FF906413			ldi		$s5,#-7
FFFC0D0C 00864663			blt		$s9,$s5,.0009
FFFC0D10 00106213			ldi		$s1,#1
FFFC0D14 00000463			bra		.0008
                        	.0009:
FFFC0D18 FFF06213			ldi		$s1,#-1
                        	.0008:
                        	;	// Spit out a leading zero before the decimal point for a small number.
                        	;    if (exp < -6) {
                        	;		buf[ndx] = '0';
                        	;		ndx++;
                        	;        buf[ndx] = '.';
                        	;        ndx++;
                        	;    }
FFFC0D1C FFA06413			ldi		$s5,#-6
FFFC0D20 00865E63			bge		$s9,$s5,.0010
FFFC0D24 03006D13			ldi		$t0,#'0'
FFFC0D28 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0D2C 001E0E13			add		$t2,$t2,#1
FFFC0D30 02E06D13			ldi		$t0,#'.'
FFFC0D34 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0D38 001E0E13			add		$t2,$t2,#1
                        	.0010:
                        	;	// Now loop processing one digit at a time.
                        	;    for (nn = 0; nn < 30 && precision > 0; nn++) {
                        	;        digit = 0;
                        	;		dbla = dbl;
                        	;		// dbl is on the same order of magnitude as dbl2 so
                        	;		// a repeated subtract can be used to find the digit.
                        	;        while (dbl >= dbl2) {
                        	;            dbl -= dbl2;
                        	;            digit++;
                        	;        }
                        	;        buf[ndx] = digit + '0';
                        	;		// Now go back and perform just a single subtract and
                        	;		// a multiply to find out how much to reduce dbl by.
                        	;		// This should improve the accuracy
                        	;		if (digit > 2)
                        	;			dbl = dbla - dbl2 * digit;
                        	;        ndx++;
                        	;        digits_before_decpt--;
                        	;        if (digits_before_decpt==0) {
                        	;           buf[ndx] = '.';
                        	;           ndx++;
                        	;        }
                        	;        else if (digits_before_decpt < 0)
                        	;            precision--;
                        	;		// Shift the next digit to be tested into position.
                        	;        dbl *= 10.0;
                        	;    }
FFFC0D3C 00006313			ldi		$s3,#0						; s3 = nn = 0
FFFC0D40 01E06413			ldi		$s5,#30
FFFC0D44 FFFC1637			flw		$f7,fltTen				; f7 = 10.0
FFFC0D48 F8060613
FFFC0D4C 00060633
FFFC0D50 00062387
                        	.0016:
FFFC0D54 00832D33			slt		$t0,$s3,$s5
FFFC0D58 060D0863			beq		$t0,$x0,.0011
FFFC0D5C 00006413			ldi		$s5,#0
FFFC0D60 07445463			bge		$s5,$a2,.0011			; (0 < precision)
FFFC0D64 00006393			ldi		$s4,#0						; s4 = digit = 0
FFFC0D68 38090153			fmov	$f2,$f18						; dbla = dbl
                        	.0013:
FFFC0D6C A1208D53			fle		$t0,$f1,$f18						; while (dbl2 <= dbl)
FFFC0D70 000D0863			beq		$t0,$x0,.0012
FFFC0D74 08190953			fsub	$f18,$f18,$f1						; dbl -= dbl2
FFFC0D78 00138393			add		$s4,$s4,#1						; digit++
FFFC0D7C FE0008E3			bra		.0013
                        	.0012:
FFFC0D80 03038413			add		$s5,$s4,#'0'			; buf[ndx] = digit + '0'
FFFC0D84 208E0023			stb		$s5,STRTMP[$t2]
FFFC0D88 00206413			ldi		$s5,#2						; if (2 < digit)
FFFC0D8C 00745863			bge		$s5,$s4,.0014
FFFC0D90 D00382D3			fcvt.s.w	$f5,$s4				; f5 = digit as float
FFFC0D94 10508353			fmul	$f6,$f1,$f5				; f6 = dbl2 * digit
FFFC0D98 08610953			fsub	$f18,$f2,$f6				; dbl = dbla - dbl2 * digit
                        	.0014:
FFFC0D9C 001E0E13			add		$t2,$t2,#1				; ndx++
FFFC0DA0 FFF20213			sub		$s1,$s1,#1				; digits_before_decpt--;
FFFC0DA4 00021A63			bne		$s1,$x0,.0015			; if (digits_before_decpt==0)
FFFC0DA8 02E06D13			ldi		$t0,#'.'
FFFC0DAC 21AE0023			stb		$t0,STRTMP[$t2]		; buf[ndx] = '.'
FFFC0DB0 001E0E13			add		$t2,$t2,#1				; ndx++
FFFC0DB4 00000663			bra		.0017
                        	.0015:
FFFC0DB8 00025463			bge		$s1,$x0,.0017			; else if (digits_before_decpt < 0)
FFFC0DBC FFFA0A13			sub		$a2,$a2,#1				; 	precision--
                        	.0017:
FFFC0DC0 10790953			fmul	$f18,$f18,$f7				; dbl *= 10.0
FFFC0DC4 F80008E3			bra		.0016
                        	.0011:
                        	;	// Trim trailing zeros from the number
                        	;    do {
                        	;        ndx--;
                        	;    } while(buf[ndx]=='0');
                        	;    ndx++;
                        	.0018:
FFFC0DC8 FFFE0E13			sub		$t2,$t2,#1				; ndx--
FFFC0DCC 200E0D03			ldb		$t0,STRTMP[$t2]
FFFC0DD0 030D4D13			xor		$t0,$t0,#'0'
FFFC0DD4 FE0D0AE3			beq		$t0,$x0,.0018
FFFC0DD8 001E0E13			add		$t2,$t2,#1				; ndx++
                        	;	// Make sure we have at least one digit after the decimal point.
                        	;	if (buf[ndx]=='.') {
                        	;		ndx++;
                        	;		buf[ndx]='0';
                        	;		ndx++;
                        	;        buf[ndx]='\0';
                        	;	}
FFFC0DDC 200E0D03			ldb		$t0,STRTMP[$t2]
FFFC0DE0 02ED4D13			xor		$t0,$t0,#'.'
FFFC0DE4 000D1C63			bne		$t0,$x0,.0019
FFFC0DE8 001E0E13			add		$t2,$t2,#1
FFFC0DEC 03006D13			ldi		$t0,#'0'
FFFC0DF0 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0DF4 001E0E13			add		$t2,$t2,#1
FFFC0DF8 200E0023			stb		$x0,STRTMP[$t2]
                        	.0019:
                        	;	// If the number is times 10^0 don't output the exponent
                        	;   if (exp==0) {
                        	;        buf[ndx]='\0';
                        	;        goto prt;
                        	;    }
FFFC0DFC 00061663			bne		$s9,$x0,.0020
FFFC0E00 200E0023			stb		$x0,STRTMP[$t2]
FFFC0E04 0E000E63			bra		.prt
                        	.0020:
                        	;	// Spit out +/-E
                        	;    buf[ndx] = E;
                        	;    ndx++;
                        	;    if (exp < 0) {
                        	;        buf[ndx]='-';
                        	;        ndx++;
                        	;        exp = -exp;
                        	;    }
                        	;    else {
                        	;         buf[ndx]='+';
                        	;         ndx++;
                        	;    }
FFFC0E08 04506D13			ldi		$t0,#'E'
FFFC0E0C 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0E10 001E0E13			add		$t2,$t2,#1
FFFC0E14 00065C63			bge		$s9,$x0,.0021
FFFC0E18 02D06D13			ldi		$t0,#'-'
FFFC0E1C 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0E20 001E0E13			add		$t2,$t2,#1
FFFC0E24 40C00633			sub		$s9,$x0,$s9			; exp = -exp
FFFC0E28 00000863			bra		.0022
                        	.0021:
FFFC0E2C 02B06D13			ldi		$t0,#'+'
FFFC0E30 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0E34 001E0E13			add		$t2,$t2,#1
                        	.0022:
                        	;	// now process the exponent
                        	;    digit = 0;
                        	;    while (exp >= 1000) {
                        	;        exp -= 1000;
                        	;        digit++;
                        	;    }
FFFC0E38 00006393			ldi		$s4,#0
FFFC0E3C 3E806D13			ldi		$t0,#1000
                        	.0025:
FFFC0E40 01A65463			bge		$s9,$t0,.0023
FFFC0E44 00000863			bra		.0024
                        	.0023:
FFFC0E48 41A60633			sub		$s9,$s9,$t0
FFFC0E4C 00138393			add		$s4,$s4,#1
FFFC0E50 FE0008E3			bra		.0025
                        	.0024:
                        	;	d1 = digit;
                        	;	if (digit) {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0E54 0003E4B3			mov		$s6,$s4					; s6 = d1 = s4 = digit
FFFC0E58 00039863			bne		$s4,$x0,.0026
FFFC0E5C 03038D13			add		$t0,$s4,#'0'
FFFC0E60 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0E64 001E0E13			add		$t2,$t2,#1
                        	.0026:
                        	;	digit = 0;
                        	;    while (exp >= 100) {
                        	;        exp -= 100;
                        	;        digit++;
                        	;    }
FFFC0E68 00006393			ldi		$s4,#0
FFFC0E6C 06406D13			ldi		$t0,#100
                        	.0027:
FFFC0E70 01A65463			bge		$s9,$t0,.0028
FFFC0E74 00000863			bra		.0029
                        	.0028:
FFFC0E78 41A60633			sub		$s9,$s9,$t0
FFFC0E7C 00138393			add		$s4,$s4,#1
FFFC0E80 FE0008E3			bra		.0027
                        	.0029:	
                        	;	d2 = digit;
                        	;	if (digit==0 && d1==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0E84 0003E533			mov		$s7,$s4				; $s7 = d2
FFFC0E88 00049463			bne		$s6,$x0,.0030
FFFC0E8C 00038863			beq		$s4,$x0,.0031
                        	.0030:
FFFC0E90 03038D13			add		$t0,$s4,#'0'
FFFC0E94 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0E98 001E0E13			add		$t2,$t2,#1
                        	.0031:
                        	;	digit = 0;
                        	;    while (exp >= 10) {
                        	;        exp -= 10;
                        	;        digit++;
                        	;    }
FFFC0E9C 00006393			ldi		$s4,#0
FFFC0EA0 00A06D13			ldi		$t0,#10
                        	.0032:
FFFC0EA4 01A65463			bge		$s9,$t0,.0034
FFFC0EA8 00000863			bra		.0035
                        	.0034:
FFFC0EAC 41A60633			sub		$s9,$s9,$t0
FFFC0EB0 00138393			add		$s4,$s4,#1
FFFC0EB4 FE0008E3			bra		.0032
                        	.0035:	
                        	;	d3 = digit;
                        	;	if (digit==0 && d1==0 && d2==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0EB8 0003E5B3			mov		$s8,$s4
FFFC0EBC 00039663			bne		$s4,$x0,.0036
FFFC0EC0 00049463			bne		$s6,$x0,.0036
FFFC0EC4 00050863			beq		$s7,$x0,.0037
                        	.0036:
FFFC0EC8 03038D13			add		$t0,$s4,#'0'
FFFC0ECC 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0ED0 001E0E13			add		$t2,$t2,#1
                        	.0037:
                        	;	digit = 0;
                        	;    while (exp >= 1) {
                        	;        exp -= 1;
                        	;        digit++;
                        	;    }
FFFC0ED4 00006393			ldi		$s4,#0
FFFC0ED8 00106D13			ldi		$t0,#1
                        	.0038:
FFFC0EDC 01A65463			bge		$s9,$t0,.0040
FFFC0EE0 00000863			bra		.0039
                        	.0040:
FFFC0EE4 41A60633			sub		$s9,$s9,$t0
FFFC0EE8 00138393			add		$s4,$s4,#1
FFFC0EEC FE0008E3			bra		.0038
                        	.0039:	
                        	;    buf[ndx] = digit + '0';
                        	;    ndx++;
                        	;    buf[ndx] = '\0';
FFFC0EF0 03038D13			add		$t0,$s4,#'0'
FFFC0EF4 21AE0023			sb		$t0,STRTMP[$t2]
FFFC0EF8 001E0E13			add		$t2,$t2,#1
FFFC0EFC 200E0023			sb		$x0,STRTMP[$t2]
                        	;	// Now pad the number on the left or right as requested.
                        	.prt:
                        	;    // pad left
                        	;    if (width > 0) {
                        	;        if (ndx < width) {
                        	;            for (nn = 39; nn >= width-ndx; nn--)
                        	;                buf[nn] = buf[nn-(width-ndx)];
                        	;            for (; nn >= 0; nn--)
                        	;                buf[nn] = ' ';
                        	;        }
                        	;    }
FFFC0F00 0409C663			blt		$a1,$x0,.0041
FFFC0F04 04098463			beq		$a1,$x0,.0041
FFFC0F08 013E4463			blt		$t2,$a1,.0042
FFFC0F0C 04000063			bra		.0041
                        	.0042:
FFFC0F10 02706313			ldi		$s3,#39					; s3 = nn
FFFC0F14 41C98D33			sub		$t0,$a1,$t2			; width-ndx
                        	.0045:
FFFC0F18 01A35463			bge		$s3,$t0,.0043
FFFC0F1C 00000C63			bra		.0044
                        	.0043:
FFFC0F20 41A304B3			sub		$s6,$s3,$t0			; nn-(width-ndx)
FFFC0F24 20030D83			ldb		$t1,STRTMP[$s3]
FFFC0F28 21B48023			stb		$t1,STRTMP[$s6]
FFFC0F2C FFF30313			sub		$s3,$s3,#1
FFFC0F30 FE0004E3			bra		.0045
                        	.0044:
FFFC0F34 02006D13			ldi		$t0,#' '
                        	.0048:
FFFC0F38 00035463			bge		$s3,$x0,.0046
FFFC0F3C 00000863			bra		.0047
                        	.0046:
FFFC0F40 21A30023			stb		$t0,STRTMP[$s3]
FFFC0F44 FFF30313			sub		$s3,$s3,#1
FFFC0F48 FE0008E3			bra		.0048
                        	.0047:
                        	.0041:
                        	;    // pad right
                        	;    if (width < 0) {
                        	;        width = -width;
                        	;        while (ndx < width) {
                        	;            buf[ndx]=' ';
                        	;            ndx++;
                        	;        }
                        	;        buf[ndx]='\0';
                        	;    }
                        	;    return (ndx);
FFFC0F4C 0209D063			bge		$a1,$x0,.0050
FFFC0F50 413009B3			sub		$a1,$x0,$a1
FFFC0F54 02006D13			ldi		$t0,#' '
                        	.0052:
FFFC0F58 013E5863			bge		$t2,$a1,.0051
FFFC0F5C 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0F60 001E0E13			add		$t2,$t2,#1
FFFC0F64 FE000AE3			bra		.0052
                        	.0051:
FFFC0F68 200E0023			stb		$x0,STRTMP[$t2]
                        	.0050:
FFFC0F6C 000E6833			mov		$v0,$t2
FFFC0F70 00008067			ret
                        	
                        			align	4                        	
                        	msgInf:
FFFC0F74 00666E49			db	"Inf",0
                        	msgNan:
FFFC0F78 006E614E			db	"Nan",0
                        	fltOne:
FFFC0F7C 3F800000			dw		$3F800000					; 1.0
                        	fltTen:
FFFC0F80 41200000			dw		$41200000					; 10.0
                        	fltMillion:
FFFC0F84 49742400			dw		$49742400					; 1,000,000
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../bios/bios.r5a",1
                        	.file "../bios/bios.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../bios/bios.r5a",25
                        		code
                        		align	2                        	
                        	BIOSCallTbl:
FFFC0F88 0F940F90		dh		BIOS_ClearScreen
FFFC0F8A 0F980F94		dh		BIOS_HomeCursor
FFFC0F8C 0F9C0F98		dh		BIOS_VideoPutChar
FFFC0F8E 006F0F9C		dh		BIOS_VideoPutString
                        	
                        		align	4                        	
                        	BIOS_ClearScreen:
FFFC0F90 4F10006F		jmp		VideoClearScreen
                        	BIOS_HomeCursor:
FFFC0F94 5350006F		jmp		VideoHomeCursor
                        	BIOS_VideoPutChar:
FFFC0F98 5950006F		jmp		VideoPutChar
                        	BIOS_VideoPutString:
FFFC0F9C 1100106F		jmp		VideoPutString
                        	
                        	
                        	
                        	
                        	
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../bios/mem.r5a",1
                        	.file "../bios/mem.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../bios/mem.r5a",25
                        			code	18 bits
                        			align	4                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	MMUInit:
FFFC0FA0 FF870713			sub		$sp,$sp,#8
FFFC0FA4 00173023			sto		$ra,[$sp]
FFFC0FA8 00002D37			ldi		$t0,#8192				; set number of available pages in system
FFFC0FAC 000D0D13
FFFC0FB0 00025637			stw		$t0,NPAGES
FFFC0FB4 82860613
FFFC0FB8 00060633
FFFC0FBC 01A61023
                        			; Free all memory for all maps
FFFC0FC0 00006D13			ldi		$t0,#$00
FFFC0FC4 01F06F13			ldi		$t4,#MAX_MID		; map id
                        	.0004:
FFFC0FC8 10300073			pfi
FFFC0FCC 00006D93			ldi		$t1,#$000				; regno
FFFC0FD0 00001E37			ldi		$t2,#PAGES_PER_MAP	; number of registers to update
FFFC0FD4 000E0E13
                        	.0001:
FFFC0FD8 10300073			pfi
FFFC0FDC 010F1213			sll		$s1,$t4,#16			; put mid in place
FFFC0FE0 01B26233			or		$s1,$s1,$t1			; or in page number
FFFC0FE4 024D000D			mvmap	$x0,$t0,$s1
FFFC0FE8 001D8D93			add		$t1,$t1,#$01		; increment page number
FFFC0FEC FFFE0E13			sub		$t2,$t2,#1
FFFC0FF0 FE0E14E3			bnez	$t2,.0001
FFFC0FF4 FFFF0F13			sub		$t4,$t4,#1
FFFC0FF8 FC0F58E3			bge		$t4,$x0,.0004
                        			; Now ensure all pages in PAM are marked free
FFFC0FFC 00002D37			ldi		$t0,#8191
FFFC1000 FFFD0D13
                        	.0006:
FFFC1004 10300073			pfi
FFFC1008 0A0D000D			pfree	$t0
FFFC100C FFFD0D13			sub		$t0,$t0,#1
FFFC1010 FE0D5AE3			bge		$t0,$x0,.0006
                        			; Allocate three pages for OS data.
                        			; These will end up being the first three pages of memory
FFFC1014 0800000D			palloc	$x0,$x0
FFFC1018 0800000D			palloc	$x0,$x0
FFFC101C 0800000D			palloc	$x0,$x0
                        			; allocate last page for system stack
FFFC1020 00001DB7			ldi		$t1,#$FFF				
FFFC1024 FFFD8D93
FFFC1028 00002D37			ldi		$t0,#$1FFF
FFFC102C FFFD0D13
FFFC1030 080D000D			palloc	$x0,$t0				; specifically allocate page 8191
FFFC1034 03BD000D			mvmap	$x0,$t0,$t1
FFFC1038 10300073			pfi
                        	
                        			; Now setup segment registers
FFFC103C 00006D13			ldi		$t0,#$0
FFFC1040 00706D93			ldi		$t1,#$07				; t1 = value to load RWX=111, base = 0
                        	.0002:
FFFC1044 10300073			pfi
FFFC1048 01AD800D			mvseg	$x0,$t1,$t0			; move to the segment register identifed by t0
FFFC104C 001D0D13			add		$t0,$t0,#1			; pick next segment register
FFFC1050 010D2E13			slt		$t2,$t0,#16			; 16 segment regs
FFFC1054 FE0E18E3			bne		$t2,$x0,.0002
FFFC1058 00073083			ldo		$ra,[$sp]
FFFC105C 00870713			add		$sp,$sp,#8
FFFC1060 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Find a run of buckets available for mapping virtual to physical addresses.
                        	;
                        	; Parameters:
                        	;		a0 = mid
                        	;		a1 = number of pages required.
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		v0 = starting bucket number (includes ASID), -1 if no run found
                        	;------------------------------------------------------------------------------
                        	
                        	FindRun:
FFFC1064 01F97E93		and			$t3,$a0,#MAX_MID	; t3 = mid
FFFC1068 010E9E93		sll			$t3,$t3,#16				; shift into usable position
FFFC106C 000EEE33		mov			$t2,$t3						; t2 = map entry number
FFFC1070 003E6E13		or			$t2,$t2,#OSPAGES	; start looking at page 3 (others are for OS)
FFFC1074 00002FB7		ldi			$t5,#8191					; max number of pages - 1
FFFC1078 FFFF8F93
FFFC107C 01DFEFB3		or			$t5,$t5,$t3				; t5 = max in ASID
                        	.0003:
FFFC1080 10300073		pfi
FFFC1084 00006D93		ldi			$t1,#0						; t1 = count of consecutive empty buckets
                        	.0001:
FFFC1088 10300073		pfi
FFFC108C 03C0080D		mvmap		$v0,$x0,$t2				; get map entry into v0
FFFC1090 00080A63		beqz		$v0,.empty0				; is it empty?
FFFC1094 001E0E13		add			$t2,$t2,#1
FFFC1098 FFFE68E3		bltu		$t2,$t5,.0001
                        	.0002:
FFFC109C FFF06813		ldi			$v0,#-1						; got here so no run was found
FFFC10A0 00008067		ret
                        	.empty0:
FFFC10A4 000E6EB3		mov			$t3,$t2						; save first empty bucket
                        	.empty1:
FFFC10A8 10300073		pfi
FFFC10AC FFFE78E3		bgeu		$t2,$t5,.0002
FFFC10B0 001D8D93		add			$t1,$t1,#1
FFFC10B4 013DFA63		bgeu		$t1,$a1,.foundEnough
FFFC10B8 001E0E13		add			$t2,$t2,#1				; next bucket
FFFC10BC 03C0080D		mvmap		$v0,$x0,$t2				; get map entry
FFFC10C0 FE0804E3		beqz		$v0,.empty1
FFFC10C4 FA000EE3		bra			.0003							; go back and find another run
                        	.foundEnough:
FFFC10C8 10300073		pfi
FFFC10CC 000EE833		mov			$v0,$t3						; v0 = start of run
FFFC10D0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Find a run of buckets available for mapping virtual to physical addresses.
                        	; This search starts at the top of the virtual address space and works its
                        	; way downwards. This is usually used for allocating stack space.
                        	;
                        	; Parameters:
                        	;		a0 = mid
                        	;		a1 = number of pages required.
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		v0 = starting bucket number (includes ASID), -1 if no run found
                        	;------------------------------------------------------------------------------
                        	
                        	FindStackRun:
FFFC10D4 01F97E93		and			$t3,$a0,#MAX_MID	; t3 = mid
FFFC10D8 010E9E93		sll			$t3,$t3,#16				; shift into usable position
FFFC10DC 000EEE33		mov			$t2,$t3						; t2 = map entry number
FFFC10E0 00001637		or			$t2,$t2,#PAGES_PER_MAP-1	; start looking at last page
FFFC10E4 FFF60613
FFFC10E8 01C66E33
FFFC10EC 000EEFB3		mov			$t5,$t3						; t5 = min in ASID
FFFC10F0 10300073		pfi
                        	.0003:
FFFC10F4 00006D93		ldi			$t1,#0						; t1 = count of consecutive empty buckets
                        	.0001:
FFFC10F8 10300073		pfi
FFFC10FC 03C0080D		mvmap		$v0,$x0,$t2				; get map entry into v0
FFFC1100 00080A63		beqz		$v0,.empty0				; is it empty?
FFFC1104 FFFE0E13		sub			$t2,$t2,#1
FFFC1108 FFFE78E3		bgeu		$t2,$t5,.0001
                        	.0002:
FFFC110C FFF06813		ldi			$v0,#-1						; got here so no run was found
FFFC1110 00008067		ret
                        	.empty0:
                        	.empty1:
FFFC1114 10300073		pfi
FFFC1118 FFFE6AE3		bltu		$t2,$t5,.0002
FFFC111C 001D8D93		add			$t1,$t1,#1
FFFC1120 013DFA63		bgeu		$t1,$a1,.foundEnough
FFFC1124 FFFE0E13		sub			$t2,$t2,#1				; next bucket
FFFC1128 03C0080D		mvmap		$v0,$x0,$t2				; get map entry
FFFC112C FE0804E3		beqz		$v0,.empty1
FFFC1130 FC0002E3		bra			.0003							; go back and find another run
                        	.foundEnough:
FFFC1134 10300073		pfi
FFFC1138 000E6833		mov			$v0,$t2						; v0 = start of run
FFFC113C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = mid
                        	;		a1 = amount of memory to allocate
                        	; Modifies:
                        	;		a1,t0
                        	; Returns:
                        	;		v1 = pointer to allocated memory in virtual address space.
                        	;		v0 = E_Ok for success, E_NotAlloc otherwise
                        	;------------------------------------------------------------------------------
                        	;
                        	AllocInCurrentAS:
                        		
FFFC1140 18101873		csrrw	v0,#$181,x0
FFFC1144 01F87813		and		v0,v0,#MAX_TID
FFFC1148 00086933	mov			$a0,$v0
                        	Alloc:
FFFC114C FD870713		sub			$sp,$sp,#40
FFFC1150 00173023		sto			$ra,[$sp]
FFFC1154 00473423		sto			$s1,8[$sp]				; these regs must be saved
FFFC1158 00573823		sto			$s2,16[$sp]
FFFC115C 00673C23		sto			$s3,24[$sp]
FFFC1160 10300073		pfi
                        		; First check if there are enough pages available in the system.
FFFC1164 00010637		add			$v0,$a1,#PAGESZ-1	; v0 = round memory request
FFFC1168 FFF60613
FFFC116C 01360833
FFFC1170 01085813		srl			$v0,$v0,#LOG_PGSZ	; v0 = convert to pages required
FFFC1174 00025637		ldwu		$t0,NPAGES				; check number of pages available
FFFC1178 82860613
FFFC117C 00060633
FFFC1180 00065D03
FFFC1184 010D7663		bleu		$v0,$t0,.enough
                        	.noRun2:
FFFC1188 00006893		ldi			$v1,#0						; not enough, return null
FFFC118C 06000663		bra			.noRun
                        	.enough:
FFFC1190 10300073		pfi
                        		; There are enough pages, but is there a run long enough in map space?
FFFC1194 000862B3		mov			$s2,$v0						; save required # pages
FFFC1198 000869B3		mov			$a1,$v0
FFFC119C EC9FF0EF		call		FindRun						; find a run of available slots
FFFC11A0 FE0844E3		blt			$v0,$x0,.noRun2
                        		; Now there are enough pages, and a run available, so allocate
FFFC11A4 00086233		mov			$s1,$v0						; s1 = start of run
FFFC11A8 00025637		ldwu		$s3,NPAGES				; decrease number of pages available in system
FFFC11AC 82860613
FFFC11B0 00060633
FFFC11B4 00065303
FFFC11B8 40530333		sub			$s3,$s3,$s2
FFFC11BC 00025637		stw			$s3,NPAGES
FFFC11C0 82860613
FFFC11C4 00060633
FFFC11C8 00661023
FFFC11CC 00086333		mov			$s3,$v0						; s3 = start of run
                        	.0001:
FFFC11D0 10300073		pfi
FFFC11D4 0800080D		palloc	$v0,$x0						; allocate a page (cheat and use hardware)
FFFC11D8 02080063		beqz		$v0,.noRun
FFFC11DC 0268000D		mvmap		$x0,$v0,$s3				; map the page
FFFC11E0 00130313		add			$s3,$s3,#1				; next bucket
FFFC11E4 FFF28293		sub			$s2,$s2,#1
FFFC11E8 FE5044E3		bgt			$s2,$x0,.0001
FFFC11EC 01021893		sll			$v1,$s1,#LOG_PGSZ	; v1 = virtual address of allocated mem.
FFFC11F0 00006813		ldi			$v0,#E_Ok
FFFC11F4 00000663		bra			.xit
                        	.noRun:
FFFC11F8 10300073		pfi
FFFC11FC 00906813		ldi			$v0,#E_NotAlloc
                        	.xit
FFFC1200 10300073		pfi
FFFC1204 00073083		ldo			$ra,[$sp]					; restore saved regs
FFFC1208 00873203		ldo			$s1,8[$sp]
FFFC120C 01073283		ldo			$s2,16[$sp]
FFFC1210 01873303		ldo			$s3,24[$sp]
FFFC1214 02870713		add			$sp,$sp,#40
FFFC1218 00008067		ret
                        	
                        	_Alloc:
FFFC121C FF870713		sub			$sp,$sp,#8
FFFC1220 00173023		sto			$ra,[$sp]
FFFC1224 F29FF0EF		call		Alloc
FFFC1228 00080463		beqz		$v0,.ok
FFFC122C 000068B3		mov			$v1,$x0
                        	.ok:
FFFC1230 10300073		pfi
FFFC1234 0008E833		mov			$v0,$v1
FFFC1238 00073083		ldo			$ra,[$sp]
FFFC123C 00870713		add			$sp,$sp,#8
FFFC1240 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Allocate the stack page for a map. The stack is located at the highest
                        	; virtual address ($7FC00).
                        	;
                        	; Parameters:
                        	;		a0 = mid to allocate for
                        	;	Returns:
                        	;		v0 = physical address, 0 if unsuccessful
                        	;		v1 = virtual address, not valid unless successful
                        	;------------------------------------------------------------------------------
                        	
                        	AllocStack:
FFFC1244 FF870713		sub			$sp,$sp,#8
FFFC1248 00173023		sto			$ra,[$sp]
FFFC124C 01091893		sll			$v1,$a0,#16			; 
FFFC1250 00001637		or			$v1,$v1,#PAGES_PER_MAP-1	; last page of memory is for stack
FFFC1254 FFF60613
FFFC1258 011668B3
FFFC125C 10300073		pfi
FFFC1260 0310080D		mvmap		$v0,$x0,$v1			; check if stack already allocated
FFFC1264 00081863		bnez		$v0,.0001
FFFC1268 0800080D		palloc	$v0,$x0					; allocate a page
FFFC126C 02080063		beqz		$v0,.xit				; success?
FFFC1270 0318000D		mvmap		$x0,$v0,$v1
                        	.0001:
FFFC1274 10300073		pfi
FFFC1278 00001637		and			$v1,$v1,#4095
FFFC127C FFF60613
FFFC1280 011678B3
FFFC1284 01081813		sll			$v0,$v0,#LOG_PGSZ			; convert pages to addresses
FFFC1288 01089893		sll			$v1,$v1,#LOG_PGSZ
                        	.xit:
FFFC128C 10300073		pfi
FFFC1290 00073083		ldo			$ra,[$sp]
FFFC1294 00870713		add			$sp,$sp,#8
FFFC1298 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; This routine will de-allocate all the pages associated with a map including
                        	; the stack.
                        	;
                        	; Parameters:
                        	;		a0 = mid to free memory for
                        	;	Modifies:
                        	;		t0,t1,t3,t4
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	FreeAll:
FFFC129C 00006E93		ldi			$t3,#0
FFFC12A0 01091F13		sll			$t4,$a0,#16
                        	.nxt:
FFFC12A4 10300073		pfi
FFFC12A8 00001637		slt			$t1,$t3,#PAGES_PER_MAP		; number of buckets to check
FFFC12AC 00060613
FFFC12B0 040D8A63		beqz		$t1,.0001
FFFC12B4 003F0637		and			$t4,$t4,#$3F0000
FFFC12B8 00060613
FFFC12BC 01E67F33
FFFC12C0 01DF6F33		or			$t4,$t4,$t3			; combine mid and bucket number
FFFC12C4 00006D13		ldi			$t0,#0					; new page number to set (indicates free)
FFFC12C8 03ED0D0D		mvmap		$t0,$t0,$t4			; get page mapping and set to zero
FFFC12CC 001E8E93		add			$t3,$t3,#1			; advance to next bucket
FFFC12D0 FC0D0AE3		beqz		$t0,.nxt				; 0 = no map in this bucket
FFFC12D4 10300073		pfi
FFFC12D8 0A0D000D		pfree		$t0							; free the page
FFFC12DC 00025637		ldwu		$t0,NPAGES			; update the number of available pages
FFFC12E0 82860613
FFFC12E4 00060633
FFFC12E8 00065D03
FFFC12EC 001D0D13		add			$t0,$t0,#1
FFFC12F0 00025637		stw			$t0,NPAGES
FFFC12F4 82860613
FFFC12F8 00060633
FFFC12FC 01A61023
FFFC1300 FA0002E3		bra			.nxt
                        	.0001:
FFFC1304 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Convert a virtual address to a physical one
                        	;
                        	; Parameters:
                        	;		a0 = map id
                        	;		a1 = virtual address to convert
                        	; Modifies:
                        	;		t0
                        	; Returns:
                        	;		v0 = physical address
                        	;------------------------------------------------------------------------------
                        	
                        	_VirtToPhys:
                        	VirtToPhys:
FFFC1308 FF000837		ldi		$v0,#$FF000000
FFFC130C 00080813
FFFC1310 0309F863		bgeu	$a1,$v0,.notMapped
FFFC1314 0109DD13		srl		$t0,$a1,#LOG_PGSZ		; convert virt to page
FFFC1318 01091813		sll		$v0,$a0,#16
FFFC131C 01A86833		or		$v0,$v0,$t0					; and in mid
FFFC1320 10300073		pfi
FFFC1324 0300080D		mvmap	$v0,$x0,$v0					; get the translation
FFFC1328 01081813		sll		$v0,$v0,#LOG_PGSZ		; convert page to address
FFFC132C 00010637		and		$t0,$a1,#$FFFF			; insert LSB's
FFFC1330 FFF60613
FFFC1334 01367D33
FFFC1338 01A86833		or		$v0,$v0,$t0
FFFC133C 00008067		ret
                        	.notMapped:
FFFC1340 0009E833		mov		$v0,$a1
FFFC1344 00008067		ret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/pic.r5a",1
                        	.file "../fmtk/pic.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	;
                        	;  0x80    - irq control for irq #0
                        	;  0x84    - irq control for irq #1
                        	;            bits 0 to 7  = cause code to issue
                        	;						 bit 8 to 9   = CPU select
                        	;            bits 13 to 15 = irq level to issue
                        	;            bit 16 = irq enable
                        	;            bit 17 = edge sensitivity
                        	
                        	PIC				equ		$FFDC0F00
                        	PIC_CH16	equ		$C0				; UART
                        	PIC_CH28	equ		$F0				; KBD
                        	PIC_CH31	equ		$FC				; VIA
                        	
                        	PicInit:
FFFC1348 FFDC1DB7		ldi		$t1,#PIC					; t1 = address of pic
FFFC134C F00D8D93
FFFC1350 0001ED37		ldi		$t0,#$0001E125		; level sensitive cause 37, interrupt enabled
FFFC1354 125D0D13
FFFC1358 0DADA023		stt		$t0,PIC_CH16[$t1]
FFFC135C 10300073		pfi
FFFC1360 0001ED37		ldi		$t0,#$0001E121		; level sensitive cause 33, interrupt enabled
FFFC1364 121D0D13
FFFC1368 0FADA823		stt		$t0,PIC_CH28[$t1]
FFFC136C 0001ED37		ldi		$t0,#$0001E32F		; level sensitive cause 47, interrupt enabled, both CPU's notified
FFFC1370 32FD0D13
FFFC1374 0FADAE23		stt		$t0,PIC_CH31[$t1]
FFFC1378 00008067		ret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/serial.r5a",1
                        	.file "../fmtk/serial.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
                        	.file "../fmtk/serial.r5a",29
                        		code
FFFC137C 00000000		align	
                        	
                        	SerialFuncTbl:
FFFC1380 00000000		dco		0							; no operation
FFFC1384 00000000
FFFC1388 00000000		dco		0							; setup
FFFC138C 00000000
FFFC1390 00000000		dco		0							; initialize
FFFC1394 00000000
FFFC1398 00000000		dco		0							; status
FFFC139C 00000000
FFFC13A0 00000000		dco		0							; media check
FFFC13A4 00000000
FFFC13A8 00000000		dco		0							; build BPB
FFFC13AC 00000000
FFFC13B0 00000000		dco		0							; open
FFFC13B4 00000000
FFFC13B8 00000000		dco		0							; close
FFFC13BC 00000000
FFFC13C0 FFFC15EC		dco		SerialGetChar	; get char
FFFC13C4 00000000
FFFC13C8 FFFC16CC		dco		SerialPeekChar
FFFC13CC 00000000
FFFC13D0 00000000		dco		0							; get char direct
FFFC13D4 00000000
FFFC13D8 FFFC1734		dco		SerialPeekCharDirect	; peek char direct
FFFC13DC 00000000
FFFC13E0 00000000		dco		0							; input status
FFFC13E4 00000000
FFFC13E8 FFFC1790		dco		SerialPutChar
FFFC13EC 00000000
FFFC13F0 00000000		dco		0							; reserved
FFFC13F4 00000000
FFFC13F8 00000000		dco		0							; set position
FFFC13FC 00000000
FFFC1400 00000000		dco		0							; read block
FFFC1404 00000000
FFFC1408 00000000		dco		0							; write block
FFFC140C 00000000
FFFC1410 00000000		dco		0							; verify block
FFFC1414 00000000
FFFC1418 00000000		dco		0							; output status
FFFC141C 00000000
FFFC1420 00000000		dco		0							; flush input
FFFC1424 00000000
FFFC1428 00000000		dco		0							; flush output
FFFC142C 00000000
FFFC1430 FFFC1858		dco		SerialIRQ			; IRQ routine
FFFC1434 00000000
FFFC1438 00000000		dco		0							; Is removable
FFFC143C 00000000
FFFC1440 00000000		dco		0							; ioctrl read
FFFC1444 00000000
FFFC1448 00000000		dco		0							; ioctrl write
FFFC144C 00000000
FFFC1450 00000000		dco		0							; output until busy
FFFC1454 00000000
FFFC1458 00000000		dco		0							; 27
FFFC145C 00000000
FFFC1460 00000000		dco		0
FFFC1464 00000000
FFFC1468 00000000		dco		0
FFFC146C 00000000
FFFC1470 00000000		dco		0
FFFC1474 00000000
FFFC1478 00000000		dco		0							; 31
FFFC147C 00000000
                        	
                        	MAX_DEV_OP			EQU		31
                        	
                        	;------------------------------------------------------------------------------
                        	; Initialize serial port.
                        	;
                        	; Modifies:
                        	;		$t0
                        	;------------------------------------------------------------------------------
                        	
                        	SerialInit:
FFFC1480 FF870713		sub		$sp,$sp,#8
FFFC1484 00173023		sto		$ra,[$sp]
FFFC1488 00506913		ldi		$a0,#5							; serial device
FFFC148C FFFC19B7		ldi		$a1,#SerialFuncTbl
FFFC1490 38098993
FFFC1494 10300073		pfi
FFFC1498 5E8020EF		call	CopyDevFuncTbl
FFFC149C 00026637		stt		$x0,SerHeadRcv
FFFC14A0 80060613
FFFC14A4 00060633
FFFC14A8 00062023
FFFC14AC 00026637		stt		$x0,SerTailRcv
FFFC14B0 80460613
FFFC14B4 00060633
FFFC14B8 00062023
FFFC14BC 00026637		stt		$x0,SerHeadXmit
FFFC14C0 80860613
FFFC14C4 00060633
FFFC14C8 00062023
FFFC14CC 00026637		stt		$x0,SerTailXmit
FFFC14D0 80C60613
FFFC14D4 00060633
FFFC14D8 00062023
FFFC14DC 10300073		pfi
FFFC14E0 00026637		stb		$x0,SerRcvXon
FFFC14E4 81060613
FFFC14E8 00060633
FFFC14EC 00060023
FFFC14F0 00026637		stb		$x0,SerRcvXoff
FFFC14F4 81160613
FFFC14F8 00060633
FFFC14FC 00060023
FFFC1500 00906D13		ldi		$t0,#$09						; dtr,rts active, rxint enabled, no parity
FFFC1504 FFDC1637		stt		$t0,UART+8
FFFC1508 A0860613
FFFC150C 00060633
FFFC1510 01A62023
FFFC1514 00060D37		ldi		$t0,#$0006001E			; reset the fifo's
FFFC1518 01ED0D13
FFFC151C 10300073		pfi
FFFC1520 FFDC1637		stt		$t0,UART+12
FFFC1524 A0C60613
FFFC1528 00060633
FFFC152C 01A62023
FFFC1530 01E06D13		ldi		$t0,#$0000001E			; baud 9600, 1 stop bit, 8 bit, internal baud gen
FFFC1534 FFDC1637		stt		$t0,UART+12
FFFC1538 A0C60613
FFFC153C 00060633
FFFC1540 01A62023
FFFC1544 10300073		pfi
FFFC1548 00073083		ldo		$ra,[$sp]
FFFC154C 00870713		add		$sp,$sp,#8
FFFC1550 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	SerialServiceInit:
FFFC1554 00106913		ldi		$a0,#1			; start task
FFFC1558 40006993		ldi		$a1,#1024		; memory required
FFFC155C FFFC1A37		ldi		$a2,#SerialService
FFFC1560 56CA0A13
FFFC1564 00000073		ecall
FFFC1568 00008067		ret
                        	SerialService:
FFFC156C DE870713		sub		$sp,$sp,#512+24
FFFC1570 00E06913		ldi		$a0,#14			; get current tid
FFFC1574 00000073		ecall
FFFC1578 20470A13		add		$a2,$sp,#516
FFFC157C 000869B3		mov		$a1,$v0
FFFC1580 00606913		ldi		$a0,#6			; alloc mailbox
FFFC1584 00000073		ecall
                        	
                        	SerialServiceLoop:
FFFC1588 00A06913		ldi		$a0,#10			; waitmsg
FFFC158C 20470993		add		$a1,$sp,#516
FFFC1590 20870A13		add		$a2,$sp,#520
FFFC1594 20C70A93		add		$a3,$sp,#524
FFFC1598 21070B13		add		$a4,$sp,#528
FFFC159C FFF06B93		ldi		$a5,#-1
FFFC15A0 00000073		ecall
                        	
FFFC15A4 00072D03		lw		$t0,[$sp]
FFFC15A8 01FD7D13		and		$t0,$t0,#31
FFFC15AC 001D1D13		sll		$t0,$t0,#1
FFFC15B0 FFFC1637		lw		$t0,SerialFuncTbl[$t0]
FFFC15B4 38060613
FFFC15B8 01A60633
FFFC15BC 00062D03
FFFC15C0 000D0067		jmp		[$t0]
                        	
                        	SerialFinishCmd:
FFFC15C4 00C72983		lw		$a1,12[$sp]		; reply mbx
FFFC15C8 00198993		add		$a1,$a1,#1		; -1 = no reply requested
FFFC15CC 01298E63		beq		$a1,$a0,.0001
FFFC15D0 FFF98993		sub		$a1,$a1,#1
FFFC15D4 00906913		ldi		$a0,#9				; sendmsg
FFFC15D8 FFF06A13		ldi		$a2,#-1
FFFC15DC FFF06A93		ldi		$a3,#-1
FFFC15E0 FFF06B13		ldi		$a4,#-1
FFFC15E4 00000073		ecall
                        	.0001:
FFFC15E8 FA1FF06F		jmp		SerialServiceLoop
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialGetChar
                        	;
                        	; Check the serial port buffer to see if there's a char available. If there's
                        	; a char available then return it. If the buffer is almost empty then send an
                        	; XON.
                        	;
                        	; Stack Space:
                        	;		3 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$v0 = character or -1
                        	;------------------------------------------------------------------------------
                        	
                        	SerialGetChar:
FFFC15EC FE870713			sub		$sp,$sp,#24
FFFC15F0 00173023			sto		$ra,[$sp]
FFFC15F4 01173423			sto		$v1,8[$sp]
FFFC15F8 00473823			sto		$s1,16[$sp]
FFFC15FC 10300073			pfi
FFFC1600 00026637			lb		$s1,SerRcvXon				; skip sending XON if already sent
FFFC1604 81060613
FFFC1608 00060633
FFFC160C 00060203
FFFC1610 04021463			bne		$s1,$x0,.0002
FFFC1614 208000EF			call	SerialRcvCount			; check number of chars in receive buffer
FFFC1618 10300073			pfi
FFFC161C 00882813			slt		$v0,$v0,#8					; less than 8?
FFFC1620 02080C63			beq		$v0,$x0,.0002
FFFC1624 01106813			ldi		$v0,#XON						; if <8 send an XON
FFFC1628 00026637			sb		$x0,SerRcvXoff			; clear XOFF status
FFFC162C 81160613
FFFC1630 00060633
FFFC1634 00060023
FFFC1638 00026637			sb		$v0,SerRcvXon				; flag so we don't send it multiple times
FFFC163C 81060613
FFFC1640 00060633
FFFC1644 01060023
FFFC1648 FFDC1637			sb		$v0,UART+UART_TRB
FFFC164C A0060613
FFFC1650 00060633
FFFC1654 01060023
                        	.0002:
FFFC1658 10300073			pfi
FFFC165C 00026637			lbu		$v1,SerHeadRcv			; check if anything is in buffer
FFFC1660 80060613
FFFC1664 00060633
FFFC1668 00064883
FFFC166C 00026637			lbu		$v0,SerTailRcv
FFFC1670 80460613
FFFC1674 00060633
FFFC1678 00064803
FFFC167C 03180863			beq		$v0,$v1,.noChars		; no?
FFFC1680 00025637			lb		$v0,SerRcvBuf[$v1]	; get byte from buffer
FFFC1684 00060613
FFFC1688 01160633
FFFC168C 00060803
FFFC1690 00188893			add		$v1,$v1,#1					; update head index
FFFC1694 10300073			pfi
FFFC1698 00026637			sb		$v1,SerHeadRcv				
FFFC169C 80060613
FFFC16A0 00060633
FFFC16A4 01160023
FFFC16A8 00000663			bra		.xit
                        	.noChars:
                        	.0001:
FFFC16AC 10300073			pfi
FFFC16B0 FFF06813			ldi		$v0,#-1
                        	.xit
FFFC16B4 10300073			pfi
FFFC16B8 00073083			ldo		$ra,[$sp]
FFFC16BC 00873883			ldo		$v1,8[$sp]
FFFC16C0 01073203			ldo		$s1,16[$sp]
FFFC16C4 01870713			add		$sp,$sp,#24
FFFC16C8 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPeekChar
                        	;
                        	; Check the serial port buffer to see if there's a char available. If there's
                        	; a char available then return it. But don't update the buffer indexes. No need
                        	; to send an XON here.
                        	;
                        	; Stack Space:
                        	;		3 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$v0 = character or -1
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPeekChar:
FFFC16CC FE870713		sub		$sp,$sp,#24
FFFC16D0 00173023		sto		$ra,[$sp]
FFFC16D4 01173423		sto		$v1,8[$sp]
FFFC16D8 00473823		sto		$s1,16[$sp]
FFFC16DC 10300073		pfi
FFFC16E0 00026637		ldbu	$v1,SerHeadRcv			; check if anything is in buffer
FFFC16E4 80060613
FFFC16E8 00060633
FFFC16EC 00064883
FFFC16F0 00026637		ldbu	$v0,SerTailRcv
FFFC16F4 80460613
FFFC16F8 00060633
FFFC16FC 00064803
FFFC1700 01180C63		beq		$v0,$v1,.noChars		; no?
FFFC1704 00025637		ldb		$v0,SerRcvBuf[$v1]	; get byte from buffer
FFFC1708 00060613
FFFC170C 01160633
FFFC1710 00060803
FFFC1714 00000463		bra		.xit
                        	.noChars:
                        	.0001:
FFFC1718 FFF06813		ldi		$v0,#-1
                        	.xit
FFFC171C 10300073		pfi
FFFC1720 00073083		ldo		$ra,[$sp]
FFFC1724 00873883		ldo		$v1,8[$sp]
FFFC1728 01073203		ldo		$s1,16[$sp]
FFFC172C 01870713		add		$sp,$sp,#24
FFFC1730 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPeekChar
                        	;		Get a character directly from the I/O port. This bypasses the input
                        	; buffer.
                        	;
                        	; Stack Space:
                        	;		3 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$v0 = character or -1
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPeekCharDirect:
FFFC1734 FE870713		sub		$sp,$sp,#24
FFFC1738 00173023		sto		$ra,[$sp]
FFFC173C 01173423		sto		$v1,8[$sp]
FFFC1740 00473823		sto		$s1,16[$sp]
FFFC1744 10300073		pfi
FFFC1748 FFDC1637		ldb		$v0,UART+UART_STAT
FFFC174C A0460613
FFFC1750 00060633
FFFC1754 00060803
FFFC1758 00887813		and		$v0,$v0,#8					; look for Rx not empty
FFFC175C 00080C63		beq		$v0,$x0,.0001
FFFC1760 FFDC1637		ldb		$v0,UART+UART_TRB
FFFC1764 A0060613
FFFC1768 00060633
FFFC176C 00060803
FFFC1770 00000463		bra		.xit
                        	.0001:
FFFC1774 FFF06813		ldi		$v0,#-1
                        	.xit:
FFFC1778 10300073		pfi
FFFC177C 00073083		ldo		$ra,[$sp]
FFFC1780 00873883		ldo		$v1,8[$sp]
FFFC1784 01073203		ldo		$s1,16[$sp]
FFFC1788 01870713		add		$sp,$sp,#24
FFFC178C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPutChar
                        	;    Put a character to the serial transmitter. This routine blocks until the
                        	; transmitter is empty. The routine will attempt to transmit the char up to 
                        	; 10 times. If it still can't transmit the char then sleep is called and the
                        	; task is put to sleep for a tick. When it wakes up the routine continues to
                        	; try and send a character.
                        	;
                        	; Stack Space
                        	;		5 words
                        	; Parameters:
                        	;		$a3 = character to put
                        	; Modifies:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPutChar:
FFFC1790 FE870713		sub		$sp,$sp,#24
FFFC1794 01073023		sto		$v0,[$sp]
FFFC1798 00173423		sto		$ra,8[$sp]
FFFC179C 01173823		sto		$v1,16[$sp]
FFFC17A0 10300073		pfi
                        	.0002:
FFFC17A4 00A06893		ldi		$v1,#10
                        	.0001:
                        	;	sub		$v1,$v1,#1
                        	;	beq		$v1,$x0,.goSleep
FFFC17A8 10300073		pfi
FFFC17AC FFDC1637		ldb		$v0,UART+UART_STAT	; wait until the uart indicates tx empty
FFFC17B0 A0460613
FFFC17B4 00060633
FFFC17B8 00060803
FFFC17BC 01087813		and		$v0,$v0,#16					; bit #4 of the status reg
FFFC17C0 FE0804E3		beqz	$v0,.0001						; branch if transmitter is not empty
FFFC17C4 FFDC1637		stb		$a3,UART+UART_TRB		; send the byte
FFFC17C8 A0060613
FFFC17CC 00060633
FFFC17D0 01560023
FFFC17D4 00073803		ldo		$v0,[$sp]
FFFC17D8 00873083		ldo		$ra,8[$sp]
FFFC17DC 01073883		ldo		$v1,16[$sp]
FFFC17E0 10300073		pfi
FFFC17E4 01870713		add		$sp,$sp,#24
FFFC17E8 00008067		ret
                        	.goSleep:
FFFC17EC 10300073		pfi
FFFC17F0 FF070713		sub		$sp,$sp,#16
FFFC17F4 01273023		sto		$a0,[$sp]
FFFC17F8 01373423		sto		$a1,8[$sp]
FFFC17FC 00506913		ldi		$a0,#5							; sleep function
FFFC1800 00106993		ldi		$a1,#1							; 1 tick
FFFC1804 00000073		ecall
FFFC1808 10300073		pfi
FFFC180C 00073903		ldo		$a0,[$sp]
FFFC1810 00873983		ldo		$a1,8[$sp]
FFFC1814 01070713		add		$sp,$sp,#16
FFFC1818 F80006E3		bra		.0002
                        	
                        	;------------------------------------------------------------------------------
                        	; Calculate number of character in input buffer
                        	;------------------------------------------------------------------------------
                        	
                        	SerialRcvCount:
FFFC181C 00026637		ldbu	$v0,SerTailRcv	; v0 = tail index
FFFC1820 80460613
FFFC1824 00060633
FFFC1828 00064803
FFFC182C 00026637		ldbu	$v1,SerHeadRcv	; v1 = head index
FFFC1830 80060613
FFFC1834 00060633
FFFC1838 00064883
FFFC183C 41180D33		sub		$t0,$v0,$v1
FFFC1840 000D5863		bge		$t0,$x0,.xit
FFFC1844 10006D13		ldi		$t0,#256
FFFC1848 411D0D33		sub		$t0,$t0,$v1
FFFC184C 010D0D33		add		$t0,$t0,$v0
                        	.xit:
FFFC1850 000D6833		mov		$v0,$t0
FFFC1854 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	SerialIRQ:
                        	.nxtByte:
FFFC1858 00897D13		and		$t0,$a0,#$08				; bit 3 = rx full
FFFC185C 0C0D0063		beq		$t0,$x0,.notRxInt
FFFC1860 FFDC1637		ldt		$a1,UART+UART_TRB		; get data from Rx buffer to clear interrupt
FFFC1864 A0060613
FFFC1868 00060633
FFFC186C 00062983
FFFC1870 00026637		ldbu	$t2,SerHeadRcv			; get buffer indexes
FFFC1874 80060613
FFFC1878 00060633
FFFC187C 00064E03
FFFC1880 00026637		ldbu	$t3,SerTailRcv
FFFC1884 80460613
FFFC1888 00060633
FFFC188C 00064E83
FFFC1890 001E8E93		add		$t3,$t3,#1					; see if buffer full
FFFC1894 0FFEFE93		and		$t3,$t3,#255
FFFC1898 09DE0263		beq		$t2,$t3,.rxFull
FFFC189C 00026637		stb		$t3,SerTailRcv			; update tail pointer
FFFC18A0 80460613
FFFC18A4 00060633
FFFC18A8 01D60023
FFFC18AC FFFE8E93		sub		$t3,$t3,#1
FFFC18B0 0FFEFE13		and		$t2,$t3,#255
FFFC18B4 00025637		stb		$a1,SerRcvBuf[$t2]	; store recieved byte in buffer
FFFC18B8 00060613
FFFC18BC 01C60633
FFFC18C0 01360023
FFFC18C4 00026637		ldb		$v0,SerRcvXoff			; check if xoff already sent
FFFC18C8 81160613
FFFC18CC 00060633
FFFC18D0 00060803
FFFC18D4 02081A63		bne		$v0,$x0,.0001
FFFC18D8 F45FF0EF		call	SerialRcvCount			; if more than 240 chars in buffer
FFFC18DC 0F082813		slt		$v0,$v0,#240				; send an XOFF
FFFC18E0 02081463		bne		$v0,$x0,.0001
FFFC18E4 01306913		ldi		$a0,#XOFF
FFFC18E8 00026637		stb		$x0,SerRcvXon				; clear XON status
FFFC18EC 81060613
FFFC18F0 00060633
FFFC18F4 00060023
FFFC18F8 00026637		stb		$a0,SerRcvXoff			; set XOFF status
FFFC18FC 81160613
FFFC1900 00060633
FFFC1904 01260023
                        		stb		UART+UART_TRB
                        	.0001:
FFFC1908 FFDC1637		ldt		$a0,UART+UART_STAT	; check the status for another byte
FFFC190C A0460613
FFFC1910 00060633
FFFC1914 00062903
FFFC1918 F40000E3		bra		.nxtByte
                        	;	ldi		$a0,#$0B						; dtr,rts active, rxint disabled, no parity
                        	;	sw		$a0,UART+UART_CMD
                        	.rxFull:
                        	.notRxInt:
FFFC191C 79217073		csrrc	$x0,#$792,#2			; clear IRQ semaphore
FFFC1920 10000073		eret
                        	
                        	nmeSerial:
FFFC1924 69726553		db		"Serial",0
FFFC1928 00006C61
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/via.r5a",1
                        	.file "../fmtk/via.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
FFFC192B 00000000		align	
FFFC192F 00000000
                        	
                        	ViaFuncTbl:
FFFC1930 00000000		dco		0							; no operation
FFFC1934 00000000
FFFC1938 00000000		dco		0							; setup
FFFC193C 00000000
FFFC1940 00000000		dco		0							; initialize
FFFC1944 00000000
FFFC1948 00000000		dco		0							; status
FFFC194C 00000000
FFFC1950 00000000		dco		0							; media check
FFFC1954 00000000
FFFC1958 00000000		dco		0							; build BPB
FFFC195C 00000000
FFFC1960 00000000		dco		0							; open
FFFC1964 00000000
FFFC1968 00000000		dco		0							; close
FFFC196C 00000000
FFFC1970 00000000		dco		0							; get char
FFFC1974 00000000
FFFC1978 00000000		dco		0							; Peek char
FFFC197C 00000000
FFFC1980 00000000		dco		0							; get char direct
FFFC1984 00000000
FFFC1988 00000000		dco		0							; peek char direct
FFFC198C 00000000
FFFC1990 00000000		dco		0							; input status
FFFC1994 00000000
FFFC1998 00000000		dco		0							; Put char
FFFC199C 00000000
FFFC19A0 00000000		dco		0							; reserved
FFFC19A4 00000000
FFFC19A8 00000000		dco		0							; set position
FFFC19AC 00000000
FFFC19B0 00000000		dco		0							; read block
FFFC19B4 00000000
FFFC19B8 00000000		dco		0							; write block
FFFC19BC 00000000
FFFC19C0 00000000		dco		0							; verify block
FFFC19C4 00000000
FFFC19C8 00000000		dco		0							; output status
FFFC19CC 00000000
FFFC19D0 00000000		dco		0							; flush input
FFFC19D4 00000000
FFFC19D8 00000000		dco		0							; flush output
FFFC19DC 00000000
FFFC19E0 FFFC1A98		dco		ViaIRQ				; IRQ routine
FFFC19E4 00000000
FFFC19E8 00000000		dco		0							; Is removable
FFFC19EC 00000000
FFFC19F0 00000000		dco		0							; ioctrl read
FFFC19F4 00000000
FFFC19F8 00000000		dco		0							; ioctrl write
FFFC19FC 00000000
FFFC1A00 00000000		dco		0							; output until busy
FFFC1A04 00000000
FFFC1A08 00000000		dco		0							; 27
FFFC1A0C 00000000
FFFC1A10 00000000		dco		0
FFFC1A14 00000000
FFFC1A18 00000000		dco		0
FFFC1A1C 00000000
FFFC1A20 00000000		dco		0
FFFC1A24 00000000
FFFC1A28 00000000		dco		0							; 31
FFFC1A2C 00000000
                        	
                        	;------------------------------------------------------------------------------
                        	; ViaInit
                        	;
                        	; Initialize the versatile interface adapter.
                        	;------------------------------------------------------------------------------
                        	
                        	ViaInit:
FFFC1A30 FF870713		sub		$sp,$sp,#8
FFFC1A34 00173023		sto		$ra,[$sp]
FFFC1A38 00F06913		ldi		$a0,#15							; VIA device
FFFC1A3C FFFC29B7		ldi		$a1,#ViaFuncTbl
FFFC1A40 93098993
FFFC1A44 10300073		pfi
FFFC1A48 038020EF		call	CopyDevFuncTbl
                        		; Initialize port A low order eight bits as output, the remaining bits as
                        		; input.
FFFC1A4C FFDC0DB7		ldi		$t1,#VIA
FFFC1A50 600D8D93
FFFC1A54 0FF06D13		ldi		$t0,#$000000FF
FFFC1A58 01ADA623		stt		$t0,VIA_DDRA[$t1]
FFFC1A5C 00106D13		ldi		$t0,#1							; select timer 3 access
FFFC1A60 10300073		pfi
FFFC1A64 03AD88A3		stb		$t0,VIA_PCR+1[$t1]
FFFC1A68 01F06D13		ldi		$t0,#$1F
FFFC1A6C 03AD86A3		stb		$t0,VIA_ACR+1[$t1]		; set timer 3 mode, timer 1/2 = 64 bit
FFFC1A70 0016ED37		ldi		$t0,#$0016E360			;	divider value for 33.333Hz (30 ms)
FFFC1A74 360D0D13
FFFC1A78 01ADA823		stt		$t0,VIA_T1CL[$t1]
FFFC1A7C 000DAA23		stt		$x0,VIA_T1CH[$t1]		; trigger transfer to count registers
FFFC1A80 10300073		pfi
FFFC1A84 18006D13		ldi		$t0,#$180						; enable timer3 interrupts
FFFC1A88 03ADAC23		stt		$t0,VIA_IER[$t1]
FFFC1A8C 00073083		ldo		$ra,[$sp]
FFFC1A90 00870713		add		$sp,$sp,#8
FFFC1A94 00008067		ret
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	; Only one cpu need reset the VIA timer.
                        	;------------------------------------------------------------------------------
                        	
                        	ViaIRQ:
FFFC1A98 F1001DF3		csrrw	$t1,#$F10,$x0
FFFC1A9C 040D9A63		bnez	$t1,.hart20
                        		; Was it the VIA that caused the interrupt?
FFFC1AA0 FFDC0DB7		ldi		$t1,#VIA
FFFC1AA4 600D8D93
FFFC1AA8 034D8D03		ldb		$t0,VIA_IFR[$t1]
FFFC1AAC 040D5463		bge		$t0,$x0,.0003				; no
FFFC1AB0 00106D13		ldi		$t0,#1							; select timer 3 access
FFFC1AB4 03AD88A3		stb		$t0,VIA_PCR+1[$t1]
FFFC1AB8 010DAD03		ldt		$t0,VIA_T1CL[$t1]		; yes, clear interrupt
FFFC1ABC 00014637		ldo		$t0,milliseconds
FFFC1AC0 20860613
FFFC1AC4 00060633
FFFC1AC8 00063D03
FFFC1ACC 01ED0D13		add		$t0,$t0,#30
FFFC1AD0 00014637		sto		$t0,milliseconds
FFFC1AD4 20860613
FFFC1AD8 00060633
FFFC1ADC 01A63023
FFFC1AE0 00014637		stt		$t0,switchflag
FFFC1AE4 20060613
FFFC1AE8 00060633
FFFC1AEC 01A62023
                        	.hart20:
FFFC1AF0 4DD000EF		call	FMTK_SchedulerIRQ
                        	.0003:
FFFC1AF4 79217073		csrrc	$x0,#$792,#2			; clear IRQ semaphore
FFFC1AF8 10000073		eret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/video.r5a",1
                        	.file "../fmtk/video.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	TC64CursorAddr	equ		$FFD1DF1C
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
FFFC1AFC 00000000		align	
                        	
                        	VideoFuncTbl:
FFFC1B00 00000000		dco		0							; no operation
FFFC1B04 00000000
FFFC1B08 00000000		dco		0							; setup
FFFC1B0C 00000000
FFFC1B10 00000000		dco		0							; initialize
FFFC1B14 00000000
FFFC1B18 00000000		dco		0							; status
FFFC1B1C 00000000
FFFC1B20 00000000		dco		0							; media check
FFFC1B24 00000000
FFFC1B28 00000000		dco		0							; build BPB
FFFC1B2C 00000000
FFFC1B30 00000000		dco		0							; open
FFFC1B34 00000000
FFFC1B38 00000000		dco		0							; close
FFFC1B3C 00000000
FFFC1B40 00000000		dco		0							; get char
FFFC1B44 00000000
FFFC1B48 00000000		dco		0							; Peek char
FFFC1B4C 00000000
FFFC1B50 00000000		dco		0							; get char direct
FFFC1B54 00000000
FFFC1B58 00000000		dco		0							; peek char direct
FFFC1B5C 00000000
FFFC1B60 00000000		dco		0							; input status
FFFC1B64 00000000
FFFC1B68 FFFC1D2C		dco		VideoPutChar	; Put char
FFFC1B6C 00000000
FFFC1B70 00000000		dco		0							; reserved
FFFC1B74 00000000
FFFC1B78 00000000		dco		0							; set position
FFFC1B7C 00000000
FFFC1B80 00000000		dco		0							; read block
FFFC1B84 00000000
FFFC1B88 00000000		dco		0							; write block
FFFC1B8C 00000000
FFFC1B90 00000000		dco		0							; verify block
FFFC1B94 00000000
FFFC1B98 00000000		dco		0							; output status
FFFC1B9C 00000000
FFFC1BA0 00000000		dco		0							; flush input
FFFC1BA4 00000000
FFFC1BA8 00000000		dco		0							; flush output
FFFC1BAC 00000000
FFFC1BB0 FFFC20F0		dco		VideoIRQ			; IRQ routine
FFFC1BB4 00000000
FFFC1BB8 00000000		dco		0							; Is removable
FFFC1BBC 00000000
FFFC1BC0 00000000		dco		0							; ioctrl read
FFFC1BC4 00000000
FFFC1BC8 00000000		dco		0							; ioctrl write
FFFC1BCC 00000000
FFFC1BD0 00000000		dco		0							; output until busy
FFFC1BD4 00000000
FFFC1BD8 00000000		dco		0							; 27
FFFC1BDC 00000000
FFFC1BE0 00000000		dco		0
FFFC1BE4 00000000
FFFC1BE8 00000000		dco		0
FFFC1BEC 00000000
FFFC1BF0 00000000		dco		0
FFFC1BF4 00000000
FFFC1BF8 00000000		dco		0							; 31
FFFC1BFC 00000000
                        	
                        	;------------------------------------------------------------------------------
                        	; VideoInit
                        	;
                        	; Initialize the versatile interface adapter.
                        	;------------------------------------------------------------------------------
                        	
                        	VideoInit:
FFFC1C00 FF870713		sub		$sp,$sp,#8
FFFC1C04 00173023		sto		$ra,[$sp]
FFFC1C08 00206913		ldi		$a0,#2							; Video device
FFFC1C0C FFFC29B7		ldi		$a1,#VideoFuncTbl
FFFC1C10 B0098993
FFFC1C14 10300073		pfi
FFFC1C18 669010EF		call	CopyDevFuncTbl
FFFC1C1C 00025637		stb		$x0,CursorX
FFFC1C20 80060613
FFFC1C24 00060633
FFFC1C28 00060023
FFFC1C2C 00025637		stb		$x0,CursorY
FFFC1C30 80160613
FFFC1C34 00060633
FFFC1C38 00060023
FFFC1C3C 000F0D37		ldi		$t0,#$000F0000
FFFC1C40 000D0D13
FFFC1C44 00025637		stt		$t0,DispAttr
FFFC1C48 80860613
FFFC1C4C 00060633
FFFC1C50 01A62023
FFFC1C54 00210D37		ldi		$t0,#$0020FFFF
FFFC1C58 FFFD0D13
FFFC1C5C 00025637		stt		$t0,DispAttr+4
FFFC1C60 80C60613
FFFC1C64 00060633
FFFC1C68 01A62023
FFFC1C6C 10300073		pfi
FFFC1C70 010000EF		call	VideoClearScreen
FFFC1C74 00073083		ldo		$ra,[$sp]
FFFC1C78 00870713		add		$sp,$sp,#8
FFFC1C7C 00008067		ret
                        	
                        	VideoClearScreen:
                        	;	csrrs	$x0,#$300,#1				; interrupts on
FFFC1C80 65806D13		ldi		$t0,#56*29
FFFC1C84 00025637		ldo		$t1,DispAttr
FFFC1C88 80860613
FFFC1C8C 00060633
FFFC1C90 00063D83
FFFC1C94 020DED93		or		$t1,$t1,#' '
                        		
                        		
FFFC1C98 18101873		csrrw	v0,#$181,x0
FFFC1C9C 01F87813		and		v0,v0,#MAX_TID
FFFC1CA0 00A81813	sll		$v0,$v0,#LOG_TCBSZ
FFFC1CA4 33883803		ldo		$v0,TCBpVideo[$v0]
FFFC1CA8 FFD00837		ldi		$v0,#$FFD00000
FFFC1CAC 00080813
                        	.0001:
FFFC1CB0 10300073		pfi
FFFC1CB4 01B83023		sto		$t1,[$v0]	
FFFC1CB8 00880813		add		$v0,$v0,#8
FFFC1CBC FFFD0D13		sub		$t0,$t0,#1
FFFC1CC0 FFA048E3		bgt		$t0,$x0,.0001
FFFC1CC4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	VideoHomeCursor:
FFFC1CC8 00025637		stb		$x0,CursorX
FFFC1CCC 80060613
FFFC1CD0 00060633
FFFC1CD4 00060023
FFFC1CD8 00025637		stb		$x0,CursorY
FFFC1CDC 80160613
FFFC1CE0 00060633
FFFC1CE4 00060023
                        		; fall through into update cursor pos.
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	UpdateCursorPos:
FFFC1CE8 00025637		ldbu	$t0,CursorY
FFFC1CEC 80160613
FFFC1CF0 00060633
FFFC1CF4 00064D03
FFFC1CF8 03806D93		ldi		$t1,#56
FFFC1CFC 10300073		pfi
FFFC1D00 03BD0D33		mul		$t0,$t0,$t1
FFFC1D04 00025637		ldbu	$t1,CursorX
FFFC1D08 80060613
FFFC1D0C 00060633
FFFC1D10 00064D83
FFFC1D14 01BD0D33		add		$t0,$t0,$t1
FFFC1D18 FFD1E637		stw		$t0,TC64CursorAddr
FFFC1D1C F1C60613
FFFC1D20 00060633
FFFC1D24 01A61023
FFFC1D28 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a3 = character to display
                        	;------------------------------------------------------------------------------
                        	
                        	VideoPutChar:
FFFC1D2C FF070713		sub		$sp,$sp,#16
FFFC1D30 00173023		sto		$ra,[$sp]
FFFC1D34 00473423		sto		$s1,8[$sp]
FFFC1D38 00D06D13		ldi		$t0,#CR
FFFC1D3C 10300073		pfi
FFFC1D40 1BAA8463		beq		$a3,$t0,.doCR
FFFC1D44 00A06D13		ldi		$t0,#$0A				; line feed
FFFC1D48 1BAA8E63		beq		$a3,$t0,.doLF
FFFC1D4C 00C06D13		ldi		$t0,#$0C				; CTRL-L
FFFC1D50 29AA8663		beq		$a3,$t0,.doCls
FFFC1D54 09106D13		ldi		$t0,#$91
FFFC1D58 10300073		pfi
FFFC1D5C 1BAA8E63		beq		$a3,$t0,.cursorRight
FFFC1D60 09306D13		ldi		$t0,#$93
FFFC1D64 1FAA8863		beq		$a3,$t0,.cursorLeft
FFFC1D68 09006D13		ldi		$t0,#$90
FFFC1D6C 21AA8A63		beq		$a3,$t0,.cursorUp
FFFC1D70 09206D13		ldi		$t0,#$92
FFFC1D74 10300073		pfi
FFFC1D78 23AA8A63		beq		$a3,$t0,.cursorDown
FFFC1D7C 00806D13		ldi		$t0,#BS
FFFC1D80 27AA8863		beq		$a3,$t0,.backspace
FFFC1D84 09906D13		ldi		$t0,#$99
FFFC1D88 31AA8663		beq		$a3,$t0,.delete
FFFC1D8C 10300073		pfi
                        		
                        		
FFFC1D90 18101873		csrrw	v0,#$181,x0
FFFC1D94 01F87813		and		v0,v0,#MAX_TID
FFFC1D98 00A81813	sll		$v0,$v0,#LOG_TCBSZ
FFFC1D9C 33883803		ldo		$v0,TCBpVideo[$v0]
FFFC1DA0 FFD00837		ldi		$v0,#$FFD00000
FFFC1DA4 00080813
FFFC1DA8 00086D33	mov		$t0,$v0
FFFC1DAC 00025637		ldbu	$t1,CursorX
FFFC1DB0 80060613
FFFC1DB4 00060633
FFFC1DB8 00064D83
FFFC1DBC 003D9D93		sll		$t1,$t1,#3						; *8 bytes per display cell
FFFC1DC0 01BD6D33		or		$t0,$t0,$t1						; add in base address
FFFC1DC4 00025637		ldbu	$t1,CursorY
FFFC1DC8 80160613
FFFC1DCC 00060633
FFFC1DD0 00064D83
FFFC1DD4 10300073		pfi
FFFC1DD8 1C006E13		ldi		$t2,#56*8
FFFC1DDC 03CD8DB3		mul		$t1,$t1,$t2
FFFC1DE0 01BD0D33		add		$t0,$t0,$t1
FFFC1DE4 00025637		ldo		$t1,DispAttr
FFFC1DE8 80860613
FFFC1DEC 00060633
FFFC1DF0 00063D83
FFFC1DF4 10300073		pfi
FFFC1DF8 015DEDB3		or		$t1,$t1,$a3
FFFC1DFC 01BD3023		sto		$t1,[$t0]							; store to screen memory
FFFC1E00 00025637		ldbu	$t0,CursorX						; increment cursor position
FFFC1E04 80060613
FFFC1E08 00060633
FFFC1E0C 00064D03
FFFC1E10 001D0D13		add		$t0,$t0,#1
FFFC1E14 03806D93		ldi		$t1,#56
FFFC1E18 10300073		pfi
FFFC1E1C 0BBD4863		blt		$t0,$t1,.saveX
FFFC1E20 00006D13		ldi		$t0,#0
                        	.doLF1:
FFFC1E24 10300073		pfi
FFFC1E28 00025637		ldbu	$t2,CursorY
FFFC1E2C 80160613
FFFC1E30 00060633
FFFC1E34 00064E03
FFFC1E38 001E0E13		add		$t2,$t2,#1
FFFC1E3C 01D06D93		ldi		$t1,#29
FFFC1E40 07BE4E63		blt		$t2,$t1,.saveY
                        		; scroll up
FFFC1E44 62006E93		ldi		$t3,#56*28
                        		
                        		
FFFC1E48 18101873		csrrw	v0,#$181,x0
FFFC1E4C 01F87813		and		v0,v0,#MAX_TID
FFFC1E50 00A81813	sll		$v0,$v0,#LOG_TCBSZ
FFFC1E54 33883803		ldo		$v0,TCBpVideo[$v0]
FFFC1E58 FFD00837		ldi		$v0,#$FFD00000
FFFC1E5C 00080813
                        	;	ldi		$t4,#$FFD00000
FFFC1E60 00086F33		mov		$t4,$v0
                        	.0001:
FFFC1E64 10300073		pfi
FFFC1E68 1C0F3F83		ldo		$t5,56*8[$t4]
FFFC1E6C 01FF3023		sto		$t5,[$t4]
FFFC1E70 008F0F13		add		$t4,$t4,#8
FFFC1E74 FFFE8E93		sub		$t3,$t3,#1
FFFC1E78 FFD046E3		bgt		$t3,$x0,.0001
                        		; blank last line
FFFC1E7C 00025637		ldo		$t5,DispAttr
FFFC1E80 80860613
FFFC1E84 00060633
FFFC1E88 00063F83
FFFC1E8C 020FEF93		or		$t5,$t5,#' '
FFFC1E90 03806E93		ldi		$t3,#56
                        	.bll1:
FFFC1E94 10300073		pfi
FFFC1E98 01FF3023		sto		$t5,[$t4]
FFFC1E9C 008F0F13		add		$t4,$t4,#8
FFFC1EA0 FFFE8E93		sub		$t3,$t3,#1
FFFC1EA4 FFD048E3		bgt		$t3,$x0,.bll1
                        	.xit:
FFFC1EA8 10300073		pfi
FFFC1EAC 00073083		ldo		$ra,[$sp]
FFFC1EB0 00873203		ldo		$s1,8[$sp]
FFFC1EB4 01070713		add		$sp,$sp,#16
FFFC1EB8 00008067		ret
                        	.saveY:
FFFC1EBC 00025637		stb		$t2,CursorY
FFFC1EC0 80160613
FFFC1EC4 00060633
FFFC1EC8 01C60023
                        	.saveX:
FFFC1ECC 10300073		pfi
FFFC1ED0 00025637		stb		$t0,CursorX
FFFC1ED4 80060613
FFFC1ED8 00060633
FFFC1EDC 01A60023
FFFC1EE0 E09FF0EF		call	UpdateCursorPos
FFFC1EE4 FC0002E3		bra		.xit
                        	.doCR:
FFFC1EE8 00025637		stb		$x0,CursorX
FFFC1EEC 80060613
FFFC1EF0 00060633
FFFC1EF4 00060023
FFFC1EF8 10300073		pfi
FFFC1EFC DEDFF0EF		call	UpdateCursorPos
FFFC1F00 FA0004E3		bra		.xit
                        	.doLF:
FFFC1F04 00025637		ldbu	$t0,CursorX
FFFC1F08 80060613
FFFC1F0C 00060633
FFFC1F10 00064D03
FFFC1F14 F00008E3		bra		.doLF1
                        	.cursorRight:
FFFC1F18 10300073		pfi
FFFC1F1C 00025637		ldbu	$t0,CursorX
FFFC1F20 80060613
FFFC1F24 00060633
FFFC1F28 00064D03
FFFC1F2C 001D0D13		add		$t0,$t0,#1
FFFC1F30 03706D93		ldi		$t1,#55
FFFC1F34 01BD5E63		bge		$t0,$t1,.cr1
FFFC1F38 00025637		stb		$t0,CursorX
FFFC1F3C 80060613
FFFC1F40 00060633
FFFC1F44 01A60023
                        	.cr2:
FFFC1F48 10300073		pfi
FFFC1F4C D9DFF0EF		call	UpdateCursorPos
                        	.cr1:
FFFC1F50 F4000CE3		bra		.xit
                        	.cursorLeft:
FFFC1F54 00025637		ldbu	$t0,CursorX
FFFC1F58 80060613
FFFC1F5C 00060633
FFFC1F60 00064D03
FFFC1F64 FFFD0D13		sub		$t0,$t0,#1
FFFC1F68 FE0D44E3		blt		$t0,$x0,.cr1
FFFC1F6C 00025637		stb		$t0,CursorX
FFFC1F70 80060613
FFFC1F74 00060633
FFFC1F78 01A60023
FFFC1F7C FC0006E3		bra		.cr2
                        	.cursorUp:
FFFC1F80 00025637		ldbu	$t0,CursorY
FFFC1F84 80160613
FFFC1F88 00060633
FFFC1F8C 00064D03
FFFC1F90 FFFD0D13		sub		$t0,$t0,#1
FFFC1F94 FA0D4EE3		blt		$t0,$x0,.cr1
FFFC1F98 00025637		stb		$t0,CursorY
FFFC1F9C 80160613
FFFC1FA0 00060633
FFFC1FA4 01A60023
FFFC1FA8 FA0000E3		bra		.cr2
                        	.cursorDown:
FFFC1FAC 00025637		ldbu	$t0,CursorY
FFFC1FB0 80160613
FFFC1FB4 00060633
FFFC1FB8 00064D03
FFFC1FBC 001D0D13		add		$t0,$t0,#1
FFFC1FC0 01D06D93		ldi		$t1,#29
FFFC1FC4 F9BD56E3		bge		$t0,$t1,.cr1
FFFC1FC8 00025637		stb		$t0,CursorY
FFFC1FCC 80160613
FFFC1FD0 00060633
FFFC1FD4 01A60023
FFFC1FD8 F60008E3		bra		.cr2
                        	.doCls:
FFFC1FDC 10300073		pfi
FFFC1FE0 CA1FF0EF		call	VideoClearScreen
FFFC1FE4 CE5FF0EF		call	VideoHomeCursor
FFFC1FE8 10300073		pfi
FFFC1FEC F60002E3		bra		.cr1
                        	.backspace:
FFFC1FF0 00025637		ldbu	$t0,CursorX
FFFC1FF4 80060613
FFFC1FF8 00060633
FFFC1FFC 00064D03
FFFC2000 F40D08E3		beqz	$t0,.cr1
FFFC2004 FFFD0D13		sub		$t0,$t0,#1
FFFC2008 00025637		stb		$t0,CursorX
FFFC200C 80060613
FFFC2010 00060633
FFFC2014 01A60023
                        	.del0001:
FFFC2018 10300073		pfi
FFFC201C 03706213		ldi		$s1,#55
FFFC2020 41A20233		sub		$s1,$s1,$t0
FFFC2024 CC5FF0EF		call	UpdateCursorPos
FFFC2028 10300073		pfi
FFFC202C 00025637		ldbu	$t1,CursorY
FFFC2030 80160613
FFFC2034 00060633
FFFC2038 00064D83
FFFC203C 1C006E93		ldi		$t3,#56*8
FFFC2040 03DD8DB3		mul		$t1,$t1,$t3
FFFC2044 003D1D13		sll		$t0,$t0,#3
FFFC2048 01AD8EB3		add		$t3,$t1,$t0
FFFC204C FFD00637		add		$t3,$t3,#$FFD00000
FFFC2050 00060613
FFFC2054 01D60EB3
FFFC2058 00020E63		beqz	$s1,.bs0001
                        	.bs0002:
FFFC205C 10300073		pfi
FFFC2060 008EBF03		ldo		$t4,8[$t3]
FFFC2064 01EEB023		sto		$t4,[$t3]
FFFC2068 008E8E93		add		$t3,$t3,#8
FFFC206C FFF20213		sub		$s1,$s1,#1
FFFC2070 FFFFC6E3		bgt		$s1,.bs0002
                        	.bs0001:
FFFC2074 10300073		pfi
FFFC2078 00025637		ldo		$t4,DispAttr
FFFC207C 80860613
FFFC2080 00060633
FFFC2084 00063F03
FFFC2088 020F6F13		or		$t4,$t4,#' '
FFFC208C 01EEB423		sto		$t4,8[$t3]
FFFC2090 E0000CE3		bra		.xit
                        	.delete:
FFFC2094 00025637		ldbu	$t0,CursorX
FFFC2098 80060613
FFFC209C 00060633
FFFC20A0 00064D03
FFFC20A4 10300073		pfi
FFFC20A8 F60008E3		bra		.del0001	
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1  = pointer to null terminated string
                        	;------------------------------------------------------------------------------
                        	
                        	VideoPutString:
FFFC20AC FF870713		sub		$sp,$sp,#8
FFFC20B0 00173023		sto		$ra,[$sp]
                        	.again:
FFFC20B4 10300073		pfi
FFFC20B8 00010D37		ldi		$t0,#$10000
FFFC20BC 000D0D13
FFFC20C0 300D2073		csrrs	$x0,#$300,$t0		; set mprv
FFFC20C4 0009CA83		ldbu	$a3,[$a1]				; access using passed in memory space
FFFC20C8 300D3073		csrrc	$x0,#$300,$t0		; clear mprv
FFFC20CC 00198993		add		$a1,$a1,#1
FFFC20D0 000A8863		beqz	$a3,.done
FFFC20D4 10300073		pfi
FFFC20D8 C55FF0EF		call	VideoPutChar
FFFC20DC FC000CE3		bra		.again
                        	.done:
FFFC20E0 10300073		pfi
FFFC20E4 00073083		ldo		$ra,[$sp]
FFFC20E8 00870713		add		$sp,$sp,#8
FFFC20EC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	VideoIRQ:
                        		; Was it the Video that caused the interrupt?
                        	.0003:
FFFC20F0 10000073		eret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/task.r5a",1
                        	.file "../fmtk/task.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../fmtk/task.r5a",25
                        		code
                        		align	2                        	
                        	OSCallTbl:
FFFC20F4 29D401CA		dh		FMTK_Initialize					; 0
FFFC20F6 2B5829D4		dh		FMTK_StartTask					; 1
FFFC20F8 2B882B58		dh		FMTK_ExitTask
FFFC20FA 01CE2B88		dh		FMTK_KillTask
FFFC20FC 266001CE		dh		FMTK_SetTaskPriority
FFFC20FE 2CF82660		dh		FMTK_Sleep							; 5
FFFC2100 2DC82CF8		dh		FMTK_AllocMbx
FFFC2102 01D22DC8		dh		FMTK_FreeMbx
FFFC2104 2EAC01D2		dh		FMTK_PostMsg
FFFC2106 31502EAC		dh		FMTK_SendMsg
FFFC2108 30203150		dh		FMTK_WaitMsg						; 10
FFFC210A 01D63020		dh		FMTK_PeekMsg
FFFC210C 236401D6		dh		FMTK_StartApp
FFFC210E 229C2364		dh		FMTK_SaveContext				; 13
FFFC2110 35B0229C		dh		FMTK_GetCurrentTid
FFFC2112 000035B0		dh		DumpReadyList
FFFC2114 00000000		dh		0
FFFC2116 00000000		dh		0
FFFC2118 00000000		dh		0
FFFC211A 37A00000		dh		0
FFFC211C 380037A0		dh		FMTK_HasIOFocus					; 20
FFFC211E 39503800		dh		FMTK_SwitchIOFocus			; 21
FFFC2120 395C3950		dh		FMTK_ReleaseIOFocus			; 22
FFFC2122 38B8395C		dh		FMTK_ForceReleaseIOFocus	; 23
FFFC2124 000038B8		dh		FMTK_RequestIOFocus			; 24
FFFC2126 3A380000		dh		0
FFFC2128 00003A38		dh		FMTK_IO									; 26
                        	
                        	qToChk:
FFFC212A 01000000		db	0,0,0,1,0,0,2,1
FFFC212E 01020000
FFFC2132 01030000		db	0,0,3,1,0,0,2,1
FFFC2136 01020000
FFFC213A 01000000		db	0,0,0,1,0,0,2,1
FFFC213E 01020000
FFFC2142 01030000		db	0,0,3,1,0,0,2,1
FFFC2146 01020000
                        	
FFFC214A 46370000		align	
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FMTKInit:
FFFC214C 00024637		stt		$x0,QNDX
FFFC2150 30460613
FFFC2154 00060633
FFFC2158 00062023
FFFC215C F0000D37		ldi		$t0,#$F0000000
FFFC2160 000D0D13
FFFC2164 00024637		sto		$t0,PIDMAP
FFFC2168 31060613
FFFC216C 00060633
FFFC2170 01A63023
FFFC2174 00024637		stt		$x0,missed_ticks
FFFC2178 32060613
FFFC217C 00060633
FFFC2180 00062023
FFFC2184 FFF06D13		ldi		$t0,#-1
FFFC2188 00024637		stt		$t0,TimeoutList
FFFC218C 32860613
FFFC2190 00060633
FFFC2194 01A62023
FFFC2198 00024637		stt		$t0,READYQ
FFFC219C 30860613
FFFC21A0 00060633
FFFC21A4 01A62023
FFFC21A8 00024637		stt		$t0,READYQ+4
FFFC21AC 30C60613
FFFC21B0 00060633
FFFC21B4 01A62023
FFFC21B8 00025637		stw		$t0,hKeybdMbx
FFFC21BC 82260613
FFFC21C0 00060633
FFFC21C4 01A61023
FFFC21C8 10300073		pfi
FFFC21CC 00025637		stb		$x0,SwitchIOFocus	
FFFC21D0 82060613
FFFC21D4 00060633
FFFC21D8 00060023
FFFC21DC 00025637		stt		$x0,IOFocusTbl
FFFC21E0 81860613
FFFC21E4 00060633
FFFC21E8 00062023
FFFC21EC 00025637		stt		$t0,IOFocusNdx
FFFC21F0 81060613
FFFC21F4 00060633
FFFC21F8 01A62023
                        	
                        		; zero out device function table
FFFC21FC 00022D37		ldi		$t0,#DVF_Base
FFFC2200 000D0D13
FFFC2204 40006D93		ldi		$t1,#32*32
                        	.0003:
FFFC2208 10300073		pfi
FFFC220C 000D3023		sto		$x0,[$t0]
FFFC2210 008D0D13		add		$t0,$t0,#8
FFFC2214 FFFD8D93		sub		$t1,$t1,#1
FFFC2218 FFB048E3		bgt		$t1,$x0,.0003
                        	
                        		; Initialize mailboxes
FFFC221C 00020D37		ldi		$t0,#mbxs
FFFC2220 000D0D13
FFFC2224 08006D93		ldi		$t1,#4*32
                        	.0001:
FFFC2228 10300073		pfi
FFFC222C 000D3023		sto		$x0,[$t0]
FFFC2230 008D0D13		add		$t0,$t0,#8
FFFC2234 FFFD8D93		sub		$t1,$t1,#1
FFFC2238 FFB048E3		bgt		$t1,$x0,.0001
                        	
                        		; Initialize free message list
FFFC223C 00010D37		ldi		$t0,#msgs
FFFC2240 000D0D13
FFFC2244 00024637		sto		$t0,FreeMsg
FFFC2248 35060613
FFFC224C 00060633
FFFC2250 01A63023
FFFC2254 00006D93		ldi		$t1,#0
FFFC2258 00001E37		ldi		$t2,#NR_MSG
FFFC225C 800E0E13
                        	.0002:
FFFC2260 10300073		pfi
FFFC2264 001D8D93		add		$t1,$t1,#1
FFFC2268 01BD3023		sto		$t1,MSG_LINK[$t0]
FFFC226C 020D0D13		add		$t0,$t0,#32
FFFC2270 FFFE0E13		sub		$t2,$t2,#1
FFFC2274 FFC046E3		bgt		$t2,$x0,.0002
                        	
                        		; unlock the system semaphore	
                        		
FFFC2278 FFF06813		ldi		v0,#-1
FFFC227C 00024637		sw		v0,SysSema
FFFC2280 34060613
FFFC2284 00060633
FFFC2288 01062023
                        	
FFFC228C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Get the task id for the currently running task.
                        	;
                        	; Returns:
                        	;		v0 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	GetCurrentTid:
FFFC2290 18101873		csrrw	$v0,#$181,$x0				; get current asid
FFFC2294 01F87813		and		$v0,$v0,#MAX_TID		; mask off extra bits
FFFC2298 00008067		ret
                        	
                        	FMTK_GetCurrentTid:
FFFC229C 3000E073		csrrs	$x0,#$300,#1				; enable ints
                        		
FFFC22A0 18101873		csrrw	v0,#$181,x0
FFFC22A4 01F87813		and		v0,v0,#MAX_TID
FFFC22A8 000868B3	mov		$v1,$v0
FFFC22AC 00006813		ldi		$v0,#E_Ok
FFFC22B0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = map id
                        	;------------------------------------------------------------------------------
                        	
                        	MapOSPages:
FFFC22B4 00306813		ldi			$v0,#OSPAGES	; number of pages pre-mapped
FFFC22B8 00006893		ldi			$v1,#0
FFFC22BC 01091893		sll			$v1,$a0,#16		; put ASID in proper spot
                        	.nxt:
FFFC22C0 10300073		pfi
FFFC22C4 0318800D		mvmap		$x0,$v1,$v1
FFFC22C8 03100D0D		mvmap		$t0,$x0,$v1
FFFC22CC 00001637		and			$t1,$v1,#$FFF
FFFC22D0 FFF60613
FFFC22D4 01167DB3
FFFC22D8 01BD1A63		bne			$t0,$t1,.failed
FFFC22DC 00188893		add			$v1,$v1,#1
FFFC22E0 FFF80813		sub			$v0,$v0,#1
FFFC22E4 FD004EE3		bgt			$v0,$x0,.nxt
FFFC22E8 00008067		ret
                        	.failed:
FFFC22EC 00000063		bra			.failed
                        	
                        	;------------------------------------------------------------------------------
                        	; Select the next task to run. The ready lists are searched in a circular
                        	; fashion beginning with the list identified indirectly by QNDX. There are
                        	; four ready lists to hold tasks of four different priorities. 
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		v1, t0, t1, t2, t3, t4
                        	;	Returns:
                        	;		v0 = task id of task to run
                        	;------------------------------------------------------------------------------
                        	
                        	SelectTaskToRun:
                        		; Pick the first queue to check, occasionally the queue
                        		; chosen isn't the highest priority one in order to 
                        		; prevent starvation of lower priority tasks.
                        	.searchQ:
FFFC22F0 00024637		ldbu	$v1,QNDX						; get index into que check table
FFFC22F4 30460613
FFFC22F8 00060633
FFFC22FC 00064883
FFFC2300 00188893		add		$v1,$v1,#1					; increment it, and limit
FFFC2304 01F8F893		and		$v1,$v1,#31
FFFC2308 00024637		stb		$v1,QNDX						; store back
FFFC230C 30460613
FFFC2310 00060633
FFFC2314 01160023
FFFC2318 FFFC2637		ldbu	$v1,qToChk[$v1]			; assume this will be valid
FFFC231C 12A60613
FFFC2320 01160633
FFFC2324 00064883
FFFC2328 00406E13		ldi		$t2,#4							; 4 queues to check
                        	.nxtQ:
FFFC232C 10300073		pfi
FFFC2330 1C08880D		getrdy	$v0,$v1
;	ldw		$v0,READYQ[$v1]			; check queue to see if contains any
FFFC2334 02085463		bge		$v0,$x0,.dq					; yes, go dequeue
                        	.0001:
FFFC2338 00188893		add		$v1,$v1,#1					; no, advance to next queue
FFFC233C 0038F893		and		$v1,$v1,#3					; 4 max
FFFC2340 FFFE0E13		sub		$t2,$t2,#1					;
FFFC2344 FFC044E3		bgt		$t2,$x0,.nxtQ				; go back to check next queue
                        		; Here, nothing else is actually ready to run
FFFC2348 10100073		wfi
FFFC234C FA0002E3		bra		.searchQ
                        		; just go back to what we were doing.
                        		
FFFC2350 18101873		csrrw	v0,#$181,x0
FFFC2354 01F87813		and		v0,v0,#MAX_TID
FFFC2358 00008067	ret
                        	.dq:
                        	;	ldi		$t3,#MAX_TID				; ensure we have a valid tid
                        	;	bleu	$v0,$t3,.goodTid
                        		; If the tid isn't valid the readyq was screwed up
                        	;	ldi		$t3,#-1							; indicate queue empty
                        	;	stw		$t3,READYQ[$v1]
                        	;	bra		.0001								; and try next queue
                        	.goodTid:
FFFC235C 18181073		csrrw	$x0,#$181,$v0
                        		;sll		$t1,$v0,#LOG_TCBSZ
                        		;ldw		$t0,TCBNext[$t1]		; update head of ready queue
                        		;stw		$t0,READYQ[$v1]
FFFC2360 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_SaveContext:
                        		
FFFC2364 18101873		csrrw	v0,#$181,x0
FFFC2368 01F87813		and		v0,v0,#MAX_TID
FFFC236C 00A81213	sll		$s1,$v0,#LOG_TCBSZ
                        	SaveContext:
FFFC2370 28A20D03		ldb		$t0,TCBContextSaved[$s1]
FFFC2374 0A0D1C63		bnez	$t0,.xit
                        		; Save outgoing register set in TCB
FFFC2378 79027073		csrrc	$x0,#CSR_REGSET,#4	; select previous (user) register set for Rs2
FFFC237C 00123423		sto		$x1,8[$s1]
FFFC2380 00223823		sto		$x2,16[$s1]
FFFC2384 00323C23		sto		$x3,24[$s1]
FFFC2388 02423023		sto		$x4,32[$s1]
FFFC238C 02523423		sto		$x5,40[$s1]
FFFC2390 02623823		sto		$x6,48[$s1]
FFFC2394 02723C23		sto		$x7,56[$s1]
FFFC2398 04823023		sto		$x8,64[$s1]
FFFC239C 04923423		sto		$x9,72[$s1]
FFFC23A0 04A23823		sto		$x10,80[$s1]
FFFC23A4 04B23C23		sto		$x11,88[$s1]
FFFC23A8 06C23023		sto		$x12,96[$s1]
FFFC23AC 06D23423		sto		$x13,104[$s1]
FFFC23B0 06E23823		sto		$x14,112[$s1]
FFFC23B4 06F23C23		sto		$x15,120[$s1]
FFFC23B8 09023023		sto		$x16,128[$s1]
FFFC23BC 09123423		sto		$x17,136[$s1]
FFFC23C0 09223823		sto		$x18,144[$s1]
FFFC23C4 09323C23		sto		$x19,152[$s1]
FFFC23C8 0B423023		sto		$x20,160[$s1]
FFFC23CC 0B523423		sto		$x21,168[$s1]
FFFC23D0 0B623823		sto		$x22,176[$s1]
FFFC23D4 0B723C23		sto		$x23,184[$s1]
FFFC23D8 0D823023		sto		$x24,192[$s1]
FFFC23DC 0D923423		sto		$x25,200[$s1]
FFFC23E0 0DA23823		sto		$x26,208[$s1]
FFFC23E4 0DB23C23		sto		$x27,216[$s1]
FFFC23E8 0FC23023		sto		$x28,224[$s1]
FFFC23EC 0FD23423		sto		$x29,232[$s1]
FFFC23F0 0FE23823		sto		$x30,240[$s1]
FFFC23F4 0FF23C23		sto		$x31,248[$s1]
FFFC23F8 79026073		csrrs	$x0,#CSR_REGSET,#4				; select current register set for Rs2
FFFC23FC 34101173		csrrw	$x2,#$341,$x0				; save off mepc
FFFC2400 28223023		sto		$x2,TCBepc[$s1]
                        		; Now save off segment registers
FFFC2404 00006D93		ldi		$t1,#0
                        	.svseg:
FFFC2408 01B00D0D		mvseg	$t0,$x0,$t1
FFFC240C 003D9113		sll		$x2,$t1,#3
FFFC2410 00410133		add		$x2,$x2,$s1
FFFC2414 21A13023		sto		$t0,TCBsegs[$x2]
FFFC2418 001D8D93		add		$t1,$t1,#1
FFFC241C 00FDFD93		and		$t1,$t1,#15
FFFC2420 FE0D94E3		bne		$t1,$x0,.svseg
FFFC2424 00106D13		ldi		$t0,#1
FFFC2428 29A20523		stb		$t0,TCBContextSaved[$s1]
                        	.xit:
FFFC242C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	RestoreContext:
                        		; Switch memory maps
FFFC2430 00A2D813		srl		$v0,$s2,#10					; convert pointer to tid
FFFC2434 03F87813		and		$v0,$v0,#$3F				; mask to 64 task
FFFC2438 181818F3		csrrw	$v1,#$181,$v0				; set ASID
                        	
                        		; Restore segment register set
FFFC243C 00006D93		ldi		$t1,#0
                        	.rsseg:
FFFC2440 003D9113		sll		$x2,$t1,#3
FFFC2444 00510133		add		$x2,$x2,$s2
FFFC2448 20013D03		ldo		$t0,TCBsegs[$x2]
FFFC244C 01BD000D		mvseg	$x0,$t0,$t1
FFFC2450 001D8D93		add		$t1,$t1,#1
FFFC2454 00FDFD93		and		$t1,$t1,#15
FFFC2458 FE0D94E3		bne		$t1,$x0,.rsseg
                        	
FFFC245C 2802B103		ldo		$x2,TCBepc[$s2]			; restore epc
FFFC2460 34111073		csrrw	$x0,#$341,$x2
                        		; Restore incoming registers
FFFC2464 7900F073		csrrc	$x0,#CSR_REGSET,#1				; select previous regset for Rd
FFFC2468 0082B083		ldo		$x1,8[$s2]
FFFC246C 0102B103		ldo		$x2,16[$s2]
FFFC2470 0182B183		ldo		$x3,24[$s2]
FFFC2474 0202B203		ldo		$x4,32[$s2]
FFFC2478 0282B283		ldo		$x5,40[$s2]
FFFC247C 0302B303		ldo		$x6,48[$s2]
FFFC2480 0382B383		ldo		$x7,56[$s2]
FFFC2484 0402B403		ldo		$x8,64[$s2]
FFFC2488 0482B483		ldo		$x9,72[$s2]
FFFC248C 0502B503		ldo		$x10,80[$s2]
FFFC2490 0582B583		ldo		$x11,88[$s2]
FFFC2494 0602B603		ldo		$x12,96[$s2]
FFFC2498 0682B683		ldo		$x13,104[$s2]
FFFC249C 0702B703		ldo		$x14,112[$s2]
FFFC24A0 0782B783		ldo		$x15,120[$s2]
FFFC24A4 0802B803		ldo		$x16,128[$s2]
FFFC24A8 0882B883		ldo		$x17,136[$s2]
FFFC24AC 0902B903		ldo		$x18,144[$s2]
FFFC24B0 0982B983		ldo		$x19,152[$s2]
FFFC24B4 0A02BA03		ldo		$x20,160[$s2]
FFFC24B8 0A82BA83		ldo		$x21,168[$s2]
FFFC24BC 0B02BB03		ldo		$x22,176[$s2]
FFFC24C0 0B82BB83		ldo		$x23,184[$s2]
FFFC24C4 0C02BC03		ldo		$x24,192[$s2]
FFFC24C8 0C82BC83		ldo		$x25,200[$s2]
FFFC24CC 0D02BD03		ldo		$x26,208[$s2]
FFFC24D0 0D82BD83		ldo		$x27,216[$s2]
FFFC24D4 0E02BE03		ldo		$x28,224[$s2]
FFFC24D8 0E82BE83		ldo		$x29,232[$s2]
FFFC24DC 0F02BF03		ldo		$x30,240[$s2]
FFFC24E0 0F82BF83		ldo		$x31,248[$s2]
FFFC24E4 7900E073		csrrs	$x0,#CSR_REGSET,#1				; select current regset for Rd
FFFC24E8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Swap from outgoing context to incoming context.
                        	; This routine should be called with the system mutex already locked.
                        	; Called from Sleep() and SchedulerIRQ().
                        	;
                        	; Parameters:
                        	;		s1 = pointer to TCB of outgoing context
                        	;		s2 = pointer to TCB of incoming context
                        	;------------------------------------------------------------------------------
                        	
                        	SwapContext:
FFFC24EC 06520663		beq		$s1,$s2,.noCtxSwitch@
FFFC24F0 28A20883		ldb		$v1,TCBContextSaved[$s1]
FFFC24F4 10300073		pfi
FFFC24F8 02089863		bnez	$v1,.savedAlready
                        	
                        		; Save outgoing register set in TCB
FFFC24FC 34101173		csrrw	$x2,#$341,$x0				; save off mepc
FFFC2500 28223023		sto		$x2,TCBepc[$s1]
                        		; Now save off segment registers
FFFC2504 00006D93		ldi		$t1,#0
                        	.svseg:
FFFC2508 10300073		pfi
FFFC250C 01B00D0D		mvseg	$t0,$x0,$t1
FFFC2510 003D9113		sll		$x2,$t1,#3
FFFC2514 00410133		add		$x2,$x2,$s1
FFFC2518 21A13023		sto		$t0,TCBsegs[$x2]
FFFC251C 001D8D93		add		$t1,$t1,#1
FFFC2520 00FDFD93		and		$t1,$t1,#15
FFFC2524 FE0D92E3		bne		$t1,$x0,.svseg
                        	
                        	.savedAlready:
                        		; Restore segment register set
FFFC2528 00006D93		ldi		$t1,#0
                        	.rsseg:
FFFC252C 10300073		pfi
FFFC2530 003D9113		sll		$x2,$t1,#3
FFFC2534 00510133		add		$x2,$x2,$s2
FFFC2538 20013D03		ldo		$t0,TCBsegs[$x2]
FFFC253C 01BD000D		mvseg	$x0,$t0,$t1
FFFC2540 001D8D93		add		$t1,$t1,#1
FFFC2544 00FDFD93		and		$t1,$t1,#15
FFFC2548 FE0D92E3		bne		$t1,$x0,.rsseg
                        	
FFFC254C 2802B103		ldo		$x2,TCBepc[$s2]			; restore epc
FFFC2550 34111073		csrrw	$x0,#$341,$x2
FFFC2554 28028523		stb		$x0,TCBContextSaved[$s2]
                        	.noCtxSwitch:
FFFC2558 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Operating system call dispatcher.
                        	;------------------------------------------------------------------------------
                        	
                        	OSCALL:
FFFC255C 10300073		pfi													; check for interrupt
FFFC2560 79017073		csrrc	$x0,#CSR_REGSET,#$2		; select previous regs for Rs1		
FFFC2564 00096933		mov		$a0,$a0								; move previous to current
FFFC2568 0009E9B3		mov		$a1,$a1
FFFC256C 000A6A33		mov		$a2,$a2
FFFC2570 000AEAB3		mov		$a3,$a3
FFFC2574 000B6B33		mov		$a4,$a4
FFFC2578 000BEBB3		mov		$a5,$a5
FFFC257C 79016073		csrrs	$x0,#CSR_REGSET,#$2		; get back current registers for all
FFFC2580 40006D13		ldi		$t0,#1024
FFFC2584 09A96663		bltu	$a0,$t0,.oscall
                        		
FFFC2588 18101873		csrrw	v0,#$181,x0
FFFC258C 01F87813		and		v0,v0,#MAX_TID
FFFC2590 00086633	mov		$s9,$v0
FFFC2594 00A81213		sll		$s1,$v0,#LOG_TCBSZ
                        		; Lock BIOS mutex
FFFC2598 00181D13		sll		$t0,$v0,#1
FFFC259C 001D6D13		or		$t0,$t0,#1
                        	.lock:
FFFC25A0 10300073		pfi
FFFC25A4 FFDC0637		sto		$t0,BIOS_MUTEX
FFFC25A8 F0860613
FFFC25AC 00060633
FFFC25B0 01A63023
FFFC25B4 FFDC0637		ldo		$t2,BIOS_MUTEX
FFFC25B8 F0860613
FFFC25BC 00060633
FFFC25C0 00063E03
FFFC25C4 FDCD1EE3		bne		$t0,$t2,.lock
                        	
FFFC25C8 01F97913		and		$a0,$a0,#31
FFFC25CC 00191913		sll		$a0,$a0,#1
FFFC25D0 FFFC1637		lhu		$t0,BIOSCallTbl[$a0]
FFFC25D4 F8860613
FFFC25D8 01260633
FFFC25DC 00065D03
FFFC25E0 060D0C63		beqz	$t0,.zero
FFFC25E4 FFFC0637		or		$t0,$t0,#$FFFC0000
FFFC25E8 00060613
FFFC25EC 01A66D33
FFFC25F0 10300073		pfi
FFFC25F4 000D00E7		call	[$t0]									; call the BIOS Function
                        		; Unlock BIOS mutex
FFFC25F8 00161D13		sll		$t0,$s9,#1
FFFC25FC FFDC0637		sto		$t0,BIOS_MUTEX
FFFC2600 F0860613
FFFC2604 00060633
FFFC2608 01A63023
FFFC260C 02000A63		bra		.xit
                        	.oscall:
FFFC2610 01F97913		and		$a0,$a0,#31
FFFC2614 04090263		beqz	$a0,.zero
FFFC2618 00191913		sll		$a0,$a0,#1
FFFC261C FFFC2637		lhu		$t0,OSCallTbl[$a0]
FFFC2620 0F460613
FFFC2624 01260633
FFFC2628 00065D03
FFFC262C 020D0663		beqz	$t0,.zero
FFFC2630 FFFC0637		or		$t0,$t0,#$FFFC0000
FFFC2634 00060613
FFFC2638 01A66D33
FFFC263C 000D00E7		call	[$t0]									; call the OS Function
                        	.xit:
FFFC2640 10300073		pfi
FFFC2644 7900F073		csrrc	$x0,#CSR_REGSET,#$1		; select previous regs for Rd
FFFC2648 00086833		mov		$v0,$v0
FFFC264C 0008E8B3		mov		$v1,$v1
FFFC2650 7900E073		csrrs	$x0,#CSR_REGSET,#$1		; select current regs for Rd
FFFC2654 10000073		eret
                        	.zero:
FFFC2658 01A06813		ldi		$v0,#E_BadCallno
FFFC265C FE0002E3		bra		.xit
                        	
                        	;------------------------------------------------------------------------------
                        	; Sleep for a number of ticks. Tick interval determined by the VIA timer #3.
                        	; Passing a time of zero or less causes the function to return right away.
                        	;
                        	; Parameters:
                        	;		a1 = length of time to sleep (must be >= 0)
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_Sleep:
FFFC2660 FF870713		sub		$sp,$sp,#8
FFFC2664 00173023		sto		$ra,[$sp]
FFFC2668 1409C263		bltz	$a1,.xit
                        		
FFFC266C 18101873		csrrw	v0,#$181,x0
FFFC2670 01F87813		and		v0,v0,#MAX_TID
FFFC2674 000864B3	mov		$s6,$v0
FFFC2678 00A81213		sll		$s1,$v0,#LOG_TCBSZ
                        		; Lock system mutex
FFFC267C 00181D13		sll		$t0,$v0,#1
FFFC2680 001D6D13		or		$t0,$t0,#1
                        	.lock:
FFFC2684 10300073		pfi
FFFC2688 FFDC0637		sto		$t0,SYS_MUTEX
FFFC268C F0060613
FFFC2690 00060633
FFFC2694 01A63023
FFFC2698 FFDC0637		ldo		$t2,SYS_MUTEX
FFFC269C F0060613
FFFC26A0 00060633
FFFC26A4 00063E03
FFFC26A8 FDCD1EE3		bne		$t0,$t2,.lock
                        	
FFFC26AC 10300073		pfi
                        		; First thing: set end time. We don't want to include time spent in the OS in
                        		; the time accounting, so we set the end time as soon as possible.
FFFC26B0 70101E73		csrrw	$t2,#$701,$x0					; get time
FFFC26B4 2BC23C23		sto		$t2,TCBEndTime[$s1]
FFFC26B8 00098A63		beqz	$a1,.0001
FFFC26BC 00086933		mov		$a0,$v0								; a0 = current tid
FFFC26C0 10300073		pfi
FFFC26C4 405000EF		call	RemoveFromReadyList
FFFC26C8 4B9000EF		call	InsertIntoTimeoutList	; a1 = timeout
                        	.0001:
FFFC26CC 28824803		ldbu	$v0,TCBStatus[$s1]		; flag task as no longer running
FFFC26D0 F7F87813		and		$v0,$v0,#~TS_RUNNING
FFFC26D4 29020423		stb		$v0,TCBStatus[$s1]
                        	
                        		;	AccountTime
FFFC26D8 10300073		pfi
FFFC26DC 2B823E03		ldo		$t2,TCBEndTime[$s1]		; get back end time
FFFC26E0 2B023E83		ldo		$t3,TCBStartTime[$s1]
FFFC26E4 41DE0F33		sub		$t4,$t2,$t3						; end - start
FFFC26E8 2C023F83		ldo		$t5,TCBElapsedTime[$s1]
FFFC26EC 01EF8FB3		add		$t5,$t5,$t4						; ticks + (end - start)
FFFC26F0 2DF23023		sto		$t5,TCBElapsedTime[$s1]
                        		; Will switch to target memory map.
FFFC26F4 10300073		pfi
FFFC26F8 BF9FF0EF		call	SelectTaskToRun
                        	
FFFC26FC 00A81293		sll		$s2,$v0,#LOG_TCBSZ		; s2 = pointer to incoming TCB
FFFC2700 2882C103		ldbu	$x2,TCBStatus[$s2]		; x2 = incoming status
FFFC2704 08116E13		or		$t2,$x2,#TS_RUNNING|TS_READY	; set status = running
FFFC2708 2C82A103		ldt		$x2,TCBException[$s2]	;
FFFC270C 00010C63		beqz	$x2,.noException
FFFC2710 10300073		pfi
                        		; set link register to catch handler address
                        		;{
                        		;	t->regs[29] = t->regs[28];   // set link register to catch handler
                        		;	t->epc = t->regs[28];        // and the PC register
                        		;	t->regs[1] = t->exception;    // r1 = exception value
                        		;	t->exception = 0;
                        		;	t->regs[2] = 45;              // r2 = exception type
                        		;}
FFFC2714 0022B423		sto		$x2,8[$s2]						; r1 = exception
FFFC2718 2C02A423		stt		$x0,TCBException[$s2]	; tcb->exception = 0
FFFC271C 02D06113		ldi		$x2,#45
FFFC2720 0022B823		sto		$x2,16[$s2]						; r2 = 45
                        	.noException:
FFFC2724 10300073		pfi
                        	
                        		; If a message is ready, update status to ready and put
                        		; message in target memory. The task will be returning
                        		; from a WaitMsg so a return status of E_Ok is also set.
FFFC2728 004E7113		and		$x2,$t2,#TS_MSGRDY
FFFC272C 06010463		beqz	$x2,.noMsg
FFFC2730 00010D37		ldi		$t0,#$10000						; mprv bit
FFFC2734 000D0D13
FFFC2738 0A02B903		ldo		$a0,160[$s2]					; user a2 (x20)
FFFC273C 00090A63		beqz	$a0,.0002
FFFC2740 2982B103		ldo		$x2,TCBMsgD1[$s2]
FFFC2744 300D2073		csrrs	$x0,#$300,$t0					; set mprv
FFFC2748 00293023		sto		$x2,[$a0]							; store to user space
FFFC274C 300D3073		csrrc	$x0,#$300,$t0					; clear mprv
                        	.0002:
FFFC2750 10300073		pfi
FFFC2754 0A82B903		ldo		$a0,168[$s2]
FFFC2758 00090A63		beqz	$a0,.0003
FFFC275C 2A02B103		ldo		$x2,TCBMsgD2[$s2]
FFFC2760 300D2073		csrrs	$x0,#$300,$t0					; set mprv
FFFC2764 00293023		sto		$x2,[$a0]
FFFC2768 300D3073		csrrc	$x0,#$300,$t0					; set mprv
                        	.0003:
FFFC276C 10300073		pfi
FFFC2770 0B02B903		ldo		$a0,176[$s2]
FFFC2774 00090A63		beqz	$a0,.0004
FFFC2778 2A82B103		ldo		$x2,TCBMsgD3[$s2]
FFFC277C 300D2073		csrrs	$x0,#$300,$t0					; set mprv
FFFC2780 00293023		sto		$x2,[$a0]
FFFC2784 300D3073		csrrc	$x0,#$300,$t0					; set mprv
                        	.0004:
FFFC2788 10300073		pfi
FFFC278C 00006113		ldi		$x2,#E_Ok						; setup to return E_Ok
FFFC2790 0822B023		sto		$x2,128[$s2]					; in v0
                        	
                        	.noMsg:
FFFC2794 FFBE7E13		and		$t2,$t2,#~TS_MSGRDY		; mask out message ready status
FFFC2798 29C28423		stb		$t2,TCBStatus[$s2]
                        	
FFFC279C 10300073		pfi
FFFC27A0 D4DFF0EF		call	SwapContext
                        	
                        		; As above, we want to minimize the impact of the OS on the tasks scheduled
                        		; time. So we set the start time as late as possible.
FFFC27A4 70101E73		csrrw	$t2,#$701,$x0					; get time
FFFC27A8 2BC23823		sto		$t2,TCBStartTime[$s1]
                        	.xit:
                        		; unlock system mutex
FFFC27AC 00149D13		sll		$t0,$s6,#1
FFFC27B0 FFDC0637		sto		$t0,SYS_MUTEX
FFFC27B4 F0060613
FFFC27B8 00060633
FFFC27BC 01A63023
FFFC27C0 00073083		ldo		$ra,[$sp]
FFFC27C4 00870713		add		$sp,$sp,#8
FFFC27C8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SchedulerIRQ meant to be called from the timer ISR.
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_SchedulerIRQ:
                        		
FFFC27CC 18101873		csrrw	v0,#$181,x0
FFFC27D0 01F87813		and		v0,v0,#MAX_TID
FFFC27D4 000864B3	mov		$s6,$v0
FFFC27D8 00A81213		sll		$s1,$v0,#LOG_TCBSZ		; compute pointer to TCB
                        		; Lock system mutex
FFFC27DC 00181D13		sll		$t0,$v0,#1
FFFC27E0 001D6D13		or		$t0,$t0,#1
FFFC27E4 FFDC0637		sto		$t0,SYS_MUTEX
FFFC27E8 F0060613
FFFC27EC 00060633
FFFC27F0 01A63023
FFFC27F4 FFDC0637		ldo		$v1,SYS_MUTEX
FFFC27F8 F0060613
FFFC27FC 00060633
FFFC2800 00063883
FFFC2804 1D1D1263		bne		$t0,$v1,.noLock
                        	
FFFC2808 10300073		pfi
FFFC280C 70101E73		csrrw	$t2,#$701,$x0					; get time
FFFC2810 2BC23C23		sto		$t2,TCBEndTime[$s1]
FFFC2814 1600000D		decto												; decrement timeouts (takes 64 clock cycles async)
FFFC2818 FF870713		sub		$sp,$sp,#8
FFFC281C 00173023		sto		$ra,[$sp]
                        	; Might need the following if the external timer isn't used.
                        	;	csrrw	$v0,#$701,$x0					; get the time
                        	;	add		$v0,$v0,#300000				; wait 300,000 cycles @40MHz (30ms)
                        	;	csrrw	$x0,#$321,$v0					; set next interrupt time
                        		;	AccountTime
FFFC2820 2B023E83		ldo		$t3,TCBStartTime[$s1]
FFFC2824 41DE0F33		sub		$t4,$t2,$t3						; end - start
FFFC2828 2C023F83		ldo		$t5,TCBElapsedTime[$s1]
FFFC282C 01EF8FB3		add		$t5,$t5,$t4						; ticks + (end - start)
FFFC2830 2DF23023		sto		$t5,TCBElapsedTime[$s1]
FFFC2834 10300073		pfi
FFFC2838 28824F83		ldbu	$t5,TCBStatus[$s1]
FFFC283C 020FEF93		or		$t5,$t5,#TS_PREEMPT
FFFC2840 F7FFFF93		and		$t5,$t5,#~TS_RUNNING	; no longer running, but may still be ready
FFFC2844 29F20423		stb		$t5,TCBStatus[$s1]
                        		; Keep popping the timeout list as long as there are tasks on it with
                        		; expired timeouts.
FFFC2848 00006913		ldi		$a0,#0
FFFC284C 1400038D		getzl	$s4		; Get list of tasks whose timeout is zero
                        	.0001:
FFFC2850 10300073		pfi
FFFC2854 00A91F13		sll		$t4,$a0,#10
FFFC2858 288F4E03		lbu		$t2,TCBStatus[$t4]
FFFC285C 010E7E13		and		$t2,$t2,#TS_TIMEOUT
FFFC2860 020E0263		beqz	$t2,.noTimeout
FFFC2864 0013FE13		and		$t2,$s4,#1					; is zero bit set?
FFFC2868 000E0E63		beqz	$t2,.notZero
FFFC286C 288F4E03		lbu		$t2,TCBStatus[$t4]
FFFC2870 FE7E7E13		and		$t2,$t2,#~(TS_TIMEOUT|TS_WAITMSG)
	sb		$t2,TCBStatus[$t4]
FFFC2874 29CF0423
FFFC2878 10300073		pfi
FFFC287C 410000EF		call	MbxRemoveTask
FFFC2880 1A5000EF		call	InsertIntoReadyList
                        	.notZero:
                        	.noTimeout:
FFFC2884 10300073		pfi
FFFC2888 00190913		add		$a0,$a0,#1
FFFC288C 0013D393		srl		$s4,$s4,#1	
FFFC2890 FC0390E3		bnez	$s4,.0001
                        	
                        		; The ready list was just updated, there could be new tasks
                        		; ready to run. Will switch to target memory map.
                        	.searchQ:
FFFC2894 10300073		pfi
FFFC2898 00024637		ldbu	$v1,QNDX						; get index into que check table
FFFC289C 30460613
FFFC28A0 00060633
FFFC28A4 00064883
FFFC28A8 00188893		add		$v1,$v1,#1					; increment it, and limit
FFFC28AC 01F8F893		and		$v1,$v1,#31
FFFC28B0 00024637		stb		$v1,QNDX						; store back
FFFC28B4 30460613
FFFC28B8 00060633
FFFC28BC 01160023
FFFC28C0 FFFC2637		ldbu	$v1,qToChk[$v1]			; assume this will be valid
FFFC28C4 12A60613
FFFC28C8 01160633
FFFC28CC 00064883
FFFC28D0 00406E13		ldi		$t2,#4							; 4 queues to check
                        	.nxtQ:
FFFC28D4 10300073		pfi
FFFC28D8 1C08880D		getrdy	$v0,$v1
;	ldw		$v0,READYQ[$v1]			; check queue to see if contains any
FFFC28DC 02085063		bge		$v0,$x0,.dq					; yes, go dequeue
FFFC28E0 00188893		add		$v1,$v1,#1					; no, advance to next queue
FFFC28E4 0038F893		and		$v1,$v1,#3					; 4 max
FFFC28E8 FFFE0E13		sub		$t2,$t2,#1					;
FFFC28EC FFC044E3		bgt		$t2,$x0,.nxtQ				; go back to check next queue
                        		; Here, nothing else is actually ready to run
                        		; just go back to what we were doing.
FFFC28F0 10300073		pfi
                        		
FFFC28F4 18101873		csrrw	v0,#$181,x0
FFFC28F8 01F87813		and		v0,v0,#MAX_TID
                        	.dq:
                        	.goodTid:
FFFC28FC 18181073		csrrw	$x0,#$181,$v0
                        	
FFFC2900 00A81293		sll		$s2,$v0,#LOG_TCBSZ	; s2 = pointer to incoming TCB
FFFC2904 2882C103		lbu		$x2,TCBStatus[$s2]	; x2 = incoming status
FFFC2908 08116E13		or		$t2,$x2,#TS_RUNNING|TS_READY	; status = running
FFFC290C 2C82B103		ldo		$x2,TCBException[$s2]	;
FFFC2910 10300073		pfi
FFFC2914 00010263		beqz	$x2,.noException
                        		; set link register to catch handler address
                        		;{
                        		;	t->regs[29] = t->regs[28];   // set link register to catch handler
                        		;	t->epc = t->regs[28];        // and the PC register
                        		;	t->regs[1] = t->exception;    // r1 = exception value
                        		;	t->exception = 0;
                        		;	t->regs[2] = 45;              // r2 = exception type
                        		;}
                        	.noException:
                        	
                        		; If a message is ready, update status to ready and put
                        		; message in target memory. The task will be returning
                        		; from a WaitMsg so a return status of E_Ok is also set.
FFFC2918 06000A63		bra		.noMsg
FFFC291C 004E7113		and		$x2,$t2,#TS_MSGRDY
FFFC2920 06010663		beq		$x2,$x0,.noMsg
FFFC2924 00010D37		ldi		$t0,#$10000						; mprv bit
FFFC2928 000D0D13
FFFC292C 0A02B903		ldo		$a0,160[$s2]					; user a2 (x20)
FFFC2930 10300073		pfi
FFFC2934 00090A63		beq		$a0,$x0,.0002
FFFC2938 2982B103		ldo		$x2,TCBMsgD1[$s2]
FFFC293C 300D2073		csrrs	$x0,#$300,$t0					; set mprv
FFFC2940 00293023		sto		$x2,[$a0]
FFFC2944 300D3073		csrrc	$x0,#$300,$t0					; set mprv
                        	.0002:
FFFC2948 10300073		pfi
FFFC294C 0A82B903		ldo		$a0,168[$s2]
FFFC2950 00090A63		beq		$a0,$x0,.0003
FFFC2954 2A02B103		ldo		$x2,TCBMsgD2[$s2]
FFFC2958 300D2073		csrrs	$x0,#$300,$t0					; set mprv
FFFC295C 00293023		sto		$x2,[$a0]
FFFC2960 300D3073		csrrc	$x0,#$300,$t0					; set mprv
                        	.0003:
FFFC2964 10300073		pfi
FFFC2968 0B02B903		ldo		$a0,176[$s2]
FFFC296C 00090A63		beq		$a0,$x0,.0004
FFFC2970 2A82B103		ldo		$x2,TCBMsgD3[$s2]
FFFC2974 300D2073		csrrs	$x0,#$300,$t0					; set mprv
FFFC2978 00293023		sto		$x2,[$a0]
FFFC297C 300D3073		csrrc	$x0,#$300,$t0					; set mprv
                        	.0004:
FFFC2980 10300073		pfi
FFFC2984 00006113		ldi		$x2,#E_Ok						; setup to return E_Ok
FFFC2988 0822B023		sto		$x2,128[$s2]				; in v0
                        	
                        	.noMsg:
FFFC298C FFBE7E13		and		$t2,$t2,#~TS_MSGRDY		; mask out message ready status
FFFC2990 29C28423		stb		$t2,TCBStatus[$s2]
                        	
FFFC2994 10300073		pfi
FFFC2998 B55FF0EF		call	SwapContext
FFFC299C 00073083		ldo		$ra,[$sp]
FFFC29A0 00870713		add		$sp,$sp,#8
FFFC29A4 70101E73		csrrw	$t2,#$701,$x0					; get time
FFFC29A8 2BC2B823		sto		$t2,TCBStartTime[$s2]
                        		; Unlock system mutex
FFFC29AC 10300073		pfi
FFFC29B0 00149E13		sll		$t2,$s6,#1
FFFC29B4 FFDC0637		sto		$t2,SYS_MUTEX
FFFC29B8 F0060613
FFFC29BC 00060633
FFFC29C0 01C63023
FFFC29C4 00008067		ret
                        	.noLock:
FFFC29C8 70101E73		csrrw	$t2,#$701,$x0					; get time
FFFC29CC 2BC23823		sto		$t2,TCBStartTime[$s1]
FFFC29D0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Start a task.
                        	;	Task status is set to ready, priority normal, and the task is inserted into
                        	; the ready list. Segment registers are setup for a flat memory model.
                        	; 
                        	;	Parameters:
                        	;		a1 = memory required
                        	;		a2 = start pc (usually $100)
                        	;	Modifies:
                        	;		a0 = mid
                        	;	Returns:
                        	;		v0 = E_Ok if successful
                        	;		v1 = mid of started task if successful
                        	;------------------------------------------------------------------------------
                        	;
                        	FMTK_StartTask:
FFFC29D4 FF070713		sub		$sp,$sp,#16
FFFC29D8 00173023		sto		$ra,[$sp]
FFFC29DC 10300073		pfi
                        		
FFFC29E0 18101873		csrrw	v0,#$181,x0
FFFC29E4 01F87813		and		v0,v0,#MAX_TID
FFFC29E8 000864B3	mov		$s6,$v0						; save tid in s6
                        		; Lock system mutex
FFFC29EC 00181813		sll		$v0,$v0,#1
FFFC29F0 00186813		or		$v0,$v0,#1
                        	.lock:
FFFC29F4 10300073		pfi
FFFC29F8 FFDC0637		sto		$v0,SYS_MUTEX
FFFC29FC F0060613
FFFC2A00 00060633
FFFC2A04 01063023
FFFC2A08 FFDC0637		ldo		$v1,SYS_MUTEX
FFFC2A0C F0060613
FFFC2A10 00060633
FFFC2A14 00063883
FFFC2A18 FD181EE3		bne		$v0,$v1,.lock
                        	
FFFC2A1C 2E9000EF		call	AllocTCB
FFFC2A20 00004637		stb		$v1,$4321
FFFC2A24 32160613
FFFC2A28 00060633
FFFC2A2C 01160023
FFFC2A30 10081E63		bnez	$v0,.err
FFFC2A34 0008E933		mov		$a0,$v1
FFFC2A38 10300073		pfi
FFFC2A3C 861FE0EF		call	FreeAll
FFFC2A40 10300073		pfi
FFFC2A44 871FF0EF		call	MapOSPages			; Map OS pages into address space
FFFC2A48 00A91213		sll		$s1,$a0,#LOG_TCBSZ	; compute TCB address
FFFC2A4C 10300073		pfi
FFFC2A50 FF4FE0EF		call	AllocStack
FFFC2A54 A0010637		add		$t0,$v1,#$A000FFFC	; set stack pointer
FFFC2A58 FFC60613
FFFC2A5C 01160D33
FFFC2A60 07A23823		sto		$t0,112[$s1]
FFFC2A64 29423023		sto		$a2,TCBepc[$s1]	; address task will begin at
FFFC2A68 10300073		pfi
FFFC2A6C EE0FE0EF		call	Alloc
FFFC2A70 00004637		stb		$v0,$4320
FFFC2A74 32060613
FFFC2A78 00060633
FFFC2A7C 01060023
FFFC2A80 00096333		mov		$s3,$a0
FFFC2A84 0108D913		srl		$a0,$v1,#16
FFFC2A88 10300073		pfi
FFFC2A8C DBDFD0EF		call	PutHexHalf
FFFC2A90 00036933		mov		$a0,$s3
FFFC2A94 0A081C63		bnez	$v0,.err
FFFC2A98 00106D13		ldi		$t0,#TS_READY
FFFC2A9C 29A20423		stb		$t0,TCBStatus[$s1]
FFFC2AA0 00206D13		ldi		$t0,#2					; normal execution priority
FFFC2AA4 29A204A3		stb		$t0,TCBPriority[$s1]
                        		; leave segment base at $0, flat memory model
FFFC2AA8 10300073		pfi
FFFC2AAC 00606D13		ldi		$t0,#6							; read,write
FFFC2AB0 21A23023		sto		$t0,TCBsegs[$s1]			; segs 0 to 11
FFFC2AB4 21A23423		sto		$t0,TCBsegs+8[$s1]
FFFC2AB8 21A23823		sto		$t0,TCBsegs+16[$s1]
FFFC2ABC 21A23C23		sto		$t0,TCBsegs+24[$s1]
FFFC2AC0 23A23023		sto		$t0,TCBsegs+32[$s1]
FFFC2AC4 23A23423		sto		$t0,TCBsegs+40[$s1]
FFFC2AC8 10300073		pfi
FFFC2ACC 23A23823		sto		$t0,TCBsegs+48[$s1]
FFFC2AD0 23A23C23		sto		$t0,TCBsegs+56[$s1]
FFFC2AD4 25A23023		sto		$t0,TCBsegs+64[$s1]
FFFC2AD8 25A23423		sto		$t0,TCBsegs+72[$s1]
FFFC2ADC 25A23823		sto		$t0,TCBsegs+80[$s1]
FFFC2AE0 25A23C23		sto		$t0,TCBsegs+88[$s1]
FFFC2AE4 10300073		pfi
FFFC2AE8 00506D13		ldi		$t0,#5							; read,execute
FFFC2AEC 27A23023		sto		$t0,TCBsegs+96[$s1]	; segs 12 to 15
FFFC2AF0 27A23423		sto		$t0,TCBsegs+104[$s1]
FFFC2AF4 27A23823		sto		$t0,TCBsegs+112[$s1]
FFFC2AF8 27A23C23		sto		$t0,TCBsegs+120[$s1]
FFFC2AFC 00106993		ldi		$a1,#1
FFFC2B00 10300073		pfi
FFFC2B04 E48FE0EF		call	Alloc
FFFC2B08 33123823		sto		$v1,TCBVideoMem[$s1]
FFFC2B0C FFD00D37		ldi		$t0,#$FFD00000
FFFC2B10 000D0D13
FFFC2B14 33A23C23		sto		$t0,TCBpVideo[$s1]
FFFC2B18 10300073		pfi
FFFC2B1C 708000EF		call	InsertIntoReadyList
FFFC2B20 000968B3		mov		$v1,$a0
FFFC2B24 10300073		pfi
                        		; Unlock mutex
FFFC2B28 00149D13		sll		$t0,$s6,#1
FFFC2B2C FFDC0637		sto		$t0,SYS_MUTEX
FFFC2B30 F0060613
FFFC2B34 00060633
FFFC2B38 01A63023
FFFC2B3C E09FD0EF		call	DumpMemmap
                        	.xit:
FFFC2B40 00073083		ldo		$ra,[$sp]
FFFC2B44 01070713		add		$sp,$sp,#16
FFFC2B48 00008067		ret
                        	.err:
FFFC2B4C 00000013		nop
FFFC2B50 00000013		nop
FFFC2B54 FE000CE3		bra		.err
                        	
                        	;------------------------------------------------------------------------------
                        	; Exit the current task.
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		a1 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_ExitTask:
FFFC2B58 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC2B5C FF870713		sub		$sp,$sp,#8
FFFC2B60 00173023		sto		$ra,[$sp]
                        		
FFFC2B64 18101873		csrrw	v0,#$181,x0
FFFC2B68 01F87813		and		v0,v0,#MAX_TID
FFFC2B6C 000869B3	mov		a1,v0
FFFC2B70 10300073		pfi
FFFC2B74 00000637		call	KillTask
FFFC2B78 219600E7
                        	.xit:
FFFC2B7C 00073083		ldo		$ra,[$sp]
FFFC2B80 00870713		add		$sp,$sp,#8
FFFC2B84 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = tid of task to kill
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_KillTask:
FFFC2B88 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC2B8C FF870713		sub		$sp,$sp,#8
FFFC2B90 00173023		sto		$ra,[$sp]
FFFC2B94 0A098663		beqz	$a1,.immortal		; tid #0 is immortal (the system)
                        	
                        		; Lock system mutex
                        		
FFFC2B98 18101873		csrrw	v0,#$181,x0
FFFC2B9C 01F87813		and		v0,v0,#MAX_TID
FFFC2BA0 000864B3	mov		$s6,$v0
FFFC2BA4 00181813		sll		$v0,$v0,#1
FFFC2BA8 00186813		or		$v0,$v0,#1
                        	.lock:
FFFC2BAC 10300073		pfi
FFFC2BB0 FFDC0637		sto		$v0,SYS_MUTEX
FFFC2BB4 F0060613
FFFC2BB8 00060633
FFFC2BBC 01063023
FFFC2BC0 FFDC0637		ldo		$v1,SYS_MUTEX
FFFC2BC4 F0060613
FFFC2BC8 00060633
FFFC2BCC 00063883
FFFC2BD0 FD181EE3		bne		$v0,$v1,.lock
                        	
FFFC2BD4 00206D13		ldi		$t0,#TS_DEAD				; flag task as dead (prevents it from being re-queued)
FFFC2BD8 01F9FD93		and		$t1,$a1,#MAX_TID		; limit tid
FFFC2BDC 00AD9D93		sll		$t1,$t1,#LOG_TCBSZ	; convert to TCB address
FFFC2BE0 29AD8423		stb		$t0,TCBStatus[$t1]
FFFC2BE4 0009E933		mov		$a0,$a1								; a0 = pid
FFFC2BE8 10300073		pfi
FFFC2BEC 6DC000EF		call	RemoveFromReadyList
FFFC2BF0 EACFE0EF		call	FreeAll							; free all the memory associated with the task
FFFC2BF4 10300073		pfi
                        		; Now make process ID available for reuse
FFFC2BF8 00024637		ldo		$t1,PIDMAP
FFFC2BFC 31060613
FFFC2C00 00060633
FFFC2C04 00063D83
FFFC2C08 00106D13		ldi		$t0,#1							; generate bit "off" mask
FFFC2C0C 013D1D33		sll		$t0,$t0,$a1
FFFC2C10 FFFD4D13		xor		$t0,$t0,#-1					; complment for inverted mask
FFFC2C14 01ADFDB3		and		$t1,$t1,$t0
FFFC2C18 00024637		sto		$t1,PIDMAP
FFFC2C1C 31060613
FFFC2C20 00060633
FFFC2C24 01B63023
                        		; Unlock system mutex
FFFC2C28 10300073		pfi
FFFC2C2C 00149D93		sll		$t1,$s6,#1
FFFC2C30 FFDC0637		sto		$t1,SYS_MUTEX
FFFC2C34 F0060613
FFFC2C38 00060633
FFFC2C3C 01B63023
                        	.immortal:
FFFC2C40 00006813		ldi		$v0,#E_Ok
FFFC2C44 00073083		ldo		$ra,[$sp]
FFFC2C48 00870713		add		$sp,$sp,#8
FFFC2C4C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_AllocVideoBuf:
                        		
FFFC2C50 18101873		csrrw	v0,#$181,x0
FFFC2C54 01F87813		and		v0,v0,#MAX_TID
FFFC2C58 00086933	mov		$a0,$v0
FFFC2C5C 00106993		ldi		$a1,#1			; request 1 byte to get 1 page (64kB)
FFFC2C60 10300073		pfi
FFFC2C64 CE8FE0EF		call	Alloc
FFFC2C68 00081E63		bnez	$v0,.err
FFFC2C6C 00A91213		sll		$s1,$a0,#LOG_TCBSZ
FFFC2C70 00000637		sto		$v1,TCBVidMem[$s1]
FFFC2C74 21F60613
FFFC2C78 00460633
FFFC2C7C 01163023
FFFC2C80 33123C23		sto		$v1,TCBpVideo[$s1]
                        	.err:
FFFC2C84 10300073		pfi
FFFC2C88 00008067		ret
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/msg.r5a",1
                        	.file "../fmtk/msg.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	MBX_OWNER			equ		0		; tid of owning task
                        	MBX_WTIDS			equ		8		; tasks waiting at mailbox
                        	MBX_MQHEAD		equ		16		
                        	MBX_MQTAIL		equ		24
                        	MBX_SIZE			equ		32
                        	LOG_MBXSZ			equ		5
                        	
                        	MSG_LINK	equ		0
                        	MSG_D1		equ		8
                        	MSG_D2		equ		16
                        	MSG_D3		equ		24
                        	MSG_SIZE	equ		32
                        	LOG_MSGSZ	equ		5
                        	
                        	;	bss
                        	;	align 4
                        	;FreeMsg	dw	0
                        	;msgs:
                        	;	fill.b	MSG_SIZE*1024,0
                        	;mbxs:
                        	;	fill.b	MBX_SIZE*32,0
                        	;mbxs_end:
                        	
                        	.file "../fmtk/msg.r5a",48
                        		code
                        		align	4                        	
                        	
                        	;------------------------------------------------------------------------------
                        	; Remove the task from the list of tasks waiting at the mailbox.
                        	; This routine is only called from a couple of places and it is convenient
                        	; not to stack the return address. So, it is implemented as a macro.
                        	;
                        	; Parameters:
                        	;		a0 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	MbxRemoveTask:
FFFC2C8C FE070713		sub		$sp,$sp,#32
FFFC2C90 00473023		sto		$s1,[$sp]
FFFC2C94 01A73423		sto		$t0,8[$sp]
FFFC2C98 01B73823		sto		$t1,16[$sp]
FFFC2C9C 01C73C23		sto		$t2,24[$sp]
FFFC2CA0 10300073		pfi
FFFC2CA4 00A91213		sll		$s1,$a0,#LOG_TCBSZ		; tid to pointer
FFFC2CA8 28C21D03		ldw		$t0,TCBWaitMbx[$s1]		; get mailbox handle
FFFC2CAC 020D4863		blt		$t0,$x0,.xit					; handle good?
FFFC2CB0 005D1D13		sll		$t0,$t0,#LOG_MBXSZ		; convert to pointer
FFFC2CB4 00020637		add		$t0,$t0,#mbxs					; by adding base address
FFFC2CB8 00060613
FFFC2CBC 01A60D33
FFFC2CC0 10300073		pfi
FFFC2CC4 008D3D83		ldo		$t1,MBX_WTIDS[$t0]		; get waiting task list
FFFC2CC8 00106E13		ldi		$t2,#1								; create a mask for given task id
FFFC2CCC 012E1E33		sll		$t2,$t2,$a0
FFFC2CD0 FFFE4E13		xor		$t2,$t2,#-1
FFFC2CD4 01CDFDB3		and		$t1,$t1,$t2						; clear bit
FFFC2CD8 01BD3423		sto		$t1,MBX_WTIDS[$t0]		; update waiting task list
                        	.xit:
FFFC2CDC 10300073		pfi
FFFC2CE0 00073203		ldo		$s1,[$sp]
FFFC2CE4 00873D03		ldo		$t0,8[$sp]
FFFC2CE8 01073D83		ldo		$t1,16[$sp]
FFFC2CEC 01873E03		ldo		$t2,24[$sp]
FFFC2CF0 02070713		add		$sp,$sp,#32
FFFC2CF4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Allocate a mailbox.
                        	;
                        	; Parameters:
                        	;		a1 = task id of owner
                        	;		a2 = pointer where to store handle
                        	; Returns:
                        	;		v0 = E_Ok
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_AllocMbx:
FFFC2CF8 FF870713		sub		$sp,$sp,#8
FFFC2CFC 00173023		sto		$ra,[$sp]
FFFC2D00 0A0A0063		beq		$a2,$x0,.badArg
FFFC2D04 00020D37		ldi		$t0,#mbxs
FFFC2D08 000D0D13
                        		; Lock system mutex
                        		
FFFC2D0C 18101873		csrrw	v0,#$181,x0
FFFC2D10 01F87813		and		v0,v0,#MAX_TID
FFFC2D14 000864B3	mov		$s6,$v0
FFFC2D18 00181813		sll		$v0,$v0,#1
FFFC2D1C 00186813		or		$v0,$v0,#1
                        	.lock:
FFFC2D20 10300073		pfi
FFFC2D24 FFDC0637		sto		$v0,SYS_MUTEX
FFFC2D28 F0060613
FFFC2D2C 00060633
FFFC2D30 01063023
FFFC2D34 FFDC0637		ldo		$v1,SYS_MUTEX
FFFC2D38 F0060613
FFFC2D3C 00060633
FFFC2D40 00063883
FFFC2D44 FD181EE3		bne		$v0,$v1,.lock
                        	.nxt:
FFFC2D48 10300073		pfi
FFFC2D4C 000D4D83		ldbu	$t1,MBX_OWNER[$t0]
FFFC2D50 000D8E63		beq		$t1,$x0,.noOwner
FFFC2D54 020D0D13		add		$t0,$t0,#MBX_SIZE
FFFC2D58 00022637		slt		$t1,$t0,#mbxs_end
FFFC2D5C 00060613
FFFC2D60 FE0D94E3		bne		$t1,$x0,.nxt
FFFC2D64 04006813		ldi		$v0,#E_NoMoreMbx
FFFC2D68 02000E63		bra		.xit
                        	.noOwner:
FFFC2D6C 10300073		pfi
FFFC2D70 013D0023		stb		$a1,MBX_OWNER[$t0]
FFFC2D74 FFFE0637		sub		$t5,$t0,#mbxs				; convert pointer to handle
FFFC2D78 00060613
FFFC2D7C 41A60FB3
FFFC2D80 005FDF93		srl		$t5,$t5,#LOG_MBXSZ
FFFC2D84 0009E933		mov		$a0,$a1
FFFC2D88 000A69B3		mov		$a1,$a2
FFFC2D8C 10300073		pfi
FFFC2D90 D78FE0EF		call	VirtToPhys
FFFC2D94 01F83023		sto		$t5,[$v0]
FFFC2D98 00006813		ldi		$v0,#E_Ok
FFFC2D9C 00000463		bra		.xit
                        	.badArg:
FFFC2DA0 00106813		ldi		$v0,#E_Arg
                        	.xit:
FFFC2DA4 10300073		pfi
                        		; Unlock system mutex
FFFC2DA8 00149D13		sll		$t0,$s6,#1
FFFC2DAC FFDC0637		sto		$t0,SYS_MUTEX
FFFC2DB0 F0060613
FFFC2DB4 00060633
FFFC2DB8 01A63023
FFFC2DBC 00073083		ldo		$ra,[$sp]
FFFC2DC0 00870713		add		$sp,$sp,#8
FFFC2DC4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Free a mailbox
                        	;
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_FreeMbx:
FFFC2DC8 FF870713		sub		$sp,$sp,#8
FFFC2DCC 00173023		sto		$ra,[$sp]
FFFC2DD0 1009A213		slt		$s1,$a1,#NR_MBX
FFFC2DD4 0A020863		beq		$s1,$x0,.badMbx
FFFC2DD8 00599213		sll		$s1,$a1,#LOG_MBXSZ		; convert handle to pointer
FFFC2DDC 00020637		add		$s1,$s1,#mbxs
FFFC2DE0 00060613
FFFC2DE4 00460233
FFFC2DE8 00006293		ldi		$s2,#0
FFFC2DEC 02006393		ldi		$s4,#NR_TCB						; possibly 64 tasks
                        		; Lock system mutex
                        		
FFFC2DF0 18101873		csrrw	v0,#$181,x0
FFFC2DF4 01F87813		and		v0,v0,#MAX_TID
FFFC2DF8 00086533	mov		$s7,$v0
FFFC2DFC 00181813		sll		$v0,$v0,#1
FFFC2E00 00186813		or		$v0,$v0,#1
                        	.lock:
FFFC2E04 10300073		pfi
FFFC2E08 FFDC0637		sto		$v0,SYS_MUTEX
FFFC2E0C F0060613
FFFC2E10 00060633
FFFC2E14 01063023
FFFC2E18 FFDC0637		ldo		$v1,SYS_MUTEX
FFFC2E1C F0060613
FFFC2E20 00060633
FFFC2E24 00063883
FFFC2E28 FD181EE3		bne		$v0,$v1,.lock
                        	
FFFC2E2C 00823483		ldo		$s6,MBX_WTIDS[$s1]
                        	.0002:
FFFC2E30 10300073		pfi
FFFC2E34 0014F313		and		$s3,$s6,#1
FFFC2E38 02030A63		beq		$s3,$x0,.0001
FFFC2E3C 00A29413		sll		$s5,$s2,#LOG_TCBSZ		; tid to pointer
FFFC2E40 28844803		lbu		$v0,TCBStatus[$s5]
FFFC2E44 FF787813		and		$v0,$v0,#~TS_WAITMSG	; no longer waiting
FFFC2E48 29040423		stb		$v0,TCBStatus[$s5]
FFFC2E4C 01087813		and		$v0,$v0,#TS_TIMEOUT
FFFC2E50 0002E933		mov		$a0,$s2
FFFC2E54 00080663		beqz	$v0,.0003
FFFC2E58 10300073		pfi
FFFC2E5C 608000EF		call	RemoveFromTimeoutList
                        	.0003:
FFFC2E60 3C4000EF		call	InsertIntoReadyList
FFFC2E64 00B06813		ldi		$v0,#E_NoMsg					; but no message
FFFC2E68 09043023		sto		$v0,128[$s5]					; v0 = E_NoMsg
                        	.0001:
FFFC2E6C 10300073		pfi
FFFC2E70 0014D493		srl		$s6,$s6,#1
FFFC2E74 00128293		add		$s2,$s2,#1
FFFC2E78 FA72ECE3		bltu	$s2,$s4,.0002
FFFC2E7C 00006813		ldi		$v0,#E_Ok
FFFC2E80 00000463		bra		.xit
                        	.badMbx:
FFFC2E84 00406813		ldi		$v0,#E_BadMbx				; return null pointer if bad mailbox
                        	.xit:
FFFC2E88 10300073		pfi
                        		; Unlock system mutex
FFFC2E8C 00151D13		sll		$t0,$s7,#1
FFFC2E90 FFDC0637		sto		$t0,SYS_MUTEX
FFFC2E94 F0060613
FFFC2E98 00060633
FFFC2E9C 01A63023
FFFC2EA0 00073083		ldo		$ra,[$sp]
FFFC2EA4 00870713		add		$sp,$sp,#8
FFFC2EA8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Send a message to a mailbox.
                        	; The message will be broadcast to any waiting tasks. Waiting tasks will then
                        	; be moved to the ready list. If there are no waiting tasks then the message
                        	; is queued at the mailbox.
                        	;
                        	; Register Usage:
                        	;		t0 = mailbox pointer
                        	;		t1 = message pointer
                        	;		s1 = task id of waiting task
                        	; Modifies:
                        	;		a0
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = message d1
                        	;		a3 = message d2
                        	;		a4 = message d3
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_SendMsg:
FFFC2EAC FF870713		sub		$sp,$sp,#8
FFFC2EB0 00173023		sto		$ra,[$sp]
FFFC2EB4 1009BD13		sltu	$t0,$a1,#NR_MBX
FFFC2EB8 140D0063		beq		$t0,$x0,.badMbx
FFFC2EBC 00599D13		sll		$t0,$a1,#LOG_MBXSZ	; convert handle to pointer
FFFC2EC0 00020637		add		$t0,$t0,#mbxs
FFFC2EC4 00060613
FFFC2EC8 01A60D33
                        		; Lock system mutex
                        		
FFFC2ECC 18101873		csrrw	v0,#$181,x0
FFFC2ED0 01F87813		and		v0,v0,#MAX_TID
FFFC2ED4 000864B3	mov		$s6,$v0
FFFC2ED8 00181813		sll		$v0,$v0,#1
FFFC2EDC 00186813		or		$v0,$v0,#1
                        	.lock:
FFFC2EE0 10300073		pfi
FFFC2EE4 FFDC0637		sto		$v0,SYS_MUTEX
FFFC2EE8 F0060613
FFFC2EEC 00060633
FFFC2EF0 01063023
FFFC2EF4 FFDC0637		ldo		$v1,SYS_MUTEX
FFFC2EF8 F0060613
FFFC2EFC 00060633
FFFC2F00 00063883
FFFC2F04 FD181EE3		bne		$v0,$v1,.lock
                        	
FFFC2F08 008D3F83		ldo		$t5,MBX_WTIDS[$t0]
FFFC2F0C 060F8C63		beq		$t5,$x0,.noWaiters	; no waiters = go queue message
FFFC2F10 00006213		ldi		$s1,#0
                        	.0001:
FFFC2F14 10300073		pfi
FFFC2F18 001FF313		and		$s3,$t5,#1					; is tid waiting?
FFFC2F1C 04030463		beq		$s3,$x0,.nxtTid
FFFC2F20 00A21313		sll		$s3,$s1,#LOG_TCBSZ	; convert tid to TCB pointer
FFFC2F24 29433C23		sto		$a2,TCBMsgD1[$s3]		; copy message to TCB
FFFC2F28 2B533023		sto		$a3,TCBMsgD2[$s3]
FFFC2F2C 2B633423		sto		$a4,TCBMsgD3[$s3]
FFFC2F30 10300073		pfi
FFFC2F34 28834E03		ldbu	$t2,TCBStatus[$s3]
FFFC2F38 004E6E13		or		$t2,$t2,#TS_MSGRDY
FFFC2F3C 29C30423		stb		$t2,TCBStatus[$s3]
FFFC2F40 00026933		mov		$a0,$s1
FFFC2F44 FF070713		sub		$sp,$sp,#16
FFFC2F48 00173023		sto		$ra,[$sp]
FFFC2F4C 01A73423		sto		$t0,8[$sp]						; push t0
FFFC2F50 10300073		pfi
FFFC2F54 2D0000EF		call	InsertIntoReadyList
FFFC2F58 00073083		ldo		$ra,[$sp]
FFFC2F5C 00873D03		ldo		$t0,8[$sp]						; pop t0
FFFC2F60 01070713		add		$sp,$sp,#16
                        	.nxtTid:
FFFC2F64 10300073		pfi
FFFC2F68 001FDF93		srl		$t5,$t5,#1					; check next task
FFFC2F6C 00120213		add		$s1,$s1,#1
FFFC2F70 03F27213		and		$s1,$s1,#63
FFFC2F74 FA0210E3		bne		$s1,$x0,.0001
FFFC2F78 000D3423		sto		$x0,MBX_WTIDS[$t0]	; clear waiters
FFFC2F7C 00006813		ldi		$v0,#E_Ok
FFFC2F80 06000E63		bra		.xit
                        	.noWaiters:
FFFC2F84 10300073		pfi
FFFC2F88 00024637		ldo		$t1,FreeMsg
FFFC2F8C 35060613
FFFC2F90 00060633
FFFC2F94 00063D83
FFFC2F98 040D8A63		beq		$t1,$x0,.noMsg			; message available?
FFFC2F9C 000DBE03		ldo		$t2,MSG_LINK[$t1]
FFFC2FA0 00024637		sto		$t2,FreeMsg
FFFC2FA4 35060613
FFFC2FA8 00060633
FFFC2FAC 01C63023
FFFC2FB0 014DB423		sto		$a2,MSG_D1[$t1]
FFFC2FB4 015DB823		sto		$a3,MSG_D2[$t1]
FFFC2FB8 016DBC23		sto		$a4,MSG_D3[$t1]
FFFC2FBC 10300073		pfi
FFFC2FC0 018D3E83		ldo		$t3,MBX_MQTAIL[$t0]
FFFC2FC4 000E8A63		beq		$t3,$x0,.mbxEmpty
FFFC2FC8 01BEB023		sto		$t1,MSG_LINK[$t3]
FFFC2FCC 01BD3C23		sto		$t1,MBX_MQTAIL[$t0]
FFFC2FD0 00006813		ldi		$v0,#E_Ok
FFFC2FD4 02000463		bra		.xit
                        	.mbxEmpty:
FFFC2FD8 10300073		pfi
FFFC2FDC 01BD3823		sto		$t1,MBX_MQHEAD[$t0]
FFFC2FE0 01BD3C23		sto		$t1,MBX_MQTAIL[$t0]
FFFC2FE4 00006813		ldi		$v0,#E_Ok
FFFC2FE8 00000A63		bra		.xit
                        	.noMsg:
FFFC2FEC 10300073		pfi
FFFC2FF0 00B06813		ldi		$v0,#E_NoMsg
FFFC2FF4 00000463		bra		.xit
                        	.badMbx:
FFFC2FF8 00406813		ldi		$v0,#E_BadMbx				; return null pointer if bad mailbox
                        	.xit:
                        		; Unlock system mutex
FFFC2FFC 00149D13		sll		$t0,$s6,#1
FFFC3000 FFDC0637		sto		$t0,SYS_MUTEX
FFFC3004 F0060613
FFFC3008 00060633
FFFC300C 01A63023
FFFC3010 10300073		pfi
FFFC3014 00073083		ldo		$ra,[$sp]
FFFC3018 00870713		add		$sp,$sp,#8
FFFC301C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; PeekMsg will check for a message at a mailbox optionally dequeuing it.
                        	; If no message is available PeekMsg returns to the caller with a E_NoMsg
                        	; status.
                        	;
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = pointer where to put message D1
                        	;		a3 = pointer where to put message D2
                        	;		a4 = pointer where to put message D3
                        	;		a5 = 1 = remove from queue
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_PeekMsg:
FFFC3020 FF870713		sub		$sp,$sp,#8
FFFC3024 00173023		sto		$ra,[$sp]
FFFC3028 FF870713		sub		$sp,$sp,#8
FFFC302C 00173023		sto		$ra,[$sp]
FFFC3030 0209AD13		slt		$t0,$a1,#32
FFFC3034 10300073		pfi
FFFC3038 0E0D0863		beq		$t0,$x0,.badMbx
                        		; Lock system mutex
                        		
FFFC303C 18101873		csrrw	v0,#$181,x0
FFFC3040 01F87813		and		v0,v0,#MAX_TID
FFFC3044 000864B3	mov		$s6,$v0
FFFC3048 00181813		sll		$v0,$v0,#1
FFFC304C 00186813		or		$v0,$v0,#1
                        	.lock:
FFFC3050 10300073		pfi
FFFC3054 FFDC0637		sto		$v0,SYS_MUTEX
FFFC3058 F0060613
FFFC305C 00060633
FFFC3060 01063023
FFFC3064 FFDC0637		ldo		$v1,SYS_MUTEX
FFFC3068 F0060613
FFFC306C 00060633
FFFC3070 00063883
FFFC3074 FD181EE3		bne		$v0,$v1,.lock
                        	
FFFC3078 00599E13		sll		$t2,$a1,#LOG_MBXSZ	; convert handle to pointer
FFFC307C 00020637		add		$t2,$t2,#mbxs
FFFC3080 00060613
FFFC3084 01C60E33
FFFC3088 010E3D83		ldo		$t1,MBX_MQHEAD[$t2]
FFFC308C 080D8863		beq		$t1,$x0,.noMsg
FFFC3090 020B8863		beq		$a5,$x0,.nodq
FFFC3094 000DBE83		ldo		$t3,MSG_LINK[$t1]
FFFC3098 01DE3823		sto		$t3,MBX_MQHEAD[$t2]
FFFC309C 00024637		ldo		$t3,FreeMsg
FFFC30A0 35060613
FFFC30A4 00060633
FFFC30A8 00063E83
FFFC30AC 01DDB023		sto		$t3,MSG_LINK[$t1]
FFFC30B0 00024637		sto		$t1,FreeMsg
FFFC30B4 35060613
FFFC30B8 00060633
FFFC30BC 01B63023
                        	.nodq:
FFFC30C0 10300073		pfi
FFFC30C4 00010D37		ldi		$t0,#$10000
FFFC30C8 000D0D13
FFFC30CC 000A0A63		beqz	$a2,.nod1
FFFC30D0 008DBE83		ldo		$t3,MSG_D1[$t1]
FFFC30D4 300D2073		csrrs	$x0,#$300,$t0				; set mprv
FFFC30D8 01DA3023		sto		$t3,[$a2]
FFFC30DC 300D3073		csrrc	$x0,#$300,$t0				; clear mprv
                        	.nod1:
FFFC30E0 10300073		pfi
FFFC30E4 000A8A63		beqz	$a3,.nod2
FFFC30E8 010DBE83		ldo		$t3,MSG_D2[$t1]
FFFC30EC 300D2073		csrrs	$x0,#$300,$t0				; set mprv
FFFC30F0 01DAB023		sto		$t3,[$a3]
FFFC30F4 300D3073		csrrc	$x0,#$300,$t0				; clear mprv
                        	.nod2:
FFFC30F8 10300073		pfi
FFFC30FC 000B0A63		beqz	$a4,.nod3
FFFC3100 018DBE83		ldo		$t3,MSG_D3[$t1]
FFFC3104 300D2073		csrrs	$x0,#$300,$t0				; set mprv
FFFC3108 01DB3023		sto		$t3,[$a4]
FFFC310C 300D3073		csrrc	$x0,#$300,$t0				; clear mprv
                        	.nod3:
FFFC3110 10300073		pfi
FFFC3114 00006813		ldi		$v0,#E_Ok
FFFC3118 00000A63		bra		.ret
                        	.noMsg:
FFFC311C 10300073		pfi
FFFC3120 00B06813		ldi		$v0,#E_NoMsg
FFFC3124 00000463		bra		.ret
                        	.badMbx:
FFFC3128 00406813		ldi		$v0,#E_BadMbx				; return null pointer if bad mailbox
                        	.ret:
FFFC312C 10300073		pfi
                        		; Unlock system mutex
FFFC3130 00149D13		sll		$t0,$s6,#1
FFFC3134 FFDC0637		sto		$t0,SYS_MUTEX
FFFC3138 F0060613
FFFC313C 00060633
FFFC3140 01A63023
FFFC3144 00073083		ldo		$ra,[$sp]
FFFC3148 00870713		add		$sp,$sp,#8
FFFC314C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Calling WaitMsg will cause the task to be queued at the mailbox and a task
                        	; switch to occur if there are no messages at the mailbox.
                        	;
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = pointer where to put message D1
                        	;		a3 = pointer where to put message D2
                        	;		a4 = pointer where to put message D3
                        	;		a5 = time limit
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_WaitMsg:
FFFC3150 FF870713		sub		$sp,$sp,#8
FFFC3154 00173023		sto		$ra,[$sp]
FFFC3158 000BE433		mov		$s5,$a5
FFFC315C 00106B93		ldi		$a5,#1
FFFC3160 10300073		pfi
FFFC3164 EBDFF0EF		call	FMTK_PeekMsg				; check for a message, return if available
FFFC3168 00B06D93		ldi		$t1,#E_NoMsg
FFFC316C 01B80463		beq		$v0,$t1,.qt					; no message? Then go queue task
FFFC3170 0A000263		bra		.xit
                        	.qt:
FFFC3174 10300073		pfi
                        		; Lock system mutex
                        		
FFFC3178 18101873		csrrw	v0,#$181,x0
FFFC317C 01F87813		and		v0,v0,#MAX_TID
FFFC3180 000864B3	mov		$s6,$v0
FFFC3184 00181813		sll		$v0,$v0,#1
FFFC3188 00186813		or		$v0,$v0,#1
                        	.lock:
FFFC318C 10300073		pfi
FFFC3190 FFDC0637		sto		$v0,SYS_MUTEX
FFFC3194 F0060613
FFFC3198 00060633
FFFC319C 01063023
FFFC31A0 FFDC0637		ldo		$v1,SYS_MUTEX
FFFC31A4 F0060613
FFFC31A8 00060633
FFFC31AC 00063883
FFFC31B0 FD181EE3		bne		$v0,$v1,.lock
                        	
FFFC31B4 00106E13		ldi		$t2,#1
FFFC31B8 010E1E33		sll		$t2,$t2,$v0
FFFC31BC 00599E93		sll		$t3,$a1,#LOG_MBXSZ	; convert handle to pointer
FFFC31C0 00020637		add		$t3,$t3,#mbxs
FFFC31C4 00060613
FFFC31C8 01D60EB3
FFFC31CC 10300073		pfi
FFFC31D0 008EBF03		ldo		$t4,MBX_WTIDS[$t3]	; get waiting task list
FFFC31D4 01CF6F33		or		$t4,$t4,$t2					; set bit for tid
FFFC31D8 01EEB423		sto		$t4,MBX_WTIDS[$t3]	; save task list
FFFC31DC 00A81F13		sll		$t4,$v0,#LOG_TCBSZ	; convert tid to TCB pointer
FFFC31E0 288F4E83		ldbu	$t3,TCBStatus[$t4]
FFFC31E4 008EEE93		or		$t3,$t3,#TS_WAITMSG	; set waiting for message status
FFFC31E8 FFEEFE93		and		$t3,$t3,#~TS_READY	; not ready
FFFC31EC 10300073		pfi
FFFC31F0 29DF0423		stb		$t3,TCBStatus[$t4]
FFFC31F4 293F0623		stb		$a1,TCBWaitMbx[$t4]	; set mailbox task is waiting for
FFFC31F8 000BE9B3		mov		$a1,$a5
                        		; Unlock system mutex
FFFC31FC 00149D13		sll		$t0,$s6,#1
FFFC3200 FFDC0637		sto		$t0,SYS_MUTEX
FFFC3204 F0060613
FFFC3208 00060633
FFFC320C 01A63023
                        		; Continue by switching tasks
FFFC3210 C50FF0EF		call		FMTK_Sleep
                        	.xit:
FFFC3214 10300073		pfi
FFFC3218 00073083		ldo		$ra,[$sp]
FFFC321C 00870713		add		$sp,$sp,#8
FFFC3220 00008067		ret
                        	
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/tcb.r5a",1
                        	.file "../fmtk/tcb.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../fmtk/tcb.r5a",25
                        		code
                        		align	4                        	
                        	;------------------------------------------------------------------------------
                        	; Insert task into ready list. The list is a doubly linked circular list.
                        	;
                        	; Parameters:
                        	;		a0 = tid to insert
                        	; Modifies:
                        	;		v1,t0,t1,t2
                        	; Returns:
                        	;		v0 = 1 for success, 0 if failed
                        	;------------------------------------------------------------------------------
                        	
                        	InsertIntoReadyList:
FFFC3224 00006813		ldi		$v0,#E_Ok						; setup for ok
FFFC3228 01F06893		ldi		$v1,#MAX_TID				; check argument
FFFC322C 0928EA63		bgtu	$a0,$v1,.badTid
FFFC3230 00A91E93		sll		$t3,$a0,#LOG_TCBSZ	; tid to pointer
FFFC3234 288ECD03		ldbu	$t0,TCBStatus[$t3]	; set status to ready
FFFC3238 001D6D13		or		$t0,$t0,#TS_READY
FFFC323C 29AE8423		sb		$t0,TCBStatus[$t3]
FFFC3240 289E8D03		ldb		$t0,TCBPriority[$t3]
FFFC3244 19A9000D		insrdy	$a0,$t0
	ret
FFFC3248 00008067
FFFC324C 003D7D13		and		$t0,$t0,#3					; limit to four
FFFC3250 001D1D13		sll		$t0,$t0,#1					; *2 for indexing
FFFC3254 00024637		ldw		$t1,READYQ[$t0]			; get head of queue for that priority
FFFC3258 30860613
FFFC325C 01A60633
FFFC3260 00061D83
FFFC3264 020DD063		bge		$t1,$x0,.insert			; Is there a head?
                        		; level 0 insert - nothing in list, create a ring to self
FFFC3268 00024637		stw		$a0,READYQ[$t0]			; no head, simple to insert
FFFC326C 30860613
FFFC3270 01A60633
FFFC3274 01261023
FFFC3278 2D2E9823		stw		$a0,TCBNext[$t3]		; remember it's a ring
FFFC327C 2D2E9C23		stw		$a0,TCBPrev[$t3]
FFFC3280 00008067		ret
                        		; Insert at tail of list, which is just before the head.
                        	.insert:
FFFC3284 00AD9F13		sll		$t4,$t1,#LOG_TCBSZ	; tid to pointer
FFFC3288 2D8F1E03		ldw		$t2,TCBPrev[$t4]		; t2 = head->prev
FFFC328C 01BE1C63		bne		$t2,$t1,.level2
                        		;level 1 insert - only 1 item currently in list, items point to each other
                        		; This bit probably redundant code as normal insertion should work as well.
FFFC3290 2D2F1C23		stw		$a0,TCBPrev[$t4]		; simple to insert
FFFC3294 2D2F1823		stw		$a0,TCBNext[$t4]		; head->prev = head->next = arg
FFFC3298 2DBE9C23		stw		$t1,TCBPrev[$t3]		; arg->prev = arg->next = head
FFFC329C 2DBE9823		stw		$t1,TCBNext[$t3]
FFFC32A0 00008067		ret
                        		; Here there will be three or more entries in the list. Arg is inserted
                        		; between head and head->prev to make it the last on the list.
                        	.level2:
FFFC32A4 2DCE9C23		stw		$t2,TCBPrev[$t3]		; arg->prev = head->prev
FFFC32A8 2DBE9823		stw		$t1,TCBNext[$t3]		; arg->next = head, arg links are now set
                        		; If there's a head there should be a head->prev and head->next at least pointing to the head
FFFC32AC 000E4663		bltz	$t2,.0001						; head->prev valid?
FFFC32B0 00AE1E93		sll		$t3,$t2,#LOG_TCBSZ	; t3 = head->prev (as a pointer)
FFFC32B4 2D2E9823		stw		$a0,TCBNext[$t3]		; head->prev->next = arg
                        	.0001:
FFFC32B8 2D2F1C23		stw		$a0,TCBPrev[$t4]		; head->prev = arg
FFFC32BC 00008067		ret
                        	.badTid:
FFFC32C0 00106813		ldi		$v0,#E_Arg
FFFC32C4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; The ready list is a doubly linked list to make it easier and faster to
                        	; remove items from the list. There's no need to search the list for the item
                        	; to remove.
                        	;
                        	; Parameters:
                        	;		a0 = tid to remove
                        	; Modifies:
                        	;		t0,t1,t2,t3,t4,t5
                        	; Returns:
                        	;		v0 = E_Ok for success
                        	;------------------------------------------------------------------------------
                        	
                        	RemoveFromReadyList:
FFFC32C8 01F06893		ldi		$v1,#MAX_TID					; check arg
FFFC32CC 0128F863		bleu	$a0,$v1,.tidOk
FFFC32D0 00106813		ldi		$v0,#E_Arg
FFFC32D4 00000637		jmp		ERETx
FFFC32D8 25060067
                        	.tidOk:
FFFC32DC 1A09000D		rmvrdy	$a0									; cheat and use hardware
FFFC32E0 00A91F13		sll		$t4,$a0,#LOG_TCBSZ		; s1 = pointer to tcb
FFFC32E4 288F0D03		ldb		$t0,TCBStatus[$t4]		; set status no longer ready or running
FFFC32E8 F7ED7D13		and		$t0,$t0,#~(TS_READY|TS_RUNNING)
	stb		$t0,TCBStatus[$t4]
FFFC32EC 29AF0423
FFFC32F0 00008067		ret
                        	
                        	RemoveFromReadyList2:
FFFC32F4 01F06893		ldi		$v1,#MAX_TID					; check arg
FFFC32F8 0928E063		bgtu	$a0,$v1,.badTid
FFFC32FC 00A91F13		sll		$t4,$a0,#LOG_TCBSZ		; s1 = pointer to tcb
FFFC3300 288F0D03		ldb		$t0,TCBStatus[$t4]		; set status no longer ready or running
FFFC3304 F7ED7D13		and		$t0,$t0,#~(TS_READY|TS_RUNNING)
	stb		$t0,TCBStatus[$t4]
FFFC3308 29AF0423
FFFC330C 289F0D03		ldb		$t0,TCBPriority[$t4]	; t0 = priority
FFFC3310 003D7D13		and		$t0,$t0,#3						; limit to 0-3
FFFC3314 001D1D13		sll		$t0,$t0,#1						; *2 for indexing
FFFC3318 00024637		ldw		$t1,READYQ[$t0]				; get head tid
FFFC331C 30860613
FFFC3320 01A60633
FFFC3324 00061D83
FFFC3328 2D0F1E03		ldw		$t2,TCBNext[$t4]			; get arg->next
FFFC332C 012D9E63		bne		$t1,$a0,.0001					; removing head of list?
FFFC3330 012E1463		bne		$t2,$a0,.0003					; list emptying? (if arg->next points back to arg)
FFFC3334 FFF06E13		ldi		$t2,#-1
                        	.0003:
FFFC3338 00024637		stw		$t2,READYQ[$t0]				; yes, set new head to arg->next
FFFC333C 30860613
FFFC3340 01A60633
FFFC3344 01C61023
                        	.0001:
FFFC3348 000E4E63		bltz	$t2,.0002							; validate t2 (arg->next)
FFFC334C 011E7C63		bgeu	$t2,$v1,.0002					; there should always be an arg->next, arg->prev
FFFC3350 2D8F1E83		ldw		$t3,TCBPrev[$t4]			; because the list is circular t3=arg->prev
FFFC3354 00AE9F93		sll		$t5,$t3,#LOG_TCBSZ		; t5 = arg->prev as a pointer
FFFC3358 2DCF9823		stw		$t2,TCBNext[$t5]			; arg->prev->next = arg->next
FFFC335C 00AE1F93		sll		$t5,$t2,#LOG_TCBSZ		; t5 = arg->next as a pointer
FFFC3360 2DDF9C23		stw		$t3,TCBPrev[$t5]			; arg->next->prev = arg->prev
                        		; Now indicate links in TCB are not in use.
                        	.0002:
FFFC3364 FFF06813		ldi		$v0,#-1
FFFC3368 2D0F1823		stw		$v0,TCBNext[$t4]
FFFC336C 2D0F1C23		stw		$v0,TCBPrev[$t4]
FFFC3370 00006813		ldi		$v0,#E_Ok							; we're ok
FFFC3374 00008067		ret
                        	.badTid:
FFFC3378 00106813		ldi		$v0,#E_Arg
FFFC337C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = task id to insert
                        	;		a1 = timeout value
                        	; Modifies:
                        	;		t0,t1,t2,t3,t4,t5
                        	;------------------------------------------------------------------------------
                        	
                        	InsertIntoTimeoutList:
FFFC3380 1139000D		setto	$a0,$a1
	sll		$t5,$a0,#LOG_TCBSZ		; tid to pointer
FFFC3384 00A91F93
FFFC3388 288FCE03		ldbu	$t2,TCBStatus[$t5]		; set status to timing out
FFFC338C 010E6E13		or		$t2,$t2,#TS_TIMEOUT
FFFC3390 29CF8423		stb		$t2,TCBStatus[$t5]
FFFC3394 00006813		ldi		$v0,#E_Ok
FFFC3398 00008067		ret
FFFC339C FFF06D13		ldi		$t0,#-1						
FFFC33A0 2DAF9823		stw		$t0,TCBNext[$t5]			; initialize indexes to -1
FFFC33A4 2DAF9C23		stw		$t0,TCBPrev[$t5]
FFFC33A8 00024637		ldw		$t0,TimeoutList
FFFC33AC 32860613
FFFC33B0 00060633
FFFC33B4 00061D03
FFFC33B8 020D5063		bge		$t0,$x0,.0001
                        		; Here the timeout list was empty, easy to insert.
FFFC33BC 2F3FA023		stt		$a1,TCBTimeout[$t5]		; set timeout for task
FFFC33C0 00024637		stw		$a0,TimeoutList				; set head of list
FFFC33C4 32860613
FFFC33C8 00060633
FFFC33CC 01261023
FFFC33D0 00006813		ldi		$v0,#E_Ok							; and return
FFFC33D4 00008067		ret
                        	.0001:
FFFC33D8 FFF06D93		ldi		$t1,#-1								; t1 used as previous index
FFFC33DC 000D6E33		mov		$t2,$t0								; t2 = head of timeout list index
FFFC33E0 00AE1E93		sll		$t3,$t2,#LOG_TCBSZ		; t3 = head of timeout list as a pointer
                        		; Search the timeout list for the proper insertion point. The timeouts are
                        		; relative, so the requested amount is decremented by the amounts in the
                        		; list as it is searched.
                        	.beginWhile:
FFFC33E4 2E0EAF03		ldt		$t4,TCBTimeout[$t3]		; get the timeout
FFFC33E8 033F5663		ble		$a1,$t4,.endWhile			; is it greater than the requested timeout ?
FFFC33EC 41E989B3		sub		$a1,$a1,$t4						; decrement by list amount
FFFC33F0 000EEDB3		mov		$t1,$t3								; t1 = pointer to previous entry
FFFC33F4 2D0E9E83		ldw		$t3,TCBNext[$t3]			; get the next entry in list
FFFC33F8 000EC663		bltz	$t3,.endOfList					; end of list?
FFFC33FC 00AE9E93		sll		$t3,$t3,#LOG_TCBSZ		; no, set pointer to current entry
FFFC3400 FFBE92E3		bne		$t3,$t1,.beginWhile		; list screwed up? (This test should always be true)
                        	.endOfList:
                        		; Here the end of the list was reached, insert as last entry
FFFC3404 2D2D9823		stw		$a0,TCBNext[$t1]			; entry->next = arg
FFFC3408 2DBF9C23		stw		$t1,TCBPrev[$t5]			; arg->prev = entry
FFFC340C 2F3FA023		stt		$a1,TCBTimeout[$t5]
FFFC3410 04000063		bra		.0003
                        	.endWhile:
                        		; Here we found a timeout greater than the requested amount. Insert before.
FFFC3414 20AEDE13		sra		$t2,$t3,#LOG_TCBSZ		; pointer to tid
FFFC3418 2DCF9823		stw		$t2,TCBNext[$t5]			; arg->next = entry
FFFC341C 20ADDE13		sra		$t2,$t1,#LOG_TCBSZ
FFFC3420 2DCF9C23		stw		$t2,TCBPrev[$t5]			; arg->prev = prev entry
FFFC3424 2E0EAE03		ldt		$t2,TCBTimeout[$t3]		; update timeout of entry by subtracting off
FFFC3428 413E0E33		sub		$t2,$t2,$a1						; the arg's timeout
FFFC342C 2FCEA023		stt		$t2,TCBTimeout[$t3]
FFFC3430 2D2E9C23		stw		$a0,TCBPrev[$t3]			; entry->prev = arg
FFFC3434 000DC663		bltz	$t1,.0002							; previous entry? no - go update list head
FFFC3438 2D2D9823		stw		$a0,TCBNext[$t1]			; prev entry->next = arg
FFFC343C 00000A63		bra		.0003
                        	.0002:
FFFC3440 00024637		stw		$a0,TimeoutList				; list head = arg
FFFC3444 32860613
FFFC3448 00060633
FFFC344C 01261023
                        	.0003:
FFFC3450 288FCE03		ldbu	$t2,TCBStatus[$t5]		; set status to timing out
FFFC3454 010E6E13		or		$t2,$t2,#TS_TIMEOUT
FFFC3458 29CF8423		stb		$t2,TCBStatus[$t5]
FFFC345C 00006813		ldi		$v0,#E_Ok
FFFC3460 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Remove a task from the timeout list. The timeouts of following tasks are
                        	; adjusted. Called when a mailbox is freed and a task is waiting at the
                        	; mailbox. From within scheduling code mPopTimeoutList is used instead.
                        	;
                        	; Parameters:
                        	;		a0 = task id to remove
                        	; Modifies:
                        	;		t0,t3,t4
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	RemoveFromTimeoutList:
FFFC3464 00A91E93		sll		$t3,$a0,#LOG_TCBSZ		; tid to pointer
FFFC3468 288ECD03		ldbu	$t0,TCBStatus[$t3]		; check if waiting at a mailbox
FFFC346C 008D7D13		and		$t0,$t0,#TS_WAITMSG
FFFC3470 000D0463		beqz	$t0,.noWait				
FFFC3474 819FF0EF		call	MbxRemoveTask					; remove task from mailbox
                        	.noWait:
FFFC3478 FE7D7D13		and		$t0,$t0,#~(TS_TIMEOUT|TS_WAITMSG)
	stb		$t0,TCBStatus[$t3]
FFFC347C 29AE8423
FFFC3480 1009000D		setto	$a0,$x0
	ldi		$v0,#E_Ok
FFFC3484 00006813
FFFC3488 00008067		ret
                        	
FFFC348C 00024637		ldw		$t1,TimeoutList
FFFC3490 32860613
FFFC3494 00060633
FFFC3498 00061D83
FFFC349C 2D0E9D03		ldw		$t0,TCBNext[$t3]			; t0 = arg->next
FFFC34A0 01B91A63		bne		$a0,$t1,.0001					; check removing head of list
FFFC34A4 00024637		stw		$t0,TimeoutList				; set new head = arg->next
FFFC34A8 32860613
FFFC34AC 00060633
FFFC34B0 01A61023
                        	.0001:
FFFC34B4 020D4063		bltz	$t0,.noNext
FFFC34B8 00AD1F13		sll		$t4,$t0,#LOG_TCBSZ
FFFC34BC 2D8E9D83		ldw		$t1,TCBPrev[$t3]			; next->prev = arg->prev
FFFC34C0 2DBF1C23		stw		$t1,TCBPrev[$t4]			
FFFC34C4 2E0F2D83		ldt		$t1,TCBTimeout[$t4]		; next->timeout += arg->timeout
FFFC34C8 2E0EAE03		ldt		$t2,TCBTimeout[$t3]
FFFC34CC 01CD8DB3		add		$t1,$t1,$t2
FFFC34D0 2FBF2023		stt		$t1,TCBTimeout[$t4]
                        	.noNext:
FFFC34D4 2D8E9D03		ldw		$t0,TCBPrev[$t3]			; check for previous
FFFC34D8 000D4863		bltz	$t0,.noPrev
FFFC34DC 00AD1F13		sll		$t4,$t0,#LOG_TCBSZ
FFFC34E0 2D0E9D03		ldw		$t0,TCBNext[$t3]			; prev->next = arg->next
FFFC34E4 2DAF1823		stw		$t0,TCBNext[$t4]
                        	.noPrev:
FFFC34E8 288E8D03		ldb		$t0,TCBStatus[$t3]		; no longer timing out
FFFC34EC FE7D7D13		and		$t0,$t0,#~(TS_TIMEOUT|TS_WAITMSG)
	stb		$t0,TCBStatus[$t3]
FFFC34F0 29AE8423
FFFC34F4 FFF06D13		ldi		$t0,#-1								; reset links
FFFC34F8 2DAE9823		stw		$t0,TCBNext[$t3]
FFFC34FC 2DAE9C23		stw		$t0,TCBPrev[$t3]
FFFC3500 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Returns:
                        	;		v1 = process id
                        	;------------------------------------------------------------------------------
                        	
                        	AllocTCB:
FFFC3504 00006D93		ldi		$t1,#0
FFFC3508 00024637		ldtu	$v1,PIDMAP
FFFC350C 31060613
FFFC3510 00060633
FFFC3514 00066883
                        	.0001:
FFFC3518 0018FD13		and		$t0,$v1,#1
FFFC351C 020D0463		beqz	$t0,.allocTid
FFFC3520 0018D893		srl		$v1,$v1,#1
FFFC3524 80000637		or		$v1,$v1,#$80000000
FFFC3528 00060613
FFFC352C 011668B3
FFFC3530 001D8D93		add		$t1,$t1,#1
FFFC3534 01FDFD93		and		$t1,$t1,#31
FFFC3538 FE0D90E3		bnez	$t1,.0001
                        	; here no tcbs available
FFFC353C 04506813		ldi		$v0,#E_NoMoreTCBs
FFFC3540 00008067		ret
                        	.allocTid:
FFFC3544 000DE833		mov		$v0,$t1
FFFC3548 0018E893		or		$v1,$v1,#1
FFFC354C 000D8A63		beqz	$t1,.0003
                        	.0002:
FFFC3550 00189893		sll		$v1,$v1,#1
FFFC3554 0018E893		or		$v1,$v1,#1
FFFC3558 FFFD8D93		sub		$t1,$t1,#1
FFFC355C FE0D9AE3		bnez	$t1,.0002
                        	.0003:
FFFC3560 00024637		stt		$v1,PIDMAP
FFFC3564 31060613
FFFC3568 00060633
FFFC356C 01162023
FFFC3570 000868B3		mov		$v1,$v0
FFFC3574 00006813		ldi		$v0,#E_Ok
FFFC3578 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FreeTCB:
FFFC357C 00106D13		ldi		$t0,#1
FFFC3580 012D1D33		sll		$t0,$t0,$a0
FFFC3584 FFFD4D13		xor		$t0,$t0,#-1
FFFC3588 00024637		ldtu	$t1,PIDMAP
FFFC358C 31060613
FFFC3590 00060633
FFFC3594 00066D83
FFFC3598 01ADFDB3		and		$t1,$t1,$t0
FFFC359C 00024637		stt		$t1,PIDMAP
FFFC35A0 31060613
FFFC35A4 00060633
FFFC35A8 01B62023
FFFC35AC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Diagnostics
                        	;------------------------------------------------------------------------------
                        	
                        	DumpReadyList:
FFFC35B0 FC070713		sub		$sp,$sp,#64
FFFC35B4 00173023		sto		$ra,[$sp]
FFFC35B8 01273423		sto		$a0,8[$sp]
FFFC35BC 01473823		sto		$a2,16[$sp]
FFFC35C0 01573C23		sto		$a3,24[$sp]
FFFC35C4 03B73023		sto		$t1,32[$sp]
FFFC35C8 03C73423		sto		$t2,40[$sp]
FFFC35CC 03D73823		sto		$t3,48[$sp]
FFFC35D0 02473C23		sto		$s1,56[$sp]
FFFC35D4 FFFC3937		ldi		$a0,#msgReadyList
FFFC35D8 74090913
FFFC35DC B00FD0EF		call	PutString
FFFC35E0 00006D93		ldi		$t1,#0
FFFC35E4 3000F273		csrrc	$s1,#$300,#1
                        	.0002:
FFFC35E8 94CFE0EF		call	SerialPeekCharDirect
FFFC35EC 00384813		xor		$v0,$v0,#CTRLC
FFFC35F0 08080263		beqz	$v0,.brk
FFFC35F4 00D06913		ldi		$a0,#CR
FFFC35F8 C9DFC0EF		call	Putch
FFFC35FC 05106913		ldi		$a0,#'Q'
FFFC3600 C95FC0EF		call	Putch
FFFC3604 001DD913		srl		$a0,$t1,#1
FFFC3608 A88FD0EF		call	PutHexNybble
FFFC360C 03A06913		ldi		$a0,#':'
FFFC3610 C85FC0EF		call	Putch
FFFC3614 00024637		ldw		$a2,READYQ[$t1]
FFFC3618 30860613
FFFC361C 01B60633
FFFC3620 00061A03
FFFC3624 040A4263		blt		$a2,$x0,.nxt
FFFC3628 000A6AB3		mov		$a3,$a2
                        	.0001:
FFFC362C 000AE933		mov		$a0,$a3
FFFC3630 A18FD0EF		call	PutHexHalf
FFFC3634 02006913		ldi		$a0,#' '
FFFC3638 C5DFC0EF		call	Putch
FFFC363C 00AA9A93		sll		$a3,$a3,#LOG_TCBSZ
FFFC3640 2D0A9903		ldw		$a0,TCBNext[$a3]
FFFC3644 A04FD0EF		call	PutHexHalf
FFFC3648 02006913		ldi		$a0,#' '
FFFC364C C49FC0EF		call	Putch
FFFC3650 2D8A9903		ldw		$a0,TCBPrev[$a3]
FFFC3654 9F4FD0EF		call	PutHexHalf
FFFC3658 00D06913		ldi		$a0,#CR
FFFC365C C39FC0EF		call	Putch
FFFC3660 2D0A9A83		ldw		$a3,TCBNext[$a3]
FFFC3664 FD5A14E3		bne		$a2,$a3,.0001
                        	.nxt:
FFFC3668 002D8D93		add		$t1,$t1,#2
FFFC366C 008DAE13		slt		$t2,$t1,#8
FFFC3670 F60E1CE3		bnez	$t2,.0002
                        	.brk:
FFFC3674 30021073		csrrw	$x0,#$300,$s1
FFFC3678 00073083		ldo		$ra,[$sp]
FFFC367C 00873903		ldo		$a0,8[$sp]
FFFC3680 01073A03		ldo		$a2,16[$sp]
FFFC3684 01873A83		ldo		$a3,24[$sp]
FFFC3688 02073D83		ldo		$t1,32[$sp]
FFFC368C 02873E03		ldo		$t2,40[$sp]
FFFC3690 03073E83		ldo		$t3,48[$sp]
FFFC3694 03873203		ldo		$s1,56[$sp]
FFFC3698 04070713		add		$sp,$sp,#64
FFFC369C 00008067		ret
                        	
                        	DumpTimeoutList:
FFFC36A0 FE070713		sub		$sp,$sp,#32
FFFC36A4 00172023		stt		$ra,[$sp]
FFFC36A8 01272223		stt		$a0,4[$sp]
FFFC36AC 01472423		stt		$a2,8[$sp]
FFFC36B0 01572623		stt		$a3,12[$sp]
FFFC36B4 01B72823		stt		$t1,16[$sp]
FFFC36B8 01C72A23		stt		$t2,20[$sp]
FFFC36BC 01D72C23		stt		$t3,24[$sp]
FFFC36C0 00472E23		stt		$s1,28[$sp]
FFFC36C4 FFFC3937		ldi		$a0,#msgTimeoutList
FFFC36C8 77190913
FFFC36CC A10FD0EF		call	PutString
FFFC36D0 00006D93		ldi		$t1,#0
FFFC36D4 3000F273		csrrc	$s1,#$300,#1
FFFC36D8 00006A93		ldi		$a3,#0
                        	.0002:
FFFC36DC 858FE0EF		call	SerialPeekCharDirect
FFFC36E0 00384813		xor		$v0,$v0,#CTRLC
FFFC36E4 02080863		beqz	$v0,.brk
FFFC36E8 00D06913		ldi		$a0,#CR
FFFC36EC BA9FC0EF		call	Putch
                        	;	ldw		$a2,TimeoutList
                        	;	bltz	$a2,.brk
                        	;	mov		$a3,$a2
                        	;.0001:
FFFC36F0 000AE933		mov		$a0,$a3
FFFC36F4 954FD0EF		call	PutHexHalf
FFFC36F8 02D06913		ldi		$a0,#'-'
FFFC36FC B99FC0EF		call	Putch
FFFC3700 120D890D		getto	$a0,$t1
;	sll		$a3,$a3,#LOG_TCBSZ
                        	;	ldt		$a0,TCBTimeout[$a3]
FFFC3704 920FD0EF		call	PutHexWord
                        	;	ldi		$a0,#CR
                        	;	call	Putch
FFFC3708 001A8A93		add		$a3,$a3,#1
FFFC370C 00FAFA93		and		$a3,$a3,#15
FFFC3710 FD5046E3		bgt		$a3,$x0,.0002
                        	;	ldw		$a3,TCBNext[$a3]
                        	;	bge		$a3,$x0,.0001
                        	.brk:
FFFC3714 30021073		csrrw	$x0,#$300,$s1
FFFC3718 00072083		ldt		$ra,[$sp]
FFFC371C 00472903		ldt		$a0,4[$sp]
FFFC3720 00872A03		ldt		$a2,8[$sp]
FFFC3724 00C72A83		ldt		$a3,12[$sp]
FFFC3728 01072D83		ldt		$t1,16[$sp]
FFFC372C 01472E03		ldt		$t2,20[$sp]
FFFC3730 01872E83		ldt		$t3,24[$sp]
FFFC3734 01C72203		ldt		$s1,28[$sp]
FFFC3738 02070713		add		$sp,$sp,#32
FFFC373C 00008067		ret
                        	
                        	msgReadyList:
FFFC3740 6165520D		db	CR,"Ready List",CR
FFFC3744 4C207964
FFFC3748 0D747369
FFFC374C 20657551		db	"Que Tid  Prv  Nxt",CR
FFFC3750 20646954
FFFC3754 76725020
FFFC3758 784E2020
FFFC375C 2D2D0D74
FFFC375E 2D2D2D2D		db	"-----------------",CR,0
FFFC3762 2D2D2D2D
FFFC3766 2D2D2D2D
FFFC376A 2D2D2D2D
FFFC376E 0D000D2D
                        	
                        	msgTimeoutList:
FFFC3771 6D69540D		db	CR,"Timeout List",CR
FFFC3775 74756F65
FFFC3779 73694C20
FFFC377D 54200D74
FFFC377F 64695420		db	" Tid - Timeout",CR
FFFC3783 54202D20
FFFC3787 6F656D69
FFFC378B 2D0D7475
FFFC378E 2D2D2D2D		db	"--------------",CR,0
FFFC3792 2D2D2D2D
FFFC3796 2D2D2D2D
FFFC379A 000D2D2D
                        	
FFFC379E E0730000		align 
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/iofocus.r5a",1
                        	.file "../fmtk/iofocus.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;-----------------------------------------------------------------------------
                        	; IO Focus routines complicated by the fact that the base address of TCB
                        	; zero is zero (looks like a null pointer but isn't). So the value -1 is 
                        	; used to indicate no focus index.
                        	;-----------------------------------------------------------------------------
                        	
                        	.file "../fmtk/iofocus.r5a",31
                        		code
                        		align	4                        	
                        	
                        	;-----------------------------------------------------------------------------
                        	; Determine if the currently running task has the I/O focus.
                        	;
                        	; Stack Space:
                        	;		2 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		v0 = E_Ok
                        	;		v1 = 1 if task has IO focus, 0 otherwise
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_HasIOFocus:
                        		; Enable interrupts
FFFC37A0 3000E073		csrrs	$x0,#$300,#1				
FFFC37A4 00025637		ldb		$v0,SwitchIOFocus
FFFC37A8 82060613
FFFC37AC 00060633
FFFC37B0 00060803
FFFC37B4 00080C63		beqz	$v0,.noSwitch
FFFC37B8 00025637		stb		$x0,SwitchIOFocus
FFFC37BC 82060613
FFFC37C0 00060633
FFFC37C4 00060023
FFFC37C8 038000EF		call	FMTK_SwitchIOFocus
                        	.noSwitch:
                        		
FFFC37CC 18101873		csrrw	v0,#$181,x0
FFFC37D0 01F87813		and		v0,v0,#MAX_TID
FFFC37D4 00A81813	sll		$v0,$v0,#LOG_TCBSZ
FFFC37D8 3000F073		csrrc	$x0,#$300,#1				; disable ints
FFFC37DC 2400088D		nxtiof	$v1
FFFC37E0 2600088D		prviof	$v1
FFFC37E4 3000E073		csrrs	$x0,#$300,#1				
                        	;	ldo		$v1,IOFocusNdx
FFFC37E8 01180663		beq		$v0,$v1,.hasFocus
FFFC37EC 00006893		ldi		$v1,#0
FFFC37F0 00000463		bra		.xit
                        	.hasFocus:
FFFC37F4 00106893		ldi		$v1,#1
                        	.xit:
FFFC37F8 00006813		ldi		$v0,#E_Ok
FFFC37FC 00008067		ret
                        	
                        	;-----------------------------------------------------------------------------
                        	; First check if it's even possible to switch the focus to another
                        	; task. The I/O focus list could be empty or there may be only a
                        	; single task in the list. In either case it's not possible to
                        	; switch.
                        	;
                        	;	Parameters:
                        	;		none
                        	;	Modifies:
                        	;		a0,a1,t0,t1,t2,t3
                        	;	Returns:
                        	;		v0 = E_Ok
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_SwitchIOFocus:
FFFC3800 FF870713		sub		$sp,$sp,#8
FFFC3804 00173023		sto		$ra,[$sp]
FFFC3808 24000D0D		nxtiof	$t0
FFFC380C 26000D8D		prviof	$t1
FFFC3810 09BD0C63		beq		$t0,$t1,.sameFocus
FFFC3814 080D4A63		bltz	$t0,.noFocus
FFFC3818 24000D0D		nxtiof	$t0
                        	
                        	;	ldo		$t0,IOFocusNdx			; get focus pointer
                        	;	bltz	$t0,.noFocus				; is it -1?
                        	;	ldo		$t1,IOF_NEXT[$t0]
                        	;	beq		$t1,$t0,.sameFocus
                        	;	bltz	$t1,.noFocus
FFFC381C 3000E073		csrrs	$x0,#$300,#1				; enable interrupts
                        		; swap virtual text screens
FFFC3820 65806213		ldi		$s1,#56*29
FFFC3824 330D3E03		ldo		$t2,TCBVideoMem[$t0]
FFFC3828 020E0A63		beqz	$t2,.0002
FFFC382C 33CD3C23		sto		$t2,TCBpVideo[$t0]
FFFC3830 FFD00EB7		ldi		$t3,#$FFD00000
FFFC3834 000E8E93
FFFC3838 00AD5913		srl		$a0,$t0,#LOG_TCBSZ
FFFC383C 000E69B3		mov		$a1,$t2
FFFC3840 AC9FD0EF		call	VirtToPhys
                        	.0001:
FFFC3844 000EBF03		ldo		$t4,[$t3]
FFFC3848 01E83023		sto		$t4,[$v0]
FFFC384C 008E8E93		add		$t3,$t3,#8
FFFC3850 00880813		add		$v0,$v0,#8
FFFC3854 FFF20213		sub		$s1,$s1,#1
FFFC3858 FE4046E3		bgt		$s1,$x0,.0001
                        	.0002:
FFFC385C 65806213		ldi		$s1,#56*29
FFFC3860 330DBE03		ldo		$t2,TCBVideoMem[$t1]
FFFC3864 020E0A63		beqz	$t2,.0004
FFFC3868 FFD00EB7		ldi		$t3,#$FFD00000
FFFC386C 000E8E93
FFFC3870 33DDBC23		sto		$t3,TCBpVideo[$t1]
FFFC3874 00ADD913		srl		$a0,$t1,#LOG_TCBSZ
FFFC3878 000E69B3		mov		$a1,$t2
FFFC387C A8DFD0EF		call	VirtToPhys
                        	.0003:
FFFC3880 00083F03		ldo		$t4,[$v0]
FFFC3884 01EEB023		sto		$t4,[$t3]
FFFC3888 008E8E93		add		$t3,$t3,#8
FFFC388C 00880813		add		$v0,$v0,#8
FFFC3890 FFF20213		sub		$s1,$s1,#1
FFFC3894 FE4046E3		bgt		$s1,$x0,.0003
                        	.0004:
FFFC3898 00025637		sto		$t1,IOFocusNdx
FFFC389C 81060613
FFFC38A0 00060633
FFFC38A4 01B63023
                        	.sameFocus:
                        	.noFocus:
FFFC38A8 00006813		ldi		$v0,#E_Ok
FFFC38AC 00073083		ldo		$ra,[$sp]
FFFC38B0 00870713		add		$sp,$sp,#8
FFFC38B4 00008067		ret
                        	
                        	;-----------------------------------------------------------------------------
                        	; The I/O focus list is an array indicating which jobs are requesting the
                        	; I/O focus. The I/O focus is user controlled by pressing CNTRL-T on the
                        	; keyboard.
                        	;
                        	; Parameters:
                        	;		a1 = task id requesting focus for
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_RequestIOFocus:
FFFC38B8 2009800D		insiof	$a1
FFFC38BC 00006813		ldi		$v0,#E_Ok
FFFC38C0 00008067		ret
                        	
FFFC38C4 00106D13		ldi		$t0,#1
FFFC38C8 013D1D33		sll		$t0,$t0,$a1
FFFC38CC 00025637		ldo		$t1,IOFocusTbl			; Is the task already included in the IO focus?
FFFC38D0 81860613
FFFC38D4 00060633
FFFC38D8 00063D83
FFFC38DC 01ADFE33		and		$t2,$t1,$t0					; test bit
FFFC38E0 060E1463		bnez	$t2,.ret						; If so, don't add again
FFFC38E4 01ADEDB3		or		$t1,$t1,$t0					; set bit indicator
FFFC38E8 00025637		sto		$t1,IOFocusTbl
FFFC38EC 81860613
FFFC38F0 00060633
FFFC38F4 01B63023
                        		; Disable interrupts while manipulating IO focus list
FFFC38F8 3000F073		csrrc	$x0,#$300,#1				
FFFC38FC 00025637		ldo		$t0,IOFocusNdx			; get current index
FFFC3900 81060613
FFFC3904 00060633
FFFC3908 00063D03
FFFC390C 00A99D93		sll		$t1,$a1,#LOG_TCBSZ	; t1 = pointer to TCB
FFFC3910 020D5063		bge		$t0,$x0,.notEmpty		; is there one? (!= -1)
FFFC3914 00025637		sto		$t1,IOFocusNdx			; no current index, so set equal to requester
FFFC3918 81060613
FFFC391C 00060633
FFFC3920 01B63023
FFFC3924 2FBDB423		sto		$t1,IOF_NEXT[$t1]		; and loop back to self
FFFC3928 2FBDB823		sto		$t1,IOF_PREV[$t1]
FFFC392C 00000E63		bra		.ret
                        	.notEmpty:
FFFC3930 2F0D3E03		ldo		$t2,IOF_PREV[$t0]		; insert t1 into focus ring
FFFC3934 2FCDB823		sto		$t2,IOF_PREV[$t1]
FFFC3938 2FADB423		sto		$t0,IOF_NEXT[$t1]
FFFC393C 2F0D3E03		ldo		$t2,IOF_PREV[$t0]
FFFC3940 2FBE3423		sto		$t1,IOF_NEXT[$t2]
FFFC3944 2FBD3823		sto		$t1,IOF_PREV[$t0]
                        	.ret:
FFFC3948 00006813		ldi		$v0,#E_Ok
FFFC394C 00008067		ret
                        	
                        	;-----------------------------------------------------------------------------
                        	; ReleaseIOFocus called when the task no longer desires to be on the I/O
                        	; focus list.
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_ReleaseIOFocus:
                        		
FFFC3950 18101873		csrrw	v0,#$181,x0
FFFC3954 01F87813		and		v0,v0,#MAX_TID
FFFC3958 000869B3	mov		$a1,$v0
                        		; fall into ForceReleaseIOFocus
                        	
                        	;-----------------------------------------------------------------------------
                        	; Releasing the I/O focus causes the focus to switch if the running job
                        	; had the I/O focus.
                        	; ForceReleaseIOFocus forces the release of the IO focus for a job
                        	; different than the one currently running.
                        	; 
                        	; Stack Space:
                        	;		2 words
                        	; Parameters:
                        	;		a1 = task id to release
                        	; Returns:
                        	;		v0 = E_Ok
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_ForceReleaseIOFocus:
FFFC395C FF870713		sub		$sp,$sp,#8
FFFC3960 00173023		sto		$ra,[$sp]
FFFC3964 2209880D		rmviof	$v0,$a1
	beqz	$v0,.noSwitch
FFFC3968 00080463
FFFC396C E95FF0EF		call	FMTK_SwitchIOFocus
                        	.noSwitch:
FFFC3970 00073083		ldo		$ra,[$sp]
FFFC3974 00870713		add		$sp,$sp,#8
FFFC3978 00006813		ldi		$v0,#E_Ok
FFFC397C 00008067		ret
                        	
FFFC3980 3000E073		csrrs	$x0,#$300,#1				; enable interrupts
FFFC3984 00106D13		ldi		$t0,#1
FFFC3988 013D1D33		sll		$t0,$t0,$a1
FFFC398C 00025637		ldo		$t1,IOFocusTbl
FFFC3990 81860613
FFFC3994 00060633
FFFC3998 00063D83
FFFC399C 01ADFE33		and		$t2,$t1,$t0				; test bit for task
FFFC39A0 080E0863		beq		$t2,$x0,.noFocus	; does it even have the focus?
FFFC39A4 FFFD4D13		xor		$t0,$t0,#-1				; get inverted mask
FFFC39A8 01ADFDB3		and		$t1,$t1,$t0				; clear bit for task
FFFC39AC 00025637		sto		$t1,IOFocusTbl
FFFC39B0 81860613
FFFC39B4 00060633
FFFC39B8 01B63023
FFFC39BC 00025637		ldo		$t1,IOFocusNdx		; check if the focus being released is the current
FFFC39C0 81060613
FFFC39C4 00060633
FFFC39C8 00063D83
FFFC39CC 00A99D13		sll		$t0,$a1,#LOG_TCBSZ	; io focus. If so, switch focus
FFFC39D0 03BD1063		bne		$t0,$t1,.notSame
FFFC39D4 FF070713		sub		$sp,$sp,#16
FFFC39D8 01A73023		sto		$t0,[$sp]
FFFC39DC 01B73423		sto		$t1,8[$sp]
FFFC39E0 E21FF0EF		call	FMTK_SwitchIOFocus
FFFC39E4 00073D03		ldo		$t0,[$sp]
FFFC39E8 00873D83		ldo		$t1,8[$sp]
FFFC39EC 01070713		add		$sp,$sp,#16
                        	.notSame:
                        		; Disable interrupts while manipulating IO focus list
FFFC39F0 3000F073		csrrc	$x0,#$300,#1				
FFFC39F4 2E8D3E03		ldo		$t2,IOF_NEXT[$t0]
FFFC39F8 020E4C63		blt		$t2,$x0,.done
FFFC39FC 01AE0A63		beq		$t2,$t0,.pjSame
FFFC3A00 2F0D3D83		ldo		$t1,IOF_PREV[$t0]
FFFC3A04 2FBE3823		sto		$t1,IOF_PREV[$t2]
FFFC3A08 2FCDB423		sto		$t2,IOF_NEXT[$t1]
FFFC3A0C 00000C63		bra		.0001
                        	.pjSame:
FFFC3A10 FFF06D93		ldi		$t1,#-1
FFFC3A14 00025637		sto		$t1,IOFocusNdx
FFFC3A18 81060613
FFFC3A1C 00060633
FFFC3A20 01B63023
                        	.0001:
FFFC3A24 FFF06D93		ldi		$t1,#-1
FFFC3A28 2FBD3423		sto		$t1,IOF_NEXT[$t0]	
FFFC3A2C 2FBD3823		sto		$t1,IOF_PREV[$t0]	
                        	.done:
                        	.noFocus:
FFFC3A30 00006813		ldi		$v0,#E_Ok
FFFC3A34 00008067		ret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/io.r5a",1
                        	.file "../fmtk/io.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;Standard Devices are:
                        	
                        	;#		Device					Standard name
                        	
                        	;0		NULL device 			NUL		(OS built-in)
                        	;1		Keyboard (sequential)	KBD		(OS built-in)
                        	;2		Video (sequential)		VID		(OS built-in)
                        	;3		Printer (parallel 1)	LPT
                        	;4		Printer (parallel 2)	LPT2
                        	;5		RS-232 1				COM1	(OS built-in)
                        	;6		RS-232 2				COM2
                        	;7		RS-232 3				COM3
                        	;8		RS-232 4				COM4
                        	;9		Parallel xfer	  PTI
                        	;10		Floppy					FD0
                        	;11		Floppy					FD1
                        	;12		Hard disk				HD0
                        	;13		Hard disk				HD1
                        	;14
                        	;15   VIA							VIA1
                        	;16		SDCard					CARD1 	(OS built-in)
                        	;17
                        	;18
                        	;19
                        	;20
                        	;21
                        	;22
                        	;23
                        	;24
                        	;25
                        	;26
                        	;27
                        	;28		Audio						PSG1	(OS built-in)
                        	;29
                        	;30   Random Number		PRNG
                        	;31		Debug						DBG
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a2 = function
                        	;		a3 = data
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_IO:
FFFC3A38 02006813		ldi		$v0,#32
FFFC3A3C 0309FE63		bgeu	$a1,$v0,.badDev
FFFC3A40 02006893		ldi		$v1,#32
FFFC3A44 031A7663		bgeu	$a2,$v1,.badFunc
FFFC3A48 00899813		sll		$v0,$a1,#8					; each device allowed 32 functions (*256)
FFFC3A4C 003A1893		sll		$v1,$a2,#3					; function number *8
FFFC3A50 00022637		add		$v0,$v0,#DVF_Base		; base address of function table
FFFC3A54 00060613
FFFC3A58 01060833
FFFC3A5C 01186833		or		$v0,$v0,$v1
FFFC3A60 00083803		ldo		$v0,[$v0]
FFFC3A64 00080663		beq		$v0,$x0,.badFunc
FFFC3A68 000800E7		call	[$v0]
                        	.xit:
FFFC3A6C 00008067		ret
                        	.badFunc:
FFFC3A70 02206813		ldi		$v0,#E_BadDevOp
FFFC3A74 FE000CE3		bra		.xit
                        	.badDev:
FFFC3A78 02006813		ldi		$v0,#E_BadDevNum
FFFC3A7C FE0008E3		bra		.xit
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = I/O channel
                        	;		a1 = points to function table
                        	;------------------------------------------------------------------------------
                        	
                        	CopyDevFuncTbl:
FFFC3A80 00891813		sll		$v0,$a0,#8					; each device allowed 32 functions (*256)
FFFC3A84 00022637		add		$v0,$v0,#DVF_Base		; base address of function table
FFFC3A88 00060613
FFFC3A8C 01060833
FFFC3A90 02006D13		ldi		$t0,#32							; 32 functions to copy
                        	.again:
FFFC3A94 0009BE03		ldo		$t2,[$a1]
FFFC3A98 01C83023		sto		$t2,[$v0]
FFFC3A9C 00898993		add		$a1,$a1,#8
FFFC3AA0 00880813		add		$v0,$v0,#8
FFFC3AA4 FFFD0D13		sub		$t0,$t0,#1
FFFC3AA8 FFA046E3		bgt		$t0,$x0,.again
FFFC3AAC 00008067		ret
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/scancodes.r5a",1
                        	.file "../fmtk/scancodes.r5a",1
                        		;--------------------------------------------------------------------------
                        		; PS2 scan codes to ascii conversion tables.
                        		;--------------------------------------------------------------------------
                        		;
                        		align	8                        	
                        	_unshiftedScanCodes:
FFFC3AB0 A52EA92E		.byte	$2e,$a9,$2e,$a5,$a3,$a1,$a2,$ac
FFFC3AB4 ACA2A1A3
FFFC3AB8 A6A8AA2E		.byte	$2e,$aa,$a8,$a6,$a4,$09,$60,$2e
FFFC3ABC 2E6009A4
FFFC3AC0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$71,$31,$2e
FFFC3AC4 2E31712E
FFFC3AC8 737A2E2E		.byte	$2e,$2e,$7a,$73,$61,$77,$32,$2e
FFFC3ACC 2E327761
FFFC3AD0 6478632E		.byte	$2e,$63,$78,$64,$65,$34,$33,$2e
FFFC3AD4 2E333465
FFFC3AD8 6676202E		.byte	$2e,$20,$76,$66,$74,$72,$35,$2e
FFFC3ADC 2E357274
FFFC3AE0 68626E2E		.byte	$2e,$6e,$62,$68,$67,$79,$36,$2e
FFFC3AE4 2E367967
FFFC3AE8 6A6D2E2E		.byte	$2e,$2e,$6d,$6a,$75,$37,$38,$2e
FFFC3AEC 2E383775
FFFC3AF0 696B2C2E		.byte	$2e,$2c,$6b,$69,$6f,$30,$39,$2e
FFFC3AF4 2E39306F
FFFC3AF8 6C2F2E2E		.byte	$2e,$2e,$2f,$6c,$3b,$70,$2d,$2e
FFFC3AFC 2E2D703B
FFFC3B00 2E272E2E		.byte	$2e,$2e,$27,$2e,$5b,$3d,$2e,$2e
FFFC3B04 2E2E3D5B
FFFC3B08 5D0D2EAD		.byte	$ad,$2e,$0d,$5d,$2e,$5c,$2e,$2e
FFFC3B0C 2E2E5C2E
FFFC3B10 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
FFFC3B14 2E082E2E
FFFC3B18 932E952E		.byte	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
FFFC3B1C 2E2E2E94
FFFC3B20 2E927F98		.byte	$98,$7f,$92,$2e,$91,$90,$1b,$af
FFFC3B24 AF1B9091
FFFC3B28 2E972EAB		.byte	$ab,$2e,$97,$2e,$2e,$96,$ae,$2e
FFFC3B2C 2EAE962E
                        	
FFFC3B30 A72E2E2E		.byte	$2e,$2e,$2e,$a7,$2e,$2e,$2e,$2e
FFFC3B34 2E2E2E2E
FFFC3B38 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3B3C 2E2E2E2E
FFFC3B40 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3B44 2E2E2E2E
FFFC3B48 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3B4C 2E2E2E2E
FFFC3B50 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3B54 2E2E2E2E
FFFC3B58 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3B5C 2E2E2E2E
FFFC3B60 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3B64 2E2E2E2E
FFFC3B68 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3B6C 2E2E2E2E
FFFC3B70 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3B74 2E2E2E2E
FFFC3B78 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3B7C 2E2E2E2E
FFFC3B80 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3B84 2E2E2E2E
FFFC3B88 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3B8C 2E2E2E2E
FFFC3B90 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3B94 2E2E2E2E
FFFC3B98 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3B9C 2E2E2E2E
FFFC3BA0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3BA4 2E2E2E2E
FFFC3BA8 2EFA2E2E		.byte	$2e,$2e,$fa,$2e,$2e,$2e,$2e,$2e
FFFC3BAC 2E2E2E2E
                        	
                        	_shiftedScanCodes:
FFFC3BB0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3BB4 2E2E2E2E
FFFC3BB8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
FFFC3BBC 2E7E092E
FFFC3BC0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$51,$21,$2e
FFFC3BC4 2E21512E
FFFC3BC8 535A2E2E		.byte	$2e,$2e,$5a,$53,$41,$57,$40,$2e
FFFC3BCC 2E405741
FFFC3BD0 4458432E		.byte	$2e,$43,$58,$44,$45,$24,$23,$2e
FFFC3BD4 2E232445
FFFC3BD8 4656202E		.byte	$2e,$20,$56,$46,$54,$52,$25,$2e
FFFC3BDC 2E255254
FFFC3BE0 48424E2E		.byte	$2e,$4e,$42,$48,$47,$59,$5e,$2e
FFFC3BE4 2E5E5947
FFFC3BE8 4A4D2E2E		.byte	$2e,$2e,$4d,$4a,$55,$26,$2a,$2e
FFFC3BEC 2E2A2655
FFFC3BF0 494B3C2E		.byte	$2e,$3c,$4b,$49,$4f,$29,$28,$2e
FFFC3BF4 2E28294F
FFFC3BF8 4C3F3E2E		.byte	$2e,$3e,$3f,$4c,$3a,$50,$5f,$2e
FFFC3BFC 2E5F503A
FFFC3C00 2E222E2E		.byte	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
FFFC3C04 2E2E2B7B
FFFC3C08 7D0D2E2E		.byte	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
FFFC3C0C 2E2E7C2E
FFFC3C10 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
FFFC3C14 2E082E2E
FFFC3C18 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3C1C 2E2E2E2E
FFFC3C20 2E2E7F2E		.byte	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
FFFC3C24 2E1B2E2E
FFFC3C28 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3C2C 2E2E2E2E
                        	
FFFC3C30 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3C34 2E2E2E2E
FFFC3C38 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3C3C 2E2E2E2E
FFFC3C40 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3C44 2E2E2E2E
FFFC3C48 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3C4C 2E2E2E2E
FFFC3C50 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3C54 2E2E2E2E
FFFC3C58 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3C5C 2E2E2E2E
FFFC3C60 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3C64 2E2E2E2E
FFFC3C68 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3C6C 2E2E2E2E
FFFC3C70 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3C74 2E2E2E2E
FFFC3C78 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3C7C 2E2E2E2E
FFFC3C80 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3C84 2E2E2E2E
FFFC3C88 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3C8C 2E2E2E2E
FFFC3C90 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3C94 2E2E2E2E
FFFC3C98 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3C9C 2E2E2E2E
FFFC3CA0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3CA4 2E2E2E2E
FFFC3CA8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3CAC 2E2E2E2E
                        	
                        	; control
                        	_keybdControlCodes:
FFFC3CB0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3CB4 2E2E2E2E
FFFC3CB8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
FFFC3CBC 2E7E092E
FFFC3CC0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$11,$21,$2e
FFFC3CC4 2E21112E
FFFC3CC8 131A2E2E		.byte	$2e,$2e,$1a,$13,$01,$17,$40,$2e
FFFC3CCC 2E401701
FFFC3CD0 0418032E		.byte	$2e,$03,$18,$04,$05,$24,$23,$2e
FFFC3CD4 2E232405
FFFC3CD8 0616202E		.byte	$2e,$20,$16,$06,$14,$12,$25,$2e
FFFC3CDC 2E251214
FFFC3CE0 08020E2E		.byte	$2e,$0e,$02,$08,$07,$19,$5e,$2e
FFFC3CE4 2E5E1907
FFFC3CE8 0A0D2E2E		.byte	$2e,$2e,$0d,$0a,$15,$26,$2a,$2e
FFFC3CEC 2E2A2615
FFFC3CF0 090B3C2E		.byte	$2e,$3c,$0b,$09,$0f,$29,$28,$2e
FFFC3CF4 2E28290F
FFFC3CF8 0C3F3E2E		.byte	$2e,$3e,$3f,$0c,$3a,$10,$5f,$2e
FFFC3CFC 2E5F103A
FFFC3D00 2E222E2E		.byte	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
FFFC3D04 2E2E2B7B
FFFC3D08 7D0D2E2E		.byte	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
FFFC3D0C 2E2E7C2E
FFFC3D10 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
FFFC3D14 2E082E2E
FFFC3D18 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3D1C 2E2E2E2E
FFFC3D20 2E2E7F2E		.byte	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
FFFC3D24 2E1B2E2E
FFFC3D28 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3D2C 2E2E2E2E
                        	
                        	_keybdExtendedCodes:
FFFC3D30 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$a3,$a1,$a2,$2e
FFFC3D34 2EA2A1A3
FFFC3D38 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3D3C 2E2E2E2E
FFFC3D40 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3D44 2E2E2E2E
FFFC3D48 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3D4C 2E2E2E2E
FFFC3D50 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3D54 2E2E2E2E
FFFC3D58 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3D5C 2E2E2E2E
FFFC3D60 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3D64 2E2E2E2E
FFFC3D68 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3D6C 2E2E2E2E
FFFC3D70 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3D74 2E2E2E2E
FFFC3D78 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3D7C 2E2E2E2E
FFFC3D80 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3D84 2E2E2E2E
FFFC3D88 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3D8C 2E2E2E2E
FFFC3D90 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3D94 2E2E2E2E
FFFC3D98 932E952E		.byte	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
FFFC3D9C 2E2E2E94
FFFC3DA0 2E929998		.byte	$98,$99,$92,$2e,$91,$90,$2e,$2e
FFFC3DA4 2E2E9091
FFFC3DA8 2E972E2E		.byte	$2e,$2e,$97,$2e,$2e,$96,$2e,$2e
FFFC3DAC 2E2E962E
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/keybd_driver_asm.r5a",1
                        	.file "../fmtk/keybd_driver_asm.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
                        		align	8                        	
                        	KeybdFuncTbl:
FFFC3DB0 00000000		dco		0							; no operation
FFFC3DB4 00000000
FFFC3DB8 00000000		dco		0							; setup
FFFC3DBC 00000000
FFFC3DC0 00000000		dco		0							; initialize
FFFC3DC4 00000000
FFFC3DC8 00000000		dco		0							; status
FFFC3DCC 00000000
FFFC3DD0 00000000		dco		0							; media check
FFFC3DD4 00000000
FFFC3DD8 00000000		dco		0							; build BPB
FFFC3DDC 00000000
FFFC3DE0 00000000		dco		0							; open
FFFC3DE4 00000000
FFFC3DE8 00000000		dco		0							; close
FFFC3DEC 00000000
FFFC3DF0 00000000		dco		0							; get char
FFFC3DF4 00000000
FFFC3DF8 00000000		dco		0							; Peek char
FFFC3DFC 00000000
FFFC3E00 FFFC41BC		dco		_KeybdGetScancode		; get char direct
FFFC3E04 00000000
FFFC3E08 FFFC41A8		dco		_KeybdPeekScancode	; Peek char direct
FFFC3E0C 00000000
FFFC3E10 00000000		dco		0							; input status
FFFC3E14 00000000
FFFC3E18 00000000		dco		0							; Put char
FFFC3E1C 00000000
FFFC3E20 FFFC411C		dco		_KeybdSendByte	; reserved
FFFC3E24 00000000
FFFC3E28 00000000		dco		0							; set position
FFFC3E2C 00000000
FFFC3E30 00000000		dco		0							; read block
FFFC3E34 00000000
FFFC3E38 00000000		dco		0							; write block
FFFC3E3C 00000000
FFFC3E40 00000000		dco		0							; verify block
FFFC3E44 00000000
FFFC3E48 00000000		dco		0							; output status
FFFC3E4C 00000000
FFFC3E50 00000000		dco		0							; flush input
FFFC3E54 00000000
FFFC3E58 00000000		dco		0							; flush output
FFFC3E5C 00000000
FFFC3E60 FFFC41E0		dco		KeybdIRQ			; IRQ routine
FFFC3E64 00000000
FFFC3E68 00000000		dco		0							; Is removable
FFFC3E6C 00000000
FFFC3E70 00000000		dco		0							; ioctrl read
FFFC3E74 00000000
FFFC3E78 00000000		dco		0							; ioctrl write
FFFC3E7C 00000000
FFFC3E80 00000000		dco		0							; output until busy
FFFC3E84 00000000
FFFC3E88 00000000		dco		0							; 27
FFFC3E8C 00000000
FFFC3E90 00000000		dco		0
FFFC3E94 00000000
FFFC3E98 00000000		dco		0
FFFC3E9C 00000000
FFFC3EA0 00000000		dco		0
FFFC3EA4 00000000
FFFC3EA8 00000000		dco		0							; 31
FFFC3EAC 00000000
                        	
                        	;===============================================================================
                        	; Keyboard routines
                        	;===============================================================================
                        	
                        	SC_C		equ		$21
                        	SC_Z		equ		$1A
                        	SC_TAB	equ		$0D
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Initialize the keyboard.
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        		align	4                        			; we don't know what was before
                        	_KeybdInit:
FFFC3EB0 FF070713		sub		$sp,$sp,#16
FFFC3EB4 00173023		sto		$ra,[$sp]
FFFC3EB8 10300073		pfi
FFFC3EBC 00106913		ldi		$a0,#1					; Keyboard device
FFFC3EC0 FFFC49B7		ldi		$a1,#KeybdFuncTbl
FFFC3EC4 DB098993
FFFC3EC8 10300073		pfi
FFFC3ECC BB5FF0EF		call	CopyDevFuncTbl
FFFC3ED0 00006993		ldi		$a1,#0
FFFC3ED4 00025A37		ldi		$a2,#hKeybdMbx
FFFC3ED8 822A0A13
FFFC3EDC 10300073		pfi
FFFC3EE0 E19FE0EF		call	FMTK_AllocMbx
FFFC3EE4 0E000C63		bra		.xit
FFFC3EE8 00506E93		ldi		$t3,#5
                        	.0002:
FFFC3EEC 00031937		ldi		$a0,#200000			; 10ms wait
FFFC3EF0 D4090913
FFFC3EF4 01D73423		sto		$t3,8[$sp]
FFFC3EF8 A1DFC0EF		call	_MicroDelay
FFFC3EFC FFF06913		ldi		$a0,#-1					; send reset code to keyboard
FFFC3F00 00000637		stb		$a0,KEYBD+1			; write $FF to status reg to clear TX state
FFFC3F04 29160613
FFFC3F08 00060633
FFFC3F0C 01260023
FFFC3F10 20C000EF		call	_KeybdSendByte	; now write to transmit register
FFFC3F14 21C000EF		call	_KeybdWaitTx		; wait until no longer busy
FFFC3F18 1A0000EF		call	_KeybdRecvByte	; look for an ACK ($FA)
FFFC3F1C 0FA84E13		xor		$t2,$v0,#$FA
FFFC3F20 040E1863		bnez	$t2,.tryAgain
FFFC3F24 194000EF		call	_KeybdRecvByte	; look for BAT completion code ($AA)
FFFC3F28 0FC84E13		xor		$t2,$v0,#$FC		; reset error ?
FFFC3F2C 040E0263		beqz	$t2,.tryAgain
FFFC3F30 0AA84813		xor		$v0,$v0,#$AA	; reset complete okay ?
FFFC3F34 02081E63		bnez	$v0,.tryAgain
                        	
                        		; After a reset, scan code set #2 should be active
                        	.config:
FFFC3F38 0F006913		ldi		$a0,#$F0			; send scan code select
FFFC3F3C FFDC0637		stb		$a0,LEDS
FFFC3F40 60060613
FFFC3F44 00060633
FFFC3F48 01260023
FFFC3F4C 1D0000EF		call	_KeybdSendByte
FFFC3F50 1E0000EF		call	_KeybdWaitTx
FFFC3F54 08087813		and		$v0,$v0,#$80
FFFC3F58 00081C63		bnez	$v0,.tryAgain
FFFC3F5C 15C000EF		call	_KeybdRecvByte	; wait for response from keyboard
FFFC3F60 08087893		and		$v1,$v0,#$80
FFFC3F64 00089663		bnez	$v1,.tryAgain
FFFC3F68 0FA84E13		xor		$t2,$v0,#$FA
FFFC3F6C 020E0463		beqz	$t2,.0004
                        	.tryAgain:
FFFC3F70 00873E83		ldo		$t3,8[$sp]
FFFC3F74 FFFE8E93	  sub   $t3,$t3,#1
FFFC3F78 F60E9AE3		bnez	$t3,.0002
                        	.keybdErr:
FFFC3F7C 00000937		ldi		$a0,#msgBadKeybd
FFFC3F80 29790913
FFFC3F84 FF870713		sub		$sp,$sp,#8
FFFC3F88 01273023		sto		$a0,[$sp]
FFFC3F8C 951FC0EF		call	PutString		; _DBGDisplayAsciiStringCRLF
FFFC3F90 02000863		bra		.ledxit
                        	.0004:
FFFC3F94 00206913		ldi		$a0,#2			; select scan code set #2
FFFC3F98 184000EF		call	_KeybdSendByte
FFFC3F9C 194000EF		call	_KeybdWaitTx
FFFC3FA0 08087813		and		$v0,$v0,#$80
FFFC3FA4 FC0816E3		bnez	$v0,.tryAgain
FFFC3FA8 110000EF		call	_KeybdRecvByte	; wait for response from keyboard
FFFC3FAC 08087893		and		$v1,$v0,#$80
FFFC3FB0 FC0890E3		bnez	$v1,.tryAgain
FFFC3FB4 0FA84E13		xor		$t2,$v0,#$FA
FFFC3FB8 FA0E1CE3		bnez	$t2,.tryAgain
FFFC3FBC 080000EF		call	_KeybdGetID
                        	.ledxit:
FFFC3FC0 00706913		ldi		$a0,#$07
FFFC3FC4 028000EF		call	_KeybdSetLED
FFFC3FC8 005B9937		ldi		$a0,#6000000	; 300 ms
FFFC3FCC D8090913
FFFC3FD0 945FC0EF		call	_MicroDelay
FFFC3FD4 00006913		ldi		$a0,#$00
FFFC3FD8 014000EF		call	_KeybdSetLED
                        	.xit:
FFFC3FDC 10300073		pfi
FFFC3FE0 00073083		ldo		$ra,[$sp]
FFFC3FE4 01070713		add		$sp,$sp,#16
FFFC3FE8 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Set the LEDs on the keyboard.
                        	;
                        	; Parameters: $a0 LED status to set
                        	; Returns: none
                        	; Modifies: none
                        	; Stack Space: 2 words
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdSetLED:
FFFC3FEC FF070713		sub		$sp,$sp,#16
FFFC3FF0 00173023		sto		$ra,[$sp]
FFFC3FF4 00096E33		mov		$t2,$a0
FFFC3FF8 0ED06913		ldi		$a0,#$ED
FFFC3FFC 01C73423		sto		$t2,8[$sp]
FFFC4000 10300073		pfi
FFFC4004 118000EF		call	_KeybdSendByte
FFFC4008 128000EF		call	_KeybdWaitTx
FFFC400C 0AC000EF		call	_KeybdRecvByte	; should be an ack
FFFC4010 10300073		pfi
FFFC4014 00873E03		ldo		$t2,8[$sp]
FFFC4018 000E6933		mov		$a0,$t2
FFFC401C 10300073		pfi
FFFC4020 0FC000EF		call	_KeybdSendByte
FFFC4024 10C000EF		call	_KeybdWaitTx
FFFC4028 090000EF		call	_KeybdRecvByte	; should be an ack
FFFC402C 10300073		pfi
FFFC4030 00073083		ldo		$ra,[$sp]
FFFC4034 01070713		add		$sp,$sp,#16
FFFC4038 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Get ID - get the keyboards identifier code.
                        	;
                        	; Parameters: none
                        	; Returns: r1 = $AB83, $00 on fail
                        	; Modifies: r1, KeybdID updated
                        	; Stack Space: 2 words
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdGetID:
FFFC403C FF870713		sub		$sp,$sp,#8
FFFC4040 00173023		sto		$ra,[$sp]
FFFC4044 0F206913		ldi		$a0,#$F2
FFFC4048 10300073		pfi
FFFC404C 0D0000EF		call	_KeybdSendByte
FFFC4050 0E0000EF		call	_KeybdWaitTx
FFFC4054 064000EF		call	_KeybdRecvByte
FFFC4058 10300073		pfi
FFFC405C 08087893		and		$v1,$v0,#$80
FFFC4060 04089663		bnez	$v1,.notKbd
FFFC4064 0AB84E13		xor		$t2,$v0,#$AB
FFFC4068 040E1263		bnez	$t2,.notKbd
FFFC406C 10300073		pfi
FFFC4070 048000EF		call	_KeybdRecvByte
FFFC4074 08087893		and		$v1,$v0,#$80
FFFC4078 02089A63		bnez	$v1,.notKbd
FFFC407C 08384E13		xor		$t2,$v0,#$83
FFFC4080 020E1663		bnez	$t2,.notKbd
FFFC4084 0000B837		ldi		$v0,#$AB83
FFFC4088 B8380813
                        	.0001:
FFFC408C 10300073		pfi
FFFC4090 00000637		stt		$v0,_KeybdID
FFFC4094 29D60613
FFFC4098 00060633
FFFC409C 01062023
FFFC40A0 00073083		ldo		$ra,[$sp]
FFFC40A4 00870713		add		$sp,$sp,#8
FFFC40A8 00008067		ret
                        	.notKbd:
FFFC40AC 10300073		pfi
FFFC40B0 00006813		ldi		$v0,#$00
FFFC40B4 FC000CE3		bra		.0001
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Recieve a byte from the keyboard, used after a command is sent to the
                        	; keyboard in order to wait for a response.
                        	;
                        	; Parameters: none
                        	; Returns: r1 = recieved byte ($00 to $FF), -1 on timeout
                        	; Modifies: r1
                        	; Stack Space: 2 words
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdRecvByte:
FFFC40B8 FF070713		sub		$sp,$sp,#16
FFFC40BC 00173023		sto		$ra,[$sp]
FFFC40C0 06406E93		ldi		$t3,#100				; wait up to 1s
                        	.0003:
FFFC40C4 10300073		pfi
FFFC40C8 0CC000EF		call	_KeybdGetStatus	; wait for response from keyboard
FFFC40CC 08087813		and		$v0,$v0,#$80		; is input buffer full ? yes, branch
FFFC40D0 02081C63		bnez	$v0,.0004
FFFC40D4 00031937		ldi		$a0,#200000
FFFC40D8 D4090913
FFFC40DC 01D73423		sto		$t3,8[$sp]
FFFC40E0 10300073		pfi
FFFC40E4 831FC0EF		call	_MicroDelay
FFFC40E8 00873E83		ldo		$t3,8[$sp]
FFFC40EC FFFE8E93		sub   $t3,$t3,#1
FFFC40F0 FC0E9AE3		bnez	$t3,.0003				; go back and try again
FFFC40F4 10300073		pfi
FFFC40F8 FFF06813		ldi		$v0,#-1				; return -1
FFFC40FC 00073083		ldo		$ra,[$sp]
FFFC4100 01070713		add		$sp,$sp,#16
FFFC4104 00008067		ret
                        	.0004:
FFFC4108 10300073		pfi
FFFC410C 0B0000EF		call	_KeybdGetScancode
FFFC4110 00073083		ldo		$ra,[$sp]
FFFC4114 01070713		add		$sp,$sp,#16
FFFC4118 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Send a byte to the keyboard.
                        	;
                        	; Parameters: $a0 byte to send
                        	; Returns: none
                        	; Modifies: none
                        	; Stack Space: 0 words
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdSendByte:
FFFC411C 00000637		stb		$a0,KEYBD
FFFC4120 29060613
FFFC4124 00060633
FFFC4128 01260023
FFFC412C 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Wait until the keyboard transmit is complete
                        	;
                        	; Parameters: none
                        	; Returns: r1 = 0 if successful, r1 = -1 timeout
                        	; Modifies: v0,t3
                        	; Stack Space: 1 words
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdWaitTx:
FFFC4130 FF070713		sub		$sp,$sp,#16
FFFC4134 00173023		sto		$ra,[$sp]
FFFC4138 06406E93		ldi		$t3,#100			; wait a max of 1s
                        	.0001:
FFFC413C 10300073		pfi
FFFC4140 054000EF		call	_KeybdGetStatus
FFFC4144 04087813		and		$v0,$v0,#$40	; check for transmit complete bit; branch if bit set
FFFC4148 02081C63		bnez	$v0,.0002
FFFC414C 01D73423		sto		$t3,8[$sp]
FFFC4150 00031937		ldi		$a0,#200000		; 10 ms @20MHz
FFFC4154 D4090913
FFFC4158 10300073		pfi
FFFC415C FB8FC0EF		call	_MicroDelay		; delay a little bit
FFFC4160 00873E83		ldo		$t3,8[$sp]
FFFC4164 FFFE8E93		sub		$t3,$t3,#1
FFFC4168 FC0E9AE3		bnez	$t3,.0001
FFFC416C 10300073		pfi
FFFC4170 00073083		ldo		$ra,[$sp]			; timed out
FFFC4174 00870713		add		$sp,$sp,#8
FFFC4178 FFF06813		ldi		$v0,#-1
FFFC417C 00008067		ret		
                        	.0002:
FFFC4180 10300073		pfi
FFFC4184 00073083		ldo		$ra,[$sp]			; timed out
FFFC4188 01070713		add		$sp,$sp,#16
FFFC418C 00006813		ldi		$v0,#0
FFFC4190 00008067		ret		
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Get the keyboard status
                        	;
                        	; Parameters: none
                        	; Returns: r1 = status
                        	; Modifies: r1
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdGetStatus:
FFFC4194 00000637		ldb		$v0,KEYBD+1
FFFC4198 29160613
FFFC419C 00060633
FFFC41A0 00060803
FFFC41A4 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Get the scancode from the keyboard port. Getting the scancode clears the
                        	; interrupt status.
                        	;
                        	; Parameters: none
                        	; Returns: r1 = scancode
                        	; Modifies: r1
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdPeekScancode:
FFFC41A8 00000637		ldbu		$v0,KEYBD			; get the scan code
FFFC41AC 29060613
FFFC41B0 00060633
FFFC41B4 00064803
FFFC41B8 00008067		ret
                        	
                        	_KeybdGetScancode:
FFFC41BC 00000637		ldbu		$v0,KEYBD			; get the scan code
FFFC41C0 29060613
FFFC41C4 00060633
FFFC41C8 00064803
FFFC41CC 00000637		stb			$x0,KEYBD+1		; clear receive register
FFFC41D0 29160613
FFFC41D4 00060633
FFFC41D8 00060023
FFFC41DC 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	KeybdIRQ:
FFFC41E0 FB5FF0EF		call	_KeybdGetStatus
FFFC41E4 10085063		bge		$v0,$x0,.notKbd
FFFC41E8 FD5FF0EF		call	_KeybdGetScancode
FFFC41EC 10300073		pfi
FFFC41F0 00025637		ldo		$s1,IOFocusNdx
FFFC41F4 81060613
FFFC41F8 00060633
FFFC41FC 00063203
FFFC4200 0E020263		beqz	$s1,.notKbd
FFFC4204 30024D03		ldbu	$t0,TCBKbdHead[$s1]
FFFC4208 30124D83		ldbu	$t1,TCBKbdTail[$s1]
FFFC420C 001D0D13		add		$t0,$t0,#1
FFFC4210 01FD7D13		and		$t0,$t0,#31
FFFC4214 01BD0863		beq		$t0,$t1,.noRoom
FFFC4218 10300073		pfi
FFFC421C 31A20023		stb		$t0,TCBKbdHead[$s1]
FFFC4220 31020423		stb		$v0,TCBKbdBuf[$s1]
                        	.noRoom:
FFFC4224 10300073		pfi
                        		; check trigger debugger
                        		; check CTRL-C
FFFC4228 00000637		lbu		$t0,TCBKbdState2
FFFC422C 2A560613
FFFC4230 00060633
FFFC4234 00064D03
FFFC4238 004D7D93		and		$t1,$t0,#4
FFFC423C 040D8063		beqz	$t1,.notCtrl
FFFC4240 02106D13		ldi		$t0,#SC_C
FFFC4244 01A81863		bne		$v0,$t0,.notCtrlC
FFFC4248 00306D13		ldi		$t0,#3
FFFC424C 2DA23423		sto		$t0,TCBException[$s1]
FFFC4250 02000663		bra		.0001
                        	.notCtrlC:
FFFC4254 10300073		pfi
FFFC4258 01A06D13		ldi		$t0,#SC_Z
FFFC425C 03A81063		bne		$v0,$t0,.notCtrlZ
FFFC4260 01A06D13		ldi		$t0,#26
                        		
FFFC4264 18101873		csrrw	v0,#$181,x0
FFFC4268 01F87813		and		v0,v0,#MAX_TID
FFFC426C 00081813	sll		$v0,$v0,#32
FFFC4270 01A86833		or		$v0,$v0,$t0
FFFC4274 2D023423		sto		$v0,TCBException[$s1]
FFFC4278 00000263		bra		.0001
                        	.notCtrlZ:
                        	.0001:
                        	.notCtrl:
FFFC427C 10300073		pfi
FFFC4280 002D7D93		and		$t1,$t0,#2
FFFC4284 020D8363		beqz	$t1,.notAlt
FFFC4288 00D06D13		ldi		$t0,#SC_TAB
FFFC428C 01A81A63		bne		$v0,$t0,.notAltTab
FFFC4290 00025637		stb		$t0,SwitchIOFocus
FFFC4294 82060613
FFFC4298 00060633
FFFC429C 01A60023
                        	.notAltTab:
FFFC42A0 10300073		pfi
                        		; Send a message indicating a key is available
                        		; Keyboard mailbox setup yet?
FFFC42A4 00025637		ldw		$a1,hKeybdMbx
FFFC42A8 82260613
FFFC42AC 00060633
FFFC42B0 00061983
FFFC42B4 0209C863		blt		$a1,$x0,.notKbd
                        		; If there's already a keyboard message, don't send another one.
FFFC42B8 00599213		sll		$s1,$a1,#LOG_MBXSZ
FFFC42BC 00020637		add		$s1,$s1,#mbxs
FFFC42C0 00060613
FFFC42C4 00460233
FFFC42C8 01823D03		ldo		$t0,MBX_MQTAIL[$s1]
FFFC42CC 000D1C63		bnez	$t0,.notKbd
FFFC42D0 10300073		pfi
FFFC42D4 FFF06A13		ldi		$a2,#-1
FFFC42D8 FFF06A93		ldi		$a3,#-1
FFFC42DC FFF06B13		ldi		$a4,#-1
FFFC42E0 BCDFE0EF		call	FMTK_SendMsg
                        	.notKbd:
FFFC42E4 10300073		pfi
FFFC42E8 79217073		csrrc	$x0,#$792,#2			; clear IRQ semaphore
FFFC42EC 10000073		eret
                        	
                        	; Return -1 if there is a scancode available in the buffer.
                        	
                        	_KeybdGetBufferStatus:
                        		
FFFC42F0 18101873		csrrw	v0,#$181,x0
FFFC42F4 01F87813		and		v0,v0,#MAX_TID
FFFC42F8 00A81213	sll		$s1,$v0,#LOG_TCBSZ
FFFC42FC 10300073		pfi
FFFC4300 30024D03		ldbu	$t0,TCBKbdHead[$s1]
FFFC4304 30124D83		ldbu	$t1,TCBKbdTail[$s1]
FFFC4308 01BD0663		beq		$t0,$t1,.empty
FFFC430C FFF06813		ldi		$v0,#-1
FFFC4310 00008067		ret
                        	.empty:
FFFC4314 10300073		pfi
FFFC4318 00006813		ldi		$v0,#0
FFFC431C 00008067		ret
                        	
                        	_KeybdGetBufferedScancode:	
                        		
FFFC4320 18101873		csrrw	v0,#$181,x0
FFFC4324 01F87813		and		v0,v0,#MAX_TID
FFFC4328 00A81213	sll		$s1,$v0,#LOG_TCBSZ
FFFC432C 00006813		ldi		$v0,#0									; $v0 = scancode
FFFC4330 30024D03		ldbu	$t0,TCBKbdHead[$s1]
FFFC4334 30124D83		ldbu	$t1,TCBKbdTail[$s1]
FFFC4338 10300073		pfi
FFFC433C 01BD0C63		beq		$t0,$t1,.empty					; return 0 if empty
FFFC4340 004D8D33		add		$t0,$t1,$s1							; calc pointer to buffer entry
FFFC4344 308D4803		ldbu	$v0,TCBKbdBuf[$t0]			; get buffer entry
FFFC4348 001D8D93		add		$t1,$t1,#1							; increment tail pointer
FFFC434C 01FDFD93		and		$t1,$t1,#31
FFFC4350 31B200A3		stb		$t1,TCBKbdTail[$s1]			; store tail pointer
                        	.empty:
FFFC4354 10300073		pfi
FFFC4358 00008067		ret
                        	
                        	; Parameters:
                        	;		a0 = scancode
                        	
                        	_XlatScancode:
FFFC435C 00008067		ret
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/source/drivers/prng_driver_asm.r5a",1
                        	.file "../fmtk/source/drivers/prng_driver_asm.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2018-2020  Robert Finch, Waterloo
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;
                        	;	prng_driver_asm.r5a
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	;
                        	;
                        	;------------------------------------------------------------------------------
                        	
                        	PRNGL					equ		$FFDC0C00
                        	PRNG_VALUE		equ		$00
                        	PRNG_STREAM		equ		$08
                        	
                        	.file "../fmtk/source/drivers/prng_driver_asm.r5a",33
                        			code	18
                        	;------------------------------------------------------------------------------
                        	; Initialize PRNG
                        	;------------------------------------------------------------------------------
                        	_PRNGInit:
FFFC4360 00025637			sto		$x0,_randStream
FFFC4364 83060613
FFFC4368 00060633
FFFC436C 00063023
FFFC4370 FFDC1D37			ldi		$t0,#PRNGL
FFFC4374 C00D0D13
FFFC4378 000D3423			sto		$x0,$08[$t0]			; select stream #0
FFFC437C 88889837			ldi		$v0,#$88888888
FFFC4380 88880813
FFFC4384 10300073			pfi
FFFC4388 010D3823			sto		$v0,$10[$t0]			; set initial m_z
FFFC438C 01234837			ldi		$v0,#$01234567
FFFC4390 56780813
FFFC4394 010D3C23			sto		$v0,$18[$t0]			; set initial m_w
FFFC4398 00008067			ret
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	; Seed random number generator.
                        	;
                        	; Parameters:
                        	;		$a0 - stream to seed
                        	;		$a1 - value to use as seed
                        	;		$a2 - value to use as seed
                        	; Modifies:
                        	;		$t0
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	_SeedRand:
FFFC439C FFDC1D37			ldi		$t0,#PRNGL
FFFC43A0 C00D0D13
FFFC43A4 10300073			pfi
FFFC43A8 012D3423			sto		$a0,$08[$t0]		; select stream #
FFFC43AC 013D3823			sto		$a1,$10[$t0]		; set initial m_z
FFFC43B0 014D3C23			sto		$a2,$18[$t0]		; set initial m_w
FFFC43B4 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a random number, and generate the next number.
                        	;
                        	; Parameters:
                        	;		$a0 = random stream number.
                        	; Returns:
                        	;		$v0 = random 32 bit number.
                        	;------------------------------------------------------------------------------
                        	
                        	_PeekRand:
FFFC43B8 10300073			pfi
FFFC43BC FFDC1637			sto		$a0,PRNGL+PRNG_STREAM	; set the stream
FFFC43C0 C0860613
FFFC43C4 00060633
FFFC43C8 01263023
FFFC43CC FFDC1637			ldo		$v0,PRNGL+PRNG_VALUE		; get a number
FFFC43D0 C0060613
FFFC43D4 00060633
FFFC43D8 00063803
FFFC43DC 00008067			ret
                        	
                        	_GetRand:
FFFC43E0 10300073			pfi
FFFC43E4 FFDC1637			sto		$a0,PRNGL+PRNG_STREAM	; set the stream
FFFC43E8 C0860613
FFFC43EC 00060633
FFFC43F0 01263023
FFFC43F4 FFDC1637			ldo		$v0,PRNGL+PRNG_VALUE		; get a number
FFFC43F8 C0060613
FFFC43FC 00060633
FFFC4400 00063803
FFFC4404 FFDC1637			sto		$x0,PRNGL+PRNG_VALUE		; generate next number
FFFC4408 C0060613
FFFC440C 00060633
FFFC4410 00063023
FFFC4414 00008067			ret
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/source/kernel/DBGKeybd.s",1
                        	.file "../fmtk/source/kernel/DBGKeybd.s",1
                        	.file "../fmtk/source/kernel/DBGKeybd.s",94
                        		code
FFFC4418 00000000		align	1
FFFC441C 00000000
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC4420 FE070713	public code _DBGCheckForKey:
	      	sub      	$sp,$sp,#32
FFFC4424 00273023		      	sto      	$fp,[$sp]
FFFC4428 00073423		      	sto      	$x0,8[$sp]
FFFC442C 00173C23		      	sto      	$ra,24[$sp]
FFFC4430 00076133		      	mov      	$fp,$sp
FFFC4434 D61FF0EF		      	call     	_KeybdGetStatus
FFFC4438 00086D33		      	mov      	$t0,$v0
FFFC443C 000D6833		      	mov      	$v0,$t0
                        	DBGKeybd_5:
                        	DBGKeybd_8:
FFFC4440 00016733		      	mov      	$sp,$fp
FFFC4444 00073103		      	ldo      	$fp,[$sp]
FFFC4448 01873083		      	ldo      	$ra,24[$sp]
FFFC444C 02070713		      	add      	$sp,$sp,#32
FFFC4450 00008067		      	ret      
                        	endpublic
                        	
                        	.file "../fmtk/source/kernel/DBGKeybd.s",119
                        		code
FFFC4454 00000000		align	1
FFFC4458 00000000
FFFC445C 00000000
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC4460 FE070713	public code _DBGGetKey:
	      	sub      	$sp,$sp,#32
FFFC4464 00273023		      	sto      	$fp,[$sp]
FFFC4468 00073423		      	sto      	$x0,8[$sp]
FFFC446C 00173C23		      	sto      	$ra,24[$sp]
FFFC4470 00076133		      	mov      	$fp,$sp
FFFC4474 FC270713		      	sub      	$sp,$sp,#62
FFFC4478 00473023		      	sto      	$s1,0[$sp]
FFFC447C 00573423		      	sto      	$s2,8[$sp]
FFFC4480 00673823		      	sto      	$s3,16[$sp]
FFFC4484 00773C23		      	sto      	$s4,24[$sp]
FFFC4488 FEE13203		      	ldo      	$s1,-18[$fp]
FFFC448C FF710283		      	ldb      	$s2,-9[$fp]
FFFC4490 FF813303		      	ldo      	$s3,-8[$fp]
FFFC4494 0000A3B7		      	ldi      	$s4,#40000
FFFC4498 C4038393
                        	DBGKeybd_66:
                        	; 		for (count = 0; (KeybdGetStatus() & 0x40) != 0 && count < 40000; count++);
FFFC449C 00006233		      	mov      	$s1,$x0
FFFC44A0 CF5FF0EF		      	call     	_KeybdGetStatus
FFFC44A4 00086DB3		      	mov      	$t1,$v0
FFFC44A8 040DFD13		      	and      	$t0,$t1,#64
FFFC44AC 020D0063		      	beq      	$t0,$x0,DBGKeybd_69
FFFC44B0 00725E63		      	bge      	$s1,$s4,DBGKeybd_69
                        	DBGKeybd_68:
FFFC44B4 00120213		      	add      	$s1,$s1,#1
FFFC44B8 CDDFF0EF		      	call     	_KeybdGetStatus
FFFC44BC 00086DB3		      	mov      	$t1,$v0
FFFC44C0 040DFD13		      	and      	$t0,$t1,#64
FFFC44C4 000D0463		      	beq      	$t0,$x0,DBGKeybd_71
FFFC44C8 FE7246E3		      	blt      	$s1,$s4,DBGKeybd_68
                        	DBGKeybd_71:
                        	DBGKeybd_69:
                        	; 		while ((KeybdGetStatus() & 0x80) == 0) {
FFFC44CC CC9FF0EF		      	call     	_KeybdGetStatus
FFFC44D0 00086DB3		      	mov      	$t1,$v0
FFFC44D4 080DFD13		      	and      	$t0,$t1,#128
FFFC44D8 040D1063		      	bne      	$t0,$x0,DBGKeybd_73
                        	DBGKeybd_72:
                        	; 			if (!block)
FFFC44DC 02091663		      	bne      	$a0,$x0,DBGKeybd_74
                        	; 				return (-1);
FFFC44E0 FFF06813		      	ldi      	$v0,#-1
                        	DBGKeybd_62:
                        	DBGKeybd_65:
FFFC44E4 00073203		      	ldo      	$s1,0[$sp]
FFFC44E8 00873283		      	ldo      	$s2,8[$sp]
FFFC44EC 01073303		      	ldo      	$s3,16[$sp]
FFFC44F0 01873383		      	ldo      	$s4,24[$sp]
FFFC44F4 00016733		      	mov      	$sp,$fp
FFFC44F8 00073103		      	ldo      	$fp,[$sp]
FFFC44FC 01873083		      	ldo      	$ra,24[$sp]
FFFC4500 02070713		      	add      	$sp,$sp,#32
FFFC4504 00008067		      	ret      
                        	DBGKeybd_74:
FFFC4508 C8DFF0EF		      	call     	_KeybdGetStatus
FFFC450C 00086DB3		      	mov      	$t1,$v0
FFFC4510 080DFD13		      	and      	$t0,$t1,#128
FFFC4514 FC0D04E3		      	beq      	$t0,$x0,DBGKeybd_72
                        	DBGKeybd_73:
                        	; 		sc = KeybdGetScancode() & 0xff;
FFFC4518 CA5FF0EF		      	call     	_KeybdGetScancode
FFFC451C 00086DB3		      	mov      	$t1,$v0
FFFC4520 0FFDFD13		      	and      	$t0,$t1,#255
FFFC4524 000D6333		      	mov      	$s3,$t0
                        	; 		for (count = 0; count < 20; count++)
FFFC4528 00006233		      	mov      	$s1,$x0
FFFC452C 01422D13		      	slt      	$t0,$s1,#20
FFFC4530 000D0863		      	beqz     	$t0,DBGKeybd_77
                        	DBGKeybd_76:
                        	; 			;
FFFC4534 00120213		      	add      	$s1,$s1,#1
FFFC4538 01422D13		      	slt      	$t0,$s1,#20
FFFC453C FE0D1CE3		      	bnez     	$t0,DBGKeybd_76
                        	DBGKeybd_77:
                        	; 	  case 0xF0:
FFFC4540 0F034D13		      	xor      	$t0,$s3,#240
FFFC4544 040D0063		      	beq      	$t0,$x0,DBGKeybd_90
                        	; 	  case 0xE0:
FFFC4548 0E034D13		      	xor      	$t0,$s3,#224
FFFC454C 040D0863		      	beq      	$t0,$x0,DBGKeybd_91
                        	; 	  case 0x14:
FFFC4550 01434D13		      	xor      	$t0,$s3,#20
FFFC4554 060D0863		      	beq      	$t0,$x0,DBGKeybd_92
                        	; 	  case 0x59:
FFFC4558 05934D13		      	xor      	$t0,$s3,#89
FFFC455C 0C0D0E63		      	beq      	$t0,$x0,DBGKeybd_93
                        	; 	  case 0x77:
FFFC4560 07734D13		      	xor      	$t0,$s3,#119
FFFC4564 140D0463		      	beq      	$t0,$x0,DBGKeybd_94
                        	; 	  case 0x58:
FFFC4568 05834D13		      	xor      	$t0,$s3,#88
FFFC456C 1A0D0063		      	beq      	$t0,$x0,DBGKeybd_95
                        	; 	  case 0x7E:
FFFC4570 07E34D13		      	xor      	$t0,$s3,#126
FFFC4574 1E0D0C63		      	beq      	$t0,$x0,DBGKeybd_96
                        	; 	  case 0x11:
FFFC4578 01134D13		      	xor      	$t0,$s3,#17
FFFC457C 240D0863		      	beq      	$t0,$x0,DBGKeybd_97
                        	; 	  default:
FFFC4580 2C000063		      	bra      	DBGKeybd_98
                        	DBGKeybd_90:
                        	;       KeyState1 = -1;
FFFC4584 FFF06D13		      	ldi      	$t0,#-1
FFFC4588 00025637		      	stb      	$t0,_KeyState1
FFFC458C 82460613
FFFC4590 00060633
FFFC4594 01A60023
                        	;       break;
FFFC4598 3C000663		      	bra      	DBGKeybd_79
                        	DBGKeybd_91:
                        	;       KeyState2 |= 0x80;
FFFC459C 00025637		      	ldb      	$t0,_KeyState2
FFFC45A0 82560613
FFFC45A4 00060633
FFFC45A8 00060D03
FFFC45AC 080D6D13		      	or       	$t0,$t0,#128
FFFC45B0 00025637		      	stb      	$t0,_KeyState2
FFFC45B4 82560613
FFFC45B8 00060633
FFFC45BC 01A60023
                        	;       break;
FFFC45C0 3A000263		      	bra      	DBGKeybd_79
                        	DBGKeybd_92:
                        	;       if (KeyState1 >= 0)
FFFC45C4 00025637		      	ldb      	$t0,_KeyState1
FFFC45C8 82460613
FFFC45CC 00060633
FFFC45D0 00060D03
FFFC45D4 020D4663		      	blt      	$t0,$x0,DBGKeybd_99
                        	;         KeyState2 |= 4;
FFFC45D8 00025637		      	ldb      	$t0,_KeyState2
FFFC45DC 82560613
FFFC45E0 00060633
FFFC45E4 00060D03
FFFC45E8 004D6D13		      	or       	$t0,$t0,#4
FFFC45EC 00025637		      	stb      	$t0,_KeyState2
FFFC45F0 82560613
FFFC45F4 00060633
FFFC45F8 01A60023
FFFC45FC 02000463		      	bra      	DBGKeybd_100
                        	DBGKeybd_99:
                        	;         KeyState2 &= ~4;
FFFC4600 00025637		      	ldb      	$t0,_KeyState2
FFFC4604 82560613
FFFC4608 00060633
FFFC460C 00060D03
FFFC4610 FFBD7D13		      	and      	$t0,$t0,#-5
FFFC4614 00025637		      	stb      	$t0,_KeyState2
FFFC4618 82560613
FFFC461C 00060633
FFFC4620 01A60023
                        	DBGKeybd_100:
                        	;       KeyState1 = 0;
FFFC4624 00025637		      	stb      	$x0,_KeyState1
FFFC4628 82460613
FFFC462C 00060633
FFFC4630 00060023
                        	;       break;
FFFC4634 32000863		      	bra      	DBGKeybd_79
                        	DBGKeybd_93:
                        	;       if (KeyState1 >= 0)
FFFC4638 00025637		      	ldb      	$t0,_KeyState1
FFFC463C 82460613
FFFC4640 00060633
FFFC4644 00060D03
FFFC4648 020D4663		      	blt      	$t0,$x0,DBGKeybd_101
                        	;         KeyState2 |= 1;
FFFC464C 00025637		      	ldb      	$t0,_KeyState2
FFFC4650 82560613
FFFC4654 00060633
FFFC4658 00060D03
FFFC465C 001D6D13		      	or       	$t0,$t0,#1
FFFC4660 00025637		      	stb      	$t0,_KeyState2
FFFC4664 82560613
FFFC4668 00060633
FFFC466C 01A60023
FFFC4670 02000463		      	bra      	DBGKeybd_102
                        	DBGKeybd_101:
                        	;         KeyState2 &= ~1;
FFFC4674 00025637		      	ldb      	$t0,_KeyState2
FFFC4678 82560613
FFFC467C 00060633
FFFC4680 00060D03
FFFC4684 FFED7D13		      	and      	$t0,$t0,#-2
FFFC4688 00025637		      	stb      	$t0,_KeyState2
FFFC468C 82560613
FFFC4690 00060633
FFFC4694 01A60023
                        	DBGKeybd_102:
                        	;       KeyState1 = 0;
FFFC4698 00025637		      	stb      	$x0,_KeyState1
FFFC469C 82460613
FFFC46A0 00060633
FFFC46A4 00060023
                        	;       break;
FFFC46A8 2A000E63		      	bra      	DBGKeybd_79
                        	DBGKeybd_94:
                        	;       KeyState2 ^= 16;
FFFC46AC 00025637		      	ldb      	$t0,_KeyState2
FFFC46B0 82560613
FFFC46B4 00060633
FFFC46B8 00060D03
FFFC46BC 010D4D13		      	xor      	$t0,$t0,#16
FFFC46C0 00025637		      	stb      	$t0,_KeyState2
FFFC46C4 82560613
FFFC46C8 00060633
FFFC46CC 01A60023
                        	;       KeyLED ^= 2;
FFFC46D0 00025637		      	ldb      	$t0,_KeyLED
FFFC46D4 82660613
FFFC46D8 00060633
FFFC46DC 00060D03
FFFC46E0 002D4D13		      	xor      	$t0,$t0,#2
FFFC46E4 00025637		      	stb      	$t0,_KeyLED
FFFC46E8 82660613
FFFC46EC 00060633
FFFC46F0 01A60023
                        	;       KeybdSetLED(KeyLED);
FFFC46F4 00025637		      	ldb      	$a0,_KeyLED
FFFC46F8 82660613
FFFC46FC 00060633
FFFC4700 00060903
FFFC4704 8E9FF0EF		      	call     	_KeybdSetLED
                        	;       break;
FFFC4708 24000E63		      	bra      	DBGKeybd_79
                        	DBGKeybd_95:
                        	;       KeyState2 ^= 32;
FFFC470C 00025637		      	ldb      	$t0,_KeyState2
FFFC4710 82560613
FFFC4714 00060633
FFFC4718 00060D03
FFFC471C 020D4D13		      	xor      	$t0,$t0,#32
FFFC4720 00025637		      	stb      	$t0,_KeyState2
FFFC4724 82560613
FFFC4728 00060633
FFFC472C 01A60023
                        	;       KeyLED ^= 4;
FFFC4730 00025637		      	ldb      	$t0,_KeyLED
FFFC4734 82660613
FFFC4738 00060633
FFFC473C 00060D03
FFFC4740 004D4D13		      	xor      	$t0,$t0,#4
FFFC4744 00025637		      	stb      	$t0,_KeyLED
FFFC4748 82660613
FFFC474C 00060633
FFFC4750 01A60023
                        	;       KeybdSetLED(KeyLED);
FFFC4754 00025637		      	ldb      	$a0,_KeyLED
FFFC4758 82660613
FFFC475C 00060633
FFFC4760 00060903
FFFC4764 889FF0EF		      	call     	_KeybdSetLED
                        	;       break;
FFFC4768 1E000E63		      	bra      	DBGKeybd_79
                        	DBGKeybd_96:
                        	;       KeyState2 ^= 64;
FFFC476C 00025637		      	ldb      	$t0,_KeyState2
FFFC4770 82560613
FFFC4774 00060633
FFFC4778 00060D03
FFFC477C 040D4D13		      	xor      	$t0,$t0,#64
FFFC4780 00025637		      	stb      	$t0,_KeyState2
FFFC4784 82560613
FFFC4788 00060633
FFFC478C 01A60023
                        	;       KeyLED ^= 1;
FFFC4790 00025637		      	ldb      	$t0,_KeyLED
FFFC4794 82660613
FFFC4798 00060633
FFFC479C 00060D03
FFFC47A0 001D4D13		      	xor      	$t0,$t0,#1
FFFC47A4 00025637		      	stb      	$t0,_KeyLED
FFFC47A8 82660613
FFFC47AC 00060633
FFFC47B0 01A60023
                        	;       KeybdSetLED(KeyLED);
FFFC47B4 00025637		      	ldb      	$a0,_KeyLED
FFFC47B8 82660613
FFFC47BC 00060633
FFFC47C0 00060903
FFFC47C4 829FF0EF		      	call     	_KeybdSetLED
                        	;       break;
FFFC47C8 18000E63		      	bra      	DBGKeybd_79
                        	DBGKeybd_97:
                        	;       if (KeyState1 >= 0)
FFFC47CC 00025637		      	ldb      	$t0,_KeyState1
FFFC47D0 82460613
FFFC47D4 00060633
FFFC47D8 00060D03
FFFC47DC 020D4663		      	blt      	$t0,$x0,DBGKeybd_103
                        	;         KeyState2 |= 2;
FFFC47E0 00025637		      	ldb      	$t0,_KeyState2
FFFC47E4 82560613
FFFC47E8 00060633
FFFC47EC 00060D03
FFFC47F0 002D6D13		      	or       	$t0,$t0,#2
FFFC47F4 00025637		      	stb      	$t0,_KeyState2
FFFC47F8 82560613
FFFC47FC 00060633
FFFC4800 01A60023
FFFC4804 02000463		      	bra      	DBGKeybd_104
                        	DBGKeybd_103:
                        	;         KeyState2 &= ~2;
FFFC4808 00025637		      	ldb      	$t0,_KeyState2
FFFC480C 82560613
FFFC4810 00060633
FFFC4814 00060D03
FFFC4818 FFDD7D13		      	and      	$t0,$t0,#-3
FFFC481C 00025637		      	stb      	$t0,_KeyState2
FFFC4820 82560613
FFFC4824 00060633
FFFC4828 01A60023
                        	DBGKeybd_104:
                        	;       KeyState1 = 0;
FFFC482C 00025637		      	stb      	$x0,_KeyState1
FFFC4830 82460613
FFFC4834 00060633
FFFC4838 00060023
                        	;       break;
FFFC483C 12000463		      	bra      	DBGKeybd_79
                        	DBGKeybd_98:
                        	; 				if (KeyState1) {
FFFC4840 00025637		      	ldb      	$t0,_KeyState1
FFFC4844 82460613
FFFC4848 00060633
FFFC484C 00060D03
FFFC4850 000D0C63		      	beq      	$t0,$x0,DBGKeybd_105
                        	; 					KeyState1 = 0;
FFFC4854 00025637		      	stb      	$x0,_KeyState1
FFFC4858 82460613
FFFC485C 00060633
FFFC4860 00060023
FFFC4864 10000063		      	bra      	DBGKeybd_106
                        	DBGKeybd_105:
                        	; 					if (((KeyState2 & 0x06)==0x06) && sc==0x71) {
FFFC4868 00025637		      	ldb      	$t1,_KeyState2
FFFC486C 82560613
FFFC4870 00060633
FFFC4874 00060D83
FFFC4878 006DFD13		      	and      	$t0,$t1,#6
FFFC487C 006D4D93		      	xor      	$t1,$t0,#6
FFFC4880 000D9C63		      	bnez     	$t1,DBGKeybd_107
FFFC4884 07134D13		      	xor      	$t0,$s3,#113
FFFC4888 000D1863		      	bnez     	$t0,DBGKeybd_107
                        	; 						__asm {
                        		      	;asm     	
FFFC488C 00000637				jmp		$FFFC0100
FFFC4890 2D760067
                        	; 						}
FFFC4894 0C000863		      	bra      	DBGKeybd_108
                        	DBGKeybd_107:
                        	; 					else if (KeyState2 & 0x80) { // Extended code ?
FFFC4898 00025637		      	ldb      	$t1,_KeyState2
FFFC489C 82560613
FFFC48A0 00060633
FFFC48A4 00060D83
FFFC48A8 080DFD13		      	and      	$t0,$t1,#128
FFFC48AC 040D0063		      	beq      	$t0,$x0,DBGKeybd_109
                        	; 						KeyState2 &= ~0x80;
FFFC48B0 00025637		      	ldb      	$t0,_KeyState2
FFFC48B4 82560613
FFFC48B8 00060633
FFFC48BC 00060D03
FFFC48C0 F7FD7D13		      	and      	$t0,$t0,#-129
FFFC48C4 00025637		      	stb      	$t0,_KeyState2
FFFC48C8 82560613
FFFC48CC 00060633
FFFC48D0 01A60023
                        	; 						ch = keybdExtendedCodes[sc];
FFFC48D4 FFFC4637		      	ldb      	$s2,_keybdExtendedCodes[$s3]
FFFC48D8 D3060613
FFFC48DC 00660633
FFFC48E0 00060283
                        	; 						return (ch);
FFFC48E4 0002E833		      	mov      	$v0,$s2
FFFC48E8 BE000EE3		      	bra      	DBGKeybd_65
                        	DBGKeybd_109:
                        	; 					else if (KeyState2 & 0x04) { // control ?
FFFC48EC 00025637		      	ldb      	$t1,_KeyState2
FFFC48F0 82560613
FFFC48F4 00060633
FFFC48F8 00060D83
FFFC48FC 004DFD13		      	and      	$t0,$t1,#4
FFFC4900 000D0E63		      	beq      	$t0,$x0,DBGKeybd_111
                        	; 						ch = keybdControlCodes[sc];
FFFC4904 FFFC4637		      	ldb      	$s2,_keybdControlCodes[$s3]
FFFC4908 CB060613
FFFC490C 00660633
FFFC4910 00060283
                        	; 						return (ch);
FFFC4914 0002E833		      	mov      	$v0,$s2
FFFC4918 BC0006E3		      	bra      	DBGKeybd_65
                        	DBGKeybd_111:
                        	; 					else if (KeyState2 & 0x01) { // shifted ?
FFFC491C 00025637		      	ldb      	$t1,_KeyState2
FFFC4920 82560613
FFFC4924 00060633
FFFC4928 00060D83
FFFC492C 001DFD13		      	and      	$t0,$t1,#1
FFFC4930 000D0E63		      	beq      	$t0,$x0,DBGKeybd_113
                        	; 						ch = shiftedScanCodes[sc];
FFFC4934 FFFC4637		      	ldb      	$s2,_shiftedScanCodes[$s3]
FFFC4938 BB060613
FFFC493C 00660633
FFFC4940 00060283
                        	; 						return (ch);
FFFC4944 0002E833		      	mov      	$v0,$s2
FFFC4948 B8000EE3		      	bra      	DBGKeybd_65
                        	DBGKeybd_113:
                        	; 						ch = unshiftedScanCodes[sc];
FFFC494C FFFC4637		      	ldb      	$s2,_unshiftedScanCodes[$s3]
FFFC4950 AB060613
FFFC4954 00660633
FFFC4958 00060283
                        	; 						return (ch);
FFFC495C 0002E833		      	mov      	$v0,$s2
FFFC4960 B80002E3		      	bra      	DBGKeybd_65
                        	DBGKeybd_108:
                        	DBGKeybd_106:
                        	DBGKeybd_79:
FFFC4964 B2000CE3		      	bra      	DBGKeybd_66
                        	endpublic
                        	
                        	.file "TinyBasic.r5a",84
                        			code
FFFC4968 00000000			align	25
FFFC496C 00000000
FFFC4970 00000000
FFFC4974 00000000
FFFC4978 00000000
FFFC497C 00000000
FFFC4980 00000000
FFFC4984 00000000
FFFC4988 00000000
FFFC498C 00000000
FFFC4990 00000000
FFFC4994 00000000
FFFC4998 00000000
FFFC499C 00000000
FFFC49A0 00000000
FFFC49A4 00000000
FFFC49A8 00000000
FFFC49AC 00000000
FFFC49B0 00000000
FFFC49B4 00000000
FFFC49B8 00000000
FFFC49BC 00000000
FFFC49C0 00000000
FFFC49C4 00000000
FFFC49C8 00000000
FFFC49CC 00000000
FFFC49D0 00000000
FFFC49D4 00000000
FFFC49D8 00000000
FFFC49DC 00000000
FFFC49E0 00000000
FFFC49E4 00000000
FFFC49E8 00000000
FFFC49EC 00000000
FFFC49F0 00000000
FFFC49F4 00000000
FFFC49F8 00000000
FFFC49FC 00000000
                        	
                        	;
                        	; Standard jump table. You can change these addresses if you are
                        	; customizing this interpreter for a different environment.
                        	;
                        	TinyBasic:
                        	GOSTART:	
FFFC4A00 0300006F			jmp	CSTART	;	Cold Start entry point
                        	GOWARM:	
FFFC4A04 1200006F			jmp	WSTART	;	Warm Start entry point
                        	GOOUT:	
FFFC4A08 17C0206F			jmp	OUTC	;	Jump to character-out routine
                        	GOIN:	
FFFC4A0C 17C0206F			jmp	INCH	;Jump to character-in routine
                        	GOAUXO:	
FFFC4A10 00000637			jmp	AUXOUT	;	Jump to auxiliary-out routine
FFFC4A14 2E560067
                        	GOAUXI:	
FFFC4A18 00000637			jmp	AUXIN	;	Jump to auxiliary-in routine
FFFC4A1C 2E760067
                        	GOBYE:	
FFFC4A20 1980206F			jmp	BYEBYE	;	Jump to monitor, DOS, etc.
                        	
FFFC4A24 00000000		align	1
FFFC4A28 00000000
FFFC4A2C 00000000
                        	
                        	//message "CSTART"
FFFC4A30 F15FB0EF	public CSTART:
	call	DumpMemmap
                        		; First save off the link register and OS sp value
FFFC4A34 00030637		sto		$sp,OSSP
FFFC4A38 00060613
FFFC4A3C 00060633
FFFC4A40 00E63023
FFFC4A44 AFFFC737		ldi		$sp,#STACKOFFS	; initialize stack pointer
FFFC4A48 00070713
FFFC4A4C 00E06913		ldi		$a0,#14							; Get current tid
FFFC4A50 00000073		ecall
FFFC4A54 0008E9B3		mov		$a1,$v1
FFFC4A58 01806913		ldi		$a0,#24							; RequestIOFocus
FFFC4A5C 00000073		ecall
                        	;	call	_DBGHomeCursor[pc]
FFFC4A60 00006933		mov		a0,r0			; turn off keyboard echoing
                        	//	call	SetKeyboardEcho
                        	//	stz		CursorFlash
                        	//	ldx		#0x10000020	; black chars, yellow background
                        	;	stx		charToPrint
                        	;	call	_DBGClearScreen[pc]
FFFC4A64 FFFC7937		ldi		a0,#msgInit	;	tell who we are
FFFC4A68 BCC90913
FFFC4A6C 71D010EF		call	PRMESG
FFFC4A70 00032937		ldi		a0,#TXTBGN	;	init. end-of-program pointer
FFFC4A74 80090913
FFFC4A78 00030637		sw		a0,TXTUNF
FFFC4A7C 00460613
FFFC4A80 00060633
FFFC4A84 01262023
FFFC4A88 00040937		ldi		a0,#ENDMEM	;	get address of end of memory
FFFC4A8C FFC90913
FFFC4A90 00080937		ldi		a0,#$7F800
FFFC4A94 80090913
FFFC4A98 00030637		sw		a0,STKBOT
FFFC4A9C 09C60613
FFFC4AA0 00060633
FFFC4AA4 01262023
FFFC4AA8 00040937		ldi		a0,#ENDMEM
FFFC4AAC FFC90913
FFFC4AB0 00030637		sw		a0,VAREND
FFFC4AB4 00C60613
FFFC4AB8 00060633
FFFC4ABC 01262023
FFFC4AC0 CE090913		sub		a0,a0,#800 	;   100 vars
FFFC4AC4 00030637		sw    a0,VARBGN
FFFC4AC8 00860613
FFFC4ACC 00060633
FFFC4AD0 01262023
FFFC4AD4 598000EF		call  clearVars   ; clear the variable area
FFFC4AD8 00030637		sw		r0,IRQROUT
FFFC4ADC 0A460613
FFFC4AE0 00060633
FFFC4AE4 00062023
FFFC4AE8 00030637		lw    a0,VARBGN   ; calculate number of bytes free
FFFC4AEC 00860613
FFFC4AF0 00060633
FFFC4AF4 00062903
FFFC4AF8 00030637		lw		a1,TXTUNF
FFFC4AFC 00460613
FFFC4B00 00060633
FFFC4B04 00062983
FFFC4B08 41390933		sub   a0,a0,a1
FFFC4B0C 00606993		ldi		a1,#6		; max 6 digits
FFFC4B10 00A06A13		ldi		a2,#10	; base 10
FFFC4B14 399010EF		call  PRTNUM
FFFC4B18 FFFC7937		ldi		a0,#msgBytesFree
FFFC4B1C C6D90913
FFFC4B20 669010EF		call	PRMESG
                        	WSTART:
FFFC4B24 00030637		sw		x0,LOPVAR   ; initialize internal variables
FFFC4B28 01060613
FFFC4B2C 00060633
FFFC4B30 00062023
FFFC4B34 00030637		sw		x0,STKGOS
FFFC4B38 01460613
FFFC4B3C 00060633
FFFC4B40 00062023
FFFC4B44 00030637		sw		x0,CURRNT	;	current line number pointer = 0
FFFC4B48 01860613
FFFC4B4C 00060633
FFFC4B50 00062023
FFFC4B54 AFFFC737		ldi		$sp,#STACKOFFS	;	init S.P. again, just in case
FFFC4B58 00070713
FFFC4B5C FFFC7937		ldi		a0,#msgReady	;	display "Ready"
FFFC4B60 C7A90913
FFFC4B64 625010EF		call	PRMESG
                        	BASPRMPT:
FFFC4B68 00E06913		ldi		a0,#14		; get current tid
FFFC4B6C 00000073		ecall
FFFC4B70 0008E933		mov		a0,v1
FFFC4B74 CF9FB0EF		call	PutHexByte
FFFC4B78 03E06913		ldi		a0,#'>'		; Prompt with a '>' and
FFFC4B7C 758010EF		call	GETLN		; read a line.
FFFC4B80 555010EF		call	TOUPBUF 	; convert to upper case
FFFC4B84 000E64B3		mov		$s6,$t2		; save pointer to end of line
FFFC4B88 00030E37		ldi		$t2,#BUFFER	; point to the beginning of line
FFFC4B8C 01CE0E13
FFFC4B90 4A1010EF		call	TSTNUM		; is there a number there?
FFFC4B94 511010EF		call	IGNBLK		; skip trailing blanks
FFFC4B98 000E4483		lbu		$s6,[$t2]
FFFC4B9C 00D4C493		xor		$s6,$s6,#CR	; s6 = flag empty line
                        	; does line no. exist? (or nonzero?)
FFFC4BA0 2C088063		beq		v1,x0,DIRECT		; if not, it's a direct statement
FFFC4BA4 00100DB7		ldi		$t1,#$FFFFF
FFFC4BA8 FFFD8D93
FFFC4BAC 010DD863		ble		v0,$t1,ST2	; see if line no. is <= 16 bits
FFFC4BB0 FFFC7937		ldi		a0,#msgLineRange	; if not, we've overflowed
FFFC4BB4 C9590913
FFFC4BB8 6C00106F		jmp		ERROR
                        	ST2:
FFFC4BBC 00086933	  mov		$a0,$v0		; a0 = line number
FFFC4BC0 000E6433	  mov		$s5,$t2			; save line buffer pointer
FFFC4BC4 FFCE0E13		sub		$t2,$t2,#4
FFFC4BC8 012E2023	  sw		$a0,[$t2]		;	This will end up in buffer
FFFC4BCC 015010EF		call	FNDLN		; find this line in save area
FFFC4BD0 000EE533		mov		$s7,$t3		; save possible line pointer
FFFC4BD4 00080663		beq		$v0,$x0,INSLINE	; if not found, insert
FFFC4BD8 000EE933		mov		$a0,$t3
FFFC4BDC 044000EF		call	DeleteLine
                        	INSLINE:
FFFC4BE0 F80484E3		beq		$s6,$x0,BASPRMPT	; line was empty
FFFC4BE4 00046933		mov		$a0,$s5			; a0 = buffer pointer	
                        		; GetBuflen just get the length of the text.
                        		; A line number is stuffed just before the text
                        		; so length needs to be adjusted by 4.
FFFC4BE8 0B8000EF		call	GetBuflen
FFFC4BEC 00480393		add		$s4,$v0,#4
FFFC4BF0 00056933		mov		$a0,$s7
FFFC4BF4 0003E9B3		mov		$a1,$s4
FFFC4BF8 0D4000EF		call	OpenSpace
FFFC4BFC 00081863		bne		$v0,$x0,.0001	; space available?
FFFC4C00 FFFC7937		ldi		a0,#msgTooBig	; no space available
FFFC4C04 D6790913
FFFC4C08 6700106F		jmp		ERROR
                        	.0001:
FFFC4C0C 00056933		mov		$a0,$s7			; target
FFFC4C10 FFC40993		sub		$a1,$s5,#4	; source (incl lineno)
FFFC4C14 0003EA33		mov		$a2,$s4			; length
FFFC4C18 068000EF		call	InsertLine
FFFC4C1C F40006E3		bra		BASPRMPT
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = pointer to line to delete
                        	; Modifies:
                        	;		t0,t1,t2,t3
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	DeleteLine:
                        		; Find the end of the line to delete
FFFC4C20 00490D13		add		$t0,$a0,#4		; t0 = pointer to line past line number
FFFC4C24 00D06E13		ldi		$t2,#CR
FFFC4C28 00030637		lw		$t3,TXTUNF		; last text address
FFFC4C2C 00460613
FFFC4C30 00060633
FFFC4C34 00062E83
                        	.0002:
FFFC4C38 000D4D83		lbu		$t1,[$t0]
FFFC4C3C 000D8A63		beq		$t1,$x0,.0003	; might be null
FFFC4C40 01CD8663		beq		$t1,$t2,.0001	; lines end with CR
FFFC4C44 001D0D13		add		$t0,$t0,#1
FFFC4C48 FFDD68E3		bltu	$t0,$t3,.0002	; end of program?
                        	.0001:
FFFC4C4C 001D0D13		add		$t0,$t0,#1
                        	.0003:
                        		; pull text after eol overtop
FFFC4C50 000D4F03		lbu		$t4,[$t0]			; copy from next line
FFFC4C54 01E90023		sb		$t4,[$a0]			; overtop deleted line
FFFC4C58 001D0D13		add		$t0,$t0,#1		; increment pointers
FFFC4C5C 00190913		add		$a0,$a0,#1
FFFC4C60 FFAEF8E3		bleu	$t0,$t3,.0003	; to end of program
                        		; update end of text
FFFC4C64 412D0933		sub		$a0,$t0,$a0		; difference of pointers = length
FFFC4C68 412E8EB3		sub		$t3,$t3,$a0		
FFFC4C6C 00030637		sw		$t3,TXTUNF
FFFC4C70 00460613
FFFC4C74 00060633
FFFC4C78 01D62023
FFFC4C7C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = insertion point
                        	; 	a1 = source buffer
                        	; 	a2 = length
                        	; Modifies:
                        	;		a0,a1,a2,t1
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	InsertLine:
FFFC4C80 000A0E63		beq		$a2,$x0,.done		; zero length? Probably a SW error
                        	.0001:
FFFC4C84 0009CD83		lbu		$t1,[$a1]				; get from source text
FFFC4C88 01B90023		sb		$t1,[$a0]				; store to insertion point
FFFC4C8C 00198993		add		$a1,$a1,#1			; increment pointers
FFFC4C90 00190913		add		$a0,$a0,#1
FFFC4C94 FFFA0A13		sub		$a2,$a2,#1			; decrement length
FFFC4C98 FF4066E3		bgtu	$a2,$x0,.0001
                        	.done:
FFFC4C9C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; GetBuflen - get the length of text in a buffer. The length is taken up to
                        	; the first null character or carriage return character encountered.
                        	;
                        	; Parameters:
                        	;		a0 = pointer to buffer
                        	; Modifies:
                        	;		t2,t3,t5
                        	; Returns:
                        	;		v0 = length of data in buffer
                        	;------------------------------------------------------------------------------
                        	
                        	GetBuflen:
FFFC4CA0 00006813		ldi		$v0,#0
FFFC4CA4 00D06E93		ldi		$t3,#CR
FFFC4CA8 00096FB3		mov		$t5,$a0
                        	.0002:
FFFC4CAC 000FCE03		lbu		$t2,[$t5]
FFFC4CB0 001F8F93		add		$t5,$t5,#1
FFFC4CB4 000E0A63		beq		$t2,$x0,.0001
FFFC4CB8 01DE0663		beq		$t2,$t3,.0004
FFFC4CBC 00180813		add		$v0,$v0,#1
FFFC4CC0 FE0006E3		bra		.0002
                        	.0004:
FFFC4CC4 00180813		add		$v0,$v0,#1
                        	.0001:
FFFC4CC8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = place to insert line
                        	; 	a1 = buffer length
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		v0 = 1 if successful, 0 if not enough room available
                        	;------------------------------------------------------------------------------
                        	
                        	OpenSpace:
FFFC4CCC 00030637		lw		$t2,TXTUNF
FFFC4CD0 00460613
FFFC4CD4 00060633
FFFC4CD8 00062E03
FFFC4CDC 000E6EB3		mov		$t3,$t2				; t3 = old end of text
FFFC4CE0 013E0E33		add		$t2,$t2,$a1		; increment end of text by buffer length
FFFC4CE4 00030637		lw		$t1,VARBGN		; compare to start of variables
FFFC4CE8 00860613
FFFC4CEC 00060633
FFFC4CF0 00062D83
FFFC4CF4 03BE7863		bgeu	$t2,$t1,.noSpace	; enough room?
FFFC4CF8 00030637		sw		$t2,TXTUNF		; yes, set new end of text
FFFC4CFC 00460613
FFFC4D00 00060633
FFFC4D04 01C62023
                        	.0003:
FFFC4D08 000ECF83		lbu		$t5,[$t3]			; copy old text
FFFC4D0C 01FE0023		sb		$t5,[$t2]			; to new text loc
FFFC4D10 FFFE8E93		sub		$t3,$t3,#1		; decrement pointers
FFFC4D14 FFFE0E13		sub		$t2,$t2,#1
FFFC4D18 FF2EF8E3		bgeu	$t3,$a0,.0003	; until insert point reached
FFFC4D1C 00106813		ldi		$v0,#1				; return success
FFFC4D20 00008067		ret
                        	.noSpace:
FFFC4D24 00006813		ldi		$v0,#0
FFFC4D28 00008067		ret	
                        	
                        	;******************************************************************
                        	;
                        	; *** Tables *** DIRECT *** EXEC ***
                        	;
                        	; This section of the code tests a string against a table. When
                        	; a match is found, control is transferred to the section of
                        	; code according to the table.
                        	;
                        	; At 'EXEC', r8 should point to the string, r9 should point to
                        	; the character table, and r10 should point to the execution
                        	; table. At 'DIRECT', r8 should point to the string, r9 and
                        	; r10 will be set up to point to TAB1 and TAB1_1, which are
                        	; the tables of all direct and statement commands.
                        	;
                        	; A '.' in the string will terminate the test and the partial
                        	; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                        	; 'PRIN.', or 'PRINT' will all match 'PRINT'.
                        	;
                        	; There are two tables: the character table and the execution
                        	; table. The character table consists of any number of text items.
                        	; Each item is a string of characters with the last character's
                        	; high bit set to one. The execution table holds a 32-bit
                        	; execution addresses that correspond to each entry in the
                        	; character table.
                        	;
                        	; The end of the character table is a 0 byte which corresponds
                        	; to the default routine in the execution table, which is
                        	; executed if none of the other table items are matched.
                        	;
                        	; Character-matching tables:
                        	TAB1:
FFFC4D2C D453494C		db	"LIS",'T'+0x80        ; Direct commands
FFFC4D30 C4414F4C		db	"LOA",'D'+0x80
FFFC4D34 52D7454E		db	"NE",'W'+0x80
FFFC4D37 53CE5552		db	"RU",'N'+0x80
FFFC4D3A C5564153		db	"SAV",'E'+0x80
                        	TAB2:
FFFC4D3E D458454E		db	"NEX",'T'+0x80         ; Direct / statement
FFFC4D42 49D4454C		db	"LE",'T'+0x80
FFFC4D45 4F47C649		db	"I",'F'+0x80
FFFC4D47 CF544F47		db	"GOT",'O'+0x80
FFFC4D4B 55534F47		db	"GOSU",'B'+0x80
FFFC4D4F 544552C2
FFFC4D50 55544552		db	"RETUR",'N'+0x80
FFFC4D54 4552CE52
FFFC4D56 46CD4552		db	"RE",'M'+0x80
FFFC4D59 49D24F46		db	"FO",'R'+0x80
FFFC4D5C 55504E49		db	"INPU",'T'+0x80
FFFC4D60 495250D4
FFFC4D61 4E495250		db	"PRIN",'T'+0x80
FFFC4D65 4B4F50D4
FFFC4D66 C54B4F50		db	"POK",'E'+0x80
FFFC4D6A 454B4F50		db	"POKE",'W'+0x80
FFFC4D6E 4B4F50D7
FFFC4D6F 454B4F50		db	"POKE",'H'+0x80
FFFC4D73 454959C8
FFFC4D74 4C454959		db	"YIEL",'D'+0x80
FFFC4D78 4F5453C4
FFFC4D79 D04F5453		db	"STO",'P'+0x80
FFFC4D7D 53C55942		db	"BY",'E'+0x80
FFFC4D80 43D35953		db	"SY",'S'+0x80
FFFC4D83 43D34C43		db	"CL",'S'+0x80
FFFC4D86 52D24C43	    db  "CL",'R'+0x80
FFFC4D89 C6434452	    db	"RDC",'F'+0x80
FFFC4D8D 52494E4F	    db	"ONIR",'Q'+0x80
FFFC4D91 494157D1
FFFC4D92 D4494157	    db	"WAI",'T'+0x80
FFFC4D96 45455000		db	0
                        	TAB4:
FFFC4D97 CB454550		db	"PEE",'K'+0x80         ;Functions
FFFC4D9B 4B454550		db	"PEEK",'W'+0x80
FFFC4D9F 454550D7
FFFC4DA0 4B454550		db	"PEEK",'H'+0x80
FFFC4DA4 C44E52C8
FFFC4DA5 41C44E52		db	"RN",'D'+0x80
FFFC4DA8 53D34241		db	"AB",'S'+0x80
FFFC4DAB 54CE4753		db  "SG",'N'+0x80
FFFC4DAE CB434954		db	"TIC",'K'+0x80
FFFC4DB2 C55A4953		db	"SIZ",'E'+0x80
FFFC4DB6 41D25355		db  "US",'R'+0x80
FFFC4DB9 4F4C4C41	  db	"ALLOCMB",'X'+0x80
FFFC4DBD D8424D43
FFFC4DC1 444E4553	  db	"SENDMS",'G'+0x80
FFFC4DC5 57C7534D
FFFC4DC8 54494157	  db	"WAITMS",'G'+0x80
FFFC4DCC 00C7534D
FFFC4DCF 00CF5400		db	0
                        	TAB5:
FFFC4DD0 5300CF54		db	"T",'O'+0x80           ;"TO" in "FOR"
FFFC4DD2 45545300		db	0
                        	TAB6:
FFFC4DD3 D0455453		db	"STE",'P'+0x80         ;"STEP" in "FOR"
FFFC4DD7 3CBD3E00		db	0
                        	TAB8:
FFFC4DD8 BE3CBD3E		db	'>','='+0x80           ;Relational operators
FFFC4DDA BDBEBE3C		db	'<','>'+0x80
FFFC4DDC BD3CBDBE		db	'>'+0x80
FFFC4DDD BCBD3CBD		db	'='+0x80
FFFC4DDE 00BCBD3C		db	'<','='+0x80
FFFC4DE0 4E4100BC		db	'<'+0x80
FFFC4DE1 C44E4100		db	0
                        	TAB9:
FFFC4DE2 00C44E41	    db  "AN",'D'+0x80
FFFC4DE5 00D24F00	    db  0
                        	TAB10:
FFFC4DE6 0000D24F	    db  "O",'R'+0x80
FFFC4DE8 510C0000	    db  0
                        	
                        	;* Execution address tables:
                        	; We save some bytes by specifiying only the low order 16 bits of the address
                        	;
FFFC4DE9 40510C00		align	
                        	
                        	TAB1_1:
FFFC4DEA 5740510C		dh	LISTX			;Direct commands
FFFC4DEC 4EE85740		dh	LOAD3
FFFC4DEE 4F1C4EE8		dh	NEW
FFFC4DF0 57A84F1C		dh	RUN
FFFC4DF2 53BC57A8		dh	SAVE3
                        	TAB2_1:
FFFC4DF4 55D453BC		dh	NEXT		;	Direct / statement
FFFC4DF6 547C55D4		dh	LET
FFFC4DF8 5040547C		dh	IF0
FFFC4DFA 52005040		dh	GOTO
FFFC4DFC 52745200		dh	GOSUB
FFFC4DFE 54885274		dh	RETURN
FFFC4E00 52DC5488		dh	IF2			; REM
FFFC4E02 54D452DC		dh	FOR
FFFC4E04 516054D4		dh	INPUT
FFFC4E06 591C5160		dh	PRINT
FFFC4E08 5948591C		dh	POKE
FFFC4E0A 59745948		dh	POKEW
FFFC4E0C 4F105974		dh	POKEH
FFFC4E0E 4F084F10		dh	YIELD0
FFFC4E10 4A204F08		dh	STOP
FFFC4E12 59AC4A20		dh	GOBYE
FFFC4E14 033759AC		dh	SYSX
FFFC4E16 50640337		dh	_cls
FFFC4E18 03395064		dh  _clr
FFFC4E1A 50B00339		dh	_rdcf
FFFC4E1C 50F050B0		dh  ONIRQ
FFFC4E1E 55C850F0		dh	WAITIRQ
FFFC4E20 5FEC55C8		dh	DEFLT
                        	TAB4_1:
FFFC4E22 60045FEC		dh	PEEK			;Functions
FFFC4E24 601C6004		dh	PEEKW
FFFC4E26 6080601C		dh	PEEKH
FFFC4E28 00006080		dh	RND
FFFC4E2A 61140000		dh	ABS
FFFC4E2C 61006114		dh  SGN
FFFC4E2E 61506100		dh	TICKX
FFFC4E30 60346150		dh	SIZEX
FFFC4E32 69A06034		dh  USRX
FFFC4E34 6A1069A0		dh	ALLOCMBX
FFFC4E36 6AAC6A10		dh	SENDMSG
FFFC4E38 5DA46AAC		dh	WAITMSG
FFFC4E3A 53085DA4		dh	XP40
                        	TAB5_1
FFFC4E3C 62705308		dh	FR1			;"TO" in "FOR"
FFFC4E3E 53306270		dh	QWHAT
                        	TAB6_1
FFFC4E40 53385330		dh	FR2			;"STEP" in "FOR"
FFFC4E42 5B5C5338		dh	FR3
                        	TAB8_1
FFFC4E44 5B745B5C		dh	XP11	;>=		Relational operators
FFFC4E46 5B8C5B74		dh	XP12	;<>
FFFC4E48 5BBC5B8C		dh	XP13	;>
FFFC4E4A 5BA45BBC		dh	XP15	;=
FFFC4E4C 5BD45BA4		dh	XP14	;<=
FFFC4E4E 5C145BD4		dh	XP16	;<
FFFC4E50 5A6C5C14		dh	XP17
                        	TAB9_1
FFFC4E52 5A805A6C	    dh  XP_AND
FFFC4E54 5A0C5A80	    dh  XP_ANDX
                        	TAB10_1
FFFC4E56 5A205A0C	    dh  XP_OR
FFFC4E58 00005A20	    dh  XP_ORX
                        	
                        	;*
                        	; r3 = match flag (trashed)
                        	; r9 = text table
                        	; r10 = exec table
                        	; r11 = trashed
FFFC4E5A 00000000		align	1
FFFC4E5E 5EB70000
                        	
                        	//message "DIRECT"
                        	DIRECT:
FFFC4E60 FFFC5EB7		ldi		$t3,#TAB1
FFFC4E64 D2CE8E93
FFFC4E68 FFFC5F37		ldi		$t4,#TAB1_1
FFFC4E6C DEAF0F13
                        	EXEC:
FFFC4E70 235010EF		call	IGNBLK		; ignore leading blanks
FFFC4E74 000E6FB3		mov		$t5,$t2		; save the pointer
FFFC4E78 000061B3		mov		r3,r0		; clear match flag
                        	EXLP:
FFFC4E7C 000E4903		lbu		a0,[$t2]		; get the program character
FFFC4E80 001E0E13		add		$t2,$t2,#1
FFFC4E84 000EC983		lbu		a1,[$t3]		; get the table character
FFFC4E88 00099663		bne		a1,x0,EXNGO		; If end of table,
FFFC4E8C 000FEE33		mov		$t2,$t5		;	restore the text pointer and...
FFFC4E90 04000263		bra		EXGO		;   execute the default.
                        	EXNGO:
FFFC4E94 04390063		beq		a0,r3,EXGO	; Else check for period... if so, execute
FFFC4E98 07F9F993		and		a1,a1,#0x7f	; ignore the table's high bit
FFFC4E9C 03298263		beq		a1,a0,EXMAT	;		is there a match?
FFFC4EA0 002F0F13		add		$t4,$t4,#2	;if not, try the next entry
FFFC4EA4 000FEE33		mov		$t2,$t5		; reset the program pointer
FFFC4EA8 000061B3		mov		r3,x0		; sorry, no match
                        	EX1:
FFFC4EAC 000EC903		lbu		a0,[$t3]		; get to the end of the entry
FFFC4EB0 001E8E93		add		$t3,$t3,#1
FFFC4EB4 08097D93		and		$t1,$a0,#$80
FFFC4EB8 FE0D8AE3		beq		$t1,$r0,EX1	; test for bit 7 set
FFFC4EBC FC0000E3		bra		EXLP		; back for more matching
                        	EXMAT:
FFFC4EC0 02E06193		ldi		r3,#'.'		; we've got a match so far
FFFC4EC4 000EC903		lbu		a0,[$t3]		; end of table entry?
FFFC4EC8 001E8E93		add		$t3,$t3,#1
FFFC4ECC 08097D93		and		$t1,$a0,#$80
FFFC4ED0 FA0D86E3		beq		$t1,$r0,EXLP		; test for bit 7 set, if not, go back for more
                        	EXGO:
                        		; execute the appropriate routine
FFFC4ED4 000F5903		lhu		a0,[$t4]	; get the low mid order byte
FFFC4ED8 FFFC0637		or		a0,a0,#$FFFC0000	; add in ROM base
FFFC4EDC 00060613
FFFC4EE0 01266933
FFFC4EE4 00090067		jmp		[a0]
                        	
                        	    
                        	;******************************************************************
                        	;
                        	; What follows is the code to execute direct and statement
                        	; commands. Control is transferred to these points via the command
                        	; table lookup code of 'DIRECT' and 'EXEC' in the last section.
                        	; After the command is executed, control is transferred to other
                        	; sections as follows:
                        	;
                        	; For 'LISTX', 'NEW', and 'STOP': go back to the warm start point.
                        	; For 'RUN': go execute the first stored line if any; else go
                        	; back to the warm start point.
                        	; For 'GOTO' and 'GOSUB': go execute the target line.
                        	; For 'RETURN' and 'NEXT'; go back to saved return line.
                        	; For all others: if 'CURRNT' is 0, go to warm start; else go
                        	; execute next command. (This is done in 'FINISH'.)
                        	;
                        	;******************************************************************
                        	;
                        	; *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                        	;
                        	; 'NEW<CR>' sets TXTUNF to point to TXTBGN
                        	;
                        	
                        	NEW:
FFFC4EE8 340010EF		call	ENDCHK
FFFC4EEC 00032837		ldi		v0,#TXTBGN
FFFC4EF0 80080813
FFFC4EF4 00030637		sw		v0,TXTUNF	;	set the end pointer
FFFC4EF8 00460613
FFFC4EFC 00060633
FFFC4F00 01062023
FFFC4F04 168000EF		call  clearVars
                        	
                        	; 'STOP<CR>' goes back to WSTART
                        	;
                        	STOP:
FFFC4F08 320010EF		call	ENDCHK
FFFC4F0C C19FF06F		jmp		WSTART		; WSTART will reset the stack
                        	
                        	;------------------------------------------------------------------------------
                        	; YIELD suspends execution of TinyBasic by switching to the next ready task.
                        	;------------------------------------------------------------------------------
                        	
                        	YIELD0:
FFFC4F10 00D06913		ldi		a0,#13
FFFC4F14 00000073		ecall
FFFC4F18 2E00006F		jmp		FINISH
                        	
                        	;------------------------------------------------------------------------------
                        	; 'RUN<CR>' finds the first stored line, stores its address
                        	; in CURRNT, and starts executing it. Note that only those
                        	; commands in TAB2 are legal for a stored program.
                        	;
                        	; There are 3 more entries in 'RUN':
                        	; 'RUNNXL' finds next line, stores it's address and executes it.
                        	; 'RUNTSL' stores the address of this line and executes it.
                        	; 'RUNSML' continues the execution on same line.
                        	;
                        	RUN:
FFFC4F1C 30C010EF		call	ENDCHK
FFFC4F20 00032E37		ldi		$t2,#TXTBGN	;	set pointer to beginning
FFFC4F24 800E0E13
FFFC4F28 00030637		sw		$t2,CURRNT
FFFC4F2C 01860613
FFFC4F30 00060633
FFFC4F34 01C62023
FFFC4F38 134000EF		call  clearVars
                        	
                        	RUNNXL:					; RUN <next line>
FFFC4F3C 00030637		lw		$t2,CURRNT	; executing a program?
FFFC4F40 01860613
FFFC4F44 00060633
FFFC4F48 00062E03
FFFC4F4C 000E1463		bne		$t2,x0,RUN3	; if not, we've finished a direct stat.
                        	RUN2:
FFFC4F50 BD5FF06F		jmp		WSTART
                        	RUN3:
FFFC4F54 00030637		lw		a0,IRQROUT		; are we handling IRQ's ?
FFFC4F58 0A460613
FFFC4F5C 00060633
FFFC4F60 00062903
FFFC4F64 08090863		beq		a0,x0,RUN1
FFFC4F68 00030637		lw		$t1,IRQFlag		; was there an IRQ ?
FFFC4F6C 0B460613
FFFC4F70 00060633
FFFC4F74 00062D83
FFFC4F78 060D8E63		beq		$t1,x0,RUN1
FFFC4F7C 00030637		sw		x0,IRQFlag
FFFC4F80 0B460613
FFFC4F84 00060633
FFFC4F88 00062023
FFFC4F8C 598010EF		call	PUSHA_		; the same code as a GOSUB
FFFC4F90 FF470713		sub		$sp,$sp,#12
FFFC4F94 00030637		lw		a0,STKGOS
FFFC4F98 01460613
FFFC4F9C 00060633
FFFC4FA0 00062903
FFFC4FA4 01272023		sw		a0,[$sp]
FFFC4FA8 00030637		lw		a0,CURRNT
FFFC4FAC 01860613
FFFC4FB0 00060633
FFFC4FB4 00062903
FFFC4FB8 01272223		sw		a0,4[$sp]
FFFC4FBC 01C72423		sw		$t2,8[$sp]
FFFC4FC0 00030637		sw		x0,LOPVAR		; load new values
FFFC4FC4 01060613
FFFC4FC8 00060633
FFFC4FCC 00062023
FFFC4FD0 00030637		sw		$sp,STKGOS
FFFC4FD4 01460613
FFFC4FD8 00060633
FFFC4FDC 00E62023
FFFC4FE0 00030637		lw		$t3,IRQROUT
FFFC4FE4 0A460613
FFFC4FE8 00060633
FFFC4FEC 00062E83
FFFC4FF0 02000263		bra		RUNTSL
                        	RUN1:
FFFC4FF4 000E6EB3		mov		$t3,$t2
FFFC4FF8 00006933		mov		a0,x0
FFFC4FFC 404010EF		call	FNDLNP		; else find the next line number
FFFC5000 00030637		lw		$t1,TXTUNF	; if we've fallen off the end, stop
FFFC5004 00460613
FFFC5008 00060633
FFFC500C 00062D83
FFFC5010 F5BEF0E3		bgeu	$t3,$t1,RUN2
                        	
                        	RUNTSL:					; RUN <this line>
FFFC5014 00030637		sw		$t3,CURRNT	; set CURRNT to point to the line no.
FFFC5018 01860613
FFFC501C 00060633
FFFC5020 01D62023
FFFC5024 004E8E13		add		$t2,$t3,#4	; set the text pointer to
                        	
                        	RUNSML:                 ; RUN <same line>
FFFC5028 131010EF		call	CHKIO		; see if a control-C was pressed
FFFC502C FFFC5EB7		ldi		$t3,#TAB2		; find command in TAB2
FFFC5030 D3EE8E93
FFFC5034 FFFC5F37		ldi		$t4,#TAB2_1
FFFC5038 DF4F0F13
FFFC503C E35FF06F		jmp		EXEC		; and execute it
                        	
                        	
                        	;******************************************************************
                        	; 'GOTO expr<CR>' evaluates the expression, finds the target
                        	; line, and jumps to 'RUNTSL' to do it.
                        	;******************************************************************
                        	;
                        	GOTO:
FFFC5040 199000EF		call	OREXPR		;evaluate the following expression
FFFC5044 000862B3		mov   r5,v0
FFFC5048 1E0010EF		call 	ENDCHK		;must find end of line
FFFC504C 0002E933		mov   a0,r5
FFFC5050 390010EF		call 	FNDLN		; find the target line
FFFC5054 FC0810E3		bne		v0,x0,RUNTSL; go do it
FFFC5058 FFFC7937		ldi		a0,#msgBadGotoGosub
FFFC505C D3590913
FFFC5060 2180106F		jmp		ERROR		; no such line no.
                        	
                        	_clr:
FFFC5064 008000EF	    call    clearVars
FFFC5068 1900006F	    jmp     FINISH
                        	
                        	; Clear the variable area of memory
                        	clearVars:
FFFC506C FF870713		sub		$sp,$sp,#8
FFFC5070 00672023		sw		r6,[$sp]
FFFC5074 00172223		sw		$ra,4[$sp]
FFFC5078 06406313	  ldi   r6,#100    	; number of word pairs to clear
FFFC507C 00030637	  lw    v0,VARBGN
FFFC5080 00860613
FFFC5084 00060633
FFFC5088 00062803
                        	.cv1:
FFFC508C 00082023	  sw		x0,[$v0]		; variable name
FFFC5090 00082223	  sw		x0,4[$v0]		; and value
FFFC5094 00880813	  add		v0,v0,#8
FFFC5098 FFF30313	  sub		r6,r6,#1
FFFC509C FE6048E3		bgt		r6,x0,.cv1
FFFC50A0 00072303	  lw		r6,[$sp]
FFFC50A4 00472083	  lw		$ra,4[$sp]
FFFC50A8 00870713	  add		$sp,$sp,#8
FFFC50AC 00008067	  ret
                        	
                        	;******************************************************************
                        	; ONIRQ <line number>
                        	; ONIRQ sets up an interrupt handler which acts like a specialized
                        	; subroutine call. ONIRQ is coded like a GOTO that never executes.
                        	;******************************************************************
                        	;
                        	ONIRQ:
FFFC50B0 129000EF		call	OREXPR		;evaluate the following expression
FFFC50B4 000862B3		mov   r5,v0
FFFC50B8 170010EF		call 	ENDCHK		;must find end of line
FFFC50BC 0002E933		mov   a0,r5
FFFC50C0 320010EF		call 	FNDLN		; find the target line
FFFC50C4 00081C63		bne		v0,r0,ONIRQ1
FFFC50C8 00030637		sw		x0,IRQROUT
FFFC50CC 0A460613
FFFC50D0 00060633
FFFC50D4 00062023
FFFC50D8 1200006F		jmp		FINISH
                        	ONIRQ1:
FFFC50DC 00030637		sw		$t3,IRQROUT
FFFC50E0 0A460613
FFFC50E4 00060633
FFFC50E8 01D62023
FFFC50EC 10C0006F		jmp		FINISH
                        	
                        	WAITIRQ:
FFFC50F0 069010EF		call	CHKIO		; see if a control-C was pressed
FFFC50F4 00030637		lw		$t1,IRQFlag
FFFC50F8 0B460613
FFFC50FC 00060633
FFFC5100 00062D83
FFFC5104 FE0D86E3		beq		$t1,x0,WAITIRQ
FFFC5108 0F00006F		jmp		FINISH
                        	
                        	
                        	;******************************************************************
                        	; LIST
                        	;
                        	; LISTX has two forms:
                        	; 'LIST<CR>' lists all saved lines
                        	; 'LIST #<CR>' starts listing at the line #
                        	; Control-S pauses the listing, control-C stops it.
                        	;******************************************************************
                        	;
                        	LISTX:
FFFC510C 724010EF		call		TSTNUM		; see if there's a line no.
FFFC5110 000862B3		mov      r5,v0
FFFC5114 114010EF		call		ENDCHK		; if not, we get a zero
FFFC5118 0002E933		mov      a0,r5
FFFC511C 2C4010EF		call		FNDLN		; find this or next line
                        	LS1:
FFFC5120 00081C63		bne		v0,r0,LS4
                        	LS5:
FFFC5124 00030637		lw		$t1,TXTUNF
FFFC5128 00460613
FFFC512C 00060633
FFFC5130 00062D83
FFFC5134 9FBEF8E3		bgeu	$t3,$t1,WSTART	; warm start if we passed the end
                        	LS4:
FFFC5138 000EE933		mov		a0,$t3
FFFC513C 64C010EF		call	PRTLN		; print the line
FFFC5140 00086EB3		mov		$t3,$v0		; set pointer for next
FFFC5144 015010EF		call	CHKIO		; check for listing halt request
FFFC5148 00080A63		beq		v0,x0,LS3
FFFC514C 01306D93		ldi		$t1,#CTRLS
FFFC5150 01B81663		bne		v0,$t1,LS3; pause the listing?
                        	LS2:
FFFC5154 005010EF		call 	CHKIO		; if so, wait for another keypress
FFFC5158 FE080EE3		beq		v0,r0,LS2
                        	LS3:
                        	;	mov		$v0,$x0
FFFC515C FC0004E3		bra		LS5
                        	;	mov		a0,r0
                        	;	call	FNDSKP	;FNDLNP		; find the next line
                        	;	bra		LS1
                        	
                        	
                        	;******************************************************************
                        	; PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                        	; where '....' is a list of expressions, formats, back-arrows,
                        	; and strings.	These items a separated by commas.
                        	;
                        	; A format is a pound sign followed by a number.  It controls
                        	; the number of spaces the value of an expression is going to
                        	; be printed in.  It stays effective for the rest of the print
                        	; command unless changed by another format.  If no format is
                        	; specified, 11 positions will be used.
                        	;
                        	; A string is quoted in a pair of single- or double-quotes.
                        	;
                        	; An underline (back-arrow) means generate a <CR> without a <LF>
                        	;
                        	; A <CR LF> is generated after the entire list has been printed
                        	; or if the list is empty.  If the list ends with a semicolon,
                        	; however, no <CR LF> is generated.
                        	;******************************************************************
                        	;
                        	PRINT:
FFFC5160 00B06293		ldi		r5,#11		; D4 = number of print spaces
FFFC5164 680010EF		call	TSTC		; if null list and ":"
FFFC5168 0000003A		dw		':'
FFFC516C 00000663		bra		PR2
FFFC5170 011010EF		call	CRLF		; give CR-LF and continue
FFFC5174 EB5FF06F		jmp		RUNSML		;		execution on the same line
                        	PR2:
FFFC5178 66C010EF		call	TSTC		;if null list and <CR>
FFFC517C 0000000D		dw		CR
FFFC5180 00000663		bra		PR0
FFFC5184 7FC010EF		call	CRLF		;also give CR-LF and
FFFC5188 DB5FF06F		jmp		RUNNXL		;execute the next line
                        	PR0:
FFFC518C 658010EF		call	TSTC		;else is it a format?
FFFC5190 00000023		dw		'#'
FFFC5194 00000863		bra		PR1
FFFC5198 041000EF		call	OREXPR		; yes, evaluate expression
FFFC519C 000862B3		mov		r5,v0	; and save it as print width
FFFC51A0 02000263		bra		PR3		; look for more to print
                        	PR1:
FFFC51A4 640010EF		call	TSTC	;	is character expression? (MRL)
FFFC51A8 00000024		dw		'$'
FFFC51AC 00000863		bra		PR4
FFFC51B0 029000EF		call	OREXPR	;	yep. Evaluate expression (MRL)
FFFC51B4 855FF0EF		call	GOOUT	;	print low byte (MRL)
FFFC51B8 00000663		bra		PR3		;look for more. (MRL)
                        	PR4:
FFFC51BC 45C010EF		call	QTSTG	;	is it a string?
                        		; the following branch must occupy only 1 word!
FFFC51C0 02000063		bra		PR8		;	if not, must be an expression
                        	PR3:
FFFC51C4 620010EF		call		TSTC	;	if ",", go find next
FFFC51C8 0000002C		dw		','
FFFC51CC 00000663		bra		PR6
FFFC51D0 01C010EF		call		FIN		;in the list.
FFFC51D4 FA000CE3		bra		PR0
                        	PR6:
FFFC51D8 7A8010EF		call		CRLF		;list ends here
FFFC51DC 01C0006F		jmp		FINISH
                        	PR8:
FFFC51E0 7F8000EF		call	OREXPR		; evaluate the expression
FFFC51E4 00086933		mov		a0,v0
FFFC51E8 00506993		ldi		a1,#5		; set the width
FFFC51EC 00A06A13		ldi		a2,#10
FFFC51F0 4BC010EF		call	PRTNUM		; print its value
FFFC51F4 FC0008E3		bra		PR3			; more to print?
                        	
                        	
                        	FINISH:
FFFC51F8 7F5000EF		call	FIN		; Check end of command
FFFC51FC 0740106F		jmp		QWHAT	; print "What?" if wrong
                        	
                        	
                        	;*******************************************************************
                        	;
                        	; *** GOSUB *** & RETURN ***
                        	;
                        	; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                        	; except that the current text pointer, stack pointer, etc. are
                        	; saved so that execution can be continued after the subroutine
                        	; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                        	; recursive), the save area must be stacked.  The stack pointer
                        	; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                        	; If we are in the main routine, 'STKGOS' is zero (this was done
                        	; in the initialization section of the interpreter), but we still
                        	; save it as a flag for no further 'RETURN's.
                        	;******************************************************************
                        	;
                        	GOSUB:
FFFC5200 324010EF		call	PUSHA_		; save the current 'FOR' parameters
FFFC5204 7D4000EF		call	OREXPR		; get line number
FFFC5208 00086933		mov		$a0,$v0
FFFC520C 1D4010EF		call	FNDLN		; find the target line
FFFC5210 00081863		bne		v0,r0,gosub1
FFFC5214 FFFC7937		ldi		a0,#msgBadGotoGosub
FFFC5218 D3590913
FFFC521C 05C0106F		jmp		ERROR		; if not there, say "How?"
                        	gosub1:
FFFC5220 FF470713		sub		$sp,$sp,#12
FFFC5224 00030637		lw		a0,STKGOS	; 'STKGOS'
FFFC5228 01460613
FFFC522C 00060633
FFFC5230 00062903
FFFC5234 01272023		sw		a0,[$sp]
FFFC5238 00030637		lw		a0,CURRNT	; found it, save old 'CURRNT'...
FFFC523C 01860613
FFFC5240 00060633
FFFC5244 00062903
FFFC5248 01272223		sw		a0,4[$sp]
FFFC524C 01C72423		sw		$t2,8[$sp]
FFFC5250 00030637		sw		$x0,LOPVAR		; load new values
FFFC5254 01060613
FFFC5258 00060633
FFFC525C 00062023
FFFC5260 00030637		sw		$sp,STKGOS
FFFC5264 01460613
FFFC5268 00060633
FFFC526C 00E62023
FFFC5270 DA5FF06F		jmp		RUNTSL
                        	
                        	
                        	;******************************************************************
                        	; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                        	; returns the execution to the command after the most recent
                        	; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                        	; a 'GOSUB' and is thus an error.
                        	;******************************************************************
                        	;
                        	RETURN:
FFFC5274 7B5000EF		call	ENDCHK		; there should be just a <CR>
FFFC5278 00030637		lw		a1,STKGOS		; get old stack pointer
FFFC527C 01460613
FFFC5280 00060633
FFFC5284 00062983
FFFC5288 00099863		bne		a1,x0,return1
FFFC528C FFFC7937		ldi		a0,#msgRetWoGosub
FFFC5290 D5190913
FFFC5294 7E50006F		jmp		ERROR		; if zero, it doesn't exist
                        	return1:
FFFC5298 0009E733		mov		$sp,a1		; else restore it
FFFC529C 00072903		lw		a0,[$sp]
FFFC52A0 00470713		add		$sp,$sp,#4
FFFC52A4 00030637		sw		a0,STKGOS	; and the old 'STKGOS'
FFFC52A8 01460613
FFFC52AC 00060633
FFFC52B0 01262023
FFFC52B4 00072903		lw		a0,[$sp]
FFFC52B8 00470713		add		$sp,$sp,#4
FFFC52BC 00030637		sw		a0,CURRNT	; and the old 'CURRNT'
FFFC52C0 01860613
FFFC52C4 00060633
FFFC52C8 01262023
FFFC52CC 00072E03		lw		$t2,[$sp]	; and the old text pointer
FFFC52D0 00470713		add		$sp,$sp,#4
FFFC52D4 1DC010EF		call	POPA_		;and the old 'FOR' parameters
FFFC52D8 F21FF06F		jmp		FINISH		;and we are back home
                        	
                        	;******************************************************************
                        	; *** FOR *** & NEXT ***
                        	;
                        	; 'FOR' has two forms:
                        	; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                        	; The second form means the same thing as the first form with a
                        	; STEP of positive 1.  The interpreter will find the variable 'var'
                        	; and set its value to the current value of 'exp1'.  It also
                        	; evaluates 'exp2' and 'exp1' and saves all these together with
                        	; the text pointer, etc. in the 'FOR' save area, which consists of
                        	; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                        	; already something in the save area (indicated by a non-zero
                        	; 'LOPVAR'), then the old save area is saved on the stack before
                        	; the new values are stored.  The interpreter will then dig in the
                        	; stack and find out if this same variable was used in another
                        	; currently active 'FOR' loop.  If that is the case, then the old
                        	; 'FOR' loop is deactivated. (i.e. purged from the stack)
                        	;******************************************************************
                        	;
                        	FOR:
FFFC52DC 248010EF		call	PUSHA_		; save the old 'FOR' save area
FFFC52E0 6A5000EF		call	SETVAL		; set the control variable
FFFC52E4 00030637		sw		v0,LOPVAR		; save its address
FFFC52E8 01060613
FFFC52EC 00060633
FFFC52F0 01062023
FFFC52F4 FFFC5EB7		ldi		$t3,#TAB5
FFFC52F8 DD0E8E93
FFFC52FC FFFC5F37		ldi		$t4,#TAB5_1	; use 'EXEC' to test for 'TO'
FFFC5300 E3CF0F13
FFFC5304 B6DFF06F		jmp		EXEC
                        	FR1:
FFFC5308 6D0000EF		call	OREXPR		; evaluate the limit
FFFC530C 00030637		sw		v0,LOPLMT	; save that
FFFC5310 07C60613
FFFC5314 00060633
FFFC5318 01062023
FFFC531C FFFC5EB7		ldi		$t3,#TAB6
FFFC5320 DD3E8E93
FFFC5324 FFFC5F37		ldi		$t4,#TAB6_1	; use 'EXEC' to test for the word 'STEP
FFFC5328 E40F0F13
FFFC532C B45FF06F		jmp		EXEC
                        	FR2:
FFFC5330 6A8000EF		call	OREXPR		; found it, get the step value
FFFC5334 00000463		bra		FR4
                        	FR3:
FFFC5338 00106813		ldi		v0,#1		; not found, step defaults to 1
                        	FR4:
FFFC533C 00030637		sw		v0,LOPINC	; save that too
FFFC5340 07860613
FFFC5344 00060633
FFFC5348 01062023
                        	FR5:
FFFC534C 00030637		lw		a1,CURRNT
FFFC5350 01860613
FFFC5354 00060633
FFFC5358 00062983
FFFC535C 00030637		sw		a1,LOPLN	; save address of current line number
FFFC5360 07460613
FFFC5364 00060633
FFFC5368 01362023
FFFC536C 00030637		sw		$t2,LOPPT	; and text pointer
FFFC5370 07060613
FFFC5374 00060633
FFFC5378 01C62023
FFFC537C 000761B3		mov		r3,$sp		; dig into the stack to find 'LOPVAR'
FFFC5380 00030637		lw		r6,LOPVAR
FFFC5384 01060613
FFFC5388 00060633
FFFC538C 00062303
FFFC5390 00000463		bra		FR7
                        	FR6:
FFFC5394 01418193		add		r3,r3,#20	; look at next stack frame
                        	FR7:
FFFC5398 0001A983		lw		a1,[r3]		; is it zero?
FFFC539C 00098E63		beq		a1,x0,FR8	; if so, we're done
FFFC53A0 FE699AE3		bne		a1,r6,FR6	; same as current LOPVAR? nope, look some more
                        	
FFFC53A4 0001E933	  mov		a0,r3	   ; Else remove 5 words from...
FFFC53A8 000769B3		mov		a1,$sp
FFFC53AC 01418A13		add		a2,r3,#20  ; inside the stack.
FFFC53B0 0F8010EF		call	MVDOWN
FFFC53B4 01470713		add		$sp,$sp,#20	; set the SP 5 long words up
                        	;	lw		a0,[$sp]		; ???
                        	;	add		$sp,$sp,#4
                        	FR8:
FFFC53B8 E41FF06F	  jmp	    FINISH		; and continue execution
                        	
                        	
                        	;******************************************************************
                        	; 'NEXT var' serves as the logical (not necessarily physical) end
                        	; of the 'FOR' loop.  The control variable 'var' is checked with
                        	; the 'LOPVAR'.  If they are not the same, the interpreter digs in
                        	; the stack to find the right one and purges all those that didn't
                        	; match.  Either way, it then adds the 'STEP' to that variable and
                        	; checks the result with against the limit value.  If it is within
                        	; the limit, control loops back to the command following the
                        	; 'FOR'.  If it's outside the limit, the save area is purged and
                        	; execution continues.
                        	;******************************************************************
                        	;
                        	NEXT:
FFFC53BC 00006933		mov		a0,x0		; don't allocate it
FFFC53C0 259000EF		call	TSTV		; get address of variable
FFFC53C4 00081863		bne		v0,x0,NX4
FFFC53C8 FFFC7937		ldi		a0,#msgNextVar
FFFC53CC D1290913
FFFC53D0 6A0004E3		bra		ERROR		; if no variable, say "What?"
                        	NX4:
FFFC53D4 00086EB3		mov		$t3,v0	; save variable's address
                        	NX0:
FFFC53D8 00030637		lw		a0,LOPVAR	; If 'LOPVAR' is zero, we never...
FFFC53DC 01060613
FFFC53E0 00060633
FFFC53E4 00062903
FFFC53E8 00091863		bne		a0,x0,NX5	; had a FOR loop
FFFC53EC FFFC7937		ldi		a0,#msgNextFor
FFFC53F0 D0090913
FFFC53F4 680002E3		bra		ERROR
                        	NX5:
FFFC53F8 01D90663		beq		a0,$t3,NX2	; else we check them OK, they agree
FFFC53FC 0B4010EF		call	POPA_		; nope, let's see the next frame
FFFC5400 FC000CE3		bra		NX0
                        	NX2:
FFFC5404 000EA903		lw		a0,[$t3]		; get control variable's value
FFFC5408 00030637		lw		a1,LOPINC
FFFC540C 07860613
FFFC5410 00060633
FFFC5414 00062983
FFFC5418 01390933		add		a0,a0,a1	; add in loop increment
                        	;	BVS.L	QHOW		say "How?" for 32-bit overflow
FFFC541C 012EA023		sw		a0,[$t3]		; save control variable's new value
FFFC5420 00030637		lw		r3,LOPLMT	; get loop's limit value
FFFC5424 07C60613
FFFC5428 00060633
FFFC542C 00062183
FFFC5430 0009D663		bge		a1,x0,NX1	; check loop increment, branch if loop increment is positive
FFFC5434 04394063		blt		a0,r3,NXPurge	; test against limit
FFFC5438 00000463		bra     NX3
                        	NX1:
FFFC543C 0321CC63		bgt		a0,r3,NXPurge
                        	NX3:
FFFC5440 00030637		lw		$t2,LOPLN	; Within limit, go back to the...
FFFC5444 07460613
FFFC5448 00060633
FFFC544C 00062E03
FFFC5450 00030637		sw		$t2,CURRNT
FFFC5454 01860613
FFFC5458 00060633
FFFC545C 01C62023
FFFC5460 00030637		lw		$t2,LOPPT	; saved 'CURRNT' and text pointer.
FFFC5464 07060613
FFFC5468 00060633
FFFC546C 00062E03
FFFC5470 D89FF06F		jmp		FINISH
                        	NXPurge:
FFFC5474 03C010EF	  call    POPA_        ; purge this loop
FFFC5478 D81FF06F	  jmp     FINISH
                        	
                        	
                        	;******************************************************************
                        	; *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                        	;
                        	; 'REM' can be followed by anything and is ignored by the
                        	; interpreter.
                        	;
                        	;REM
                        	;    br	    IF2		    ; skip the rest of the line
                        	; 'IF' is followed by an expression, as a condition and one or
                        	; more commands (including other 'IF's) separated by colons.
                        	; Note that the word 'THEN' is not used.  The interpreter evaluates
                        	; the expression.  If it is non-zero, execution continues.  If it
                        	; is zero, the commands that follow are ignored and execution
                        	; continues on the next line.
                        	;******************************************************************
                        	;
                        	IF0:
FFFC547C 55C000EF	  call	OREXPR		; evaluate the expression
                        	IF1:
FFFC5480 00080463	  beq	  v0,x0,IF2	; is it zero? if not, continue
FFFC5484 BA5FF06F	  jmp		RUNSML
                        	IF2:
FFFC5488 000E6EB3	  mov		$t3,$t2	; set lookup pointer
FFFC548C 00006933		mov		a0,x0		; find line #0 (impossible)
FFFC5490 7DD000EF		call	FNDSKP		; if so, skip the rest of the line
FFFC5494 00081463		bne		v0,x0,IF3; if no next line, do a warm start
FFFC5498 E8CFF06F		jmp		WSTART
                        	IF3:
FFFC549C B79FF06F		jmp		RUNTSL		; run the next line
                        	
                        	
                        	;******************************************************************
                        	; INPUT is called first and establishes a stack frame
                        	INPERR:
FFFC54A0 00030637		lw		$sp,STKINP		; restore the old stack pointer
FFFC54A4 09860613
FFFC54A8 00060633
FFFC54AC 00062703
FFFC54B0 00072903		lw		a0,[$sp]
FFFC54B4 00470713		add		$sp,$sp,#4
FFFC54B8 00030637		sw		a0,CURRNT		; and old 'CURRNT'
FFFC54BC 01860613
FFFC54C0 00060633
FFFC54C4 01262023
FFFC54C8 00072E03		lw		$t2,[$sp]		; and old text pointer
FFFC54CC 00470713		add		$sp,$sp,#4
FFFC54D0 01470713		add		$sp,$sp,#20	; fall through will subtract 20
                        	
                        	; 'INPUT' is like the 'PRINT' command, and is followed by a list
                        	; of items.  If the item is a string in single or double quotes,
                        	; or is an underline (back arrow), it has the same effect as in
                        	; 'PRINT'.  If an item is a variable, this variable name is
                        	; printed out followed by a colon, then the interpreter waits for
                        	; an expression to be typed in.  The variable is then set to the
                        	; value of this expression.  If the variable is preceeded by a
                        	; string (again in single or double quotes), the string will be
                        	; displayed followed by a colon.  The interpreter the waits for an
                        	; expression to be entered and sets the variable equal to the
                        	; expression's value.  If the input expression is invalid, the
                        	; interpreter will print "What?", "How?", or "Sorry" and reprint
                        	; the prompt and redo the input.  The execution will not terminate
                        	; unless you press control-C.  This is handled in 'INPERR'.
                        	;
                        	INPUT:
FFFC54D4 FEC70713		sub		$sp,$sp,#20	; allocate five words on stack
FFFC54D8 00572823		sw		r5,16[$sp]	; save off r5 into stack var
                        	IP6:
FFFC54DC 01C72023		sw		$t2,[$sp]	; save in case of error
FFFC54E0 138010EF		call	QTSTG		; is next item a string?
FFFC54E4 00000C63		bra		IP2			; nope - this branch must take only 1 word
FFFC54E8 00106913		ldi		a0,#1		; allocate var
FFFC54EC 12D000EF		call	TSTV		; yes, but is it followed by a variable?
FFFC54F0 0A090E63		beq    a0,r0,IP4   ; if not, brnch
FFFC54F4 00096F33		mov		$t4,a0		; put away the variable's address
FFFC54F8 04000063		bra		IP3			; if so, input to variable
                        	IP2:
FFFC54FC 01C72223		sw		$t2,4[$sp]	; save off in stack var for 'PRTSTG'
FFFC5500 00106913		ldi		a0,#1
FFFC5504 115000EF		call	TSTV		; must be a variable now
FFFC5508 00091A63		bne		a0,r0,IP7
FFFC550C FFFC7937		ldi		a0,#msgInputVar
FFFC5510 CE490913
FFFC5514 01470713		add		$sp,$sp,#20	; cleanup stack
FFFC5518 560000E3		bra		ERROR		; "What?" it isn't?
                        	IP7:
FFFC551C 00096F33		mov		$t4,a0		; put away the variable's address
FFFC5520 000E4283		lbu		r5,[$t2]		; get ready for 'PRTSTG' by null terminating
FFFC5524 000E0023		sb		x0,[$t2]
FFFC5528 000069B3		mov		a1,x0
FFFC552C 00472903		lw		a0,4[$sp]	; get back text pointer
FFFC5530 080010EF		call	PRTSTG		; print string as prompt
FFFC5534 005E0023		sb		r5,[$t2]		; un-null terminate
                        	IP3
FFFC5538 01C72223		sw		$t2,4[$sp]	; save in case of error
FFFC553C 00030637		lw		a0,CURRNT
FFFC5540 01860613
FFFC5544 00060633
FFFC5548 00062903
FFFC554C 01272423		sw		a0,8[$sp]	; also save 'CURRNT'
FFFC5550 FFF06913		ldi		a0,#-1
FFFC5554 00030637		sw		a0,CURRNT	; flag that we are in INPUT
FFFC5558 01860613
FFFC555C 00060633
FFFC5560 01262023
FFFC5564 00030637		sw		$sp,STKINP	; save the stack pointer too
FFFC5568 09860613
FFFC556C 00060633
FFFC5570 00E62023
FFFC5574 01E72623		sw		$t4,12[$sp]	; save the variable address
FFFC5578 03A06913		ldi		a0,#':'		; print a colon first
FFFC557C 559000EF		call	GETLN		; then get an input line
FFFC5580 00030E37		ldi		$t2,#BUFFER	; point to the buffer
FFFC5584 01CE0E13
FFFC5588 450000EF		call	OREXPR		; evaluate the input
FFFC558C 00C72F03		lw		$t4,12[$sp]	; restore the variable address
FFFC5590 012F2023		sw		a0,[$t4]	; save value in variable
FFFC5594 00872903		lw		a0,8[$sp]	; restore old 'CURRNT'
FFFC5598 00030637		sw		a0,CURRNT
FFFC559C 01860613
FFFC55A0 00060633
FFFC55A4 01262023
FFFC55A8 00472E03		lw		$t2,4[$sp]	; and the old text pointer
                        	IP4:
FFFC55AC 238010EF		call	TSTC
FFFC55B0 0000002C		dw		','
FFFC55B4 00000463		bra		IP5
FFFC55B8 F20002E3		bra		IP6			; yes, more items
                        	IP5:
FFFC55BC 01072283		lw		r5,16[$sp]
FFFC55C0 01470713		add		$sp,$sp,#20	; cleanup stack
FFFC55C4 C35FF06F	 	jmp		FINISH
                        	
                        	
                        	DEFLT:
FFFC55C8 000E4903	  lbu    	a0,[$t2]
FFFC55CC 00D06D93	  ldi			$t1,#CR
FFFC55D0 C3B904E3		beq	    a0,$t1,FINISH	    ; empty line is OK else it is 'LET'
                        	
                        	
                        	;******************************************************************
                        	; 'LET' is followed by a list of items separated by commas.
                        	; Each item consists of a variable, an equals sign, and an
                        	; expression.  The interpreter evaluates the expression and sets
                        	; the variable to that value.  The interpreter will also handle
                        	; 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                        	;******************************************************************
                        	;
                        	LET:
FFFC55D4 3B1000EF	  call	SETVAL		; do the assignment
FFFC55D8 20C010EF		call	TSTC		; check for more 'LET' items
FFFC55DC 0000002C		dw		','
FFFC55E0 C19FF06F		jmp		FINISH
FFFC55E4 FE0008E3		bra	    LET
                        	LT1:
FFFC55E8 C11FF06F	  jmp	    FINISH		; until we are finished.
                        	
                        	
                        	;******************************************************************
                        	; *** LOAD *** & SAVE ***
                        	;
                        	; These two commands transfer a program to/from an auxiliary
                        	; device such as a cassette, another computer, etc.  The program
                        	; is converted to an easily-stored format: each line starts with
                        	; a colon, the line no. as 4 hex digits, and the rest of the line.
                        	; At the end, a line starting with an '@' sign is sent.  This
                        	; format can be read back with a minimum of processing time by
                        	; the RTF65002
                        	;******************************************************************
                        	;
                        	LOAD
FFFC55EC 00032E37		ldi		$t2,#TXTBGN	; set pointer to start of prog. area
FFFC55F0 800E0E13
FFFC55F4 00D06913		ldi		a0,#CR		; For a CP/M host, tell it we're ready...
FFFC55F8 C18FF0EF		call	GOAUXO		; by sending a CR to finish PIP command.
                        	LOD1:
FFFC55FC C1CFF0EF		call	GOAUXI		; look for start of line
FFFC5600 FF205EE3		ble		a0,r0,LOD1
FFFC5604 04006D93		ldi		$t1,#'@'
FFFC5608 03B90E63		beq		a0,$t1,LODEND	; end of program?
FFFC560C 01A06D93		ldi		$t1,#$1A
FFFC5610 03B90A63		beq		a0,$t1,LODEND	; or EOF marker
FFFC5614 03A06D93		ldi		$t1,#':'
FFFC5618 FFB912E3		bne		a0,$t1,LOD1	; if not, is it start of line? if not, wait for it
FFFC561C 03C000EF		call	GCHAR		; get line number
FFFC5620 012E2023		sw		a0,[$t2]		; store it
FFFC5624 004E0E13		add		$t2,$t2,#4
                        	LOD2:
FFFC5628 BF0FF0EF		call	GOAUXI		; get another text char.
FFFC562C FF205EE3		ble		a0,r0,LOD2
FFFC5630 012E0023		sb		a0,[$t2]		; store it
FFFC5634 001E0E13		add		$t2,$t2,#1
FFFC5638 00D06D93		ldi		$t1,#CR
FFFC563C FFB916E3		bne		a0,$t1,LOD2		; is it the end of the line? if not, go back for more
FFFC5640 FA000EE3		bra		LOD1		; if so, start a new line
                        	LODEND:
FFFC5644 00030637		sw		$t2,TXTUNF	; set end-of program pointer
FFFC5648 00460613
FFFC564C 00060633
FFFC5650 01C62023
FFFC5654 CD0FF06F		jmp		WSTART		; back to direct mode
                        	
                        	
                        	; get character from input (32 bit value)
                        	GCHAR:
FFFC5658 FF470713		sub		$sp,$sp,#12
FFFC565C 00572023		sw		r5,[$sp]
FFFC5660 00672223		sw		r6,4[$sp]
FFFC5664 00172423		sw		$ra,8[$sp]
FFFC5668 00806313		ldi		r6,#8       ; repeat ten times
FFFC566C 00006293		ldi		r5,#0
                        	GCHAR1:
FFFC5670 BA8FF0EF		call	GOAUXI		; get a char
FFFC5674 FF205EE3		ble		a0,r0,GCHAR1
FFFC5678 02C000EF		call	asciiToHex
FFFC567C 00429293		sll		r5,r5,#4
FFFC5680 0122E2B3		or		r5,r5,a0
FFFC5684 FFF30313		sub		r6,r6,#1
FFFC5688 FE6064E3		bgtu	r6,r0,GCHAR1
FFFC568C 0002E933		mov		a0,r5
FFFC5690 00072283		lw		r5,[$sp]
FFFC5694 00472303		lw		r6,4[$sp]
FFFC5698 00872083		lw		$ra,8[$sp]
FFFC569C 00C70713		add		$sp,$sp,#12
FFFC56A0 00008067		ret
                        	
                        	; convert an ascii char to hex code
                        	; input
                        	;	a0 = char to convert
                        	
                        	asciiToHex:
FFFC56A4 03906D93		ldi		$t1,#'9'
FFFC56A8 012DF463		bleu	a0,$t1,a2h1; less than '9'
FFFC56AC FF990913		sub		a0,a0,#7	; shift 'A' to '9'+1
                        	a2h1:
FFFC56B0 FD090913		sub		a0,a0,#'0'
FFFC56B4 00F97913		and		a0,a0,#15	; make sure a nybble
FFFC56B8 00008067		ret
                        	
                        	GetFilename:
FFFC56BC FFC70713		sub		$sp,$sp,#4
FFFC56C0 00172023		sw		$ra,[$sp]
FFFC56C4 120010EF		call	TSTC
FFFC56C8 00000022		dw		'"'
FFFC56CC 06000863		bra		gfn1
FFFC56D0 000061B3		mov		r3,r0
                        	gfn2:
FFFC56D4 000E4903		lbu		a0,[$t2]		; get text character
FFFC56D8 001E0E13		add		$t2,$t2,#1
FFFC56DC 02206D93		ldi		$t1,#'"'
FFFC56E0 03B90863		beq		a0,$t1,gfn3
FFFC56E4 02090663		beq		a0,r0,gfn3
FFFC56E8 0003F637		sb		a0,FILENAME[r3]
FFFC56EC 6C060613
FFFC56F0 00360633
FFFC56F4 01260023
FFFC56F8 00118193		add		r3,r3,#1
FFFC56FC 04006D93		ldi		$t1,#64
FFFC5700 FDB1EAE3		bltu	r3,$t1,gfn2
FFFC5704 00072083		lw		$ra,[$sp]
FFFC5708 00470713		add		$sp,$sp,#4
FFFC570C 00008067		ret
                        	gfn3:
FFFC5710 02006913		ldi		a0,#' '
FFFC5714 0003F637		sb		a0,FILENAME[r3]
FFFC5718 6C060613
FFFC571C 00360633
FFFC5720 01260023
FFFC5724 00118193		add		r3,r3,#1
FFFC5728 04006D93		ldi		$t1,#64
FFFC572C FFB1E2E3		bltu	r3,$t1,gfn3
FFFC5730 00072083		lw		$ra,[$sp]
FFFC5734 00470713		add		$sp,$sp,#4
FFFC5738 00008067		ret
                        	gfn1:
FFFC573C BE8FF06F		jmp		WSTART
                        	
                        	LOAD3:
FFFC5740 F7DFF0EF		call	GetFilename
FFFC5744 00000637		call	AUXIN_INIT
FFFC5748 3BA600E7
FFFC574C EA1FF06F		jmp		LOAD
                        	
                        	;	call		OREXPR		;evaluate the following expression
                        	;	ld		a0,#5000
FFFC5750 000019B7		ldi		a1,#$E00
FFFC5754 E0098993
FFFC5758 00000637		call	SDReadSector
FFFC575C 3BB600E7
FFFC5760 00190913		add		a0,a0,#1
FFFC5764 000329B7		ldi		a1,#TXTBGN
FFFC5768 80098993
                        	LOAD4:
FFFC576C FFC70713		sub		$sp,$sp,#4
FFFC5770 01272023		sw		a0,[$sp]
FFFC5774 00000637		call	SDReadSector
FFFC5778 3BB600E7
FFFC577C 20098993		add		a1,a1,#512
FFFC5780 00072903		lw		a0,[$sp]
FFFC5784 00470713		add		$sp,$sp,#4
FFFC5788 00190913		add		a0,a0,#1
FFFC578C 00032237		ldi		r4,#TXTBGN
FFFC5790 80020213
FFFC5794 00010637		add		r4,r4,#65536
FFFC5798 00060613
FFFC579C 00460233
FFFC57A0 FC49C6E3		blt		a1,r4,LOAD4
                        	LOAD5:
FFFC57A4 B8000063		bra		WSTART
                        	
                        	
                        	SAVE3:
FFFC57A8 F15FF0EF		call	GetFilename
FFFC57AC 00000637		call	AUXOUT_INIT
FFFC57B0 3BE600E7
FFFC57B4 0600006F		jmp		SAVE
                        	
FFFC57B8 220000EF		call	OREXPR		;evaluate the following expression
                        	;	lda		#5000		; starting sector
FFFC57BC 000019B7		ldi		a1,#$E00	; starting address to write
FFFC57C0 E0098993
FFFC57C4 00000637		call	SDWriteSector
FFFC57C8 3C0600E7
FFFC57CC 00190913		add		a0,a0,#1
FFFC57D0 000329B7		ldi		a1,#TXTBGN
FFFC57D4 80098993
                        	SAVE4:
FFFC57D8 FFC70713		sub		$sp,$sp,#4
FFFC57DC 01272023		sw		a0,[$sp]
FFFC57E0 00000637		call	SDWriteSector
FFFC57E4 3C0600E7
FFFC57E8 20098993		add		a1,a1,#512
FFFC57EC 00072903		lw		a0,[$sp]
FFFC57F0 00470713		add		$sp,$sp,#4
FFFC57F4 00190913		add		a0,a0,#1
FFFC57F8 00032237		ldi		r4,#TXTBGN
FFFC57FC 80020213
FFFC5800 00010637		add		r4,r4,#65536
FFFC5804 00060613
FFFC5808 00460233
FFFC580C FC49C6E3		blt		a1,r4,SAVE4
FFFC5810 B0000A63		bra		WSTART
                        	
                        	SAVE:
FFFC5814 00032E37		ldi		$t2,#TXTBGN	;set pointer to start of prog. area
FFFC5818 800E0E13
FFFC581C 00030637		lw		$t3,TXTUNF	;set pointer to end of prog. area
FFFC5820 00460613
FFFC5824 00060633
FFFC5828 00062E83
                        	SAVE1:
FFFC582C 054000EF		call	AUXOCRLF    ; send out a CR & LF (CP/M likes this)
FFFC5830 03CEC863		bgt		$t2,$t3,SAVEND; are we finished?
FFFC5834 03A06913		ldi		a0,#':'		; if not, start a line
FFFC5838 9D8FF0EF		call	GOAUXO
FFFC583C 000E2903		lw		a0,[$t2]		; get line number
FFFC5840 004E0E13		add		$t2,$t2,#4
FFFC5844 060000EF		call	PWORD       ; output line number as 5-digit hex
                        	SAVE2:
FFFC5848 000E4903		lbu		a0,[$t2]		; get a text char.
FFFC584C 001E0E13		add		$t2,$t2,#1
FFFC5850 00D06D93		ldi		$t1,#CR
FFFC5854 FDB90CE3		beq		a0,$t1,SAVE1	; is it the end of the line? if so, send CR & LF and start new line
FFFC5858 9B8FF0EF		call	GOAUXO		; send it out
FFFC585C FE0006E3		bra		SAVE2		; go back for more text
                        	SAVEND:
FFFC5860 04006913		ldi		a0,#'@'		; send end-of-program indicator
FFFC5864 9ACFF0EF		call	GOAUXO
FFFC5868 018000EF		call	AUXOCRLF    ; followed by a CR & LF
FFFC586C 01A06913		ldi		a0,#$1A		; and a control-Z to end the CP/M file
FFFC5870 9A0FF0EF		call	GOAUXO
FFFC5874 00000637		call	AUXOUT_FLUSH
FFFC5878 3C7600E7
FFFC587C AA000463		bra		WSTART		; then go do a warm start
                        	
                        	; output a CR LF sequence to auxillary output
                        	; Registers Affected
                        	;   r3 = LF
                        	AUXOCRLF:
FFFC5880 FFC70713		sub		$sp,$sp,#4
FFFC5884 00172023		sw		$ra,[$sp]
FFFC5888 00D06913	  ldi		a0,#CR
FFFC588C 984FF0EF	  call	GOAUXO
FFFC5890 00A06913	  ldi		a0,#LINEFD
FFFC5894 97CFF0EF	  call	GOAUXO
FFFC5898 00072083	  lw		$ra,[$sp]
FFFC589C 00470713	  add		$sp,$sp,#4
FFFC58A0 00008067	  ret
                        	
                        	
                        	; output a word in hex format
                        	; tricky because of the need to reverse the order of the chars
                        	PWORD:
FFFC58A4 FF870713		sub		$sp,$sp,#8
FFFC58A8 00572023		sw		r5,[$sp]
FFFC58AC 00172223		sw		$ra,4[$sp]
FFFC58B0 000302B7		ldi		r5,#NUMWKA+14
FFFC58B4 0A228293
FFFC58B8 00096233		mov		r4,a0		; r4 = value
                        	pword1:
FFFC58BC 00026933	  mov   a0,r4	    ; a0 = value
FFFC58C0 00425213	  srl		r4,r4,#4	; shift over to next nybble
FFFC58C4 040000EF	  call	toAsciiHex  ; convert LS nybble to ascii hex
FFFC58C8 01228023	  sb    a0,[r5]		; save in work area
FFFC58CC FFF28293	  sub		r5,r5,#1
FFFC58D0 00030DB7	  ldi		$t1,#NUMWKA
FFFC58D4 094D8D93
FFFC58D8 FFB2D2E3		bge		r5,$t1,pword1
                        	pword2:
FFFC58DC 00128293	  add		r5,r5,#1
FFFC58E0 0002C903	  lbu   a0,[r5]     ; get char to output
FFFC58E4 92CFF0EF		call	GOAUXO		; send it
FFFC58E8 00030DB7		ldi		$t1,#NUMWKA+14
FFFC58EC 0A2D8D93
FFFC58F0 FFB2C6E3		blt		r5,$t1,pword2
FFFC58F4 00072283		lw		r5,[$sp]
FFFC58F8 00472083		lw		$ra,4[$sp]
FFFC58FC 00870713		add		$sp,$sp,#8
FFFC5900 00008067		ret
                        	
                        	; convert nybble in a1 to ascii hex chaa1
                        	; a1 = character to convert
                        	
                        	toAsciiHex:
FFFC5904 00F97913		and		a0,a0,#15	; make sure it's a nybble
FFFC5908 00A06D93		ldi		$t1,#10
FFFC590C 01B94463		blt		a0,$t1,tah1	; > 10 ?
FFFC5910 00790913		add		a0,a0,#7	; bump it up to the letter 'A'
                        	tah1:
FFFC5914 03090913		add		a0,a0,#'0'	; bump up to ascii '0'
FFFC5918 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	; *** POKE ***
                        	;
                        	; 'POKE expr1,expa1' stores the byte from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEW expr1,expa1' stores the word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEH expr1,expa1' stores the half-word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	;******************************************************************
                        	;
                        	POKE:
FFFC591C 0BC000EF		call	OREXPR		; get the memory address
FFFC5920 6C5000EF		call	TSTC		; it must be followed by a comma
FFFC5924 0000002C		dw		','
FFFC5928 06000C63		bra		PKER
FFFC592C FFC70713		sub		$sp,$sp,#4
FFFC5930 01272023		sw		a0,[$sp]	; save the address
FFFC5934 0A4000EF		call	OREXPR		; get the byte to be POKE'd
FFFC5938 00072983		lw		a1,[$sp]	; get the address back
FFFC593C 00470713		add		$sp,$sp,#4
FFFC5940 01298023		sb		a0,[a1]		; store the byte in memory
FFFC5944 8B5FF06F		jmp		FINISH
                        	
                        	POKEW:
FFFC5948 090000EF		call	OREXPR		; get the memory address
FFFC594C 699000EF		call	TSTC		; it must be followed by a comma
FFFC5950 0000002C		dw		','
FFFC5954 04000663		bra		PKER
FFFC5958 FFC70713		sub		$sp,$sp,#4
FFFC595C 01272023		sw		a0,[$sp]	; save the address
FFFC5960 078000EF		call	OREXPR		; get the byte to be POKE'd
FFFC5964 00072983		lw		a1,[$sp]	; get the address back
FFFC5968 00470713		add		$sp,$sp,#4
FFFC596C 0129A023		sw		a0,[a1]		; store the byte in memory
FFFC5970 889FF06F		jmp		FINISH
                        	
                        	POKEH:
FFFC5974 064000EF		call	OREXPR		; get the memory address
FFFC5978 66D000EF		call	TSTC		; it must be followed by a comma
FFFC597C 0000002C		dw		','
FFFC5980 02000063		bra		PKER
FFFC5984 FFC70713		sub		$sp,$sp,#4
FFFC5988 01272023		sw		a0,[$sp]	; save the address
FFFC598C 04C000EF		call	OREXPR		; get the byte to be POKE'd
FFFC5990 00072983		lw		a1,[$sp]	; get the address back
FFFC5994 00470713		add		$sp,$sp,#4
FFFC5998 01299023		sh		a0,[a1]		; store the byte in memory
FFFC599C 85DFF06F		jmp		FINISH
                        	
                        	PKER:
FFFC59A0 FFFC7937		ldi		a0,#msgComma
FFFC59A4 C8290913
FFFC59A8 0D10006F		jmp		ERROR		; if no comma, say "What?"
                        	
                        	;******************************************************************
                        	; 'SYSX expr' jumps to the machine language subroutine whose
                        	; starting address is specified by 'expr'.  The subroutine can use
                        	; all registers but must leave the stack the way it found it.
                        	; The subroutine returns to the interpreter by executing an RTS.
                        	;******************************************************************
                        	
                        	SYSX:
FFFC59AC 02C000EF		call	OREXPR		; get the subroutine's address
FFFC59B0 00081863		bne		v0,r0,sysx1; make sure we got a valid address
FFFC59B4 FFFC7937		ldi		a0,#msgSYSBad
FFFC59B8 CD390913
FFFC59BC 0BD0006F		jmp		ERROR
                        	sysx1:
FFFC59C0 FFC70713		sub		$sp,$sp,#4
FFFC59C4 01C72023		stt		$t2,[$sp]	; save the text pointer
FFFC59C8 000800E7		call	[v0]			; jump to the subroutine
FFFC59CC 00072E03		ldt		$t2,[$sp]	; restore the text pointer
FFFC59D0 00470713		add		$sp,$sp,#4
FFFC59D4 825FF06F		jmp		FINISH
                        	
                        	;******************************************************************
                        	; *** EXPR ***
                        	;
                        	; 'EXPR' evaluates arithmetical or logical expressions.
                        	; <OREXPR>::= <ANDEXPR> OR <ANDEXPR> ...
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	; <EXPR>::=<ADDEXPR>
                        	;	   <ADDEXPR><rel.op.><ADDEXPR>
                        	; where <rel.op.> is one of the operators in TAB8 and the result
                        	; of these operations is 1 if true and 0 if false.
                        	; <ADDEXPR>::=(+ or -)<MULEXPR>(+ or -)<MULEXPR>(...
                        	; where () are optional and (... are optional repeats.
                        	; <MULEXPR>::=<FUNCEXPR>( <* or /><FUNCEXPR> )(...
                        	; <FUNCEXPR>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                        	; as an index, functions can have an <EXPR> as arguments, and
                        	; <FUNCEXPR> can be an <EXPR> in parenthesis.
                        	;
                        	
                        	; <OREXPR>::=<ANDEXPR> OR <ANDEXPR> ...
                        	;
                        	OREXPR:
FFFC59D8 FF470713		sub		$sp,$sp,#12
FFFC59DC 00172023		sw		$ra,[$sp]
FFFC59E0 00372223		sw		r3,4[$sp]
FFFC59E4 00472423		sw		r4,8[$sp]
FFFC59E8 058000EF		call	ANDEXPR		; get first <ANDEXPR>
                        	XP_OR1:
FFFC59EC FF870713		sub		$sp,$sp,#8
FFFC59F0 01072023		sw		$v0,[$sp]		; save <ANDEXPR> value
FFFC59F4 01172223		sw		$v1,4[$sp]	; save type
FFFC59F8 FFFC5EB7		ldi		$t3,#TAB10	; look up a logical operator
FFFC59FC DE6E8E93
FFFC5A00 FFFC5F37		ldi		$t4,#TAB10_1
FFFC5A04 E56F0F13
FFFC5A08 C68FF06F		jmp		EXEC		; go do it
                        	XP_OR:
FFFC5A0C 034000EF	  call	ANDEXPR
FFFC5A10 00072903	  lw		$a0,[$sp]
FFFC5A14 00870713	  add		$sp,$sp,#8
FFFC5A18 01286833	  or    v0,v0,a0
FFFC5A1C FC0008E3	  bra   XP_OR1
                        	XP_ORX:
FFFC5A20 00072803	  lw		$v0,[$sp]
FFFC5A24 00472883	  lw		$v1,4[$sp]
FFFC5A28 00870713	  add		$sp,$sp,#8
FFFC5A2C 00072083		lw		$ra,[$sp]
FFFC5A30 00472183		lw		r3,4[$sp]
FFFC5A34 00872203		lw		r4,8[$sp]
FFFC5A38 00C70713		add		$sp,$sp,#12
FFFC5A3C 00008067	  ret
                        	
                        	
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	;
                        	ANDEXPR:
FFFC5A40 FFC70713		sub		$sp,$sp,#4
FFFC5A44 00172023		sw		$ra,[$sp]
FFFC5A48 0E8000EF		call	EXPR		; get first <EXPR>
                        	XP_AND1:
FFFC5A4C FF870713		sub		$sp,$sp,#8
FFFC5A50 01072023		sw		$v0,[$sp]		; save <EXPR> value
FFFC5A54 01172223		sw		$v1,4[$sp]	; save type
FFFC5A58 FFFC5EB7		ldi		$t3,#TAB9		; look up a logical operator
FFFC5A5C DE2E8E93
FFFC5A60 FFFC5F37		ldi		$t4,#TAB9_1
FFFC5A64 E52F0F13
FFFC5A68 C08FF06F		jmp		EXEC		; go do it
                        	XP_AND:
FFFC5A6C 0C4000EF	  call	EXPR
FFFC5A70 00072903	  lw		$a0,[$sp]
FFFC5A74 00870713	  add		$sp,$sp,#8
FFFC5A78 01287833	  and   v0,v0,a0
FFFC5A7C FC0008E3	  bra   XP_AND1
                        	XP_ANDX:
FFFC5A80 00072803	  lw		$v0,[$sp]
FFFC5A84 00472883	  lw		$v1,4[$sp]
FFFC5A88 00870713	  add		$sp,$sp,#8
FFFC5A8C 00072083		lw		$ra,[$sp]
FFFC5A90 00470713		add		$sp,$sp,#4
FFFC5A94 00008067	  ret
                        	
                        	
                        	; Determine if the character is a digit
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if digit, otherwise 0
                        	;
                        	isDigit:
FFFC5A98 03006D93		ldi		$t1,#'0'
FFFC5A9C 01B94A63		blt		a0,$t1,isDigitFalse
FFFC5AA0 03906D93		ldi		$t1,#'9'
FFFC5AA4 012DC663		bgt		a0,$t1,isDigitFalse
FFFC5AA8 00106813		ldi		v0,#1
FFFC5AAC 00008067	  ret
                        	isDigitFalse:
FFFC5AB0 00006833	  mov		v0,r0
FFFC5AB4 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphabetic
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlpha:
FFFC5AB8 04106D93		ldi		$t1,#'A'
FFFC5ABC 03B94263		blt		a0,$t1,isAlphaFalse
FFFC5AC0 05A06D93		ldi		$t1,#'Z'
FFFC5AC4 012DDA63		ble		a0,$t1,isAlphaTrue
FFFC5AC8 06106D93		ldi		$t1,#'a'
FFFC5ACC 01B94A63		blt		a0,$t1,isAlphaFalse
FFFC5AD0 07A06D93		ldi		$t1,#'z'
FFFC5AD4 012DC663		bgt		a0,$t1,isAlphaFalse
                        	isAlphaTrue:
FFFC5AD8 00106813	  ldi		v0,#1
FFFC5ADC 00008067	  ret
                        	isAlphaFalse:
FFFC5AE0 00006833	  mov		v0,r0
FFFC5AE4 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphanumeric
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlnum:
FFFC5AE8 FFC70713		sub		$sp,$sp,#4
FFFC5AEC 00172023		sw		$ra,[$sp]
FFFC5AF0 FA9FF0EF	  call	isDigit
FFFC5AF4 00081463		bne		v0,r0,isDigitx	; if it is a digit
FFFC5AF8 FC1FF0EF	  call  isAlpha
                        	isDigitx:
FFFC5AFC 00072083		lw		$ra,[$sp]
FFFC5B00 00470713		add		$sp,$sp,#4
FFFC5B04 00008067	  ret
                        	
                        	FORCEFIT:
FFFC5B08 03198263		beq		a1,v1,.0001				; types match
FFFC5B0C 00006D13		ldi		$t0,#0
FFFC5B10 01A98663		beq		a1,$t0,.intAnd
                        	;	itof	$f1,$v0
FFFC5B14 00106913		ldi		a0,#1
FFFC5B18 00008067		ret
                        	.intAnd:
FFFC5B1C 00106D13		ldi		$t0,#1
FFFC5B20 01A89663		bne		$v1,$t0,.0001
                        	;	itof	$f2,$a1
FFFC5B24 00106993		ldi		$a1,#1
FFFC5B28 00008067		ret
                        	.0001:
FFFC5B2C 00008067		ret
                        	
                        	EXPR:
FFFC5B30 FFC70713		sub		$sp,$sp,#4
FFFC5B34 00172023		sw		$ra,[$sp]
FFFC5B38 11C000EF		call	ADDEXPR
FFFC5B3C FF870713		sub		$sp,$sp,#8				; save <ADDEXPR> value
FFFC5B40 01072023		sw		v0,[$sp]
FFFC5B44 01172223		sw		v1,4[$sp]					; save type
FFFC5B48 FFFC5EB7		ldi		$t3,#TAB8		; look up a relational operator
FFFC5B4C DD8E8E93
FFFC5B50 FFFC5F37		ldi		$t4,#TAB8_1
FFFC5B54 E44F0F13
FFFC5B58 B18FF06F		jmp		EXEC		; go do it
                        	XP11:
FFFC5B5C 00072903		lw		a0,[$sp]
FFFC5B60 00472983		lw		a1,4[$sp]
FFFC5B64 00870713		add		$sp,$sp,#8
FFFC5B68 0C4000EF		call	XP18	; is it ">="?
FFFC5B6C 09095A63		bge		a0,v0,XPRT1	; no, return v0=1
FFFC5B70 06000E63		bra		XPRT0	; else return v0=0
                        	XP12:
FFFC5B74 00072903		lw		a0,[$sp]
FFFC5B78 00472983		lw		a1,4[$sp]
FFFC5B7C 00870713		add		$sp,$sp,#8
FFFC5B80 0AC000EF		call	XP18	; is it "<>"?
FFFC5B84 07091E63		bne		a0,v0,XPRT1	; no, return a1=1
FFFC5B88 06000263		bra		XPRT0	; else return a1=0
                        	XP13:
FFFC5B8C 00072903		lw		a0,[$sp]
FFFC5B90 00472983		lw		a1,4[$sp]
FFFC5B94 00870713		add		$sp,$sp,#8
FFFC5B98 094000EF		call	XP18	; is it ">"?
FFFC5B9C 07284263		bgt		a0,v0,XPRT1	; no, return a1=1
FFFC5BA0 04000663		bra		XPRT0	; else return a1=0
                        	XP14:
FFFC5BA4 00072903		lw		a0,[$sp]
FFFC5BA8 00472983		lw		a1,4[$sp]
FFFC5BAC 00870713		add		$sp,$sp,#8
FFFC5BB0 07C000EF		call	XP18	; is it "<="?
FFFC5BB4 05285663		ble		a0,v0,XPRT1	; no, return a1=1
FFFC5BB8 02000A63		bra		XPRT0	; else return a1=0
                        	XP15:
FFFC5BBC 00072903		lw		a0,[$sp]
FFFC5BC0 00472983		lw		a1,4[$sp]
FFFC5BC4 00870713		add		$sp,$sp,#8
FFFC5BC8 064000EF		call	XP18	; is it "="?
FFFC5BCC 03090A63		beq		a0,v0,XPRT1	; if not, return a1=1
FFFC5BD0 00000E63		bra		XPRT0	; else return a1=0
                        	XP16:
FFFC5BD4 00072903		lw		a0,[$sp]
FFFC5BD8 00472983		lw		a1,4[$sp]
FFFC5BDC 00870713		add		$sp,$sp,#8
FFFC5BE0 04C000EF		call	XP18	; is it "<"?
FFFC5BE4 01094E63		blt		a0,v0,XPRT1	; if not, return a1=1
FFFC5BE8 00000263		bra		XPRT0	; else return a1=0
                        	XPRT0:
FFFC5BEC 00006833		mov		v0,x0   ; return a0=0 (false)
FFFC5BF0 000068B3		mov		v1,x0		; type = int
FFFC5BF4 00072083		lw		$ra,[$sp]
FFFC5BF8 00470713		add		$sp,$sp,#4
FFFC5BFC 00008067		ret
                        	XPRT1:
FFFC5C00 00106813		ldi		v0,#1	; return a0=1 (true)
FFFC5C04 00006893		ldi		v1,#0	; type = int
FFFC5C08 00072083		lw		$ra,[$sp]
FFFC5C0C 00470713		add		$sp,$sp,#4
FFFC5C10 00008067		ret
                        	
                        	XP17:				; it's not a rel. operator
FFFC5C14 00072803		lw		v0,[$sp]; return a1=<ADDEXPR>
FFFC5C18 00472883		lw		v1,4[$sp]
FFFC5C1C 00870713		add		$sp,$sp,#8
FFFC5C20 00072083		lw		$ra,[$sp]
FFFC5C24 00470713		add		$sp,$sp,#4
FFFC5C28 00008067		ret
                        	
                        	XP18:
FFFC5C2C FF470713		sub		$sp,$sp,#12
FFFC5C30 00172023		sw		$ra,[$sp]
FFFC5C34 01072223		sw		v0,4[$sp]
FFFC5C38 01172423		sw		v1,8[$sp]
FFFC5C3C 018000EF		call	ADDEXPR		; do a second <ADDEXPR>
FFFC5C40 00472903		lw		a0,4[$sp]
FFFC5C44 00872983		lw		a1,8[$sp]
FFFC5C48 00072083		lw		$ra,[$sp]
FFFC5C4C 00C70713		add		$sp,$sp,#12
FFFC5C50 00008067		ret
                        	
                        	; <ADDEXPR>::=(+ or -)<MULEXPR>(+ or -)<MULEXPR>(...
                        	//message "ADDEXPR"
                        	ADDEXPR:
FFFC5C54 FFC70713		sub		$sp,$sp,#4
FFFC5C58 00172023		sw		$ra,[$sp]
FFFC5C5C 389000EF		call	TSTC		; negative sign?
FFFC5C60 0000002D		dw		'-'
FFFC5C64 00000C63		bra		XP21
FFFC5C68 00006833		mov		v0,r0		; yes, fake '0-'
FFFC5C6C FF870713		sub		$sp,$sp,#8
FFFC5C70 01072023		sw		v0,[$sp]
FFFC5C74 01172223		sw		v1,4[$sp]
FFFC5C78 04000863		bra		XP26
                        	XP21:
FFFC5C7C 369000EF		call	TSTC		; positive sign? ignore it
FFFC5C80 0000002B		dw		'+'
FFFC5C84 00000263		bra		XP22
                        	XP22:
FFFC5C88 064000EF		call	MULEXPR		; first <MULEXPR>
                        	XP23:
FFFC5C8C FF870713		sub		$sp,$sp,#8; yes, save the value
FFFC5C90 01072023		sw		v0,[$sp]
FFFC5C94 01172223		sw		v1,4[$sp]	; and type
FFFC5C98 34D000EF		call	TSTC		; add?
FFFC5C9C 0000002B		dw		'+'
FFFC5CA0 00000E63		bra		XP25
FFFC5CA4 048000EF		call	MULEXPR		; get the second <MULEXPR>
                        	XP24:
FFFC5CA8 00072903		lw		a0,[$sp]
FFFC5CAC 00472983		lw		a1,4[$sp]
FFFC5CB0 00870713		add		$sp,$sp,#8
FFFC5CB4 01280833		add		v0,v0,a0	; add it to the first <MULEXPR>
                        	;	BVS.L	QHOW		brnch if there's an overflow
FFFC5CB8 FC000AE3		bra		XP23		; else go back for more operations
                        	XP25:
FFFC5CBC 329000EF		call	TSTC		; subtract?
FFFC5CC0 0000002D		dw		'-'
FFFC5CC4 00000863		bra		XP45
                        	XP26:
FFFC5CC8 024000EF		call	MULEXPR		; get second <MULEXPR>
FFFC5CCC 41000833		sub		v0,r0,v0	; change its sign
FFFC5CD0 FC000CE3		bra		XP24		; and do an addition
                        	XP45:
FFFC5CD4 00072803		lw		v0,[$sp]
FFFC5CD8 00472883		lw		v1,4[$sp]
FFFC5CDC 00870713		add		$sp,$sp,#8
FFFC5CE0 00072083		lw		$ra,[$sp]
FFFC5CE4 00470713		add		$sp,$sp,#4
FFFC5CE8 00008067		ret
                        	
                        	
                        	; <MULEXPR>::=<FUNCEXPR>( <* or /><FUNCEXPR> )(...
                        	
                        	MULEXPR:
FFFC5CEC FFC70713		sub		$sp,$sp,#4
FFFC5CF0 00172023		sw		$ra,[$sp]
FFFC5CF4 094000EF		call	FUNCEXPR		; get first <FUNCEXPR>
                        	XP31:
FFFC5CF8 FF870713		sub		$sp,$sp,#8
FFFC5CFC 01072023		sw		v0,[$sp]; yes, save that first result
FFFC5D00 01172223		sw		v1,4[$sp]
FFFC5D04 2E1000EF		call	TSTC		; multiply?
FFFC5D08 0000002A		dw		'*'
FFFC5D0C 00000E63		bra		XP34
FFFC5D10 078000EF		call	FUNCEXPR		; get second <FUNCEXPR>
FFFC5D14 00072903		lw		a0,[$sp]
FFFC5D18 00472983		lw		a1,4[$sp]
FFFC5D1C 00870713		add		$sp,$sp,#8
FFFC5D20 03280833		mul		v0,v0,a0	; multiply the two
FFFC5D24 FC000AE3		bra		XP31        ; then look for more terms
                        	XP34:
FFFC5D28 2BD000EF		call	TSTC		; divide?
FFFC5D2C 0000002F		dw		'/'
FFFC5D30 00000E63		bra		XP35
FFFC5D34 054000EF		call	FUNCEXPR		; get second <FUNCEXPR>
FFFC5D38 00072903		lw		a0,[$sp]
FFFC5D3C 00472983		lw		a1,4[$sp]
FFFC5D40 00870713		add		$sp,$sp,#8
FFFC5D44 03284833		div		v0,v0,a0	; do the division
FFFC5D48 FA0008E3		bra		XP31		; go back for any more terms
                        	XP35:
FFFC5D4C 299000EF		call	TSTC
FFFC5D50 00000025		dw		'%'
FFFC5D54 00000E63		bra		XP47
FFFC5D58 030000EF		call	FUNCEXPR
FFFC5D5C 00072903		lw		a0,[$sp]
FFFC5D60 00472983		lw		a1,4[$sp]
FFFC5D64 00870713		add		$sp,$sp,#8
FFFC5D68 03286833		rem		v0,v0,a0
FFFC5D6C F80006E3		bra		XP31
                        	XP47:
FFFC5D70 00072803		lw		v0,[$sp]
FFFC5D74 00472883		lw		v1,4[$sp]
FFFC5D78 00870713		add		$sp,$sp,#8
FFFC5D7C 00072083		lw		$ra,[$sp]
FFFC5D80 00470713		add		$sp,$sp,#4
FFFC5D84 00008067		ret
                        	
                        	
                        	; Functions are called through FUNCEXPR
                        	; <FUNCEXPR>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	
                        	FUNCEXPR:
FFFC5D88 FFC70713		sub		$sp,$sp,#4
FFFC5D8C 00172023		sw		$ra,[$sp]
FFFC5D90 FFFC5EB7	  ldi		$t3,#TAB4		; find possible function
FFFC5D94 D97E8E93
FFFC5D98 FFFC5F37	  ldi		$t4,#TAB4_1
FFFC5D9C E22F0F13
FFFC5DA0 8D0FF06F		jmp		EXEC        ; branch to function which does subsequent ret for FUNCEXPR
                        	XP40:                   ; we get here if it wasn't a function
FFFC5DA4 00006933		mov		a0,x0
FFFC5DA8 070000EF		call	TSTV
FFFC5DAC 00080A63		beq   v0,x0,XP41	; not a variable
FFFC5DB0 00082803		lw		$v0,[$v0]		; if a variable, return its value in v0
FFFC5DB4 00072083		lw		$ra,[$sp]
FFFC5DB8 00470713		add		$sp,$sp,#4
FFFC5DBC 00008067		ret
                        	XP41:
FFFC5DC0 271000EF		call	TSTNUM		; or is it a number?
FFFC5DC4 00089463		bne		v1,x0,XP46	; (if not, # of digits will be zero) if so, return it in v0
FFFC5DC8 010000EF		call	PARN        ; check for (EXPR)
                        	XP46:
FFFC5DCC 00072083		lw		$ra,[$sp]
FFFC5DD0 00470713		add		$sp,$sp,#4
FFFC5DD4 00008067		ret
                        	
                        	
                        	; Check for a parenthesized expression
                        	PARN:
FFFC5DD8 FFC70713		sub		$sp,$sp,#4
FFFC5DDC 00172023		sw		$ra,[$sp]	
FFFC5DE0 205000EF		call	TSTC		; else look for ( OREXPR )
FFFC5DE4 00000028		dw		'('
FFFC5DE8 02000063		bra		XP43
FFFC5DEC BEDFF0EF		call	OREXPR
FFFC5DF0 1F5000EF		call	TSTC
FFFC5DF4 00000029		dw		')'
FFFC5DF8 00000863		bra		XP43
                        	XP42:
FFFC5DFC 00072083		lw		$ra,[$sp]
FFFC5E00 00470713		add		$sp,$sp,#4
FFFC5E04 00008067		ret
                        	XP43:
FFFC5E08 00470713		add		$sp,$sp,#4		; get rid of return address
FFFC5E0C FFFC7937		ldi		a0,#msgWhat
FFFC5E10 C0890913
FFFC5E14 4640006F		jmp		ERROR
                        	
                        	
                        	; ===== Test for a valid variable name.  Returns Z=1 if not
                        	;	found, else returns Z=0 and the address of the
                        	;	variable in a0.
                        	; Parameters
                        	;		a0 = 1 = allocate if not found
                        	; Returns
                        	;		v0 = address of variable, zero if not found
                        	
                        	TSTV:
FFFC5E18 FF870713		sub		$sp,$sp,#8
FFFC5E1C 00572023		sw		r5,[$sp]
FFFC5E20 00172223		sw		$ra,4[$sp]
FFFC5E24 000962B3		mov		r5,a0		; r5=allocate flag
FFFC5E28 27D000EF		call	IGNBLK
FFFC5E2C 000E4903		lbu		a0,[$t2]		; look at the program text
FFFC5E30 04006D93		ldi		$t1,#'@'
FFFC5E34 07B94863		blt		a0,$t1,tstv_notfound	; C=1: not a variable
FFFC5E38 05B91463		bne		a0,$t1,TV1				; brnch if not "@" array
FFFC5E3C 001E0E13		add		$t2,$t2,#1	; If it is, it should be
FFFC5E40 F99FF0EF		call	PARN		; followed by (EXPR) as its index.
                        	;	BCS.L	QHOW		say "How?" if index is too big
FFFC5E44 00000263		bra		TV3
                        	TV3:
FFFC5E48 FFC70713		sub		$sp,$sp,#4	; save the index
FFFC5E4C 01072023		sw		v0,[$sp]
FFFC5E50 300000EF		call	SIZEX		; get amount of free memory
FFFC5E54 00072983		lw		a1,[$sp]
FFFC5E58 00470713		add		$sp,$sp,#4	; get back the index
FFFC5E5C 0109C663		blt		a1,v0,TV2		; see if there's enough memory
FFFC5E60 00870713		add		$sp,$sp,#8
FFFC5E64 4000006F		jmp   QSORRY		; if not, say "Sorry"
                        	TV2:
FFFC5E68 00030637		lw		a0,VARBGN	; put address of array element...
FFFC5E6C 00860613
FFFC5E70 00060633
FFFC5E74 00062903
FFFC5E78 41390833		sub   v0,a0,a1    ; into a0 (neg. offset is used)
FFFC5E7C 00000C63		bra   TSTVRT
                        	TV1:	
FFFC5E80 038000EF	  call	getVarName      ; get variable name
FFFC5E84 00080863	  beq   v0,x0,TSTVRT    ; if not, return v0=0
FFFC5E88 00086933	  mov		a0,v0
FFFC5E8C 0002E9B3	  mov		a1,r5
FFFC5E90 0D4000EF	  call	findVar     ; find or allocate
                        	TSTVRT:
FFFC5E94 00072283		lw		r5,[$sp]
FFFC5E98 00472083		lw		$ra,4[$sp]
FFFC5E9C 00870713		add		$sp,$sp,#8
FFFC5EA0 00008067		ret								; v0<>0 (if found)
                        	tstv_notfound:
FFFC5EA4 00072283		lw		r5,[$sp]
FFFC5EA8 00472083		lw		$ra,4[$sp]
FFFC5EAC 00870713		add		$sp,$sp,#8
FFFC5EB0 00006833		mov		v0,x0				; v0=0 if not found
FFFC5EB4 00008067	  ret
                        	
                        	; Get a variable name. Called after blanks have been ignored.
                        	;
                        	; Returns
                        	;   v0 = 3 character variable name + type
                        	;
                        	getVarName:
FFFC5EB8 FF470713		sub		$sp,$sp,#12
FFFC5EBC 00572023		sw		r5,[$sp]
FFFC5EC0 00172223		sw		$ra,4[$sp]
FFFC5EC4 000E4903	  lbu   a0,[$t2]		; get first character
FFFC5EC8 01272423	  sw		a0,8[$sp]		; save off current name
FFFC5ECC BEDFF0EF	  call	isAlpha
FFFC5ED0 08080063	  beq   v0,r0,gvn1
FFFC5ED4 00206293	  ldi	  r5,#2       ; loop two more times
                        	
                        		; check for second/third character
                        	gvn4:
FFFC5ED8 001E0E13		add		$t2,$t2,#1
FFFC5EDC 000E4903		lbu   a0,[$t2]		; do we have another char ?
FFFC5EE0 C09FF0EF		call	isAlnum
FFFC5EE4 02080863		beq   v0,x0,gvn2	; nope
FFFC5EE8 00872903		lw		a0,8[$sp]		; get varname
FFFC5EEC 00891913		sll		a0,a0,#8
FFFC5EF0 000E4983		lbu   a1,[$t2]
FFFC5EF4 01396933		or    a0,a0,a1   	; add in new char
FFFC5EF8 01272423	  sw		a0,8[$sp]		; save off current name again
FFFC5EFC FFF28293	  sub		r5,r5,#1
FFFC5F00 FC504CE3	  bgt		r5,x0,gvn4
                        	
                        	 	; now ignore extra variable name characters
                        	gvn6:
FFFC5F04 001E0E13		add		$t2,$t2,#1
FFFC5F08 000E4903		lbu   a0,[$t2]		; do we have another char ?
FFFC5F0C BDDFF0EF	  call  isAlnum
FFFC5F10 FE081AE3	  bne   v0,x0,gvn6	; keep looping as long as we have identifier chars
                        	
                        	  ; check for a variable type
                        	gvn2:
FFFC5F14 000E4983		lbu   a1,[$t2]
FFFC5F18 02506D93		ldi		$t1,#'%'
FFFC5F1C 01B98A63		beq		a1,$t1,gvn3
FFFC5F20 02406D93		ldi		$t1,#'$'
FFFC5F24 01B98663		beq		a1,$t1,gvn3
FFFC5F28 FFFE0E13	  sub		$t2,$t2,#1
FFFC5F2C 02E06993	  ldi		$a1,#'.'		; if no variable type assume float
                        	
                        	  ; insert variable type indicator and return
                        	gvn3:
FFFC5F30 001E0E13		add		$t2,$t2,#1
FFFC5F34 00872903		lw		a0,8[$sp]		; get varname
FFFC5F38 00891913		sll		a0,a0,#8
FFFC5F3C 01396833	  or    v0,a0,a1    ; add in variable type
FFFC5F40 00072283	  lw		r5,[$sp]
FFFC5F44 00472083	  lw		$ra,4[$sp]
FFFC5F48 00C70713	  add		$sp,$sp,#12
FFFC5F4C 00008067	  ret								; return a0 = varname
                        	
                        	  ; not a variable name
                        	gvn1:
FFFC5F50 00072283		lw		r5,[$sp]
FFFC5F54 00472083	  lw		$ra,4[$sp]
FFFC5F58 00C70713		add		$sp,$sp,#12
FFFC5F5C 00006833	  mov		v0,x0       ; return v0 = 0 if not a varname
FFFC5F60 00008067	  ret
                        	
                        	
                        	; Find variable
                        	;   a0 = varname
                        	;		a1 = allocate flag
                        	; Returns
                        	;   v0 = variable address, Z =0 if found / allocated, Z=1 if not found
                        	
                        	findVar:
FFFC5F64 FF870713		sub		$sp,$sp,#8
FFFC5F68 00772023		sw		x7,[$sp]
FFFC5F6C 00372223		sw		x3,4[$sp]
FFFC5F70 00030637	  lw    x3,VARBGN
FFFC5F74 00860613
FFFC5F78 00060633
FFFC5F7C 00062183
                        	fv4:
FFFC5F80 0001A383	  lw    x7,[x3]     ; get varname / type
FFFC5F84 02038C63	  beq   x7,x0,fv3		; no more vars ?
FFFC5F88 02790E63	  beq   a0,x7,fv1		; match ?
FFFC5F8C 00818193		add		x3,x3,#8		; move to next var
FFFC5F90 00030637	  lw    x7,VAREND		; 
FFFC5F94 00C60613
FFFC5F98 00060633
FFFC5F9C 00062383
FFFC5FA0 FE71C0E3	  blt   x3,x7,fv4		; loop back to look at next var
                        	
                        	  ; variable not found
                        	  ; no more memory
FFFC5FA4 00072383	  lw		x7,[$sp]
FFFC5FA8 00472183	  lw		x3,4[$sp]
FFFC5FAC 00870713	  add		$sp,$sp,#8
FFFC5FB0 FFFC7937	  ldi		a0,#msgVarSpace
FFFC5FB4 C5690913
FFFC5FB8 2C00006F	  jmp   ERROR
                        	
                        	  ; variable not found
                        	  ; allocate new ?
                        	fv3:
FFFC5FBC 00098E63		beq		a1,x0,fv2
FFFC5FC0 0121A023	  sw    a0,[x3]     ; save varname / type
                        	  ; found variable
                        	  ; return address
                        	fv1:
FFFC5FC4 00418813	  add		v0,x3,#4
FFFC5FC8 00072383	  lw		x7,[$sp]
FFFC5FCC 00472183	  lw		x3,4[$sp]
FFFC5FD0 00870713	  add		$sp,$sp,#8
FFFC5FD4 00008067	  ret			    			; v0 = address
                        	
                        	  ; didn't find var and not allocating
                        	fv2:
FFFC5FD8 00072383	  lw		x7,[$sp]
FFFC5FDC 00472183	  lw		x3,4[$sp]
FFFC5FE0 00870713	  add		$sp,$sp,#8
FFFC5FE4 00006833		mov		v0,x0				; v0 = nullptr
FFFC5FE8 00008067	  ret
                        	
                        	; The following functions are entered via a jump instruction with
                        	; the return address already saved.
                        	
                        	; ===== The PEEK function returns the byte stored at the address
                        	;	contained in the following expression.
                        	;
                        	PEEK:
FFFC5FEC DEDFF0EF		call	PARN		; get the memory address
FFFC5FF0 00080803		lb		v0,[v0]		; get the addressed byte
FFFC5FF4 000068B3		mov		v1,x0			; type = int
FFFC5FF8 00072083		lw		$ra,[$sp]
FFFC5FFC 00470713		add		$sp,$sp,#4
FFFC6000 00008067		ret
                        	PEEKW:
FFFC6004 DD5FF0EF		call	PARN		; get the memory address
FFFC6008 00082803		lw		v0,[v0]		; get the addressed word
FFFC600C 000068B3		mov		v1,x0			; type = int
FFFC6010 00072083		lw		$ra,[$sp]
FFFC6014 00470713		add		$sp,$sp,#4
FFFC6018 00008067		ret
                        	PEEKH:
FFFC601C DBDFF0EF		call	PARN		; get the memory address
FFFC6020 00081803		lh		v0,[v0]		; get the addressed byte
FFFC6024 000068B3		mov		v1,x0			; type = int
FFFC6028 00072083		lw		$ra,[$sp]
FFFC602C 00470713		add		$sp,$sp,#4
FFFC6030 00008067		ret
                        	
                        	
                        	; user function call
                        	; call the user function with argument in a0, type in a1
                        	USRX:
FFFC6034 FFC70713		sub		$sp,$sp,#4
FFFC6038 01A72023		sw		$t0,[$sp]
FFFC603C D9DFF0EF		call	PARN		; get expression value
FFFC6040 00086933		mov		a0,v0
FFFC6044 0008E9B3		mov		a1,v1
FFFC6048 FFC70713		sub		$sp,$sp,#4	; save the text pointer
FFFC604C 01C72023		sw		$t2,[$sp]
FFFC6050 00030637		lw		$t0,usrJmp
FFFC6054 0A060613
FFFC6058 00060633
FFFC605C 00062D03
FFFC6060 000D00E7		call	[$t0]			; get usr vector, jump to the subroutine
FFFC6064 00072E03		lw		$t2,[$sp]	; restore the text pointer
FFFC6068 00470713		add		$sp,$sp,#4
FFFC606C 00072D03		lw		$t0,[$sp]
FFFC6070 00470713		add		$sp,$sp,#4
FFFC6074 00072083		lw		$ra,[$sp]
FFFC6078 00470713		add		$sp,$sp,#4
FFFC607C 00008067		ret
                        	
                        	
                        	; ===== The RND function returns a random number from 1 to
                        	;	the value of the following expression in D0.
                        	;
                        	RND:
FFFC6080 D59FF0EF		call	PARN		; get the upper limit
FFFC6084 04080063		beq		v0,r0,rnd2	; it must be positive and non-zero
FFFC6088 02084663		blt		v0,r0,rnd1
FFFC608C 000869B3		mov		a1,v0
FFFC6090 000868B3		mov		v1,v0
FFFC6094 00000637		call	gen_rand	; generate a random number
FFFC6098 40C600E7
FFFC609C 03186833		rem		v0,v0,v1
FFFC60A0 00180813		add		v0,v0,#1
FFFC60A4 000068B3		mov		v1,x0
FFFC60A8 00072083		lw		$ra,[$sp]
FFFC60AC 00470713		add		$sp,$sp,#4
FFFC60B0 00008067		ret
                        	rnd1:
FFFC60B4 FFFC7937		ldi		a0,#msgRNDBad
FFFC60B8 CC090913
FFFC60BC 00470713		add		$sp,$sp,#4
FFFC60C0 1B80006F		jmp		ERROR
                        	rnd2:
FFFC60C4 00000637		call	gen_rand	; generate a random number
FFFC60C8 40C600E7
FFFC60CC 000068B3		mov		v1,x0
FFFC60D0 00072083		lw		$ra,[$sp]
FFFC60D4 00470713		add		$sp,$sp,#4
FFFC60D8 00008067		ret
                        	
                        	; ===== The ABS function returns an absolute value in a1.
                        	;
                        	ABS:
FFFC60DC CFDFF0EF		call	PARN		; get the following expr.'s value
FFFC60E0 00084863		blt		v0,r0,ABS1
FFFC60E4 00072083		lw		$ra,[$sp]
FFFC60E8 00470713		add		$sp,$sp,#4
FFFC60EC 00008067		ret
                        	ABS1:
FFFC60F0 41000833		sub		v0,x0,v0
FFFC60F4 00072083		lw		$ra,[$sp]
FFFC60F8 00470713		add		$sp,$sp,#4
FFFC60FC 00008067		ret
                        	
                        	
                        	;==== The TICK function returns the cpu tick value in a0.
                        	;
                        	TICKX:
FFFC6100 C0001873		csrrw	v0,#$C00,x0
FFFC6104 000068B3		mov		v1,x0
FFFC6108 00072083		lw		$ra,[$sp]
FFFC610C 00470713		add		$sp,$sp,#4
FFFC6110 00008067		ret
                        	
                        	; ===== The SGN function returns the sign in a0. +1,0, or -1
                        	;
                        	SGN:
FFFC6114 CC5FF0EF		call	PARN		; get the following expr.'s value
FFFC6118 000068B3		mov		v1,x0
FFFC611C 02080463		beq		v0,r0,SGN1
FFFC6120 00084A63		blt		v0,r0,SGN2
FFFC6124 00106813		ldi		v0,#1
FFFC6128 00072083		lw		$ra,[$sp]
FFFC612C 00470713		add		$sp,$sp,#4
FFFC6130 00008067		ret
                        	SGN2:
FFFC6134 FFF06813		ldi		v0,#-1
FFFC6138 00072083		lw		$ra,[$sp]
FFFC613C 00470713		add		$sp,$sp,#4
FFFC6140 00008067		ret
                        	SGN1:
FFFC6144 00072083		lw		$ra,[$sp]
FFFC6148 00470713		add		$sp,$sp,#4
FFFC614C 00008067		ret	
                        	
                        	; ===== The SIZE function returns the size of free memory in v0.
                        	; does not consider memory used by @()
                        	;
                        	SIZEX:
FFFC6150 00030637		lw		v0,VARBGN	; get the number of free bytes...
FFFC6154 00860613
FFFC6158 00060633
FFFC615C 00062803
FFFC6160 00030637		lw		v1,TXTUNF	; between 'TXTUNF' and 'VARBGN'
FFFC6164 00460613
FFFC6168 00060633
FFFC616C 00062883
FFFC6170 41180833		sub		v0,v0,v1
FFFC6174 000068B3		mov		v1,x0			; type = int
FFFC6178 00072083		lw		$ra,[$sp]
FFFC617C 00470713		add		$sp,$sp,#4
FFFC6180 00008067		ret					; return the number in v0
                        	
                        	
                        	;******************************************************************
                        	;
                        	; *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                        	;
                        	; 'SETVAL' expects a variable, followed by an equal sign and then
                        	; an expression.  It evaluates the expression and sets the variable
                        	; to that value.
                        	;
                        	; returns
                        	; a1 = variable's address
                        	;
                        	SETVAL:
FFFC6184 FFC70713		sub		$sp,$sp,#4
FFFC6188 00172023		sw		$ra,[$sp]
FFFC618C 00106913	  ldi		a0,#1		; allocate var
FFFC6190 C89FF0EF	  call	TSTV		; variable name?
FFFC6194 00081A63	  bne		v0,x0,.sv2
FFFC6198 FFFC7937	 	ldi		a0,#msgVar
FFFC619C CAA90913
FFFC61A0 00470713		add		$sp,$sp,#4
FFFC61A4 0D40006F	 	jmp		ERROR 
                        	.sv2:
FFFC61A8 FFC70713		sub		$sp,$sp,#4
FFFC61AC 01072023		sw		v0,[$sp]	; save the variable's address
FFFC61B0 634000EF		call	TSTC			; get past the "=" sign
FFFC61B4 0000003D		dw		'='
FFFC61B8 02000663		bra		SV1
FFFC61BC 81DFF0EF		call	OREXPR		; evaluate the expression
FFFC61C0 00072983		lw		a1,[$sp]	; get back the variable's address
FFFC61C4 00470713		add		$sp,$sp,#4
FFFC61C8 0109A023		sw    v0,[a1]   ; and save value in the variable
FFFC61CC 0009E833		mov		v0,a1			; return v0 = variable address
FFFC61D0 FFC9A883		lw		v1,-4[a1]
FFFC61D4 0FF8F893		and		v1,v1,#$FF
FFFC61D8 00072083		lw		$ra,[$sp]
FFFC61DC 00470713		add		$sp,$sp,#4
FFFC61E0 00008067		ret
                        	SV1:
FFFC61E4 00470713		add		$sp,$sp,#4
FFFC61E8 0880006F	  jmp	  QWHAT		; if no "=" sign
                        	
                        	
                        	; 'FIN' checks the end of a command.  If it ended with ":",
                        	; execution continues.	If it ended with a CR, it finds the
                        	; the next line and continues from there.
                        	;
                        	FIN:
FFFC61EC FFC70713		sub		$sp,$sp,#4
FFFC61F0 00172023		sw		$ra,[$sp]
FFFC61F4 5F0000EF		call	TSTC		; *** FIN ***
FFFC61F8 0000003A		dw		':'
FFFC61FC 00000663		bra		FI1
FFFC6200 00470713		add		$sp,$sp,#4	; if ":", discard return address
FFFC6204 E25FE06F		jmp		RUNSML		; continue on the same line
                        	FI1:
FFFC6208 5DC000EF		call	TSTC		; not ":", is it a CR?
FFFC620C 0000000D		dw		CR
FFFC6210 00000663		bra		FI2
                        							; else return to the caller
FFFC6214 00470713		add		$sp,$sp,#4	; yes, purge return address
FFFC6218 D25FE06F		jmp		RUNNXL		; execute the next line
                        	FI2:
FFFC621C 00072083		lw		$ra,[$sp]
FFFC6220 00470713		add		$sp,$sp,#4
FFFC6224 00008067		ret					; else return to the caller
                        	
                        	
                        	; 'ENDCHK' checks if a command is ended with a CR. This is
                        	; required in certain commands, such as GOTO, RETURN, STOP, etc.
                        	;
                        	; Check that there is nothing else on the line
                        	; Registers Affected
                        	;   a0
                        	;
                        	ENDCHK:
FFFC6228 FFC70713		sub		$sp,$sp,#4
FFFC622C 00172023		sw		$ra,[$sp]
FFFC6230 674000EF		call	IGNBLK
FFFC6234 000E4903		lbu		a0,[$t2]
FFFC6238 00D06D93		ldi		$t1,#CR
FFFC623C 01B90863		beq		a0,$t1,ec1	; does it end with a CR?
FFFC6240 FFFC7937		ldi		a0,#msgExtraChars
FFFC6244 D7B90913
FFFC6248 0300006F		jmp		ERROR
                        	ec1:
FFFC624C 00072083		lw		$ra,[$sp]
FFFC6250 00470713		add		$sp,$sp,#4
FFFC6254 00008067		ret
                        	
                        	; 'ERROR' prints the string pointed to by a0. It then prints the
                        	; line pointed to by CURRNT with a "?" inserted at where the
                        	; old text pointer (should be on top of the stack) points to.
                        	; Execution of Tiny BASIC is stopped and a warm start is done.
                        	; If CURRNT is zero (indicating a direct command), the direct
                        	; command is not printed. If CURRNT is -1 (indicating
                        	; 'INPUT' command in progress), the input line is not printed
                        	; and execution is not terminated but continues at 'INPERR'.
                        	;
                        	; Related to 'ERROR' are the following:
                        	; 'QWHAT' saves text pointer on stack and gets "What?" message.
                        	; 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                        	; 'QSORRY' and 'ASORRY' do the same kind of thing.
                        	; 'QHOW' and 'AHOW' also do this for "How?".
                        	;
                        	TOOBIG:
FFFC6258 FFFC7937		ldi		a0,#msgTooBig
FFFC625C D6790913
FFFC6260 00000C63		bra		ERROR
                        	QSORRY:
FFFC6264 FFFC7937	  ldi		a0,#SRYMSG
FFFC6268 C0F90913
FFFC626C 00000663		bra	    ERROR
                        	QWHAT:
FFFC6270 FFFC7937		ldi		a0,#msgWhat
FFFC6274 C0890913
                        	ERROR:
FFFC6278 710000EF		call	PRMESG		; display the error message
FFFC627C 00030637		lw		a0,CURRNT	; get the current line pointer
FFFC6280 01860613
FFFC6284 00060633
FFFC6288 00062903
FFFC628C 04090263		beq		a0,r0,ERROR1	; if zero, do a warm start
FFFC6290 FFF06D93		ldi		$t1,#-1
FFFC6294 A1B90663		beq		a0,$t1,INPERR	; is the line no. pointer = -1? if so, redo input
FFFC6298 000E4283		lbu		r5,[$t2]		; save the char. pointed to
FFFC629C 000E0023		sb		x0,[$t2]		; put a zero where the error is
FFFC62A0 00030637		lw		a0,CURRNT	; point to start of current line
FFFC62A4 01860613
FFFC62A8 00060633
FFFC62AC 00062903
FFFC62B0 4D8000EF		call	PRTLN		; display the line in error up to the 0
FFFC62B4 00096333		mov     r6,a0	    ; save off end pointer
FFFC62B8 005E0023		sb		r5,[$t2]		; restore the character
FFFC62BC 03F06913		ldi		a0,#'?'		; display a "?"
FFFC62C0 F48FE0EF		call	GOOUT
FFFC62C4 000069B3		mov		a1,r0		; stop char = 0
FFFC62C8 FFF30913		sub		a0,r6,#1	; point back to the error char.
FFFC62CC 2E4000EF		call	PRTSTG		; display the rest of the line
                        	ERROR1:
FFFC62D0 855FE06F		jmp	    WSTART		; and do a warm start
                        	
                        	;******************************************************************
                        	;
                        	; *** GETLN *** FNDLN (& friends) ***
                        	;
                        	; 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                        	; the character in r3 (given by the caller), then it fills the
                        	; buffer and echos. It ignores LF's but still echos
                        	; them back. Control-H is used to delete the last character
                        	; entered (if there is one), and control-X is used to delete the
                        	; whole line and start over again. CR signals the end of a line,
                        	; and causes 'GETLN' to return.
                        	;
                        	;
                        	GETLN:
FFFC62D4 FF870713		sub		$sp,$sp,#8
FFFC62D8 00572023		sw		r5,[$sp]
FFFC62DC 00172223		sw		$ra,4[$sp]
FFFC62E0 F28FE0EF		call	GOOUT		; display the prompt
FFFC62E4 00106913		ldi		a0,#1
                        	;	sw		a0,CursorFlash	; turn on cursor flash
FFFC62E8 02006913		ldi		a0,#' '		; and a space
FFFC62EC F1CFE0EF		call	GOOUT
FFFC62F0 00030E37		ldi		$t2,#BUFFER	; $t2 is the buffer pointer
FFFC62F4 01CE0E13
                        	.GL1:
FFFC62F8 660000EF		call	CHKIO		; check keyboard
FFFC62FC FE080EE3		beq		v0,x0,.GL1	; wait for a char. to come in
FFFC6300 00806D93		ldi		$t1,#CTRLH
FFFC6304 05B80863		beq		v0,$t1,.GL3	; delete last character? if so
FFFC6308 01806D93		ldi		$t1,#CTRLX
FFFC630C 07B80A63		beq		v0,$t1,.GL4	; delete the whole line?
FFFC6310 00D06D93		ldi		$t1,#CR
FFFC6314 01B80663		beq		v0,$t1,.GL2		; accept a CR
FFFC6318 02006D93		ldi		$t1,#' '
FFFC631C FDB84EE3		blt		v0,$t1,.GL1	; if other control char., discard it
                        	.GL2:
FFFC6320 010E0023		sb		v0,[$t2]		; save the char.
FFFC6324 001E0E13		add		$t2,$t2,#1
FFFC6328 FFC70713		sub		$sp,$sp,#4
FFFC632C 01072023		sw		v0,[$sp]
FFFC6330 00086933		mov		$a0,$v0
FFFC6334 ED4FE0EF		call	GOOUT		; echo the char back out
FFFC6338 00072803		lw		v0,[$sp]; get char back (GOOUT destroys a0)
FFFC633C 00470713		add		$sp,$sp,#4
FFFC6340 00D06D93		ldi		$t1,#CR
FFFC6344 09B80063		beq		v0,$t1,.GL7			; if it's a CR, end the line
FFFC6348 00030DB7		ldi		$t1,#BUFFER+BUFLEN-1
FFFC634C 06FD8D93
FFFC6350 FBBE44E3		blt		$t2,$t1,.GL1		; any more room? ; yes: get some more, else delete last char.
                        	.GL3:
FFFC6354 00806913		ldi		a0,#CTRLH	; delete a char. if possible
FFFC6358 EB0FE0EF		call	GOOUT
FFFC635C 02006913		ldi		a0,#' '
FFFC6360 EA8FE0EF		call	GOOUT
FFFC6364 00030DB7		ldi		$t1,#BUFFER
FFFC6368 01CD8D93
FFFC636C F9CDD6E3		ble		$t2,$t1,.GL1	; any char.'s left?	; if not
FFFC6370 00806913		ldi		a0,#CTRLH		; if so, finish the BS-space-BS sequence
FFFC6374 E94FE0EF		call	GOOUT
FFFC6378 FFFE0E13		sub		$t2,$t2,#1	; decrement the text pointer
FFFC637C F6000EE3		bra		.GL1		; back for more
                        	.GL4:
FFFC6380 000E6933		mov		a0,$t2		; delete the whole line
FFFC6384 FFFD0637		sub		r5,a0,#BUFFER   ; figure out how many backspaces we need
FFFC6388 FE460613
FFFC638C 412602B3
FFFC6390 02028463		beq		r5,r0,.GL6		; if none needed, brnch
FFFC6394 FFF28293		sub		r5,r5,#1		; loop count is one less
                        	.GL5:
FFFC6398 00806913		ldi		a0,#CTRLH		; and display BS-space-BS sequences
FFFC639C E6CFE0EF		call	GOOUT
FFFC63A0 02006913		ldi		a0,#' '
FFFC63A4 E64FE0EF		call	GOOUT
FFFC63A8 00806913		ldi		a0,#CTRLH
FFFC63AC E5CFE0EF		call	GOOUT
FFFC63B0 FFF28293		sub		r5,r5,#1
FFFC63B4 FE0292E3		bne		r5,r0,.GL5
                        	.GL6:
FFFC63B8 00030E37		ldi		$t2,#BUFFER	; reinitialize the text pointer
FFFC63BC 01CE0E13
FFFC63C0 F2000CE3		bra		.GL1		; and go back for more
                        	.GL7:
FFFC63C4 000E0023		sb		x0,[$t2]		; null terminate line
                        	;	sw		x0,CursorFlash	; turn off cursor flash
FFFC63C8 00A06913		ldi		a0,#LINEFD	; echo a LF for the CR
FFFC63CC E3CFE0EF		call	GOOUT
FFFC63D0 00072283		lw		r5,[$sp]
FFFC63D4 00472083		lw		$ra,4[$sp]
FFFC63D8 00870713		add		$sp,$sp,#8
FFFC63DC 00008067		ret
                        	
                        	
                        	; 'FNDLN' finds a line with a given line no. (in a0) in the
                        	; text save area.  $t3 is used as the text pointer. If the line
                        	; is found, $t3 will point to the beginning of that line
                        	; (i.e. the high byte of the line no.), and $v0 = 1.
                        	; If that line is not there and a line with a higher line no.
                        	; is found, $t3 points there and $v0 = 0. If we reached
                        	; the end of the text save area and cannot find the line, flags
                        	; $t3 = 0, $v0 = 0.
                        	; $v0=1 if line found
                        	; r0 = 1	<= line is found
                        	;	$t3 = pointer to line
                        	; r0 = 0    <= line is not found
                        	;	r9 = zero, if end of text area
                        	;	r9 = otherwise higher line number
                        	;
                        	; 'FNDLN' will initialize $t3 to the beginning of the text save
                        	; area to start the search. Some other entries of this routine
                        	; will not initialize $t3 and do the search.
                        	; 'FNDLNP' will start with $t3 and search for the line no.
                        	; 'FNDNXT' will bump $t3 by 4, find a CR and then start search.
                        	; 'FNDSKP' uses $t3 to find a CR, and then starts the search.
                        	; return Z=1 if line is found, r9 = pointer to line
                        	;
                        	; Parameters
                        	;	a0 = line number to find
                        	;
                        	FNDLN:
FFFC63E0 00100DB7		ldi		$t1,#$FFFFF
FFFC63E4 FFFD8D93
FFFC63E8 01B94863		blt		a0,$t1,fl1	; line no. must be < 65535
FFFC63EC FFFC7937		ldi		a0,#msgLineRange
FFFC63F0 C9590913
FFFC63F4 E85FF06F		jmp		ERROR
                        	fl1:
FFFC63F8 00032EB7		ldi		$t3,#TXTBGN	; init. the text save pointer
FFFC63FC 800E8E93
                        	
                        	FNDLNP:
FFFC6400 00030637		lw		$t4,TXTUNF	; check if we passed the end
FFFC6404 00460613
FFFC6408 00060633
FFFC640C 00062F03
FFFC6410 05EEF463		bgeu	$t3,$t4,FNDRET1; if so, return with r9=0,a0=0
FFFC6414 FF870713		sub		$sp,$sp,#8	; push a0
FFFC6418 01272023		sw		a0,[$sp]
FFFC641C 00172223		sw		ra,4[$sp]
FFFC6420 000EE933		mov		a0,t3
FFFC6424 338000EF		call	LoadWord		; get line number
FFFC6428 00072903		lw		a0,[$sp]		; pop a0
FFFC642C 00472083		lw		ra,4[$sp]
FFFC6430 00870713		add		$sp,$sp,#8
FFFC6434 03280663		beq		v0,a0,FNDRET2
FFFC6438 03286863		bltu	v0,a0,FNDNXT	; is this the line we want? no, not there yet
                        	FNDRET:
FFFC643C 004E8E93		add		$t3,$t3,#4	; find the next line, skip over line number
                        	.0001:
FFFC6440 000EC883		lbu		v1,[$t3]
FFFC6444 001E8E93		add		$t3,$t3,#1
FFFC6448 00D06D93		ldi		$t1,#CR
FFFC644C FFB89AE3		bne		v1,$t1,.0001	; try to find a CR, keep looking
FFFC6450 00006833		mov		v0,x0	; line not found, but $t3=next line pointer
FFFC6454 00008067		ret
                        	FNDRET1:
                        	;	eor		r9,r9,r9	; no higher line
FFFC6458 00006833		mov		v0,x0	; line not found
FFFC645C 00008067		ret
                        	FNDRET2:
FFFC6460 00106813		ldi		v0,#1	; line found
FFFC6464 00008067		ret
                        	
                        	FNDNXT:
FFFC6468 004E8E93		add		$t3,$t3,#4	; find the next line
                        	
                        	FNDSKP:
FFFC646C 000EC883		lbu		v1,[$t3]
FFFC6470 001E8E93		add		$t3,$t3,#1
FFFC6474 00D06D93		ldi		$t1,#CR
FFFC6478 FFB89AE3		bne		v1,$t1,FNDSKP	; try to find a CR, keep looking
FFFC647C F80002E3		bra		FNDLNP		; check if end of text
                        	
                        	
                        	;******************************************************************
                        	; 'MVUP' moves a block up from where a0 points to where a1 points
                        	; until a0=a2
                        	;
                        	MVUP1:
FFFC6480 00090203		lb		r4,[a0]
FFFC6484 00498023		sb		r4,[a1]
FFFC6488 00190913		add		a0,a0,#1
FFFC648C 00198993		add		a1,a1,#1
                        	MVUP:
FFFC6490 FF4918E3		bne		a0,a2,MVUP1
FFFC6494 00008067		ret
                        	
                        	
                        	; 'MVDOWN' moves a block down from where a0 points to where a1
                        	; points until a0=a2
                        	;
                        	MVDOWN1:
FFFC6498 FFF90913		sub		a0,a0,#1
FFFC649C FFF98993		sub		a1,a1,#1
FFFC64A0 00090203		lb		r4,[a0]
FFFC64A4 00498023		sb		r4,[a1]
                        	MVDOWN:
FFFC64A8 FF4918E3		bne		a0,a2,MVDOWN1
FFFC64AC 00008067		ret
                        	
                        	
                        	; 'POPA_' restores the 'FOR' loop variable save area from the stack
                        	;
                        	; 'PUSHA_' stacks for 'FOR' loop variable save area onto the stack
                        	;
                        	; Note: a single zero word is stored on the stack in the
                        	; case that no FOR loops need to be saved. This needs to be
                        	; done because PUSHA_ / POPA_ is called all the time.
                        	//message "POPA_"
                        	POPA_:
FFFC64B0 00072903		lw		a0,[$sp]
FFFC64B4 00470713		add		$sp,$sp,#4
FFFC64B8 00030637		sw		a0,LOPVAR	; restore LOPVAR, but zero means no more
FFFC64BC 01060613
FFFC64C0 00060633
FFFC64C4 01262023
FFFC64C8 04090C63		beq		a0,x0,PP1
FFFC64CC 00072903		lw		a0,[$sp]
FFFC64D0 00030637		sw		a0,LOPPT
FFFC64D4 07060613
FFFC64D8 00060633
FFFC64DC 01262023
FFFC64E0 00472903		lw		a0,4[$sp]
FFFC64E4 00030637		sw		a0,LOPLN
FFFC64E8 07460613
FFFC64EC 00060633
FFFC64F0 01262023
FFFC64F4 00872903		lw		a0,8[$sp]
FFFC64F8 00030637		sw		a0,LOPLMT
FFFC64FC 07C60613
FFFC6500 00060633
FFFC6504 01262023
FFFC6508 00C72903		lw		a0,12[$sp]
FFFC650C 00030637		sw		a0,LOPINC
FFFC6510 07860613
FFFC6514 00060633
FFFC6518 01262023
FFFC651C 01070713		add		$sp,$sp,#16
                        	PP1:
FFFC6520 00008067		ret
                        	
                        	
                        	PUSHA_:
FFFC6524 00030637		lw		a0,STKBOT	; Are we running out of stack room?
FFFC6528 09C60613
FFFC652C 00060633
FFFC6530 00062903
FFFC6534 01490913		add		a0,a0,#20	; we might need this many bytes
FFFC6538 D32746E3		blt		$sp,a0,QSORRY	; out of stack space
FFFC653C 00030637		lw		a1,LOPVAR		; save loop variables
FFFC6540 01060613
FFFC6544 00060633
FFFC6548 00062983
FFFC654C 04098C63		beq		a1,x0,PU1		; if LOPVAR is zero, that's all
FFFC6550 FF070713		sub		$sp,$sp,#16
FFFC6554 00030637		lw		a0,LOPPT
FFFC6558 07060613
FFFC655C 00060633
FFFC6560 00062903
FFFC6564 01272023		sw		a0,[$sp]
FFFC6568 00030637		lw		a0,LOPLN
FFFC656C 07460613
FFFC6570 00060633
FFFC6574 00062903
FFFC6578 01272223		sw		a0,4[$sp]
FFFC657C 00030637		lw		a0,LOPLMT
FFFC6580 07C60613
FFFC6584 00060633
FFFC6588 00062903
FFFC658C 01272423		sw		a0,8[$sp]
FFFC6590 00030637		lw		a0,LOPINC
FFFC6594 07860613
FFFC6598 00060633
FFFC659C 00062903
FFFC65A0 01272623		sw		a0,12[$sp]
                        	PU1:
FFFC65A4 FFC70713		sub		$sp,$sp,#4
FFFC65A8 01372023		sw		a1,[$sp]
FFFC65AC 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	;
                        	; 'PRTSTG' prints a string pointed to by a0. It stops printing
                        	; and returns to the caller when either a CR is printed or when
                        	; the next byte is the same as what was passed in a1 by the
                        	; caller.
                        	;
                        	; 'PRTLN' prints the saved text line pointed to by r3
                        	; with line no. and all.
                        	;
                        	
                        	; a0 = pointer to string
                        	; a1 = stop character
                        	; return v0 = pointer to end of line + 1
                        	
                        	PRTSTG:
FFFC65B0 FEC70713		sub		$sp,$sp,#20
FFFC65B4 00572023		sw		r5,[$sp]
FFFC65B8 00672223		sw		r6,4[$sp]
FFFC65BC 00772423		sw		r7,8[$sp]
FFFC65C0 00172623		sw		$ra,12[$sp]
FFFC65C4 01272823		sw		$a0,16[$sp]
FFFC65C8 000962B3		mov   r5,a0	    ; r5 = pointer
FFFC65CC 0009E333		mov   r6,a1	    ; r6 = stop char
                        	.PS1:
FFFC65D0 0002C383	  lbu   r7,[r5]     ; get a text character
FFFC65D4 00128293		add		r5,r5,#1
FFFC65D8 00638E63		beq	  r7,r6,.PRTRET	; same as stop character? if so, return
FFFC65DC 0003E933		mov   a0,r7
FFFC65E0 C28FE0EF		call	GOOUT		; display the char.
FFFC65E4 00D06D93		ldi		$t1,#CR
FFFC65E8 FFB394E3		bne   r7,$t1,.PS1	; is it a C.R.? no, go back for more
FFFC65EC 00A06913		ldi		a0,#LINEFD  ; yes, add a L.F.
FFFC65F0 C18FE0EF		call	GOOUT
                        	.PRTRET:
FFFC65F4 0003E8B3	  mov   v1,r7	    ; return a1 = stop char
FFFC65F8 0002E833		mov		v0,r5		; return a0 = line pointer
FFFC65FC 00072283		lw		$r5,[$sp]
FFFC6600 00472303		lw		$r6,4[$sp]
FFFC6604 00872383		lw		$r7,8[$sp]
FFFC6608 00C72083		lw		$ra,12[$sp]
FFFC660C 01072903		lw		$a0,16[$sp]
FFFC6610 01470713		add		$sp,$sp,#20
FFFC6614 00008067	  ret					; then return
                        	
                        	
                        	; 'QTSTG' looks for an underline (back-arrow on some systems),
                        	; single-quote, or double-quote.  If none of these are found, returns
                        	; to the caller.  If underline, outputs a CR without a LF.  If single
                        	; or double quote, prints the quoted string and demands a matching
                        	; end quote.  After the printing, the next i-word of the caller is
                        	; skipped over (usually a branch instruction).
                        	;
                        	QTSTG:
FFFC6618 FFC70713		sub		$sp,$sp,#4
FFFC661C 00172023		sw		$ra,[$sp]
FFFC6620 1C4000EF		call	TSTC		; *** QTSTG ***
FFFC6624 00000022		dw		'"'
FFFC6628 02000063		bra		QT3
FFFC662C 02206993		ldi		a1,#'"'		; it is a "
                        	QT1:
FFFC6630 000E6933		mov		a0,$t2
FFFC6634 F7DFF0EF		call	PRTSTG		; print until another
FFFC6638 00086E33		mov		$t2,v0
FFFC663C 00D06D93		ldi		$t1,#CR
FFFC6640 03B89863		bne		v1,$t1,QT2	; was last one a CR?
FFFC6644 8F9FE06F		jmp		RUNNXL		; if so run next line
                        	QT3:
FFFC6648 19C000EF		call	TSTC		; is it a single quote?
FFFC664C 0000005C		dw		'\''
FFFC6650 00000663		bra		QT4
FFFC6654 02706993		ldi		a1,#'\''	; if so, do same as above
FFFC6658 FC000CE3		bra		QT1
                        	QT4:
FFFC665C 188000EF		call	TSTC		; is it an underline?
FFFC6660 0000005F		dw		'_'
FFFC6664 00000C63		bra		QT5
FFFC6668 00D06913		ldi		a0,#CR		; if so, output a CR without LF
FFFC666C B9CFE0EF		call	GOOUT
                        	QT2:
FFFC6670 00072083		lw		$ra,[$sp]		; get return address
FFFC6674 00470713		add		$sp,$sp,#4
FFFC6678 00408067		jmp		4[$ra]		; skip following branch
                        	QT5:					; not " ' or _
FFFC667C 00072083		lw		$ra,[$sp]		; get return address
FFFC6680 00470713		add		$sp,$sp,#4
FFFC6684 00008067		ret
                        	
                        	; Output a CR LF sequence
                        	;
                        	prCRLF:
FFFC6688 FFC70713		sub		$sp,$sp,#4
FFFC668C 00172023		sw		$ra,[$sp]
FFFC6690 00D06913		ldi		a0,#CR
FFFC6694 B74FE0EF		call	GOOUT
FFFC6698 00A06913		ldi		a0,#LINEFD
FFFC669C B6CFE0EF		call	GOOUT
FFFC66A0 00072083		lw		$ra,[$sp]
FFFC66A4 00470713		add		$sp,$sp,#4
FFFC66A8 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; 'PRTNUM' prints the 32 bit number in a0, leading blanks are added if
                        	; needed to pad the number of spaces to the number in a1.
                        	; However, if the number of digits is larger than the no. in
                        	; a1, all digits are printed anyway. Negative sign is also
                        	; printed and counted in, positive sign is not.
                        	;
                        	; Parameters
                        	; 	a0 = number to print
                        	; 	a1 = number of digits
                        	;		a2 = base (eg 10, 16)
                        	; Register Usage
                        	;		s2 = number of padding spaces
                        	; Modifies:
                        	;		a0,a1,t1
                        	; Returns:
                        	;		none
                        	;-------------------------------------------------------------------------------
                        	
FFFC66AC FEC70713	public PRTNUM:
	sub		$sp,$sp,#20
FFFC66B0 00472023		sw		$s1,[$sp]
FFFC66B4 00572223		sw		$s2,4[$sp]
FFFC66B8 00672423		sw		$s3,8[$sp]
FFFC66BC 00772623		sw		$s4,12[$sp]
FFFC66C0 00172823		sw		$ra,16[$sp]
FFFC66C4 000303B7		ldi		s4,#NUMWKA	; r7 = pointer to numeric work area
FFFC66C8 09438393
FFFC66CC 00096333		mov		s3,a0		; save number for later
FFFC66D0 0009E2B3		mov		s2,a1		; s2 = min number of chars
FFFC66D4 00095663		bge		a0,x0,.PN2	; is it negative? if not
FFFC66D8 41200933		sub		a0,x0,a0	; else make it positive
FFFC66DC FFF28293		sub		s2,s2,#1	; one less for width count
                        	.PN2:
FFFC66E0 00A06D93		ldi		$t1,#10
                        	.PN1:
FFFC66E4 034969B3		rem		a1,a0,a2	; a1 = a0 mod 10
FFFC66E8 03494933		div		a0,a0,a2	; a0 /= 10 divide by 10
FFFC66EC 013A7463		bleu	a1,a2,.PN7
FFFC66F0 00798993		add		a1,a1,#'A'-10-'0'
                        	.PN7:
FFFC66F4 03098993		add		a1,a1,#'0'	; convert remainder to ascii
FFFC66F8 01338023		sb		a1,[$s4]		; and store in buffer
FFFC66FC 00138393		add		s4,s4,#1
FFFC6700 FFF28293		sub		s2,s2,#1	; decrement width
FFFC6704 FE0910E3		bne		a0,x0,.PN1
FFFC6708 00505A63		ble		$s2,$x0,.PN4	; test pad count, skip padding if not needed
                        	.PN3:
FFFC670C 02006913		ldi		$a0,#' '		; display the required leading spaces
FFFC6710 AF8FE0EF		call	GOOUT
FFFC6714 FFF28293		sub		$s2,$s2,#1
FFFC6718 FE504AE3		bgt		$s2,$x0,.PN3
                        	.PN4:
FFFC671C 00035663		bge		$s3,$x0,.PN5	; is number negative?
FFFC6720 02D06913		ldi		$a0,#'-'		; if so, display the sign
FFFC6724 AE4FE0EF		call	GOOUT
                        	.PN5:
FFFC6728 00030DB7		ldi		$t1,#NUMWKA
FFFC672C 094D8D93
                        	.PN6:
FFFC6730 FFF38393		sub		$s4,$s4,#1
FFFC6734 0003C903		lbu		$a0,[$s4]		; now unstack the digits and display
FFFC6738 AD0FE0EF		call	GOOUT
FFFC673C FE7DEAE3		bgtu	$s4,$t1,.PN6
                        	
FFFC6740 00072203		lw		$s1,[$sp]
FFFC6744 00472283		lw		$s2,4[$sp]
FFFC6748 00872303		lw		$s3,8[$sp]
FFFC674C 00C72383		lw		$s4,12[$sp]
FFFC6750 01072083		lw		$ra,16[$sp]
FFFC6754 01470713		add		$sp,$sp,#20
FFFC6758 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; Load a word from memory using unaligned access.
                        	; Moves forwards through memory
                        	;
                        	; Parameters:
                        	;		a0 = pointer to word
                        	; Returns:
                        	;		v0 = word loaded
                        	;-------------------------------------------------------------------------------
                        	LoadWord:
FFFC675C 00094803	  lbu		$v0,[$a0]	
FFFC6760 00194883	  lbu		$v1,1[$a0]
FFFC6764 00889893	  sll		$v1,$v1,#8
FFFC6768 01186833	  or		$v0,$v0,$v1
FFFC676C 00294883	  lbu		$v1,2[$a0]
FFFC6770 01089893	  sll		$v1,$v1,#16
FFFC6774 01186833	  or		$v0,$v0,$v1
FFFC6778 00394883	  lbu		$v1,3[$a0]
FFFC677C 01889893	  sll		$v1,$v1,#24
FFFC6780 01186833	  or		$v0,$v0,$v1
FFFC6784 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = pointer to line
                        	; Returns:
                        	;		v0 = pointer to end of line + 1
                        	;-------------------------------------------------------------------------------
                        	
                        	PRTLN:
FFFC6788 FF070713		sub		$sp,$sp,#16
FFFC678C 00572023		sw		$r5,[$sp]
FFFC6790 00172223		sw		$ra,4[$sp]
FFFC6794 01272423		sw		$a0,8[$sp]
FFFC6798 01372623		sw		$a1,12[$sp]
FFFC679C 000962B3	  mov		$r5,$a0		; r5 = pointer
                        	  ; get the line number stored as binary
                        	  ; assume unaligned loads not allowed
FFFC67A0 FBDFF0EF	  call	LoadWord
FFFC67A4 00086933	  mov		a0,v0
                        	
FFFC67A8 00428293		add		r5,r5,#4
FFFC67AC 00506993	  ldi		a1,#5       ; display a 0 or more digit line no.
FFFC67B0 00A06A13	  ldi		a2,#10
FFFC67B4 EF9FF0EF		call	PRTNUM
FFFC67B8 02006913		ldi		a0,#' '     ; followed by a blank
FFFC67BC A4CFE0EF		call	GOOUT
FFFC67C0 000069B3		mov		a1,r0       ; stop char. is a zero
FFFC67C4 0002E933		mov		a0,r5
FFFC67C8 DE9FF0EF		call  PRTSTG		; display the rest of the line
FFFC67CC 00072283		lw		$r5,[$sp]
FFFC67D0 00472083		lw		$ra,4[$sp]
FFFC67D4 00872903		lw		$a0,8[$sp]
FFFC67D8 00C72983		lw		$a1,12[$sp]
FFFC67DC 01070713		add		$sp,$sp,#16
FFFC67E0 00008067		ret
                        	
                        	
                        	; ===== Test text byte following the call to this subroutine. If it
                        	;	equals the byte pointed to by t2, return to the code following
                        	;	the call. 
                        	;
                        	; Parameters:
                        	;		<static> word byte to look for
                        	;		<static> branch if not found
                        	; Registers Affected
                        	;   none
                        	; Returns
                        	;		t2 = updated text pointer
                        	;
                        	TSTC:
FFFC67E4 FF470713		sub		$sp,$sp,#12
FFFC67E8 01272023		sw		$a0,[$sp]
FFFC67EC 00172223		sw		$ra,4[$sp]
FFFC67F0 01372423		sw		$a1,8[$sp]
FFFC67F4 0B0000EF		call	IGNBLK		; ignore leading blanks
FFFC67F8 00472083		lw		$ra,4[$sp]	; get return address, it's needed for a reference
FFFC67FC 000E4903		lbu		$a0,[$t2]
FFFC6800 0000C983		lbu		$a1,[$ra]
FFFC6804 01298A63		beq		$a1,$a0,TC1	; is it = to what t2 points to? if so
FFFC6808 00072903		lw		$a0,[$sp]		; restore a0
FFFC680C 00872983		lw		$a1,8[$sp]
FFFC6810 00C70713		add		$sp,$sp,#12	;
FFFC6814 00408067		jmp		4[$ra]			; jump to the routine skip param
                        	TC1:
FFFC6818 001E0E13		add		$t2,$t2,#1	; if equal, bump text pointer
FFFC681C 00072903		lw		$a0,[$sp]
FFFC6820 00472083		lw		$ra,4[$sp]
FFFC6824 00872983		lw		$a1,8[$sp]
FFFC6828 00C70713		add		$sp,$sp,#12
FFFC682C 00808067		jmp		8[$ra]			; jump back, skip parm and branch
                        	
                        	
                        	; ===== See if the text pointed to by $t2 is a number. If so,
                        	;	return the number in $v0 and the number of digits in $v1,
                        	;	else return zero in $v0 and $v1.
                        	; Registers Affected
                        	;   a0,a1,r3,r4
                        	; Returns
                        	; 	v0 = number
                        	;		v1 = number of digits in number
                        	;	t2 = updated text pointer
                        	;
                        	TSTNUM:
FFFC6830 FF870713		sub		$sp,$sp,#8
FFFC6834 00172223		sw		$ra,4[$sp]
FFFC6838 00372023		sw		r3,[$sp]
FFFC683C 068000EF		call	IGNBLK		; skip over blanks
FFFC6840 00006833		mov		$v0,$x0		; initialize return parameters
FFFC6844 000068B3		mov		$v1,$x0
                        	TN1:
FFFC6848 000E4183		lbu		r3,[$t2]
FFFC684C 03006D93		ldi		$t1,#'0'
FFFC6850 05B1C263		blt		r3,$t1,TSNMRET; is it less than zero?
FFFC6854 03906D93		ldi		$t1,#'9'
FFFC6858 023DCE63		bgt		r3,$t1,TSNMRET; is it greater than nine?
FFFC685C 00000DB7		ldi		$t1,#$7FFFFFFFFFFFFFF
FFFC6860 FFFD8D93
FFFC6864 010DF863		bleu	$v0,$t1,TN2; see if there's room for new digit
FFFC6868 FFFC7937		ldi		$a0,#msgNumTooBig
FFFC686C C3190913
FFFC6870 A09FF06F		jmp		ERROR		; if not, we've overflowd
                        	TN2:
FFFC6874 001E0E13		add		$t2,$t2,#1	; adjust text pointer
FFFC6878 00181E93		sll		$t3,$v0,#1	; quickly multiply result by 10
FFFC687C 00381813		sll		$v0,$v0,#3	; *8
FFFC6880 01D80833		add		$v0,$v0,$t3	; *8 + *2
FFFC6884 00F1F193		and		r3,r3,#$0F	; add in the new digit
FFFC6888 00380833		add		$v0,$v0,r3
FFFC688C 00188893		add		$v1,$v1,#1	; increment the no. of digits
FFFC6890 FA000CE3		bra		TN1
                        	TSNMRET:
FFFC6894 00072183		lw		r3,[$sp]
FFFC6898 00472083		lw		$ra,4[$sp]
FFFC689C 00870713		add		$sp,$sp,#8
FFFC68A0 00008067		ret
                        	
                        	
                        	;===== Skip over blanks in the text pointed to by $t2.
                        	;
                        	; Registers Affected:
                        	;	$t2
                        	; Returns
                        	;	$t2 = pointer updateded past any spaces or tabs
                        	;
                        	IGNBLK:
FFFC68A4 FFC70713		sub		$sp,$sp,#4
FFFC68A8 01272023		sw		$a0,[$sp]
                        	IGB2:
FFFC68AC 000E4903		lbu		a0,[$t2]			; get char
FFFC68B0 02006D93		ldi		$t1,#' '
FFFC68B4 01B90663		beq		$a0,$t1,IGB1	; see if it's a space
FFFC68B8 00906D93		ldi		$t1,#'\t'
FFFC68BC 01B91663		bne		a0,$t1,IGBRET	; or a tab
                        	IGB1:
FFFC68C0 001E0E13		add		$t2,$t2,#1		; increment the text pointer
FFFC68C4 FE0004E3		bra		IGB2
                        	IGBRET:
FFFC68C8 00072903		lw		$a0,[$sp]
FFFC68CC 00470713		add		$sp,$sp,#4
FFFC68D0 00008067		ret
                        	
                        	; ===== Convert the line of text in the input buffer to upper
                        	;	case (except for stuff between quotes).
                        	;
                        	; Registers Affected
                        	;   a0,r3
                        	; Returns
                        	;	r8 = pointing to end of text in buffer
                        	;
                        	TOUPBUF:
FFFC68D4 FFC70713		sub		$sp,$sp,#4
FFFC68D8 00172023		sw		$ra,[$sp]
FFFC68DC 00030E37		ldi		$t2,#BUFFER	; set up text pointer
FFFC68E0 01CE0E13
FFFC68E4 000061B3		mov		r3,x0		; clear quote flag
                        	TOUPB1:
FFFC68E8 000E4903		lbu		a0,[$t2]		; get the next text char.
FFFC68EC 001E0E13		add		$t2,$t2,#1
FFFC68F0 00D06D93		ldi		$t1,#CR
FFFC68F4 03B90E63		beq		a0,$t1,TOUPBRT		; is it end of line?
FFFC68F8 02206D93		ldi		$t1,#'"'
FFFC68FC 01B90E63		beq		a0,$t1,DOQUO	; a double quote?
FFFC6900 02706D93		ldi		$t1,#'\''
FFFC6904 01B90A63		beq		a0,$t1,DOQUO	; or a single quote?
FFFC6908 FE0190E3		bne		r3,x0,TOUPB1	; inside quotes?
FFFC690C 030000EF		call	toUpper 	; convert to upper case
FFFC6910 FF0E0FA3		sb		v0,-1[$t2]	; store it
FFFC6914 FC000AE3		bra		TOUPB1		; and go back for more
                        	DOQUO:
FFFC6918 00019663		bne		r3,x0,DOQUO1; are we inside quotes?
FFFC691C 000961B3		mov		r3,a0		; if not, toggle inside-quotes flag
FFFC6920 FC0004E3		bra		TOUPB1
                        	DOQUO1:
FFFC6924 FD2192E3		bne		r3,a0,TOUPB1; make sure we're ending proper quote
FFFC6928 000061B3		mov		r3,r0		; else clear quote flag
FFFC692C FA000EE3		bra		TOUPB1
                        	TOUPBRT:
FFFC6930 00072083		lw		$ra,[$sp]
FFFC6934 00470713		add		$sp,$sp,#4
FFFC6938 00008067		ret
                        	
                        	
                        	; ===== Convert the character in a0 to upper case
                        	;
                        	toUpper:
FFFC693C 00096833		mov		$v0,$a0
FFFC6940 06182D93		slt		$t1,$v0,#'a'
FFFC6944 000D9863		bne   $t1,$x0,TOUPRET	; is it < 'a'?
FFFC6948 07A06D93		ldi		$t1,#'z'
FFFC694C 010DC463		bgt		$v0,$t1,TOUPRET	; or > 'z'?
FFFC6950 FE080813		sub		$v0,$v0,#32	  ; if not, make it upper case
                        	TOUPRET:
FFFC6954 00008067		ret
                        	
                        	; 'CHKIO' checks the input. If there's no input, it will return
                        	; to the caller with the a0=0. If there is input, the input byte is in a0.
                        	; However, if a control-C is read, 'CHKIO' will warm-start BASIC and will
                        	; not return to the caller.
                        	;
                        	//message "CHKIO"
                        	CHKIO:
FFFC6958 FFC70713		sub		$sp,$sp,#4
FFFC695C 00172023		sw		$ra,[$sp]
FFFC6960 228000EF		call	INCH		; get input if possible
FFFC6964 00080863		beq		$v0,$x0,CHKRET	; if Zero, no input
FFFC6968 00384893		xor		$v1,$v0,#CTRLC
FFFC696C 00089463		bne		$v1,$x0,CHKRET; is it control-C?
FFFC6970 9B4FE06F		jmp		WSTART		; if so, do a warm start
                        	CHKRET:
FFFC6974 00072083		lw		$ra,[$sp]
FFFC6978 00470713		add		$sp,$sp,#4
FFFC697C 00008067		ret
                        	
                        	; ===== Display a CR-LF sequence
                        	;
                        	CRLF:
FFFC6980 FFFC7937		ldi		a0,#CLMSG
FFFC6984 C1590913
                        	
                        	; ===== Display a zero-ended string pointed to by register a0
                        	; Registers Affected
                        	;   a0,a1,r4
                        	;
                        	PRMESG:
FFFC6988 FFC70713		sub		$sp,$sp,#4
FFFC698C 00172023		sw		$ra,[$sp]
FFFC6990 F4DF90EF		call	PutString
FFFC6994 00072083		lw		$ra,[$sp]
FFFC6998 00470713		add		$sp,$sp,#4
FFFC699C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;	erc = ALLOCMBX (<handle var>)
                        	;------------------------------------------------------------------------------
                        	
                        	ALLOCMBX:
FFFC69A0 E45FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC69A4 00000028		dw		'('
FFFC69A8 04000E63		bra		.paren
FFFC69AC 00106913		ldi		a0,#1
FFFC69B0 C68FF0EF		call	TSTV
FFFC69B4 00081863		bne		v0,x0,.0001
FFFC69B8 FFFC7937		ldi		a0,#msgVar
FFFC69BC CAA90913
FFFC69C0 8B9FF06F		jmp		ERROR
                        	.0001:
FFFC69C4 E21FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC69C8 00000029		dw		')'
FFFC69CC 02000C63		bra		.paren
FFFC69D0 00086233		mov		s1,v0
FFFC69D4 00E06913		ldi		a0,#14			; get current tid
FFFC69D8 00000073		ecall
FFFC69DC 0008E9B3		mov		a1,v1
FFFC69E0 00026A33		mov		a2,s1
FFFC69E4 00606913		ldi		a0,#6
FFFC69E8 00000073		ecall
FFFC69EC 00081463		bne		v0,x0,.0002
FFFC69F0 01122023		sw		v1,[s1]				; save handle in variable
                        	.0002:
FFFC69F4 000068B3		mov		v1,x0
FFFC69F8 00072083		lw		$ra,[$sp]
FFFC69FC 00470713		add		$sp,$sp,#4
FFFC6A00 00008067		ret
                        	.paren:
FFFC6A04 FFFC7937		ldi		a0,#msgParen
FFFC6A08 DB790913
FFFC6A0C 86DFF06F		jmp		ERROR
                        	
                        	;------------------------------------------------------------------------------
                        	; erc = SENDMSG (<handle var>, <msg data 1>, <msg data 2>, <msg data 3>)
                        	;------------------------------------------------------------------------------
                        	
                        	SENDMSG:
FFFC6A10 DD5FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC6A14 00000028		dw		'('
FFFC6A18 08000463		bra		.paren
FFFC6A1C FBDFE0EF		call	OREXPR	; get the mailbox handle
FFFC6A20 00086233		mov		s1,v0
FFFC6A24 DC1FF0EF		call	TSTC		; it must be followed by a comma
FFFC6A28 0000002C		dw		','
FFFC6A2C 06000463		bra		.err
FFFC6A30 FA9FE0EF		call	OREXPR	; get the memory address
FFFC6A34 000862B3		mov		s2,v0
FFFC6A38 DADFF0EF		call	TSTC		; it must be followed by a comma
FFFC6A3C 0000002C		dw		','
FFFC6A40 04000A63		bra		.err
FFFC6A44 F95FE0EF		call	OREXPR	; get the memory address
FFFC6A48 00086333		mov		s3,v0
FFFC6A4C D99FF0EF		call	TSTC		; it must be followed by a comma
FFFC6A50 0000002C		dw		','
FFFC6A54 04000063		bra		.err
FFFC6A58 F81FE0EF		call	OREXPR	; get the memory address
FFFC6A5C 000863B3		mov		s4,v0
FFFC6A60 D85FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC6A64 00000029		dw		')'
FFFC6A68 02000C63		bra		.paren
FFFC6A6C 00906913		ldi		a0,#9		; SendMsg
FFFC6A70 000269B3		mov		a1,s1
FFFC6A74 0002EA33		mov		a2,s2
FFFC6A78 00036AB3		mov		a3,s3
FFFC6A7C 0003EB33		mov		a4,s4
FFFC6A80 00000073		ecall
FFFC6A84 000068B3		mov		v1,x0
FFFC6A88 00072083		lw		$ra,[$sp]
FFFC6A8C 00470713		add		$sp,$sp,#4
FFFC6A90 00008067		ret
                        	.err:
FFFC6A94 FFFC7937		ldi		a0,#msgComma
FFFC6A98 C8290913
FFFC6A9C FDCFF06F		jmp		ERROR
                        	.paren:
FFFC6AA0 FFFC7937		ldi		a0,#msgParen
FFFC6AA4 DB790913
FFFC6AA8 FD0FF06F		jmp		ERROR
                        	
                        	;------------------------------------------------------------------------------
                        	; WAITMSG <handle var>, <var for data 1>, <var for data 2>, <var for data 3>,
                        	;		<expr>
                        	;------------------------------------------------------------------------------
                        	
                        	WAITMSG:
FFFC6AAC D39FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC6AB0 00000028		dw		'('
FFFC6AB4 0C000263		bra		.paren
FFFC6AB8 F21FE0EF		call	OREXPR	; get the mailbox handle
FFFC6ABC 00086233		mov		s1,v0
FFFC6AC0 D25FF0EF		call	TSTC		; it must be followed by a comma
FFFC6AC4 0000002C		dw		','
FFFC6AC8 0A000263		bra		.err
FFFC6ACC 00106913		ldi		a0,#1
FFFC6AD0 B48FF0EF		call	TSTV
FFFC6AD4 00081863		bne		v0,x0,.0001
                        	.0002:
FFFC6AD8 FFFC7937		ldi		a0,#msgVar
FFFC6ADC CAA90913
FFFC6AE0 F98FF06F		jmp		ERROR
                        	.0001:
FFFC6AE4 D01FF0EF		call	TSTC		; it must be followed by a comma
FFFC6AE8 0000002C		dw		','
FFFC6AEC 08000063		bra		.err
FFFC6AF0 000862B3		mov		s2,v0
FFFC6AF4 00106913		ldi		a0,#1
FFFC6AF8 B20FF0EF		call	TSTV
FFFC6AFC FC080EE3		beq		v0,x0,.0002
FFFC6B00 CE5FF0EF		call	TSTC		; it must be followed by a comma
FFFC6B04 0000002C		dw		','
FFFC6B08 06000263		bra		.err
FFFC6B0C 00086333		mov		s3,v0
FFFC6B10 00106913		ldi		a0,#1
FFFC6B14 B04FF0EF		call	TSTV
FFFC6B18 FC0800E3		beq		v0,x0,.0002
FFFC6B1C 000863B3		mov		s4,v0
FFFC6B20 CC5FF0EF		call	TSTC		; it must be followed by a comma
FFFC6B24 0000002C		dw		','
FFFC6B28 04000263		bra		.err
FFFC6B2C EADFE0EF		call	OREXPR	; get queue remove flag
FFFC6B30 00086BB3		mov		a5,v0
FFFC6B34 000863B3		mov		s4,v0
FFFC6B38 CADFF0EF		call	TSTC		; else look for ( OREXPR )
FFFC6B3C 00000029		dw		')'
FFFC6B40 02000C63		bra		.paren
FFFC6B44 00A06913		ldi		a0,#10		; WaitMsg
FFFC6B48 000269B3		mov		a1,s1
FFFC6B4C 0002EA33		mov		a2,s2
FFFC6B50 00036AB3		mov		a3,s3
FFFC6B54 0003EB33		mov		a4,s4
FFFC6B58 00000073		ecall
FFFC6B5C 000068B3		mov		v1,x0
FFFC6B60 00072083		lw		$ra,[$sp]
FFFC6B64 00470713		add		$sp,$sp,#4
FFFC6B68 00008067		ret
                        	.err:
FFFC6B6C FFFC7937		ldi		a0,#msgComma
FFFC6B70 C8290913
FFFC6B74 F04FF06F		jmp		ERROR
                        	.paren:
FFFC6B78 FFFC7937		ldi		a0,#msgParen
FFFC6B7C DB790913
FFFC6B80 EF8FF06F		jmp		ERROR
                        	
                        	;*****************************************************
                        	; The following routines are the only ones that need *
                        	; to be changed for a different I/O environment.     *
                        	;*****************************************************
                        	
                        	; ===== Output character to the console (Port 1) from register a0
                        	;	(Preserves all registers.)
                        	;
                        	OUTC:
FFFC6B84 F10F906F		jmp		Putch
                        	
                        	; ===== Input a character from the console into register v0 (or
                        	;	return Zero status if there's no character available).
                        	;
                        	INCH:
FFFC6B88 FFC70713		sub 	$sp,$sp,#4
FFFC6B8C 00172023		sw		$ra,[$sp]
FFFC6B90 ED4F90EF		call	Getch
FFFC6B94 00180813		add		$v0,$v0,#1				; prepare test -1
FFFC6B98 00080A63		beq		$v0,$x0,INCH1			; was = -1
FFFC6B9C FFF80813		sub		$v0,$v0,#1				; get char back
FFFC6BA0 00072083		lw		$ra,[$sp]
FFFC6BA4 00470713		add		$sp,$sp,#4
FFFC6BA8 00008067		ret
                        	INCH1:
FFFC6BAC 00072083		lw		$ra,[$sp]		; return a zero for no-char
FFFC6BB0 00470713		add		$sp,$sp,#4
FFFC6BB4 00008067		ret
                        	
                        	; ===== Return to the resident monitor, operating system, etc.
                        	;
                        	//message "BYEBYE"
                        	BYEBYE:
                        	//	call	ReleaseIOFocus
FFFC6BB8 00030637		lw		$sp,OSSP
FFFC6BBC 00060613
FFFC6BC0 00060633
FFFC6BC4 00062703
FFFC6BC8 F94F906F		jmp		Monitor
                        	 
                        	
FFFC6BCC 53430A0D	msgInit	db	CR,LINEFD,"CS01 Tiny BASIC v1.0",CR,LINEFD,"(C) 2017-2020  Robert Finch",CR,CR,0
FFFC6BD0 54203130
FFFC6BD4 20796E69
FFFC6BD8 49534142
FFFC6BDC 31762043
FFFC6BE0 0A0D302E
FFFC6BE4 20294328
FFFC6BE8 37313032
FFFC6BEC 3230322D
FFFC6BF0 52202030
FFFC6BF4 7265626F
FFFC6BF8 69462074
FFFC6BFC 0D68636E
FFFC6C00 0A0D000D
FFFC6C02 4B4F0A0D	OKMSG	db	CR,LINEFD,"OK",CR,0
FFFC6C06 6857000D
FFFC6C08 74616857	msgWhat	db	"What?",CR,0
FFFC6C0C 53000D3F
FFFC6C0F 72726F53	SRYMSG	db	"Sorry."
FFFC6C13 000D2E79
FFFC6C15 6F43000D	CLMSG	db	CR,0
FFFC6C17 706D6F43	msgReadError	db	"Compact FLASH read error",CR,0
FFFC6C1B 20746361
FFFC6C1F 53414C46
FFFC6C23 65722048
FFFC6C27 65206461
FFFC6C2B 726F7272
FFFC6C2F 754E000D
FFFC6C31 626D754E	msgNumTooBig	db	"Number is too big",CR,0
FFFC6C35 69207265
FFFC6C39 6F742073
FFFC6C3D 6962206F
FFFC6C41 44000D67
FFFC6C44 69766944	msgDivZero		db	"Division by zero",CR,0
FFFC6C48 6E6F6973
FFFC6C4C 20796220
FFFC6C50 6F72657A
FFFC6C54 754F000D
FFFC6C56 2074754F	msgVarSpace     db  "Out of variable space",CR,0
FFFC6C5A 7620666F
FFFC6C5E 61697261
FFFC6C62 20656C62
FFFC6C66 63617073
FFFC6C6A 20000D65
FFFC6C6D 74796220	msgBytesFree	db	" bytes free",CR,0
FFFC6C71 66207365
FFFC6C75 0D656572
FFFC6C79 65520D00
FFFC6C7A 6165520D	msgReady		db	CR,"Ready",CR,0
FFFC6C7E 000D7964
FFFC6C82 65707845	msgComma		db	"Expecting a comma",CR,0
FFFC6C86 6E697463
FFFC6C8A 20612067
FFFC6C8E 6D6D6F63
FFFC6C92 4C000D61
FFFC6C95 656E694C	msgLineRange	db	"Line number too big",CR,0
FFFC6C99 6D756E20
FFFC6C9D 20726562
FFFC6CA1 206F6F74
FFFC6CA5 0D676962
FFFC6CA9 70784500
FFFC6CAA 65707845	msgVar			db "Expecting a variable",CR,0
FFFC6CAE 6E697463
FFFC6CB2 20612067
FFFC6CB6 69726176
FFFC6CBA 656C6261
FFFC6CBE 4E52000D
FFFC6CC0 20444E52	msgRNDBad		db	"RND bad parameter",CR,0
FFFC6CC4 20646162
FFFC6CC8 61726170
FFFC6CCC 6574656D
FFFC6CD0 53000D72
FFFC6CD3 20535953	msgSYSBad		db	"SYS bad address",CR,0
FFFC6CD7 20646162
FFFC6CDB 72646461
FFFC6CDF 0D737365
FFFC6CE3 504E4900
FFFC6CE4 55504E49	msgInputVar		db	"INPUT expecting a variable",CR,0
FFFC6CE8 78652054
FFFC6CEC 74636570
FFFC6CF0 20676E69
FFFC6CF4 61762061
FFFC6CF8 62616972
FFFC6CFC 000D656C
FFFC6D00 5458454E	msgNextFor		db	"NEXT without FOR",CR,0
FFFC6D04 74697720
FFFC6D08 74756F68
FFFC6D0C 524F4620
FFFC6D10 454E000D
FFFC6D12 5458454E	msgNextVar		db	"NEXT expecting a defined variable",CR,0
FFFC6D16 70786520
FFFC6D1A 69746365
FFFC6D1E 6120676E
FFFC6D22 66656420
FFFC6D26 64656E69
FFFC6D2A 72617620
FFFC6D2E 6C626169
FFFC6D32 47000D65
FFFC6D35 4F544F47	msgBadGotoGosub	db	"GOTO/GOSUB bad line number",CR,0
FFFC6D39 534F472F
FFFC6D3D 62204255
FFFC6D41 6C206461
FFFC6D45 20656E69
FFFC6D49 626D756E
FFFC6D4D 000D7265
FFFC6D51 55544552	msgRetWoGosub   db	"RETURN without GOSUB",CR,0
FFFC6D55 77204E52
FFFC6D59 6F687469
FFFC6D5D 47207475
FFFC6D61 4255534F
FFFC6D65 7250000D
FFFC6D67 676F7250	msgTooBig		db	"Program is too big",CR,0
FFFC6D6B 206D6172
FFFC6D6F 74207369
FFFC6D73 62206F6F
FFFC6D77 000D6769
FFFC6D7B 72747845	msgExtraChars	db	"Extra characters on line ignored",CR,0
FFFC6D7F 68632061
FFFC6D83 63617261
FFFC6D87 73726574
FFFC6D8B 206E6F20
FFFC6D8F 656E696C
FFFC6D93 6E676920
FFFC6D97 6465726F
FFFC6D9B 4520000D
FFFC6D9D 766E4520	msgEnvFail		db	" Environment call failed",CR,0
FFFC6DA1 6E6F7269
FFFC6DA5 746E656D
FFFC6DA9 6C616320
FFFC6DAD 6166206C
FFFC6DB1 64656C69
FFFC6DB5 7845000D
FFFC6DB7 65707845	msgParen		db	"Expecting parenthesis",CR,0
FFFC6DBB 6E697463
FFFC6DBF 61702067
FFFC6DC3 746E6572
FFFC6DC7 69736568
FFFC6DCB 00000D73
                        	
                        	LSTROM	equ	*		; end of possible ROM area
;	END
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "SpriteDemo.s",1
                        	.file "SpriteDemo.s",1
                        	.file "SpriteDemo.s",2
                        		code
FFFC6DCE 00730000		align	1
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
                        	public code _EnableSprite:
; 	pSPRCTRL[0x180] = pSPRCTRL[0x180] | (1 << spriteno);
FFFC6DD0 10300073		      	pfi      
FFFC6DD4 FFDAE637		      	ldo      	$t1,4292530176+3072
FFFC6DD8 C0060613
FFFC6DDC 00060633
FFFC6DE0 00063D83
FFFC6DE4 00106E93		      	ldi      	$t3,#1
FFFC6DE8 00073F03		      	ldo      	$t4,0[$sp]
FFFC6DEC 01EE9E33		      	sll      	$t2,$t3,$t4
FFFC6DF0 01CDED33		      	or       	$t0,$t1,$t2
FFFC6DF4 FFDAE637		      	sto      	$t0,4292530176+3072
FFFC6DF8 C0060613
FFFC6DFC 00060633
FFFC6E00 01A63023
                        	SpriteDemo_9:
FFFC6E04 02070713		      	add      	$sp,$sp,#32
FFFC6E08 00008067		      	ret      
                        	endpublic
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC6E0C FE070713	public code _EnableSprites:
	      	sub      	$sp,$sp,#32
FFFC6E10 00273023		      	sto      	$fp,[$sp]
FFFC6E14 00073423		      	sto      	$x0,8[$sp]
FFFC6E18 00076133		      	mov      	$fp,$sp
FFFC6E1C FEE70713		      	sub      	$sp,$sp,#18
FFFC6E20 00473023		      	sto      	$s1,0[$sp]
FFFC6E24 10300073		      	pfi      
                        	; 	unsigned int *pSPRCTRL = ((unsigned __int64 *)0xFFDAD000);
FFFC6E28 FFDAD237		      	ldi      	$s1,#4292530176
FFFC6E2C 00020213
                        	; 	pSPRCTRL[0x180] = pSPRCTRL[0x180] | sprites;
FFFC6E30 00001637		      	ldo      	$t1,3072[$s1]
FFFC6E34 C0060613
FFFC6E38 00460633
FFFC6E3C 00063D83
FFFC6E40 02013E03		      	ldo      	$t2,32[$fp]
FFFC6E44 01CDED33		      	or       	$t0,$t1,$t2
FFFC6E48 00001637		      	sto      	$t0,3072[$s1]
FFFC6E4C C0060613
FFFC6E50 00460633
FFFC6E54 01A63023
                        	SpriteDemo_17:
FFFC6E58 00073203		      	ldo      	$s1,0[$sp]
FFFC6E5C 00016733		      	mov      	$sp,$fp
FFFC6E60 00073103		      	ldo      	$fp,[$sp]
FFFC6E64 02070713		      	add      	$sp,$sp,#32
FFFC6E68 00008067		      	ret      
                        	endpublic
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC6E6C FE070713	public code _RandomizeSpriteColors:
	      	sub      	$sp,$sp,#32
FFFC6E70 00273023		      	sto      	$fp,[$sp]
FFFC6E74 00073423		      	sto      	$x0,8[$sp]
FFFC6E78 00173C23		      	sto      	$ra,24[$sp]
FFFC6E7C 00076133		      	mov      	$fp,$sp
FFFC6E80 FCC70713		      	sub      	$sp,$sp,#52
FFFC6E84 00473023		      	sto      	$s1,0[$sp]
FFFC6E88 10300073		      	pfi      
FFFC6E8C FF813203		      	ldo      	$s1,-8[$fp]
                        	; 	randStream = 0;
FFFC6E90 00025637		      	sto      	$x0,_randStream
FFFC6E94 83060613
FFFC6E98 00060633
FFFC6E9C 00063023
                        	; 	for (colorno = 2; colorno < 256; colorno++) {
FFFC6EA0 00206213		      	ldi      	$s1,#2
FFFC6EA4 10022D13		      	slt      	$t0,$s1,#256
FFFC6EA8 040D0463		      	beqz     	$t0,SpriteDemo_30
                        	SpriteDemo_29:
                        	; 		pSprite[colorno] = GetRand(randStream) & 0xffffffff;
FFFC6EAC 10300073		      	pfi      
FFFC6EB0 00321D13		      	sll      	$t0,$s1,#3
FFFC6EB4 FFDAD637		      	add      	$t0,$t0,#4292530176
FFFC6EB8 00060613
FFFC6EBC 01A60D33
FFFC6EC0 00025637		      	ldo      	$a0,_randStream
FFFC6EC4 83060613
FFFC6EC8 00060633
FFFC6ECC 00063903
FFFC6ED0 D10FD0EF		      	call     	_GetRand
FFFC6ED4 00086E33		      	mov      	$t2,$v0
FFFC6ED8 10300073		      	pfi      
FFFC6EDC FFFE7D93		      	and      	$t1,$t2,#4294967295
FFFC6EE0 01BD3023		      	sto      	$t1,[$t0]
FFFC6EE4 00120213		      	add      	$s1,$s1,#1
FFFC6EE8 10022D13		      	slt      	$t0,$s1,#256
FFFC6EEC FC0D10E3		      	bnez     	$t0,SpriteDemo_29
                        	SpriteDemo_30:
                        	SpriteDemo_25:
                        	SpriteDemo_28:
FFFC6EF0 00073203		      	ldo      	$s1,0[$sp]
FFFC6EF4 00016733		      	mov      	$sp,$fp
FFFC6EF8 00073103		      	ldo      	$fp,[$sp]
FFFC6EFC 01873083		      	ldo      	$ra,24[$sp]
FFFC6F00 02070713		      	add      	$sp,$sp,#32
FFFC6F04 00008067		      	ret      
                        	endpublic
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC6F08 FE070713	public code _SetSpritePos:
	      	sub      	$sp,$sp,#32
FFFC6F0C 00273023		      	sto      	$fp,[$sp]
FFFC6F10 00073423		      	sto      	$x0,8[$sp]
FFFC6F14 00076133		      	mov      	$fp,$sp
FFFC6F18 FEE70713		      	sub      	$sp,$sp,#18
FFFC6F1C 00473023		      	sto      	$s1,0[$sp]
FFFC6F20 10300073		      	pfi      
                        	; 	__int32 *pSprite = &((unsigned __int64 *)0xFFDAD000)[0x100];
FFFC6F24 FFDAE237		      	ldi      	$s1,#4292532224
FFFC6F28 80020213
                        	; 	pSprite[spriteno*4 + 2] = (y << 16) | x;
FFFC6F2C 02013E83		      	ldo      	$t3,32[$fp]
FFFC6F30 002E9E13		      	sll      	$t2,$t3,#2
FFFC6F34 002E1D93		      	sll      	$t1,$t2,#2
FFFC6F38 004D8D33		      	add      	$t0,$t1,$s1
FFFC6F3C 10300073		      	pfi      
FFFC6F40 03413E83		      	ldo      	$t3,52[$fp]
FFFC6F44 010E9E13		      	sll      	$t2,$t3,#16
FFFC6F48 02A13E83		      	ldo      	$t3,42[$fp]
FFFC6F4C 01DE6DB3		      	or       	$t1,$t2,$t3
FFFC6F50 01BD2423		      	stt      	$t1,8[$t0]
                        	SpriteDemo_39:
FFFC6F54 00073203		      	ldo      	$s1,0[$sp]
FFFC6F58 00016733		      	mov      	$sp,$fp
FFFC6F5C 00073103		      	ldo      	$fp,[$sp]
FFFC6F60 02070713		      	add      	$sp,$sp,#32
FFFC6F64 00008067		      	ret      
                        	endpublic
                        	
                        	.file "SpriteDemo.s",127
                        		code
FFFC6F68 00000000		align	1
FFFC6F6C 00000000
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC6F70 FE070713	public code _RandomizeSpritePositions:
	      	sub      	$sp,$sp,#32
FFFC6F74 00273023		      	sto      	$fp,[$sp]
FFFC6F78 00073423		      	sto      	$x0,8[$sp]
FFFC6F7C 00173C23		      	sto      	$ra,24[$sp]
FFFC6F80 00076133		      	mov      	$fp,$sp
FFFC6F84 FA870713		      	sub      	$sp,$sp,#88
FFFC6F88 00473023		      	sto      	$s1,0[$sp]
FFFC6F8C 00573423		      	sto      	$s2,8[$sp]
FFFC6F90 00673823		      	sto      	$s3,16[$sp]
FFFC6F94 00773C23		      	sto      	$s4,24[$sp]
FFFC6F98 10300073		      	pfi      
FFFC6F9C FF813203		      	ldo      	$s1,-8[$fp]
FFFC6FA0 FD813283		      	ldo      	$s2,-40[$fp]
FFFC6FA4 FE413303		      	ldo      	$s3,-28[$fp]
FFFC6FA8 FEE13383		      	ldo      	$s4,-18[$fp]
                        	; 	int spriteno;
FFFC6FAC FFDAE2B7		      	ldi      	$s2,#4292532224
FFFC6FB0 80028293
                        	; 	randStream = 0;
FFFC6FB4 00025637		      	sto      	$x0,_randStream
FFFC6FB8 83060613
FFFC6FBC 00060633
FFFC6FC0 00063023
                        	; 	for (spriteno = 0; spriteno < 64; spriteno++) {
FFFC6FC4 00006233		      	mov      	$s1,$x0
FFFC6FC8 10300073		      	pfi      
FFFC6FCC 04022D13		      	slt      	$t0,$s1,#64
FFFC6FD0 080D0463		      	beqz     	$t0,SpriteDemo_52
                        	SpriteDemo_51:
                        	; 		x = (GetRand(randStream) % 800) + 256;
FFFC6FD4 00025637		      	ldo      	$a0,_randStream
FFFC6FD8 83060613
FFFC6FDC 00060633
FFFC6FE0 00063903
FFFC6FE4 BFCFD0EF		      	call     	_GetRand
FFFC6FE8 00086E33		      	mov      	$t2,$v0
FFFC6FEC 10300073		      	pfi      
FFFC6FF0 32006E93		      	ldi      	$t3,#800
FFFC6FF4 100D8D13		      	add      	$t0,$t1,#256
FFFC6FF8 000D63B3		      	mov      	$s4,$t0
                        	; 		y = (GetRand(randStream) % 600) + 28;
FFFC6FFC 00025637		      	ldo      	$a0,_randStream
FFFC7000 83060613
FFFC7004 00060633
FFFC7008 00063903
FFFC700C BD4FD0EF		      	call     	_GetRand
FFFC7010 00086E33		      	mov      	$t2,$v0
FFFC7014 10300073		      	pfi      
FFFC7018 25806E93		      	ldi      	$t3,#600
FFFC701C 01CD8D13		      	add      	$t0,$t1,#28
FFFC7020 000D6333		      	mov      	$s3,$t0
                        	; 		pSprite[1] = (2560 << 48) | (y << 16) | x;
FFFC7024 01031E13		      	sll      	$t2,$s3,#16
FFFC7028 FFFC8637		      	ldo      	$t3,SpriteDemo_longlit0
FFFC702C 00060613
FFFC7030 00060633
FFFC7034 00063E83
FFFC7038 01DE6DB3		      	or       	$t1,$t2,$t3
FFFC703C 10300073		      	pfi      
FFFC7040 007DED33		      	or       	$t0,$t1,$s4
FFFC7044 01A2B423		      	sto      	$t0,8[$s2]
                        	; 		pSprite += 2;
FFFC7048 01028293		      	add      	$s2,$s2,#16
FFFC704C 00120213		      	add      	$s1,$s1,#1
FFFC7050 04022D13		      	slt      	$t0,$s1,#64
FFFC7054 F80D10E3		      	bnez     	$t0,SpriteDemo_51
                        	SpriteDemo_52:
                        	SpriteDemo_47:
                        	SpriteDemo_50:
FFFC7058 00073203		      	ldo      	$s1,0[$sp]
FFFC705C 00873283		      	ldo      	$s2,8[$sp]
FFFC7060 01073303		      	ldo      	$s3,16[$sp]
FFFC7064 01873383		      	ldo      	$s4,24[$sp]
FFFC7068 00016733		      	mov      	$sp,$fp
FFFC706C 00073103		      	ldo      	$fp,[$sp]
FFFC7070 01873083		      	ldo      	$ra,24[$sp]
FFFC7074 02070713		      	add      	$sp,$sp,#32
FFFC7078 00008067		      	ret      
                        	endpublic
                        	
                        	.file "SpriteDemo.s",211
                        		code
FFFC707C 00000000		align	1
                        	
                        	;====================================================
                        	; Basic Block 0
                        	;====================================================
FFFC7080 FE070713	public code _SpriteDemo:
	      	sub      	$sp,$sp,#32
FFFC7084 00273023		      	sto      	$fp,[$sp]
FFFC7088 00073423		      	sto      	$x0,8[$sp]
FFFC708C 00173C23		      	sto      	$ra,24[$sp]
FFFC7090 00076133		      	mov      	$fp,$sp
FFFC7094 B2670713		      	sub      	$sp,$sp,#1242
FFFC7098 00473023		      	sto      	$s1,0[$sp]
FFFC709C 00573423		      	sto      	$s2,8[$sp]
FFFC70A0 00673823		      	sto      	$s3,16[$sp]
FFFC70A4 00773C23		      	sto      	$s4,24[$sp]
FFFC70A8 02873023		      	sto      	$s5,32[$sp]
FFFC70AC 02973423		      	sto      	$s6,40[$sp]
FFFC70B0 02A73823		      	sto      	$s7,48[$sp]
FFFC70B4 02B73C23		      	sto      	$s8,56[$sp]
FFFC70B8 04C73023		      	sto      	$s9,64[$sp]
FFFC70BC 04D73423		      	sto      	$s10,72[$sp]
FFFC70C0 10300073		      	pfi      
FFFC70C4 FF813203		      	ldo      	$s1,-8[$fp]
FFFC70C8 BDE13283		      	ldo      	$s2,-1058[$fp]
FFFC70CC BD413303		      	ldo      	$s3,-1068[$fp]
FFFC70D0 EF610393		      	lea      	$s4,-266[$fp]
FFFC70D4 DF210413		      	lea      	$s5,-526[$fp]
FFFC70D8 BEA10493		      	lea      	$s6,-1046[$fp]
FFFC70DC BC013503		      	ldo      	$s7,-1088[$fp]
FFFC70E0 10300073		      	pfi      
FFFC70E4 CEE10593		      	lea      	$s8,-786[$fp]
FFFC70E8 BB613603		      	ldo      	$s9,-1098[$fp]
FFFC70EC BA013683		      	ldo      	$s10,-1120[$fp]
                        	; 	int spriteno;
FFFC70F0 FFDAED37		      	ldi      	$t0,#4292532224
FFFC70F4 800D0D13
FFFC70F8 BBA13423		      	sto      	$t0,-1112[$fp]
FFFC70FC 10300073		      	pfi      
FFFC7100 000109B7		      	ldi      	$a1,#65536
FFFC7104 00098993
FFFC7108 00006933		      	mov      	$a0,$x0
FFFC710C 910FA0EF		      	call     	_Alloc
FFFC7110 00086D33		      	mov      	$t0,$v0
FFFC7114 000D66B3		      	mov      	$s10,$t0
                        	; 	randStream = 0;
FFFC7118 10300073		      	pfi      
FFFC711C 00025637		      	sto      	$x0,_randStream
FFFC7120 83060613
FFFC7124 00060633
FFFC7128 00063023
                        	; 	RandomizeSpriteColors();
FFFC712C D41FF0EF		      	call     	_RandomizeSpriteColors
                        	; 	EnableSprites(-1);
FFFC7130 FFF06D13		      	ldi      	$t0,#-1
FFFC7134 01A73423		      	sto      	$t0,8[$sp]
FFFC7138 CD5FF0EF		      	call     	_EnableSprites
FFFC713C 00870713		      	add      	$sp,$sp,#8
                        	; 	for (n = 0; n < 64 * 32 * 4; n = n + 1)
FFFC7140 10300073		      	pfi      
FFFC7144 000062B3		      	mov      	$s2,$x0
FFFC7148 00002637		      	slt      	$t0,$s2,#8192
FFFC714C 00060613
FFFC7150 060D0463		      	beqz     	$t0,SpriteDemo_96
                        	SpriteDemo_95:
                        	; 		pImages[n] = GetRand(randStream)|(GetRand(randStream)<<32);
FFFC7154 10300073		      	pfi      
FFFC7158 00329D13		      	sll      	$t0,$s2,#3
FFFC715C 01A68D33		      	add      	$t0,$s10,$t0
FFFC7160 00025637		      	ldo      	$a0,_randStream
FFFC7164 83060613
FFFC7168 00060633
FFFC716C 00063903
FFFC7170 A70FD0EF		      	call     	_GetRand
FFFC7174 00086E33		      	mov      	$t2,$v0
FFFC7178 10300073		      	pfi      
FFFC717C 00025637		      	ldo      	$a0,_randStream
FFFC7180 83060613
FFFC7184 00060633
FFFC7188 00063903
FFFC718C A54FD0EF		      	call     	_GetRand
FFFC7190 00086F33		      	mov      	$t4,$v0
FFFC7194 000F1E93		      	sll      	$t3,$t4,#32
FFFC7198 01DE6DB3		      	or       	$t1,$t2,$t3
FFFC719C 01BD3023		      	sto      	$t1,[$t0]
FFFC71A0 00128D13		      	add      	$t0,$s2,#1
FFFC71A4 000D62B3		      	mov      	$s2,$t0
FFFC71A8 10300073		      	pfi      
FFFC71AC 00002637		      	slt      	$t0,$s2,#8192
FFFC71B0 00060613
FFFC71B4 FA0D10E3		      	bnez     	$t0,SpriteDemo_95
                        	SpriteDemo_96:
                        	; 	x = 256; y = 64;
FFFC71B8 10006513		      	ldi      	$s7,#256
FFFC71BC 04006613		      	ldi      	$s9,#64
                        	; 	for (spriteno = 0; spriteno < 64; spriteno++) {
FFFC71C0 00006233		      	mov      	$s1,$x0
FFFC71C4 04022D13		      	slt      	$t0,$s1,#64
FFFC71C8 0A0D0063		      	beqz     	$t0,SpriteDemo_99
                        	SpriteDemo_98:
                        	; 		pSprite[spriteno*2] = VirtToPhys(0,&pImages[spriteno * 128]);
FFFC71CC 10300073		      	pfi      
FFFC71D0 00121D93		      	sll      	$t1,$s1,#1
FFFC71D4 003D9D13		      	sll      	$t0,$t1,#3
FFFC71D8 BA813E03		      	ldo      	$t2,-1112[$fp]
FFFC71DC 01AE0D33		      	add      	$t0,$t2,$t0
FFFC71E0 10300073		      	pfi      
FFFC71E4 B7A13B23		      	sto      	$t0,-1162[$fp]
FFFC71E8 00721E93		      	sll      	$t3,$s1,#7
FFFC71EC 003E9E13		      	sll      	$t2,$t3,#3
FFFC71F0 00DE09B3		      	add      	$a1,$t2,$s10
FFFC71F4 00006933		      	mov      	$a0,$x0
FFFC71F8 910FA0EF		      	call     	_VirtToPhys
FFFC71FC B7613D03		      	ldo      	$t0,-1162[$fp]
FFFC7200 00086DB3		      	mov      	$t1,$v0
FFFC7204 01BD3023		      	sto      	$t1,[$t0]
                        	; 		xpos[spriteno] = x;
FFFC7208 10300073		      	pfi      
FFFC720C 00221D13		      	sll      	$t0,$s1,#2
FFFC7210 01A38D33		      	add      	$t0,$s4,$t0
FFFC7214 00AD2023		      	stt      	$s7,[$t0]
                        	; 		ypos[spriteno] = y;
FFFC7218 10300073		      	pfi      
FFFC721C 00221D13		      	sll      	$t0,$s1,#2
FFFC7220 01A40D33		      	add      	$t0,$s5,$t0
FFFC7224 00CD2023		      	stt      	$s9,[$t0]
                        	; 		SetSpritePos(spriteno, x, y);
FFFC7228 10300073		      	pfi      
FFFC722C 00C73C23		      	sto      	$s9,24[$sp]
FFFC7230 00A73C23		      	sto      	$s7,24[$sp]
FFFC7234 00473C23		      	sto      	$s1,24[$sp]
FFFC7238 CD1FF0EF		      	call     	_SetSpritePos
FFFC723C 01870713		      	add      	$sp,$sp,#24
                        	; 		x += 20;
FFFC7240 10300073		      	pfi      
FFFC7244 01450513		      	add      	$s7,$s7,#20
                        	; 		if (x >= 800) {
FFFC7248 32052D13		      	slt      	$t0,$s7,#800
FFFC724C 000D1663		      	bnez     	$t0,SpriteDemo_101
                        	; 			x = 256;
FFFC7250 10006513		      	ldi      	$s7,#256
                        	; 			y += 64;
FFFC7254 04060613		      	add      	$s9,$s9,#64
                        	SpriteDemo_101:
FFFC7258 00120213		      	add      	$s1,$s1,#1
FFFC725C 10300073		      	pfi      
FFFC7260 04022D13		      	slt      	$t0,$s1,#64
FFFC7264 F60D14E3		      	bnez     	$t0,SpriteDemo_98
                        	SpriteDemo_99:
                        	; 	for (spriteno = 0; spriteno < 64; spriteno++) {
FFFC7268 00006233		      	mov      	$s1,$x0
FFFC726C 10300073		      	pfi      
FFFC7270 04022D13		      	slt      	$t0,$s1,#64
FFFC7274 060D0C63		      	beqz     	$t0,SpriteDemo_104
                        	SpriteDemo_103:
                        	; 		dx[spriteno] = (GetRand(randStream) & 15) - 8;
FFFC7278 00221D13		      	sll      	$t0,$s1,#2
FFFC727C 01A58D33		      	add      	$t0,$s8,$t0
FFFC7280 00025637		      	ldo      	$a0,_randStream
FFFC7284 83060613
FFFC7288 00060633
FFFC728C 00063903
FFFC7290 950FD0EF		      	call     	_GetRand
FFFC7294 00086EB3		      	mov      	$t3,$v0
FFFC7298 10300073		      	pfi      
FFFC729C 00FEFE13		      	and      	$t2,$t3,#15
FFFC72A0 FF8E0D93		      	sub      	$t1,$t2,#8
FFFC72A4 01BD2023		      	stt      	$t1,[$t0]
                        	; 		dy[spriteno] = (GetRand(randStream) & 15) - 8;
FFFC72A8 00221D13		      	sll      	$t0,$s1,#2
FFFC72AC 10300073		      	pfi      
FFFC72B0 01A48D33		      	add      	$t0,$s6,$t0
FFFC72B4 00025637		      	ldo      	$a0,_randStream
FFFC72B8 83060613
FFFC72BC 00060633
FFFC72C0 00063903
FFFC72C4 91CFD0EF		      	call     	_GetRand
FFFC72C8 00086EB3		      	mov      	$t3,$v0
FFFC72CC 10300073		      	pfi      
FFFC72D0 00FEFE13		      	and      	$t2,$t3,#15
FFFC72D4 FF8E0D93		      	sub      	$t1,$t2,#8
FFFC72D8 01BD2023		      	stt      	$t1,[$t0]
FFFC72DC 00120213		      	add      	$s1,$s1,#1
FFFC72E0 10300073		      	pfi      
FFFC72E4 04022D13		      	slt      	$t0,$s1,#64
FFFC72E8 F80D18E3		      	bnez     	$t0,SpriteDemo_103
                        	SpriteDemo_104:
                        	; 	for (n = 0; n < 64 * 32 * 2; n = n + 1)
FFFC72EC 000062B3		      	mov      	$s2,$x0
FFFC72F0 00001637		      	slt      	$t0,$s2,#4096
FFFC72F4 00060613
FFFC72F8 040D0263		      	beqz     	$t0,SpriteDemo_107
                        	SpriteDemo_106:
                        	; 		pImages[n] = GetRand(randStream);
FFFC72FC 10300073		      	pfi      
FFFC7300 00329D13		      	sll      	$t0,$s2,#3
FFFC7304 01A68D33		      	add      	$t0,$s10,$t0
FFFC7308 00025637		      	ldo      	$a0,_randStream
FFFC730C 83060613
FFFC7310 00060633
FFFC7314 00063903
FFFC7318 8C8FD0EF		      	call     	_GetRand
FFFC731C 00086DB3		      	mov      	$t1,$v0
FFFC7320 01BD3023		      	sto      	$t1,[$t0]
FFFC7324 10300073		      	pfi      
FFFC7328 00128D13		      	add      	$t0,$s2,#1
FFFC732C 000D62B3		      	mov      	$s2,$t0
FFFC7330 00001637		      	slt      	$t0,$s2,#4096
FFFC7334 00060613
FFFC7338 FC0D12E3		      	bnez     	$t0,SpriteDemo_106
                        	SpriteDemo_107:
                        	SpriteDemo_109:
                        	; 		btn = GetButton();
FFFC733C 10300073		      	pfi      
                        	; 	__asm {
                        		      	;asm     	
FFFC7340 FFDC0637				ldt		$v0,BUTTONS
FFFC7344 60060613
FFFC7348 00060633
FFFC734C 00062803
FFFC7350 01085813				srl		$v0,$v0,#16
FFFC7354 01F87813				and		$v0,$v0,#$1F
                        	; 	}
FFFC7358 00086D33		      	mov      	$t0,$v0
FFFC735C BDA13523		      	sto      	$t0,-1078[$fp]
                        	; 		for (m = 0; m < 50000; m++);	// Timing delay
FFFC7360 00006333		      	mov      	$s3,$x0
FFFC7364 0000C637		      	slt      	$t0,$s3,#50000
FFFC7368 35060613
FFFC736C 000D0C63		      	beqz     	$t0,SpriteDemo_115
                        	SpriteDemo_114:
FFFC7370 10300073		      	pfi      
FFFC7374 00130313		      	add      	$s3,$s3,#1
FFFC7378 0000C637		      	slt      	$t0,$s3,#50000
FFFC737C 35060613
FFFC7380 FE0D18E3		      	bnez     	$t0,SpriteDemo_114
                        	SpriteDemo_115:
                        	; 		for (spriteno = 0; spriteno < 64; spriteno++) {
FFFC7384 00006233		      	mov      	$s1,$x0
FFFC7388 04022D13		      	slt      	$t0,$s1,#64
FFFC738C 140D0863		      	beqz     	$t0,SpriteDemo_118
                        	SpriteDemo_117:
                        	; 			xpos[spriteno] = xpos[spriteno] + dx[spriteno];
FFFC7390 10300073		      	pfi      
FFFC7394 00221D13		      	sll      	$t0,$s1,#2
FFFC7398 01A38D33		      	add      	$t0,$s4,$t0
FFFC739C 00221E13		      	sll      	$t2,$s1,#2
FFFC73A0 01C38E33		      	add      	$t2,$s4,$t2
FFFC73A4 10300073		      	pfi      
FFFC73A8 00221E93		      	sll      	$t3,$s1,#2
FFFC73AC 01D58EB3		      	add      	$t3,$s8,$t3
FFFC73B0 01DE0DB3		      	add      	$t1,$t2,$t3
FFFC73B4 01BD2023		      	stt      	$t1,[$t0]
                        	; 			ypos[spriteno] = ypos[spriteno] + dy[spriteno];
FFFC73B8 10300073		      	pfi      
FFFC73BC 00221D13		      	sll      	$t0,$s1,#2
FFFC73C0 01A40D33		      	add      	$t0,$s5,$t0
FFFC73C4 00221E13		      	sll      	$t2,$s1,#2
FFFC73C8 01C40E33		      	add      	$t2,$s5,$t2
FFFC73CC 10300073		      	pfi      
FFFC73D0 00221E93		      	sll      	$t3,$s1,#2
FFFC73D4 01D48EB3		      	add      	$t3,$s6,$t3
FFFC73D8 01DE0DB3		      	add      	$t1,$t2,$t3
FFFC73DC 01BD2023		      	stt      	$t1,[$t0]
                        	; 			if (xpos[spriteno] < 256) {
FFFC73E0 10300073		      	pfi      
FFFC73E4 00221D13		      	sll      	$t0,$s1,#2
FFFC73E8 01A38D33		      	add      	$t0,$s4,$t0
FFFC73EC 100D2D93		      	slt      	$t1,$t0,#256
FFFC73F0 020D8663		      	beqz     	$t1,SpriteDemo_120
                        	; 				xpos[spriteno] = 256;
FFFC73F4 10300073		      	pfi      
                        	; 				dx[spriteno] = -dx[spriteno];
FFFC73F8 00221D13		      	sll      	$t0,$s1,#2
FFFC73FC 01A58D33		      	add      	$t0,$s8,$t0
FFFC7400 10300073		      	pfi      
FFFC7404 00221E13		      	sll      	$t2,$s1,#2
FFFC7408 01C58E33		      	add      	$t2,$s8,$t2
FFFC740C 001B1C01		      	neg      	$t1,$t2
FFFC7410 1B010005
FFFC7411 1B1B0100		      	sxh      	$t1,$t1
FFFC7415 23000A00
FFFC7417 BD202300		      	stt      	$t1,[$t0]
FFFC741B 30007301
                        	SpriteDemo_120:
                        	; 			if (xpos[spriteno] >= 816) {
FFFC741C 10300073		      	pfi      
FFFC7420 00221D13		      	sll      	$t0,$s1,#2
FFFC7424 01A38D33		      	add      	$t0,$s4,$t0
FFFC7428 330D2D93		      	slt      	$t1,$t0,#816
FFFC742C 020D9463		      	bnez     	$t1,SpriteDemo_122
                        	; 				xpos[spriteno] = 816;
FFFC7430 10300073		      	pfi      
                        	; 				dx[spriteno] = -dx[spriteno];
FFFC7434 00221D13		      	sll      	$t0,$s1,#2
FFFC7438 01A58D33		      	add      	$t0,$s8,$t0
FFFC743C 00221E13		      	sll      	$t2,$s1,#2
FFFC7440 01C58E33		      	add      	$t2,$s8,$t2
FFFC7444 001B1C01		      	neg      	$t1,$t2
FFFC7448 1B010005
FFFC7449 1B1B0100		      	sxh      	$t1,$t1
FFFC744D 23000A00
FFFC744F BD202300		      	stt      	$t1,[$t0]
FFFC7453 30007301
                        	SpriteDemo_122:
                        	; 			if (ypos[spriteno] < 28) {
FFFC7454 10300073		      	pfi      
FFFC7458 00221D13		      	sll      	$t0,$s1,#2
FFFC745C 01A40D33		      	add      	$t0,$s5,$t0
FFFC7460 01CD2D93		      	slt      	$t1,$t0,#28
FFFC7464 020D8663		      	beqz     	$t1,SpriteDemo_124
                        	; 				ypos[spriteno] = 28;
FFFC7468 10300073		      	pfi      
                        	; 				dy[spriteno] = -dy[spriteno];
FFFC746C 00221D13		      	sll      	$t0,$s1,#2
FFFC7470 01A48D33		      	add      	$t0,$s6,$t0
FFFC7474 10300073		      	pfi      
FFFC7478 00221E13		      	sll      	$t2,$s1,#2
FFFC747C 01C48E33		      	add      	$t2,$s6,$t2
FFFC7480 001B1C01		      	neg      	$t1,$t2
FFFC7484 1B010005
FFFC7485 1B1B0100		      	sxh      	$t1,$t1
FFFC7489 23000A00
FFFC748B BD202300		      	stt      	$t1,[$t0]
FFFC748F 30007301
                        	SpriteDemo_124:
                        	; 			if (ypos[spriteno] >= 614)
FFFC7490 10300073		      	pfi      
FFFC7494 00221D13		      	sll      	$t0,$s1,#2
FFFC7498 01A40D33		      	add      	$t0,$s5,$t0
FFFC749C 266D2D93		      	slt      	$t1,$t0,#614
FFFC74A0 000D9663		      	bnez     	$t1,SpriteDemo_126
                        	; 				ypos[spriteno] = 614;
FFFC74A4 10300073		      	pfi      
FFFC74A8 26606D13		      	ldi      	$t0,#614
                        	SpriteDemo_126:
                        	; 				dy[spriteno] = -dy[spriteno];
FFFC74AC 00221D13		      	sll      	$t0,$s1,#2
FFFC74B0 01A48D33		      	add      	$t0,$s6,$t0
FFFC74B4 00221E13		      	sll      	$t2,$s1,#2
FFFC74B8 01C48E33		      	add      	$t2,$s6,$t2
FFFC74BC 001B1C01		      	neg      	$t1,$t2
FFFC74C0 1B010005
FFFC74C1 1B1B0100		      	sxh      	$t1,$t1
FFFC74C5 23000A00
FFFC74C7 BD202300		      	stt      	$t1,[$t0]
FFFC74CB 30007301
FFFC74CC 10300073		      	pfi      
FFFC74D0 00120213		      	add      	$s1,$s1,#1
FFFC74D4 04022D13		      	slt      	$t0,$s1,#64
FFFC74D8 EA0D1CE3		      	bnez     	$t0,SpriteDemo_117
                        	SpriteDemo_118:
                        	; 			SetSpritePos(spriteno, (int)xpos[spriteno], (int)ypos[spriteno]);
FFFC74DC 10300073		      	pfi      
FFFC74E0 00221D13		      	sll      	$t0,$s1,#2
FFFC74E4 01A40D33		      	add      	$t0,$s5,$t0
FFFC74E8 01A73C23		      	sto      	$t0,24[$sp]
FFFC74EC 10300073		      	pfi      
FFFC74F0 00221D13		      	sll      	$t0,$s1,#2
FFFC74F4 01A38D33		      	add      	$t0,$s4,$t0
FFFC74F8 01A73C23		      	sto      	$t0,24[$sp]
FFFC74FC 00473C23		      	sto      	$s1,24[$sp]
FFFC7500 A09FF0EF		      	call     	_SetSpritePos
FFFC7504 01870713		      	add      	$sp,$sp,#24
FFFC7508 E2000AE3		      	bra      	SpriteDemo_109
                        	SpriteDemo_91:
                        	SpriteDemo_94:
FFFC750C 00073203		      	ldo      	$s1,0[$sp]
FFFC7510 00873283		      	ldo      	$s2,8[$sp]
FFFC7514 01073303		      	ldo      	$s3,16[$sp]
FFFC7518 01873383		      	ldo      	$s4,24[$sp]
FFFC751C 02073403		      	ldo      	$s5,32[$sp]
FFFC7520 02873483		      	ldo      	$s6,40[$sp]
FFFC7524 03073503		      	ldo      	$s7,48[$sp]
FFFC7528 03873583		      	ldo      	$s8,56[$sp]
FFFC752C 04073603		      	ldo      	$s9,64[$sp]
FFFC7530 04873683		      	ldo      	$s10,72[$sp]
FFFC7534 00016733		      	mov      	$sp,$fp
FFFC7538 00073103		      	ldo      	$fp,[$sp]
FFFC753C 01873083		      	ldo      	$ra,24[$sp]
FFFC7540 02070713		      	add      	$sp,$sp,#32
FFFC7544 00008067		      	ret      
                        	endpublic
                        	
                        		rodata
                        		align	16                        	
                        		extern	_tcbs
	extern	_nMsgBlk
	extern	_mmu_Free512kPage
	extern	_mmu_Alloc8kPage
	extern	_mmu_alloc
	extern	_IOFocusTbl
	extern	_outb
	extern	_outc
	extern	_mmu_MapCardMemory
	extern	_FMTK_StartApp
	extern	_outh
	extern	_irq_stack
	extern	_IOFocusNdx
	extern	_DumpTaskList
;	global	_GetImLevel
                        		extern	_outw
	extern	_fmtk_irq_stack
	extern	_mmu_SetOperateKey
	extern	_keybdControlCodes
	extern	_fmtk_sys_stack
	extern	_message
	extern	_mailbox
	extern	_FMTK_Inited
;	global	_UnlockIOFSemaphore
                        		extern	_KeybdSetLED
	extern	_mmu_AllocateMap
	extern	_FMTK_StartThread
;	global	_DBGCheckForKey
                        		extern	_GetRunningACBPtr
	extern	_KeyLED
	extern	_hFocusSwitchMbx
	extern	_KeybdClearRcv
	extern	_missed_ticks
;	global	_SetVBA
                        		extern	_mmu_SetMapEntry
	extern	_LockIOFSemaphore
	extern	_chkTCB
;	global	_UnlockSemaphore
                        	;	global	_DBGGetKey
                        		extern	_mmu_Alloc512kPage
	extern	_GetVecno
	extern	_GetACBPtr
;	global	_UnlockKbdSemaphore
                        		extern	_video_bufs
	extern	_getCPU
;	global	_LEDS
                        		extern	_hasUltraHighPriorityTasks
	extern	_LockSemaphore
	extern	_keybdExtendedCodes
	extern	_iof_switch
	extern	_KeybdGetScancode
	extern	_kbd_sema
	extern	_DeviceTable
	extern	_nMailbox
	extern	_unshiftedScanCodes
	extern	_set_vector
	extern	_LockKbdSemaphore
	extern	_FMTK_SendMsg
	extern	_iof_sema
	extern	_sys_stacks
	extern	_FocusSwitcher
	extern	_BIOS_RespMbx
	extern	_FMTK_WaitMsg
	extern	_mmu_FreeMap
	extern	_mmu_Free8kPage
	extern	_mmu_free
	extern	_mmu_SetAccessKey
	extern	_shiftedScanCodes
	extern	_KeyState1
	extern	_KeyState2
	extern	_BIOS1_sema
	extern	_sys_sema
	extern	_readyQ
	extern	_LockSysSemaphore
	extern	_ACBPtrs
	extern	_sysstack
	extern	_freeTCB
	extern	_RequestIOFocus
	extern	_TimeoutList
	extern	_RemoveFromTimeoutList
	extern	_stacks
	extern	_freeMSG
	extern	_freeMBX
	extern	_SetBound50
	extern	_SetBound51
	extern	_GetAppHandle
	extern	_SetBound48
	extern	_SetBound49
	extern	_InsertIntoTimeoutList
;	global	_RestoreImLevel
                        		extern	_RemoveFromReadyList
	extern	_KeybdGetStatus
	extern	_bios_stacks
	extern	_FMTK_Reschedule
	extern	_InsertIntoReadyList
.file "boot.r5a",1
                        	.file "TinyBasic.r5a",1
                        	;****************************************************************;
                        	;                                                                ;
                        	;		Tiny BASIC for the CS01                                      ;
                        	;                                                                ;
                        	; Derived from a 68000 derivative of Palo Alto Tiny BASIC as     ;
                        	; published in the May 1976 issue of Dr. Dobb's Journal.         ;
                        	; Adapted to the 68000 by:                                       ;
                        	;	Gordon brndly						                         ;
                        	;	12147 - 51 Street					                         ;
                        	;	Edmonton AB  T5W 3G8					                     ;
                        	;	Canada							                             ;
                        	;	(updated mailing address for 1996)			                 ;
                        	;                                                                ;
                        	; Adapted to the CS01 by:                                        ;
                        	;    Robert Finch                                                ;
                        	;    Ontario, Canada                                             ;
                        	;	 robfinch<remove>@finitron.ca    	                             ;  
                        	;****************************************************************;
                        	;  Copyright (C) 2016-2020 by Robert Finch. This program may be	 ;
                        	;    freely distributed for personal use only. All commercial	 ;
                        	;		       rights are reserved.			                     ;
                        	;****************************************************************;
                        	;
                        	; Register Usage
                        	; $t2 = text pointer (global usage)
                        	; r3,r4 = inputs parameters to subroutines
                        	; a1 = return value
                        	;
                        	;* Vers. 1.0  1984/7/17	- Original version by Gordon brndly
                        	;*	1.1  1984/12/9	- Addition of '0x' print term by Marvin Lipford
                        	;*	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                        	
                        	CR		EQU	0x0D		;ASCII equates
                        	LINEFD	EQU	0x0A		; Don't use LF (same as load float instruction)
                        	TAB		EQU	0x09
                        	CTRLC	EQU	0x03
                        	CTRLH	EQU	0x08
                        	CTRLI	EQU	0x09
                        	CTRLJ	EQU	0x0A
                        	CTRLK	EQU	0x0B
                        	CTRLM   EQU 0x0D
                        	CTRLS	EQU	0x13
                        	CTRLX	EQU	0x18
                        	XON		EQU	0x11
                        	XOFF	EQU	0x13
                        	
                        	FILENAME	EQU		0x3F6C0
                        	FILEBUF		EQU		0x03F600
                        	OSSP		EQU		0x30000
                        	TXTUNF		EQU		OSSP+4
                        	VARBGN		EQU		TXTUNF+4
                        	VAREND		EQU		VARBGN+4
                        	LOPVAR		EQU		VAREND+4
                        	STKGOS		EQU		LOPVAR+4
                        	CURRNT		EQU		STKGOS+4
                        	BUFFER		EQU		CURRNT+4
                        	BUFLEN		EQU		84
                        	LOPPT		EQU		BUFFER+84
                        	LOPLN		EQU		LOPPT+4
                        	LOPINC		EQU		LOPLN+4
                        	LOPLMT		EQU		LOPINC+4
                        	NUMWKA		EQU		LOPLMT+24
                        	STKINP		EQU		NUMWKA+4
                        	STKBOT		EQU		STKINP+4
                        	usrJmp		EQU		STKBOT+4
                        	IRQROUT		EQU		usrJmp+4
                        	
                        	OUTPTR		EQU		IRQROUT+4
                        	INPPTR		EQU		OUTPTR+4
                        	CursorFlash	EQU		INPPTR+4
                        	IRQFlag		EQU		CursorFlash+4
                        	
                        	;
                        	; Modifiable system constants:
                        	;
                        	;THRD_AREA	dw	0x04000000	; threading switch area 0x04000000-0x40FFFFF
                        	;bitmap dw	0x00100000	; bitmap graphics memory 0x04100000-0x417FFFF
                        	TXTBGN		EQU		0x031800	;TXT ;beginning of program memory
                        	ENDMEM		EQU		0x03FFFC	; end of available memory
                        	STACKOFFS	EQU		0xAFFFC000	; stack offset
                        	
                        	
                        		rodata
                        		align	16                        	
                        		align	8                        	
                        	SpriteDemo_longlit0:
FFFC8000 0000048D80000000		dco	A00000000000000
                        		extern	_GetRand
;	global	_EnableSprite
                        	;	global	_SetSpritePos
                        	;	global	_RandomizeSpritePositions
                        		extern	_Alloc
;	global	_SpriteDemo
                        		extern	_VirtToPhys
	extern	_randStream
;	global	_EnableSprites
                        	;	global	_RandomizeSpriteColors
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	
                        		rodata
                        		align 8                        	
                        	begin_init_data:
                        	_begin_init_data:
                        		data
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9000 00000000            		fill.b	4,0x00
FFFC9004 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
FFFC9008 00000000            		fill.b	4,0x00
FFFC900C 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9010 0000000000000000		fill.b	40,0x00
FFFC9018 0000000000000000
FFFC9020 0000000000000000
FFFC9028 0000000000000000
FFFC9030 0000000000000000
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9038 0000000000000000		fill.b	6,0x00
FFFC903E 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9040 0000000000000000		fill.b	20,0x00
FFFC9048 0000000000000000
FFFC9050 00000000            
FFFC9054 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9058 0000000000000000		fill.b	8,0x00
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9060 0000000000000000		fill.b	944,0x00
FFFC9068 0000000000000000
FFFC9070 0000000000000000
FFFC9078 0000000000000000
FFFC9080 0000000000000000
FFFC9088 0000000000000000
FFFC9090 0000000000000000
FFFC9098 0000000000000000
FFFC90A0 0000000000000000
FFFC90A8 0000000000000000
FFFC90B0 0000000000000000
FFFC90B8 0000000000000000
FFFC90C0 0000000000000000
FFFC90C8 0000000000000000
FFFC90D0 0000000000000000
FFFC90D8 0000000000000000
FFFC90E0 0000000000000000
FFFC90E8 0000000000000000
FFFC90F0 0000000000000000
FFFC90F8 0000000000000000
FFFC9100 0000000000000000
FFFC9108 0000000000000000
FFFC9110 0000000000000000
FFFC9118 0000000000000000
FFFC9120 0000000000000000
FFFC9128 0000000000000000
FFFC9130 0000000000000000
FFFC9138 0000000000000000
FFFC9140 0000000000000000
FFFC9148 0000000000000000
FFFC9150 0000000000000000
FFFC9158 0000000000000000
FFFC9160 0000000000000000
FFFC9168 0000000000000000
FFFC9170 0000000000000000
FFFC9178 0000000000000000
FFFC9180 0000000000000000
FFFC9188 0000000000000000
FFFC9190 0000000000000000
FFFC9198 0000000000000000
FFFC91A0 0000000000000000
FFFC91A8 0000000000000000
FFFC91B0 0000000000000000
FFFC91B8 0000000000000000
FFFC91C0 0000000000000000
FFFC91C8 0000000000000000
FFFC91D0 0000000000000000
FFFC91D8 0000000000000000
FFFC91E0 0000000000000000
FFFC91E8 0000000000000000
FFFC91F0 0000000000000000
FFFC91F8 0000000000000000
FFFC9200 0000000000000000
FFFC9208 0000000000000000
FFFC9210 0000000000000000
FFFC9218 0000000000000000
FFFC9220 0000000000000000
FFFC9228 0000000000000000
FFFC9230 0000000000000000
FFFC9238 0000000000000000
FFFC9240 0000000000000000
FFFC9248 0000000000000000
FFFC9250 0000000000000000
FFFC9258 0000000000000000
FFFC9260 0000000000000000
FFFC9268 0000000000000000
FFFC9270 0000000000000000
FFFC9278 0000000000000000
FFFC9280 0000000000000000
FFFC9288 0000000000000000
FFFC9290 0000000000000000
FFFC9298 0000000000000000
FFFC92A0 0000000000000000
FFFC92A8 0000000000000000
FFFC92B0 0000000000000000
FFFC92B8 0000000000000000
FFFC92C0 0000000000000000
FFFC92C8 0000000000000000
FFFC92D0 0000000000000000
FFFC92D8 0000000000000000
FFFC92E0 0000000000000000
FFFC92E8 0000000000000000
FFFC92F0 0000000000000000
FFFC92F8 0000000000000000
FFFC9300 0000000000000000
FFFC9308 0000000000000000
FFFC9310 0000000000000000
FFFC9318 0000000000000000
FFFC9320 0000000000000000
FFFC9328 0000000000000000
FFFC9330 0000000000000000
FFFC9338 0000000000000000
FFFC9340 0000000000000000
FFFC9348 0000000000000000
FFFC9350 0000000000000000
FFFC9358 0000000000000000
FFFC9360 0000000000000000
FFFC9368 0000000000000000
FFFC9370 0000000000000000
FFFC9378 0000000000000000
FFFC9380 0000000000000000
FFFC9388 0000000000000000
FFFC9390 0000000000000000
FFFC9398 0000000000000000
FFFC93A0 0000000000000000
FFFC93A8 0000000000000000
FFFC93B0 0000000000000000
FFFC93B8 0000000000000000
FFFC93C0 0000000000000000
FFFC93C8 0000000000000000
FFFC93D0 0000000000000000
FFFC93D8 0000000000000000
FFFC93E0 0000000000000000
FFFC93E8 0000000000000000
FFFC93F0 0000000000000000
FFFC93F8 0000000000000000
FFFC9400 0000000000000000
FFFC9408 0000000000000000
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9410 0000000000000000		fill.b	8,0x00
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		data
                        		align	8                        	
                        		data
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		data
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        	
FFFC9418 0000000000000000		rodata
FFFC9420 0000000000000000
FFFC9428 0000000000000000
FFFC9430 0000000000000000
FFFC9438 0000000000000000
FFFC9440 0000000000000000
FFFC9448 0000000000000000
FFFC9450 0000000000000000
FFFC9458 0000000000000000
FFFC9460 0000000000000000
FFFC9468 0000000000000000
FFFC9470 0000000000000000
FFFC9478 0000000000000000
FFFC9480 0000000000000000
FFFC9488 0000000000000000
FFFC9490 0000000000000000
FFFC9498 0000000000000000
FFFC94A0 0000000000000000
FFFC94A8 0000000000000000
FFFC94B0 0000000000000000
FFFC94B8 0000000000000000
FFFC94C0 0000000000000000
FFFC94C8 0000000000000000
FFFC94D0 0000000000000000
FFFC94D8 0000000000000000
FFFC94E0 0000000000000000
FFFC94E8 0000000000000000
FFFC94F0 0000000000000000
FFFC94F8 0000000000000000
FFFC9500 0000000000000000
FFFC9508 0000000000000000
FFFC9510 0000000000000000
FFFC9518 0000000000000000
FFFC9520 0000000000000000
FFFC9528 0000000000000000
FFFC9530 0000000000000000
FFFC9538 0000000000000000
FFFC9540 0000000000000000
FFFC9548 0000000000000000
FFFC9550 0000000000000000
FFFC9558 0000000000000000
FFFC9560 0000000000000000
FFFC9568 0000000000000000
FFFC9570 0000000000000000
FFFC9578 0000000000000000
FFFC9580 0000000000000000
FFFC9588 0000000000000000
FFFC9590 0000000000000000
FFFC9598 0000000000000000
FFFC95A0 0000000000000000
FFFC95A8 0000000000000000
FFFC95B0 0000000000000000
FFFC95B8 0000000000000000
FFFC95C0 0000000000000000
FFFC95C8 0000000000000000
FFFC95D0 0000000000000000
FFFC95D8 0000000000000000
FFFC95E0 0000000000000000
FFFC95E8 0000000000000000
FFFC95F0 0000000000000000
FFFC95F8 0000000000000000
FFFC9600 0000000000000000
FFFC9608 0000000000000000
FFFC9610 0000000000000000
FFFC9618 0000000000000000
FFFC9620 0000000000000000
FFFC9628 0000000000000000
FFFC9630 0000000000000000
FFFC9638 0000000000000000
FFFC9640 0000000000000000
FFFC9648 0000000000000000
FFFC9650 0000000000000000
FFFC9658 0000000000000000
FFFC9660 0000000000000000
FFFC9668 0000000000000000
FFFC9670 0000000000000000
FFFC9678 0000000000000000
FFFC9680 0000000000000000
FFFC9688 0000000000000000
FFFC9690 0000000000000000
FFFC9698 0000000000000000
FFFC96A0 0000000000000000
FFFC96A8 0000000000000000
FFFC96B0 0000000000000000
FFFC96B8 0000000000000000
FFFC96C0 0000000000000000
FFFC96C8 0000000000000000
FFFC96D0 0000000000000000
FFFC96D8 0000000000000000
FFFC96E0 0000000000000000
FFFC96E8 0000000000000000
FFFC96F0 0000000000000000
FFFC96F8 0000000000000000
FFFC9700 0000000000000000
FFFC9708 0000000000000000
FFFC9710 0000000000000000
FFFC9718 0000000000000000
FFFC9720 0000000000000000
FFFC9728 0000000000000000
FFFC9730 0000000000000000
FFFC9738 0000000000000000
FFFC9740 0000000000000000
FFFC9748 0000000000000000
FFFC9750 0000000000000000
FFFC9758 0000000000000000
FFFC9760 0000000000000000
FFFC9768 0000000000000000
FFFC9770 0000000000000000
FFFC9778 0000000000000000
FFFC9780 0000000000000000
FFFC9788 0000000000000000
FFFC9790 0000000000000000
FFFC9798 0000000000000000
FFFC97A0 0000000000000000
FFFC97A8 0000000000000000
FFFC97B0 0000000000000000
FFFC97B8 0000000000000000
FFFC97C0 0000000000000000
FFFC97C8 0000000000000000
FFFC97D0 0000000000000000
FFFC97D8 0000000000000000
FFFC97E0 0000000000000000
FFFC97E8 0000000000000000
FFFC97F0 0000000000000000
FFFC97F8 0000000000000000
FFFC9800 0000000000000000
FFFC9808 0000000000000000
FFFC9810 0000000000000000
FFFC9818 0000000000000000
FFFC9820 0000000000000000
FFFC9828 0000000000000000
FFFC9830 0000000000000000
FFFC9838 0000000000000000
FFFC9840 0000000000000000
FFFC9848 0000000000000000
FFFC9850 0000000000000000
FFFC9858 0000000000000000
FFFC9860 0000000000000000
FFFC9868 0000000000000000
FFFC9870 0000000000000000
FFFC9878 0000000000000000
FFFC9880 0000000000000000
FFFC9888 0000000000000000
FFFC9890 0000000000000000
FFFC9898 0000000000000000
FFFC98A0 0000000000000000
FFFC98A8 0000000000000000
FFFC98B0 0000000000000000
FFFC98B8 0000000000000000
FFFC98C0 0000000000000000
FFFC98C8 0000000000000000
FFFC98D0 0000000000000000
FFFC98D8 0000000000000000
FFFC98E0 0000000000000000
FFFC98E8 0000000000000000
FFFC98F0 0000000000000000
FFFC98F8 0000000000000000
FFFC9900 0000000000000000
FFFC9908 0000000000000000
FFFC9910 0000000000000000
FFFC9918 0000000000000000
FFFC9920 0000000000000000
FFFC9928 0000000000000000
FFFC9930 0000000000000000
FFFC9938 0000000000000000
FFFC9940 0000000000000000
FFFC9948 0000000000000000
FFFC9950 0000000000000000
FFFC9958 0000000000000000
FFFC9960 0000000000000000
FFFC9968 0000000000000000
FFFC9970 0000000000000000
FFFC9978 0000000000000000
FFFC9980 0000000000000000
FFFC9988 0000000000000000
FFFC9990 0000000000000000
FFFC9998 0000000000000000
FFFC99A0 0000000000000000
FFFC99A8 0000000000000000
FFFC99B0 0000000000000000
FFFC99B8 0000000000000000
FFFC99C0 0000000000000000
FFFC99C8 0000000000000000
FFFC99D0 0000000000000000
FFFC99D8 0000000000000000
FFFC99E0 0000000000000000
FFFC99E8 0000000000000000
FFFC99F0 0000000000000000
FFFC99F8 0000000000000000
FFFC9A00 0000000000000000
FFFC9A08 0000000000000000
FFFC9A10 0000000000000000
FFFC9A18 0000000000000000
FFFC9A20 0000000000000000
FFFC9A28 0000000000000000
FFFC9A30 0000000000000000
FFFC9A38 0000000000000000
FFFC9A40 0000000000000000
FFFC9A48 0000000000000000
FFFC9A50 0000000000000000
FFFC9A58 0000000000000000
FFFC9A60 0000000000000000
FFFC9A68 0000000000000000
FFFC9A70 0000000000000000
FFFC9A78 0000000000000000
FFFC9A80 0000000000000000
FFFC9A88 0000000000000000
FFFC9A90 0000000000000000
FFFC9A98 0000000000000000
FFFC9AA0 0000000000000000
FFFC9AA8 0000000000000000
FFFC9AB0 0000000000000000
FFFC9AB8 0000000000000000
FFFC9AC0 0000000000000000
FFFC9AC8 0000000000000000
FFFC9AD0 0000000000000000
FFFC9AD8 0000000000000000
FFFC9AE0 0000000000000000
FFFC9AE8 0000000000000000
FFFC9AF0 0000000000000000
FFFC9AF8 0000000000000000
FFFC9B00 0000000000000000
FFFC9B08 0000000000000000
FFFC9B10 0000000000000000
FFFC9B18 0000000000000000
FFFC9B20 0000000000000000
FFFC9B28 0000000000000000
FFFC9B30 0000000000000000
FFFC9B38 0000000000000000
FFFC9B40 0000000000000000
FFFC9B48 0000000000000000
FFFC9B50 0000000000000000
FFFC9B58 0000000000000000
FFFC9B60 0000000000000000
FFFC9B68 0000000000000000
FFFC9B70 0000000000000000
FFFC9B78 0000000000000000
FFFC9B80 0000000000000000
FFFC9B88 0000000000000000
FFFC9B90 0000000000000000
FFFC9B98 0000000000000000
FFFC9BA0 0000000000000000
FFFC9BA8 0000000000000000
FFFC9BB0 0000000000000000
FFFC9BB8 0000000000000000
FFFC9BC0 0000000000000000
FFFC9BC8 0000000000000000
FFFC9BD0 0000000000000000
FFFC9BD8 0000000000000000
FFFC9BE0 0000000000000000
FFFC9BE8 0000000000000000
FFFC9BF0 0000000000000000
FFFC9BF8 0000000000000000
FFFC9C00 0000000000000000
FFFC9C08 0000000000000000
FFFC9C10 0000000000000000
FFFC9C18 0000000000000000
FFFC9C20 0000000000000000
FFFC9C28 0000000000000000
FFFC9C30 0000000000000000
FFFC9C38 0000000000000000
FFFC9C40 0000000000000000
FFFC9C48 0000000000000000
FFFC9C50 0000000000000000
FFFC9C58 0000000000000000
FFFC9C60 0000000000000000
FFFC9C68 0000000000000000
FFFC9C70 0000000000000000
FFFC9C78 0000000000000000
FFFC9C80 0000000000000000
FFFC9C88 0000000000000000
FFFC9C90 0000000000000000
FFFC9C98 0000000000000000
FFFC9CA0 0000000000000000
FFFC9CA8 0000000000000000
FFFC9CB0 0000000000000000
FFFC9CB8 0000000000000000
FFFC9CC0 0000000000000000
FFFC9CC8 0000000000000000
FFFC9CD0 0000000000000000
FFFC9CD8 0000000000000000
FFFC9CE0 0000000000000000
FFFC9CE8 0000000000000000
FFFC9CF0 0000000000000000
FFFC9CF8 0000000000000000
FFFC9D00 0000000000000000
FFFC9D08 0000000000000000
FFFC9D10 0000000000000000
FFFC9D18 0000000000000000
FFFC9D20 0000000000000000
FFFC9D28 0000000000000000
FFFC9D30 0000000000000000
FFFC9D38 0000000000000000
FFFC9D40 0000000000000000
FFFC9D48 0000000000000000
FFFC9D50 0000000000000000
FFFC9D58 0000000000000000
FFFC9D60 0000000000000000
FFFC9D68 0000000000000000
FFFC9D70 0000000000000000
FFFC9D78 0000000000000000
FFFC9D80 0000000000000000
FFFC9D88 0000000000000000
FFFC9D90 0000000000000000
FFFC9D98 0000000000000000
FFFC9DA0 0000000000000000
FFFC9DA8 0000000000000000
FFFC9DB0 0000000000000000
FFFC9DB8 0000000000000000
FFFC9DC0 0000000000000000
FFFC9DC8 0000000000000000
FFFC9DD0 0000000000000000
FFFC9DD8 0000000000000000
FFFC9DE0 0000000000000000
FFFC9DE8 0000000000000000
FFFC9DF0 0000000000000000
FFFC9DF8 0000000000000000
FFFC9E00 0000000000000000
FFFC9E08 0000000000000000
FFFC9E10 0000000000000000
FFFC9E18 0000000000000000
FFFC9E20 0000000000000000
FFFC9E28 0000000000000000
FFFC9E30 0000000000000000
FFFC9E38 0000000000000000
FFFC9E40 0000000000000000
FFFC9E48 0000000000000000
FFFC9E50 0000000000000000
FFFC9E58 0000000000000000
FFFC9E60 0000000000000000
FFFC9E68 0000000000000000
FFFC9E70 0000000000000000
FFFC9E78 0000000000000000
FFFC9E80 0000000000000000
FFFC9E88 0000000000000000
FFFC9E90 0000000000000000
FFFC9E98 0000000000000000
FFFC9EA0 0000000000000000
FFFC9EA8 0000000000000000
FFFC9EB0 0000000000000000
FFFC9EB8 0000000000000000
FFFC9EC0 0000000000000000
FFFC9EC8 0000000000000000
FFFC9ED0 0000000000000000
FFFC9ED8 0000000000000000
FFFC9EE0 0000000000000000
FFFC9EE8 0000000000000000
FFFC9EF0 0000000000000000
FFFC9EF8 0000000000000000
FFFC9F00 0000000000000000
FFFC9F08 0000000000000000
FFFC9F10 0000000000000000
FFFC9F18 0000000000000000
FFFC9F20 0000000000000000
FFFC9F28 0000000000000000
FFFC9F30 0000000000000000
FFFC9F38 0000000000000000
FFFC9F40 0000000000000000
FFFC9F48 0000000000000000
FFFC9F50 0000000000000000
FFFC9F58 0000000000000000
FFFC9F60 0000000000000000
FFFC9F68 0000000000000000
FFFC9F70 0000000000000000
FFFC9F78 0000000000000000
FFFC9F80 0000000000000000
FFFC9F88 0000000000000000
FFFC9F90 0000000000000000
FFFC9F98 0000000000000000
FFFC9FA0 0000000000000000
FFFC9FA8 0000000000000000
FFFC9FB0 0000000000000000
FFFC9FB8 0000000000000000
FFFC9FC0 0000000000000000
FFFC9FC8 0000000000000000
FFFC9FD0 0000000000000000
FFFC9FD8 0000000000000000
FFFC9FE0 0000000000000000
FFFC9FE8 0000000000000000
FFFC9FF0 0000000000000000
FFFC9FF8 0000000000000000
                        		align 8                        	
                        	end_init_data:
                        	_end_init_data:
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9418 00000000            		fill.b	4,0x00
FFFC941C 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
FFFC9420 00000000            		fill.b	4,0x00
FFFC9424 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9428 0000000000000000		fill.b	40,0x00
FFFC9430 0000000000000000
FFFC9438 0000000000000000
FFFC9440 0000000000000000
FFFC9448 0000000000000000
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9450 0000000000000000		fill.b	6,0x00
FFFC9456 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9458 0000000000000000		fill.b	20,0x00
FFFC9460 0000000000000000
FFFC9468 00000000            
FFFC946C 00000000            		align	
                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9470 0000000000000000		fill.b	8,0x00
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9478 0000000000000000		fill.b	944,0x00
FFFC9480 0000000000000000
FFFC9488 0000000000000000
FFFC9490 0000000000000000
FFFC9498 0000000000000000
FFFC94A0 0000000000000000
FFFC94A8 0000000000000000
FFFC94B0 0000000000000000
FFFC94B8 0000000000000000
FFFC94C0 0000000000000000
FFFC94C8 0000000000000000
FFFC94D0 0000000000000000
FFFC94D8 0000000000000000
FFFC94E0 0000000000000000
FFFC94E8 0000000000000000
FFFC94F0 0000000000000000
FFFC94F8 0000000000000000
FFFC9500 0000000000000000
FFFC9508 0000000000000000
FFFC9510 0000000000000000
FFFC9518 0000000000000000
FFFC9520 0000000000000000
FFFC9528 0000000000000000
FFFC9530 0000000000000000
FFFC9538 0000000000000000
FFFC9540 0000000000000000
FFFC9548 0000000000000000
FFFC9550 0000000000000000
FFFC9558 0000000000000000
FFFC9560 0000000000000000
FFFC9568 0000000000000000
FFFC9570 0000000000000000
FFFC9578 0000000000000000
FFFC9580 0000000000000000
FFFC9588 0000000000000000
FFFC9590 0000000000000000
FFFC9598 0000000000000000
FFFC95A0 0000000000000000
FFFC95A8 0000000000000000
FFFC95B0 0000000000000000
FFFC95B8 0000000000000000
FFFC95C0 0000000000000000
FFFC95C8 0000000000000000
FFFC95D0 0000000000000000
FFFC95D8 0000000000000000
FFFC95E0 0000000000000000
FFFC95E8 0000000000000000
FFFC95F0 0000000000000000
FFFC95F8 0000000000000000
FFFC9600 0000000000000000
FFFC9608 0000000000000000
FFFC9610 0000000000000000
FFFC9618 0000000000000000
FFFC9620 0000000000000000
FFFC9628 0000000000000000
FFFC9630 0000000000000000
FFFC9638 0000000000000000
FFFC9640 0000000000000000
FFFC9648 0000000000000000
FFFC9650 0000000000000000
FFFC9658 0000000000000000
FFFC9660 0000000000000000
FFFC9668 0000000000000000
FFFC9670 0000000000000000
FFFC9678 0000000000000000
FFFC9680 0000000000000000
FFFC9688 0000000000000000
FFFC9690 0000000000000000
FFFC9698 0000000000000000
FFFC96A0 0000000000000000
FFFC96A8 0000000000000000
FFFC96B0 0000000000000000
FFFC96B8 0000000000000000
FFFC96C0 0000000000000000
FFFC96C8 0000000000000000
FFFC96D0 0000000000000000
FFFC96D8 0000000000000000
FFFC96E0 0000000000000000
FFFC96E8 0000000000000000
FFFC96F0 0000000000000000
FFFC96F8 0000000000000000
FFFC9700 0000000000000000
FFFC9708 0000000000000000
FFFC9710 0000000000000000
FFFC9718 0000000000000000
FFFC9720 0000000000000000
FFFC9728 0000000000000000
FFFC9730 0000000000000000
FFFC9738 0000000000000000
FFFC9740 0000000000000000
FFFC9748 0000000000000000
FFFC9750 0000000000000000
FFFC9758 0000000000000000
FFFC9760 0000000000000000
FFFC9768 0000000000000000
FFFC9770 0000000000000000
FFFC9778 0000000000000000
FFFC9780 0000000000000000
FFFC9788 0000000000000000
FFFC9790 0000000000000000
FFFC9798 0000000000000000
FFFC97A0 0000000000000000
FFFC97A8 0000000000000000
FFFC97B0 0000000000000000
FFFC97B8 0000000000000000
FFFC97C0 0000000000000000
FFFC97C8 0000000000000000
FFFC97D0 0000000000000000
FFFC97D8 0000000000000000
FFFC97E0 0000000000000000
FFFC97E8 0000000000000000
FFFC97F0 0000000000000000
FFFC97F8 0000000000000000
FFFC9800 0000000000000000
FFFC9808 0000000000000000
FFFC9810 0000000000000000
FFFC9818 0000000000000000
FFFC9820 0000000000000000
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
FFFC9828 0000000000000000		fill.b	8,0x00
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		data
                        		align	8                        	
                        		data
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		data
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
                        		align	8                        	
1249 symbols
  Symbol Name                              seg     address bits
  A00000000000000                          rodata  800000000000048d 32
  ABS                                        code  fffc60dc 18
  ABS1                                       code  fffc60f0 18
  ADDEXPR                                    code  fffc5c54 18
  ALLOCMBX                                   code  fffc69a0 18
  ALLOCMBX.0001                              code  fffc69c4 18
  ALLOCMBX.0002                              code  fffc69f4 18
  ALLOCMBX.paren                             code  fffc6a04 18
  ANDEXPR                                    code  fffc5a40 18
  AUXIN                                      code  80000000000002e7 32
  AUXIN_INIT                                 code  80000000000003ba 32
  AUXOCRLF                                   code  fffc5880 18
  AUXOUT                                     code  80000000000002e5 32
  AUXOUT_FLUSH                               code  80000000000003c7 32
  AUXOUT_INIT                                code  80000000000003be 32
  Alloc                                      code  fffc114c 18
  Alloc.0001                                 code  fffc11d0 18
  Alloc.enough                               code  fffc1190 18
  Alloc.noRun                                code  fffc11f8 18
  Alloc.noRun2                               code  fffc1188 18
  Alloc.xit                                  code  fffc1200 18
  AllocInCurrentAS                           code  fffc1140 18
  AllocStack                                 code  fffc1244 18
  AllocStack.0001                            code  fffc1274 18
  AllocStack.xit                             code  fffc128c 18
  AllocTCB                                   code  fffc3504 18
  AllocTCB.0001                              code  fffc3518 18
  AllocTCB.0002                              code  fffc3550 18
  AllocTCB.0003                              code  fffc3560 18
  AllocTCB.allocTid                          code  fffc3544 18
  BASPRMPT                                   code  fffc4b68 18
  BIOSCallTbl                                code  fffc0f88 18
  BIOS_ClearScreen                           code  fffc0f90 18
  BIOS_HomeCursor                            code  fffc0f94 18
  BIOS_MUTEX                                const  ffdbff08 33
  BIOS_VideoPutChar                          code  fffc0f98 18
  BIOS_VideoPutString                        code  fffc0f9c 18
  BS                                        const  000008 5
  BUFFER                                    const  03001c 19
  BUFLEN                                    const  000054 8
  BUTTONS                                   const  ffdc0600 33
  BYEBYE                                     code  fffc6bb8 18
  CHKIO                                      code  fffc6958 18
  CHKRET                                     code  fffc6974 18
  CLMSG                                      code  fffc6c15 18
  CR                                        const  00000d 5
  CRLF                                       code  fffc6980 18
  CSR_REGSET                                const  000790 12
  CSTART                                     code  fffc4a30 32
  CTRLC                                     const  000003 3
  CTRLH                                     const  000008 5
  CTRLI                                     const  000009 5
  CTRLJ                                     const  00000a 5
  CTRLK                                     const  00000b 5
  CTRLM                                     const  00000d 5
  CTRLS                                     const  000013 6
  CTRLX                                     const  000018 6
  CURRNT                                    const  030018 19
  CopyDevFuncTbl                             code  fffc3a80 18
  CopyDevFuncTbl.again                       code  fffc3a94 18
  CursorFlash                               const  0300b0 19
  CursorX                                   const  024800 19
  CursorY                                   const  024801 19
  DBGKeybd_100                               code  fffc4624 18
  DBGKeybd_101                               code  fffc4674 18
  DBGKeybd_102                               code  fffc4698 18
  DBGKeybd_103                               code  fffc4808 18
  DBGKeybd_104                               code  fffc482c 18
  DBGKeybd_105                               code  fffc4868 18
  DBGKeybd_106                               code  fffc4964 18
  DBGKeybd_107                               code  fffc4898 18
  DBGKeybd_108                               code  fffc4964 18
  DBGKeybd_109                               code  fffc48ec 18
  DBGKeybd_111                               code  fffc491c 18
  DBGKeybd_113                               code  fffc494c 18
  DBGKeybd_5                                 code  fffc4440 18
  DBGKeybd_62                                code  fffc44e4 18
  DBGKeybd_65                                code  fffc44e4 18
  DBGKeybd_66                                code  fffc449c 18
  DBGKeybd_68                                code  fffc44b4 18
  DBGKeybd_69                                code  fffc44cc 18
  DBGKeybd_71                                code  fffc44cc 18
  DBGKeybd_72                                code  fffc44dc 18
  DBGKeybd_73                                code  fffc4518 18
  DBGKeybd_74                                code  fffc4508 18
  DBGKeybd_76                                code  fffc4534 18
  DBGKeybd_77                                code  fffc4540 18
  DBGKeybd_79                                code  fffc4964 18
  DBGKeybd_8                                 code  fffc4440 18
  DBGKeybd_90                                code  fffc4584 18
  DBGKeybd_91                                code  fffc459c 18
  DBGKeybd_92                                code  fffc45c4 18
  DBGKeybd_93                                code  fffc4638 18
  DBGKeybd_94                                code  fffc46ac 18
  DBGKeybd_95                                code  fffc470c 18
  DBGKeybd_96                                code  fffc476c 18
  DBGKeybd_97                                code  fffc47cc 18
  DBGKeybd_98                                code  fffc4840 18
  DBGKeybd_99                                code  fffc4600 18
  DCB_LastErc                               const  000018 6
  DCB_Mbx                                   const  000048 8
  DCB_Name                                  const  000000 1
  DCB_ReentCount                            const  000038 7
  DCB_Resv1                                 const  000058 8
  DCB_Resv2                                 const  000060 8
  DCB_Size                                  const  000068 8
  DCB_StartBlock                            const  000020 7
  DCB_Type                                  const  00000c 5
  DCB_fSingleUser                           const  000039 7
  DCB_hJob                                  const  000040 8
  DCB_nBPB                                  const  000010 6
  DCB_nBlocks                               const  000028 7
  DCB_pCmdProc                              const  000030 7
  DCB_pSema                                 const  000050 8
  DEFLT                                      code  fffc55c8 18
  DEL                                       const  00007f 8
  DIRECT                                     code  fffc4e60 18
  DOQUO                                      code  fffc6918 18
  DOQUO1                                     code  fffc6924 18
  DRSP_DONE                                 const  000001 2
  DVC_BuildBPB                              const  000005 4
  DVC_Close                                 const  000007 4
  DVC_FlushInput                            const  000014 6
  DVC_FlushOutput                           const  000015 6
  DVC_GetChar                               const  000008 5
  DVC_GetCharDirect                         const  00000a 5
  DVC_IOCTRL_READ                           const  000018 6
  DVC_IOCTRL_WRITE                          const  000019 6
  DVC_IRQ                                   const  000016 6
  DVC_Initialize                            const  000002 3
  DVC_InputStatus                           const  00000c 5
  DVC_IsRemoveable                          const  000017 6
  DVC_MediaCheck                            const  000004 4
  DVC_Nop                                   const  000000 1
  DVC_Open                                  const  000006 4
  DVC_OutputStatus                          const  000013 6
  DVC_OutputUntilBusy                       const  00001a 6
  DVC_PeekChar                              const  000009 5
  DVC_PeekCharDirect                        const  00000b 5
  DVC_PutChar                               const  00000d 5
  DVC_ReadBlock                             const  000010 6
  DVC_SetPosition                           const  00000f 5
  DVC_Setup                                 const  000001 2
  DVC_Status                                const  000003 3
  DVC_VerifyBlock                           const  000012 6
  DVC_WriteBlock                            const  000011 6
  DVF_Base                                  const  022000 19
  DVF_Limit                                 const  024000 19
  DeleteLine                                 code  fffc4c20 18
  DeleteLine.0001                            code  fffc4c4c 18
  DeleteLine.0002                            code  fffc4c38 18
  DeleteLine.0003                            code  fffc4c50 18
  DispAttr                                  const  024808 19
  DumpMemmap                                 code  fffc0944 18
  DumpMemmap.again                           code  fffc095c 18
  DumpReadyList                              code  fffc35b0 18
  DumpReadyList.0001                         code  fffc362c 18
  DumpReadyList.0002                         code  fffc35e8 18
  DumpReadyList.brk                          code  fffc3674 18
  DumpReadyList.nxt                          code  fffc3668 18
  DumpTimeoutList                            code  fffc36a0 18
  DumpTimeoutList.0002                       code  fffc36dc 18
  DumpTimeoutList.brk                        code  fffc3714 18
  ENDCHK                                     code  fffc6228 18
  ENDMEM                                    const  03fffc 19
  ERETx                                      code  8000000000000250 32
  ERROR                                      code  fffc6278 18
  ERROR1                                     code  fffc62d0 18
  EX1                                        code  fffc4eac 18
  EXEC                                       code  fffc4e70 18
  EXGO                                       code  fffc4ed4 18
  EXLP                                       code  fffc4e7c 18
  EXMAT                                      code  fffc4ec0 18
  EXNGO                                      code  fffc4e94 18
  EXPR                                       code  fffc5b30 18
  E_Arg                                     const  000001 2
  E_BadAlarm                                const  000011 6
  E_BadBlockNum                             const  000025 7
  E_BadCallno                               const  00001a 6
  E_BadDevNum                               const  000020 7
  E_BadDevOp                                const  000022 7
  E_BadMbx                                  const  000004 4
  E_DCBInUse                                const  000019 6
  E_NoDev                                   const  000021 7
  E_NoMem                                   const  00000c 5
  E_NoMoreAlarmBlks                         const  000044 8
  E_NoMoreMbx                               const  000040 8
  E_NoMoreMsgBlks                           const  000041 8
  E_NoMoreTCBs                              const  000045 8
  E_NoMsg                                   const  00000b 5
  E_NoThread                                const  000006 4
  E_NotAlloc                                const  000009 5
  E_NotOwner                                const  000012 6
  E_Ok                                      const  000000 1
  E_QueFull                                 const  000005 4
  E_QueStrategy                             const  000013 6
  E_ReadError                               const  000023 7
  E_Timeout                                 const  000010 6
  E_TooManyBlocks                           const  000026 7
  E_WriteError                              const  000024 7
  EditMem                                    code  fffc06b8 18
  FFFC0100                                   code  80000000000002d7 32
  FI1                                        code  fffc6208 18
  FI2                                        code  fffc621c 18
  FILEBUF                                   const  03f600 19
  FILENAME                                  const  03f6c0 19
  FIN                                        code  fffc61ec 18
  FINISH                                     code  fffc51f8 18
  FMTKInit                                   code  fffc214c 18
  FMTKInit.0001                              code  fffc2228 18
  FMTKInit.0002                              code  fffc2260 18
  FMTKInit.0003                              code  fffc2208 18
  FMTK_AllocMbx                              code  fffc2cf8 18
  FMTK_AllocMbx.badArg                       code  fffc2da0 18
  FMTK_AllocMbx.lock                         code  fffc2d20 18
  FMTK_AllocMbx.noOwner                      code  fffc2d6c 18
  FMTK_AllocMbx.nxt                          code  fffc2d48 18
  FMTK_AllocMbx.xit                          code  fffc2da4 18
  FMTK_AllocVideoBuf                         code  fffc2c50 18
  FMTK_AllocVideoBuf.err                     code  fffc2c84 18
  FMTK_ExitTask                              code  fffc2b58 18
  FMTK_ExitTask.xit                          code  fffc2b7c 18
  FMTK_ForceReleaseIOFocus                   code  fffc395c 18
  FMTK_ForceReleaseIOFocus.0001              code  fffc3a24 18
  FMTK_ForceReleaseIOFocus.done              code  fffc3a30 18
  FMTK_ForceReleaseIOFocus.noFocus           code  fffc3a30 18
  FMTK_ForceReleaseIOFocus.noSwitch          code  fffc3970 18
  FMTK_ForceReleaseIOFocus.notSame           code  fffc39f0 18
  FMTK_ForceReleaseIOFocus.pjSame            code  fffc3a10 18
  FMTK_FreeMbx                               code  fffc2dc8 18
  FMTK_FreeMbx.0001                          code  fffc2e6c 18
  FMTK_FreeMbx.0002                          code  fffc2e30 18
  FMTK_FreeMbx.0003                          code  fffc2e60 18
  FMTK_FreeMbx.badMbx                        code  fffc2e84 18
  FMTK_FreeMbx.lock                          code  fffc2e04 18
  FMTK_FreeMbx.xit                           code  fffc2e88 18
  FMTK_GetCurrentTid                         code  fffc229c 18
  FMTK_HasIOFocus                            code  fffc37a0 18
  FMTK_HasIOFocus.hasFocus                   code  fffc37f4 18
  FMTK_HasIOFocus.noSwitch                   code  fffc37cc 18
  FMTK_HasIOFocus.xit                        code  fffc37f8 18
  FMTK_IO                                    code  fffc3a38 18
  FMTK_IO.badDev                             code  fffc3a78 18
  FMTK_IO.badFunc                            code  fffc3a70 18
  FMTK_IO.xit                                code  fffc3a6c 18
  FMTK_Initialize                            code  80000000000001ca 32
  FMTK_KillTask                              code  fffc2b88 18
  FMTK_KillTask.immortal                     code  fffc2c40 18
  FMTK_KillTask.lock                         code  fffc2bac 18
  FMTK_PeekMsg                               code  fffc3020 18
  FMTK_PeekMsg.badMbx                        code  fffc3128 18
  FMTK_PeekMsg.lock                          code  fffc3050 18
  FMTK_PeekMsg.noMsg                         code  fffc311c 18
  FMTK_PeekMsg.nod1                          code  fffc30e0 18
  FMTK_PeekMsg.nod2                          code  fffc30f8 18
  FMTK_PeekMsg.nod3                          code  fffc3110 18
  FMTK_PeekMsg.nodq                          code  fffc30c0 18
  FMTK_PeekMsg.ret                           code  fffc312c 18
  FMTK_PostMsg                               code  80000000000001d2 32
  FMTK_ReleaseIOFocus                        code  fffc3950 18
  FMTK_RequestIOFocus                        code  fffc38b8 18
  FMTK_RequestIOFocus.notEmpty               code  fffc3930 18
  FMTK_RequestIOFocus.ret                    code  fffc3948 18
  FMTK_SaveContext                           code  fffc2364 18
  FMTK_SchedulerIRQ                          code  fffc27cc 18
  FMTK_SchedulerIRQ.0001                     code  fffc2850 18
  FMTK_SchedulerIRQ.0002                     code  fffc2948 18
  FMTK_SchedulerIRQ.0003                     code  fffc2964 18
  FMTK_SchedulerIRQ.0004                     code  fffc2980 18
  FMTK_SchedulerIRQ.dq                       code  fffc28fc 18
  FMTK_SchedulerIRQ.goodTid                  code  fffc28fc 18
  FMTK_SchedulerIRQ.noException              code  fffc2918 18
  FMTK_SchedulerIRQ.noLock                   code  fffc29c8 18
  FMTK_SchedulerIRQ.noMsg                    code  fffc298c 18
  FMTK_SchedulerIRQ.noTimeout                code  fffc2884 18
  FMTK_SchedulerIRQ.notZero                  code  fffc2884 18
  FMTK_SchedulerIRQ.nxtQ                     code  fffc28d4 18
  FMTK_SchedulerIRQ.searchQ                  code  fffc2894 18
  FMTK_SendMsg                               code  fffc2eac 18
  FMTK_SendMsg.0001                          code  fffc2f14 18
  FMTK_SendMsg.badMbx                        code  fffc2ff8 18
  FMTK_SendMsg.lock                          code  fffc2ee0 18
  FMTK_SendMsg.mbxEmpty                      code  fffc2fd8 18
  FMTK_SendMsg.noMsg                         code  fffc2fec 18
  FMTK_SendMsg.noWaiters                     code  fffc2f84 18
  FMTK_SendMsg.nxtTid                        code  fffc2f64 18
  FMTK_SendMsg.xit                           code  fffc2ffc 18
  FMTK_SetTaskPriority                       code  80000000000001ce 32
  FMTK_Sleep                                 code  fffc2660 18
  FMTK_Sleep.0001                            code  fffc26cc 18
  FMTK_Sleep.0002                            code  fffc2750 18
  FMTK_Sleep.0003                            code  fffc276c 18
  FMTK_Sleep.0004                            code  fffc2788 18
  FMTK_Sleep.lock                            code  fffc2684 18
  FMTK_Sleep.noException                     code  fffc2724 18
  FMTK_Sleep.noMsg                           code  fffc2794 18
  FMTK_Sleep.xit                             code  fffc27ac 18
  FMTK_StartApp                              code  80000000000001d6 32
  FMTK_StartTask                             code  fffc29d4 18
  FMTK_StartTask.err                         code  fffc2b4c 18
  FMTK_StartTask.lock                        code  fffc29f4 18
  FMTK_StartTask.xit                         code  fffc2b40 18
  FMTK_SwitchIOFocus                         code  fffc3800 18
  FMTK_SwitchIOFocus.0001                    code  fffc3844 18
  FMTK_SwitchIOFocus.0002                    code  fffc385c 18
  FMTK_SwitchIOFocus.0003                    code  fffc3880 18
  FMTK_SwitchIOFocus.0004                    code  fffc3898 18
  FMTK_SwitchIOFocus.noFocus                 code  fffc38a8 18
  FMTK_SwitchIOFocus.sameFocus               code  fffc38a8 18
  FMTK_WaitMsg                               code  fffc3150 18
  FMTK_WaitMsg.lock                          code  fffc318c 18
  FMTK_WaitMsg.qt                            code  fffc3174 18
  FMTK_WaitMsg.xit                           code  fffc3214 18
  FNDLN                                      code  fffc63e0 18
  FNDLNP                                     code  fffc6400 18
  FNDNXT                                     code  fffc6468 18
  FNDRET                                     code  fffc643c 18
  FNDRET.0001                                code  fffc6440 18
  FNDRET1                                    code  fffc6458 18
  FNDRET2                                    code  fffc6460 18
  FNDSKP                                     code  fffc646c 18
  FOR                                        code  fffc52dc 18
  FORCEFIT                                   code  fffc5b08 18
  FORCEFIT.0001                              code  fffc5b2c 18
  FORCEFIT.intAnd                            code  fffc5b1c 18
  FR1                                        code  fffc5308 18
  FR2                                        code  fffc5330 18
  FR3                                        code  fffc5338 18
  FR4                                        code  fffc533c 18
  FR5                                        code  fffc534c 18
  FR6                                        code  fffc5394 18
  FR7                                        code  fffc5398 18
  FR8                                        code  fffc53b8 18
  FUNCEXPR                                   code  fffc5d88 18
  FillMem                                    code  fffc06d8 18
  FillMem.0001                               code  fffc0700 18
  FindRun                                    code  fffc1064 18
  FindRun.0001                               code  fffc1088 18
  FindRun.0002                               code  fffc109c 18
  FindRun.0003                               code  fffc1080 18
  FindRun.empty0                             code  fffc10a4 18
  FindRun.empty1                             code  fffc10a8 18
  FindRun.foundEnough                        code  fffc10c8 18
  FindStackRun                               code  fffc10d4 18
  FindStackRun.0001                          code  fffc10f8 18
  FindStackRun.0002                          code  fffc110c 18
  FindStackRun.0003                          code  fffc10f4 18
  FindStackRun.empty0                        code  fffc1114 18
  FindStackRun.empty1                        code  fffc1114 18
  FindStackRun.foundEnough                   code  fffc1134 18
  FreeAll                                    code  fffc129c 18
  FreeAll.0001                               code  fffc1304 18
  FreeAll.nxt                                code  fffc12a4 18
  FreeMsg                                   const  024350 19
  FreeTCB                                    code  fffc357c 18
  GCHAR                                      code  fffc5658 18
  GCHAR1                                     code  fffc5670 18
  GETLN                                      code  fffc62d4 18
  GETLN.GL1                                  code  fffc62f8 18
  GETLN.GL2                                  code  fffc6320 18
  GETLN.GL3                                  code  fffc6354 18
  GETLN.GL4                                  code  fffc6380 18
  GETLN.GL5                                  code  fffc6398 18
  GETLN.GL6                                  code  fffc63b8 18
  GETLN.GL7                                  code  fffc63c4 18
  GOAUXI                                     code  fffc4a18 18
  GOAUXO                                     code  fffc4a10 18
  GOBYE                                      code  fffc4a20 18
  GOIN                                       code  fffc4a0c 18
  GOOUT                                      code  fffc4a08 18
  GOSTART                                    code  fffc4a00 18
  GOSUB                                      code  fffc5200 18
  GOTO                                       code  fffc5040 18
  GOWARM                                     code  fffc4a04 18
  GetBuflen                                  code  fffc4ca0 18
  GetBuflen.0001                             code  fffc4cc8 18
  GetBuflen.0002                             code  fffc4cac 18
  GetBuflen.0004                             code  fffc4cc4 18
  GetCurrentTid                              code  fffc2290 18
  GetFilename                                code  fffc56bc 18
  GetHexNum                                  code  fffc0748 18
  GetHexNum.0001                             code  fffc07a0 18
  GetHexNum.isDigit                          code  fffc07e8 18
  GetHexNum.isHexLower                       code  fffc07cc 18
  GetHexNum.isHexUpper                       code  fffc07b0 18
  GetHexNum.next                             code  fffc075c 18
  Getch                                      code  fffc0264 18
  IF0                                        code  fffc547c 18
  IF1                                        code  fffc5480 18
  IF2                                        code  fffc5488 18
  IF3                                        code  fffc549c 18
  IGB1                                       code  fffc68c0 18
  IGB2                                       code  fffc68ac 18
  IGBRET                                     code  fffc68c8 18
  IGNBLK                                     code  fffc68a4 18
  INBUF                                     const  014100 18
  INCH                                       code  fffc6b88 18
  INCH1                                      code  fffc6bac 18
  INPERR                                     code  fffc54a0 18
  INPPTR                                    const  0300ac 19
  INPUT                                      code  fffc54d4 18
  INSLINE                                    code  fffc4be0 18
  INSLINE.0001                               code  fffc4c0c 18
  IOF_NEXT                                  const  0002e8 11
  IOF_PREV                                  const  0002f0 11
  IOFocusNdx                                const  024810 19
  IOFocusTbl                                const  024818 19
  IP2                                        code  fffc54fc 18
  IP3                                        code  fffc5538 18
  IP4                                        code  fffc55ac 18
  IP5                                        code  fffc55bc 18
  IP6                                        code  fffc54dc 18
  IP7                                        code  fffc551c 18
  IRQFlag                                   const  0300b4 19
  IRQROUT                                   const  0300a4 19
  IRQRout                                    code  fffc09e0 18
  IRQRout.cause0to7                          code  fffc0aac 18
  IRQRout.cause12plus                        code  fffc0aac 18
  IRQRout.doIRQ                              code  fffc0a54 18
  IRQRout.isIRQ                              code  fffc0a18 18
  IRQRout.noIRQ                              code  fffc0a74 18
  IdleTask                                   code  fffc0260 18
  InsertIntoReadyList                        code  fffc3224 18
  InsertIntoReadyList.0001                   code  fffc32b8 18
  InsertIntoReadyList.badTid                 code  fffc32c0 18
  InsertIntoReadyList.insert                 code  fffc3284 18
  InsertIntoReadyList.level2                 code  fffc32a4 18
  InsertIntoTimeoutList                      code  fffc3380 18
  InsertIntoTimeoutList.0001                 code  fffc33d8 18
  InsertIntoTimeoutList.0002                 code  fffc3440 18
  InsertIntoTimeoutList.0003                 code  fffc3450 18
  InsertIntoTimeoutList.beginWhile           code  fffc33e4 18
  InsertIntoTimeoutList.endOfList            code  fffc3404 18
  InsertIntoTimeoutList.endWhile             code  fffc3414 18
  InsertLine                                 code  fffc4c80 18
  InsertLine.0001                            code  fffc4c84 18
  InsertLine.done                            code  fffc4c9c 18
  KEYBD                                      code  8000000000000290 32
  KeybdFuncTbl                               code  fffc3db0 18
  KeybdIRQ                                   code  fffc41e0 18
  KeybdIRQ.0001                              code  fffc427c 18
  KeybdIRQ.noRoom                            code  fffc4224 18
  KeybdIRQ.notAlt                            code  80000000000002aa 32
  KeybdIRQ.notAltTab                         code  fffc42a0 18
  KeybdIRQ.notCtrl                           code  fffc427c 18
  KeybdIRQ.notCtrlC                          code  fffc4254 18
  KeybdIRQ.notCtrlZ                          code  fffc427c 18
  KeybdIRQ.notKbd                            code  fffc42e4 18
  KillTask                                   code  8000000000000219 32
  LEDS                                      const  ffdc0600 33
  LET                                        code  fffc55d4 18
  LINEFD                                    const  00000a 5
  LISTX                                      code  fffc510c 18
  LNFD                                      const  00000a 5
  LOAD                                       code  fffc55ec 18
  LOAD3                                      code  fffc5740 18
  LOAD4                                      code  fffc576c 18
  LOAD5                                      code  fffc57a4 18
  LOD1                                       code  fffc55fc 18
  LOD2                                       code  fffc5628 18
  LODEND                                     code  fffc5644 18
  LOG_MBXSZ                                 const  000005 4
  LOG_MSGSZ                                 const  000005 4
  LOG_PGSZ                                  const  000010 6
  LOG_TCBSZ                                 const  00000a 5
  LOPINC                                    const  030078 19
  LOPLMT                                    const  03007c 19
  LOPLN                                     const  030074 19
  LOPPT                                     const  030070 19
  LOPVAR                                    const  030010 19
  LS1                                        code  fffc5120 18
  LS2                                        code  fffc5154 18
  LS3                                        code  fffc515c 18
  LS4                                        code  fffc5138 18
  LS5                                        code  fffc5124 18
  LSTROM                                    const  000000 1
  LT1                                        code  fffc55e8 18
  LoadWord                                   code  fffc675c 18
  MAX_ASID                                  const  00001f 6
  MAX_DEV_OP                                const  00001f 6
  MAX_MID                                   const  00001f 6
  MAX_TID                                   const  00001f 6
  MBX_MQHEAD                                const  000010 6
  MBX_MQTAIL                                const  000018 6
  MBX_OWNER                                 const  000000 1
  MBX_SIZE                                  const  000020 7
  MBX_WTIDS                                 const  000008 5
  MMUInit                                    code  fffc0fa0 18
  MMUInit.0001                               code  fffc0fd8 18
  MMUInit.0002                               code  fffc1044 18
  MMUInit.0004                               code  fffc0fc8 18
  MMUInit.0006                               code  fffc1004 18
  MSG_D1                                    const  000008 5
  MSG_D2                                    const  000010 6
  MSG_D3                                    const  000018 6
  MSG_LINK                                  const  000000 1
  MSG_SIZE                                  const  000020 7
  MULEXPR                                    code  fffc5cec 18
  MVDOWN                                     code  fffc64a8 18
  MVDOWN1                                    code  fffc6498 18
  MVUP                                       code  fffc6490 18
  MVUP1                                      code  fffc6480 18
  MachineStart                               code  fffc0100 18
  MachineStart.hart00                        code  fffc011c 18
  MachineStart.hart20                        code  fffc0114 18
  MachineStart.skipInit                      code  fffc016c 18
  MapOSPages                                 code  fffc22b4 18
  MapOSPages.failed                          code  fffc22ec 18
  MapOSPages.nxt                             code  fffc22c0 18
  MbxRemoveTask                              code  fffc2c8c 18
  MbxRemoveTask.xit                          code  fffc2cdc 18
  MonEntry                                   code  fffc0354 18
  Monitor                                    code  fffc035c 18
  Monitor.0001                               code  fffc0388 18
  Monitor.0002                               code  fffc03e4 18
  Monitor.0003                               code  fffc0450 18
  Monitor.0004                               code  fffc04e8 18
  Monitor.0005                               code  fffc0610 18
  Monitor.0006                               code  fffc0560 18
  Monitor.0007                               code  fffc0598 18
  Monitor.0008                               code  fffc05a8 18
  Monitor.0009                               code  fffc05b8 18
  Monitor.0010                               code  fffc05d4 18
  Monitor.0011                               code  fffc05f4 18
  Monitor.0012                               code  fffc0610 18
  Monitor.doBackspace                        code  fffc0438 18
  Monitor.doDelete                           code  fffc03d8 18
  Monitor.noT                                code  fffc058c 18
  Monitor.procLine                           code  fffc04a4 18
  Monitor.skip                               code  fffc04bc 18
  Monitor.skip2                              code  fffc04dc 18
  NEW                                        code  fffc4ee8 18
  NEXT                                       code  fffc53bc 18
  NPAGES                                    const  024828 19
  NR_DCB                                    const  000020 7
  NR_MBX                                    const  000100 10
  NR_MSG                                    const  000800 13
  NR_TCB                                    const  000020 7
  NUMWKA                                    const  030094 19
  NX0                                        code  fffc53d8 18
  NX1                                        code  fffc543c 18
  NX2                                        code  fffc5404 18
  NX3                                        code  fffc5440 18
  NX4                                        code  fffc53d4 18
  NX5                                        code  fffc53f8 18
  NXPurge                                    code  fffc5474 18
  OKMSG                                      code  fffc6c02 18
  ONIRQ                                      code  fffc50b0 18
  ONIRQ1                                     code  fffc50dc 18
  OREXPR                                     code  fffc59d8 18
  OSCALL                                     code  fffc255c 18
  OSCALL.lock                                code  fffc25a0 18
  OSCALL.oscall                              code  fffc2610 18
  OSCALL.xit                                 code  fffc2640 18
  OSCALL.zero                                code  fffc2658 18
  OSCallTbl                                  code  fffc20f4 18
  OSPAGES                                   const  000003 3
  OSSP                                      const  030000 19
  OUTC                                       code  fffc6b84 18
  OUTPTR                                    const  0300a8 19
  OpenSpace                                  code  fffc4ccc 18
  OpenSpace.0003                             code  fffc4d08 18
  OpenSpace.noSpace                          code  fffc4d24 18
  PAGESZ                                    const  010000 18
  PAGES_PER_MAP                             const  001000 14
  PAGES_PER_TASK                            const  001000 14
  PARN                                       code  fffc5dd8 18
  PEEK                                       code  fffc5fec 18
  PEEKH                                      code  fffc601c 18
  PEEKW                                      code  fffc6004 18
  PIC                                       const  ffdc0f00 33
  PIC_CH16                                  const  0000c0 9
  PIC_CH28                                  const  0000f0 9
  PIC_CH31                                  const  0000fc 9
  PIDMAP                                    const  024310 19
  PKER                                       code  fffc59a0 18
  POKE                                       code  fffc591c 18
  POKEH                                      code  fffc5974 18
  POKEW                                      code  fffc5948 18
  POPA_                                      code  fffc64b0 18
  PP1                                        code  fffc6520 18
  PR0                                        code  fffc518c 18
  PR1                                        code  fffc51a4 18
  PR2                                        code  fffc5178 18
  PR3                                        code  fffc51c4 18
  PR4                                        code  fffc51bc 18
  PR6                                        code  fffc51d8 18
  PR8                                        code  fffc51e0 18
  PRINT                                      code  fffc5160 18
  PRMESG                                     code  fffc6988 18
  PRNGL                                     const  ffdc0c00 33
  PRNG_STREAM                               const  000008 5
  PRNG_VALUE                                const  000000 1
  PRTLN                                      code  fffc6788 18
  PRTNUM                                     code  fffc66ac 32
  PRTNUM.PN1                                 code  fffc66e4 18
  PRTNUM.PN2                                 code  fffc66e0 18
  PRTNUM.PN3                                 code  fffc670c 18
  PRTNUM.PN4                                 code  fffc671c 18
  PRTNUM.PN5                                 code  fffc6728 18
  PRTNUM.PN6                                 code  fffc6730 18
  PRTNUM.PN7                                 code  fffc66f4 18
  PRTSTG                                     code  fffc65b0 18
  PRTSTG.PRTRET                              code  fffc65f4 18
  PRTSTG.PS1                                 code  fffc65d0 18
  PU1                                        code  fffc65a4 18
  PUSHA_                                     code  fffc6524 18
  PWORD                                      code  fffc58a4 18
  PicInit                                    code  fffc1348 18
  PutHexByte                                 code  fffc086c 18
  PutHexDword                                code  fffc0800 18
  PutHexHalf                                 code  fffc0848 18
  PutHexNybble                               code  fffc0890 18
  PutHexNybble.0001                          code  fffc08cc 18
  PutHexNybble.lt10                          code  fffc08c0 18
  PutHexWord                                 code  fffc0824 18
  PutString                                  code  fffc08dc 18
  PutString.0001                             code  fffc08ec 18
  PutString.done                             code  fffc0904 18
  Putch                                      code  fffc0294 18
  QNDX                                      const  024304 19
  QSORRY                                     code  fffc6264 18
  QT1                                        code  fffc6630 18
  QT2                                        code  fffc6670 18
  QT3                                        code  fffc6648 18
  QT4                                        code  fffc665c 18
  QT5                                        code  fffc667c 18
  QTSTG                                      code  fffc6618 18
  QWHAT                                      code  fffc6270 18
  RDYQ0                                     const  024400 19
  RDYQ1                                     const  024500 19
  RDYQ2                                     const  024600 19
  RDYQ3                                     const  024700 19
  READYQ                                    const  024308 19
  RETURN                                     code  fffc5274 18
  RND                                        code  fffc6080 18
  RUN                                        code  fffc4f1c 18
  RUN1                                       code  fffc4ff4 18
  RUN2                                       code  fffc4f50 18
  RUN3                                       code  fffc4f54 18
  RUNNXL                                     code  fffc4f3c 18
  RUNSML                                     code  fffc5028 18
  RUNTSL                                     code  fffc5014 18
  RemoveFromReadyList                        code  fffc32c8 18
  RemoveFromReadyList.tidOk                  code  fffc32dc 18
  RemoveFromReadyList2                       code  fffc32f4 18
  RemoveFromReadyList2.0001                  code  fffc3348 18
  RemoveFromReadyList2.0002                  code  fffc3364 18
  RemoveFromReadyList2.0003                  code  fffc3338 18
  RemoveFromReadyList2.badTid                code  fffc3378 18
  RemoveFromTimeoutList                      code  fffc3464 18
  RemoveFromTimeoutList.0001                 code  fffc34b4 18
  RemoveFromTimeoutList.noNext               code  fffc34d4 18
  RemoveFromTimeoutList.noPrev               code  fffc34e8 18
  RemoveFromTimeoutList.noWait               code  fffc3478 18
  RestoreContext                             code  fffc2430 18
  RestoreContext.rsseg                       code  fffc2440 18
  SAVE                                       code  fffc5814 18
  SAVE1                                      code  fffc582c 18
  SAVE2                                      code  fffc5848 18
  SAVE3                                      code  fffc57a8 18
  SAVE4                                      code  fffc57d8 18
  SAVEND                                     code  fffc5860 18
  SC_C                                      const  000021 7
  SC_TAB                                    const  00000d 5
  SC_Z                                      const  00001a 6
  SDReadSector                               code  80000000000003bb 32
  SDWriteSector                              code  80000000000003c0 32
  SENDMSG                                    code  fffc6a10 18
  SENDMSG.err                                code  fffc6a94 18
  SENDMSG.paren                              code  fffc6aa0 18
  SETVAL                                     code  fffc6184 18
  SETVAL.sv2                                 code  fffc61a8 18
  SGN                                        code  fffc6114 18
  SGN1                                       code  fffc6144 18
  SGN2                                       code  fffc6134 18
  SIZEX                                      code  fffc6150 18
  SRYMSG                                     code  fffc6c0f 18
  ST2                                        code  fffc4bbc 18
  STACKOFFS                                 const  afffc000 33
  STKBOT                                    const  03009c 19
  STKGOS                                    const  030014 19
  STKINP                                    const  030098 19
  STOP                                       code  fffc4f08 18
  STRTMP                                    const  000200 11
  SV1                                        code  fffc61e4 18
  SYSX                                       code  fffc59ac 18
  SYS_MUTEX                                 const  ffdbff00 33
  SaveContext                                code  fffc2370 18
  SaveContext.svseg                          code  fffc2408 18
  SaveContext.xit                            code  fffc242c 18
  SelectTaskToRun                            code  fffc22f0 18
  SelectTaskToRun.0001                       code  fffc2338 18
  SelectTaskToRun.dq                         code  fffc235c 18
  SelectTaskToRun.goodTid                    code  fffc235c 18
  SelectTaskToRun.nxtQ                       code  fffc232c 18
  SelectTaskToRun.searchQ                    code  fffc22f0 18
  SerHeadRcv                                const  025800 19
  SerHeadXmit                               const  025808 19
  SerRcvBuf                                 const  025000 19
  SerRcvXoff                                const  025811 19
  SerRcvXon                                 const  025810 19
  SerTailRcv                                const  025804 19
  SerTailXmit                               const  02580c 19
  SerXmitBuf                                const  025400 19
  SerialFinishCmd                            code  fffc15c4 18
  SerialFinishCmd.0001                       code  fffc15e8 18
  SerialFuncTbl                              code  fffc1380 18
  SerialGetChar                              code  fffc15ec 18
  SerialGetChar.0001                         code  fffc16ac 18
  SerialGetChar.0002                         code  fffc1658 18
  SerialGetChar.noChars                      code  fffc16ac 18
  SerialGetChar.xit                          code  fffc16b4 18
  SerialIRQ                                  code  fffc1858 18
  SerialIRQ.0001                             code  fffc1908 18
  SerialIRQ.notRxInt                         code  fffc191c 18
  SerialIRQ.nxtByte                          code  fffc1858 18
  SerialIRQ.rxFull                           code  fffc191c 18
  SerialInit                                 code  fffc1480 18
  SerialPeekChar                             code  fffc16cc 18
  SerialPeekChar.0001                        code  fffc1718 18
  SerialPeekChar.noChars                     code  fffc1718 18
  SerialPeekChar.xit                         code  fffc171c 18
  SerialPeekCharDirect                       code  fffc1734 18
  SerialPeekCharDirect.0001                  code  fffc1774 18
  SerialPeekCharDirect.xit                   code  fffc1778 18
  SerialPutChar                              code  fffc1790 18
  SerialPutChar.0001                         code  fffc17a8 18
  SerialPutChar.0002                         code  fffc17a4 18
  SerialPutChar.goSleep                      code  fffc17ec 18
  SerialRcvCount                             code  fffc181c 18
  SerialRcvCount.xit                         code  fffc1850 18
  SerialService                              code  fffc156c 18
  SerialServiceInit                          code  fffc1554 18
  SerialServiceLoop                          code  fffc1588 18
  SkipSpaces                                 code  fffc0714 18
  SkipSpaces.skip1                           code  fffc073c 18
  SkipSpaces.skip2                           code  fffc0714 18
  SpriteDemo_101                             code  fffc7258 18
  SpriteDemo_103                             code  fffc7278 18
  SpriteDemo_104                             code  fffc72ec 18
  SpriteDemo_106                             code  fffc72fc 18
  SpriteDemo_107                             code  fffc733c 18
  SpriteDemo_109                             code  fffc733c 18
  SpriteDemo_114                             code  fffc7370 18
  SpriteDemo_115                             code  fffc7384 18
  SpriteDemo_117                             code  fffc7390 18
  SpriteDemo_118                             code  fffc74dc 18
  SpriteDemo_120                             code  fffc741c 18
  SpriteDemo_122                             code  fffc7454 18
  SpriteDemo_124                             code  fffc7490 18
  SpriteDemo_126                             code  fffc74ac 18
  SpriteDemo_17                              code  fffc6e58 18
  SpriteDemo_25                              code  fffc6ef0 18
  SpriteDemo_28                              code  fffc6ef0 18
  SpriteDemo_29                              code  fffc6eac 18
  SpriteDemo_30                              code  fffc6ef0 18
  SpriteDemo_39                              code  fffc6f54 18
  SpriteDemo_47                              code  fffc7058 18
  SpriteDemo_50                              code  fffc7058 18
  SpriteDemo_51                              code  fffc6fd4 18
  SpriteDemo_52                              code  fffc7058 18
  SpriteDemo_9                               code  fffc6e04 18
  SpriteDemo_91                              code  fffc750c 18
  SpriteDemo_94                              code  fffc750c 18
  SpriteDemo_95                              code  fffc7154 18
  SpriteDemo_96                              code  fffc71b8 18
  SpriteDemo_98                              code  fffc71cc 18
  SpriteDemo_99                              code  fffc7268 18
  SpriteDemo_longlit0                      rodata  fffc8000 32
  SwapContext                                code  fffc24ec 18
  SwapContext.noCtxSwitch                    code  fffc2558 18
  SwapContext.rsseg                          code  fffc252c 18
  SwapContext.savedAlready                   code  fffc2528 18
  SwapContext.svseg                          code  fffc2508 18
  SwitchIOFocus                             const  024820 19
  SysSema                                   const  024340 19
  TAB                                       const  000009 5
  TAB1                                       code  fffc4d2c 18
  TAB10                                      code  fffc4de6 18
  TAB10_1                                    code  fffc4e56 18
  TAB1_1                                     code  fffc4dea 18
  TAB2                                       code  fffc4d3e 18
  TAB2_1                                     code  fffc4df4 18
  TAB4                                       code  fffc4d97 18
  TAB4_1                                     code  fffc4e22 18
  TAB5                                       code  fffc4dd0 18
  TAB5_1                                     code  fffc4e3c 18
  TAB6                                       code  fffc4dd3 18
  TAB6_1                                     code  fffc4e40 18
  TAB8                                       code  fffc4dd8 18
  TAB8_1                                     code  fffc4e44 18
  TAB9                                       code  fffc4de2 18
  TAB9_1                                     code  fffc4e52 18
  TC1                                        code  fffc6818 18
  TC64CursorAddr                            const  ffd1df1c 33
  TCBContextSaved                           const  00028a 11
  TCBElapsedTime                            const  0002c0 11
  TCBEndTime                                const  0002b8 11
  TCBException                              const  0002c8 11
  TCBKbdBuf                                 const  000308 11
  TCBKbdHead                                const  000300 11
  TCBKbdState2                               code  80000000000002a5 32
  TCBKbdTail                                const  000301 11
  TCBMsgD1                                  const  000298 11
  TCBMsgD2                                  const  0002a0 11
  TCBMsgD3                                  const  0002a8 11
  TCBName                                   const  0002f8 11
  TCBNext                                   const  0002d0 11
  TCBPrev                                   const  0002d8 11
  TCBPriority                               const  000289 11
  TCBResource                               const  000328 11
  TCBStackBot                               const  000290 11
  TCBStartTime                              const  0002b0 11
  TCBStatus                                 const  000288 11
  TCBTimeout                                const  0002e0 11
  TCBVidMem                                  code  800000000000021f 32
  TCBVideoMem                               const  000330 11
  TCBWaitMbx                                const  00028c 11
  TCBepc                                    const  000280 11
  TCBpVideo                                 const  000338 11
  TCBsegs                                   const  000200 11
  TICKX                                      code  fffc6100 18
  TN1                                        code  fffc6848 18
  TN2                                        code  fffc6874 18
  TOOBIG                                     code  fffc6258 18
  TOUPB1                                     code  fffc68e8 18
  TOUPBRT                                    code  fffc6930 18
  TOUPBUF                                    code  fffc68d4 18
  TOUPRET                                    code  fffc6954 18
  TSNMRET                                    code  fffc6894 18
  TSTC                                       code  fffc67e4 18
  TSTNUM                                     code  fffc6830 18
  TSTV                                       code  fffc5e18 18
  TSTVRT                                     code  fffc5e94 18
  TS_DEAD                                   const  000002 3
  TS_MSGRDY                                 const  000004 4
  TS_NONE                                   const  000000 1
  TS_PREEMPT                                const  000020 7
  TS_READY                                  const  000001 2
  TS_RUNNING                                const  000080 9
  TS_TIMEOUT                                const  000010 6
  TS_WAITMSG                                const  000008 5
  TV1                                        code  fffc5e80 18
  TV2                                        code  fffc5e68 18
  TV3                                        code  fffc5e48 18
  TXTBGN                                    const  031800 19
  TXTUNF                                    const  030004 19
  Tick                                      const  024330 19
  TimeoutList                               const  024328 19
  TinyBasic                                  code  fffc4a00 18
  UART                                      const  ffdc0a00 33
  UART_CMD                                  const  000008 5
  UART_STAT                                 const  000004 4
  UART_TRB                                  const  000000 1
  USRX                                       code  fffc6034 18
  UpdateCursorPos                            code  fffc1ce8 18
  UserStart                                  code  fffc018c 18
  UserStart.0001                             code  fffc01bc 18
  UserStart2                                 code  fffc01bc 18
  UserStart2a                                code  fffc01c4 18
  UserStart2a.0002                           code  fffc021c 18
  UserStart2a.0003                           code  fffc0240 18
  UserStart2a.0004                           code  fffc021c 18
  UserStart2a.0005                           code  fffc021c 18
  UserStart2a.loop                           code  fffc01c4 18
  VARBGN                                    const  030008 19
  VAREND                                    const  03000c 19
  VIA                                       const  ffdc0600 33
  VIA_ACR                                   const  00002c 7
  VIA_DDRA                                  const  00000c 5
  VIA_IER                                   const  000038 7
  VIA_IFR                                   const  000034 7
  VIA_PA                                    const  000004 4
  VIA_PARAW                                 const  00003c 7
  VIA_PCR                                   const  000030 7
  VIA_T1CH                                  const  000014 6
  VIA_T1CL                                  const  000010 6
  ViaFuncTbl                                 code  fffc1930 18
  ViaIRQ                                     code  fffc1a98 18
  ViaIRQ.0003                                code  fffc1af4 18
  ViaIRQ.hart20                              code  fffc1af0 18
  ViaInit                                    code  fffc1a30 18
  VideoClearScreen                           code  fffc1c80 18
  VideoClearScreen.0001                      code  fffc1cb0 18
  VideoFuncTbl                               code  fffc1b00 18
  VideoHomeCursor                            code  fffc1cc8 18
  VideoIRQ                                   code  fffc20f0 18
  VideoIRQ.0003                              code  fffc20f0 18
  VideoInit                                  code  fffc1c00 18
  VideoPutChar                               code  fffc1d2c 18
  VideoPutChar.0001                          code  fffc1e64 18
  VideoPutChar.backspace                     code  fffc1ff0 18
  VideoPutChar.bll1                          code  fffc1e94 18
  VideoPutChar.bs0001                        code  fffc2074 18
  VideoPutChar.bs0002                        code  fffc205c 18
  VideoPutChar.cr1                           code  fffc1f50 18
  VideoPutChar.cr2                           code  fffc1f48 18
  VideoPutChar.cursorDown                    code  fffc1fac 18
  VideoPutChar.cursorLeft                    code  fffc1f54 18
  VideoPutChar.cursorRight                   code  fffc1f18 18
  VideoPutChar.cursorUp                      code  fffc1f80 18
  VideoPutChar.del0001                       code  fffc2018 18
  VideoPutChar.delete                        code  fffc2094 18
  VideoPutChar.doCR                          code  fffc1ee8 18
  VideoPutChar.doCls                         code  fffc1fdc 18
  VideoPutChar.doLF                          code  fffc1f04 18
  VideoPutChar.doLF1                         code  fffc1e24 18
  VideoPutChar.saveX                         code  fffc1ecc 18
  VideoPutChar.saveY                         code  fffc1ebc 18
  VideoPutChar.xit                           code  fffc1ea8 18
  VideoPutString                             code  fffc20ac 18
  VideoPutString.again                       code  fffc20b4 18
  VideoPutString.done                        code  fffc20e0 18
  VirtToPhys                                 code  fffc1308 18
  VirtToPhys.notMapped                       code  fffc1340 18
  WAITIRQ                                    code  fffc50f0 18
  WAITMSG                                    code  fffc6aac 18
  WAITMSG.0001                               code  fffc6ae4 18
  WAITMSG.0002                               code  fffc6ad8 18
  WAITMSG.err                                code  fffc6b6c 18
  WAITMSG.paren                              code  fffc6b78 18
  WSTART                                     code  fffc4b24 18
  XOFF                                      const  000013 6
  XON                                       const  000011 6
  XP11                                       code  fffc5b5c 18
  XP12                                       code  fffc5b74 18
  XP13                                       code  fffc5b8c 18
  XP14                                       code  fffc5ba4 18
  XP15                                       code  fffc5bbc 18
  XP16                                       code  fffc5bd4 18
  XP17                                       code  fffc5c14 18
  XP18                                       code  fffc5c2c 18
  XP21                                       code  fffc5c7c 18
  XP22                                       code  fffc5c88 18
  XP23                                       code  fffc5c8c 18
  XP24                                       code  fffc5ca8 18
  XP25                                       code  fffc5cbc 18
  XP26                                       code  fffc5cc8 18
  XP31                                       code  fffc5cf8 18
  XP34                                       code  fffc5d28 18
  XP35                                       code  fffc5d4c 18
  XP40                                       code  fffc5da4 18
  XP41                                       code  fffc5dc0 18
  XP42                                       code  fffc5dfc 18
  XP43                                       code  fffc5e08 18
  XP45                                       code  fffc5cd4 18
  XP46                                       code  fffc5dcc 18
  XP47                                       code  fffc5d70 18
  XPRT0                                      code  fffc5bec 18
  XPRT1                                      code  fffc5c00 18
  XP_AND                                     code  fffc5a6c 18
  XP_AND1                                    code  fffc5a4c 18
  XP_ANDX                                    code  fffc5a80 18
  XP_OR                                      code  fffc5a0c 18
  XP_OR1                                     code  fffc59ec 18
  XP_ORX                                     code  fffc5a20 18
  YIELD0                                     code  fffc4f10 18
  _ACBPtrs                                 rodata  000000 32
  _Alloc                                   rodata  fffc121c 32
  _Alloc.ok                                  code  fffc1230 18
  _BIOS1_sema                              rodata  000000 32
  _BIOS_RespMbx                            rodata  000000 32
  _DBGCheckForKey                            code  fffc4420 32
  _DBGGetKey                                 code  fffc4460 32
  _DeviceTable                             rodata  000000 32
  _DumpTaskList                            rodata  000000 32
  _EnableSprite                              code  fffc6dd0 32
  _EnableSprites                             code  fffc6e0c 32
  _FMTK_Inited                             rodata  000000 32
  _FMTK_Reschedule                         rodata  000000 32
  _FMTK_SendMsg                            rodata  000000 32
  _FMTK_StartApp                           rodata  000000 32
  _FMTK_StartThread                        rodata  000000 32
  _FMTK_WaitMsg                            rodata  000000 32
  _FocusSwitcher                           rodata  000000 32
  _GetACBPtr                               rodata  000000 32
  _GetAppHandle                            rodata  000000 32
  _GetRand                                 rodata  fffc43e0 32
  _GetRunningACBPtr                        rodata  000000 32
  _GetVecno                                rodata  000000 32
  _IOFocusNdx                              rodata  000000 32
  _IOFocusTbl                              rodata  000000 32
  _InsertIntoReadyList                     rodata  000000 32
  _InsertIntoTimeoutList                   rodata  000000 32
  _KeyLED                                  rodata  024826 32
  _KeyState1                               rodata  024824 32
  _KeyState2                               rodata  024825 32
  _KeybdClearRcv                           rodata  000000 32
  _KeybdGetBufferStatus                      code  fffc42f0 18
  _KeybdGetBufferStatus.empty                code  fffc4314 18
  _KeybdGetBufferedScancode                  code  fffc4320 18
  _KeybdGetBufferedScancode.empty            code  fffc4354 18
  _KeybdGetID                                code  fffc403c 18
  _KeybdGetID.0001                           code  fffc408c 18
  _KeybdGetID.notKbd                         code  fffc40ac 18
  _KeybdGetScancode                        rodata  fffc41bc 32
  _KeybdGetStatus                          rodata  fffc4194 32
  _KeybdID                                   code  800000000000029d 32
  _KeybdInit                                 code  fffc3eb0 18
  _KeybdInit.0002                            code  fffc3eec 18
  _KeybdInit.0004                            code  fffc3f94 18
  _KeybdInit.config                          code  fffc3f38 18
  _KeybdInit.keybdErr                        code  fffc3f7c 18
  _KeybdInit.ledxit                          code  fffc3fc0 18
  _KeybdInit.tryAgain                        code  fffc3f70 18
  _KeybdInit.xit                             code  fffc3fdc 18
  _KeybdPeekScancode                         code  fffc41a8 18
  _KeybdRecvByte                             code  fffc40b8 18
  _KeybdRecvByte.0003                        code  fffc40c4 18
  _KeybdRecvByte.0004                        code  fffc4108 18
  _KeybdSendByte                             code  fffc411c 18
  _KeybdSetLED                             rodata  fffc3fec 32
  _KeybdWaitTx                               code  fffc4130 18
  _KeybdWaitTx.0001                          code  fffc413c 18
  _KeybdWaitTx.0002                          code  fffc4180 18
  _LockIOFSemaphore                        rodata  000000 32
  _LockKbdSemaphore                        rodata  000000 32
  _LockSemaphore                           rodata  000000 32
  _LockSysSemaphore                        rodata  000000 32
  _MicroDelay                                code  fffc0914 18
  _MicroDelay.0001                           code  fffc0918 18
  _PRNGInit                                  code  fffc4360 18
  _PeekRand                                  code  fffc43b8 18
  _RandomizeSpriteColors                     code  fffc6e6c 32
  _RandomizeSpritePositions                  code  fffc6f70 32
  _RemoveFromReadyList                     rodata  000000 32
  _RemoveFromTimeoutList                   rodata  000000 32
  _RequestIOFocus                          rodata  000000 32
  _SeedRand                                  code  fffc439c 18
  _SetBound48                              rodata  000000 32
  _SetBound49                              rodata  000000 32
  _SetBound50                              rodata  000000 32
  _SetBound51                              rodata  000000 32
  _SetSpritePos                              code  fffc6f08 32
  _SpriteDemo                                code  fffc7080 32
  _TimeoutList                             rodata  000000 32
  _VirtToPhys                              rodata  fffc1308 32
  _XlatScancode                              code  fffc435c 18
  _bios_stacks                             rodata  000000 32
  _chkTCB                                  rodata  000000 32
  _clr                                       code  fffc5064 18
  _cls                                       code  8000000000000337 32
  _end_init_data                           rodata  fffc9000 32
  _fmtk_irq_stack                          rodata  000000 32
  _fmtk_sys_stack                          rodata  000000 32
  _freeMBX                                 rodata  000000 32
  _freeMSG                                 rodata  000000 32
  _freeTCB                                 rodata  000000 32
  _getCPU                                  rodata  000000 32
  _hFocusSwitchMbx                         rodata  000000 32
  _hasUltraHighPriorityTasks               rodata  000000 32
  _iof_sema                                rodata  000000 32
  _iof_switch                              rodata  000000 32
  _irq_stack                               rodata  000000 32
  _kbd_sema                                rodata  000000 32
  _keybdControlCodes                       rodata  fffc3cb0 32
  _keybdExtendedCodes                      rodata  fffc3d30 32
  _mailbox                                 rodata  000000 32
  _message                                 rodata  000000 32
  _missed_ticks                            rodata  000000 32
  _mmu_Alloc512kPage                       rodata  000000 32
  _mmu_Alloc8kPage                         rodata  000000 32
  _mmu_AllocateMap                         rodata  000000 32
  _mmu_Free512kPage                        rodata  000000 32
  _mmu_Free8kPage                          rodata  000000 32
  _mmu_FreeMap                             rodata  000000 32
  _mmu_MapCardMemory                       rodata  000000 32
  _mmu_SetAccessKey                        rodata  000000 32
  _mmu_SetMapEntry                         rodata  000000 32
  _mmu_SetOperateKey                       rodata  000000 32
  _mmu_alloc                               rodata  000000 32
  _mmu_free                                rodata  000000 32
  _nMailbox                                rodata  000000 32
  _nMsgBlk                                 rodata  000000 32
  _outb                                    rodata  000000 32
  _outc                                    rodata  000000 32
  _outh                                    rodata  000000 32
  _outw                                    rodata  000000 32
  _randStream                              rodata  024830 32
  _rdcf                                      code  8000000000000339 32
  _readyQ                                  rodata  000000 32
  _set_vector                              rodata  000000 32
  _shiftedScanCodes                        rodata  fffc3bb0 32
  _stacks                                  rodata  000000 32
  _sys_sema                                rodata  000000 32
  _sys_stacks                              rodata  000000 32
  _sysstack                                rodata  000000 32
  _tcbs                                    rodata  000000 32
  _unshiftedScanCodes                      rodata  fffc3ab0 32
  _video_bufs                              rodata  000000 32
  a2h1                                       code  fffc56b0 18
  asciiToHex                                 code  fffc56a4 18
  begin_init_data                          rodata  fffc8008 32
  clearVars                                  code  fffc506c 18
  clearVars.cv1                              code  fffc508c 18
  datAttr                                    code  fffc0258 18
  doMem                                      code  fffc0614 18
  doMem.loop                                 code  fffc0690 18
  doMem.loop2                                code  fffc0660 18
  ec1                                        code  fffc624c 18
  end_init_data                            rodata  fffc9000 32
  findVar                                    code  fffc5f64 18
  fl1                                        code  fffc63f8 18
  flt10                                      code  fffc0bb0 18
  flt20                                      code  fffc0ba0 18
  flt50                                      code  fffc0b90 18
  fltMillion                                 code  fffc0f84 18
  fltOne                                     code  fffc0f7c 18
  fltTen                                     code  fffc0f80 18
  fltToString                                code  fffc0bc0 18
  fltToString.0001                           code  fffc0c20 18
  fltToString.0002                           code  fffc0ca0 18
  fltToString.0003                           code  fffc0c8c 18
  fltToString.0004                           code  fffc0cec 18
  fltToString.0005                           code  fffc0ce4 18
  fltToString.0006                           code  fffc0ccc 18
  fltToString.0007                           code  fffc0d08 18
  fltToString.0008                           code  fffc0d1c 18
  fltToString.0009                           code  fffc0d18 18
  fltToString.0010                           code  fffc0d3c 18
  fltToString.0011                           code  fffc0dc8 18
  fltToString.0012                           code  fffc0d80 18
  fltToString.0013                           code  fffc0d6c 18
  fltToString.0014                           code  fffc0d9c 18
  fltToString.0015                           code  fffc0db8 18
  fltToString.0016                           code  fffc0d54 18
  fltToString.0017                           code  fffc0dc0 18
  fltToString.0018                           code  fffc0dc8 18
  fltToString.0019                           code  fffc0dfc 18
  fltToString.0020                           code  fffc0e08 18
  fltToString.0021                           code  fffc0e2c 18
  fltToString.0022                           code  fffc0e38 18
  fltToString.0023                           code  fffc0e48 18
  fltToString.0024                           code  fffc0e54 18
  fltToString.0025                           code  fffc0e40 18
  fltToString.0026                           code  fffc0e68 18
  fltToString.0027                           code  fffc0e70 18
  fltToString.0028                           code  fffc0e78 18
  fltToString.0029                           code  fffc0e84 18
  fltToString.0030                           code  fffc0e90 18
  fltToString.0031                           code  fffc0e9c 18
  fltToString.0032                           code  fffc0ea4 18
  fltToString.0034                           code  fffc0eac 18
  fltToString.0035                           code  fffc0eb8 18
  fltToString.0036                           code  fffc0ec8 18
  fltToString.0037                           code  fffc0ed4 18
  fltToString.0038                           code  fffc0edc 18
  fltToString.0039                           code  fffc0ef0 18
  fltToString.0040                           code  fffc0ee4 18
  fltToString.0041                           code  fffc0f4c 18
  fltToString.0042                           code  fffc0f10 18
  fltToString.0043                           code  fffc0f20 18
  fltToString.0044                           code  fffc0f34 18
  fltToString.0045                           code  fffc0f18 18
  fltToString.0046                           code  fffc0f40 18
  fltToString.0047                           code  fffc0f4c 18
  fltToString.0048                           code  fffc0f38 18
  fltToString.0050                           code  fffc0f6c 18
  fltToString.0051                           code  fffc0f68 18
  fltToString.0052                           code  fffc0f58 18
  fltToString.inf                            code  fffc0c08 18
  fltToString.notZero                        code  fffc0c5c 18
  fltToString.pos                            code  fffc0c48 18
  fltToString.prt                            code  fffc0f00 18
  fputc                                      code  fffc0308 18
  fv1                                        code  fffc5fc4 18
  fv2                                        code  fffc5fd8 18
  fv3                                        code  fffc5fbc 18
  fv4                                        code  fffc5f80 18
  gen_rand                                   code  800000000000040c 32
  getVarName                                 code  fffc5eb8 18
  gfn1                                       code  fffc573c 18
  gfn2                                       code  fffc56d4 18
  gfn3                                       code  fffc5710 18
  gosub1                                     code  fffc5220 18
  gvn1                                       code  fffc5f50 18
  gvn2                                       code  fffc5f14 18
  gvn3                                       code  fffc5f30 18
  gvn4                                       code  fffc5ed8 18
  gvn6                                       code  fffc5f04 18
  hKeybdMbx                                 const  024822 19
  isAlnum                                    code  fffc5ae8 18
  isAlpha                                    code  fffc5ab8 18
  isAlphaFalse                               code  fffc5ae0 18
  isAlphaTrue                                code  fffc5ad8 18
  isDigit                                    code  fffc5a98 18
  isDigitFalse                               code  fffc5ab0 18
  isDigitx                                   code  fffc5afc 18
  mbxs                                      const  020000 19
  mbxs_end                                  const  022000 19
  milliseconds                              const  014208 18
  missed_ticks                              const  024320 19
  msgBadGotoGosub                            code  fffc6d35 18
  msgBadKeybd                                code  8000000000000297 32
  msgBytesFree                               code  fffc6c6d 18
  msgCRLF                                    code  fffc0b8a 18
  msgComma                                   code  fffc6c82 18
  msgDivZero                                 code  fffc6c44 18
  msgEnvFail                                 code  fffc6d9d 18
  msgExtraChars                              code  fffc6d7b 18
  msgInf                                     code  fffc0f74 18
  msgInit                                    code  fffc6bcc 18
  msgInputVar                                code  fffc6ce4 18
  msgLineRange                               code  fffc6c95 18
  msgMonHelp                                 code  fffc0ad2 18
  msgNan                                     code  fffc0f78 18
  msgNextFor                                 code  fffc6d00 18
  msgNextVar                                 code  fffc6d12 18
  msgNumTooBig                               code  fffc6c31 18
  msgParen                                   code  fffc6db7 18
  msgRNDBad                                  code  fffc6cc0 18
  msgReadError                               code  fffc6c17 18
  msgReady                                   code  fffc6c7a 18
  msgReadyList                               code  fffc3740 18
  msgRetWoGosub                              code  fffc6d51 18
  msgSYSBad                                  code  fffc6cd3 18
  msgStart                                   code  fffc0ab8 18
  msgTaskStart                               code  fffc0b7c 18
  msgTimeoutList                             code  fffc3771 18
  msgTooBig                                  code  fffc6d67 18
  msgVar                                     code  fffc6caa 18
  msgVarSpace                                code  fffc6c56 18
  msgWhat                                    code  fffc6c08 18
  msgs                                      const  010000 18
  nmeSerial                                  code  fffc1924 18
  prCRLF                                     code  fffc6688 18
  pword1                                     code  fffc58bc 18
  pword2                                     code  fffc58dc 18
  qToChk                                     code  fffc212a 18
  return1                                    code  fffc5298 18
  rnd1                                       code  fffc60b4 18
  rnd2                                       code  fffc60c4 18
  switchflag                                const  014200 18
  sysx1                                      code  fffc59c0 18
  tah1                                       code  fffc5914 18
  toAsciiHex                                 code  fffc5904 18
  toUpper                                    code  fffc693c 18
  tstv_notfound                              code  fffc5ea4 18
  usrJmp                                    const  0300a0 19

Undefined Symbols
  A00000000000000                          rodata  800000000000048d 32
  AUXIN                                      code  80000000000002e7 32
  AUXIN_INIT                                 code  80000000000003ba 32
  AUXOUT                                     code  80000000000002e5 32
  AUXOUT_FLUSH                               code  80000000000003c7 32
  AUXOUT_INIT                                code  80000000000003be 32
  ERETx                                      code  8000000000000250 32
  FFFC0100                                   code  80000000000002d7 32
  FMTK_Initialize                            code  80000000000001ca 32
  FMTK_PostMsg                               code  80000000000001d2 32
  FMTK_SetTaskPriority                       code  80000000000001ce 32
  FMTK_StartApp                              code  80000000000001d6 32
  KEYBD                                      code  8000000000000290 32
  KeybdIRQ.notAlt                            code  80000000000002aa 32
  KillTask                                   code  8000000000000219 32
  SDReadSector                               code  80000000000003bb 32
  SDWriteSector                              code  80000000000003c0 32
  TCBKbdState2                               code  80000000000002a5 32
  TCBVidMem                                  code  800000000000021f 32
  _ACBPtrs                                 rodata  000000 32
  _Alloc                                   rodata  fffc121c 32
  _BIOS1_sema                              rodata  000000 32
  _BIOS_RespMbx                            rodata  000000 32
  _DeviceTable                             rodata  000000 32
  _DumpTaskList                            rodata  000000 32
  _FMTK_Inited                             rodata  000000 32
  _FMTK_Reschedule                         rodata  000000 32
  _FMTK_SendMsg                            rodata  000000 32
  _FMTK_StartApp                           rodata  000000 32
  _FMTK_StartThread                        rodata  000000 32
  _FMTK_WaitMsg                            rodata  000000 32
  _FocusSwitcher                           rodata  000000 32
  _GetACBPtr                               rodata  000000 32
  _GetAppHandle                            rodata  000000 32
  _GetRand                                 rodata  fffc43e0 32
  _GetRunningACBPtr                        rodata  000000 32
  _GetVecno                                rodata  000000 32
  _IOFocusNdx                              rodata  000000 32
  _IOFocusTbl                              rodata  000000 32
  _InsertIntoReadyList                     rodata  000000 32
  _InsertIntoTimeoutList                   rodata  000000 32
  _KeyLED                                  rodata  024826 32
  _KeyState1                               rodata  024824 32
  _KeyState2                               rodata  024825 32
  _KeybdClearRcv                           rodata  000000 32
  _KeybdGetScancode                        rodata  fffc41bc 32
  _KeybdGetStatus                          rodata  fffc4194 32
  _KeybdID                                   code  800000000000029d 32
  _KeybdSetLED                             rodata  fffc3fec 32
  _LockIOFSemaphore                        rodata  000000 32
  _LockKbdSemaphore                        rodata  000000 32
  _LockSemaphore                           rodata  000000 32
  _LockSysSemaphore                        rodata  000000 32
  _RemoveFromReadyList                     rodata  000000 32
  _RemoveFromTimeoutList                   rodata  000000 32
  _RequestIOFocus                          rodata  000000 32
  _SetBound48                              rodata  000000 32
  _SetBound49                              rodata  000000 32
  _SetBound50                              rodata  000000 32
  _SetBound51                              rodata  000000 32
  _TimeoutList                             rodata  000000 32
  _VirtToPhys                              rodata  fffc1308 32
  _bios_stacks                             rodata  000000 32
  _chkTCB                                  rodata  000000 32
  _cls                                       code  8000000000000337 32
  _fmtk_irq_stack                          rodata  000000 32
  _fmtk_sys_stack                          rodata  000000 32
  _freeMBX                                 rodata  000000 32
  _freeMSG                                 rodata  000000 32
  _freeTCB                                 rodata  000000 32
  _getCPU                                  rodata  000000 32
  _hFocusSwitchMbx                         rodata  000000 32
  _hasUltraHighPriorityTasks               rodata  000000 32
  _iof_sema                                rodata  000000 32
  _iof_switch                              rodata  000000 32
  _irq_stack                               rodata  000000 32
  _kbd_sema                                rodata  000000 32
  _keybdControlCodes                       rodata  fffc3cb0 32
  _keybdExtendedCodes                      rodata  fffc3d30 32
  _mailbox                                 rodata  000000 32
  _message                                 rodata  000000 32
  _missed_ticks                            rodata  000000 32
  _mmu_Alloc512kPage                       rodata  000000 32
  _mmu_Alloc8kPage                         rodata  000000 32
  _mmu_AllocateMap                         rodata  000000 32
  _mmu_Free512kPage                        rodata  000000 32
  _mmu_Free8kPage                          rodata  000000 32
  _mmu_FreeMap                             rodata  000000 32
  _mmu_MapCardMemory                       rodata  000000 32
  _mmu_SetAccessKey                        rodata  000000 32
  _mmu_SetMapEntry                         rodata  000000 32
  _mmu_SetOperateKey                       rodata  000000 32
  _mmu_alloc                               rodata  000000 32
  _mmu_free                                rodata  000000 32
  _nMailbox                                rodata  000000 32
  _nMsgBlk                                 rodata  000000 32
  _outb                                    rodata  000000 32
  _outc                                    rodata  000000 32
  _outh                                    rodata  000000 32
  _outw                                    rodata  000000 32
  _randStream                              rodata  024830 32
  _rdcf                                      code  8000000000000339 32
  _readyQ                                  rodata  000000 32
  _set_vector                              rodata  000000 32
  _shiftedScanCodes                        rodata  fffc3bb0 32
  _stacks                                  rodata  000000 32
  _sys_sema                                rodata  000000 32
  _sys_stacks                              rodata  000000 32
  _sysstack                                rodata  000000 32
  _tcbs                                    rodata  000000 32
  _unshiftedScanCodes                      rodata  fffc3ab0 32
  _video_bufs                              rodata  000000 32
  gen_rand                                   code  800000000000040c 32
  msgBadKeybd                                code  8000000000000297 32

  Macro Name
 mDispIRQLive                              -842150451

	ldo      $v0,$FFD00000+440
	add     	$v0,$v0,#1
	sto      $v0,$FFD00000+440

 mGetCurrentTid                            -842150451

	csrrw	v0,#$181,x0
	and		v0,v0,#MAX_TID

 mGetVideoPtr                              -842150451

	
	csrrw	v0,#$181,x0
	and		v0,v0,#MAX_TID
sll		$v0,$v0,#LOG_TCBSZ
	ldo		$v0,TCBpVideo[$v0]
	ldi		$v0,#$FFD00000

 mHasFocus                                 -842150451

	ldi		$a0,#20
	ecall

 mLockSysMutex                             -842150451

	
	csrrw	v0,#$181,x0
	and		v0,v0,#MAX_TID
sll		$v0,$v0,#1
	or		$v0,$v0,#1
	ldi		$t0,#$FFDBFF00
.lock@:
	sto		$v0,[$t0]
	ldo		$v1,[$t0]
	bne		$v0,$v1,.lock@

 mPopTimeoutList                           -842150451

	sll		$t0,$v0,#LOG_TCBSZ		; tid to pointer
	lbu		$v1,TCBStatus[$t0]		; no longer a waiting status
	and		$t1,$v1,#TS_WAITMSG		; check if waiting for a message
	beqz	$t1,.noWait@
	mMbxRemoveTask							; remove task from mailbox list
.noWait@:
	and		$v1,$v1,#~(TS_WAITMSG|TS_TIMEOUT)
	stb		$v1,TCBStatus[$t0]
	ldw		$v1,TCBNext[$t0]			; get next task on timeout list
	stw		$v1,TimeoutList				; update list head
	ldi		$t1,#NR_TCB						; check valid handle
	bgeu	$v1,$t1,.done@
	ldi		$t1,#-1								;
	sll		$v1,$v1,#LOG_TCBSZ		; v1 = tid to pointer
	stw		$t1,TCBPrev[$v1]			; TimeoutList->prev = -1
.done@:
	ldi		$t1,#-1								; reset next and prev indexes
	stw		$t1,TCBNext[$t0]			; on popped task
	stw		$t1,TCBPrev[$t0]

 mSleep                                    1

	ldi		$a0,#5
	ldi		$a1,#0
	ecall

 mUnlockSemaphore                          1

	ldi		v0,#-1
	sw		v0,0

 mWaitForFocus                             -842150451

.WFF1@:
	
	ldi		$a0,#20
	ecall
bne		v1,x0,.HasFocus@
	call	SerialPeekChar	;Direct
	ldi		a0,#$14							; CTRL-T
	bne		$v0,$a0,.WFF2@
	call	SerialGetChar
	ldi		$a0,#21							; switch IO Focus
	ecall
	bra		.WFF1@
.WFF2@:
	
	ldi		$a0,#5
	ldi		$a1,#1
	ecall

	bra		.WFF1@
.HasFocus@:

0 compressable instructions
The top 1024 are:
Comp  Opcode  Count
