                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/const.r5a",1
                        	.file "../fmtk/const.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	; First 256 bytes are for integer register set
                        	; Second 256 bytes are for float register set
                        	; Leave some room for 64-bit regs
                        	TCBsegs			EQU		$200		; segment register storage
                        	TCBepc			EQU		$280
                        	TCBStatus		EQU		$288
                        	TCBPriority	EQU		$289
                        	TCBWaitMbx	EQU		$28A
                        	TCBStackBot	EQU		$290
                        	TCBMsgD1		EQU		$298
                        	TCBMsgD2		EQU		$2A0
                        	TCBMsgD3		EQU		$2A8
                        	TCBStartTime	EQU		$2B0
                        	TCBEndTime		EQU		$2B8
                        	TCBElapsedTime		EQU		$2C0
                        	TCBException	EQU	$2C8
                        	TCBNext			EQU		$2D0
                        	TCBPrev			EQU		$2D8
                        	TCBTimeout	EQU		$2E0
                        	IOF_NEXT		EQU		$2E8
                        	IOF_PREV		EQU		$2F0
                        	TCBName			EQU		$2F8
                        	TCBKbdHead	EQU		$300
                        	TCBKbdTail	EQU		$301
                        	TCBKbdBuf		EQU		$308
                        	; 328 end of keyboard buffer
                        	TCBResource	EQU		$328
                        	TCBVideoMem	EQU		$330
                        	TCBpVideo		EQU		$338
                        	
                        	TS_NONE			EQU		0
                        	TS_READY		EQU		1
                        	TS_DEAD			EQU		2
                        	TS_MSGRDY		EQU		4
                        	TS_WAITMSG	EQU		8
                        	TS_TIMEOUT	EQU		16
                        	TS_PREEMPT	EQU		32
                        	TS_RUNNING	EQU		128
                        	
                        	; error codes
                        	E_Ok		=		0x00
                        	E_Arg		=		0x01
                        	E_BadMbx	=		0x04
                        	E_QueFull	=		0x05
                        	E_NoThread	=		0x06
                        	E_NotAlloc	=		0x09
                        	E_NoMsg		=		0x0b
                        	E_Timeout	=		0x10
                        	E_BadAlarm	=		0x11
                        	E_NotOwner	=		0x12
                        	E_QueStrategy =		0x13
                        	E_BadDevNum	=		0x18
                        	E_DCBInUse	=		0x19
                        	E_BadCallno	=  0x1A
                        	; Device driver errors
                        	E_BadDevNum	=		0x20
                        	E_NoDev		=		0x21
                        	E_BadDevOp	=		0x22
                        	E_ReadError	=		0x23
                        	E_WriteError =		0x24
                        	E_BadBlockNum	=	0x25
                        	E_TooManyBlocks	=	0x26
                        	
                        	; resource errors
                        	E_NoMoreMbx	=		0x40
                        	E_NoMoreMsgBlks	=	0x41
                        	E_NoMoreAlarmBlks	=0x44
                        	E_NoMoreTCBs	=	0x45
                        	E_NoMem		= 12
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/config.r5a",1
                        	.file "../fmtk/config.r5a",1
                        	MAX_TID		EQU		63
                        	NR_TCB		EQU		64
                        	NR_MBX		EQU		256
                        	NR_MSG		EQU		2048
                        	LOG_TCBSZ	EQU		10
                        	LOG_PGSZ	EQU		16
                        	PAGESZ		EQU		65536
                        	PAGES_PER_TASK	EQU		4096	; maximum number of pages per task
                        	OSPAGES		EQU		3			; pages of memory dedicated to OS
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/device.r5a",1
                        	.file "../fmtk/device.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2014-2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; DeviceDriver.inc
                        	; - Device driver structures and constants                                                                         
                        	; ============================================================================
                        	
                        	;	.global			; global constants
                        	
                        	; Device Control Block
                        	;
                        	DCB_Name			EQU		0		; string: first byte is length, 11 chars max
                        	DCB_Type			EQU		0x0C
                        	DCB_nBPB			EQU		0x10
                        	DCB_LastErc			EQU		0x18		; last error code
                        	DCB_StartBlock		EQU		0x20		; starting block number (partitioned devices)
                        	DCB_nBlocks			EQU		0x28		; number of blocks on device
                        	DCB_pCmdProc		EQU		0x30		; pointer to command processor routine
                        	DCB_ReentCount		EQU		0x38		; re-entrancy count (1 to 255)
                        	DCB_fSingleUser		EQU		0x39
                        	DCB_hJob			EQU		0x40		; handle to associated job
                        	DCB_Mbx				EQU		0x48
                        	DCB_pSema			EQU		0x50		; pointer to device semaphore
                        	DCB_Resv1			EQU		0x58		; reserved
                        	DCB_Resv2			EQU		0x60		; reserved
                        	DCB_Size			EQU		0x68
                        	
                        	; Device command opcodes
                        	;
                        	DVC_Nop				EQU		0
                        	DVC_Setup			EQU		1
                        	DVC_Initialize		EQU		2
                        	DVC_Status			EQU		3
                        	DVC_MediaCheck		EQU		4
                        	DVC_BuildBPB		EQU		5
                        	DVC_Open			EQU		6
                        	DVC_Close			EQU		7
                        	DVC_GetChar			EQU		8
                        	DVC_PeekChar		EQU		9
                        	DVC_GetCharDirect	EQU		10
                        	DVC_PeekCharDirect	EQU		11
                        	DVC_InputStatus		EQU		12
                        	DVC_PutChar			EQU		13
                        	DVC_SetPosition		EQU		15
                        	DVC_ReadBlock		EQU		16
                        	DVC_WriteBlock		EQU		17
                        	DVC_VerifyBlock		EQU		18
                        	DVC_OutputStatus	EQU		19
                        	DVC_FlushInput		EQU		20
                        	DVC_FlushOutput		EQU		21
                        	DVC_IRQ				EQU		22
                        	DVC_IsRemoveable	EQU		23
                        	DVC_IOCTRL_READ		EQU		24
                        	DVC_IOCTRL_WRITE	EQU		25
                        	DVC_OutputUntilBusy	EQU		26
                        	
                        	MAX_DEV_OP			EQU		31
                        	
                        	
                        	DRSP_DONE			EQU		1
                        	
                        	;Standard Devices are:
                        	
                        	;#		Device					Standard name
                        	
                        	;0		NULL device 			NUL		(OS built-in)
                        	;1		Keyboard (sequential)	KBD		(OS built-in)
                        	;2		Video (sequential)		VID		(OS built-in)
                        	;3		Printer (parallel 1)	LPT
                        	;4		Printer (parallel 2)	LPT2
                        	;5		RS-232 1				COM1	(OS built-in)
                        	;6		RS-232 2				COM2
                        	;7		RS-232 3				COM3
                        	;8		RS-232 4				COM4
                        	;9		Parallel xfer	  PTI
                        	;10		Floppy					FD0
                        	;11		Floppy					FD1
                        	;12		Hard disk				HD0
                        	;13		Hard disk				HD1
                        	;14
                        	;15
                        	;16		SDCard					CARD1 	(OS built-in)
                        	;17
                        	;18
                        	;19
                        	;20
                        	;21
                        	;22
                        	;23
                        	;24
                        	;25
                        	;26
                        	;27
                        	;28		Audio						PSG1	(OS built-in)
                        	;29
                        	;30   Random Number		PRNG
                        	;31		Debug						DBG
                        	
                        	NR_DCB			EQU		32
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/macro.r5a",1
                        	.file "../fmtk/macro.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	; macros have to be defined before they are encountered.
                        	
                        	; unlock the a semaphore	
                        	macro mUnlockSemaphore (adr)
	ldi		v0,#-1
	sw		v0,adr
endm
                        	
                        	; Look at the asid register for task id
                        	macro mGetCurrentTid
	csrrw	v0,#$181,x0
	and		v0,v0,#15
endm
                        	
                        	macro	mHasFocus
	ldi		a0,#20
	ecall
endm
                        	
                        	macro mSleep(tm)
	ldi		a0,#5
	ldi		a1,#tm
	ecall
endm
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	macro mWaitForFocus
.WFF1@:
	
	ldi		a0,#20
	ecall
bne		v1,x0,.HasFocus@
	call	SerialPeekChar	;Direct
	ldi		a0,#$14							; CTRL-T
	bne		$v0,$a0,.WFF2@
	call	SerialGetChar
	ldi		$a0,#21							; switch IO Focus
	ecall
	bra		.WFF1@
.WFF2@:
	
	ldi		a0,#5
	ldi		a1,#1
	ecall

	bra		.WFF1@
.HasFocus@:
endm
                        	
                        	;------------------------------------------------------------------------------
                        	; Pop an entry off the timeout list. It is assumed the entry is popped when
                        	; its timeout reached zero. Hence there is no adjustment of the following
                        	; timeout made. Routine used only in the schedulerIRQ, so written as a macro.
                        	;
                        	; Parameters:
                        	;		v0 = top timeout list
                        	; Modifies:
                        	;		v1,t0,t1,t2,t3
                        	;	Returns:
                        	;		v0 = timeout list entry tid
                        	;------------------------------------------------------------------------------
                        	
                        	macro mPopTimeoutList
	sll		$t0,$v0,#LOG_TCBSZ		; tid to pointer
	lbu		$v1,TCBStatus[$t0]		; no longer a waiting status
	and		$t1,$v1,#TS_WAITMSG		; check if waiting for a message
	beqz	$t1,.noWait@
	mMbxRemoveTask							; remove task from mailbox list
.noWait@:
	and		$v1,$v1,#~(TS_WAITMSG|TS_TIMEOUT)
	stb		$v1,TCBStatus[$t0]
	ldw		$v1,TCBNext[$t0]			; get next task on timeout list
	stw		$v1,TimeoutList				; update list head
	ldi		$t1,#NR_TCB						; check valid handle
	bgeu	$v1,$t1,.done@
	ldi		$t1,#-1								;
	sll		$v1,$v1,#LOG_TCBSZ		; v1 = tid to pointer
	stw		$t1,TCBPrev[$v1]			; TimeoutList->prev = -1
.done@:
	ldi		$t1,#-1								; reset next and prev indexes
	stw		$t1,TCBNext[$t0]			; on popped task
	stw		$t1,TCBPrev[$t0]
endm
                        	
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/global.r5a",1
                        	.file "../fmtk/global.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	;
                        	; 00000000	+-----------------------------------
                        	;						| Task Control Blocks (64 x 1kB)
                        	; 00010000	+-----------------------------------
                        	;						| Message Array (2048 x 32b)
                        	; 00020000	+-----------------------------------
                        	;						| Mailbox Array (256 x 32b)
                        	; 00022000	+-----------------------------------
                        	;						| Device Control Blocks (32 x 256b)
                        	; 00024000	+-----------------------------------
                        	
                        	msgs		EQU		$10000
                        	mbxs		EQU		$20000
                        	mbxs_end	EQU	$22000
                        	; The following must be at least 256 byte aligned
                        	DVF_Base		EQU		$22000
                        	DVF_Limit		EQU		$24000
                        	QNDX		EQU		$24304
                        	READYQ	EQU		$24308
                        	PIDMAP	EQU		$24310
                        	missed_ticks	equ		$24320
                        	TimeoutList		equ		$24328
                        	Tick		EQU		$24330
                        	SysSema	EQU		$24340
                        	FreeMsg	EQU		$24350
                        	RDYQ0		EQU		$24400
                        	RDYQ1		EQU		$24500
                        	RDYQ2		EQU		$24600
                        	RDYQ3		EQU		$24700
                        	CursorX		equ		$24800
                        	CursorY		equ		$24801
                        	DispAttr	equ		$24808
                        	IOFocusNdx		EQU		$24810
                        	IOFocusTbl		EQU		$24818
                        	SwitchIOFocus	EQU		$24820
                        	hKeybdMbx	equ		$24822
                        	NPAGES	equ		$24828
                        	
                        	SerRcvBuf		EQU		$25000
                        	SerXmitBuf	EQU		$25400
                        	SerHeadRcv	EQU		$25800
                        	SerTailRcv	EQU		$25804
                        	SerHeadXmit	EQU		$25808
                        	SerTailXmit	EQU		$2580C
                        	SerRcvXon		EQU		$25810
                        	SerRcvXoff	EQU		$25811
                        	
                        	
                        	
                        	
                        	
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	
                        	CTRLC				equ		$03
                        	BS					equ		$08
                        	LF					equ		$0A
                        	CR					equ		$0D
                        	XON					equ		$11
                        	XOFF				equ		$13
                        	DEL					equ		$7F
                        	LEDS				equ		$FFDC0600
                        	VIA					equ		$FFDC0600
                        	VIA_PA			equ		$04
                        	VIA_DDRA		equ		$0C
                        	VIA_T1CL		equ		$10
                        	VIA_T1CH		equ		$14
                        	VIA_ACR			equ		$2C
                        	VIA_PCR			equ		$30
                        	VIA_IFR			equ		$34
                        	VIA_IER			equ		$38
                        	VIA_PARAW		equ		$3C
                        	UART				equ		$FFDC0A00
                        	UART_TRB		equ		$00
                        	UART_STAT		equ		$04
                        	UART_CMD		equ		$08
                        			; First 16kB is for TCB's
                        	INBUF				equ		$14100
                        	switchflag	equ		$14200
                        	milliseconds	equ		$14208
                        	
                        	
                        	.file "boot.r5a",31
                        		code	18 bits
                        	;------------------------------------------------------------------------------
                        	; Exception vector table.
                        	;------------------------------------------------------------------------------
                        		org		$FFFC0000				; user mode exception
FFFC0000 7DC0006F		jmp		IRQRout
FFFC0004 00000000		org		$FFFC0040				; supervisor mode exception (not possible)
FFFC0008 00000000
FFFC000C 00000000
FFFC0010 00000000
FFFC0014 00000000
FFFC0018 00000000
FFFC001C 00000000
FFFC0020 00000000
FFFC0024 00000000
FFFC0028 00000000
FFFC002C 00000000
FFFC0030 00000000
FFFC0034 00000000
FFFC0038 00000000
FFFC003C 00000000
FFFC0040 79C0006F		jmp		IRQRout
FFFC0044 00000000		org		$FFFC0080				; hypervisor mode exception (not possible)
FFFC0048 00000000
FFFC004C 00000000
FFFC0050 00000000
FFFC0054 00000000
FFFC0058 00000000
FFFC005C 00000000
FFFC0060 00000000
FFFC0064 00000000
FFFC0068 00000000
FFFC006C 00000000
FFFC0070 00000000
FFFC0074 00000000
FFFC0078 00000000
FFFC007C 00000000
FFFC0080 75C0006F		jmp		IRQRout
FFFC0084 00000000		org 	$FFFC00C0				; machine mode exception
FFFC0088 00000000
FFFC008C 00000000
FFFC0090 00000000
FFFC0094 00000000
FFFC0098 00000000
FFFC009C 00000000
FFFC00A0 00000000
FFFC00A4 00000000
FFFC00A8 00000000
FFFC00AC 00000000
FFFC00B0 00000000
FFFC00B4 00000000
FFFC00B8 00000000
FFFC00BC 00000000
FFFC00C0 71C0006F		jmp		IRQRout
FFFC00C4 00000000		org		$FFFC00FC				; non-maskable interrupt
FFFC00C8 00000000
FFFC00CC 00000000
FFFC00D0 00000000
FFFC00D4 00000000
FFFC00D8 00000000
FFFC00DC 00000000
FFFC00E0 00000000
FFFC00E4 00000000
FFFC00E8 00000000
FFFC00EC 00000000
FFFC00F0 00000000
FFFC00F4 00000000
FFFC00F8 00000000
FFFC00FC 0040006F		jmp		MachineStart
                        	
                        	;------------------------------------------------------------------------------
                        	; User mode code starts here
                        	;------------------------------------------------------------------------------
                        		org		$FFFC0100
                        	MachineStart:
FFFC0100 1FFFC737		ldi		$sp,#$1FFFBFF8		; setup machine mode stack pointer
FFFC0104 FF870713
                        		; The dram needs a bit of time before it's ready for access. along with
                        		; the video screen which also needs some time. So the first thing done is
                        		; to delay for about 3 seconds.
FFFC0108 FFDC0DB7		ldi		$t1,#VIA
FFFC010C 600D8D93
FFFC0110 0FF06D13		ldi		$t0,#$000000FF		; set via so we can see output on LEDs
FFFC0114 01ADA623		stt		$t0,VIA_DDRA[$t1]
FFFC0118 03938937		ldi		$a0,#60000000			; 3s in 50ns intervals
FFFC011C 70090913
FFFC0120 690000EF		call	_MicroDelay
FFFC0124 3C1000EF		call	MMUInit					; initialize MMU for address space zero.
FFFC0128 0F9010EF		call	FMTKInit
FFFC012C 604010EF		call	VideoInit
FFFC0130 488010EF		call	ViaInit
FFFC0134 74D000EF		call	SerialInit
FFFC0138 178030EF		call	_KeybdInit
FFFC013C 655000EF		call	PicInit
FFFC0140 00006D13		ldi		$t0,#0
FFFC0144 181D1073		csrrw	$x0,#$181,$t0		; set ASID
FFFC0148 FFFC0D37		ldi		$t0,#$FFFC0000
FFFC014C 000D0D13
FFFC0150 301D1073		csrrw $x0,#$301,$t0		; set tvec
FFFC0154 FFFC0D37		ldi		$t0,#UserStart
FFFC0158 168D0D13
FFFC015C 341D1073		csrrw	$x0,#$341,$t0		; set mepc
FFFC0160 30046073		csrrs	$x0,#$300,#8		; enable interrupts (on eret)
FFFC0164 10000073		eret									; switch to user mode
                        	UserStart:
FFFC0168 00106913		ldi		$a0,#1					; start TinyBasic
FFFC016C 000089B7		ldi		$a1,#32000
FFFC0170 D0098993
FFFC0174 FFFC3A37		ldi		$a2,#CSTART
FFFC0178 730A0A13
FFFC017C 00000073		ecall
FFFC0180 00106913		ldi		$a0,#1
FFFC0184 000069B7		ldi		$a1,#24000
FFFC0188 DC098993
FFFC018C FFFC0A37		ldi		$a2,#UserStart2
FFFC0190 198A0A13
FFFC0194 00000073		ecall
                        	;	wfi
                        	UserStart2:
FFFC0198 03938937		ldi		$a0,#60000000				; 3s in 50ns intervals
FFFC019C 70090913
FFFC01A0 610000EF		call	_MicroDelay
FFFC01A4 604010EF		call	VideoClearScreen
FFFC01A8 62C010EF		call	VideoHomeCursor
FFFC01AC 00E06913		ldi		$a0,#14							; Get current tid
FFFC01B0 00000073		ecall
FFFC01B4 0008E9B3		mov		$a1,$v1
FFFC01B8 01806913		ldi		$a0,#24							; RequestIOFocus
FFFC01BC 00000073		ecall
                        	;	ldi		$sp,#$1FFF7FF8			; setup user mode stack pointer
FFFC01C0 B0000737		ldi		$sp,#$AFFFFFFC
FFFC01C4 FFC70713
FFFC01C8 00406D13		ldi		$t0,#$04						; turn on the LED
FFFC01CC FFDC0637		stt		$t0,VIA+VIA_PARAW
FFFC01D0 63C60613
FFFC01D4 00060633
FFFC01D8 01A62023
FFFC01DC 01006E13		ldi		$t2,#16							; send an XON just in case
                        	;	ldi		$a3,#XON
                        	;.0004:
                        	;	call	SerialPutChar
                        	;	sub		$t2,$t2,#1
                        	;	bnez	$t2,.0004
                        	.0002:
FFFC01E0 FFFC1937		ldi		$a0,#msgStart				; spit out a startup message
FFFC01E4 82090913
FFFC01E8 594000EF		call	PutString
                        	;		ldi		a0,#1
                        	;		ldi		a1,#24000
                        	;		ldi		a2,#Monitor
                        	;		ecall
FFFC01EC 045020EF		call	DumpReadyList
FFFC01F0 0C000463		bra		MonEntry
                        	
                        			; Now a loop to recieve and echo back characters
                        	.0003:
FFFC01F4 0B8010EF		call	SerialPeekChar
FFFC01F8 FE084EE3		blt		$v0,$x0,.0003
FFFC01FC 00086933		mov		$a0,$v0
FFFC0200 170010EF		call	SerialPutChar
FFFC0204 FE0008E3		bra		.0003
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	IdleTask:
FFFC0208 00000063		bra		IdleTask
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a character from input device. Checks for a CTRL-T which indicates to
                        	; switch the I/O focus.
                        	;
                        	; Parameters:
                        	;		none
                        	; Returns:
                        	;		v0 = character, -1 if none available
                        	;------------------------------------------------------------------------------
                        	
                        	Getch:
FFFC020C FE870713		sub		$sp,$sp,#24
FFFC0210 00173023		sto		$ra,[$sp]
FFFC0214 01273423		sto		$a0,8[$sp]
FFFC0218 01373823		sto		$a1,16[$sp]
                        	;	mWaitForFocus
FFFC021C 7C1000EF		call	SerialGetChar
FFFC0220 00073083		ldo		$ra,[$sp]
FFFC0224 00873903		ldo		$a0,8[$sp]
FFFC0228 01073983		ldo		$a1,16[$sp]
FFFC022C 01870713		add		$sp,$sp,#24
FFFC0230 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	Putch:
FFFC0234 FD870713		sub		$sp,$sp,#40
FFFC0238 00173023		sto		$ra,[$sp]
FFFC023C 01073423		sto		$v0,8[$sp]
FFFC0240 01573823		sto		$a3,16[$sp]
FFFC0244 01173C23		sto		$v1,24[$sp]
FFFC0248 03373023		sto		$a1,32[$sp]
FFFC024C 00096AB3		mov		$a3,$a0
                        	;	call	SerialPutChar
FFFC0250 5E4010EF		call	VideoPutChar
                        	;	ldi		$a1,#5							; serial port = 5
                        	;	call	fputc
                        	;	ldi		$a1,#2							; video = 2
                        	;	call	fputc
FFFC0254 00073083		ldo		$ra,[$sp]
FFFC0258 00873803		ldo		$v0,8[$sp]
FFFC025C 01073A83		ldo		$a3,16[$sp]
FFFC0260 01873883		ldo		$v1,24[$sp]
FFFC0264 02073983		ldo		$a1,32[$sp]
FFFC0268 02870713		add		$sp,$sp,#40
FFFC026C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; fputc - put a character to an I/O device. If the task doesn't have the I/O
                        	; focus then it is rescheduled, allowing another task to run.
                        	;
                        	; Stack Space:
                        	;		6 words
                        	; Register Usage:
                        	;		a0 = FMTK_IO specify
                        	;		a2 = device putchar function
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a3 = character to put
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	fputc:
FFFC0270 FD070713		sub		$sp,$sp,#48
FFFC0274 00173023		sto		$ra,[$sp]
FFFC0278 01073423		sto		$v0,8[$sp]
FFFC027C 01273823		sto		$a0,16[$sp]
FFFC0280 01173C23		sto		$v1,24[$sp]
FFFC0284 03373023		sto		$a1,32[$sp]
FFFC0288 03473423		sto		$a2,40[$sp]
                        	;	mWaitForFocus
FFFC028C 01A06913		ldi		$a0,#26							; FMTK_IO
FFFC0290 00D06A13		ldi		$a2,#13							; putchar function
FFFC0294 00000073		ecall
FFFC0298 00073083		ldo		$ra,[$sp]
FFFC029C 00873803		ldo		$v0,8[$sp]
FFFC02A0 01073903		ldo		$a0,16[$sp]
FFFC02A4 01873883		ldo		$v1,24[$sp]
FFFC02A8 02073983		ldo		$a1,32[$sp]
FFFC02AC 02873A03		ldo		$a2,40[$sp]
FFFC02B0 03070713		add		$sp,$sp,#48
FFFC02B4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	MonEntry:
                        	;		flw			$f2,fltTen
                        	;		fsw			$f2,f2Save
                        	;		flw			$f1,fltTen
                        	;		fsw			$f1,f1Save
                        	;		fadd		$f18,$f2,$f1
                        	;		fsw			$f18,f18Save
FFFC02B8 00A06913			ldi		$a0,#10
FFFC02BC 00606A13			ldi		$a2,#6
                        	;		call	fltToString
                        	;		ldi		$a0,#STRTMP
                        	;		call	PutString
                        	
                        	Monitor:
FFFC02C0 B0000737		ldi		$sp,#$AFFFFFFC
FFFC02C4 FFC70713
FFFC02C8 3000F073		csrrc	$x0,#$300,#1
                        	;		call	DumpReadyList
                        	;		call	DumpTimeoutList
FFFC02CC 3000E073		csrrs	$x0,#$300,#1
FFFC02D0 00006213		ldi		$s1,#0					; s1 = input pointer
FFFC02D4 00D06913		ldi		$a0,#CR
FFFC02D8 F5DFF0EF		call	Putch
FFFC02DC 00006913		ldi		$a0,#LF
	call	Putch
FFFC02E0 F55FF0EF
FFFC02E4 03E06913		ldi		$a0,#'>'
FFFC02E8 F4DFF0EF		call	Putch
                        	.0001:
FFFC02EC F21FF0EF			call	Getch						; wait until character pressed
FFFC02F0 FE084EE3			blt		$v0,$x0,.0001
FFFC02F4 00084D13			xor		$t0,$v0,#LF			; ignore line feed
		beq		$t0,$x0,.procLine
FFFC02F8 0E0D0C63
FFFC02FC 00D84D13			xor		$t0,$v0,#CR
FFFC0300 0E0D0863			beq		$t0,$x0,.procLine
FFFC0304 00884D13			xor		$t0,$v0,#BS
FFFC0308 080D0263			beq		$t0,$x0,.doBackspace
FFFC030C 07F84D13			xor		$t0,$v0,#DEL
FFFC0310 020D0263			beq		$t0,$x0,.doDelete
FFFC0314 00014637			sb		$v0,INBUF[$s1]
FFFC0318 10060613
FFFC031C 00460633
FFFC0320 01060023
FFFC0324 00120213			add		$s1,$s1,#1
FFFC0328 00086933			mov		$a0,$v0
FFFC032C F09FF0EF			call	Putch
FFFC0330 FA000EE3			bra		.0001
                        	.doDelete:
FFFC0334 000262B3			mov		$s2,$s1
FFFC0338 00128293			add		$s2,$s2,#1
                        	.0002:
FFFC033C 00014637			lb		$t0,INBUF[$s2]
FFFC0340 10060613
FFFC0344 00560633
FFFC0348 00060D03
FFFC034C 00014637			sb		$t0,INBUF-1[$s2]
FFFC0350 0FF60613
FFFC0354 00560633
FFFC0358 01A60023
FFFC035C 00128293			add		$s2,$s2,#1
FFFC0360 00014637			add		$t0,$s2,#INBUF
FFFC0364 10060613
FFFC0368 00560D33
FFFC036C 00014637			slt		$t0,$t0,#INBUF+$7F
FFFC0370 17F60613
FFFC0374 FC0D14E3			bne		$t0,$x0,.0002
FFFC0378 00014637			sb		$x0,INBUF[$s2]
FFFC037C 10060613
FFFC0380 00560633
FFFC0384 00060023
FFFC0388 F60002E3			bra		.0001
                        	.doBackspace:
FFFC038C F60200E3			beq		$s1,$x0,.0001		; can't backspace anymore
FFFC0390 00086933			mov		$a0,$v0					; show the backspace
FFFC0394 EA1FF0EF			call	Putch
FFFC0398 FFF20213			sub		$s1,$s1,#1
FFFC039C 000262B3			mov		$s2,$s1
                        	.0003:
FFFC03A0 00014637			lb		$t0,INBUF+1[$s2]
FFFC03A4 10160613
FFFC03A8 00560633
FFFC03AC 00060D03
FFFC03B0 00014637			sb		$t0,INBUF[$s2]
FFFC03B4 10060613
FFFC03B8 00560633
FFFC03BC 01A60023
FFFC03C0 00128293			add		$s2,$s2,#1
FFFC03C4 00014637			add		$t0,$s2,#INBUF
FFFC03C8 10060613
FFFC03CC 00560D33
FFFC03D0 00014637			slt		$t0,$t0,#INBUF+$7F
FFFC03D4 17F60613
FFFC03D8 FC0D14E3			bne		$t0,$x0,.0003
FFFC03DC 00014637			sb		$x0,INBUF[$s2]
FFFC03E0 10060613
FFFC03E4 00560633
FFFC03E8 00060023
FFFC03EC F00000E3			bra		.0001
                        	.procLine:
FFFC03F0 00014637			sb		$x0,INBUF[$s1]
FFFC03F4 10060613
FFFC03F8 00460633
FFFC03FC 00060023
FFFC0400 00006213			ldi		$s1,#0
                        	.skip:
FFFC0404 00014637			lb		$t0,INBUF[$s1]
FFFC0408 10060613
FFFC040C 00460633
FFFC0410 00060D03
FFFC0414 100D0663			beq		$t0,$x0,.0005
FFFC0418 03ED4D93			xor		$t1,$t0,#'>'
FFFC041C 000D9663			bne		$t1,$x0,.0004
                        	.skip2:
FFFC0420 00120213			add		$s1,$s1,#1
FFFC0424 FE0000E3			bra		.skip
                        	.0004:
FFFC0428 020D4D93			xor		$t1,$t0,#' '
FFFC042C FE0D8AE3			beq		$t1,$x0,.skip2
FFFC0430 009D4D93			xor		$t1,$t0,#'\t'
FFFC0434 FE0D86E3			beq		$t1,$x0,.skip2
FFFC0438 04DD4D93			xor		$t1,$t0,#'M'
FFFC043C 0E0D8463			beq		$t1,$x0,doMem
FFFC0440 04206D93			ldi		$t1,#'B'
FFFC0444 05BD1463			bne		$t0,$t1,.0006
FFFC0448 00106913			ldi		$a0,#1					; Start task
FFFC044C 000089B7			ldi		$a1,#32000			; 32 kB
FFFC0450 D0098993
FFFC0454 FFFC3A37			ldi		$a2,#CSTART			; start address
FFFC0458 730A0A13
FFFC045C 00000073			ecall
FFFC0460 0008E233			mov		$s1,$v1					; save v1
FFFC0464 FFFC1937			ldi		$a0,#msgCRLF
FFFC0468 8E690913
FFFC046C 310000EF			call	PutString
FFFC0470 00026933			mov		$a0,$s1					; get back v1
FFFC0474 2A8000EF			call	PutHexByte
FFFC0478 FFFC1937			ldi		$a0,#msgTaskStart
FFFC047C 8D890913
FFFC0480 2FC000EF			call	PutString
FFFC0484 5AC020EF			call  DumpReadyList
                        			;ldi		$a0,#5					; Reschedule task
                        			;ldi		$a1,#1					; sleep(0)
                        			;ecall
FFFC0488 E39FF06F			jmp		Monitor
                        	.0006:
FFFC048C 04406D93			ldi		$t1,#'D'
FFFC0490 03BD1663			bne		$t0,$t1,.0007
FFFC0494 00014637			lb		$t0,INBUF+1[$s1]
FFFC0498 10160613
FFFC049C 00460633
FFFC04A0 00060D03
FFFC04A4 05406D93			ldi		$t1,#'T'
FFFC04A8 01BD1663			bne		$t0,$t1,.noT
FFFC04AC 674020EF			call	DumpTimeoutList
FFFC04B0 E11FF06F			jmp		Monitor
                        	.noT:
FFFC04B4 57C020EF			call 	DumpReadyList
                        			;ldi		$a0,#15
                        			;ecall
FFFC04B8 E09FF06F			jmp		Monitor
                        	.0007:
FFFC04BC 04506D93			ldi		$t1,#'E'
FFFC04C0 01BD1463			bne		$t0,$t1,.0008
FFFC04C4 0E80006F			jmp		EditMem
                        	.0008:
FFFC04C8 04606D93			ldi		$t1,#'F'
FFFC04CC 01BD1463			bne		$t0,$t1,.0009
FFFC04D0 0F40006F			jmp		FillMem
                        	.0009:
FFFC04D4 05306D93			ldi		$t1,#'S'
FFFC04D8 01BD1A63			bne		$t0,$t1,.0010
FFFC04DC 00506913			ldi		$a0,#5					; sleep(0)
FFFC04E0 00106993			ldi		$a1,#1
FFFC04E4 00000073			ecall
FFFC04E8 DD9FF06F			jmp		Monitor
                        	.0010:
FFFC04EC 04B06D93			ldi		$t1,#'K'
FFFC04F0 01BD1C63			bne		$t0,$t1,.0011
FFFC04F4 128000EF			call	GetHexNum
FFFC04F8 00306913			ldi		$a0,#3					; kill task
FFFC04FC 000869B3			mov		$a1,$v0					; a0 = pid
FFFC0500 00000073			ecall
FFFC0504 DBDFF06F			jmp		Monitor
                        	.0011:
FFFC0508 03F06D93			ldi		$t1,#'?'
FFFC050C 01BD1A63			bne		$t0,$t1,.0012
FFFC0510 FFFC1937			ldi		$a0,#msgMonHelp
FFFC0514 83990913
FFFC0518 264000EF			call	PutString
FFFC051C DA5FF06F			jmp		Monitor
                        	.0012:
                        	.0005:
FFFC0520 DA0000E3			bra		Monitor
                        	
                        	doMem:
FFFC0524 FF870713			sub		$sp,$sp,#8
FFFC0528 00120213			add		$s1,$s1,#1
FFFC052C 00473023			sto		$s1,[$sp]
FFFC0530 00D06913			ldi		$a0,#CR
FFFC0534 D01FF0EF			call	Putch
FFFC0538 00014937			ldi		$a0,INBUF
FFFC053C 10090913
FFFC0540 23C000EF			call	PutString
FFFC0544 00073203			ldo		$s1,[$sp]
FFFC0548 00870713			add		$sp,$sp,#8
FFFC054C 0D0000EF			call	GetHexNum
FFFC0550 00086333			mov		$s3,$v0
FFFC0554 00120213			add		$s1,$s1,#1
FFFC0558 0C4000EF			call	GetHexNum
FFFC055C 006803B3			add		$s4,$v0,$s3
                        	.loop2:
FFFC0560 CADFF0EF			call	Getch						; check for ctrl-c
FFFC0564 00384813			xor		$v0,$v0,#3
FFFC0568 D4080CE3			beq		$v0,$x0,Monitor
FFFC056C 00D06913			ldi		$a0,#CR
FFFC0570 CC5FF0EF			call	Putch
FFFC0574 00036933			mov		$a0,$s3
FFFC0578 164000EF			call	PutHexWord
FFFC057C 03A06913			ldi		$a0,#':'
FFFC0580 CB5FF0EF			call	Putch
FFFC0584 00706293			ldi		$s2,#7
                        	.loop:
FFFC0588 02006913			ldi		$a0,#' '
FFFC058C CA9FF0EF			call	Putch
FFFC0590 00030903			ldb		$a0,[$s3]
FFFC0594 188000EF			call	PutHexByte
FFFC0598 00130313			add		$s3,$s3,#1
FFFC059C FFF28293			sub		$s2,$s2,#1
FFFC05A0 FE02D4E3			bge		$s2,$x0,.loop
FFFC05A4 FA736EE3			bltu	$s3,$s4,.loop2
FFFC05A8 D0000CE3			bra		Monitor		
                        	
                        	EditMem:
FFFC05AC 070000EF			call	GetHexNum			; get address to edit
FFFC05B0 00086333			mov		$s3,$v0
FFFC05B4 00120213			add		$s1,$s1,#1
FFFC05B8 064000EF			call	GetHexNum			; get value to set
FFFC05BC 00680023			stb		$s3,[$v0]			; update mem
FFFC05C0 D01FF06F			jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	;	>F 1000 800 EE
                        	; Fills memory beginning at address $1000 for $800 bytes with the value $EE
                        	;------------------------------------------------------------------------------
                        	
                        	FillMem:
FFFC05C4 058000EF			call	GetHexNum			; get address
FFFC05C8 00086333			mov		$s3,$v0
FFFC05CC 00120213			add		$s1,$s1,#1
FFFC05D0 04C000EF			call	GetHexNum			; get length
FFFC05D4 000863B3			mov		$s4,$v0
FFFC05D8 00120213			add		$s1,$s1,#1
FFFC05DC 040000EF			call	GetHexNum			; get byte to use
                        	.0001:
FFFC05E0 01030023			stb		$v0,[$s3]
FFFC05E4 FFF38393			sub		$s4,$s4,#1
FFFC05E8 FE704CE3			bgt		$s4,$x0,.0001
FFFC05EC CD5FF06F			jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; Skip over spaces and tabs in the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	SkipSpaces:
                        	.skip2:
FFFC05F0 00014637			ldb		$t0,INBUF[$s1]
FFFC05F4 10060613
FFFC05F8 00460633
FFFC05FC 00060D03
FFFC0600 020D4D93			xor		$t1,$t0,#' '
FFFC0604 000D8863			beq		$t1,$x0,.skip1
FFFC0608 009D4D93			xor		$t1,$t0,#'\t'
FFFC060C 000D8463			beq		$t1,$x0,.skip1
FFFC0610 00008067			ret
                        	.skip1:
FFFC0614 00120213			add		$s1,$s1,#1
FFFC0618 FC000CE3			bra		.skip2
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a hex number from the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	GetHexNum:
FFFC061C 00006813			ldi		$v0,#0							; v0 = num
FFFC0620 FF870713			sub		$sp,$sp,#8
FFFC0624 00173023			sto		$ra,[$sp]
FFFC0628 FC9FF0EF			call	SkipSpaces
                        	.next:
FFFC062C 00014637			lb		$t0,INBUF[$s1]
FFFC0630 10060613
FFFC0634 00460633
FFFC0638 00060D03
FFFC063C 03006E13			ldi		$t2,#'0'
FFFC0640 03CD4663			blt		$t0,$t2,.0001
FFFC0644 03A06E13			ldi		$t2,#'9'+1
FFFC0648 07CD4063			blt		$t0,$t2,.isDigit
FFFC064C 04106E13			ldi		$t2,#'A'
FFFC0650 01CD4E63			blt		$t0,$t2,.0001
FFFC0654 04706E13			ldi		$t2,#'F'+1
FFFC0658 03CD4063			blt		$t0,$t2,.isHexUpper
FFFC065C 06106E13			ldi		$t2,#'a'
FFFC0660 01CD4663			blt		$t0,$t2,.0001
FFFC0664 06706E13			ldi		$t2,#'f'+1
FFFC0668 03CD4463			blt		$t0,$t2,.isHexLower
                        	.0001:
FFFC066C 00073083			ldo		$ra,[$sp]
FFFC0670 00870713			add		$sp,$sp,#8
FFFC0674 00008067			ret
                        	.isHexUpper:
FFFC0678 00481813			sll		$v0,$v0,#4
FFFC067C FBFD0D13			sub		$t0,$t0,#'A'
FFFC0680 00AD0D13			add		$t0,$t0,#10
FFFC0684 01A86833			or		$v0,$v0,$t0
FFFC0688 00120213			add		$s1,$s1,#1
FFFC068C FA0000E3			bra		.next
                        	.isHexLower:
FFFC0690 00481813			sll		$v0,$v0,#4
FFFC0694 F9FD0D13			sub		$t0,$t0,#'a'
FFFC0698 00AD0D13			add		$t0,$t0,#10
FFFC069C 01A86833			or		$v0,$v0,$t0
FFFC06A0 00120213			add		$s1,$s1,#1
FFFC06A4 F80004E3			bra		.next
                        	.isDigit:
FFFC06A8 00481813			sll		$v0,$v0,#4
FFFC06AC FD0D0D13			sub		$t0,$t0,#'0'
FFFC06B0 01A86833			or		$v0,$v0,$t0
FFFC06B4 00120213			add		$s1,$s1,#1
FFFC06B8 F6000AE3			bra		.next
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a word as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexDword:
FFFC06BC FF070713			sub		$sp,$sp,#16
FFFC06C0 00173023			sto		$ra,[$sp]
FFFC06C4 01273423			sto		$a0,8[$sp]
FFFC06C8 00095913			srl		$a0,$a0,#32
FFFC06CC 010000EF			call	PutHexWord
FFFC06D0 00073083			ldo		$ra,[$sp]
FFFC06D4 00873903			ldo		$a0,8[$sp]
FFFC06D8 01070713			add		$sp,$sp,#16	; fall through to PutHexWord
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a word as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexWord:
FFFC06DC FF070713			sub		$sp,$sp,#16
FFFC06E0 00173023			sto		$ra,[$sp]
FFFC06E4 01273423			sto		$a0,8[$sp]
FFFC06E8 01095913			srl		$a0,$a0,#16
FFFC06EC 010000EF			call	PutHexHalf
FFFC06F0 00073083			ldo		$ra,[$sp]
FFFC06F4 00873903			ldo		$a0,8[$sp]
FFFC06F8 01070713			add		$sp,$sp,#16	; fall through to PutHexHalf
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a half-word (16 bits) as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexHalf:
FFFC06FC FF070713			sub		$sp,$sp,#16
FFFC0700 00173023			sto		$ra,[$sp]
FFFC0704 01273423			sto		$a0,8[$sp]
FFFC0708 00895913			srl		$a0,$a0,#8
FFFC070C 010000EF			call	PutHexByte
FFFC0710 00073083			ldo		$ra,[$sp]
FFFC0714 00873903			ldo		$a0,8[$sp]		
FFFC0718 01070713			add		$sp,$sp,#16	; fall through to PutHexByte
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a byte as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexByte:
FFFC071C FF070713			sub		$sp,$sp,#16
FFFC0720 00173023			sto		$ra,[$sp]
FFFC0724 01273423			sto		$a0,8[$sp]
FFFC0728 00495913			srl		$a0,$a0,#4		; put the high order nybble first
FFFC072C 010000EF			call	PutHexNybble
FFFC0730 00073083			ldo		$ra,[$sp]
FFFC0734 00873903			ldo		$a0,8[$sp]
FFFC0738 01070713			add		$sp,$sp,#16		; fall through to PutHexNybble
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a nybble as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexNybble:
FFFC073C FF070713			sub		$sp,$sp,#16
FFFC0740 00173023			sto		$ra,[$sp]
FFFC0744 01273423			sto		$a0,8[$sp]
FFFC0748 00F97913			and		$a0,$a0,#15		; strip off high order bits
FFFC074C 00A06D13			ldi		$t0,#10
FFFC0750 01A94A63			blt		$a0,$t0,.lt10
FFFC0754 FF690913			sub		$a0,$a0,#10
FFFC0758 04190913			add		$a0,$a0,#'A'
FFFC075C AD9FF0EF			call	Putch
FFFC0760 00000663			bra		.0001
                        	.lt10:
FFFC0764 03090913			add		$a0,$a0,#'0'
FFFC0768 ACDFF0EF			call	Putch
                        	.0001:
FFFC076C 00073083			ldo		$ra,[$sp]
FFFC0770 00873903			ldo		$a0,8[$sp]
FFFC0774 01070713			add		$sp,$sp,#16
FFFC0778 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; PutString
                        	;    Put a string of characters to output device. Calls the 
                        	; Putch routine, so this routine also blocks if the transmitter is not
                        	; empty.
                        	;
                        	; Parameters:
                        	;		$a0 = pointer to null terminated string to put
                        	; Modifies:
                        	;		$t0 and $t1
                        	; Stack Space:
                        	;		2 words
                        	;------------------------------------------------------------------------------
                        	
                        	PutString:
FFFC077C FF070713		sub		$sp,$sp,#16				; save link register
FFFC0780 00173023		sto		$ra,[$sp]
FFFC0784 01273423		sto		$a0,8[$sp]				; and argument
FFFC0788 00096DB3		mov		$t1,$a0						; t1 = pointer to string
                        	.0001:
FFFC078C 000D8903		lb		$a0,[$t1]
FFFC0790 001D8D93		add		$t1,$t1,#1				; advance pointer to next byte
FFFC0794 00090663		beqz	$a0,.done			; branch if done
FFFC0798 A9DFF0EF		call	Putch							; output character
FFFC079C FE0008E3		bra		.0001
                        	.done:
FFFC07A0 00073083		ldo		$ra,[$sp]					; restore return address
FFFC07A4 00873903		ldo		$a0,8[$sp]				; and argument
FFFC07A8 01070713		add		$sp,$sp,#16
FFFC07AC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; MicroDelay - delay for a few clock ticks
                        	;
                        	; Parameters:
                        	;		a0 = wait in ticks (50 ns intervals)
                        	;------------------------------------------------------------------------------
                        	
                        	_MicroDelay:
FFFC07B0 C0001EF3		csrrw	$t3,#$C00,$x0
                        	.0001:
FFFC07B4 C0001F73		csrrw	$t4,#$C00,$x0
FFFC07B8 41DF0F33		sub		$t4,$t4,$t3
FFFC07BC 011F5F93		srl		$t5,$t4,#17
FFFC07C0 FFDC0637		stt		$t5,VIA+VIA_PARAW
FFFC07C4 63C60613
FFFC07C8 00060633
FFFC07CC 01F62023
FFFC07D0 012F2F33		slt		$t4,$t4,$a0
FFFC07D4 FE0F10E3		bnez	$t4,.0001
FFFC07D8 00008067		ret
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	; Exception processing code starts here.
                        	; As per the RISCV privilege spec, the MSB indicates an external interrupt.
                        	; The system uses cause codes 32 to 63 for external devices. This cause code
                        	; range is reserved in the RISCV spec.
                        	;------------------------------------------------------------------------------
                        	.file "boot.r5a",633
                        		code
                        		align	4                        	
                        	IRQRout:
FFFC07DC 78001D73		csrrw	$t0,#$780,$x0			; get register set
FFFC07E0 00AD1D13		sll		$t0,$t0,#10				; 1k stack area
FFFC07E4 20000737		ldi		$sp,#$20000000-8	; setup machine mode stack pointer (top of ram)
FFFC07E8 FF870713
FFFC07EC 41A70733		sub		$sp,$sp,$t0				; set stack pointer for register set
FFFC07F0 34201D73		csrrw	$t0,#$342,$x0			; get cause code
FFFC07F4 000D4463		blt		$t0,$x0,.isIRQ		; irq or ecall?
FFFC07F8 6D80106F		jmp		OSCALL						; goto operating system call dispatcher
                        	.isIRQ:
FFFC07FC 01FD7D13		and		$t0,$t0,#31				; interrupting device # is low order 5 bits of cause code
FFFC0800 008D1D13		sll		$t0,$t0,#8				; 256 bytes per device func table
FFFC0804 00022637		add		$t0,$t0,#DVF_Base+22*8	; load IRQ routine vector from device func table
FFFC0808 0B060613
FFFC080C 01A60D33
FFFC0810 000D3D03		ldo		$t0,[$t0]
FFFC0814 000D0463		beq		$t0,$x0,.noIRQ		; make sure there's an address to go to
FFFC0818 000D0067		jmp		[$t0]							; jump to the IRQ routine
                        	.noIRQ:
FFFC081C 10000073		eret
                        	
                        	;------------------------------------------------------------------------------
                        	; Message strings
                        	;------------------------------------------------------------------------------
                        	
                        	msgStart:
FFFC0820 61746550			db		"Petajon System Starting.",13
FFFC0824 206E6F6A
FFFC0828 74737953
FFFC082C 53206D65
FFFC0830 74726174
FFFC0834 2E676E69
FFFC0838 6E6F4D0D
                        	msgMonHelp:
FFFC0839 696E6F4D			db		"Monitor Commands",13
FFFC083D 20726F74
FFFC0841 6D6D6F43
FFFC0845 73646E61
FFFC0849 2D20420D
FFFC084A 202D2042			db		"B - start tiny basic",13
FFFC084E 72617473
FFFC0852 69742074
FFFC0856 6220796E
FFFC085A 63697361
FFFC085E 2D20440D
FFFC085F 202D2044			db		"D - dump ready que",13
FFFC0863 706D7564
FFFC0867 61657220
FFFC086B 71207964
FFFC086F 450D6575
FFFC0872 202D2045			db		"E - edit memory",13
FFFC0876 74696465
FFFC087A 6D656D20
FFFC087E 0D79726F
FFFC0882 202D2046			db		"F - fill memory",13
FFFC0886 6C6C6966
FFFC088A 6D656D20
FFFC088E 0D79726F
FFFC0892 743C204B			db		"K <tid> - kill task", 13
FFFC0896 203E6469
FFFC089A 696B202D
FFFC089E 74206C6C
FFFC08A2 0D6B7361
FFFC08A6 733C204D			db		"M <start> <length>	- dump memory",13
FFFC08AA 74726174
FFFC08AE 6C3C203E
FFFC08B2 74676E65
FFFC08B6 2D093E68
FFFC08BA 6D756420
FFFC08BE 656D2070
FFFC08C2 79726F6D
FFFC08C6 2D20530D
FFFC08C7 202D2053			db		"S - switch task",13
FFFC08CB 74697773
FFFC08CF 74206863
FFFC08D3 0D6B7361
FFFC08D7 61742000			db		0
                        			align 4                        	
                        	msgTaskStart:
FFFC08D8 73617420			db		" task started."
FFFC08DC 7473206B
FFFC08E0 65747261
FFFC08E4 0A0D2E64
                        	msgCRLF:
FFFC08E6 00000A0D			db		13,10,0
                        	flt50:
FFFC08E9 00000000		dw	0x00000000,0x00000000,0x00000000,0x40049000
FFFC08ED 00000000
FFFC08F1 00000000
FFFC08F5 40049000
                        	flt20:
FFFC08F9 00000000		dw	0x00000000,0x00000000,0x00000000,0x40034000
FFFC08FD 00000000
FFFC0901 00000000
FFFC0905 40034000
                        	flt10:
FFFC0909 00000000		dw	0x00000000,0x00000000,0x00000000,0x40024000
FFFC090D 00000000
FFFC0911 00000000
FFFC0915 40024000
                        	
                        	.file "fltToString.r5a",1
                        	.file "fltToString.r5a",1
                        	STRTMP		equ		$0200
                        	
                        	; -----------------------------------------------------------------------------
                        	;		$fa0 = number to convert (f18)
                        	;		$a1	= width
                        	;		$a2 = precision
                        	;		$a3 = E
                        	;		$t2 = ndx
                        	;		$s9 = exp
                        	; -----------------------------------------------------------------------------
                        	
                        	fltToString:
FFFC0919 006E1300			ldi		$t2,#0				; $t2 = 0
FFFC091D 09095300
FFFC091E E0090953			fmv		$a0,$f18
FFFC0922 7F800637			and		$t0,$a0,#$7F800000
FFFC0926 00060613
FFFC092A 01267D33
FFFC092E 7F800DB7			ldi		$t1,#$7F800000
FFFC0932 000D8D93
FFFC0936 05BD1263			bne		$t0,$t1,.0001
FFFC093A 00800637			and		$t0,$a0,#$007FFFFF
FFFC093E FFF60613
FFFC0942 01267D33
FFFC0946 000D0E63			beq		$t0,$x0,.inf
FFFC094A FFFC1637			ldt		$t0,msgNan
FFFC094E CD460613
FFFC0952 00060633
FFFC0956 00062D03
FFFC095A 21A02023			stt		$t0,STRTMP
FFFC095E 2E000E63			bra		.prt
                        	.inf:
FFFC0962 FFFC1637			ldt		$t0,msgInf
FFFC0966 CD060613
FFFC096A 00060633
FFFC096E 00062D03
FFFC0972 21A02023			stt		$t0,STRTMP
FFFC0976 2E000263			bra		.prt
                        	.0001:
FFFC097A 80000637			and		$t0,$a0,#$80000000
FFFC097E 00060613
FFFC0982 01267D33
FFFC0986 000D0E63			beq		$t0,$x0,.pos
FFFC098A 02D06D13			ldi		$t0,#'-'
FFFC098E 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0992 001E0E13			add		$t2,$t2,#1
FFFC0996 80000637			and		$a0,$a0,#$7FFFFFFF
FFFC099A FFF60613
FFFC099E 01267933
                        	.pos:
FFFC09A2 00091A63			bne		$a0,$x0,.notZero
FFFC09A6 03006D13			ldi		$t0,#'0'
FFFC09AA 21AE0023			stb		$t0,STRTMP[$t2]
FFFC09AE 200E00A3			stb		$x0,STRTMP+1[$t2]
FFFC09B2 2A000463			bra		.prt		
                        	.notZero:
FFFC09B6 00006633			mov		$s9,$x0			; exp = 0.0
                        	;	// Make a small number > 0 so we can get at the digits.
                        	;	if (dbl < 1.0) {
                        	;		while (dbl < 1.0) {
                        	;			dbl *= 1000000.0;
                        	;			exp -= 6;  
                        	;		}
                        	;	}
FFFC09BA FFFC1637			flw		$f3,fltOne
FFFC09BE CD860613
FFFC09C2 00060633
FFFC09C6 00062187
FFFC09CA F0090053			fmv		$f0,$a0
FFFC09CE A0391D53			flt		$t0,$f18,$f3
FFFC09D2 020D0463			beq		$t0,$x0,.0002
FFFC09D6 FFFC1637			flw		$f4,fltMillion
FFFC09DA CE060613
FFFC09DE 00060633
FFFC09E2 00062207
                        	.0003:
FFFC09E6 A0391D53			flt		$t0,$f18,$f3
FFFC09EA 000D0863			beq		$t0,$x0,.0002
FFFC09EE 10490953			fmul	$f18,$f18,$f4
FFFC09F2 FFA60613			sub		$s9,$s9,#6
FFFC09F6 FE0008E3			bra		.0003
                        	.0002:
                        	;	// The following is similar to using log10() and pow() functions.
                        	;	// Now dbl is >= 1.0
                        	;	// Create a number dbl2 on the same order of magnitude as dbl, but
                        	;	// less than dbl.
                        	;	dbl2 = 1.0;
                        	;	dbla = dbl2;
                        	;	if (dbl > dbl2) {	// dbl > 1.0 ?
                        	;		while (dbl2 <= dbl) {
                        	;			dbla = dbl2;
                        	;			dbl2 *= 10.0;	// increase power of 10
                        	;			exp++;
                        	;		}
                        	;		// The above loop goes one too far, we want the last value less
                        	;		// than dbl.
                        	;		dbl2 = dbla;
                        	;		exp--;
                        	;	}
FFFC09FA FFFC1637			flw		$f1,fltOne				; $f1 = dbl2 = 1.0
FFFC09FE CD860613
FFFC0A02 00060633
FFFC0A06 00062087
FFFC0A0A 38008153			fmov	$f2,$f1						; $f2 = dbla = dbl2
FFFC0A0E A1209D53			flt		$t0,$f1,$f18				; if (dbl2 < dbl)
FFFC0A12 020D0A63			beq		$t0,$x0,.0004
FFFC0A16 FFFC1637			flw		$f5,fltTen				; $f5 = 10.0
FFFC0A1A CDC60613
FFFC0A1E 00060633
FFFC0A22 00062287
                        	.0006:
FFFC0A26 A1208D53			fle		$t0,$f1,$f18				; while ($f1 <= $f18)
FFFC0A2A 000D0A63			beq		$t0,$x0,.0005
FFFC0A2E 38008153			fmov	$f2,$f1						; dbla = dbl2
FFFC0A32 105080D3			fmul	$f1,$f1,$f5				; dbl2 *= 10.0
FFFC0A36 00160613			add		$s9,$s9,#1				; exp++;
FFFC0A3A FE0006E3			bra		.0006
                        	.0005:
FFFC0A3E 380100D3			fmov	$f1,$f2						; dbl2 = dbla
FFFC0A42 FFF60613			sub		$s9,$s9,#1				; exp--;
                        	.0004:
                        	;	// For small constants < 1000000 try and spit out a whole number
                        	;    if (exp >= 0 && exp < 6) {
                        	;        digits_before_decpt = exp+1;
                        	;		exp = 0;
                        	;	}
                        	;	else if (exp >= -6)
                        	;		digits_before_decpt = 1;
                        	;	else
                        	;		digits_before_decpt = -1;
FFFC0A46 00064E63			blt		$s9,$x0,.0007
FFFC0A4A 00606413			ldi		$s5,#6
FFFC0A4E 00865A63			bge		$s9,$s5,.0007
FFFC0A52 FFFFE233			mov		$s1,#s0						; s1 = digits before decpt
FFFC0A56 00120213			add		$s1,$s1,#1
FFFC0A5A 00006613			ldi		$s9,#0						; exp = 0
FFFC0A5E 00000C63			bra		.0008
                        	.0007:
FFFC0A62 FF906413			ldi		$s5,#-7
FFFC0A66 00864663			blt		$s9,$s5,.0009
FFFC0A6A 00106213			ldi		$s1,#1
FFFC0A6E 00000463			bra		.0008
                        	.0009:
FFFC0A72 FFF06213			ldi		$s1,#-1
                        	.0008:
                        	;	// Spit out a leading zero before the decimal point for a small number.
                        	;    if (exp < -6) {
                        	;		buf[ndx] = '0';
                        	;		ndx++;
                        	;        buf[ndx] = '.';
                        	;        ndx++;
                        	;    }
FFFC0A76 FFA06413			ldi		$s5,#-6
FFFC0A7A 00865E63			bge		$s9,$s5,.0010
FFFC0A7E 03006D13			ldi		$t0,#'0'
FFFC0A82 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0A86 001E0E13			add		$t2,$t2,#1
FFFC0A8A 02E06D13			ldi		$t0,#'.'
FFFC0A8E 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0A92 001E0E13			add		$t2,$t2,#1
                        	.0010:
                        	;	// Now loop processing one digit at a time.
                        	;    for (nn = 0; nn < 30 && precision > 0; nn++) {
                        	;        digit = 0;
                        	;		dbla = dbl;
                        	;		// dbl is on the same order of magnitude as dbl2 so
                        	;		// a repeated subtract can be used to find the digit.
                        	;        while (dbl >= dbl2) {
                        	;            dbl -= dbl2;
                        	;            digit++;
                        	;        }
                        	;        buf[ndx] = digit + '0';
                        	;		// Now go back and perform just a single subtract and
                        	;		// a multiply to find out how much to reduce dbl by.
                        	;		// This should improve the accuracy
                        	;		if (digit > 2)
                        	;			dbl = dbla - dbl2 * digit;
                        	;        ndx++;
                        	;        digits_before_decpt--;
                        	;        if (digits_before_decpt==0) {
                        	;           buf[ndx] = '.';
                        	;           ndx++;
                        	;        }
                        	;        else if (digits_before_decpt < 0)
                        	;            precision--;
                        	;		// Shift the next digit to be tested into position.
                        	;        dbl *= 10.0;
                        	;    }
FFFC0A96 00006313			ldi		$s3,#0						; s3 = nn = 0
FFFC0A9A 01E06413			ldi		$s5,#30
FFFC0A9E FFFC1637			flw		$f7,fltTen				; f7 = 10.0
FFFC0AA2 CDC60613
FFFC0AA6 00060633
FFFC0AAA 00062387
                        	.0016:
FFFC0AAE 00832D33			slt		$t0,$s3,$s5
FFFC0AB2 060D0863			beq		$t0,$x0,.0011
FFFC0AB6 00006413			ldi		$s5,#0
FFFC0ABA 07445463			bge		$s5,$a2,.0011			; (0 < precision)
FFFC0ABE 00006393			ldi		$s4,#0						; s4 = digit = 0
FFFC0AC2 38090153			fmov	$f2,$f18						; dbla = dbl
                        	.0013:
FFFC0AC6 A1208D53			fle		$t0,$f1,$f18						; while (dbl2 <= dbl)
FFFC0ACA 000D0863			beq		$t0,$x0,.0012
FFFC0ACE 08190953			fsub	$f18,$f18,$f1						; dbl -= dbl2
FFFC0AD2 00138393			add		$s4,$s4,#1						; digit++
FFFC0AD6 FE0008E3			bra		.0013
                        	.0012:
FFFC0ADA 03038413			add		$s5,$s4,#'0'			; buf[ndx] = digit + '0'
FFFC0ADE 208E0023			stb		$s5,STRTMP[$t2]
FFFC0AE2 00206413			ldi		$s5,#2						; if (2 < digit)
FFFC0AE6 00745863			bge		$s5,$s4,.0014
FFFC0AEA D00382D3			fcvt.s.w	$f5,$s4				; f5 = digit as float
FFFC0AEE 10508353			fmul	$f6,$f1,$f5				; f6 = dbl2 * digit
FFFC0AF2 08610953			fsub	$f18,$f2,$f6				; dbl = dbla - dbl2 * digit
                        	.0014:
FFFC0AF6 001E0E13			add		$t2,$t2,#1				; ndx++
FFFC0AFA FFF20213			sub		$s1,$s1,#1				; digits_before_decpt--;
FFFC0AFE 00021A63			bne		$s1,$x0,.0015			; if (digits_before_decpt==0)
FFFC0B02 02E06D13			ldi		$t0,#'.'
FFFC0B06 21AE0023			stb		$t0,STRTMP[$t2]		; buf[ndx] = '.'
FFFC0B0A 001E0E13			add		$t2,$t2,#1				; ndx++
FFFC0B0E 00000663			bra		.0017
                        	.0015:
FFFC0B12 00025463			bge		$s1,$x0,.0017			; else if (digits_before_decpt < 0)
FFFC0B16 FFFA0A13			sub		$a2,$a2,#1				; 	precision--
                        	.0017:
FFFC0B1A 10790953			fmul	$f18,$f18,$f7				; dbl *= 10.0
FFFC0B1E F80008E3			bra		.0016
                        	.0011:
                        	;	// Trim trailing zeros from the number
                        	;    do {
                        	;        ndx--;
                        	;    } while(buf[ndx]=='0');
                        	;    ndx++;
                        	.0018:
FFFC0B22 FFFE0E13			sub		$t2,$t2,#1				; ndx--
FFFC0B26 200E0D03			ldb		$t0,STRTMP[$t2]
FFFC0B2A 030D4D13			xor		$t0,$t0,#'0'
FFFC0B2E FE0D0AE3			beq		$t0,$x0,.0018
FFFC0B32 001E0E13			add		$t2,$t2,#1				; ndx++
                        	;	// Make sure we have at least one digit after the decimal point.
                        	;	if (buf[ndx]=='.') {
                        	;		ndx++;
                        	;		buf[ndx]='0';
                        	;		ndx++;
                        	;        buf[ndx]='\0';
                        	;	}
FFFC0B36 200E0D03			ldb		$t0,STRTMP[$t2]
FFFC0B3A 02ED4D13			xor		$t0,$t0,#'.'
FFFC0B3E 000D1C63			bne		$t0,$x0,.0019
FFFC0B42 001E0E13			add		$t2,$t2,#1
FFFC0B46 03006D13			ldi		$t0,#'0'
FFFC0B4A 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0B4E 001E0E13			add		$t2,$t2,#1
FFFC0B52 200E0023			stb		$x0,STRTMP[$t2]
                        	.0019:
                        	;	// If the number is times 10^0 don't output the exponent
                        	;   if (exp==0) {
                        	;        buf[ndx]='\0';
                        	;        goto prt;
                        	;    }
FFFC0B56 00061663			bne		$s9,$x0,.0020
FFFC0B5A 200E0023			stb		$x0,STRTMP[$t2]
FFFC0B5E 0E000E63			bra		.prt
                        	.0020:
                        	;	// Spit out +/-E
                        	;    buf[ndx] = E;
                        	;    ndx++;
                        	;    if (exp < 0) {
                        	;        buf[ndx]='-';
                        	;        ndx++;
                        	;        exp = -exp;
                        	;    }
                        	;    else {
                        	;         buf[ndx]='+';
                        	;         ndx++;
                        	;    }
FFFC0B62 04506D13			ldi		$t0,#'E'
FFFC0B66 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0B6A 001E0E13			add		$t2,$t2,#1
FFFC0B6E 00065C63			bge		$s9,$x0,.0021
FFFC0B72 02D06D13			ldi		$t0,#'-'
FFFC0B76 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0B7A 001E0E13			add		$t2,$t2,#1
FFFC0B7E 40C00633			sub		$s9,$x0,$s9			; exp = -exp
FFFC0B82 00000863			bra		.0022
                        	.0021:
FFFC0B86 02B06D13			ldi		$t0,#'+'
FFFC0B8A 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0B8E 001E0E13			add		$t2,$t2,#1
                        	.0022:
                        	;	// now process the exponent
                        	;    digit = 0;
                        	;    while (exp >= 1000) {
                        	;        exp -= 1000;
                        	;        digit++;
                        	;    }
FFFC0B92 00006393			ldi		$s4,#0
FFFC0B96 3E806D13			ldi		$t0,#1000
                        	.0025:
FFFC0B9A 01A65463			bge		$s9,$t0,.0023
FFFC0B9E 00000863			bra		.0024
                        	.0023:
FFFC0BA2 41A60633			sub		$s9,$s9,$t0
FFFC0BA6 00138393			add		$s4,$s4,#1
FFFC0BAA FE0008E3			bra		.0025
                        	.0024:
                        	;	d1 = digit;
                        	;	if (digit) {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0BAE 0003E4B3			mov		$s6,$s4					; s6 = d1 = s4 = digit
FFFC0BB2 00039863			bne		$s4,$x0,.0026
FFFC0BB6 03038D13			add		$t0,$s4,#'0'
FFFC0BBA 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0BBE 001E0E13			add		$t2,$t2,#1
                        	.0026:
                        	;	digit = 0;
                        	;    while (exp >= 100) {
                        	;        exp -= 100;
                        	;        digit++;
                        	;    }
FFFC0BC2 00006393			ldi		$s4,#0
FFFC0BC6 06406D13			ldi		$t0,#100
                        	.0027:
FFFC0BCA 01A65463			bge		$s9,$t0,.0028
FFFC0BCE 00000863			bra		.0029
                        	.0028:
FFFC0BD2 41A60633			sub		$s9,$s9,$t0
FFFC0BD6 00138393			add		$s4,$s4,#1
FFFC0BDA FE0008E3			bra		.0027
                        	.0029:	
                        	;	d2 = digit;
                        	;	if (digit==0 && d1==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0BDE 0003E533			mov		$s7,$s4				; $s7 = d2
FFFC0BE2 00049463			bne		$s6,$x0,.0030
FFFC0BE6 00038863			beq		$s4,$x0,.0031
                        	.0030:
FFFC0BEA 03038D13			add		$t0,$s4,#'0'
FFFC0BEE 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0BF2 001E0E13			add		$t2,$t2,#1
                        	.0031:
                        	;	digit = 0;
                        	;    while (exp >= 10) {
                        	;        exp -= 10;
                        	;        digit++;
                        	;    }
FFFC0BF6 00006393			ldi		$s4,#0
FFFC0BFA 00A06D13			ldi		$t0,#10
                        	.0032:
FFFC0BFE 01A65463			bge		$s9,$t0,.0034
FFFC0C02 00000863			bra		.0035
                        	.0034:
FFFC0C06 41A60633			sub		$s9,$s9,$t0
FFFC0C0A 00138393			add		$s4,$s4,#1
FFFC0C0E FE0008E3			bra		.0032
                        	.0035:	
                        	;	d3 = digit;
                        	;	if (digit==0 && d1==0 && d2==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0C12 0003E5B3			mov		$s8,$s4
FFFC0C16 00039663			bne		$s4,$x0,.0036
FFFC0C1A 00049463			bne		$s6,$x0,.0036
FFFC0C1E 00050863			beq		$s7,$x0,.0037
                        	.0036:
FFFC0C22 03038D13			add		$t0,$s4,#'0'
FFFC0C26 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0C2A 001E0E13			add		$t2,$t2,#1
                        	.0037:
                        	;	digit = 0;
                        	;    while (exp >= 1) {
                        	;        exp -= 1;
                        	;        digit++;
                        	;    }
FFFC0C2E 00006393			ldi		$s4,#0
FFFC0C32 00106D13			ldi		$t0,#1
                        	.0038:
FFFC0C36 01A65463			bge		$s9,$t0,.0040
FFFC0C3A 00000863			bra		.0039
                        	.0040:
FFFC0C3E 41A60633			sub		$s9,$s9,$t0
FFFC0C42 00138393			add		$s4,$s4,#1
FFFC0C46 FE0008E3			bra		.0038
                        	.0039:	
                        	;    buf[ndx] = digit + '0';
                        	;    ndx++;
                        	;    buf[ndx] = '\0';
FFFC0C4A 03038D13			add		$t0,$s4,#'0'
FFFC0C4E 21AE0023			sb		$t0,STRTMP[$t2]
FFFC0C52 001E0E13			add		$t2,$t2,#1
FFFC0C56 200E0023			sb		$x0,STRTMP[$t2]
                        	;	// Now pad the number on the left or right as requested.
                        	.prt:
                        	;    // pad left
                        	;    if (width > 0) {
                        	;        if (ndx < width) {
                        	;            for (nn = 39; nn >= width-ndx; nn--)
                        	;                buf[nn] = buf[nn-(width-ndx)];
                        	;            for (; nn >= 0; nn--)
                        	;                buf[nn] = ' ';
                        	;        }
                        	;    }
FFFC0C5A 0409C663			blt		$a1,$x0,.0041
FFFC0C5E 04098463			beq		$a1,$x0,.0041
FFFC0C62 013E4463			blt		$t2,$a1,.0042
FFFC0C66 04000063			bra		.0041
                        	.0042:
FFFC0C6A 02706313			ldi		$s3,#39					; s3 = nn
FFFC0C6E 41C98D33			sub		$t0,$a1,$t2			; width-ndx
                        	.0045:
FFFC0C72 01A35463			bge		$s3,$t0,.0043
FFFC0C76 00000C63			bra		.0044
                        	.0043:
FFFC0C7A 41A304B3			sub		$s6,$s3,$t0			; nn-(width-ndx)
FFFC0C7E 20030D83			ldb		$t1,STRTMP[$s3]
FFFC0C82 21B48023			stb		$t1,STRTMP[$s6]
FFFC0C86 FFF30313			sub		$s3,$s3,#1
FFFC0C8A FE0004E3			bra		.0045
                        	.0044:
FFFC0C8E 02006D13			ldi		$t0,#' '
                        	.0048:
FFFC0C92 00035463			bge		$s3,$x0,.0046
FFFC0C96 00000863			bra		.0047
                        	.0046:
FFFC0C9A 21A30023			stb		$t0,STRTMP[$s3]
FFFC0C9E FFF30313			sub		$s3,$s3,#1
FFFC0CA2 FE0008E3			bra		.0048
                        	.0047:
                        	.0041:
                        	;    // pad right
                        	;    if (width < 0) {
                        	;        width = -width;
                        	;        while (ndx < width) {
                        	;            buf[ndx]=' ';
                        	;            ndx++;
                        	;        }
                        	;        buf[ndx]='\0';
                        	;    }
                        	;    return (ndx);
FFFC0CA6 0209D063			bge		$a1,$x0,.0050
FFFC0CAA 413009B3			sub		$a1,$x0,$a1
FFFC0CAE 02006D13			ldi		$t0,#' '
                        	.0052:
FFFC0CB2 013E5863			bge		$t2,$a1,.0051
FFFC0CB6 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0CBA 001E0E13			add		$t2,$t2,#1
FFFC0CBE FE000AE3			bra		.0052
                        	.0051:
FFFC0CC2 200E0023			stb		$x0,STRTMP[$t2]
                        	.0050:
FFFC0CC6 000E6833			mov		$v0,$t2
FFFC0CCA 00008067			ret
                        	
FFFC0CCE 6E490000			align	
                        	
                        	msgInf:
FFFC0CD0 00666E49			db	"Inf",0
                        	msgNan:
FFFC0CD4 006E614E			db	"Nan",0
                        	fltOne:
FFFC0CD8 3F800000			dw		$3F800000					; 1.0
                        	fltTen:
FFFC0CDC 41200000			dw		$41200000					; 10.0
                        	fltMillion:
FFFC0CE0 49742400			dw		$49742400					; 1,000,000
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "cs01Mem.r5a",1
                        	.file "cs01Mem.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "cs01Mem.r5a",25
                        			code	18 bits
                        			align	4                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	MMUInit:
FFFC0CE4 FF870713			sub		$sp,$sp,#8
FFFC0CE8 00173023			sto		$ra,[$sp]
FFFC0CEC 00002D37			ldi		$t0,#8189				; set number of available pages (3 pages already allocated)
FFFC0CF0 FFDD0D13
FFFC0CF4 00025637			stt		$t0,NPAGES
FFFC0CF8 82860613
FFFC0CFC 00060633
FFFC0D00 01A62023
                        			; Free all memory for all tasks			
FFFC0D04 00006D13			ldi		$t0,#$00
FFFC0D08 03F06F13			ldi		$t4,#MAX_TID		; task id
                        	.0004:
FFFC0D0C 00006D93			ldi		$t1,#$000				; regno
FFFC0D10 00001E37			ldi		$t2,#PAGES_PER_TASK	; number of registers to update
FFFC0D14 000E0E13
FFFC0D18 00206E93			ldi		$t3,#2					; number of pages pre-allocated
                        	.0001:
FFFC0D1C 010F1213			sll		$s1,$t4,#16			; put tid in place
FFFC0D20 01B26233			or		$s1,$s1,$t1			; or in page number
FFFC0D24 024D000D			mvmap	$x0,$t0,$s1
FFFC0D28 001D0D13			add		$t0,$t0,#$01
FFFC0D2C 001D8D93			add		$t1,$t1,#$01		; increment page number
FFFC0D30 01DDE463			bltu	$t1,$t3,.0003
FFFC0D34 00006D33			mov		$t0,$x0					; mark pages unallocated
                        	.0003:
FFFC0D38 FFFE0E13			sub		$t2,$t2,#1
FFFC0D3C FE0E10E3			bne		$t2,$x0,.0001
FFFC0D40 FFFF0F13			sub		$t4,$t4,#1
FFFC0D44 FC0F54E3			bge		$t4,$x0,.0004
                        			; Now ensure all pages in PAM are marked free
FFFC0D48 00002D37			ldi		$t0,#8191
FFFC0D4C FFFD0D13
                        	.0006:
FFFC0D50 0A0D000D			pfree	$t0
FFFC0D54 FFFD0D13			sub		$t0,$t0,#1
FFFC0D58 FE0D5CE3			bge		$t0,$x0,.0006
                        			; allocate last page for system stack
FFFC0D5C 00002DB7			ldi		$t1,#$1FFF				
FFFC0D60 FFFD8D93
FFFC0D64 00002D37			ldi		$t0,#$1FFF
FFFC0D68 FFFD0D13
FFFC0D6C 03BD000D			mvmap	$x0,$t0,$t1
                        	
                        			; Now setup segment registers
FFFC0D70 00006D13			ldi		$t0,#$0
FFFC0D74 00706D93			ldi		$t1,#$07				; t1 = value to load RWX=111, base = 0
                        	.0002:
FFFC0D78 01AD800D			mvseg	$x0,$t1,$t0			; move to the segment register identifed by t0
FFFC0D7C 001D0D13			add		$t0,$t0,#1			; pick next segment register
FFFC0D80 010D2E13			slt		$t2,$t0,#16			; 16 segment regs
FFFC0D84 FE0E1AE3			bne		$t2,$x0,.0002
FFFC0D88 00073083			ldo		$ra,[$sp]
FFFC0D8C 00870713			add		$sp,$sp,#8
FFFC0D90 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Find a run of buckets available for mapping virtual to physical addresses.
                        	;
                        	; Parameters:
                        	;		a0 = tid
                        	;		a1 = number of pages required.
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		v0 = starting bucket number (includes ASID), -1 if no run found
                        	;------------------------------------------------------------------------------
                        	
                        	FindRun:
FFFC0D94 03F97E93		and			$t3,$a0,#$3F			; t3 = tid
FFFC0D98 010E9E93		sll			$t3,$t3,#16				; shift into usable position
FFFC0D9C 00006D93		ldi			$t1,#0						; t1 = count of consecutive empty buckets
FFFC0DA0 000EEE33		mov			$t2,$t3						; t2 = map entry number
FFFC0DA4 003E6E13		or			$t2,$t2,#OSPAGES	; start looking at page 32 (others are for OS)
FFFC0DA8 00002FB7		ldi			$t5,#8191					; max number of pages - 1
FFFC0DAC FFFF8F93
FFFC0DB0 01DFEFB3		or			$t5,$t5,$t3				; t5 = max in ASID
                        	.0001:
FFFC0DB4 03C0080D		mvmap		$v0,$x0,$t2				; get map entry into v0
FFFC0DB8 00080A63		beq			$v0,$x0,.empty0		; is it empty?
FFFC0DBC 001E0E13		add			$t2,$t2,#1
FFFC0DC0 FFFE6AE3		bltu		$t2,$t5,.0001
                        	.0002:
FFFC0DC4 FFF06813		ldi			$v0,#-1						; got here so no run was found
FFFC0DC8 00008067		ret
                        	.empty0:
FFFC0DCC 000E6EB3		mov			$t3,$t2						; save first empty bucket
                        	.empty1:
FFFC0DD0 FFFE7AE3		bgeu		$t2,$t5,.0002
FFFC0DD4 001D8D93		add			$t1,$t1,#1
FFFC0DD8 013DFC63		bgeu		$t1,$a1,.foundEnough
FFFC0DDC 001E0E13		add			$t2,$t2,#1				; next bucket
FFFC0DE0 03C0080D		mvmap		$v0,$x0,$t2				; get map entry
FFFC0DE4 FE0806E3		beq			$v0,$x0,.empty1
FFFC0DE8 00006DB3		mov			$t1,$x0						; reset counter
FFFC0DEC FC0004E3		bra			.0001							; go back and find another run
                        	.foundEnough:
FFFC0DF0 000EE833		mov			$v0,$t3						; v0 = start of run
FFFC0DF4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = pid
                        	;		a1 = amount of memory to allocate
                        	; Modifies:
                        	;		a1,t0
                        	; Returns:
                        	;		v1 = pointer to allocated memory in virtual address space.
                        	;		v0 = E_Ok for success, E_NotAlloc otherwise
                        	;------------------------------------------------------------------------------
                        	;
                        	Alloc:
FFFC0DF8 FE070713		sub			$sp,$sp,#32
FFFC0DFC 00173023		sto			$ra,[$sp]
FFFC0E00 00473423		sto			$s1,8[$sp]				; these regs must be saved
FFFC0E04 00573823		sto			$s2,16[$sp]
FFFC0E08 00673C23		sto			$s3,24[$sp]
                        		; First check if there are enough pages available in the system.
FFFC0E0C 00010637		add			$v0,$a1,#PAGESZ-1	; v0 = round memory request
FFFC0E10 FFF60613
FFFC0E14 01360833
FFFC0E18 01085813		srl			$v0,$v0,#LOG_PGSZ	; v0 = convert to pages required
FFFC0E1C 00025637		ldo			$t0,NPAGES				; check number of pages available
FFFC0E20 82860613
FFFC0E24 00060633
FFFC0E28 00063D03
FFFC0E2C 010D7663		bleu		$v0,$t0,.enough
                        	.noRun2:
FFFC0E30 00006893		ldi			$v1,#0						; not enough, return null
FFFC0E34 06000263		bra			.noRun
                        	.enough:
                        		; There are enough pages, but is there a run long enough in map space?
FFFC0E38 000862B3		mov			$s2,$v0						; save required # pages
FFFC0E3C 000869B3		mov			$a1,$v0
FFFC0E40 F55FF0EF		call		FindRun						; find a run of available slots
FFFC0E44 FE0846E3		blt			$v0,$x0,.noRun2
                        		; Now there are enough pages, and a run available, so allocate
FFFC0E48 00086233		mov			$s1,$v0						; s1 = start of run
FFFC0E4C 00025637		ldo			$s3,NPAGES				; decrease number of pages available in system
FFFC0E50 82860613
FFFC0E54 00060633
FFFC0E58 00063303
FFFC0E5C 40530333		sub			$s3,$s3,$s2
FFFC0E60 00025637		sto			$s3,NPAGES
FFFC0E64 82860613
FFFC0E68 00060633
FFFC0E6C 00663023
FFFC0E70 00086333		mov			$s3,$v0						; s3 = start of run
                        	.0001:
FFFC0E74 0800080D		palloc	$v0								; allocate a page (cheat and use hardware)
FFFC0E78 02080063		beqz		$v0,.noRun
FFFC0E7C 0268000D		mvmap		$x0,$v0,$s3				; map the page
FFFC0E80 00130313		add			$s3,$s3,#1				; next bucket
FFFC0E84 FFF28293		sub			$s2,$s2,#1
FFFC0E88 FE5046E3		bgt			$s2,$x0,.0001
FFFC0E8C 01021893		sll			$v1,$s1,#LOG_PGSZ	; v0 = virtual address of allocated mem.
FFFC0E90 00006813		ldi			$v0,#E_Ok
FFFC0E94 00000463		bra			.xit
                        	.noRun:
FFFC0E98 00906813		ldi			$v0,#E_NotAlloc
                        	.xit
FFFC0E9C 00073083		ldo			$ra,[$sp]					; restore saved regs
FFFC0EA0 00873203		ldo			$s1,8[$sp]
FFFC0EA4 01073283		ldo			$s2,16[$sp]
FFFC0EA8 01873303		ldo			$s3,24[$sp]
FFFC0EAC 02070713		add			$sp,$sp,#32
FFFC0EB0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Allocate the stack page for a task. The stack is located at the highest
                        	; virtual address ($7FC00).
                        	;
                        	; Parameters:
                        	;		a0 = pid to allocate for
                        	;	Returns:
                        	;		v0 = physical address, 0 if unsuccessful
                        	;		v1 = virtual address, not valid unless successful
                        	;------------------------------------------------------------------------------
                        	
                        	AllocStack:
FFFC0EB4 01091893		sll			$v1,$a0,#16			; 
FFFC0EB8 00001637		or			$v1,$v1,#PAGES_PER_TASK-1	; last page of memory is for stack
FFFC0EBC FFF60613
FFFC0EC0 011668B3
FFFC0EC4 0310080D		mvmap		$v0,$x0,$v1			; check if stack already allocated
FFFC0EC8 00081863		bnez		$v0,.0001
FFFC0ECC 0800080D		palloc	$v0							; allocate a page
FFFC0ED0 00080E63		beq			$v0,$x0,.xit		; success?
FFFC0ED4 0318000D		mvmap		$x0,$v0,$v1
                        	.0001:
FFFC0ED8 00001637		and			$v1,$v1,#4095
FFFC0EDC FFF60613
FFFC0EE0 011678B3
FFFC0EE4 01081813		sll			$v0,$v0,#LOG_PGSZ			; convert pages to addresses
FFFC0EE8 01089893		sll			$v1,$v1,#LOG_PGSZ
                        	.xit:
FFFC0EEC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; This routine will de-allocate all the pages associated with a task including
                        	; the stack.
                        	;
                        	; Parameters:
                        	;		a0 = pid to free memory for
                        	;	Modifies:
                        	;		a0,t0,t1,t3,t4
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	FreeAll:
FFFC0EF0 00006E93		ldi			$t3,#0
FFFC0EF4 01091F13		sll			$t4,$a0,#16
                        	.nxt:
FFFC0EF8 00001637		slt			$t1,$t3,#PAGES_PER_TASK		; number of buckets to check
FFFC0EFC 00060613
FFFC0F00 040D8863		beqz		$t1,.0001
FFFC0F04 003F0637		and			$t4,$t4,#$3F0000
FFFC0F08 00060613
FFFC0F0C 01E67F33
FFFC0F10 01DF6F33		or			$t4,$t4,$t3			; combine pid and bucket number
FFFC0F14 00006D13		ldi			$t0,#0					; new page number to set (indicates free)
FFFC0F18 03ED0D0D		mvmap		$t0,$t0,$t4			; get page mapping and set to zero
FFFC0F1C 001E8E93		add			$t3,$t3,#1			; advance to next bucket
FFFC0F20 FC0D0CE3		beqz		$t0,.nxt				; 0 = no map in this bucket
FFFC0F24 0A0D000D		pfree		$t0							; free the page
FFFC0F28 00025637		ldo			$t0,NPAGES			; update the number of available pages
FFFC0F2C 82860613
FFFC0F30 00060633
FFFC0F34 00063D03
FFFC0F38 001D0D13		add			$t0,$t0,#1
FFFC0F3C 00025637		sto			$t0,NPAGES
FFFC0F40 82860613
FFFC0F44 00060633
FFFC0F48 01A63023
FFFC0F4C FA0006E3		bra			.nxt
                        	.0001:
FFFC0F50 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Convert a virtual address to a physical one
                        	;
                        	; Parameters:
                        	;		a0 = virtual address to convert
                        	; Modifies:
                        	;		t0
                        	; Returns:
                        	;		v0 = physcial address
                        	;------------------------------------------------------------------------------
                        	
                        	VirtToPhys:
FFFC0F54 02094A63		blt		$a0,$x0,.notMapped
FFFC0F58 01095D13		srl		$t0,$a0,#LOG_PGSZ		; convert virt to page
                        		
FFFC0F5C 18101873		csrrw	v0,#$181,x0
FFFC0F60 00F87813		and		v0,v0,#15
FFFC0F64 01081813	sll		$v0,$v0,#16
FFFC0F68 01A86833		or		$v0,$v0,$t0					; and in tid
FFFC0F6C 0300080D		mvmap	$v0,$x0,$v0					; get the translation
FFFC0F70 01081813		sll		$v0,$v0,#LOG_PGSZ		; convert page to address
FFFC0F74 00010637		and		$t0,$a0,#$FFFF			; insert LSB's
FFFC0F78 FFF60613
FFFC0F7C 01267D33
FFFC0F80 01A86833		or		$v0,$v0,$t0
FFFC0F84 00008067		ret
                        	.notMapped:
FFFC0F88 00096833		mov		$v0,$a0
FFFC0F8C 00008067		ret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/pic.r5a",1
                        	.file "../fmtk/pic.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	;
                        	;  0x80    - irq control for irq #0
                        	;  0x84    - irq control for irq #1
                        	;            bits 0 to 7  = cause code to issue
                        	;            bits 13 to 15 = irq level to issue
                        	;            bit 16 = irq enable
                        	;            bit 17 = edge sensitivity
                        	
                        	PIC				equ		$FFDC0F00
                        	PIC_CH16	equ		$C0
                        	PIC_CH28	equ		$F0
                        	PIC_CH31	equ		$FC
                        	
                        	PicInit:
FFFC0F90 00006D93		ldi		$t1,#$PIC					; t1 = address of pic
FFFC0F94 0001ED37		ldi		$t0,#$0001E025		; level sensitive cause 37, interrupt enabled
FFFC0F98 025D0D13
FFFC0F9C 0DADA023		stt		$t0,PIC_CH16[$t1]
FFFC0FA0 0001ED37		ldi		$t0,#$0001E021		; level sensitive cause 33, interrupt enabled
FFFC0FA4 021D0D13
FFFC0FA8 0FADA823		stt		$t0,PIC_CH28[$t1]
FFFC0FAC 0000ED37		ldi		$t0,#$0000E02F		; level sensitive cause 47, interrupt enabled
FFFC0FB0 02FD0D13
FFFC0FB4 0FADAE23		stt		$t0,PIC_CH31[$t1]
FFFC0FB8 00008067		ret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/serial.r5a",1
                        	.file "../fmtk/serial.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
                        	.file "../fmtk/serial.r5a",29
                        		code
FFFC0FBC 00000000		align	
                        	
                        	SerialFuncTbl:
FFFC0FC0 00000000		dco		0							; no operation
FFFC0FC4 00000000
FFFC0FC6 00000000		dco		0							; setup
FFFC0FCA 00000000
FFFC0FCC 00000000		dco		0							; initialize
FFFC0FD0 00000000
FFFC0FD2 00000000		dco		0							; status
FFFC0FD6 00000000
FFFC0FD8 00000000		dco		0							; media check
FFFC0FDC 00000000
FFFC0FDE 00000000		dco		0							; build BPB
FFFC0FE2 00000000
FFFC0FE4 00000000		dco		0							; open
FFFC0FE8 00000000
FFFC0FEA 00000000		dco		0							; close
FFFC0FEE 11DC0000
FFFC0FF0 FFFC11DC		dco		SerialGetChar	; get char
FFFC0FF4 12AC0000
FFFC0FF6 FFFC12AC		dco		SerialPeekChar
FFFC0FFA 00000000
FFFC0FFC 00000000		dco		0							; get char direct
FFFC1000 13140000
FFFC1002 FFFC1314		dco		SerialPeekCharDirect	; peek char direct
FFFC1006 00000000
FFFC1008 00000000		dco		0							; input status
FFFC100C 13700000
FFFC100E FFFC1370		dco		SerialPutChar
FFFC1012 00000000
FFFC1014 00000000		dco		0							; reserved
FFFC1018 00000000
FFFC101A 00000000		dco		0							; set position
FFFC101E 00000000
FFFC1020 00000000		dco		0							; read block
FFFC1024 00000000
FFFC1026 00000000		dco		0							; write block
FFFC102A 00000000
FFFC102C 00000000		dco		0							; verify block
FFFC1030 00000000
FFFC1032 00000000		dco		0							; output status
FFFC1036 00000000
FFFC1038 00000000		dco		0							; flush input
FFFC103C 00000000
FFFC103E 00000000		dco		0							; flush output
FFFC1042 14240000
FFFC1044 FFFC1424		dco		SerialIRQ			; IRQ routine
FFFC1048 00000000
FFFC104A 00000000		dco		0							; Is removable
FFFC104E 00000000
FFFC1050 00000000		dco		0							; ioctrl read
FFFC1054 00000000
FFFC1056 00000000		dco		0							; ioctrl write
FFFC105A 00000000
FFFC105C 00000000		dco		0							; output until busy
FFFC1060 00000000
FFFC1062 00000000		dco		0							; 27
FFFC1066 00000000
FFFC1068 00000000		dco		0
FFFC106C 00000000
FFFC106E 00000000		dco		0
FFFC1072 00000000
FFFC1074 00000000		dco		0
FFFC1078 00000000
FFFC107A 00000000		dco		0							; 31
FFFC107E 07130000
                        	
                        	MAX_DEV_OP			EQU		31
                        	
                        	;------------------------------------------------------------------------------
                        	; Initialize serial port.
                        	;
                        	; Modifies:
                        	;		$t0
                        	;------------------------------------------------------------------------------
                        	
                        	SerialInit:
FFFC1080 FF870713		sub		$sp,$sp,#8
FFFC1084 00173023		sto		$ra,[$sp]
FFFC1088 00506913		ldi		$a0,#5							; serial device
FFFC108C FFFC19B7		ldi		$a1,#SerialFuncTbl
FFFC1090 FC098993
FFFC1094 621010EF		call	CopyDevFuncTbl
FFFC1098 00026637		stt		$x0,SerHeadRcv
FFFC109C 80060613
FFFC10A0 00060633
FFFC10A4 00062023
FFFC10A8 00026637		stt		$x0,SerTailRcv
FFFC10AC 80460613
FFFC10B0 00060633
FFFC10B4 00062023
FFFC10B8 00026637		stt		$x0,SerHeadXmit
FFFC10BC 80860613
FFFC10C0 00060633
FFFC10C4 00062023
FFFC10C8 00026637		stt		$x0,SerTailXmit
FFFC10CC 80C60613
FFFC10D0 00060633
FFFC10D4 00062023
FFFC10D8 00026637		stb		$x0,SerRcvXon
FFFC10DC 81060613
FFFC10E0 00060633
FFFC10E4 00060023
FFFC10E8 00026637		stb		$x0,SerRcvXoff
FFFC10EC 81160613
FFFC10F0 00060633
FFFC10F4 00060023
FFFC10F8 00906D13		ldi		$t0,#$09						; dtr,rts active, rxint enabled, no parity
FFFC10FC FFDC1637		stt		$t0,UART+8
FFFC1100 A0860613
FFFC1104 00060633
FFFC1108 01A62023
FFFC110C 00060D37		ldi		$t0,#$0006001E			; reset the fifo's
FFFC1110 01ED0D13
FFFC1114 FFDC1637		stt		$t0,UART+12
FFFC1118 A0C60613
FFFC111C 00060633
FFFC1120 01A62023
FFFC1124 01E06D13		ldi		$t0,#$0000001E			; baud 9600, 1 stop bit, 8 bit, internal baud gen
FFFC1128 FFDC1637		stt		$t0,UART+12
FFFC112C A0C60613
FFFC1130 00060633
FFFC1134 01A62023
FFFC1138 00073083		ldo		$ra,[$sp]
FFFC113C 00870713		add		$sp,$sp,#8
FFFC1140 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	SerialServiceInit:
FFFC1144 00106913		ldi		$a0,#1			; start task
FFFC1148 40006993		ldi		$a1,#1024		; memory required
FFFC114C FFFC1A37		ldi		$a2,#SerialService
FFFC1150 15CA0A13
FFFC1154 00000073		ecall
FFFC1158 00008067		ret
                        	SerialService:
FFFC115C DE870713		sub		$sp,$sp,#512+24
FFFC1160 00E06913		ldi		$a0,#14			; get current tid
FFFC1164 00000073		ecall
FFFC1168 20470A13		add		$a2,$sp,#516
FFFC116C 000869B3		mov		$a1,$v0
FFFC1170 00606913		ldi		$a0,#6			; alloc mailbox
FFFC1174 00000073		ecall
                        	
                        	SerialServiceLoop:
FFFC1178 00A06913		ldi		$a0,#10			; waitmsg
FFFC117C 20470993		add		$a1,$sp,#516
FFFC1180 20870A13		add		$a2,$sp,#520
FFFC1184 20C70A93		add		$a3,$sp,#524
FFFC1188 21070B13		add		$a4,$sp,#528
FFFC118C FFF06B93		ldi		$a5,#-1
FFFC1190 00000073		ecall
                        	
FFFC1194 00072D03		lw		$t0,[$sp]
FFFC1198 01FD7D13		and		$t0,$t0,#31
FFFC119C 001D1D13		sll		$t0,$t0,#1
FFFC11A0 FFFC1637		lw		$t0,SerialFuncTbl[$t0]
FFFC11A4 FC060613
FFFC11A8 01A60633
FFFC11AC 00062D03
FFFC11B0 000D0067		jmp		[$t0]
                        	
                        	SerialFinishCmd:
FFFC11B4 00C72983		lw		$a1,12[$sp]		; reply mbx
FFFC11B8 00198993		add		$a1,$a1,#1		; -1 = no reply requested
FFFC11BC 01298E63		beq		$a1,$a0,.0001
FFFC11C0 FFF98993		sub		$a1,$a1,#1
FFFC11C4 00906913		ldi		$a0,#9				; sendmsg
FFFC11C8 FFF06A13		ldi		$a2,#-1
FFFC11CC FFF06A93		ldi		$a3,#-1
FFFC11D0 FFF06B13		ldi		$a4,#-1
FFFC11D4 00000073		ecall
                        	.0001:
FFFC11D8 FA1FF06F		jmp		SerialServiceLoop
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialGetChar
                        	;
                        	; Check the serial port buffer to see if there's a char available. If there's
                        	; a char available then return it. If the buffer is almost empty then send an
                        	; XON.
                        	;
                        	; Stack Space:
                        	;		3 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$v0 = character or -1
                        	;------------------------------------------------------------------------------
                        	
                        	SerialGetChar:
FFFC11DC FE870713			sub		$sp,$sp,#24
FFFC11E0 00173023			sto		$ra,[$sp]
FFFC11E4 01173423			sto		$v1,8[$sp]
FFFC11E8 00473823			sto		$s1,16[$sp]
FFFC11EC 00026637			lb		$s1,SerRcvXon				; skip sending XON if already sent
FFFC11F0 81060613
FFFC11F4 00060633
FFFC11F8 00060203
FFFC11FC 3000F273			csrrc	$s1,#$300,#1				; disable interrupts
FFFC1200 04021263			bne		$s1,$x0,.0002
FFFC1204 1E4000EF			call	SerialRcvCount			; check number of chars in receive buffer
FFFC1208 00882813			slt		$v0,$v0,#8					; less than 8?
FFFC120C 02080C63			beq		$v0,$x0,.0002
FFFC1210 01106813			ldi		$v0,#XON						; if <8 send an XON
FFFC1214 00026637			sb		$x0,SerRcvXoff			; clear XOFF status
FFFC1218 81160613
FFFC121C 00060633
FFFC1220 00060023
FFFC1224 00026637			sb		$v0,SerRcvXon				; flag so we don't send it multiple times
FFFC1228 81060613
FFFC122C 00060633
FFFC1230 01060023
FFFC1234 FFDC1637			sb		$v0,UART+UART_TRB
FFFC1238 A0060613
FFFC123C 00060633
FFFC1240 01060023
                        	.0002:
FFFC1244 00026637			lbu		$v1,SerHeadRcv			; check if anything is in buffer
FFFC1248 80060613
FFFC124C 00060633
FFFC1250 00064883
FFFC1254 00026637			lbu		$v0,SerTailRcv
FFFC1258 80460613
FFFC125C 00060633
FFFC1260 00064803
FFFC1264 03180663			beq		$v0,$v1,.noChars		; no?
FFFC1268 00025637			lb		$v0,SerRcvBuf[$v1]	; get byte from buffer
FFFC126C 00060613
FFFC1270 01160633
FFFC1274 00060803
FFFC1278 00188893			add		$v1,$v1,#1					; update head index
FFFC127C 00026637			sb		$v1,SerHeadRcv				
FFFC1280 80060613
FFFC1284 00060633
FFFC1288 01160023
FFFC128C 00000463			bra		.xit
                        	.noChars:
                        	.0001:
FFFC1290 FFF06813			ldi		$v0,#-1
                        	.xit
FFFC1294 30021073			csrrw	$x0,#$300,$s1				; restore interrupts
FFFC1298 00073083			ldo		$ra,[$sp]
FFFC129C 00873883			ldo		$v1,8[$sp]
FFFC12A0 01073203			ldo		$s1,16[$sp]
FFFC12A4 01870713			add		$sp,$sp,#24
FFFC12A8 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPeekChar
                        	;
                        	; Check the serial port buffer to see if there's a char available. If there's
                        	; a char available then return it. But don't update the buffer indexes. No need
                        	; to send an XON here.
                        	;
                        	; Stack Space:
                        	;		3 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$v0 = character or -1
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPeekChar:
FFFC12AC FE870713		sub		$sp,$sp,#24
FFFC12B0 00173023		sto		$ra,[$sp]
FFFC12B4 01173423		sto		$v1,8[$sp]
FFFC12B8 00473823		sto		$s1,16[$sp]
FFFC12BC 3000F273		csrrc	$s1,#$300,#1				; disable interrupts
FFFC12C0 00026637		ldbu	$v1,SerHeadRcv			; check if anything is in buffer
FFFC12C4 80060613
FFFC12C8 00060633
FFFC12CC 00064883
FFFC12D0 00026637		ldbu	$v0,SerTailRcv
FFFC12D4 80460613
FFFC12D8 00060633
FFFC12DC 00064803
FFFC12E0 01180C63		beq		$v0,$v1,.noChars		; no?
FFFC12E4 00025637		ldb		$v0,SerRcvBuf[$v1]	; get byte from buffer
FFFC12E8 00060613
FFFC12EC 01160633
FFFC12F0 00060803
FFFC12F4 00000463		bra		.xit
                        	.noChars:
                        	.0001:
FFFC12F8 FFF06813		ldi		$v0,#-1
                        	.xit
FFFC12FC 30021073		csrrw	$x0,#$300,$s1				; restore interrupts
FFFC1300 00073083		ldo		$ra,[$sp]
FFFC1304 00873883		ldo		$v1,8[$sp]
FFFC1308 01073203		ldo		$s1,16[$sp]
FFFC130C 01870713		add		$sp,$sp,#24
FFFC1310 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPeekChar
                        	;		Get a character directly from the I/O port. This bypasses the input
                        	; buffer.
                        	;
                        	; Stack Space:
                        	;		3 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$v0 = character or -1
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPeekCharDirect:
FFFC1314 FE870713		sub		$sp,$sp,#24
FFFC1318 00173023		sto		$ra,[$sp]
FFFC131C 01173423		sto		$v1,8[$sp]
FFFC1320 00473823		sto		$s1,16[$sp]
FFFC1324 3000F273		csrrc	$s1,#$300,#1				; disable interrupts
FFFC1328 FFDC1637		ldb		$v0,UART+UART_STAT
FFFC132C A0460613
FFFC1330 00060633
FFFC1334 00060803
FFFC1338 00887813		and		$v0,$v0,#8					; look for Rx not empty
FFFC133C 00080C63		beq		$v0,$x0,.0001
FFFC1340 FFDC1637		ldb		$v0,UART+UART_TRB
FFFC1344 A0060613
FFFC1348 00060633
FFFC134C 00060803
FFFC1350 00000463		bra		.xit
                        	.0001:
FFFC1354 FFF06813		ldi		$v0,#-1
                        	.xit
FFFC1358 30021073		csrrw	$x0,#$300,$s1				; restore interrupts
FFFC135C 00073083		ldo		$ra,[$sp]
FFFC1360 00873883		ldo		$v1,8[$sp]
FFFC1364 01073203		ldo		$s1,16[$sp]
FFFC1368 01870713		add		$sp,$sp,#24
FFFC136C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPutChar
                        	;    Put a character to the serial transmitter. This routine blocks until the
                        	; transmitter is empty. The routine will attempt to transmit the char up to 
                        	; 10 times. If it still can't transmit the char then sleep is called and the
                        	; task is put to sleep for a tick. When it wakes up the routine continues to
                        	; try and send a character.
                        	;
                        	; Stack Space
                        	;		5 words
                        	; Parameters:
                        	;		$a3 = character to put
                        	; Modifies:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPutChar:
FFFC1370 FE870713		sub		$sp,$sp,#24
FFFC1374 01073023		sto		$v0,[$sp]
FFFC1378 00173423		sto		$ra,8[$sp]
FFFC137C 01173823		sto		$v1,16[$sp]
                        	.0002:
FFFC1380 00A06893		ldi		$v1,#10
                        	.0001:
                        	;	sub		$v1,$v1,#1
                        	;	beq		$v1,$x0,.goSleep
FFFC1384 FFDC1637		ldb		$v0,UART+UART_STAT	; wait until the uart indicates tx empty
FFFC1388 A0460613
FFFC138C 00060633
FFFC1390 00060803
FFFC1394 01087813		and		$v0,$v0,#16					; bit #4 of the status reg
FFFC1398 FE0806E3		beqz	$v0,.0001						; branch if transmitter is not empty
FFFC139C FFDC1637		stb		$a3,UART+UART_TRB		; send the byte
FFFC13A0 A0060613
FFFC13A4 00060633
FFFC13A8 01560023
FFFC13AC 00073803		ldo		$v0,[$sp]
FFFC13B0 00873083		ldo		$ra,8[$sp]
FFFC13B4 01073883		ldo		$v1,16[$sp]
FFFC13B8 01870713		add		$sp,$sp,#24
FFFC13BC 00008067		ret
                        	.goSleep:
FFFC13C0 FF070713		sub		$sp,$sp,#16
FFFC13C4 01273023		sto		$a0,[$sp]
FFFC13C8 01373423		sto		$a1,8[$sp]
FFFC13CC 00506913		ldi		$a0,#5							; sleep function
FFFC13D0 00106993		ldi		$a1,#1							; 1 tick
FFFC13D4 00000073		ecall
FFFC13D8 00073903		ldo		$a0,[$sp]
FFFC13DC 00873983		ldo		$a1,8[$sp]
FFFC13E0 01070713		add		$sp,$sp,#16
FFFC13E4 F8000EE3		bra		.0002
                        	
                        	;------------------------------------------------------------------------------
                        	; Calculate number of character in input buffer
                        	;------------------------------------------------------------------------------
                        	
                        	SerialRcvCount:
FFFC13E8 00026637		ldbu	$v0,SerTailRcv	; v0 = tail index
FFFC13EC 80460613
FFFC13F0 00060633
FFFC13F4 00064803
FFFC13F8 00026637		ldbu	$v1,SerHeadRcv	; v1 = head index
FFFC13FC 80060613
FFFC1400 00060633
FFFC1404 00064883
FFFC1408 41180D33		sub		$t0,$v0,$v1
FFFC140C 000D5863		bge		$t0,$x0,.xit
FFFC1410 10006D13		ldi		$t0,#256
FFFC1414 411D0D33		sub		$t0,$t0,$v1
FFFC1418 010D0D33		add		$t0,$t0,$v0
                        	.xit:
FFFC141C 000D6833		mov		$v0,$t0
FFFC1420 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	SerialIRQ:
                        	.nxtByte:
FFFC1424 00897D13		and		$t0,$a0,#$08				; bit 3 = rx full
FFFC1428 0C0D0063		beq		$t0,$x0,.notRxInt
FFFC142C FFDC1637		lw		$a1,UART+UART_TRB		; get data from Rx buffer to clear interrupt
FFFC1430 A0060613
FFFC1434 00060633
FFFC1438 00062983
FFFC143C 00026637		lbu		$t2,SerHeadRcv			; get buffer indexes
FFFC1440 80060613
FFFC1444 00060633
FFFC1448 00064E03
FFFC144C 00026637		lbu		$t3,SerTailRcv
FFFC1450 80460613
FFFC1454 00060633
FFFC1458 00064E83
FFFC145C 001E8E93		add		$t3,$t3,#1					; see if buffer full
FFFC1460 0FFEFE93		and		$t3,$t3,#255
FFFC1464 09DE0263		beq		$t2,$t3,.rxFull
FFFC1468 00026637		sb		$t3,SerTailRcv			; update tail pointer
FFFC146C 80460613
FFFC1470 00060633
FFFC1474 01D60023
FFFC1478 FFFE8E93		sub		$t3,$t3,#1
FFFC147C 0FFEFE13		and		$t2,$t3,#255
FFFC1480 00025637		sb		$a1,SerRcvBuf[$t2]	; store recieved byte in buffer
FFFC1484 00060613
FFFC1488 01C60633
FFFC148C 01360023
FFFC1490 00026637		lb		$v0,SerRcvXoff			; check if xoff already sent
FFFC1494 81160613
FFFC1498 00060633
FFFC149C 00060803
FFFC14A0 02081A63		bne		$v0,$x0,.0001
FFFC14A4 F45FF0EF		call	SerialRcvCount			; if more than 240 chars in buffer
FFFC14A8 0F082813		slt		$v0,$v0,#240				; send an XOFF
FFFC14AC 02081463		bne		$v0,$x0,.0001
FFFC14B0 01306913		ldi		$a0,#XOFF
FFFC14B4 00026637		sb		$x0,SerRcvXon				; clear XON status
FFFC14B8 81060613
FFFC14BC 00060633
FFFC14C0 00060023
FFFC14C4 00026637		sb		$a0,SerRcvXoff			; set XOFF status
FFFC14C8 81160613
FFFC14CC 00060633
FFFC14D0 01260023
                        		sb		UART+UART_TRB
                        	.0001:
FFFC14D4 FFDC1637		lw		$a0,UART+UART_STAT	; check the status for another byte
FFFC14D8 A0460613
FFFC14DC 00060633
FFFC14E0 00062903
FFFC14E4 F40000E3		bra		.nxtByte
                        	;	ldi		$a0,#$0B						; dtr,rts active, rxint disabled, no parity
                        	;	sw		$a0,UART+UART_CMD
                        	.rxFull:
                        	.notRxInt:
FFFC14E8 10000073		eret
                        	
                        	nmeSerial:
FFFC14EC 69726553		db		"Serial",0
FFFC14F0 00006C61
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/via.r5a",1
                        	.file "../fmtk/via.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
FFFC14F3 00000000		align	
FFFC14F7 00000000
                        	
                        	ViaFuncTbl:
FFFC14F8 00000000		dco		0							; no operation
FFFC14FC 00000000
FFFC14FE 00000000		dco		0							; setup
FFFC1502 00000000
FFFC1504 00000000		dco		0							; initialize
FFFC1508 00000000
FFFC150A 00000000		dco		0							; status
FFFC150E 00000000
FFFC1510 00000000		dco		0							; media check
FFFC1514 00000000
FFFC1516 00000000		dco		0							; build BPB
FFFC151A 00000000
FFFC151C 00000000		dco		0							; open
FFFC1520 00000000
FFFC1522 00000000		dco		0							; close
FFFC1526 00000000
FFFC1528 00000000		dco		0							; get char
FFFC152C 00000000
FFFC152E 00000000		dco		0							; Peek char
FFFC1532 00000000
FFFC1534 00000000		dco		0							; get char direct
FFFC1538 00000000
FFFC153A 00000000		dco		0							; peek char direct
FFFC153E 00000000
FFFC1540 00000000		dco		0							; input status
FFFC1544 00000000
FFFC1546 00000000		dco		0							; Put char
FFFC154A 00000000
FFFC154C 00000000		dco		0							; reserved
FFFC1550 00000000
FFFC1552 00000000		dco		0							; set position
FFFC1556 00000000
FFFC1558 00000000		dco		0							; read block
FFFC155C 00000000
FFFC155E 00000000		dco		0							; write block
FFFC1562 00000000
FFFC1564 00000000		dco		0							; verify block
FFFC1568 00000000
FFFC156A 00000000		dco		0							; output status
FFFC156E 00000000
FFFC1570 00000000		dco		0							; flush input
FFFC1574 00000000
FFFC1576 00000000		dco		0							; flush output
FFFC157A 16140000
FFFC157C FFFC1614		dco		ViaIRQ				; IRQ routine
FFFC1580 00000000
FFFC1582 00000000		dco		0							; Is removable
FFFC1586 00000000
FFFC1588 00000000		dco		0							; ioctrl read
FFFC158C 00000000
FFFC158E 00000000		dco		0							; ioctrl write
FFFC1592 00000000
FFFC1594 00000000		dco		0							; output until busy
FFFC1598 00000000
FFFC159A 00000000		dco		0							; 27
FFFC159E 00000000
FFFC15A0 00000000		dco		0
FFFC15A4 00000000
FFFC15A6 00000000		dco		0
FFFC15AA 00000000
FFFC15AC 00000000		dco		0
FFFC15B0 00000000
FFFC15B2 00000000		dco		0							; 31
FFFC15B6 07130000
                        	
                        	;------------------------------------------------------------------------------
                        	; ViaInit
                        	;
                        	; Initialize the versatile interface adapter.
                        	;------------------------------------------------------------------------------
                        	
                        	ViaInit:
FFFC15B8 FF870713		sub		$sp,$sp,#8
FFFC15BC 00173023		sto		$ra,[$sp]
FFFC15C0 00F06913		ldi		$a0,#15							; VIA device
FFFC15C4 FFFC19B7		ldi		$a1,#ViaFuncTbl
FFFC15C8 4F898993
FFFC15CC 0E9010EF		call	CopyDevFuncTbl
                        		; Initialize port A low order eight bits as output, the remaining bits as
                        		; input.
FFFC15D0 FFDC0DB7		ldi		$t1,#VIA
FFFC15D4 600D8D93
FFFC15D8 0FF06D13		ldi		$t0,#$000000FF
FFFC15DC 01ADA623		stt		$t0,VIA_DDRA[$t1]
FFFC15E0 00106D13		ldi		$t0,#1							; select timer 3 access
FFFC15E4 03AD88A3		stb		$t0,VIA_PCR+1[$t1]
FFFC15E8 01F06D13		ldi		$t0,#$1F
FFFC15EC 03AD86A3		stb		$t0,VIA_ACR+1[$t1]		; set timer 3 mode, timer 1/2 = 64 bit
FFFC15F0 0016ED37		ldi		$t0,#$0016E360			;	divider value for 33.333Hz (30 ms)
FFFC15F4 360D0D13
FFFC15F8 01ADA823		stt		$t0,VIA_T1CL[$t1]
FFFC15FC 000DAA23		stt		$x0,VIA_T1CH[$t1]		; trigger transfer to count registers
FFFC1600 18006D13		ldi		$t0,#$180						; enable timer3 interrupts
FFFC1604 03ADAC23		stt		$t0,VIA_IER[$t1]
FFFC1608 00073083		ldo		$ra,[$sp]
FFFC160C 00870713		add		$sp,$sp,#8
FFFC1610 00008067		ret
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	ViaIRQ:
                        		; Was it the VIA that caused the interrupt?
FFFC1614 FFDC0DB7		ldi		$t1,VIA
FFFC1618 600D8D93
FFFC161C 034D8D03		ldb		$t0,VIA_IFR[$t1]
FFFC1620 040D5463		bge		$t0,$x0,.0003				; no
FFFC1624 00106D13		ldi		$t0,#1							; select timer 3 access
FFFC1628 03AD88A3		stb		$t0,VIA_PCR+1[$t1]
FFFC162C 010DAD03		ldt		$t0,VIA_T1CL[$t1]		; yes, clear interrupt
FFFC1630 00014637		ldt		$t0,milliseconds
FFFC1634 20860613
FFFC1638 00060633
FFFC163C 00062D03
FFFC1640 01ED0D13		add		$t0,$t0,#30
FFFC1644 00014637		stt		$t0,milliseconds
FFFC1648 20860613
FFFC164C 00060633
FFFC1650 01A62023
FFFC1654 00014637		stt		$t0,switchflag
FFFC1658 20060613
FFFC165C 00060633
FFFC1660 01A62023
FFFC1664 1D5000EF		call	FMTK_SchedulerIRQ
                        	.0003:
FFFC1668 10000073		eret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/video.r5a",1
                        	.file "../fmtk/video.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	TC64CursorAddr	equ		$FFD1DF1C
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
FFFC166C 00000000		align	
                        	
                        	VideoFuncTbl:
FFFC1670 00000000		dco		0							; no operation
FFFC1674 00000000
FFFC1676 00000000		dco		0							; setup
FFFC167A 00000000
FFFC167C 00000000		dco		0							; initialize
FFFC1680 00000000
FFFC1682 00000000		dco		0							; status
FFFC1686 00000000
FFFC1688 00000000		dco		0							; media check
FFFC168C 00000000
FFFC168E 00000000		dco		0							; build BPB
FFFC1692 00000000
FFFC1694 00000000		dco		0							; open
FFFC1698 00000000
FFFC169A 00000000		dco		0							; close
FFFC169E 00000000
FFFC16A0 00000000		dco		0							; get char
FFFC16A4 00000000
FFFC16A6 00000000		dco		0							; Peek char
FFFC16AA 00000000
FFFC16AC 00000000		dco		0							; get char direct
FFFC16B0 00000000
FFFC16B2 00000000		dco		0							; peek char direct
FFFC16B6 00000000
FFFC16B8 00000000		dco		0							; input status
FFFC16BC 18340000
FFFC16BE FFFC1834		dco		VideoPutChar	; Put char
FFFC16C2 00000000
FFFC16C4 00000000		dco		0							; reserved
FFFC16C8 00000000
FFFC16CA 00000000		dco		0							; set position
FFFC16CE 00000000
FFFC16D0 00000000		dco		0							; read block
FFFC16D4 00000000
FFFC16D6 00000000		dco		0							; write block
FFFC16DA 00000000
FFFC16DC 00000000		dco		0							; verify block
FFFC16E0 00000000
FFFC16E2 00000000		dco		0							; output status
FFFC16E6 00000000
FFFC16E8 00000000		dco		0							; flush input
FFFC16EC 00000000
FFFC16EE 00000000		dco		0							; flush output
FFFC16F2 19C40000
FFFC16F4 FFFC19C4		dco		VideoIRQ			; IRQ routine
FFFC16F8 00000000
FFFC16FA 00000000		dco		0							; Is removable
FFFC16FE 00000000
FFFC1700 00000000		dco		0							; ioctrl read
FFFC1704 00000000
FFFC1706 00000000		dco		0							; ioctrl write
FFFC170A 00000000
FFFC170C 00000000		dco		0							; output until busy
FFFC1710 00000000
FFFC1712 00000000		dco		0							; 27
FFFC1716 00000000
FFFC1718 00000000		dco		0
FFFC171C 00000000
FFFC171E 00000000		dco		0
FFFC1722 00000000
FFFC1724 00000000		dco		0
FFFC1728 00000000
FFFC172A 00000000		dco		0							; 31
FFFC172E 07130000
                        	
                        	;------------------------------------------------------------------------------
                        	; VideoInit
                        	;
                        	; Initialize the versatile interface adapter.
                        	;------------------------------------------------------------------------------
                        	
                        	VideoInit:
FFFC1730 FF870713		sub		$sp,$sp,#8
FFFC1734 00173023		sto		$ra,[$sp]
FFFC1738 00206913		ldi		$a0,#2							; Video device
FFFC173C FFFC19B7		ldi		$a1,#VideoFuncTbl
FFFC1740 67098993
FFFC1744 770010EF		call	CopyDevFuncTbl
FFFC1748 00025637		stb		$x0,CursorX
FFFC174C 80060613
FFFC1750 00060633
FFFC1754 00060023
FFFC1758 00025637		stb		$x0,CursorY
FFFC175C 80160613
FFFC1760 00060633
FFFC1764 00060023
FFFC1768 000F0D37		ldi		$t0,#$000F0000
FFFC176C 000D0D13
FFFC1770 00025637		stt		$t0,DispAttr
FFFC1774 80860613
FFFC1778 00060633
FFFC177C 01A62023
FFFC1780 00210D37		ldi		$t0,#$0020FFFF
FFFC1784 FFFD0D13
FFFC1788 00025637		stt		$t0,DispAttr+4
FFFC178C 80C60613
FFFC1790 00060633
FFFC1794 01A62023
FFFC1798 010000EF		call	VideoClearScreen
FFFC179C 00073083		ldo		$ra,[$sp]
FFFC17A0 00870713		add		$sp,$sp,#8
FFFC17A4 00008067		ret
                        	
                        	VideoClearScreen:
FFFC17A8 65806D13		ldi		$t0,#56*29
FFFC17AC 00025DB7		ldi		$t1,DispAttr
FFFC17B0 808D8D93
FFFC17B4 020DED93		or		$t1,$t1,#' '
FFFC17B8 FFD00E37		ldi		$t2,#$FFD00000
FFFC17BC 000E0E13
                        	.0001:
FFFC17C0 01BE3023		sto		$t1,[$t2]	
FFFC17C4 008E0E13		add		$t2,$t2,#8
FFFC17C8 FFFD0D13		sub		$t0,$t0,#1
FFFC17CC FFA04AE3		bgt		$t0,$x0,.0001
FFFC17D0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	VideoHomeCursor:
FFFC17D4 00025637		stb		$x0,CursorX
FFFC17D8 80060613
FFFC17DC 00060633
FFFC17E0 00060023
FFFC17E4 00025637		stb		$x0,CursorY
FFFC17E8 80160613
FFFC17EC 00060633
FFFC17F0 00060023
                        		; fall through into update cursor pos.
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	UpdateCursorPos:
FFFC17F4 00025637		ldbu	$t0,CursorY
FFFC17F8 80160613
FFFC17FC 00060633
FFFC1800 00064D03
FFFC1804 03806D93		ldi		$t1,#56
FFFC1808 03BD0D33		mul		$t0,$t0,$t1
FFFC180C 00025637		ldbu	$t1,CursorX
FFFC1810 80060613
FFFC1814 00060633
FFFC1818 00064D83
FFFC181C 01BD0D33		add		$t0,$t0,$t1
FFFC1820 FFD1E637		stw		$t0,TC64CursorAddr
FFFC1824 F1C60613
FFFC1828 00060633
FFFC182C 01A61023
FFFC1830 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	VideoPutChar:
FFFC1834 FF870713		sub		$sp,$sp,#8
FFFC1838 00173023		sto		$ra,[$sp]
FFFC183C 00D06D13		ldi		$t0,#CR
FFFC1840 11A90463		beq		$a0,$t0,.doCR
FFFC1844 00A06D13		ldi		$t0,#$0A				; line feed
FFFC1848 13A90063		beq		$a0,$t0,.doLF
FFFC184C 00C06D13		ldi		$t0,#$0C				; CTRL-L
FFFC1850 17A90463		beq		$a0,$t0,.doCls
FFFC1854 FFD00D37		ldi		$t0,#$FFD00000
FFFC1858 000D0D13
FFFC185C 09106D13		ldi		$t0,#$91
FFFC1860 11A90E63		beq		$a0,$t0,.cursorRight
FFFC1864 00025637		ldbu	$t1,CursorX
FFFC1868 80060613
FFFC186C 00060633
FFFC1870 00064D83
FFFC1874 003D9D93		sll		$t1,$t1,#3
FFFC1878 01BD0D33		add		$t0,$t0,$t1
FFFC187C 00025637		ldbu	$t1,CursorY
FFFC1880 80160613
FFFC1884 00060633
FFFC1888 00064D83
FFFC188C 1C006E13		ldi		$t2,#56*8
FFFC1890 03CD8DB3		mul		$t1,$t1,$t2
FFFC1894 01BD0D33		add		$t0,$t0,$t1
FFFC1898 00025637		ldo		$t1,DispAttr
FFFC189C 80860613
FFFC18A0 00060633
FFFC18A4 00063D83
FFFC18A8 013DEDB3		or		$t1,$t1,$a1
FFFC18AC 01BD3023		sto		$t1,[$t0]
FFFC18B0 00025637		ldbu	$t0,CursorX
FFFC18B4 80060613
FFFC18B8 00060633
FFFC18BC 00064D03
FFFC18C0 001D0D13		add		$t0,$t0,#1
FFFC18C4 03806D93		ldi		$t1,#56
FFFC18C8 07BD4063		blt		$t0,$t1,.saveX
FFFC18CC 00006D13		ldi		$t0,#0
                        	.doLF1:
FFFC18D0 00025637		ldbu	$t2,CursorY
FFFC18D4 80160613
FFFC18D8 00060633
FFFC18DC 00064E03
FFFC18E0 001E0E13		add		$t2,$t2,#1
FFFC18E4 01D06D93		ldi		$t1,#29
FFFC18E8 03BE4863		blt		$t2,$t1,.saveY
                        		; scroll up
FFFC18EC 65806E93		ldi		$t3,#56*29
FFFC18F0 FFD00F37		ldi		$t4,#$FFD00000
FFFC18F4 000F0F13
                        	.0001:
FFFC18F8 1C0F3F83		ldo		$t5,56*8[$t4]
FFFC18FC 01FF3023		sto		$t5,[$t4]
FFFC1900 008F0F13		add		$t4,$t4,#8
FFFC1904 FFFE8E93		sub		$t3,$t3,#1
FFFC1908 FFD048E3		bgt		$t3,$x0,.0001
FFFC190C 00073083		ldo		$ra,[$sp]
FFFC1910 00870713		add		$sp,$sp,#8
FFFC1914 00008067		ret
                        	.saveY:
FFFC1918 00025637		stb		$t2,CursorY
FFFC191C 80160613
FFFC1920 00060633
FFFC1924 01C60023
                        	.saveX:
FFFC1928 00025637		stb		$t0,CursorX
FFFC192C 80060613
FFFC1930 00060633
FFFC1934 01A60023
FFFC1938 EBDFF0EF		call	UpdateCursorPos
FFFC193C 00073083		ldo		$ra,[$sp]
FFFC1940 00870713		add		$sp,$sp,#8
FFFC1944 00008067		ret
                        	.doCR:
FFFC1948 00025637		stb		$x0,CursorX
FFFC194C 80060613
FFFC1950 00060633
FFFC1954 00060023
FFFC1958 E9DFF0EF		call	UpdateCursorPos
FFFC195C 00073083		ldo		$ra,[$sp]
FFFC1960 00870713		add		$sp,$sp,#8
FFFC1964 00008067		ret
                        	.doLF:
FFFC1968 00025637		ldbu	$t0,CursorX
FFFC196C 80060613
FFFC1970 00060633
FFFC1974 00064D03
FFFC1978 F4000CE3		bra		.doLF1
                        	.cursorRight:
FFFC197C 00025637		ldbu	$t0,CursorX
FFFC1980 80060613
FFFC1984 00060633
FFFC1988 00064D03
FFFC198C 001D0D13		add		$t0,$t0,#1
FFFC1990 03706D93		ldi		$t1,#55
FFFC1994 01BD5C63		bge		$t0,$t1,.cr1
FFFC1998 00025637		stb		$t0,CursorX
FFFC199C 80060613
FFFC19A0 00060633
FFFC19A4 01A60023
FFFC19A8 E4DFF0EF		call	UpdateCursorPos
                        	.cr1:
FFFC19AC 00073083		ldo		$ra,[$sp]
FFFC19B0 00870713		add		$sp,$sp,#8
FFFC19B4 00008067		ret
                        	.doCls:
FFFC19B8 DF1FF0EF		call	VideoClearScreen
FFFC19BC E19FF0EF		call	VideoHomeCursor
FFFC19C0 FE0006E3		bra		.cr1
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	VideoIRQ:
                        		; Was it the Video that caused the interrupt?
                        	.0003:
FFFC19C4 10000073		eret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/task.r5a",1
                        	.file "../fmtk/task.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../fmtk/task.r5a",25
                        		code
                        		align	2                        	
                        	OSCallTbl:
FFFC19C8 2170018B		dh		FMTK_Initialize					; 0
FFFC19CA 224C2170		dh		FMTK_StartTask					; 1
FFFC19CC 2278224C		dh		FMTK_ExitTask
FFFC19CE 018F2278		dh		FMTK_KillTask
FFFC19D0 1F38018F		dh		FMTK_SetTaskPriority
FFFC19D2 23481F38		dh		FMTK_Sleep							; 5
FFFC19D4 23B82348		dh		FMTK_AllocMbx
FFFC19D6 019323B8		dh		FMTK_FreeMbx
FFFC19D8 24480193		dh		FMTK_PostMsg
FFFC19DA 26202448		dh		FMTK_SendMsg
FFFC19DC 25582620		dh		FMTK_WaitMsg						; 10
FFFC19DE 01972558		dh		FMTK_PeekMsg
FFFC19E0 00000197		dh		FMTK_StartApp
FFFC19E2 1B580000		dh		0												; 13
FFFC19E4 01991B58		dh		FMTK_GetCurrentTid
FFFC19E6 00000199		dh		DumpReadyQueue
FFFC19E8 00000000		dh		0
FFFC19EA 00000000		dh		0
FFFC19EC 00000000		dh		0
FFFC19EE 2C200000		dh		0
FFFC19F0 2C802C20		dh		FMTK_HasIOFocus					; 20
FFFC19F2 2DA82C80		dh		FMTK_SwitchIOFocus			; 21
FFFC19F4 2DB42DA8		dh		FMTK_ReleaseIOFocus			; 22
FFFC19F6 2D1C2DB4		dh		FMTK_ForceReleaseIOFocus	; 23
FFFC19F8 00002D1C		dh		FMTK_RequestIOFocus			; 24
FFFC19FA 2E6C0000		dh		0
FFFC19FC 00002E6C		dh		FMTK_IO									; 26
                        	
                        	qToChk:
FFFC19FE 02000000		db	0,0,0,2,0,0,4,2
FFFC1A02 02040000
FFFC1A06 02060000		db	0,0,6,2,0,0,4,2
FFFC1A0A 02040000
FFFC1A0E 02000000		db	0,0,0,2,0,0,4,2
FFFC1A12 02040000
FFFC1A16 02060000		db	0,0,6,2,0,0,4,2
FFFC1A1A 02040000
                        	
FFFC1A1E 46370000		align	
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FMTKInit:
FFFC1A20 00024637		stt		$x0,QNDX
FFFC1A24 30460613
FFFC1A28 00060633
FFFC1A2C 00062023
FFFC1A30 00024637		sto		$x0,PIDMAP
FFFC1A34 31060613
FFFC1A38 00060633
FFFC1A3C 00063023
FFFC1A40 00024637		stt		$x0,missed_ticks
FFFC1A44 32060613
FFFC1A48 00060633
FFFC1A4C 00062023
FFFC1A50 FFF06D13		ldi		$t0,#-1
FFFC1A54 00024637		stt		$t0,TimeoutList
FFFC1A58 32860613
FFFC1A5C 00060633
FFFC1A60 01A62023
FFFC1A64 00024637		stt		$t0,READYQ
FFFC1A68 30860613
FFFC1A6C 00060633
FFFC1A70 01A62023
FFFC1A74 00024637		stt		$t0,READYQ+4
FFFC1A78 30C60613
FFFC1A7C 00060633
FFFC1A80 01A62023
FFFC1A84 00025637		stw		$t0,hKeybdMbx
FFFC1A88 82260613
FFFC1A8C 00060633
FFFC1A90 01A61023
                        	
FFFC1A94 00025637		stb		$x0,SwitchIOFocus	
FFFC1A98 82060613
FFFC1A9C 00060633
FFFC1AA0 00060023
FFFC1AA4 00025637		stt		$x0,IOFocusTbl
FFFC1AA8 81860613
FFFC1AAC 00060633
FFFC1AB0 00062023
FFFC1AB4 00025637		stt		$t0,IOFocusNdx
FFFC1AB8 81060613
FFFC1ABC 00060633
FFFC1AC0 01A62023
                        	
                        		; zero out device function table
FFFC1AC4 00022D37		ldi		$t0,#DVF_Base
FFFC1AC8 000D0D13
FFFC1ACC 40006D93		ldi		$t1,#32*32
                        	.0003:
FFFC1AD0 000D3023		sto		$x0,[$t0]
FFFC1AD4 008D0D13		add		$t0,$t0,#8
FFFC1AD8 FFFD8D93		sub		$t1,$t1,#1
FFFC1ADC FFB04AE3		bgt		$t1,$x0,.0003
                        	
                        		; Initialize mailboxes
FFFC1AE0 00020D37		ldi		$t0,#mbxs
FFFC1AE4 000D0D13
FFFC1AE8 08006D93		ldi		$t1,#4*32
                        	.0001:
FFFC1AEC 000D3023		sto		$x0,[$t0]
FFFC1AF0 008D0D13		add		$t0,$t0,#8
FFFC1AF4 FFFD8D93		sub		$t1,$t1,#1
FFFC1AF8 FFB04AE3		bgt		$t1,$x0,.0001
                        	
                        		; Initialize free message list
FFFC1AFC 00010D37		ldi		$t0,#msgs
FFFC1B00 000D0D13
FFFC1B04 00024637		sto		$t0,FreeMsg
FFFC1B08 35060613
FFFC1B0C 00060633
FFFC1B10 01A63023
FFFC1B14 00006D93		ldi		$t1,#0
FFFC1B18 00001E37		ldi		$t2,#NR_MSG
FFFC1B1C 800E0E13
                        	.0002:
FFFC1B20 001D8D93		add		$t1,$t1,#1
FFFC1B24 01BD3023		sto		$t1,MSG_LINK[$t0]
FFFC1B28 020D0D13		add		$t0,$t0,#32
FFFC1B2C FFFE0E13		sub		$t2,$t2,#1
FFFC1B30 FFC048E3		bgt		$t2,$x0,.0002
                        	
                        		; unlock the system semaphore	
                        		
FFFC1B34 FFF06813		ldi		v0,#-1
FFFC1B38 00024637		sw		v0,SysSema
FFFC1B3C 34060613
FFFC1B40 00060633
FFFC1B44 01062023
                        	
FFFC1B48 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Get the task id for the currently running task.
                        	;
                        	; Returns:
                        	;		v0 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	GetCurrentTid:
FFFC1B4C 18101873		csrrw	$v0,#$181,$x0				; get current pid
FFFC1B50 03F87813		and		$v0,$v0,#MAX_TID		; mask off extra bits
FFFC1B54 00008067		ret
                        	
                        	FMTK_GetCurrentTid:
FFFC1B58 3000E073		csrrs	$x0,#$300,#1				; enable ints
                        		
FFFC1B5C 18101873		csrrw	v0,#$181,x0
FFFC1B60 00F87813		and		v0,v0,#15
FFFC1B64 000868B3	mov		$v1,$v0
FFFC1B68 00006813		ldi		$v0,#E_Ok
FFFC1B6C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	MapOSPages:
FFFC1B70 00306813		ldi			$v0,#OSPAGES	; number of pages pre-mapped
FFFC1B74 00006893		ldi			$v1,#0
FFFC1B78 01091893		sll			$v1,$a0,#16		; put ASID in proper spot
                        	.nxt:
FFFC1B7C 0318800D		mvmap		$x0,$v1,$v1
FFFC1B80 00188893		add			$v1,$v1,#1
FFFC1B84 FFF80813		sub			$v0,$v0,#1
FFFC1B88 FF004AE3		bgt			$v0,$x0,.nxt
FFFC1B8C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Select the next task to run. The ready lists are searched in a circular
                        	; fashion beginning with the list identified indirectly by QNDX. There are
                        	; four ready lists to hold tasks of four different priorities. 
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		v1, t0, t1, t2, t3, t4
                        	;	Returns:
                        	;		v0 = task id of task to run
                        	;------------------------------------------------------------------------------
                        	
                        	SelectTaskToRun:
                        		; Pick the first queue to check, occasionally the queue
                        		; chosen isn't the highest priority one in order to 
                        		; prevent starvation of lower priority tasks.
FFFC1B90 00024637		ldbu	$v1,QNDX						; get index into que check table
FFFC1B94 30460613
FFFC1B98 00060633
FFFC1B9C 00064883
FFFC1BA0 00188893		add		$v1,$v1,#1					; increment it, and limit
FFFC1BA4 01F8F893		and		$v1,$v1,#31
FFFC1BA8 00024637		stb		$v1,QNDX						; store back
FFFC1BAC 30460613
FFFC1BB0 00060633
FFFC1BB4 01160023
FFFC1BB8 FFFC2637		ldbu	$v1,qToChk[$v1]			; assume this will be valid
FFFC1BBC 9FE60613
FFFC1BC0 01160633
FFFC1BC4 00064883
FFFC1BC8 00406E13		ldi		$t2,#4							; 4 queues to check
                        	.nxtQ:
FFFC1BCC 1C08880D		getrdy	$v0,$v1
;	ldw		$v0,READYQ[$v1]			; check queue to see if contains any
FFFC1BD0 02085063		bge		$v0,$x0,.dq					; yes, go dequeue
                        	.0001:
FFFC1BD4 00188893		add		$v1,$v1,#1					; no, advance to next queue
FFFC1BD8 0038F893		and		$v1,$v1,#3					; 4 max
FFFC1BDC FFFE0E13		sub		$t2,$t2,#1					;
FFFC1BE0 FFC046E3		bgt		$t2,$x0,.nxtQ				; go back to check next queue
                        		; Here, nothing else is actually ready to run
                        		; just go back to what we were doing.
                        		
FFFC1BE4 18101873		csrrw	v0,#$181,x0
FFFC1BE8 00F87813		and		v0,v0,#15
FFFC1BEC 00008067	ret
                        	.dq:
                        	;	ldi		$t3,#MAX_TID				; ensure we have a valid tid
                        	;	bleu	$v0,$t3,.goodTid
                        		; If the tid isn't valid the readyq was screwed up
                        	;	ldi		$t3,#-1							; indicate queue empty
                        	;	stw		$t3,READYQ[$v1]
                        	;	bra		.0001								; and try next queue
                        	.goodTid:
FFFC1BF0 18181073		csrrw		$x0,#$181,$v0
                        		;sll		$t1,$v0,#LOG_TCBSZ
                        		;ldw		$t0,TCBNext[$t1]		; update head of ready queue
                        		;stw		$t0,READYQ[$v1]
FFFC1BF4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	SaveContext:
                        		; Save outgoing register set in TCB
FFFC1BF8 78027073		csrrc	$x0,#$780,#4	; select previous (user) register set for Rs2
FFFC1BFC 00123423		sto		$x1,8[$s1]
FFFC1C00 00223823		sto		$x2,16[$s1]
FFFC1C04 00323C23		sto		$x3,24[$s1]
FFFC1C08 02423023		sto		$x4,32[$s1]
FFFC1C0C 02523423		sto		$x5,40[$s1]
FFFC1C10 02623823		sto		$x6,48[$s1]
FFFC1C14 02723C23		sto		$x7,56[$s1]
FFFC1C18 04823023		sto		$x8,64[$s1]
FFFC1C1C 04923423		sto		$x9,72[$s1]
FFFC1C20 04A23823		sto		$x10,80[$s1]
FFFC1C24 04B23C23		sto		$x11,88[$s1]
FFFC1C28 06C23023		sto		$x12,96[$s1]
FFFC1C2C 06D23423		sto		$x13,104[$s1]
FFFC1C30 06E23823		sto		$x14,112[$s1]
FFFC1C34 06F23C23		sto		$x15,120[$s1]
FFFC1C38 09023023		sto		$x16,128[$s1]
FFFC1C3C 09123423		sto		$x17,136[$s1]
FFFC1C40 09223823		sto		$x18,144[$s1]
FFFC1C44 09323C23		sto		$x19,152[$s1]
FFFC1C48 0B423023		sto		$x20,160[$s1]
FFFC1C4C 0B523423		sto		$x21,168[$s1]
FFFC1C50 0B623823		sto		$x22,176[$s1]
FFFC1C54 0B723C23		sto		$x23,184[$s1]
FFFC1C58 0D823023		sto		$x24,192[$s1]
FFFC1C5C 0D923423		sto		$x25,200[$s1]
FFFC1C60 0DA23823		sto		$x26,208[$s1]
FFFC1C64 0DB23C23		sto		$x27,216[$s1]
FFFC1C68 0FC23023		sto		$x28,224[$s1]
FFFC1C6C 0FD23423		sto		$x29,232[$s1]
FFFC1C70 0FE23823		sto		$x30,240[$s1]
FFFC1C74 0FF23C23		sto		$x31,248[$s1]
FFFC1C78 78026073		csrrs	$x0,#$780,#4				; select current register set for Rs2
FFFC1C7C 34101173		csrrw	$x2,#$341,$x0				; save off mepc
FFFC1C80 28223023		sto		$x2,TCBepc[$s1]
                        		; Now save off segment registers
FFFC1C84 00006D93		ldi		$t1,#0
                        	.svseg:
FFFC1C88 01B00D0D		mvseg	$t0,$x0,$t1
FFFC1C8C 003D9113		sll		$x2,$t1,#3
FFFC1C90 00410133		add		$x2,$x2,$s1
FFFC1C94 21A13023		sto		$t0,TCBsegs[$x2]
FFFC1C98 001D8D93		add		$t1,$t1,#1
FFFC1C9C 00FDFD93		and		$t1,$t1,#15
FFFC1CA0 FE0D94E3		bne		$t1,$x0,.svseg
FFFC1CA4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	RestoreContext:
                        		; Switch memory maps
FFFC1CA8 00A2D813		srl		$v0,$s2,#10					; convert pointer to tid
FFFC1CAC 03F87813		and		$v0,$v0,#$3F				; mask to 64 task
FFFC1CB0 181818F3		csrrw	$v1,#$181,$v0				; set ASID
                        	
                        		; Restore segment register set
FFFC1CB4 00006D93		ldi		$t1,#0
                        	.rsseg:
FFFC1CB8 003D9113		sll		$x2,$t1,#3
FFFC1CBC 00510133		add		$x2,$x2,$s2
FFFC1CC0 20013D03		ldo		$t0,TCBsegs[$x2]
FFFC1CC4 01BD000D		mvseg	$x0,$t0,$t1
FFFC1CC8 001D8D93		add		$t1,$t1,#1
FFFC1CCC 00FDFD93		and		$t1,$t1,#15
FFFC1CD0 FE0D94E3		bne		$t1,$x0,.rsseg
                        	
FFFC1CD4 2802B103		ldo		$x2,TCBepc[$s2]			; restore epc
FFFC1CD8 34111073		csrrw	$x0,#$341,$x2
                        		; Restore incoming registers
FFFC1CDC 7800F073		csrrc	$x0,#$780,#1				; select previous regset for Rd
FFFC1CE0 0082B083		ldo		$x1,8[$s2]
FFFC1CE4 0102B103		ldo		$x2,16[$s2]
FFFC1CE8 0182B183		ldo		$x3,24[$s2]
FFFC1CEC 0202B203		ldo		$x4,32[$s2]
FFFC1CF0 0282B283		ldo		$x5,40[$s2]
FFFC1CF4 0302B303		ldo		$x6,48[$s2]
FFFC1CF8 0382B383		ldo		$x7,56[$s2]
FFFC1CFC 0402B403		ldo		$x8,64[$s2]
FFFC1D00 0482B483		ldo		$x9,72[$s2]
FFFC1D04 0502B503		ldo		$x10,80[$s2]
FFFC1D08 0582B583		ldo		$x11,88[$s2]
FFFC1D0C 0602B603		ldo		$x12,96[$s2]
FFFC1D10 0682B683		ldo		$x13,104[$s2]
FFFC1D14 0702B703		ldo		$x14,112[$s2]
FFFC1D18 0782B783		ldo		$x15,120[$s2]
FFFC1D1C 0802B803		ldo		$x16,128[$s2]
FFFC1D20 0882B883		ldo		$x17,136[$s2]
FFFC1D24 0902B903		ldo		$x18,144[$s2]
FFFC1D28 0982B983		ldo		$x19,152[$s2]
FFFC1D2C 0A02BA03		ldo		$x20,160[$s2]
FFFC1D30 0A82BA83		ldo		$x21,168[$s2]
FFFC1D34 0B02BB03		ldo		$x22,176[$s2]
FFFC1D38 0B82BB83		ldo		$x23,184[$s2]
FFFC1D3C 0C02BC03		ldo		$x24,192[$s2]
FFFC1D40 0C82BC83		ldo		$x25,200[$s2]
FFFC1D44 0D02BD03		ldo		$x26,208[$s2]
FFFC1D48 0D82BD83		ldo		$x27,216[$s2]
FFFC1D4C 0E02BE03		ldo		$x28,224[$s2]
FFFC1D50 0E82BE83		ldo		$x29,232[$s2]
FFFC1D54 0F02BF03		ldo		$x30,240[$s2]
FFFC1D58 0F82BF83		ldo		$x31,248[$s2]
FFFC1D5C 7800E073		csrrs	$x0,#$780,#1				; select current regset for Rd
FFFC1D60 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Swap from outgoing context to incoming context.
                        	;
                        	; Parameters:
                        	;		s1 = pointer to TCB of outgoing context
                        	;		s2 = pointer to TCB of incoming context
                        	;------------------------------------------------------------------------------
                        	
                        	SwapContext:
FFFC1D64 16520463		beq		$s1,$s2,.noCtxSwitch@
                        		; Save outgoing register set in TCB
FFFC1D68 78001873		csrrw	$v0,#$780,$x0				; get register set
FFFC1D6C F3F87893		and		$v1,$v0,#$FFFFFF3F	; set previous to user regset
FFFC1D70 78089073		csrrw	$x0,#$780,$v1	
FFFC1D74 78027073		csrrc	$x0,#$780,#4				; select previous (user) register set for Rs2
FFFC1D78 00123423		sto		$x1,8[$s1]
FFFC1D7C 00223823		sto		$x2,16[$s1]
FFFC1D80 00323C23		sto		$x3,24[$s1]
FFFC1D84 02423023		sto		$x4,32[$s1]
FFFC1D88 02523423		sto		$x5,40[$s1]
FFFC1D8C 02623823		sto		$x6,48[$s1]
FFFC1D90 02723C23		sto		$x7,56[$s1]
FFFC1D94 04823023		sto		$x8,64[$s1]
FFFC1D98 04923423		sto		$x9,72[$s1]
FFFC1D9C 04A23823		sto		$x10,80[$s1]
FFFC1DA0 04B23C23		sto		$x11,88[$s1]
FFFC1DA4 06C23023		sto		$x12,96[$s1]
FFFC1DA8 06D23423		sto		$x13,104[$s1]
FFFC1DAC 06E23823		sto		$x14,112[$s1]
FFFC1DB0 06F23C23		sto		$x15,120[$s1]
FFFC1DB4 09023023		sto		$x16,128[$s1]
FFFC1DB8 09123423		sto		$x17,136[$s1]
FFFC1DBC 09223823		sto		$x18,144[$s1]
FFFC1DC0 09323C23		sto		$x19,152[$s1]
FFFC1DC4 0B423023		sto		$x20,160[$s1]
FFFC1DC8 0B523423		sto		$x21,168[$s1]
FFFC1DCC 0B623823		sto		$x22,176[$s1]
FFFC1DD0 0B723C23		sto		$x23,184[$s1]
FFFC1DD4 0D823023		sto		$x24,192[$s1]
FFFC1DD8 0D923423		sto		$x25,200[$s1]
FFFC1DDC 0DA23823		sto		$x26,208[$s1]
FFFC1DE0 0DB23C23		sto		$x27,216[$s1]
FFFC1DE4 0FC23023		sto		$x28,224[$s1]
FFFC1DE8 0FD23423		sto		$x29,232[$s1]
FFFC1DEC 0FE23823		sto		$x30,240[$s1]
FFFC1DF0 0FF23C23		sto		$x31,248[$s1]
FFFC1DF4 78026073		csrrs	$x0,#$780,#4				; select current register set for Rs2
FFFC1DF8 34101173		csrrw	$x2,#$341,$x0				; save off mepc
FFFC1DFC 28223023		sto		$x2,TCBepc[$s1]
                        		; Now save off segment registers
FFFC1E00 00006D93		ldi		$t1,#0
                        	.svseg:
FFFC1E04 01B00D0D		mvseg	$t0,$x0,$t1
FFFC1E08 003D9113		sll		$x2,$t1,#3
FFFC1E0C 00410133		add		$x2,$x2,$s1
FFFC1E10 21A13023		sto		$t0,TCBsegs[$x2]
FFFC1E14 001D8D93		add		$t1,$t1,#1
FFFC1E18 00FDFD93		and		$t1,$t1,#15
FFFC1E1C FE0D94E3		bne		$t1,$x0,.svseg
                        	
                        		; Restore segment register set
FFFC1E20 00006D93		ldi		$t1,#0
                        	.rsseg:
FFFC1E24 003D9113		sll		$x2,$t1,#3
FFFC1E28 00510133		add		$x2,$x2,$s2
FFFC1E2C 20013D03		ldo		$t0,TCBsegs[$x2]
FFFC1E30 01BD000D		mvseg	$x0,$t0,$t1
FFFC1E34 001D8D93		add		$t1,$t1,#1
FFFC1E38 00FDFD93		and		$t1,$t1,#15
FFFC1E3C FE0D94E3		bne		$t1,$x0,.rsseg
                        	
FFFC1E40 2809B103		ldo		$x2,TCBepc[$a1]			; restore epc
FFFC1E44 34111073		csrrw	$x0,#$341,$x2
                        		; Restore incoming registers
FFFC1E48 7800F073		csrrc	$x0,#$780,#1				; select previous regset for Rd
FFFC1E4C 0082B083		ldo		$x1,8[$s2]
FFFC1E50 0102B103		ldo		$x2,16[$s2]
FFFC1E54 0182B183		ldo		$x3,24[$s2]
FFFC1E58 0202B203		ldo		$x4,32[$s2]
FFFC1E5C 0282B283		ldo		$x5,40[$s2]
FFFC1E60 0302B303		ldo		$x6,48[$s2]
FFFC1E64 0382B383		ldo		$x7,56[$s2]
FFFC1E68 0402B403		ldo		$x8,64[$s2]
FFFC1E6C 0482B483		ldo		$x9,72[$s2]
FFFC1E70 0502B503		ldo		$x10,80[$s2]
FFFC1E74 0582B583		ldo		$x11,88[$s2]
FFFC1E78 0602B603		ldo		$x12,96[$s2]
FFFC1E7C 0682B683		ldo		$x13,104[$s2]
FFFC1E80 0702B703		ldo		$x14,112[$s2]
FFFC1E84 0782B783		ldo		$x15,120[$s2]
FFFC1E88 0802B803		ldo		$x16,128[$s2]
FFFC1E8C 0882B883		ldo		$x17,136[$s2]
FFFC1E90 0902B903		ldo		$x18,144[$s2]
FFFC1E94 0982B983		ldo		$x19,152[$s2]
FFFC1E98 0A02BA03		ldo		$x20,160[$s2]
FFFC1E9C 0A82BA83		ldo		$x21,168[$s2]
FFFC1EA0 0B02BB03		ldo		$x22,176[$s2]
FFFC1EA4 0B82BB83		ldo		$x23,184[$s2]
FFFC1EA8 0C02BC03		ldo		$x24,192[$s2]
FFFC1EAC 0C82BC83		ldo		$x25,200[$s2]
FFFC1EB0 0D02BD03		ldo		$x26,208[$s2]
FFFC1EB4 0D82BD83		ldo		$x27,216[$s2]
FFFC1EB8 0E02BE03		ldo		$x28,224[$s2]
FFFC1EBC 0E82BE83		ldo		$x29,232[$s2]
FFFC1EC0 0F02BF03		ldo		$x30,240[$s2]
FFFC1EC4 0F82BF83		ldo		$x31,248[$s2]
FFFC1EC8 78081073		csrrw	$x0,#$780,$v0				; restore register set selections
                        	.noCtxSwitch:
FFFC1ECC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Operating system call dispatcher.
                        	;------------------------------------------------------------------------------
                        	
                        	OSCALL:
FFFC1ED0 78017073		csrrc	$x0,#$780,#2		; select previous regs for Rs1		
FFFC1ED4 00096933		mov		$a0,$a0					; move previous to current
FFFC1ED8 0009E9B3		mov		$a1,$a1
FFFC1EDC 000A6A33		mov		$a2,$a2
FFFC1EE0 000AEAB3		mov		$a3,$a3
FFFC1EE4 000B6B33		mov		$a4,$a4
FFFC1EE8 000BEBB3		mov		$a5,$a5
FFFC1EEC 78016073		csrrs	$x0,#$780,#2		; get back current registers for all
FFFC1EF0 01F97913		and		$a0,$a0,#31
FFFC1EF4 02090E63		beqz	$a0,.zero
FFFC1EF8 00191913		sll		$a0,$a0,#1
FFFC1EFC FFFC2637		lhu		$t0,OSCallTbl[$a0]
FFFC1F00 9C860613
FFFC1F04 01260633
FFFC1F08 00065D03
FFFC1F0C 020D0263		beqz	$t0,.zero
FFFC1F10 FFFC0637		or		$t0,$t0,#$FFFC0000
FFFC1F14 00060613
FFFC1F18 01A66D33
FFFC1F1C 000D00E7		call	[$t0]						; call the OS Function
                        	.xit:
FFFC1F20 7800F073		csrrc	$x0,#$780,#1		; select previous regs for Rd
FFFC1F24 00086833		mov		$v0,$v0
FFFC1F28 0008E8B3		mov		$v1,$v1
FFFC1F2C 10000073		eret
                        	.zero:
FFFC1F30 01A06813		ldi		$v0,#E_BadCallno
FFFC1F34 FE0006E3		bra		.xit
                        	
                        	;------------------------------------------------------------------------------
                        	; Sleep for a number of ticks. Tick interval determined by the VIA timer #3.
                        	; Passing a time of zero or less causes the function to return right away.
                        	;
                        	; Parameters:
                        	;		a1 = length of time to sleep (must be >= 0)
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_Sleep:
FFFC1F38 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC1F3C FF870713		sub		$sp,$sp,#8
FFFC1F40 00173023		sto		$ra,[$sp]
FFFC1F44 0E09C463		bltz	$a1,.xit
                        		
FFFC1F48 18101873		csrrw	v0,#$181,x0
FFFC1F4C 00F87813		and		v0,v0,#15
FFFC1F50 00A81213	sll		$s1,$v0,#LOG_TCBSZ
                        		; First thing: set end time. We don't want to include time spent in the OS in
                        		; the time accounting, so we set the end time as soon as possible.
FFFC1F54 70101E73		csrrw	$t2,#$701,$x0					; get time
FFFC1F58 2BC23C23		sto		$t2,TCBEndTime[$s1]
FFFC1F5C 00098C63		beqz	$a1,.0001
FFFC1F60 00086933		mov		$a0,$v0								; a0 = current tid
FFFC1F64 3000F073		csrrc	$x0,#$300,#1					; disable ints
FFFC1F68 7E0000EF		call	RemoveFromReadyList
FFFC1F6C 095000EF		call	InsertIntoTimeoutList	; a1 = timeout
FFFC1F70 3000E073		csrrs	$x0,#$300,#1					; enable ints
                        	.0001:
FFFC1F74 28824803		ldbu	$v0,TCBStatus[$s1]		; flag task as no longer running
FFFC1F78 F7F87813		and		$v0,$v0,#~TS_RUNNING
FFFC1F7C 29020423		stb		$v0,TCBStatus[$s1]
                        	
                        		;	AccountTime
FFFC1F80 2B823E03		ldo		$t2,TCBEndTime[$s1]		; get back end time
FFFC1F84 2B023E83		ldo		$t3,TCBStartTime[$s1]
FFFC1F88 41DE0F33		sub		$t4,$t2,$t3						; end - start
FFFC1F8C 2C023F83		ldo		$t5,TCBElapsedTime[$s1]
FFFC1F90 01EF8FB3		add		$t5,$t5,$t4						; ticks + (end - start)
FFFC1F94 2DF23023		sto		$t5,TCBElapsedTime[$s1]
                        		; Will switch to target memory map.
FFFC1F98 BF9FF0EF		call	SelectTaskToRun
                        	
FFFC1F9C 00A81293		sll		$s2,$v0,#LOG_TCBSZ		; s2 = pointer to incoming TCB
FFFC1FA0 2882C103		ldbu	$x2,TCBStatus[$s2]		; x2 = incoming status
FFFC1FA4 08116E13		or		$t2,$x2,#TS_RUNNING|TS_READY	; set status = running
FFFC1FA8 2C82A103		ldt		$x2,TCBException[$s2]	;
FFFC1FAC 00010A63		beqz	$x2,.noException
                        		; set link register to catch handler address
                        		;{
                        		;	t->regs[29] = t->regs[28];   // set link register to catch handler
                        		;	t->epc = t->regs[28];        // and the PC register
                        		;	t->regs[1] = t->exception;    // r1 = exception value
                        		;	t->exception = 0;
                        		;	t->regs[2] = 45;              // r2 = exception type
                        		;}
FFFC1FB0 0022B423		sto		$x2,8[$s2]						; r1 = exception
FFFC1FB4 2C02A423		stt		$x0,TCBException[$s2]	; tcb->exception = 0
FFFC1FB8 02D06113		ldi		$x2,#45
FFFC1FBC 0022B823		sto		$x2,16[$s2]						; r2 = 45
                        	.noException:
                        	
                        		; If a message is ready, update status to ready and put
                        		; message in target memory. The task will be returning
                        		; from a WaitMsg so a return status of E_Ok is also set.
FFFC1FC0 004E7113		and		$x2,$t2,#TS_MSGRDY
FFFC1FC4 04010463		beqz	$x2,.noMsg
FFFC1FC8 0A02B903		ldo		$a0,160[$s2]					; user a2 (x20)
FFFC1FCC 00090863		beqz	$a0,.0002
FFFC1FD0 F85FE0EF		call	VirtToPhys
FFFC1FD4 2982B103		ldo		$x2,TCBMsgD1[$s2]
FFFC1FD8 00283023		sto		$x2,[$v0]
                        	.0002:
FFFC1FDC 0A82B903		ldo		$a0,168[$s2]
FFFC1FE0 00090863		beqz	$a0,.0003
FFFC1FE4 F71FE0EF		call	VirtToPhys
FFFC1FE8 2A02B103		ldo		$x2,TCBMsgD2[$s2]
FFFC1FEC 00283023		sto		$x2,[$v0]
                        	.0003:
FFFC1FF0 0B02B903		ldo		$a0,176[$s2]
FFFC1FF4 00090863		beqz	$a0,.0004
FFFC1FF8 F5DFE0EF		call	VirtToPhys
FFFC1FFC 2A82B103		ldo		$x2,TCBMsgD3[$s2]
FFFC2000 00283023		sto		$x2,[$v0]
                        	.0004:
FFFC2004 00006113		ldi		$x2,#E_Ok						; setup to return E_Ok
FFFC2008 0822B023		sto		$x2,128[$s2]					; in v0
                        	
                        	.noMsg:
FFFC200C FFBE7E13		and		$t2,$t2,#~TS_MSGRDY		; mask out message ready status
FFFC2010 29C28423		stb		$t2,TCBStatus[$s2]
                        	
                        		; A context switch will be performed by the scheduler IRQ when a tick occurs.
                        		; Go to a low power mode while waiting for the interrupt.
                        		; The context switch will return after the wfi. However, another interrupt
                        		; might have occurred that didn't switch the context. So, the task status
                        		; is checked to see if it's ready yet. If not the wait continues.
                        		; What's really wanted is a wait for scheduler task interrupt.
                        	.wait:
FFFC2014 10100073		wfi
FFFC2018 28824E03		ldbu	$t2,TCBStatus[$s1]
FFFC201C 001E7E13		and		$t2,$t2,#TS_READY
FFFC2020 FE0E0AE3		beqz	$t2,.wait
                        	
                        		; As above, we want to minimize the impact of the OS on the tasks scheduled
                        		; time. So we set the start time as late as possible.
FFFC2024 70101E73		csrrw	$t2,#$701,$x0					; get time
FFFC2028 2BC23823		sto		$t2,TCBStartTime[$s1]
                        	.xit:
FFFC202C 00073083		ldo		$ra,[$sp]
FFFC2030 00870713		add		$sp,$sp,#8
FFFC2034 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SchedulerIRQ meant to be called from the timer ISR.
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_SchedulerIRQ:
FFFC2038 3000E073		csrrs	$x0,#$300,#1				; enable ints
                        		
FFFC203C 18101873		csrrw	v0,#$181,x0
FFFC2040 00F87813		and		v0,v0,#15
FFFC2044 00A81213	sll		$s1,$v0,#LOG_TCBSZ		; compute pointer to TCB
FFFC2048 70101E73		csrrw	$t2,#$701,$x0					; get time
FFFC204C 2BC23C23		sto		$t2,TCBEndTime[$s1]
FFFC2050 1600000D		decto												; decrement timeouts (takes 64 clock cycles async)
FFFC2054 FF870713		sub		$sp,$sp,#8
FFFC2058 00173023		sto		$ra,[$sp]
FFFC205C 00024937		ldi		$a0,#SysSema
FFFC2060 34090913
FFFC2064 01406993		ldi		$a1,#20
                        	;	call	LockSemaphore
                        	;	beq		$v0,$x0,.noLock
                        	; Might need the following if the external timer isn't used.
                        	;	csrrw	$v0,#$701,$x0					; get the time
                        	;	add		$v0,$v0,#300000				; wait 300,000 cycles @40MHz (30ms)
                        	;	csrrw	$x0,#$321,$v0					; set next interrupt time
                        		;	AccountTime
FFFC2068 2B023E83		ldo		$t3,TCBStartTime[$s1]
FFFC206C 41DE0F33		sub		$t4,$t2,$t3						; end - start
FFFC2070 2C023F83		ldo		$t5,TCBElapsedTime[$s1]
FFFC2074 01EF8FB3		add		$t5,$t5,$t4						; ticks + (end - start)
FFFC2078 2DF23023		sto		$t5,TCBElapsedTime[$s1]
                        	
FFFC207C 28824F83		ldbu	$t5,TCBStatus[$s1]
FFFC2080 020FEF93		or		$t5,$t5,#TS_PREEMPT
FFFC2084 F7FFFF93		and		$t5,$t5,#~TS_RUNNING	; no longer running, but may still be ready
FFFC2088 29F20423		stb		$t5,TCBStatus[$s1]
                        		; Keep popping the timeout list as long as there are tasks on it with
                        		; expired timeouts.
FFFC208C 00006913		ldi		$a0,#0
FFFC2090 1400038D		getzl	$s4		; Get list of tasks whose timeout is zero
.0001:
FFFC2094 00A91F13		sll		$t4,$a0,#10
FFFC2098 288F4E03		lbu		$t2,TCBStatus[$t4]
FFFC209C 010E7E13		and		$t2,$t2,#TS_TIMEOUT
FFFC20A0 020E0463		beqz	$t2,.noTimeout
FFFC20A4 0013FE13		and		$t2,$s4,#1					; is zero bit set?
FFFC20A8 020E0063		beqz	$t2,.notZero
FFFC20AC 288F4E03		lbu		$t2,TCBStatus[$t4]
FFFC20B0 FE7E7E13		and		$t2,$t2,#~(TS_TIMEOUT|TS_WAITMSG)
	sb		$t2,TCBStatus[$t4]
FFFC20B4 29CF0423
FFFC20B8 3000F073		csrrc	$x0,#$300,#1				; disable ints
FFFC20BC 22C000EF		call	MbxRemoveTask
FFFC20C0 5E4000EF		call	InsertIntoReadyList
FFFC20C4 3000E073		csrrs	$x0,#$300,#1				; enable ints
                        	.notZero:
                        	.noTimeout:
FFFC20C8 00190913		add		$a0,$a0,#1
FFFC20CC 0013D393		srl		$s4,$s4,#1	
FFFC20D0 FC0392E3		bnez	$s4,.0001
                        	
                        		; The ready list was just updated, there could be new tasks
                        		; ready to run. Will switch to target memory map.
FFFC20D4 ABDFF0EF		call	SelectTaskToRun
                        	
FFFC20D8 00A81293		sll		$s2,$v0,#LOG_TCBSZ	; s2 = pointer to incoming TCB
FFFC20DC 2882C103		lbu		$x2,TCBStatus[$s2]	; x2 = incoming status
FFFC20E0 08116E13		or		$t2,$x2,#TS_RUNNING|TS_READY	; status = running
FFFC20E4 2C82B103		ldo		$x2,TCBException[$s2]	;
FFFC20E8 00010263		beqz	$x2,.noException
                        		; set link register to catch handler address
                        		;{
                        		;	t->regs[29] = t->regs[28];   // set link register to catch handler
                        		;	t->epc = t->regs[28];        // and the PC register
                        		;	t->regs[1] = t->exception;    // r1 = exception value
                        		;	t->exception = 0;
                        		;	t->regs[2] = 45;              // r2 = exception type
                        		;}
                        	.noException:
                        	
                        		; If a message is ready, update status to ready and put
                        		; message in target memory. The task will be returning
                        		; from a WaitMsg so a return status of E_Ok is also set.
FFFC20EC 04000863		bra		.noMsg
FFFC20F0 004E7113		and		$x2,$t2,#TS_MSGRDY
FFFC20F4 04010463		beq		$x2,$x0,.noMsg
FFFC20F8 0A02B903		ldo		$a0,160[$s2]					; user a2 (x20)
FFFC20FC 00090863		beq		$a0,$x0,.0002
FFFC2100 E55FE0EF		call	VirtToPhys
FFFC2104 2982B103		ldo		$x2,TCBMsgD1[$s2]
FFFC2108 00283023		sto		$x2,[$v0]
                        	.0002:
FFFC210C 0A82B903		ldo		$a0,168[$s2]
FFFC2110 00090863		beq		$a0,$x0,.0003
FFFC2114 E41FE0EF		call	VirtToPhys
FFFC2118 2A02B103		ldo		$x2,TCBMsgD2[$s2]
FFFC211C 00283023		sto		$x2,[$v0]
                        	.0003:
FFFC2120 0B02B903		ldo		$a0,176[$s2]
FFFC2124 00090863		beq		$a0,$x0,.0004
FFFC2128 E2DFE0EF		call	VirtToPhys
FFFC212C 2A82B103		ldo		$x2,TCBMsgD3[$s2]
FFFC2130 00283023		sto		$x2,[$v0]
                        	.0004:
FFFC2134 00006113		ldi		$x2,#E_Ok						; setup to return E_Ok
FFFC2138 0822B023		sto		$x2,128[$s2]				; in v0
                        	
                        	.noMsg:
FFFC213C FFBE7E13		and		$t2,$t2,#~TS_MSGRDY		; mask out message ready status
FFFC2140 29C28423		stb		$t2,TCBStatus[$s2]
                        	
                        		
FFFC2144 FFF06813		ldi		v0,#-1
FFFC2148 00024637		sw		v0,SysSema
FFFC214C 34060613
FFFC2150 00060633
FFFC2154 01062023
                        	
                        	.noLock:
FFFC2158 C0DFF0EF		call	SwapContext
FFFC215C 00073083		ldo		$ra,[$sp]
FFFC2160 00870713		add		$sp,$sp,#8
FFFC2164 70101E73		csrrw	$t2,#$701,$x0					; get low time
FFFC2168 2BC2B823		sto		$t2,TCBStartTime[$s2]
FFFC216C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Start a task.
                        	;	Task status is set to ready, priority normal, and the task is inserted into
                        	; the ready list. Segment registers are setup for a flat memory model.
                        	; 
                        	;	Parameters:
                        	;		a1 = memory required
                        	;		a2 = start pc (usually $100)
                        	;	Modifies:
                        	;		a0 = tid
                        	;	Returns:
                        	;		v0 = E_Ok if successful
                        	;		v1 = tid of started task if successful
                        	;------------------------------------------------------------------------------
                        	;
                        	FMTK_StartTask:
FFFC2170 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC2174 FF870713		sub		$sp,$sp,#8
FFFC2178 00173023		sto		$ra,[$sp]
FFFC217C 009000EF		call	AllocTCB
FFFC2180 00004637		stb		$v1,$4321
FFFC2184 32160613
FFFC2188 00060633
FFFC218C 01160023
FFFC2190 0A081863		bnez	$v0,.err
FFFC2194 0008E933		mov		$a0,$v1
FFFC2198 D59FE0EF		call	FreeAll
FFFC219C 9D5FF0EF		call	MapOSPages			; Map OS pages into address space
FFFC21A0 00A91213		sll		$s1,$a0,#LOG_TCBSZ	; compute TCB address
FFFC21A4 D11FE0EF		call	AllocStack
FFFC21A8 A0010637		add		$t0,$v1,#$A000FFFC	; set stack pointer
FFFC21AC FFC60613
FFFC21B0 01160D33
FFFC21B4 07A23823		sto		$t0,112[$s1]
FFFC21B8 29423023		sto		$a2,TCBepc[$s1]	; address task will begin at
FFFC21BC C3DFE0EF		call	Alloc
FFFC21C0 00004637		stb		$v0,$4320
FFFC21C4 32060613
FFFC21C8 00060633
FFFC21CC 01060023
FFFC21D0 06081863		bnez	$v0,.err
FFFC21D4 00106D13		ldi		$t0,#TS_READY
FFFC21D8 29A20423		stb		$t0,TCBStatus[$s1]
FFFC21DC 00206D13		ldi		$t0,#2					; normal execution priority
FFFC21E0 29A204A3		stb		$t0,TCBPriority[$s1]
                        		; leave segment base at $0, flat memory model
FFFC21E4 00606D13		ldi		$t0,#6							; read,write
FFFC21E8 21A23023		sto		$t0,TCBsegs[$s1]			; segs 0 to 11
FFFC21EC 21A23423		sto		$t0,TCBsegs+8[$s1]
FFFC21F0 21A23823		sto		$t0,TCBsegs+16[$s1]
FFFC21F4 21A23C23		sto		$t0,TCBsegs+24[$s1]
FFFC21F8 23A23023		sto		$t0,TCBsegs+32[$s1]
FFFC21FC 23A23423		sto		$t0,TCBsegs+40[$s1]
FFFC2200 23A23823		sto		$t0,TCBsegs+48[$s1]
FFFC2204 23A23C23		sto		$t0,TCBsegs+56[$s1]
FFFC2208 25A23023		sto		$t0,TCBsegs+64[$s1]
FFFC220C 25A23423		sto		$t0,TCBsegs+72[$s1]
FFFC2210 25A23823		sto		$t0,TCBsegs+80[$s1]
FFFC2214 25A23C23		sto		$t0,TCBsegs+88[$s1]
FFFC2218 00506D13		ldi		$t0,#5							; read,execute
FFFC221C 27A23023		sto		$t0,TCBsegs+96[$s1]	; segs 12 to 15
FFFC2220 27A23423		sto		$t0,TCBsegs+104[$s1]
FFFC2224 27A23823		sto		$t0,TCBsegs+112[$s1]
FFFC2228 27A23C23		sto		$t0,TCBsegs+120[$s1]
FFFC222C 32023823		sto		$x0,TCBVideoMem[$s1]
FFFC2230 00A25913		srl		$a0,$s1,#LOG_TCBSZ	; need the tid again
FFFC2234 3000F073		csrrc	$x0,#$300,#1				; disable ints
FFFC2238 46C000EF		call	InsertIntoReadyList
FFFC223C 000968B3		mov		$v1,$a0
                        	.err:
                        	.xit:
FFFC2240 00073083		ldo		$ra,[$sp]
FFFC2244 00870713		add		$sp,$sp,#8
FFFC2248 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Exit the current task.
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		a1 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_ExitTask:
FFFC224C 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC2250 FF870713		sub		$sp,$sp,#8
FFFC2254 00173023		sto		$ra,[$sp]
                        		
FFFC2258 18101873		csrrw	v0,#$181,x0
FFFC225C 00F87813		and		v0,v0,#15
FFFC2260 000869B3	mov		a1,v0
FFFC2264 00000637		call	KillTask
FFFC2268 1CF600E7
                        	.xit:
FFFC226C 00073083		ldo		$ra,[$sp]
FFFC2270 00870713		add		$sp,$sp,#8
FFFC2274 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = tid of task to kill
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_KillTask:
FFFC2278 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC227C FF870713		sub		$sp,$sp,#8
FFFC2280 00173023		sto		$ra,[$sp]
FFFC2284 04098A63		beqz	$a1,.immortal		; tid #0 is immortal (the system)
FFFC2288 00206D13		ldi		$t0,#TS_DEAD				; flag task as dead (prevents it from being re-queued)
FFFC228C 03F9FD93		and		$t1,$a1,#MAX_TID		; limit tid
FFFC2290 00AD9D93		sll		$t1,$t1,#LOG_TCBSZ	; convert to TCB address
FFFC2294 29AD8423		stb		$t0,TCBStatus[$t1]
FFFC2298 0009E933		mov		$a0,$a1								; a0 = pid
FFFC229C 3000F073		csrrc	$x0,#$300,#1				; disable ints
FFFC22A0 4A8000EF		call	RemoveFromReadyList
FFFC22A4 C4DFE0EF		call	FreeAll							; free all the memory associated with the task
                        		; Now make process ID available for reuse
FFFC22A8 00024637		ldo		$t1,PIDMAP
FFFC22AC 31060613
FFFC22B0 00060633
FFFC22B4 00063D83
FFFC22B8 00106D13		ldi		$t0,#1							; generate bit "off" mask
FFFC22BC 013D1D33		sll		$t0,$t0,$a1
FFFC22C0 FFFD4D13		xor		$t0,$t0,#-1					; complment for inverted mask
FFFC22C4 01ADFDB3		and		$t1,$t1,$t0
FFFC22C8 00024637		sto		$t1,PIDMAP
FFFC22CC 31060613
FFFC22D0 00060633
FFFC22D4 01B63023
                        	.immortal:
FFFC22D8 00006813		ldi		$v0,#E_Ok
                        	.xit:
FFFC22DC 00073083		ldo		$ra,[$sp]
FFFC22E0 00870713		add		$sp,$sp,#8
FFFC22E4 00008067		ret
                        	
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/msg.r5a",1
                        	.file "../fmtk/msg.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	MBX_OWNER			equ		0		; tid of owning task
                        	MBX_WTIDS			equ		8		; tasks waiting at mailbox
                        	MBX_MQHEAD		equ		16		
                        	MBX_MQTAIL		equ		24
                        	MBX_SIZE			equ		32
                        	LOG_MBXSZ			equ		5
                        	
                        	MSG_LINK	equ		0
                        	MSG_D1		equ		8
                        	MSG_D2		equ		16
                        	MSG_D3		equ		24
                        	MSG_SIZE	equ		32
                        	LOG_MSGSZ	equ		5
                        	
                        	;	bss
                        	;	align 4
                        	;FreeMsg	dw	0
                        	;msgs:
                        	;	fill.b	MSG_SIZE*1024,0
                        	;mbxs:
                        	;	fill.b	MBX_SIZE*32,0
                        	;mbxs_end:
                        	
                        	.file "../fmtk/msg.r5a",48
                        		code
                        		align	4                        	
                        	
                        	;------------------------------------------------------------------------------
                        	; Remove the task from the list of tasks waiting at the mailbox.
                        	; This routine is only called from a couple of places and it is convenient
                        	; not to stack the return address. So, it is implemented as a macro.
                        	;
                        	; Parameters:
                        	;		a0 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	MbxRemoveTask:
FFFC22E8 FE070713		sub		$sp,$sp,#32
FFFC22EC 00473023		sto		$s1,[$sp]
FFFC22F0 01A73423		sto		$t0,8[$sp]
FFFC22F4 01B73823		sto		$t1,16[$sp]
FFFC22F8 01C73C23		sto		$t2,24[$sp]
FFFC22FC 00A91213		sll		$s1,$a0,#LOG_TCBSZ		; tid to pointer
FFFC2300 28A21D03		lh		$t0,TCBWaitMbx[$s1]		; get mailbox handle
FFFC2304 020D4663		blt		$t0,$x0,.xit					; handle good?
FFFC2308 005D1D13		sll		$t0,$t0,#LOG_MBXSZ		; convert to pointer
FFFC230C 00020637		add		$t0,$t0,#mbxs					; by adding base address
FFFC2310 00060613
FFFC2314 01A60D33
FFFC2318 008D3D83		ldo		$t1,MBX_WTIDS[$t0]		; get waiting task list
FFFC231C 00106E13		ldi		$t2,#1								; create a mask for given task id
FFFC2320 012E1E33		sll		$t2,$t2,$a0
FFFC2324 FFFE4E13		xor		$t2,$t2,#-1
FFFC2328 01CDFDB3		and		$t1,$t1,$t2						; clear bit
FFFC232C 01BD3423		sto		$t1,MBX_WTIDS[$t0]		; update waiting task list
                        	.xit:
FFFC2330 00073203		ldo		$s1,[$sp]
FFFC2334 00873D03		ldo		$t0,8[$sp]
FFFC2338 01073D83		ldo		$t1,16[$sp]
FFFC233C 01873E03		ldo		$t2,24[$sp]
FFFC2340 02070713		add		$sp,$sp,#32
FFFC2344 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Allocate a mailbox.
                        	;
                        	; Parameters:
                        	;		a1 = task id of owner
                        	;		a2 = pointer where to store handle
                        	; Returns:
                        	;		v0 = E_Ok
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_AllocMbx:
                        		; Enable interrupts
FFFC2348 3000E073		csrrs	$x0,#$300,#1				
FFFC234C FF870713		sub		$sp,$sp,#8
FFFC2350 00173023		sto		$ra,[$sp]
FFFC2354 040A0A63		beq		$a2,$x0,.badArg
FFFC2358 00020D37		ldi		$t0,#mbxs
FFFC235C 000D0D13
                        	.nxt:
FFFC2360 000D4D83		ldbu	$t1,MBX_OWNER[$t0]
FFFC2364 000D8E63		beq		$t1,$x0,.noOwner
FFFC2368 020D0D13		add		$t0,$t0,#MBX_SIZE
FFFC236C 00022637		slt		$t1,$t0,#mbxs_end
FFFC2370 00060613
FFFC2374 FE0D96E3		bne		$t1,$x0,.nxt
FFFC2378 04006813		ldi		$v0,#E_NoMoreMbx
FFFC237C 02000863		bra		.xit
                        	.noOwner:
FFFC2380 013D0023		stb		$a1,MBX_OWNER[$t0]
FFFC2384 FFFE0637		sub		$t5,$t0,#mbxs				; convert pointer to handle
FFFC2388 00060613
FFFC238C 41A60FB3
FFFC2390 005FDF93		srl		$t5,$t5,#LOG_MBXSZ
FFFC2394 000A6933		mov		$a0,$a2
FFFC2398 BBDFE0EF		call	VirtToPhys
FFFC239C 01F83023		sto		$t5,[$v0]
FFFC23A0 00006813		ldi		$v0,#E_Ok
FFFC23A4 00000463		bra		.xit
                        	.badArg:
FFFC23A8 00106813		ldi		$v0,#E_Arg
                        	.xit:
FFFC23AC 00073083		ldo		$ra,[$sp]
FFFC23B0 00870713		add		$sp,$sp,#8
FFFC23B4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Free a mailbox
                        	;
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_FreeMbx:
                        		; Enable interrupts
FFFC23B8 3000E073		csrrs	$x0,#$300,#1				
FFFC23BC FF870713		sub		$sp,$sp,#8
FFFC23C0 00173023		sto		$ra,[$sp]
FFFC23C4 1009A213		slt		$s1,$a1,#NR_MBX
FFFC23C8 06020863		beq		$s1,$x0,.badMbx
FFFC23CC 00599213		sll		$s1,$a1,#LOG_MBXSZ		; convert handle to pointer
FFFC23D0 00020637		add		$s1,$s1,#mbxs
FFFC23D4 00060613
FFFC23D8 00460233
FFFC23DC 00006293		ldi		$s2,#0
FFFC23E0 04006393		ldi		$s4,#NR_TCB						; possibly 64 tasks
FFFC23E4 00823483		ldo		$s6,MBX_WTIDS[$s1]
                        	.0002:
FFFC23E8 0014F313		and		$s3,$s6,#1
FFFC23EC 02030C63		beq		$s3,$x0,.0001
FFFC23F0 00A29413		sll		$s5,$s2,#LOG_TCBSZ		; tid to pointer
FFFC23F4 28844803		lbu		$v0,TCBStatus[$s5]
FFFC23F8 FF787813		and		$v0,$v0,#~TS_WAITMSG	; no longer waiting
FFFC23FC 29040423		stb		$v0,TCBStatus[$s5]
FFFC2400 01087813		and		$v0,$v0,#TS_TIMEOUT
FFFC2404 0002E933		mov		$a0,$s2
                        		; Disable interrupts
FFFC2408 3000F073		csrrc	$x0,#$300,#1
FFFC240C 00080463		beqz	$v0,.0003
FFFC2410 4D4000EF		call	RemoveFromTimeoutList
                        	.0003:
FFFC2414 290000EF		call	InsertIntoReadyList
FFFC2418 3000E073		csrrs	$x0,#$300,#1					; enable ints
FFFC241C 00B06813		ldi		$v0,#E_NoMsg					; but no message
FFFC2420 09043023		sto		$v0,128[$s5]					; v0 = E_NoMsg
                        	.0001:
FFFC2424 0014D493		srl		$s6,$s6,#1
FFFC2428 00128293		add		$s2,$s2,#1
FFFC242C FA72EEE3		bltu	$s2,$s4,.0002
FFFC2430 00006813		ldi		$v0,#E_Ok
FFFC2434 00000463		bra		.xit
                        	.badMbx:
FFFC2438 00406813		ldi		$v0,#E_BadMbx				; return null pointer if bad mailbox
                        	.xit:
FFFC243C 00073083		ldo		$ra,[$sp]
FFFC2440 00870713		add		$sp,$sp,#8
FFFC2444 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Send a message to a mailbox.
                        	; The message will be broadcast to any waiting tasks. Waiting tasks will then
                        	; be moved to the ready list. If there are no waiting tasks then the message
                        	; is queued at the mailbox.
                        	;
                        	; Register Usage:
                        	;		t0 = mailbox pointer
                        	;		t1 = message pointer
                        	;		s1 = task id of waiting task
                        	; Modifies:
                        	;		a0
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = message d1
                        	;		a3 = message d2
                        	;		a4 = message d3
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_SendMsg:
FFFC2448 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC244C FF870713		sub		$sp,$sp,#8
FFFC2450 00173023		sto		$ra,[$sp]
FFFC2454 1009BD13		sltu	$t0,$a1,#NR_MBX
FFFC2458 0E0D0863		beq		$t0,$x0,.badMbx
FFFC245C 00599D13		sll		$t0,$a1,#LOG_MBXSZ	; convert handle to pointer
FFFC2460 00020637		add		$t0,$t0,#mbxs
FFFC2464 00060613
FFFC2468 01A60D33
FFFC246C 008D3F83		ldo		$t5,MBX_WTIDS[$t0]
FFFC2470 060F8463		beq		$t5,$x0,.noWaiters	; no waiters = go queue message
FFFC2474 00006213		ldi		$s1,#0
                        	.0001:
FFFC2478 001FF313		and		$s3,$t5,#1					; is tid waiting?
FFFC247C 04030063		beq		$s3,$x0,.nxtTid
FFFC2480 00A21313		sll		$s3,$s1,#LOG_TCBSZ	; convert tid to TCB pointer
FFFC2484 29433C23		sto		$a2,TCBMsgD1[$s3]		; copy message to TCB
FFFC2488 2B533023		sto		$a3,TCBMsgD2[$s3]
FFFC248C 2B633423		sto		$a4,TCBMsgD3[$s3]
FFFC2490 28834E03		ldbu	$t2,TCBStatus[$s3]
FFFC2494 004E6E13		or		$t2,$t2,#TS_MSGRDY
FFFC2498 29C30423		stb		$t2,TCBStatus[$s3]
FFFC249C 00026933		mov		$a0,$s1
FFFC24A0 FF070713		sub		$sp,$sp,#16
FFFC24A4 00173023		sto		$ra,[$sp]
FFFC24A8 01A73423		sto		$t0,8[$sp]						; push t0
FFFC24AC 1F8000EF		call	InsertIntoReadyList
FFFC24B0 00073083		ldo		$ra,[$sp]
FFFC24B4 00873D03		ldo		$t0,8[$sp]						; pop t0
FFFC24B8 01070713		add		$sp,$sp,#16
                        	.nxtTid:
FFFC24BC 001FDF93		srl		$t5,$t5,#1					; check next task
FFFC24C0 00120213		add		$s1,$s1,#1
FFFC24C4 03F27213		and		$s1,$s1,#63
FFFC24C8 FA0218E3		bne		$s1,$x0,.0001
FFFC24CC 000D3423		sto		$x0,MBX_WTIDS[$t0]	; clear waiters
FFFC24D0 00006813		ldi		$v0,#E_Ok
FFFC24D4 06000C63		bra		.xit
                        	.noWaiters:
FFFC24D8 00024637		ldo		$t1,FreeMsg
FFFC24DC 35060613
FFFC24E0 00060633
FFFC24E4 00063D83
FFFC24E8 040D8C63		beq		$t1,$x0,.noMsg			; message available?
FFFC24EC 3000F073		csrrc	$x0,#$300,#1				; disable ints
FFFC24F0 000DBE03		ldo		$t2,MSG_LINK[$t1]
FFFC24F4 00024637		sto		$t2,FreeMsg
FFFC24F8 35060613
FFFC24FC 00060633
FFFC2500 01C63023
FFFC2504 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC2508 014DB423		sto		$a2,MSG_D1[$t1]
FFFC250C 015DB823		sto		$a3,MSG_D2[$t1]
FFFC2510 016DBC23		sto		$a4,MSG_D3[$t1]
FFFC2514 3000F073		csrrc	$x0,#$300,#1				; diable ints
FFFC2518 018D3E83		ldo		$t3,MBX_MQTAIL[$t0]
FFFC251C 000E8A63		beq		$t3,$x0,.mbxEmpty
FFFC2520 01BEB023		sto		$t1,MSG_LINK[$t3]
FFFC2524 01BD3C23		sto		$t1,MBX_MQTAIL[$t0]
FFFC2528 00006813		ldi		$v0,#E_Ok
FFFC252C 02000063		bra		.xit
                        	.mbxEmpty:
FFFC2530 01BD3823		sto		$t1,MBX_MQHEAD[$t0]
FFFC2534 01BD3C23		sto		$t1,MBX_MQTAIL[$t0]
FFFC2538 00006813		ldi		$v0,#E_Ok
FFFC253C 00000863		bra		.xit
                        	.noMsg:
FFFC2540 00B06813		ldi		$v0,#E_NoMsg
FFFC2544 00000463		bra		.xit
                        	.badMbx:
FFFC2548 00406813		ldi		$v0,#E_BadMbx				; return null pointer if bad mailbox
                        	.xit:
FFFC254C 00073083		ldo		$ra,[$sp]
FFFC2550 00870713		add		$sp,$sp,#8
FFFC2554 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; PeekMsg will check for a message at a mailbox optionally dequeuing it.
                        	; If no message is available PeekMsg returns to the caller with a E_NoMsg
                        	; status.
                        	;
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = pointer where to put message D1
                        	;		a3 = pointer where to put message D2
                        	;		a4 = pointer where to put message D3
                        	;		a5 = 1 = remove from queue
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_PeekMsg:
FFFC2558 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC255C FF870713		sub		$sp,$sp,#8
FFFC2560 00173023		sto		$ra,[$sp]
FFFC2564 FF870713		sub		$sp,$sp,#8
FFFC2568 00173023		sto		$ra,[$sp]
FFFC256C 0209AD13		slt		$t0,$a1,#32
FFFC2570 0A0D0063		beq		$t0,$x0,.badMbx
FFFC2574 00599E13		sll		$t2,$a1,#LOG_MBXSZ	; convert handle to pointer
FFFC2578 00020637		add		$t2,$t2,#mbxs
FFFC257C 00060613
FFFC2580 01C60E33
FFFC2584 3000F073		csrrc	$x0,#$300,#1				; disable ints
FFFC2588 010E3D83		ldo		$t1,MBX_MQHEAD[$t2]
FFFC258C 060D8E63		beq		$t1,$x0,.noMsg
FFFC2590 020B8863		beq		$a5,$x0,.nodq
FFFC2594 000DBE83		ldo		$t3,MSG_LINK[$t1]
FFFC2598 01DE3823		sto		$t3,MBX_MQHEAD[$t2]
                        		; This is done here only because interrupts are disabled
FFFC259C 00024637		ldo		$t3,FreeMsg
FFFC25A0 35060613
FFFC25A4 00060633
FFFC25A8 00063E83
FFFC25AC 01DDB023		sto		$t3,MSG_LINK[$t1]
FFFC25B0 00024637		sto		$t1,FreeMsg
FFFC25B4 35060613
FFFC25B8 00060633
FFFC25BC 01B63023
                        	.nodq:
FFFC25C0 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC25C4 000A0A63		beq		$a2,$x0,.nod1
FFFC25C8 000A6933		mov		$a0,$a2
FFFC25CC 989FE0EF		call	VirtToPhys
FFFC25D0 008DBE83		ldo		$t3,MSG_D1[$t1]
FFFC25D4 01D83023		sto		$t3,[$v0]
                        	.nod1:
FFFC25D8 000A8A63		beq		$a3,$x0,.nod2
FFFC25DC 000AE933		mov		$a0,$a3
FFFC25E0 975FE0EF		call	VirtToPhys
FFFC25E4 010DBE83		ldo		$t3,MSG_D2[$t1]
FFFC25E8 01D83023		sto		$t3,[$v0]
                        	.nod2:
FFFC25EC 000B0A63		beq		$a4,$x0,.nod3
FFFC25F0 000B6933		mov		$a0,$a4
FFFC25F4 961FE0EF		call	VirtToPhys
FFFC25F8 018DBE83		ldo		$t3,MSG_D3[$t1]
FFFC25FC 01D83023		sto		$t3,[$v0]
                        	.nod3:
FFFC2600 00006813		ldi		$v0,#E_Ok
FFFC2604 00000863		bra		.ret
                        	.noMsg:
FFFC2608 00B06813		ldi		$v0,#E_NoMsg
FFFC260C 00000463		bra		.ret
                        	.badMbx:
FFFC2610 00406813		ldi		$v0,#E_BadMbx				; return null pointer if bad mailbox
                        	.ret:
FFFC2614 00073083		ldo		$ra,[$sp]
FFFC2618 00870713		add		$sp,$sp,#8
FFFC261C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Calling WaitMsg will cause the task to be queued at the mailbox and a task
                        	; switch to occur if there are no messages at the mailbox.
                        	;
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = pointer where to put message D1
                        	;		a3 = pointer where to put message D2
                        	;		a4 = pointer where to put message D3
                        	;		a5 = time limit
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_WaitMsg:
FFFC2620 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC2624 FF870713		sub		$sp,$sp,#8
FFFC2628 00173023		sto		$ra,[$sp]
FFFC262C 000BE433		mov		$s5,$a5
FFFC2630 00106B93		ldi		$a5,#1
FFFC2634 F25FF0EF		call	FMTK_PeekMsg				; check for a message, return if available
FFFC2638 00B06D93		ldi		$t1,#E_NoMsg
FFFC263C 01B80463		beq		$v0,$t1,.qt					; no message? Then go queue task
FFFC2640 04000C63		bra		.xit
                        	.qt:
                        		
FFFC2644 18101873		csrrw	v0,#$181,x0
FFFC2648 00F87813		and		v0,v0,#15
FFFC264C 00106E13	ldi		$t2,#1
FFFC2650 010E1E33		sll		$t2,$t2,$v0
FFFC2654 00599E93		sll		$t3,$a1,#LOG_MBXSZ	; convert handle to pointer
FFFC2658 00020637		add		$t3,$t3,#mbxs
FFFC265C 00060613
FFFC2660 01D60EB3
FFFC2664 3000F073		csrrc	$x0,#$300,#1				; disable ints
FFFC2668 008EBF03		ldo		$t4,MBX_WTIDS[$t3]	; get waiting task list
FFFC266C 01CF6F33		or		$t4,$t4,$t2					; set bit for tid
FFFC2670 01EEB423		sto		$t4,MBX_WTIDS[$t3]	; save task list
FFFC2674 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC2678 00A81F13		sll		$t4,$v0,#LOG_TCBSZ	; convert tid to TCB pointer
FFFC267C 288F4E83		ldbu	$t3,TCBStatus[$t4]
FFFC2680 008EEE93		or		$t3,$t3,#TS_WAITMSG	; set waiting for message status
FFFC2684 FFEEFE93		and		$t3,$t3,#~TS_READY	; not ready
FFFC2688 29DF0423		stb		$t3,TCBStatus[$t4]
FFFC268C 293F0523		stb		$a1,TCBWaitMbx[$t4]	; set mailbox task is waiting for
FFFC2690 000BE9B3		mov		$a1,$a5
                        		; Continue by switching tasks
FFFC2694 8A5FF0EF		call		FMTK_Sleep
                        	.xit:
FFFC2698 00073083		ldo		$ra,[$sp]
FFFC269C 00870713		add		$sp,$sp,#8
FFFC26A0 00008067		ret
                        	
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/tcb.r5a",1
                        	.file "../fmtk/tcb.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../fmtk/tcb.r5a",25
                        		code
                        		align	4                        	
                        	;------------------------------------------------------------------------------
                        	; Insert task into ready list. The list is a doubly linked circular list.
                        	;
                        	; Parameters:
                        	;		a0 = tid to insert
                        	; Modifies:
                        	;		v1,t0,t1,t2
                        	; Returns:
                        	;		v0 = 1 for success, 0 if failed
                        	;------------------------------------------------------------------------------
                        	
                        	InsertIntoReadyList:
FFFC26A4 00006813		ldi		$v0,#E_Ok						; setup for ok
FFFC26A8 03F06893		ldi		$v1,#MAX_TID				; check argument
FFFC26AC 0928EA63		bgtu	$a0,$v1,.badTid
FFFC26B0 00A91E93		sll		$t3,$a0,#LOG_TCBSZ	; tid to pointer
FFFC26B4 288ECD03		ldbu	$t0,TCBStatus[$t3]	; set status to ready
FFFC26B8 001D6D13		or		$t0,$t0,#TS_READY
FFFC26BC 29AE8423		sb		$t0,TCBStatus[$t3]
FFFC26C0 289E8D03		ldb		$t0,TCBPriority[$t3]
FFFC26C4 19A9000D		insrdy	$a0,$t0
	ret
FFFC26C8 00008067
FFFC26CC 003D7D13		and		$t0,$t0,#3					; limit to four
FFFC26D0 001D1D13		sll		$t0,$t0,#1					; *2 for indexing
FFFC26D4 00024637		ldw		$t1,READYQ[$t0]			; get head of queue for that priority
FFFC26D8 30860613
FFFC26DC 01A60633
FFFC26E0 00061D83
FFFC26E4 020DD063		bge		$t1,$x0,.insert			; Is there a head?
                        		; level 0 insert - nothing in list, create a ring to self
FFFC26E8 00024637		stw		$a0,READYQ[$t0]			; no head, simple to insert
FFFC26EC 30860613
FFFC26F0 01A60633
FFFC26F4 01261023
FFFC26F8 2D2E9823		stw		$a0,TCBNext[$t3]		; remember it's a ring
FFFC26FC 2D2E9C23		stw		$a0,TCBPrev[$t3]
FFFC2700 00008067		ret
                        		; Insert at tail of list, which is just before the head.
                        	.insert:
FFFC2704 00AD9F13		sll		$t4,$t1,#LOG_TCBSZ	; tid to pointer
FFFC2708 2D8F1E03		ldw		$t2,TCBPrev[$t4]		; t2 = head->prev
FFFC270C 01BE1C63		bne		$t2,$t1,.level2
                        		;level 1 insert - only 1 item currently in list, items point to each other
                        		; This bit probably redundant code as normal insertion should work as well.
FFFC2710 2D2F1C23		stw		$a0,TCBPrev[$t4]		; simple to insert
FFFC2714 2D2F1823		stw		$a0,TCBNext[$t4]		; head->prev = head->next = arg
FFFC2718 2DBE9C23		stw		$t1,TCBPrev[$t3]		; arg->prev = arg->next = head
FFFC271C 2DBE9823		stw		$t1,TCBNext[$t3]
FFFC2720 00008067		ret
                        		; Here there will be three or more entries in the list. Arg is inserted
                        		; between head and head->prev to make it the last on the list.
                        	.level2:
FFFC2724 2DCE9C23		stw		$t2,TCBPrev[$t3]		; arg->prev = head->prev
FFFC2728 2DBE9823		stw		$t1,TCBNext[$t3]		; arg->next = head, arg links are now set
                        		; If there's a head there should be a head->prev and head->next at least pointing to the head
FFFC272C 000E4663		bltz	$t2,.0001						; head->prev valid?
FFFC2730 00AE1E93		sll		$t3,$t2,#LOG_TCBSZ	; t3 = head->prev (as a pointer)
FFFC2734 2D2E9823		stw		$a0,TCBNext[$t3]		; head->prev->next = arg
                        	.0001:
FFFC2738 2D2F1C23		stw		$a0,TCBPrev[$t4]		; head->prev = arg
FFFC273C 00008067		ret
                        	.badTid:
FFFC2740 00106813		ldi		$v0,#E_Arg
FFFC2744 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; The ready list is a doubly linked list to make it easier and faster to
                        	; remove items from the list. There's no need to search the list for the item
                        	; to remove.
                        	;
                        	; Parameters:
                        	;		a0 = tid to remove
                        	; Modifies:
                        	;		t0,t1,t2,t3,t4,t5
                        	; Returns:
                        	;		v0 = E_Ok for success
                        	;------------------------------------------------------------------------------
                        	
                        	RemoveFromReadyList:
FFFC2748 03F06893		ldi		$v1,#MAX_TID					; check arg
FFFC274C 0128F863		bleu	$a0,$v1,.tidOk
FFFC2750 00106813		ldi		$v0,#E_Arg
FFFC2754 00000637		jmp		ERETx
FFFC2758 1FE60067
                        	.tidOk:
FFFC275C 1A09000D		rmvrdy	$a0									; cheat and use hardware
FFFC2760 00A91F13		sll		$t4,$a0,#LOG_TCBSZ		; s1 = pointer to tcb
FFFC2764 288F0D03		ldb		$t0,TCBStatus[$t4]		; set status no longer ready or running
FFFC2768 F7ED7D13		and		$t0,$t0,#~(TS_READY|TS_RUNNING)
	stb		$t0,TCBStatus[$t4]
FFFC276C 29AF0423
FFFC2770 00008067		ret
                        	
                        	RemoveFromReadyList2:
FFFC2774 03F06893		ldi		$v1,#MAX_TID					; check arg
FFFC2778 0928E063		bgtu	$a0,$v1,.badTid
FFFC277C 00A91F13		sll		$t4,$a0,#LOG_TCBSZ		; s1 = pointer to tcb
FFFC2780 288F0D03		ldb		$t0,TCBStatus[$t4]		; set status no longer ready or running
FFFC2784 F7ED7D13		and		$t0,$t0,#~(TS_READY|TS_RUNNING)
	stb		$t0,TCBStatus[$t4]
FFFC2788 29AF0423
FFFC278C 289F0D03		ldb		$t0,TCBPriority[$t4]	; t0 = priority
FFFC2790 003D7D13		and		$t0,$t0,#3						; limit to 0-3
FFFC2794 001D1D13		sll		$t0,$t0,#1						; *2 for indexing
FFFC2798 00024637		ldw		$t1,READYQ[$t0]				; get head tid
FFFC279C 30860613
FFFC27A0 01A60633
FFFC27A4 00061D83
FFFC27A8 2D0F1E03		ldw		$t2,TCBNext[$t4]			; get arg->next
FFFC27AC 012D9E63		bne		$t1,$a0,.0001					; removing head of list?
FFFC27B0 012E1463		bne		$t2,$a0,.0003					; list emptying? (if arg->next points back to arg)
FFFC27B4 FFF06E13		ldi		$t2,#-1
                        	.0003:
FFFC27B8 00024637		stw		$t2,READYQ[$t0]				; yes, set new head to arg->next
FFFC27BC 30860613
FFFC27C0 01A60633
FFFC27C4 01C61023
                        	.0001:
FFFC27C8 000E4E63		bltz	$t2,.0002							; validate t2 (arg->next)
FFFC27CC 011E7C63		bgeu	$t2,$v1,.0002					; there should always be an arg->next, arg->prev
FFFC27D0 2D8F1E83		ldw		$t3,TCBPrev[$t4]			; because the list is circular t3=arg->prev
FFFC27D4 00AE9F93		sll		$t5,$t3,#LOG_TCBSZ		; t5 = arg->prev as a pointer
FFFC27D8 2DCF9823		stw		$t2,TCBNext[$t5]			; arg->prev->next = arg->next
FFFC27DC 00AE1F93		sll		$t5,$t2,#LOG_TCBSZ		; t5 = arg->next as a pointer
FFFC27E0 2DDF9C23		stw		$t3,TCBPrev[$t5]			; arg->next->prev = arg->prev
                        		; Now indicate links in TCB are not in use.
                        	.0002:
FFFC27E4 FFF06813		ldi		$v0,#-1
FFFC27E8 2D0F1823		stw		$v0,TCBNext[$t4]
FFFC27EC 2D0F1C23		stw		$v0,TCBPrev[$t4]
FFFC27F0 00006813		ldi		$v0,#E_Ok							; we're ok
FFFC27F4 00008067		ret
                        	.badTid:
FFFC27F8 00106813		ldi		$v0,#E_Arg
FFFC27FC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = task id to insert
                        	;		a1 = timeout value
                        	; Modifies:
                        	;		t0,t1,t2,t3,t4,t5
                        	;------------------------------------------------------------------------------
                        	
                        	InsertIntoTimeoutList:
FFFC2800 1139000D		setto	$a0,$a1
	sll		$t5,$a0,#LOG_TCBSZ		; tid to pointer
FFFC2804 00A91F93
FFFC2808 288FCE03		ldbu	$t2,TCBStatus[$t5]		; set status to timing out
FFFC280C 010E6E13		or		$t2,$t2,#TS_TIMEOUT
FFFC2810 29CF8423		stb		$t2,TCBStatus[$t5]
FFFC2814 00006813		ldi		$v0,#E_Ok
FFFC2818 00008067		ret
FFFC281C FFF06D13		ldi		$t0,#-1						
FFFC2820 2DAF9823		stw		$t0,TCBNext[$t5]			; initialize indexes to -1
FFFC2824 2DAF9C23		stw		$t0,TCBPrev[$t5]
FFFC2828 00024637		ldw		$t0,TimeoutList
FFFC282C 32860613
FFFC2830 00060633
FFFC2834 00061D03
FFFC2838 020D5063		bge		$t0,$x0,.0001
                        		; Here the timeout list was empty, easy to insert.
FFFC283C 2F3FA023		stt		$a1,TCBTimeout[$t5]		; set timeout for task
FFFC2840 00024637		stw		$a0,TimeoutList				; set head of list
FFFC2844 32860613
FFFC2848 00060633
FFFC284C 01261023
FFFC2850 00006813		ldi		$v0,#E_Ok							; and return
FFFC2854 00008067		ret
                        	.0001:
FFFC2858 FFF06D93		ldi		$t1,#-1								; t1 used as previous index
FFFC285C 000D6E33		mov		$t2,$t0								; t2 = head of timeout list index
FFFC2860 00AE1E93		sll		$t3,$t2,#LOG_TCBSZ		; t3 = head of timeout list as a pointer
                        		; Search the timeout list for the proper insertion point. The timeouts are
                        		; relative, so the requested amount is decremented by the amounts in the
                        		; list as it is searched.
                        	.beginWhile:
FFFC2864 2E0EAF03		ldt		$t4,TCBTimeout[$t3]		; get the timeout
FFFC2868 033F5663		ble		$a1,$t4,.endWhile			; is it greater than the requested timeout ?
FFFC286C 41E989B3		sub		$a1,$a1,$t4						; decrement by list amount
FFFC2870 000EEDB3		mov		$t1,$t3								; t1 = pointer to previous entry
FFFC2874 2D0E9E83		ldw		$t3,TCBNext[$t3]			; get the next entry in list
FFFC2878 000EC663		bltz	$t3,.endOfList					; end of list?
FFFC287C 00AE9E93		sll		$t3,$t3,#LOG_TCBSZ		; no, set pointer to current entry
FFFC2880 FFBE92E3		bne		$t3,$t1,.beginWhile		; list screwed up? (This test should always be true)
                        	.endOfList:
                        		; Here the end of the list was reached, insert as last entry
FFFC2884 2D2D9823		stw		$a0,TCBNext[$t1]			; entry->next = arg
FFFC2888 2DBF9C23		stw		$t1,TCBPrev[$t5]			; arg->prev = entry
FFFC288C 2F3FA023		stt		$a1,TCBTimeout[$t5]
FFFC2890 04000063		bra		.0003
                        	.endWhile:
                        		; Here we found a timeout greater than the requested amount. Insert before.
FFFC2894 20AEDE13		sra		$t2,$t3,#LOG_TCBSZ		; pointer to tid
FFFC2898 2DCF9823		stw		$t2,TCBNext[$t5]			; arg->next = entry
FFFC289C 20ADDE13		sra		$t2,$t1,#LOG_TCBSZ
FFFC28A0 2DCF9C23		stw		$t2,TCBPrev[$t5]			; arg->prev = prev entry
FFFC28A4 2E0EAE03		ldt		$t2,TCBTimeout[$t3]		; update timeout of entry by subtracting off
FFFC28A8 413E0E33		sub		$t2,$t2,$a1						; the arg's timeout
FFFC28AC 2FCEA023		stt		$t2,TCBTimeout[$t3]
FFFC28B0 2D2E9C23		stw		$a0,TCBPrev[$t3]			; entry->prev = arg
FFFC28B4 000DC663		bltz	$t1,.0002							; previous entry? no - go update list head
FFFC28B8 2D2D9823		stw		$a0,TCBNext[$t1]			; prev entry->next = arg
FFFC28BC 00000A63		bra		.0003
                        	.0002:
FFFC28C0 00024637		stw		$a0,TimeoutList				; list head = arg
FFFC28C4 32860613
FFFC28C8 00060633
FFFC28CC 01261023
                        	.0003:
FFFC28D0 288FCE03		ldbu	$t2,TCBStatus[$t5]		; set status to timing out
FFFC28D4 010E6E13		or		$t2,$t2,#TS_TIMEOUT
FFFC28D8 29CF8423		stb		$t2,TCBStatus[$t5]
FFFC28DC 00006813		ldi		$v0,#E_Ok
FFFC28E0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Remove a task from the timeout list. The timeouts of following tasks are
                        	; adjusted. Called when a mailbox is freed and a task is waiting at the
                        	; mailbox. From within scheduling code mPopTimeoutList is used instead.
                        	;
                        	; Parameters:
                        	;		a0 = task id to remove
                        	; Modifies:
                        	;		t0,t3,t4
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	RemoveFromTimeoutList:
FFFC28E4 00A91E93		sll		$t3,$a0,#LOG_TCBSZ		; tid to pointer
FFFC28E8 288ECD03		ldbu	$t0,TCBStatus[$t3]		; check if waiting at a mailbox
FFFC28EC 008D7D13		and		$t0,$t0,#TS_WAITMSG
FFFC28F0 000D0463		beqz	$t0,.noWait				
FFFC28F4 9F5FF0EF		call	MbxRemoveTask					; remove task from mailbox
                        	.noWait:
FFFC28F8 FE7D7D13		and		$t0,$t0,#~(TS_TIMEOUT|TS_WAITMSG)
	stb		$t0,TCBStatus[$t3]
FFFC28FC 29AE8423
FFFC2900 1009000D		setto	$a0,$x0
	ldi		$v0,#E_Ok
FFFC2904 00006813
FFFC2908 00008067		ret
                        	
FFFC290C 00024637		ldw		$t1,TimeoutList
FFFC2910 32860613
FFFC2914 00060633
FFFC2918 00061D83
FFFC291C 2D0E9D03		ldw		$t0,TCBNext[$t3]			; t0 = arg->next
FFFC2920 01B91A63		bne		$a0,$t1,.0001					; check removing head of list
FFFC2924 00024637		stw		$t0,TimeoutList				; set new head = arg->next
FFFC2928 32860613
FFFC292C 00060633
FFFC2930 01A61023
                        	.0001:
FFFC2934 020D4063		bltz	$t0,.noNext
FFFC2938 00AD1F13		sll		$t4,$t0,#LOG_TCBSZ
FFFC293C 2D8E9D83		ldw		$t1,TCBPrev[$t3]			; next->prev = arg->prev
FFFC2940 2DBF1C23		stw		$t1,TCBPrev[$t4]			
FFFC2944 2E0F2D83		ldt		$t1,TCBTimeout[$t4]		; next->timeout += arg->timeout
FFFC2948 2E0EAE03		ldt		$t2,TCBTimeout[$t3]
FFFC294C 01CD8DB3		add		$t1,$t1,$t2
FFFC2950 2FBF2023		stt		$t1,TCBTimeout[$t4]
                        	.noNext:
FFFC2954 2D8E9D03		ldw		$t0,TCBPrev[$t3]			; check for previous
FFFC2958 000D4863		bltz	$t0,.noPrev
FFFC295C 00AD1F13		sll		$t4,$t0,#LOG_TCBSZ
FFFC2960 2D0E9D03		ldw		$t0,TCBNext[$t3]			; prev->next = arg->next
FFFC2964 2DAF1823		stw		$t0,TCBNext[$t4]
                        	.noPrev:
FFFC2968 288E8D03		ldb		$t0,TCBStatus[$t3]		; no longer timing out
FFFC296C FE7D7D13		and		$t0,$t0,#~(TS_TIMEOUT|TS_WAITMSG)
	stb		$t0,TCBStatus[$t3]
FFFC2970 29AE8423
FFFC2974 FFF06D13		ldi		$t0,#-1								; reset links
FFFC2978 2DAE9823		stw		$t0,TCBNext[$t3]
FFFC297C 2DAE9C23		stw		$t0,TCBPrev[$t3]
FFFC2980 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Returns:
                        	;		v1 = process id
                        	;------------------------------------------------------------------------------
                        	
                        	AllocTCB:
FFFC2984 00006D93		ldi		$t1,#0
FFFC2988 00024637		ldwu	$v1,PIDMAP
FFFC298C 31060613
FFFC2990 00060633
FFFC2994 00065883
                        	.0001:
FFFC2998 0018FD13		and		$t0,$v1,#1
FFFC299C 020D0463		beqz	$t0,.allocTid
FFFC29A0 0018D893		srl		$v1,$v1,#1
FFFC29A4 00008637		or		$v1,$v1,#$8000
FFFC29A8 00060613
FFFC29AC 011668B3
FFFC29B0 001D8D93		add		$t1,$t1,#1
FFFC29B4 00FDFD93		and		$t1,$t1,#15
FFFC29B8 FE0D90E3		bne		$t1,$x0,.0001
                        	; here no tcbs available
FFFC29BC 04506813		ldi		$v0,#E_NoMoreTCBs
FFFC29C0 00008067		ret
                        	.allocTid:
FFFC29C4 000DE833		mov		$v0,$t1
FFFC29C8 0018E893		or		$v1,$v1,#1
FFFC29CC 000D8A63		beqz	$t1,.0003
                        	.0002:
FFFC29D0 00189893		sll		$v1,$v1,#1
FFFC29D4 0018E893		or		$v1,$v1,#1
FFFC29D8 FFFD8D93		sub		$t1,$t1,#1
FFFC29DC FE0D9AE3		bnez	$t1,.0002
                        	.0003:
FFFC29E0 00024637		stw		$v1,PIDMAP
FFFC29E4 31060613
FFFC29E8 00060633
FFFC29EC 01161023
FFFC29F0 000868B3		mov		$v1,$v0
FFFC29F4 00006813		ldi		$v0,#E_Ok
FFFC29F8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FreeTCB:
FFFC29FC 00106D13		ldi		$t0,#1
FFFC2A00 012D1D33		sll		$t0,$t0,$a0
FFFC2A04 FFFD4D13		xor		$t0,$t0,#-1
FFFC2A08 00024637		lhu		$t1,PIDMAP
FFFC2A0C 31060613
FFFC2A10 00060633
FFFC2A14 00065D83
FFFC2A18 01ADFDB3		and		$t1,$t1,$t0
FFFC2A1C 00024637		stw		$t1,PIDMAP
FFFC2A20 31060613
FFFC2A24 00060633
FFFC2A28 01B61023
FFFC2A2C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Diagnostics
                        	;------------------------------------------------------------------------------
                        	
                        	DumpReadyList:
FFFC2A30 FE070713		sub		$sp,$sp,#32
FFFC2A34 00172023		stt		$ra,[$sp]
FFFC2A38 01272223		stt		$a0,4[$sp]
FFFC2A3C 01472423		stt		$a2,8[$sp]
FFFC2A40 01572623		stt		$a3,12[$sp]
FFFC2A44 01B72823		stt		$t1,16[$sp]
FFFC2A48 01C72A23		stt		$t2,20[$sp]
FFFC2A4C 01D72C23		stt		$t3,24[$sp]
FFFC2A50 00472E23		stt		$s1,28[$sp]
FFFC2A54 FFFC3937		ldi		$a0,#msgReadyList
FFFC2A58 BC090913
FFFC2A5C D21FD0EF		call	PutString
FFFC2A60 00006D93		ldi		$t1,#0
FFFC2A64 3000F273		csrrc	$s1,#$300,#1
                        	.0002:
FFFC2A68 8ADFE0EF		call	SerialPeekCharDirect
FFFC2A6C 00384813		xor		$v0,$v0,#CTRLC
FFFC2A70 08080263		beqz	$v0,.brk
FFFC2A74 00D06913		ldi		$a0,#CR
FFFC2A78 FBCFD0EF		call	Putch
FFFC2A7C 05106913		ldi		$a0,#'Q'
FFFC2A80 FB4FD0EF		call	Putch
FFFC2A84 001DD913		srl		$a0,$t1,#1
FFFC2A88 CB5FD0EF		call	PutHexNybble
FFFC2A8C 03A06913		ldi		$a0,#':'
FFFC2A90 FA4FD0EF		call	Putch
FFFC2A94 00024637		ldw		$a2,READYQ[$t1]
FFFC2A98 30860613
FFFC2A9C 01B60633
FFFC2AA0 00061A03
FFFC2AA4 040A4263		blt		$a2,$x0,.nxt
FFFC2AA8 000A6AB3		mov		$a3,$a2
                        	.0001:
FFFC2AAC 000AE933		mov		$a0,$a3
FFFC2AB0 C4DFD0EF		call	PutHexHalf
FFFC2AB4 02006913		ldi		$a0,#' '
FFFC2AB8 F7CFD0EF		call	Putch
FFFC2ABC 00AA9A93		sll		$a3,$a3,#LOG_TCBSZ
FFFC2AC0 2D0A9903		ldw		$a0,TCBNext[$a3]
FFFC2AC4 C39FD0EF		call	PutHexHalf
FFFC2AC8 02006913		ldi		$a0,#' '
FFFC2ACC F68FD0EF		call	Putch
FFFC2AD0 2D8A9903		ldw		$a0,TCBPrev[$a3]
FFFC2AD4 C29FD0EF		call	PutHexHalf
FFFC2AD8 00D06913		ldi		$a0,#CR
FFFC2ADC F58FD0EF		call	Putch
FFFC2AE0 2D0A9A83		ldw		$a3,TCBNext[$a3]
FFFC2AE4 FD5A14E3		bne		$a2,$a3,.0001
                        	.nxt:
FFFC2AE8 002D8D93		add		$t1,$t1,#2
FFFC2AEC 008DAE13		slt		$t2,$t1,#8
FFFC2AF0 F60E1CE3		bnez	$t2,.0002
                        	.brk:
FFFC2AF4 30021073		csrrw	$x0,#$300,$s1
FFFC2AF8 00072083		ldt		$ra,[$sp]
FFFC2AFC 00472903		ldt		$a0,4[$sp]
FFFC2B00 00872A03		ldt		$a2,8[$sp]
FFFC2B04 00C72A83		ldt		$a3,12[$sp]
FFFC2B08 01072D83		ldt		$t1,16[$sp]
FFFC2B0C 01472E03		ldt		$t2,20[$sp]
FFFC2B10 01872E83		ldt		$t3,24[$sp]
FFFC2B14 01C72203		ldt		$s1,28[$sp]
FFFC2B18 02070713		add		$sp,$sp,#32
FFFC2B1C 00008067		ret
                        	
                        	DumpTimeoutList:
FFFC2B20 FE070713		sub		$sp,$sp,#32
FFFC2B24 00172023		stt		$ra,[$sp]
FFFC2B28 01272223		stt		$a0,4[$sp]
FFFC2B2C 01472423		stt		$a2,8[$sp]
FFFC2B30 01572623		stt		$a3,12[$sp]
FFFC2B34 01B72823		stt		$t1,16[$sp]
FFFC2B38 01C72A23		stt		$t2,20[$sp]
FFFC2B3C 01D72C23		stt		$t3,24[$sp]
FFFC2B40 00472E23		stt		$s1,28[$sp]
FFFC2B44 FFFC3937		ldi		$a0,#msgTimeoutList
FFFC2B48 BF190913
FFFC2B4C C31FD0EF		call	PutString
FFFC2B50 00006D93		ldi		$t1,#0
FFFC2B54 3000F273		csrrc	$s1,#$300,#1
FFFC2B58 00006A93		ldi		$a3,#0
                        	.0002:
FFFC2B5C FB8FE0EF		call	SerialPeekCharDirect
FFFC2B60 00384813		xor		$v0,$v0,#CTRLC
FFFC2B64 02080863		beqz	$v0,.brk
FFFC2B68 00D06913		ldi		$a0,#CR
FFFC2B6C EC8FD0EF		call	Putch
                        	;	ldw		$a2,TimeoutList
                        	;	bltz	$a2,.brk
                        	;	mov		$a3,$a2
                        	;.0001:
FFFC2B70 000AE933		mov		$a0,$a3
FFFC2B74 B89FD0EF		call	PutHexHalf
FFFC2B78 02D06913		ldi		$a0,#'-'
FFFC2B7C EB8FD0EF		call	Putch
FFFC2B80 120D890D		getto	$a0,$t1
;	sll		$a3,$a3,#LOG_TCBSZ
                        	;	ldt		$a0,TCBTimeout[$a3]
FFFC2B84 B59FD0EF		call	PutHexWord
                        	;	ldi		$a0,#CR
                        	;	call	Putch
FFFC2B88 001A8A93		add		$a3,$a3,#1
FFFC2B8C 00FAFA93		and		$a3,$a3,#15
FFFC2B90 FD5046E3		bgt		$a3,$x0,.0002
                        	;	ldw		$a3,TCBNext[$a3]
                        	;	bge		$a3,$x0,.0001
                        	.brk:
FFFC2B94 30021073		csrrw	$x0,#$300,$s1
FFFC2B98 00072083		ldt		$ra,[$sp]
FFFC2B9C 00472903		ldt		$a0,4[$sp]
FFFC2BA0 00872A03		ldt		$a2,8[$sp]
FFFC2BA4 00C72A83		ldt		$a3,12[$sp]
FFFC2BA8 01072D83		ldt		$t1,16[$sp]
FFFC2BAC 01472E03		ldt		$t2,20[$sp]
FFFC2BB0 01872E83		ldt		$t3,24[$sp]
FFFC2BB4 01C72203		ldt		$s1,28[$sp]
FFFC2BB8 02070713		add		$sp,$sp,#32
FFFC2BBC 00008067		ret
                        	
                        	msgReadyList:
FFFC2BC0 6165520D		db	CR,"Ready List",CR
FFFC2BC4 4C207964
FFFC2BC8 0D747369
FFFC2BCC 20657551		db	"Que Tid  Prv  Nxt",CR
FFFC2BD0 20646954
FFFC2BD4 76725020
FFFC2BD8 784E2020
FFFC2BDC 2D2D0D74
FFFC2BDE 2D2D2D2D		db	"-----------------",CR,0
FFFC2BE2 2D2D2D2D
FFFC2BE6 2D2D2D2D
FFFC2BEA 2D2D2D2D
FFFC2BEE 0D000D2D
                        	
                        	msgTimeoutList:
FFFC2BF1 6D69540D		db	CR,"Timeout List",CR
FFFC2BF5 74756F65
FFFC2BF9 73694C20
FFFC2BFD 54200D74
FFFC2BFF 64695420		db	" Tid - Timeout",CR
FFFC2C03 54202D20
FFFC2C07 6F656D69
FFFC2C0B 2D0D7475
FFFC2C0E 2D2D2D2D		db	"--------------",CR,0
FFFC2C12 2D2D2D2D
FFFC2C16 2D2D2D2D
FFFC2C1A 000D2D2D
                        	
FFFC2C1E E0730000		align 
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/iofocus.r5a",1
                        	.file "../fmtk/iofocus.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;-----------------------------------------------------------------------------
                        	; IO Focus routines complicated by the fact that the base address of TCB
                        	; zero is zero (looks like a null pointer but isn't). So the value -1 is 
                        	; used to indicate no focus index.
                        	;-----------------------------------------------------------------------------
                        	
                        	.file "../fmtk/iofocus.r5a",31
                        		code
                        		align	4                        	
                        	
                        	;-----------------------------------------------------------------------------
                        	; Determine if the currently running task has the I/O focus.
                        	;
                        	; Stack Space:
                        	;		2 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		v0 = E_Ok
                        	;		v1 = 1 if task has IO focus, 0 otherwise
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_HasIOFocus:
                        		; Enable interrupts
FFFC2C20 3000E073		csrrs	$x0,#$300,#1				
FFFC2C24 00025637		ldb		$v0,SwitchIOFocus
FFFC2C28 82060613
FFFC2C2C 00060633
FFFC2C30 00060803
FFFC2C34 00080C63		beqz	$v0,.noSwitch
FFFC2C38 00025637		stb		$x0,SwitchIOFocus
FFFC2C3C 82060613
FFFC2C40 00060633
FFFC2C44 00060023
FFFC2C48 038000EF		call	FMTK_SwitchIOFocus
                        	.noSwitch:
                        		
FFFC2C4C 18101873		csrrw	v0,#$181,x0
FFFC2C50 00F87813		and		v0,v0,#15
FFFC2C54 00A81813	sll		$v0,$v0,#LOG_TCBSZ
FFFC2C58 00025637		ldt		$v1,IOFocusNdx
FFFC2C5C 81060613
FFFC2C60 00060633
FFFC2C64 00062883
FFFC2C68 01180663		beq		$v0,$v1,.hasFocus
FFFC2C6C 00006893		ldi		$v1,#0
FFFC2C70 00000463		bra		.xit
                        	.hasFocus:
FFFC2C74 00106893		ldi		$v1,#1
                        	.xit:
FFFC2C78 00006813		ldi		$v0,#E_Ok
FFFC2C7C 00008067		ret
                        	
                        	;-----------------------------------------------------------------------------
                        	; First check if it's even possible to switch the focus to another
                        	; task. The I/O focus list could be empty or there may be only a
                        	; single task in the list. In either case it's not possible to
                        	; switch.
                        	;
                        	;	Parameters:
                        	;		none
                        	;	Modifies:
                        	;		none
                        	;	Returns:
                        	;		v0 = E_Ok
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_SwitchIOFocus:
FFFC2C80 3000E073		csrrs	$x0,#$300,#1				; enable interrupts
FFFC2C84 00025637		ldt		$t0,IOFocusNdx			; get focus pointer
FFFC2C88 81060613
FFFC2C8C 00060633
FFFC2C90 00062D03
FFFC2C94 080D4063		bltz	$t0,.noFocus				; is it -1?
FFFC2C98 2E8D2D83		ldt		$t1,IOF_NEXT[$t0]
FFFC2C9C 07AD8C63		beq		$t1,$t0,.sameFocus
FFFC2CA0 060DCA63		bltz	$t1,.noFocus
                        		; swap virtual text screens
FFFC2CA4 65806213		ldi		$s1,#56*29
FFFC2CA8 330D3E03		ldo		$t2,TCBVideoMem[$t0]
FFFC2CAC 020E0463		beqz	$t2,.0002
FFFC2CB0 33CD3C23		sto		$t2,TCBpVideo[$t0]
FFFC2CB4 FFD00EB7		ldi		$t3,#$FFD00000
FFFC2CB8 000E8E93
                        	.0001:
FFFC2CBC 000EBF03		ldo		$t4,[$t3]
FFFC2CC0 01EE3023		sto		$t4,[$t2]
FFFC2CC4 008E8E93		add		$t3,$t3,#8
FFFC2CC8 008E0E13		add		$t2,$t2,#8
FFFC2CCC FFF20213		sub		$s1,$s1,#1
FFFC2CD0 FE4046E3		bgt		$s1,$x0,.0001
                        	.0002:
FFFC2CD4 65806213		ldi		$s1,#56*29
FFFC2CD8 330DBE03		ldo		$t2,TCBVideoMem[$t1]
FFFC2CDC 020E0463		beqz	$t2,.0004
FFFC2CE0 FFD00EB7		ldi		$t3,#$FFD00000
FFFC2CE4 000E8E93
FFFC2CE8 33DDBC23		sto		$t3,TCBpVideo[$t1]
                        	.0003:
FFFC2CEC 000E3F03		ldo		$t4,[$t2]
FFFC2CF0 01EEB023		sto		$t4,[$t3]
FFFC2CF4 008E8E93		add		$t3,$t3,#8
FFFC2CF8 008E0E13		add		$t2,$t2,#8
FFFC2CFC FFF20213		sub		$s1,$s1,#1
FFFC2D00 FE4046E3		bgt		$s1,$x0,.0003
                        	.0004:
FFFC2D04 00025637		stt		$t1,IOFocusNdx
FFFC2D08 81060613
FFFC2D0C 00060633
FFFC2D10 01B62023
                        	.sameFocus:
                        	.noFocus:
FFFC2D14 00006813		ldi		$v0,E_Ok
FFFC2D18 00008067		ret
                        	
                        	;-----------------------------------------------------------------------------
                        	; The I/O focus list is an array indicating which jobs are requesting the
                        	; I/O focus. The I/O focus is user controlled by pressing CNTRL-T on the
                        	; keyboard.
                        	;
                        	; Parameters:
                        	;		a1 = task id requesting focus for
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_RequestIOFocus:
FFFC2D1C 00106D13		ldi		$t0,#1
FFFC2D20 013D1D33		sll		$t0,$t0,$a1
FFFC2D24 00025637		ldo		$t1,IOFocusTbl			; Is the task already included in the IO focus?
FFFC2D28 81860613
FFFC2D2C 00060633
FFFC2D30 00063D83
FFFC2D34 01ADFE33		and		$t2,$t1,$t0					; test bit
FFFC2D38 060E1463		bnez	$t2,.ret						; If so, don't add again
FFFC2D3C 01ADEDB3		or		$t1,$t1,$t0					; set bit indicator
FFFC2D40 00025637		sto		$t1,IOFocusTbl
FFFC2D44 81860613
FFFC2D48 00060633
FFFC2D4C 01B63023
                        		; Disable interrupts while manipulating IO focus list
FFFC2D50 3000F073		csrrc	$x0,#$300,#1				
FFFC2D54 00025637		ldo		$t0,IOFocusNdx			; get current index
FFFC2D58 81060613
FFFC2D5C 00060633
FFFC2D60 00063D03
FFFC2D64 00A99D93		sll		$t1,$a1,#LOG_TCBSZ	; t1 = pointer to TCB
FFFC2D68 020D5063		bge		$t0,$x0,.notEmpty		; is there one? (!= -1)
FFFC2D6C 00025637		sto		$t1,IOFocusNdx			; no current index, so set equal to requester
FFFC2D70 81060613
FFFC2D74 00060633
FFFC2D78 01B63023
FFFC2D7C 2FBDB423		sto		$t1,IOF_NEXT[$t1]		; and loop back to self
FFFC2D80 2FBDB823		sto		$t1,IOF_PREV[$t1]
FFFC2D84 00000E63		bra		.ret
                        	.notEmpty:
FFFC2D88 2F0D3E03		ldo		$t2,IOF_PREV[$t0]		; insert t1 into focus ring
FFFC2D8C 2FCDB823		sto		$t2,IOF_PREV[$t1]
FFFC2D90 2FADB423		sto		$t0,IOF_NEXT[$t1]
FFFC2D94 2F0D3E03		ldo		$t2,IOF_PREV[$t0]
FFFC2D98 2FBE3423		sto		$t1,IOF_NEXT[$t2]
FFFC2D9C 2FBD3823		sto		$t1,IOF_PREV[$t0]
                        	.ret:
FFFC2DA0 00006813		ldi		$v0,#E_Ok
FFFC2DA4 00008067		ret
                        	
                        	;-----------------------------------------------------------------------------
                        	; ReleaseIOFocus called when the task no longer desires to be on the I/O
                        	; focus list.
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_ReleaseIOFocus:
                        		
FFFC2DA8 18101873		csrrw	v0,#$181,x0
FFFC2DAC 00F87813		and		v0,v0,#15
FFFC2DB0 000869B3	mov		a1,v0
                        		; fall into ForceReleaseIOFocus
                        	
                        	;-----------------------------------------------------------------------------
                        	; Releasing the I/O focus causes the focus to switch if the running job
                        	; had the I/O focus.
                        	; ForceReleaseIOFocus forces the release of the IO focus for a job
                        	; different than the one currently running.
                        	; 
                        	; Stack Space:
                        	;		2 words
                        	; Parameters:
                        	;		a1 = task id to release
                        	; Returns:
                        	;		v0 = E_Ok
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_ForceReleaseIOFocus:
FFFC2DB4 3000E073		csrrs	$x0,#$300,#1				; enable interrupts
FFFC2DB8 00106D13		ldi		$t0,#1
FFFC2DBC 013D1D33		sll		$t0,$t0,$a1
FFFC2DC0 00025637		ldt		$t1,IOFocusTbl
FFFC2DC4 81860613
FFFC2DC8 00060633
FFFC2DCC 00062D83
FFFC2DD0 01ADFE33		and		$t2,$t1,$t0				; test bit for task
FFFC2DD4 080E0863		beq		$t2,$x0,.noFocus	; does it even have the focus?
FFFC2DD8 FFFD4D13		xor		$t0,$t0,#-1				; get inverted mask
FFFC2DDC 01ADFDB3		and		$t1,$t1,$t0				; clear bit for task
FFFC2DE0 00025637		stt		$t1,IOFocusTbl
FFFC2DE4 81860613
FFFC2DE8 00060633
FFFC2DEC 01B62023
FFFC2DF0 00025637		ldt		$t1,IOFocusNdx		; check if the focus being released is the current
FFFC2DF4 81060613
FFFC2DF8 00060633
FFFC2DFC 00062D83
FFFC2E00 00A99D13		sll		$t0,$a1,#LOG_TCBSZ	; io focus. If so, switch focus
FFFC2E04 03BD1063		bne		$t0,$t1,.notSame
FFFC2E08 FF870713		sub		$sp,$sp,#8
FFFC2E0C 01A72023		stt		$t0,[$sp]
FFFC2E10 01B72223		stt		$t1,4[$sp]
FFFC2E14 E6DFF0EF		call	FMTK_SwitchIOFocus
FFFC2E18 00072D03		ldt		$t0,[$sp]
FFFC2E1C 00472D83		ldt		$t1,4[$sp]
FFFC2E20 00870713		add		$sp,$sp,#8
                        	.notSame:
                        		; Disable interrupts while manipulating IO focus list
FFFC2E24 3000F073		csrrc	$x0,#$300,#1				
FFFC2E28 2E8D2E03		ldt		$t2,IOF_NEXT[$t0]
FFFC2E2C 020E4C63		blt		$t2,$x0,.done
FFFC2E30 01AE0A63		beq		$t2,$t0,.pjSame
FFFC2E34 2F0D2D83		ldt		$t1,IOF_PREV[$t0]
FFFC2E38 2FBE2823		stt		$t1,IOF_PREV[$t2]
FFFC2E3C 2FCDA423		stt		$t2,IOF_NEXT[$t1]
FFFC2E40 00000C63		bra		.0001
                        	.pjSame:
FFFC2E44 FFF06D93		ldi		$t1,#-1
FFFC2E48 00025637		stt		$t1,IOFocusNdx
FFFC2E4C 81060613
FFFC2E50 00060633
FFFC2E54 01B62023
                        	.0001:
FFFC2E58 FFF06D93		ldi		$t1,#-1
FFFC2E5C 2FBD2423		stt		$t1,IOF_NEXT[$t0]	
FFFC2E60 2FBD2823		stt		$t1,IOF_PREV[$t0]	
                        	.done:
                        	.noFocus:
FFFC2E64 00006813		ldi		$v0,#E_Ok
FFFC2E68 00008067		ret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/io.r5a",1
                        	.file "../fmtk/io.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;Standard Devices are:
                        	
                        	;#		Device					Standard name
                        	
                        	;0		NULL device 			NUL		(OS built-in)
                        	;1		Keyboard (sequential)	KBD		(OS built-in)
                        	;2		Video (sequential)		VID		(OS built-in)
                        	;3		Printer (parallel 1)	LPT
                        	;4		Printer (parallel 2)	LPT2
                        	;5		RS-232 1				COM1	(OS built-in)
                        	;6		RS-232 2				COM2
                        	;7		RS-232 3				COM3
                        	;8		RS-232 4				COM4
                        	;9		Parallel xfer	  PTI
                        	;10		Floppy					FD0
                        	;11		Floppy					FD1
                        	;12		Hard disk				HD0
                        	;13		Hard disk				HD1
                        	;14
                        	;15   VIA							VIA1
                        	;16		SDCard					CARD1 	(OS built-in)
                        	;17
                        	;18
                        	;19
                        	;20
                        	;21
                        	;22
                        	;23
                        	;24
                        	;25
                        	;26
                        	;27
                        	;28		Audio						PSG1	(OS built-in)
                        	;29
                        	;30   Random Number		PRNG
                        	;31		Debug						DBG
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a2 = function
                        	;		a3 = data
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_IO:
FFFC2E6C 02006813		ldi		$v0,#32
FFFC2E70 0309FE63		bgeu	$a1,$v0,.badDev
FFFC2E74 02006893		ldi		$v1,#32
FFFC2E78 031A7663		bgeu	$a2,$v1,.badFunc
FFFC2E7C 00899813		sll		$v0,$a1,#8					; each device allowed 32 functions (*256)
FFFC2E80 003A1893		sll		$v1,$a2,#3					; function number *8
FFFC2E84 00022637		add		$v0,$v0,#DVF_Base		; base address of function table
FFFC2E88 00060613
FFFC2E8C 01060833
FFFC2E90 01186833		or		$v0,$v0,$v1
FFFC2E94 00083803		ldo		$v0,[$v0]
FFFC2E98 00080663		beq		$v0,$x0,.badFunc
FFFC2E9C 000800E7		call	[$v0]
                        	.xit:
FFFC2EA0 00008067		ret
                        	.badFunc:
FFFC2EA4 02206813		ldi		$v0,#E_BadDevOp
FFFC2EA8 FE000CE3		bra		.xit
                        	.badDev:
FFFC2EAC 02006813		ldi		$v0,#E_BadDevNum
FFFC2EB0 FE0008E3		bra		.xit
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = I/O channel
                        	;		a1 = points to function table
                        	;------------------------------------------------------------------------------
                        	
                        	CopyDevFuncTbl:
FFFC2EB4 00891813		sll		$v0,$a0,#8					; each device allowed 32 functions (*256)
FFFC2EB8 00022637		add		$v0,$v0,#DVF_Base		; base address of function table
FFFC2EBC 00060613
FFFC2EC0 01060833
FFFC2EC4 02006D13		ldi		$t0,#32							; 32 functions to copy
                        	.again:
FFFC2EC8 0009BE03		ldo		$t2,[$a1]
FFFC2ECC 01C83023		sto		$t2,[$v0]
FFFC2ED0 00898993		add		$a1,$a1,#8
FFFC2ED4 00880813		add		$v0,$v0,#8
FFFC2ED8 FFFD0D13		sub		$t0,$t0,#1
FFFC2EDC FFA046E3		bgt		$t0,$x0,.again
FFFC2EE0 00008067		ret
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/scancodes.r5a",1
                        	.file "../fmtk/scancodes.r5a",1
                        		;--------------------------------------------------------------------------
                        		; PS2 scan codes to ascii conversion tables.
                        		;--------------------------------------------------------------------------
                        		;
FFFC2EE4 00000000		align	1
FFFC2EE8 00000000
FFFC2EEC 00000000
                        	
                        	_unshiftedScanCodes:
FFFC2EF0 A52EA92E		.byte	$2e,$a9,$2e,$a5,$a3,$a1,$a2,$ac
FFFC2EF4 ACA2A1A3
FFFC2EF8 A6A8AA2E		.byte	$2e,$aa,$a8,$a6,$a4,$09,$60,$2e
FFFC2EFC 2E6009A4
FFFC2F00 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$71,$31,$2e
FFFC2F04 2E31712E
FFFC2F08 737A2E2E		.byte	$2e,$2e,$7a,$73,$61,$77,$32,$2e
FFFC2F0C 2E327761
FFFC2F10 6478632E		.byte	$2e,$63,$78,$64,$65,$34,$33,$2e
FFFC2F14 2E333465
FFFC2F18 6676202E		.byte	$2e,$20,$76,$66,$74,$72,$35,$2e
FFFC2F1C 2E357274
FFFC2F20 68626E2E		.byte	$2e,$6e,$62,$68,$67,$79,$36,$2e
FFFC2F24 2E367967
FFFC2F28 6A6D2E2E		.byte	$2e,$2e,$6d,$6a,$75,$37,$38,$2e
FFFC2F2C 2E383775
FFFC2F30 696B2C2E		.byte	$2e,$2c,$6b,$69,$6f,$30,$39,$2e
FFFC2F34 2E39306F
FFFC2F38 6C2F2E2E		.byte	$2e,$2e,$2f,$6c,$3b,$70,$2d,$2e
FFFC2F3C 2E2D703B
FFFC2F40 2E272E2E		.byte	$2e,$2e,$27,$2e,$5b,$3d,$2e,$2e
FFFC2F44 2E2E3D5B
FFFC2F48 5D0D2EAD		.byte	$ad,$2e,$0d,$5d,$2e,$5c,$2e,$2e
FFFC2F4C 2E2E5C2E
FFFC2F50 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
FFFC2F54 2E082E2E
FFFC2F58 932E952E		.byte	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
FFFC2F5C 2E2E2E94
FFFC2F60 2E927F98		.byte	$98,$7f,$92,$2e,$91,$90,$1b,$af
FFFC2F64 AF1B9091
FFFC2F68 2E972EAB		.byte	$ab,$2e,$97,$2e,$2e,$96,$ae,$2e
FFFC2F6C 2EAE962E
                        	
FFFC2F70 A72E2E2E		.byte	$2e,$2e,$2e,$a7,$2e,$2e,$2e,$2e
FFFC2F74 2E2E2E2E
FFFC2F78 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC2F7C 2E2E2E2E
FFFC2F80 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC2F84 2E2E2E2E
FFFC2F88 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC2F8C 2E2E2E2E
FFFC2F90 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC2F94 2E2E2E2E
FFFC2F98 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC2F9C 2E2E2E2E
FFFC2FA0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC2FA4 2E2E2E2E
FFFC2FA8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC2FAC 2E2E2E2E
FFFC2FB0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC2FB4 2E2E2E2E
FFFC2FB8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC2FBC 2E2E2E2E
FFFC2FC0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC2FC4 2E2E2E2E
FFFC2FC8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC2FCC 2E2E2E2E
FFFC2FD0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC2FD4 2E2E2E2E
FFFC2FD8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC2FDC 2E2E2E2E
FFFC2FE0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC2FE4 2E2E2E2E
FFFC2FE8 2EFA2E2E		.byte	$2e,$2e,$fa,$2e,$2e,$2e,$2e,$2e
FFFC2FEC 2E2E2E2E
                        	
                        	_shiftedScanCodes:
FFFC2FF0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC2FF4 2E2E2E2E
FFFC2FF8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
FFFC2FFC 2E7E092E
FFFC3000 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$51,$21,$2e
FFFC3004 2E21512E
FFFC3008 535A2E2E		.byte	$2e,$2e,$5a,$53,$41,$57,$40,$2e
FFFC300C 2E405741
FFFC3010 4458432E		.byte	$2e,$43,$58,$44,$45,$24,$23,$2e
FFFC3014 2E232445
FFFC3018 4656202E		.byte	$2e,$20,$56,$46,$54,$52,$25,$2e
FFFC301C 2E255254
FFFC3020 48424E2E		.byte	$2e,$4e,$42,$48,$47,$59,$5e,$2e
FFFC3024 2E5E5947
FFFC3028 4A4D2E2E		.byte	$2e,$2e,$4d,$4a,$55,$26,$2a,$2e
FFFC302C 2E2A2655
FFFC3030 494B3C2E		.byte	$2e,$3c,$4b,$49,$4f,$29,$28,$2e
FFFC3034 2E28294F
FFFC3038 4C3F3E2E		.byte	$2e,$3e,$3f,$4c,$3a,$50,$5f,$2e
FFFC303C 2E5F503A
FFFC3040 2E222E2E		.byte	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
FFFC3044 2E2E2B7B
FFFC3048 7D0D2E2E		.byte	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
FFFC304C 2E2E7C2E
FFFC3050 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
FFFC3054 2E082E2E
FFFC3058 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC305C 2E2E2E2E
FFFC3060 2E2E7F2E		.byte	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
FFFC3064 2E1B2E2E
FFFC3068 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC306C 2E2E2E2E
                        	
FFFC3070 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3074 2E2E2E2E
FFFC3078 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC307C 2E2E2E2E
FFFC3080 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3084 2E2E2E2E
FFFC3088 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC308C 2E2E2E2E
FFFC3090 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3094 2E2E2E2E
FFFC3098 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC309C 2E2E2E2E
FFFC30A0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC30A4 2E2E2E2E
FFFC30A8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC30AC 2E2E2E2E
FFFC30B0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC30B4 2E2E2E2E
FFFC30B8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC30BC 2E2E2E2E
FFFC30C0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC30C4 2E2E2E2E
FFFC30C8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC30CC 2E2E2E2E
FFFC30D0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC30D4 2E2E2E2E
FFFC30D8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC30DC 2E2E2E2E
FFFC30E0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC30E4 2E2E2E2E
FFFC30E8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC30EC 2E2E2E2E
                        	
                        	; control
                        	_keybdControlCodes:
FFFC30F0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC30F4 2E2E2E2E
FFFC30F8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
FFFC30FC 2E7E092E
FFFC3100 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$11,$21,$2e
FFFC3104 2E21112E
FFFC3108 131A2E2E		.byte	$2e,$2e,$1a,$13,$01,$17,$40,$2e
FFFC310C 2E401701
FFFC3110 0418032E		.byte	$2e,$03,$18,$04,$05,$24,$23,$2e
FFFC3114 2E232405
FFFC3118 0616202E		.byte	$2e,$20,$16,$06,$14,$12,$25,$2e
FFFC311C 2E251214
FFFC3120 08020E2E		.byte	$2e,$0e,$02,$08,$07,$19,$5e,$2e
FFFC3124 2E5E1907
FFFC3128 0A0D2E2E		.byte	$2e,$2e,$0d,$0a,$15,$26,$2a,$2e
FFFC312C 2E2A2615
FFFC3130 090B3C2E		.byte	$2e,$3c,$0b,$09,$0f,$29,$28,$2e
FFFC3134 2E28290F
FFFC3138 0C3F3E2E		.byte	$2e,$3e,$3f,$0c,$3a,$10,$5f,$2e
FFFC313C 2E5F103A
FFFC3140 2E222E2E		.byte	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
FFFC3144 2E2E2B7B
FFFC3148 7D0D2E2E		.byte	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
FFFC314C 2E2E7C2E
FFFC3150 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
FFFC3154 2E082E2E
FFFC3158 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC315C 2E2E2E2E
FFFC3160 2E2E7F2E		.byte	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
FFFC3164 2E1B2E2E
FFFC3168 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC316C 2E2E2E2E
                        	
                        	_keybdExtendedCodes:
FFFC3170 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$a3,$a1,$a2,$2e
FFFC3174 2EA2A1A3
FFFC3178 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC317C 2E2E2E2E
FFFC3180 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3184 2E2E2E2E
FFFC3188 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC318C 2E2E2E2E
FFFC3190 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3194 2E2E2E2E
FFFC3198 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC319C 2E2E2E2E
FFFC31A0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC31A4 2E2E2E2E
FFFC31A8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC31AC 2E2E2E2E
FFFC31B0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC31B4 2E2E2E2E
FFFC31B8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC31BC 2E2E2E2E
FFFC31C0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC31C4 2E2E2E2E
FFFC31C8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC31CC 2E2E2E2E
FFFC31D0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC31D4 2E2E2E2E
FFFC31D8 932E952E		.byte	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
FFFC31DC 2E2E2E94
FFFC31E0 2E929998		.byte	$98,$99,$92,$2e,$91,$90,$2e,$2e
FFFC31E4 2E2E9091
FFFC31E8 2E972E2E		.byte	$2e,$2e,$97,$2e,$2e,$96,$2e,$2e
FFFC31EC 2E2E962E
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/keybd_driver_asm.r5a",1
                        	.file "../fmtk/keybd_driver_asm.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
                        		align	8                        	
                        	KeybdFuncTbl:
FFFC31F0 00000000		dco		0							; no operation
FFFC31F4 00000000
FFFC31F6 00000000		dco		0							; setup
FFFC31FA 00000000
FFFC31FC 00000000		dco		0							; initialize
FFFC3200 00000000
FFFC3202 00000000		dco		0							; status
FFFC3206 00000000
FFFC3208 00000000		dco		0							; media check
FFFC320C 00000000
FFFC320E 00000000		dco		0							; build BPB
FFFC3212 00000000
FFFC3214 00000000		dco		0							; open
FFFC3218 00000000
FFFC321A 00000000		dco		0							; close
FFFC321E 00000000
FFFC3220 00000000		dco		0							; get char
FFFC3224 00000000
FFFC3226 00000000		dco		0							; Peek char
FFFC322A 35680000
FFFC322C FFFC3568		dco		_KeybdGetScancode		; get char direct
FFFC3230 35540000
FFFC3232 FFFC3554		dco		_KeybdPeekScancode	; Peek char direct
FFFC3236 00000000
FFFC3238 00000000		dco		0							; input status
FFFC323C 00000000
FFFC323E 00000000		dco		0							; Put char
FFFC3242 00000000
FFFC3244 00000000		dco		0							; reserved
FFFC3248 00000000
FFFC324A 00000000		dco		0							; set position
FFFC324E 00000000
FFFC3250 00000000		dco		0							; read block
FFFC3254 00000000
FFFC3256 00000000		dco		0							; write block
FFFC325A 00000000
FFFC325C 00000000		dco		0							; verify block
FFFC3260 00000000
FFFC3262 00000000		dco		0							; output status
FFFC3266 00000000
FFFC3268 00000000		dco		0							; flush input
FFFC326C 00000000
FFFC326E 00000000		dco		0							; flush output
FFFC3272 358C0000
FFFC3274 FFFC358C		dco		KeybdIRQ			; IRQ routine
FFFC3278 00000000
FFFC327A 00000000		dco		0							; Is removable
FFFC327E 00000000
FFFC3280 00000000		dco		0							; ioctrl read
FFFC3284 00000000
FFFC3286 00000000		dco		0							; ioctrl write
FFFC328A 00000000
FFFC328C 00000000		dco		0							; output until busy
FFFC3290 00000000
FFFC3292 00000000		dco		0							; 27
FFFC3296 00000000
FFFC3298 00000000		dco		0
FFFC329C 00000000
FFFC329E 00000000		dco		0
FFFC32A2 00000000
FFFC32A4 00000000		dco		0
FFFC32A8 00000000
FFFC32AA 00000000		dco		0							; 31
FFFC32AE 07130000
                        	
                        	;===============================================================================
                        	; Keyboard routines
                        	;===============================================================================
                        	
                        	SC_C		equ		$21
                        	SC_Z		equ		$1A
                        	SC_TAB	equ		$0D
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Initialize the keyboard.
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        		align	4                        			; we don't know what was before
                        	_KeybdInit:
FFFC32B0 FF070713		sub		$sp,$sp,#16
FFFC32B4 00173023		sto		$ra,[$sp]
FFFC32B8 00106913		ldi		$a0,#1					; Keyboard device
FFFC32BC FFFC39B7		ldi		$a1,#KeybdFuncTbl
FFFC32C0 1F098993
FFFC32C4 BF1FF0EF		call	CopyDevFuncTbl
FFFC32C8 00006993		ldi		$a1,#0
FFFC32CC 00025A37		ldi		$a2,#hKeybdMbx
FFFC32D0 822A0A13
FFFC32D4 874FF0EF		call	FMTK_AllocMbx
FFFC32D8 0E000C63		bra		.xit
FFFC32DC 00506E93		ldi		$t3,#5
                        	.0002:
FFFC32E0 00031937		ldi		$a0,#200000			; 10ms wait
FFFC32E4 D4090913
FFFC32E8 01D73423		sto		$t3,8[$sp]
FFFC32EC CC4FD0EF		call	_MicroDelay
FFFC32F0 FFF06913		ldi		$a0,#-1					; send reset code to keyboard
FFFC32F4 00000637		stb		$a0,KEYBD+1			; write $FF to status reg to clear TX state
FFFC32F8 23D60613
FFFC32FC 00060633
FFFC3300 01260023
FFFC3304 1D4000EF		call	_KeybdSendByte	; now write to transmit register
FFFC3308 1E4000EF		call	_KeybdWaitTx		; wait until no longer busy
FFFC330C 178000EF		call	_KeybdRecvByte	; look for an ACK ($FA)
FFFC3310 0FA84E13		xor		$t2,$v0,#$FA
FFFC3314 040E1863		bnez	$t2,.tryAgain
FFFC3318 16C000EF		call	_KeybdRecvByte	; look for BAT completion code ($AA)
FFFC331C 0FC84E13		xor		$t2,$v0,#$FC		; reset error ?
FFFC3320 040E0263		beqz	$t2,.tryAgain
FFFC3324 0AA84813		xor		$v0,$v0,#$AA	; reset complete okay ?
FFFC3328 02081E63		bnez	$v0,.tryAgain
                        	
                        		; After a reset, scan code set #2 should be active
                        	.config:
FFFC332C 0F006913		ldi		$a0,#$F0			; send scan code select
FFFC3330 FFDC0637		stb		$a0,LEDS
FFFC3334 60060613
FFFC3338 00060633
FFFC333C 01260023
FFFC3340 198000EF		call	_KeybdSendByte
FFFC3344 1A8000EF		call	_KeybdWaitTx
FFFC3348 08087813		and		$v0,$v0,#$80
FFFC334C 00081C63		bnez	$v0,.tryAgain
FFFC3350 134000EF		call	_KeybdRecvByte	; wait for response from keyboard
FFFC3354 08087893		and		$v1,$v0,#$80
FFFC3358 00089663		bnez	$v1,.tryAgain
FFFC335C 0FA84E13		xor		$t2,$v0,#$FA
FFFC3360 020E0463		beqz	$t2,.0004
                        	.tryAgain:
FFFC3364 00873E83		ldo		$t3,8[$sp]
FFFC3368 FFFE8E93	  sub   $t3,$t3,#1
FFFC336C F60E9AE3		bnez	$t3,.0002
                        	.keybdErr:
FFFC3370 00000937		ldi		$a0,#msgBadKeybd
FFFC3374 24490913
FFFC3378 FF870713		sub		$sp,$sp,#8
FFFC337C 01273023		sto		$a0,[$sp]
FFFC3380 BFCFD0EF		call	PutString		; _DBGDisplayAsciiStringCRLF
FFFC3384 02000863		bra		.ledxit
                        	.0004:
FFFC3388 00206913		ldi		$a0,#2			; select scan code set #2
FFFC338C 14C000EF		call	_KeybdSendByte
FFFC3390 15C000EF		call	_KeybdWaitTx
FFFC3394 08087813		and		$v0,$v0,#$80
FFFC3398 FC0816E3		bnez	$v0,.tryAgain
FFFC339C 0E8000EF		call	_KeybdRecvByte	; wait for response from keyboard
FFFC33A0 08087893		and		$v1,$v0,#$80
FFFC33A4 FC0890E3		bnez	$v1,.tryAgain
FFFC33A8 0FA84E13		xor		$t2,$v0,#$FA
FFFC33AC FA0E1CE3		bnez	$t2,.tryAgain
FFFC33B0 06C000EF		call	_KeybdGetID
                        	.ledxit:
FFFC33B4 00706913		ldi		$a0,#$07
FFFC33B8 024000EF		call	_KeybdSetLED
FFFC33BC 005B9937		ldi		$a0,#6000000	; 300 ms
FFFC33C0 D8090913
FFFC33C4 BECFD0EF		call	_MicroDelay
FFFC33C8 00006913		ldi		$a0,#$00
FFFC33CC 010000EF		call	_KeybdSetLED
                        	.xit:
FFFC33D0 00073083		ldo		$ra,[$sp]
FFFC33D4 01070713		add		$sp,$sp,#16
FFFC33D8 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Set the LEDs on the keyboard.
                        	;
                        	; Parameters: $a0 LED status to set
                        	; Returns: none
                        	; Modifies: none
                        	; Stack Space: 2 words
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdSetLED:
FFFC33DC FF070713		sub		$sp,$sp,#16
FFFC33E0 00173023		sto		$ra,[$sp]
FFFC33E4 00096E33		mov		$t2,$a0
FFFC33E8 0ED06913		ldi		$a0,#$ED
FFFC33EC 01C73423		sto		$t2,8[$sp]
FFFC33F0 0E8000EF		call	_KeybdSendByte
FFFC33F4 0F8000EF		call	_KeybdWaitTx
FFFC33F8 08C000EF		call	_KeybdRecvByte	; should be an ack
FFFC33FC 00873E03		ldo		$t2,8[$sp]
FFFC3400 000E6933		mov		$a0,$t2
FFFC3404 0D4000EF		call	_KeybdSendByte
FFFC3408 0E4000EF		call	_KeybdWaitTx
FFFC340C 078000EF		call	_KeybdRecvByte	; should be an ack
FFFC3410 00073083		ldo		$ra,[$sp]
FFFC3414 01070713		add		$sp,$sp,#16
FFFC3418 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Get ID - get the keyboards identifier code.
                        	;
                        	; Parameters: none
                        	; Returns: r1 = $AB83, $00 on fail
                        	; Modifies: r1, KeybdID updated
                        	; Stack Space: 2 words
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdGetID:
FFFC341C FF870713		sub		$sp,$sp,#8
FFFC3420 00173023		sto		$ra,[$sp]
FFFC3424 0F206913		ldi		$a0,#$F2
FFFC3428 0B0000EF		call	_KeybdSendByte
FFFC342C 0C0000EF		call	_KeybdWaitTx
FFFC3430 054000EF		call	_KeybdRecvByte
FFFC3434 08087893		and		$v1,$v0,#$80
FFFC3438 04089263		bnez	$v1,.notKbd
FFFC343C 0AB84E13		xor		$t2,$v0,#$AB
FFFC3440 020E1E63		bnez	$t2,.notKbd
FFFC3444 040000EF		call	_KeybdRecvByte
FFFC3448 08087893		and		$v1,$v0,#$80
FFFC344C 02089863		bnez	$v1,.notKbd
FFFC3450 08384E13		xor		$t2,$v0,#$83
FFFC3454 020E1463		bnez	$t2,.notKbd
FFFC3458 0000B837		ldi		$v0,#$AB83
FFFC345C B8380813
                        	.0001:
FFFC3460 00000637		stt		$v0,_KeybdID
FFFC3464 24A60613
FFFC3468 00060633
FFFC346C 01062023
FFFC3470 00073083		ldo		$ra,[$sp]
FFFC3474 00870713		add		$sp,$sp,#8
FFFC3478 00008067		ret
                        	.notKbd:
FFFC347C 00006813		ldi		$v0,#$00
FFFC3480 FE0000E3		bra		.0001
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Recieve a byte from the keyboard, used after a command is sent to the
                        	; keyboard in order to wait for a response.
                        	;
                        	; Parameters: none
                        	; Returns: r1 = recieved byte ($00 to $FF), -1 on timeout
                        	; Modifies: r1
                        	; Stack Space: 2 words
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdRecvByte:
FFFC3484 FF070713		sub		$sp,$sp,#16
FFFC3488 00173023		sto		$ra,[$sp]
FFFC348C 06406E93		ldi		$t3,#100				; wait up to 1s
                        	.0003:
FFFC3490 0B0000EF		call	_KeybdGetStatus	; wait for response from keyboard
FFFC3494 08087813		and		$v0,$v0,#$80		; is input buffer full ? yes, branch
FFFC3498 02081863		bnez	$v0,.0004
FFFC349C 00031937		ldi		$a0,#200000
FFFC34A0 D4090913
FFFC34A4 01D73423		sto		$t3,8[$sp]
FFFC34A8 B08FD0EF		call	_MicroDelay
FFFC34AC 00873E83		ldo		$t3,8[$sp]
FFFC34B0 FFFE8E93		sub   $t3,$t3,#1
FFFC34B4 FC0E9EE3		bnez	$t3,.0003				; go back and try again
FFFC34B8 FFF06813		ldi		$v0,#-1				; return -1
FFFC34BC 00073083		ldo		$ra,[$sp]
FFFC34C0 01070713		add		$sp,$sp,#16
FFFC34C4 00008067		ret
                        	.0004:
FFFC34C8 0A0000EF		call	_KeybdGetScancode
FFFC34CC 00073083		ldo		$ra,[$sp]
FFFC34D0 01070713		add		$sp,$sp,#16
FFFC34D4 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Send a byte to the keyboard.
                        	;
                        	; Parameters: $a0 byte to send
                        	; Returns: none
                        	; Modifies: none
                        	; Stack Space: 0 words
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdSendByte:
FFFC34D8 00000637		stb		$a0,KEYBD
FFFC34DC 23C60613
FFFC34E0 00060633
FFFC34E4 01260023
FFFC34E8 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Wait until the keyboard transmit is complete
                        	;
                        	; Parameters: none
                        	; Returns: r1 = 0 if successful, r1 = -1 timeout
                        	; Modifies: v0,t3
                        	; Stack Space: 1 words
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdWaitTx:
FFFC34EC FF070713		sub		$sp,$sp,#16
FFFC34F0 00173023		sto		$ra,[$sp]
FFFC34F4 06406E93		ldi		$t3,#100			; wait a max of 1s
                        	.0001:
FFFC34F8 048000EF		call	_KeybdGetStatus
FFFC34FC 04087813		and		$v0,$v0,#$40	; check for transmit complete bit; branch if bit set
FFFC3500 02081863		bnez	$v0,.0002
FFFC3504 01D73423		sto		$t3,8[$sp]
FFFC3508 00031937		ldi		$a0,#200000		; 10 ms @20MHz
FFFC350C D4090913
FFFC3510 AA0FD0EF		call	_MicroDelay		; delay a little bit
FFFC3514 00873E83		ldo		$t3,8[$sp]
FFFC3518 FFFE8E93		sub		$t3,$t3,#1
FFFC351C FC0E9EE3		bnez	$t3,.0001
FFFC3520 00073083		ldo		$ra,[$sp]			; timed out
FFFC3524 00870713		add		$sp,$sp,#8
FFFC3528 FFF06813		ldi		$v0,#-1
FFFC352C 00008067		ret		
                        	.0002:
FFFC3530 00073083		ldo		$ra,[$sp]			; timed out
FFFC3534 01070713		add		$sp,$sp,#16
FFFC3538 00006813		ldi		$v0,#0
FFFC353C 00008067		ret		
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Get the keyboard status
                        	;
                        	; Parameters: none
                        	; Returns: r1 = status
                        	; Modifies: r1
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdGetStatus:
FFFC3540 00000637		ldb		$v0,KEYBD+1
FFFC3544 23D60613
FFFC3548 00060633
FFFC354C 00060803
FFFC3550 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Get the scancode from the keyboard port. Getting the scancode clears the
                        	; interrupt status.
                        	;
                        	; Parameters: none
                        	; Returns: r1 = scancode
                        	; Modifies: r1
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdPeekScancode:
FFFC3554 00000637		ldbu		$v0,KEYBD			; get the scan code
FFFC3558 23C60613
FFFC355C 00060633
FFFC3560 00064803
FFFC3564 00008067		ret
                        	
                        	_KeybdGetScancode:
FFFC3568 00000637		ldbu		$v0,KEYBD			; get the scan code
FFFC356C 23C60613
FFFC3570 00060633
FFFC3574 00064803
FFFC3578 00000637		stb			$x0,KEYBD+1		; clear receive register
FFFC357C 23D60613
FFFC3580 00060633
FFFC3584 00060023
FFFC3588 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	KeybdIRQ:
FFFC358C FB5FF0EF		call	_KeybdGetStatus
FFFC3590 0E085263		bge		$v0,$x0,.notKbd
FFFC3594 FD5FF0EF		call	_KeybdGetScancode
FFFC3598 00025637		ldo		$s1,IOFocusNdx
FFFC359C 81060613
FFFC35A0 00060633
FFFC35A4 00063203
FFFC35A8 0C020663		beqz	$s1,.notKbd
FFFC35AC 30024D03		ldbu	$t0,TCBKbdHead[$s1]
FFFC35B0 30124D83		ldbu	$t1,TCBKbdTail[$s1]
FFFC35B4 001D0D13		add		$t0,$t0,#1
FFFC35B8 01FD7D13		and		$t0,$t0,#31
FFFC35BC 01BD0663		beq		$t0,$t1,.noRoom
FFFC35C0 31A20023		stb		$t0,TCBKbdHead[$s1]
FFFC35C4 31020423		stb		$v0,TCBKbdBuf[$s1]
                        	.noRoom:
                        		; check trigger debugger
                        		; check CTRL-C
FFFC35C8 00000637		lbu		$t0,TCBKbdState2
FFFC35CC 25260613
FFFC35D0 00060633
FFFC35D4 00064D03
FFFC35D8 004D7D93		and		$t1,$t0,#4
FFFC35DC 020D8E63		beqz	$t1,.notCtrl
FFFC35E0 02106D13		ldi		$t0,#SC_C
FFFC35E4 01A81863		bne		$v0,$t0,.notCtrlC
FFFC35E8 00306D13		ldi		$t0,#3
FFFC35EC 2DA23423		sto		$t0,TCBException[$s1]
FFFC35F0 02000463		bra		.0001
                        	.notCtrlC:
FFFC35F4 01A06D13		ldi		$t0,#SC_Z
FFFC35F8 03A81063		bne		$v0,$t0,.notCtrlZ
FFFC35FC 01A06D13		ldi		$t0,#26
                        		
FFFC3600 18101873		csrrw	v0,#$181,x0
FFFC3604 00F87813		and		v0,v0,#15
FFFC3608 00081813	sll		$v0,$v0,#32
FFFC360C 01A86833		or		$v0,$v0,$t0
FFFC3610 2D023423		sto		$v0,TCBException[$s1]
FFFC3614 00000263		bra		.0001
                        	.notCtrlZ:
                        	.0001:
                        	.notCtrl:
FFFC3618 002D7D93		and		$t1,$t0,#2
FFFC361C 420D8DE3		beqz	$t1,.notAlt
FFFC3620 00D06D13		ldi		$t0,#SC_TAB
FFFC3624 01A81A63		bne		$v0,$t0,.notAltTab
FFFC3628 00025637		stb		$t0,SwitchIOFocus
FFFC362C 82060613
FFFC3630 00060633
FFFC3634 01A60023
                        	.notAltTab:
                        		; Send a message indicating a key is available
                        		; Keyboard mailbox setup yet?
FFFC3638 00025637		ldw		$a1,hKeybdMbx
FFFC363C 82260613
FFFC3640 00060633
FFFC3644 00061983
FFFC3648 0209C663		blt		$a1,$x0,.notKbd
                        		; If there's already a keyboard message, don't send another one.
FFFC364C 00599213		sll		$s1,$a1,#LOG_MBXSZ
FFFC3650 00020637		add		$s1,$s1,#mbxs
FFFC3654 00060613
FFFC3658 00460233
FFFC365C 01823D03		ldo		$t0,MBX_MQTAIL[$s1]
FFFC3660 000D1A63		bnez	$t0,.notKbd
FFFC3664 FFF06A13		ldi		$a2,#-1
FFFC3668 FFF06A93		ldi		$a3,#-1
FFFC366C FFF06B13		ldi		$a4,#-1
FFFC3670 DD9FE0EF		call	FMTK_SendMsg
                        	.notKbd:
FFFC3674 10000073		eret
                        	
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "TinyBasic.r5a",1
                        	.file "TinyBasic.r5a",1
                        	;****************************************************************;
                        	;                                                                ;
                        	;		Tiny BASIC for the CS01                                      ;
                        	;                                                                ;
                        	; Derived from a 68000 derivative of Palo Alto Tiny BASIC as     ;
                        	; published in the May 1976 issue of Dr. Dobb's Journal.         ;
                        	; Adapted to the 68000 by:                                       ;
                        	;	Gordon brndly						                         ;
                        	;	12147 - 51 Street					                         ;
                        	;	Edmonton AB  T5W 3G8					                     ;
                        	;	Canada							                             ;
                        	;	(updated mailing address for 1996)			                 ;
                        	;                                                                ;
                        	; Adapted to the CS01 by:                                        ;
                        	;    Robert Finch                                                ;
                        	;    Ontario, Canada                                             ;
                        	;	 robfinch<remove>@finitron.ca    	                             ;  
                        	;****************************************************************;
                        	;  Copyright (C) 2016-2020 by Robert Finch. This program may be	 ;
                        	;    freely distributed for personal use only. All commercial	 ;
                        	;		       rights are reserved.			                     ;
                        	;****************************************************************;
                        	;
                        	; Register Usage
                        	; $t2 = text pointer (global usage)
                        	; r3,r4 = inputs parameters to subroutines
                        	; a1 = return value
                        	;
                        	;* Vers. 1.0  1984/7/17	- Original version by Gordon brndly
                        	;*	1.1  1984/12/9	- Addition of '0x' print term by Marvin Lipford
                        	;*	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                        	
                        	CR		EQU	0x0D		;ASCII equates
                        	LINEFD	EQU	0x0A		; Don't use LF (same as load float instruction)
                        	TAB		EQU	0x09
                        	CTRLC	EQU	0x03
                        	CTRLH	EQU	0x08
                        	CTRLI	EQU	0x09
                        	CTRLJ	EQU	0x0A
                        	CTRLK	EQU	0x0B
                        	CTRLM   EQU 0x0D
                        	CTRLS	EQU	0x13
                        	CTRLX	EQU	0x18
                        	XON		EQU	0x11
                        	XOFF	EQU	0x13
                        	
                        	FILENAME	EQU		0x6C0
                        	FILEBUF		EQU		0x07F600
                        	OSSP		EQU		0x700
                        	TXTUNF		EQU		OSSP+4
                        	VARBGN		EQU		TXTUNF+4
                        	VAREND		EQU		VARBGN+4
                        	LOPVAR		EQU		VAREND+4
                        	STKGOS		EQU		LOPVAR+4
                        	CURRNT		EQU		STKGOS+4
                        	BUFFER		EQU		CURRNT+4
                        	BUFLEN		EQU		84
                        	LOPPT		EQU		BUFFER+84
                        	LOPLN		EQU		LOPPT+4
                        	LOPINC		EQU		LOPLN+4
                        	LOPLMT		EQU		LOPINC+4
                        	NUMWKA		EQU		LOPLMT+24
                        	STKINP		EQU		NUMWKA+4
                        	STKBOT		EQU		STKINP+4
                        	usrJmp		EQU		STKBOT+4
                        	IRQROUT		EQU		usrJmp+4
                        	
                        	OUTPTR		EQU		IRQROUT+4
                        	INPPTR		EQU		OUTPTR+4
                        	CursorFlash	EQU		INPPTR+4
                        	IRQFlag		EQU		CursorFlash+4
                        	
                        	;
                        	; Modifiable system constants:
                        	;
                        	;THRD_AREA	dw	0x04000000	; threading switch area 0x04000000-0x40FFFFF
                        	;bitmap dw	0x00100000	; bitmap graphics memory 0x04100000-0x417FFFF
                        	TXTBGN		EQU		0x001800	;TXT ;beginning of program memory
                        	ENDMEM		EQU		0x008000	; end of available memory
                        	STACKOFFS	EQU		0x07FFFC	; stack offset
                        	
                        	
                        	.file "TinyBasic.r5a",84
                        			code
FFFC3678 00000000			align	25
FFFC367C 00000000
FFFC3680 00000000
FFFC3684 00000000
FFFC3688 00000000
FFFC368C 00000000
FFFC3690 00000000
FFFC3694 00000000
FFFC3698 00000000
FFFC369C 00000000
FFFC36A0 00000000
FFFC36A4 00000000
FFFC36A8 00000000
FFFC36AC 00000000
FFFC36B0 00000000
FFFC36B4 00000000
FFFC36B8 00000000
FFFC36BC 00000000
FFFC36C0 00000000
FFFC36C4 00000000
FFFC36C8 00000000
FFFC36CC 00000000
FFFC36D0 00000000
FFFC36D4 00000000
FFFC36D8 00000000
FFFC36DC 00000000
FFFC36E0 00000000
FFFC36E4 00000000
FFFC36E8 00000000
FFFC36EC 00000000
FFFC36F0 00000000
FFFC36F4 00000000
FFFC36F8 00000000
FFFC36FC 00000000
                        	
                        	;
                        	; Standard jump table. You can change these addresses if you are
                        	; customizing this interpreter for a different environment.
                        	;
                        	TinyBasic:
                        	GOSTART:	
FFFC3700 0300006F			jmp	CSTART	;	Cold Start entry point
                        	GOWARM:	
FFFC3704 0BC0006F			jmp	WSTART	;	Warm Start entry point
                        	GOOUT:	
FFFC3708 5590106F			jmp	OUTC	;	Jump to character-out routine
                        	GOIN:	
FFFC370C 5590106F			jmp	INCH	;Jump to character-in routine
                        	GOAUXO:	
FFFC3710 00000637			jmp	AUXOUT	;	Jump to auxiliary-out routine
FFFC3714 28660067
                        	GOAUXI:	
FFFC3718 00000637			jmp	AUXIN	;	Jump to auxiliary-in routine
FFFC371C 28860067
                        	GOBYE:	
FFFC3720 5750106F			jmp	BYEBYE	;	Jump to monitor, DOS, etc.
                        	
FFFC3724 00000000		align	1
FFFC3728 00000000
FFFC372C 00000000
                        	
                        	//message "CSTART"
                        	public CSTART:
	; First save off the link register and OS sp value
FFFC3730 70E02023		sw		$sp,OSSP
FFFC3734 00080737		ldi		$sp,#STACKOFFS	; initialize stack pointer
FFFC3738 FFC70713
FFFC373C 00E06913		ldi		$a0,#14							; Get current tid
FFFC3740 00000073		ecall
FFFC3744 0008E9B3		mov		$a1,$v1
FFFC3748 01806913		ldi		$a0,#24							; RequestIOFocus
FFFC374C 00000073		ecall
                        	;	call	_DBGHomeCursor[pc]
FFFC3750 00006933		mov		a0,r0			; turn off keyboard echoing
                        	//	call	SetKeyboardEcho
                        	//	stz		CursorFlash
                        	//	ldx		#0x10000020	; black chars, yellow background
                        	;	stx		charToPrint
                        	;	call	_DBGClearScreen[pc]
FFFC3754 FFFC5937		ldi		a0,#msgInit	;	tell who we are
FFFC3758 49C90913
FFFC375C 309010EF		call	PRMESG
FFFC3760 00002937		ldi		a0,#TXTBGN	;	init. end-of-program pointer
FFFC3764 80090913
FFFC3768 71202223		sw		a0,TXTUNF
FFFC376C 00008937		ldi		a0,#ENDMEM	;	get address of end of memory
FFFC3770 00090913
FFFC3774 00080937		ldi		a0,#$7F800
FFFC3778 80090913
FFFC377C 79202E23		sw		a0,STKBOT
FFFC3780 00008937		ldi		a0,#ENDMEM
FFFC3784 00090913
FFFC3788 71202623		sw		a0,VAREND
FFFC378C CE090913		sub		a0,a0,#800 	;   100 vars
FFFC3790 71202423		sw    a0,VARBGN
FFFC3794 47C000EF		call  clearVars   ; clear the variable area
FFFC3798 7A002223		sw		r0,IRQROUT
FFFC379C 70802903		lw    a0,VARBGN   ; calculate number of bytes free
FFFC37A0 70402983		lw		a1,TXTUNF
FFFC37A4 41390933		sub   a0,a0,a1
FFFC37A8 00606993		ldi		a1,#6		; max 6 digits
FFFC37AC 00A06A13		ldi		a2,#10	; base 10
FFFC37B0 7E4010EF		call  PRTNUM
FFFC37B4 FFFC5937		ldi		a0,#msgBytesFree
FFFC37B8 53D90913
FFFC37BC 2A9010EF		call	PRMESG
                        	WSTART:
FFFC37C0 70002823		sw		x0,LOPVAR   ; initialize internal variables
FFFC37C4 70002A23		sw		x0,STKGOS
FFFC37C8 70002C23		sw		x0,CURRNT	;	current line number pointer = 0
FFFC37CC 00080737		ldi		$sp,#STACKOFFS	;	init S.P. again, just in case
FFFC37D0 FFC70713
FFFC37D4 FFFC5937		ldi		a0,#msgReady	;	display "Ready"
FFFC37D8 54A90913
FFFC37DC 289010EF		call	PRMESG
                        	BASPRMPT:
FFFC37E0 00E06913		ldi		a0,#14		; get current tid
FFFC37E4 00000073		ecall
FFFC37E8 0008E933		mov		a0,v1
FFFC37EC F31FC0EF		call	PutHexByte
FFFC37F0 03E06913		ldi		a0,#'>'		; Prompt with a '>' and
FFFC37F4 470010EF		call	GETLN		; read a line.
FFFC37F8 1BD010EF		call	TOUPBUF 	; convert to upper case
FFFC37FC 000E64B3		mov		$s6,$t2		; save pointer to end of line
FFFC3800 71C06E13		ldi		$t2,#BUFFER	; point to the beginning of line
FFFC3804 10D010EF		call	TSTNUM		; is there a number there?
FFFC3808 17D010EF		call	IGNBLK		; skip trailing blanks
FFFC380C 000E4483		lbu		$s6,[$t2]
FFFC3810 00D4C493		xor		$s6,$s6,#CR	; s6 = flag empty line
                        	; does line no. exist? (or nonzero?)
FFFC3814 28088663		beq		v1,x0,DIRECT		; if not, it's a direct statement
FFFC3818 00100DB7		ldi		$t1,#$FFFFF
FFFC381C FFFD8D93
FFFC3820 010DD863		ble		v0,$t1,ST2	; see if line no. is <= 16 bits
FFFC3824 FFFC5937		ldi		a0,#msgLineRange	; if not, we've overflowed
FFFC3828 56590913
FFFC382C 3F40106F		jmp		ERROR
                        	ST2:
FFFC3830 00086933	  mov		$a0,$v0		; a0 = line number
FFFC3834 000E6433	  mov		$s5,$t2			; save line buffer pointer
FFFC3838 FFCE0E13		sub		$t2,$t2,#4
FFFC383C 012E2023	  sw		$a0,[$t2]		;	This will end up in buffer
FFFC3840 518010EF		call	FNDLN		; find this line in save area
FFFC3844 000EE533		mov		$s7,$t3		; save possible line pointer
FFFC3848 00080663		beq		$v0,$x0,INSLINE	; if not found, insert
FFFC384C 000EE933		mov		$a0,$t3
FFFC3850 044000EF		call	DeleteLine
                        	INSLINE:
FFFC3854 F80486E3		beq		$s6,$x0,BASPRMPT	; line was empty
FFFC3858 00046933		mov		$a0,$s5			; a0 = buffer pointer	
                        		; GetBuflen just get the length of the text.
                        		; A line number is stuffed just before the text
                        		; so length needs to be adjusted by 4.
FFFC385C 0A0000EF		call	GetBuflen
FFFC3860 00480393		add		$s4,$v0,#4
FFFC3864 00056933		mov		$a0,$s7
FFFC3868 0003E9B3		mov		$a1,$s4
FFFC386C 0BC000EF		call	OpenSpace
FFFC3870 00081863		bne		$v0,$x0,.0001	; space available?
FFFC3874 FFFC5937		ldi		a0,#msgTooBig	; no space available
FFFC3878 63790913
FFFC387C 3A40106F		jmp		ERROR
                        	.0001:
FFFC3880 00056933		mov		$a0,$s7			; target
FFFC3884 FFC40993		sub		$a1,$s5,#4	; source (incl lineno)
FFFC3888 0003EA33		mov		$a2,$s4			; length
FFFC388C 050000EF		call	InsertLine
FFFC3890 F40008E3		bra		BASPRMPT
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = pointer to line to delete
                        	; Modifies:
                        	;		t0,t1,t2,t3
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	DeleteLine:
                        		; Find the end of the line to delete
FFFC3894 00490D13		add		$t0,$a0,#4		; t0 = pointer to line past line number
FFFC3898 00D06E13		ldi		$t2,#CR
FFFC389C 70402E83		lw		$t3,TXTUNF		; last text address
                        	.0002:
FFFC38A0 000D4D83		lbu		$t1,[$t0]
FFFC38A4 000D8A63		beq		$t1,$x0,.0003	; might be null
FFFC38A8 01CD8663		beq		$t1,$t2,.0001	; lines end with CR
FFFC38AC 001D0D13		add		$t0,$t0,#1
FFFC38B0 FFDD68E3		bltu	$t0,$t3,.0002	; end of program?
                        	.0001:
FFFC38B4 001D0D13		add		$t0,$t0,#1
                        	.0003:
                        		; pull text after eol overtop
FFFC38B8 000D4F03		lbu		$t4,[$t0]			; copy from next line
FFFC38BC 01E90023		sb		$t4,[$a0]			; overtop deleted line
FFFC38C0 001D0D13		add		$t0,$t0,#1		; increment pointers
FFFC38C4 00190913		add		$a0,$a0,#1
FFFC38C8 FFAEF8E3		bleu	$t0,$t3,.0003	; to end of program
                        		; update end of text
FFFC38CC 412D0933		sub		$a0,$t0,$a0		; difference of pointers = length
FFFC38D0 412E8EB3		sub		$t3,$t3,$a0		
FFFC38D4 71D02223		sw		$t3,TXTUNF
FFFC38D8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = insertion point
                        	; 	a1 = source buffer
                        	; 	a2 = length
                        	; Modifies:
                        	;		a0,a1,a2,t1
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	InsertLine:
FFFC38DC 000A0E63		beq		$a2,$x0,.done		; zero length? Probably a SW error
                        	.0001:
FFFC38E0 0009CD83		lbu		$t1,[$a1]				; get from source text
FFFC38E4 01B90023		sb		$t1,[$a0]				; store to insertion point
FFFC38E8 00198993		add		$a1,$a1,#1			; increment pointers
FFFC38EC 00190913		add		$a0,$a0,#1
FFFC38F0 FFFA0A13		sub		$a2,$a2,#1			; decrement length
FFFC38F4 FF4066E3		bgtu	$a2,$x0,.0001
                        	.done:
FFFC38F8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; GetBuflen - get the length of text in a buffer. The length is taken up to
                        	; the first null character or carriage return character encountered.
                        	;
                        	; Parameters:
                        	;		a0 = pointer to buffer
                        	; Modifies:
                        	;		t2,t3,t5
                        	; Returns:
                        	;		v0 = length of data in buffer
                        	;------------------------------------------------------------------------------
                        	
                        	GetBuflen:
FFFC38FC 00006813		ldi		$v0,#0
FFFC3900 00D06E93		ldi		$t3,#CR
FFFC3904 00096FB3		mov		$t5,$a0
                        	.0002:
FFFC3908 000FCE03		lbu		$t2,[$t5]
FFFC390C 001F8F93		add		$t5,$t5,#1
FFFC3910 000E0A63		beq		$t2,$x0,.0001
FFFC3914 01DE0663		beq		$t2,$t3,.0004
FFFC3918 00180813		add		$v0,$v0,#1
FFFC391C FE0006E3		bra		.0002
                        	.0004:
FFFC3920 00180813		add		$v0,$v0,#1
                        	.0001:
FFFC3924 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = place to insert line
                        	; 	a1 = buffer length
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		v0 = 1 if successful, 0 if not enough room available
                        	;------------------------------------------------------------------------------
                        	
                        	OpenSpace:
FFFC3928 70402E03		lw		$t2,TXTUNF
FFFC392C 000E6EB3		mov		$t3,$t2				; t3 = old end of text
FFFC3930 013E0E33		add		$t2,$t2,$a1		; increment end of text by buffer length
FFFC3934 70802D83		lw		$t1,VARBGN		; compare to start of variables
FFFC3938 03BE7263		bgeu	$t2,$t1,.noSpace	; enough room?
FFFC393C 71C02223		sw		$t2,TXTUNF		; yes, set new end of text
                        	.0003:
FFFC3940 000ECF83		lbu		$t5,[$t3]			; copy old text
FFFC3944 01FE0023		sb		$t5,[$t2]			; to new text loc
FFFC3948 FFFE8E93		sub		$t3,$t3,#1		; decrement pointers
FFFC394C FFFE0E13		sub		$t2,$t2,#1
FFFC3950 FF2EF8E3		bgeu	$t3,$a0,.0003	; until insert point reached
FFFC3954 00106813		ldi		$v0,#1				; return success
FFFC3958 00008067		ret
                        	.noSpace:
FFFC395C 00006813		ldi		$v0,#0
FFFC3960 00008067		ret	
                        	
                        	;******************************************************************
                        	;
                        	; *** Tables *** DIRECT *** EXEC ***
                        	;
                        	; This section of the code tests a string against a table. When
                        	; a match is found, control is transferred to the section of
                        	; code according to the table.
                        	;
                        	; At 'EXEC', r8 should point to the string, r9 should point to
                        	; the character table, and r10 should point to the execution
                        	; table. At 'DIRECT', r8 should point to the string, r9 and
                        	; r10 will be set up to point to TAB1 and TAB1_1, which are
                        	; the tables of all direct and statement commands.
                        	;
                        	; A '.' in the string will terminate the test and the partial
                        	; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                        	; 'PRIN.', or 'PRINT' will all match 'PRINT'.
                        	;
                        	; There are two tables: the character table and the execution
                        	; table. The character table consists of any number of text items.
                        	; Each item is a string of characters with the last character's
                        	; high bit set to one. The execution table holds a 32-bit
                        	; execution addresses that correspond to each entry in the
                        	; character table.
                        	;
                        	; The end of the character table is a 0 byte which corresponds
                        	; to the default routine in the execution table, which is
                        	; executed if none of the other table items are matched.
                        	;
                        	; Character-matching tables:
                        	TAB1:
FFFC3964 D453494C		db	"LIS",'T'+0x80        ; Direct commands
FFFC3968 C4414F4C		db	"LOA",'D'+0x80
FFFC396C 52D7454E		db	"NE",'W'+0x80
FFFC396F 53CE5552		db	"RU",'N'+0x80
FFFC3972 C5564153		db	"SAV",'E'+0x80
                        	TAB2:
FFFC3976 D458454E		db	"NEX",'T'+0x80         ; Direct / statement
FFFC397A 49D4454C		db	"LE",'T'+0x80
FFFC397D 4F47C649		db	"I",'F'+0x80
FFFC397F CF544F47		db	"GOT",'O'+0x80
FFFC3983 55534F47		db	"GOSU",'B'+0x80
FFFC3987 544552C2
FFFC3988 55544552		db	"RETUR",'N'+0x80
FFFC398C 4552CE52
FFFC398E 46CD4552		db	"RE",'M'+0x80
FFFC3991 49D24F46		db	"FO",'R'+0x80
FFFC3994 55504E49		db	"INPU",'T'+0x80
FFFC3998 495250D4
FFFC3999 4E495250		db	"PRIN",'T'+0x80
FFFC399D 4B4F50D4
FFFC399E C54B4F50		db	"POK",'E'+0x80
FFFC39A2 454B4F50		db	"POKE",'W'+0x80
FFFC39A6 4B4F50D7
FFFC39A7 454B4F50		db	"POKE",'H'+0x80
FFFC39AB 454959C8
FFFC39AC 4C454959		db	"YIEL",'D'+0x80
FFFC39B0 4F5453C4
FFFC39B1 D04F5453		db	"STO",'P'+0x80
FFFC39B5 53C55942		db	"BY",'E'+0x80
FFFC39B8 43D35953		db	"SY",'S'+0x80
FFFC39BB 43D34C43		db	"CL",'S'+0x80
FFFC39BE 52D24C43	    db  "CL",'R'+0x80
FFFC39C1 C6434452	    db	"RDC",'F'+0x80
FFFC39C5 52494E4F	    db	"ONIR",'Q'+0x80
FFFC39C9 494157D1
FFFC39CA D4494157	    db	"WAI",'T'+0x80
FFFC39CE 45455000		db	0
                        	TAB4:
FFFC39CF CB454550		db	"PEE",'K'+0x80         ;Functions
FFFC39D3 4B454550		db	"PEEK",'W'+0x80
FFFC39D7 454550D7
FFFC39D8 4B454550		db	"PEEK",'H'+0x80
FFFC39DC C44E52C8
FFFC39DD 41C44E52		db	"RN",'D'+0x80
FFFC39E0 53D34241		db	"AB",'S'+0x80
FFFC39E3 54CE4753		db  "SG",'N'+0x80
FFFC39E6 CB434954		db	"TIC",'K'+0x80
FFFC39EA C55A4953		db	"SIZ",'E'+0x80
FFFC39EE 41D25355		db  "US",'R'+0x80
FFFC39F1 4F4C4C41	  db	"ALLOCMB",'X'+0x80
FFFC39F5 D8424D43
FFFC39F9 444E4553	  db	"SENDMS",'G'+0x80
FFFC39FD 57C7534D
FFFC3A00 54494157	  db	"WAITMS",'G'+0x80
FFFC3A04 00C7534D
FFFC3A07 00CF5400		db	0
                        	TAB5:
FFFC3A08 5300CF54		db	"T",'O'+0x80           ;"TO" in "FOR"
FFFC3A0A 45545300		db	0
                        	TAB6:
FFFC3A0B D0455453		db	"STE",'P'+0x80         ;"STEP" in "FOR"
FFFC3A0F 3CBD3E00		db	0
                        	TAB8:
FFFC3A10 BE3CBD3E		db	'>','='+0x80           ;Relational operators
FFFC3A12 BDBEBE3C		db	'<','>'+0x80
FFFC3A14 BD3CBDBE		db	'>'+0x80
FFFC3A15 BCBD3CBD		db	'='+0x80
FFFC3A16 00BCBD3C		db	'<','='+0x80
FFFC3A18 4E4100BC		db	'<'+0x80
FFFC3A19 C44E4100		db	0
                        	TAB9:
FFFC3A1A 00C44E41	    db  "AN",'D'+0x80
FFFC3A1D 00D24F00	    db  0
                        	TAB10:
FFFC3A1E 0000D24F	    db  "O",'R'+0x80
FFFC3A20 3C800000	    db  0
                        	
                        	;* Execution address tables:
                        	; We save some bytes by specifiying only the low order 16 bits of the address
                        	;
FFFC3A21 483C8000		align	
                        	
                        	TAB1_1:
FFFC3A22 41483C80		dh	LISTX			;Direct commands
FFFC3A24 3B284148		dh	LOAD3
FFFC3A26 3B503B28		dh	NEW
FFFC3A28 41B03B50		dh	RUN
FFFC3A2A 3E7C41B0		dh	SAVE3
                        	TAB2_1:
FFFC3A2C 40003E7C		dh	NEXT		;	Direct / statement
FFFC3A2E 3EF44000		dh	LET
FFFC3A30 3BE43EF4		dh	IF0
FFFC3A32 3D683BE4		dh	GOTO
FFFC3A34 3DAC3D68		dh	GOSUB
FFFC3A36 3F003DAC		dh	RETURN
FFFC3A38 3DF03F00		dh	IF2			; REM
FFFC3A3A 3F343DF0		dh	FOR
FFFC3A3C 3CC83F34		dh	INPUT
FFFC3A3E 430C3CC8		dh	PRINT
FFFC3A40 4338430C		dh	POKE
FFFC3A42 43644338		dh	POKEW
FFFC3A44 3B444364		dh	POKEH
FFFC3A46 3B3C3B44		dh	YIELD0
FFFC3A48 37203B3C		dh	STOP
FFFC3A4A 439C3720		dh	GOBYE
FFFC3A4C 02CB439C		dh	SYSX
FFFC3A4E 3C0802CB		dh	_cls
FFFC3A50 02CD3C08		dh  _clr
FFFC3A52 3C4802CD		dh	_rdcf
FFFC3A54 3C703C48		dh  ONIRQ
FFFC3A56 3FF43C70		dh	WAITIRQ
FFFC3A58 49B83FF4		dh	DEFLT
                        	TAB4_1:
FFFC3A5A 49D049B8		dh	PEEK			;Functions
FFFC3A5C 49E849D0		dh	PEEKW
FFFC3A5E 4A4049E8		dh	PEEKH
FFFC3A60 00004A40		dh	RND
FFFC3A62 4AD40000		dh	ABS
FFFC3A64 4AC04AD4		dh  SGN
FFFC3A66 4B104AC0		dh	TICKX
FFFC3A68 4A004B10		dh	SIZEX
FFFC3A6A 527C4A00		dh  USRX
FFFC3A6C 52EC527C		dh	ALLOCMBX
FFFC3A6E 538852EC		dh	SENDMSG
FFFC3A70 47945388		dh	WAITMSG
FFFC3A72 3E104794		dh	XP40
                        	TAB5_1
FFFC3A74 4C183E10		dh	FR1			;"TO" in "FOR"
FFFC3A76 3E2C4C18		dh	QWHAT
                        	TAB6_1
FFFC3A78 3E343E2C		dh	FR2			;"STEP" in "FOR"
FFFC3A7A 454C3E34		dh	FR3
                        	TAB8_1
FFFC3A7C 4564454C		dh	XP11	;>=		Relational operators
FFFC3A7E 457C4564		dh	XP12	;<>
FFFC3A80 45AC457C		dh	XP13	;>
FFFC3A82 459445AC		dh	XP15	;=
FFFC3A84 45C44594		dh	XP14	;<=
FFFC3A86 460445C4		dh	XP16	;<
FFFC3A88 445C4604		dh	XP17
                        	TAB9_1
FFFC3A8A 4470445C	    dh  XP_AND
FFFC3A8C 43FC4470	    dh  XP_ANDX
                        	TAB10_1
FFFC3A8E 441043FC	    dh  XP_OR
FFFC3A90 00004410	    dh  XP_ORX
                        	
                        	;*
                        	; r3 = match flag (trashed)
                        	; r9 = text table
                        	; r10 = exec table
                        	; r11 = trashed
FFFC3A92 00000000		align	1
FFFC3A96 00000000
FFFC3A9A 00000000
FFFC3A9E 4EB70000
                        	
                        	//message "DIRECT"
                        	DIRECT:
FFFC3AA0 FFFC4EB7		ldi		$t3,#TAB1
FFFC3AA4 964E8E93
FFFC3AA8 FFFC4F37		ldi		$t4,#TAB1_1
FFFC3AAC A22F0F13
                        	EXEC:
FFFC3AB0 6D4010EF		call	IGNBLK		; ignore leading blanks
FFFC3AB4 000E6FB3		mov		$t5,$t2		; save the pointer
FFFC3AB8 000061B3		mov		r3,r0		; clear match flag
                        	EXLP:
FFFC3ABC 000E4903		lbu		a0,[$t2]		; get the program character
FFFC3AC0 001E0E13		add		$t2,$t2,#1
FFFC3AC4 000EC983		lbu		a1,[$t3]		; get the table character
FFFC3AC8 00099663		bne		a1,x0,EXNGO		; If end of table,
FFFC3ACC 000FEE33		mov		$t2,$t5		;	restore the text pointer and...
FFFC3AD0 04000263		bra		EXGO		;   execute the default.
                        	EXNGO:
FFFC3AD4 04390063		beq		a0,r3,EXGO	; Else check for period... if so, execute
FFFC3AD8 07F9F993		and		a1,a1,#0x7f	; ignore the table's high bit
FFFC3ADC 03298263		beq		a1,a0,EXMAT	;		is there a match?
FFFC3AE0 002F0F13		add		$t4,$t4,#2	;if not, try the next entry
FFFC3AE4 000FEE33		mov		$t2,$t5		; reset the program pointer
FFFC3AE8 000061B3		mov		r3,x0		; sorry, no match
                        	EX1:
FFFC3AEC 000EC903		lbu		a0,[$t3]		; get to the end of the entry
FFFC3AF0 001E8E93		add		$t3,$t3,#1
FFFC3AF4 08097D93		and		$t1,$a0,#$80
FFFC3AF8 FE0D8AE3		beq		$t1,$r0,EX1	; test for bit 7 set
FFFC3AFC FC0000E3		bra		EXLP		; back for more matching
                        	EXMAT:
FFFC3B00 02E06193		ldi		r3,#'.'		; we've got a match so far
FFFC3B04 000EC903		lbu		a0,[$t3]		; end of table entry?
FFFC3B08 001E8E93		add		$t3,$t3,#1
FFFC3B0C 08097D93		and		$t1,$a0,#$80
FFFC3B10 FA0D86E3		beq		$t1,$r0,EXLP		; test for bit 7 set, if not, go back for more
                        	EXGO:
                        		; execute the appropriate routine
FFFC3B14 000F5903		lhu		a0,[$t4]	; get the low mid order byte
FFFC3B18 FFFC0637		or		a0,a0,#$FFFC0000	; add in ROM base
FFFC3B1C 00060613
FFFC3B20 01266933
FFFC3B24 00090067		jmp		[a0]
                        	
                        	    
                        	;******************************************************************
                        	;
                        	; What follows is the code to execute direct and statement
                        	; commands. Control is transferred to these points via the command
                        	; table lookup code of 'DIRECT' and 'EXEC' in the last section.
                        	; After the command is executed, control is transferred to other
                        	; sections as follows:
                        	;
                        	; For 'LISTX', 'NEW', and 'STOP': go back to the warm start point.
                        	; For 'RUN': go execute the first stored line if any; else go
                        	; back to the warm start point.
                        	; For 'GOTO' and 'GOSUB': go execute the target line.
                        	; For 'RETURN' and 'NEXT'; go back to saved return line.
                        	; For all others: if 'CURRNT' is 0, go to warm start; else go
                        	; execute next command. (This is done in 'FINISH'.)
                        	;
                        	;******************************************************************
                        	;
                        	; *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                        	;
                        	; 'NEW<CR>' sets TXTUNF to point to TXTBGN
                        	;
                        	
                        	NEW:
FFFC3B28 0A8010EF		call	ENDCHK
FFFC3B2C 00002837		ldi		v0,#TXTBGN
FFFC3B30 80080813
FFFC3B34 71002223		sw		v0,TXTUNF	;	set the end pointer
FFFC3B38 0D8000EF		call  clearVars
                        	
                        	; 'STOP<CR>' goes back to WSTART
                        	;
                        	STOP:
FFFC3B3C 094010EF		call	ENDCHK
FFFC3B40 C81FF06F		jmp		WSTART		; WSTART will reset the stack
                        	
                        	;------------------------------------------------------------------------------
                        	; YIELD suspends execution of TinyBasic by switching to the next ready task.
                        	;------------------------------------------------------------------------------
                        	
                        	YIELD0:
FFFC3B44 00D06913		ldi		a0,#13
FFFC3B48 00000073		ecall
FFFC3B4C 2140006F		jmp		FINISH
                        	
                        	;------------------------------------------------------------------------------
                        	; 'RUN<CR>' finds the first stored line, stores its address
                        	; in CURRNT, and starts executing it. Note that only those
                        	; commands in TAB2 are legal for a stored program.
                        	;
                        	; There are 3 more entries in 'RUN':
                        	; 'RUNNXL' finds next line, stores it's address and executes it.
                        	; 'RUNTSL' stores the address of this line and executes it.
                        	; 'RUNSML' continues the execution on same line.
                        	;
                        	RUN:
FFFC3B50 080010EF		call	ENDCHK
FFFC3B54 00002E37		ldi		$t2,#TXTBGN	;	set pointer to beginning
FFFC3B58 800E0E13
FFFC3B5C 71C02C23		sw		$t2,CURRNT
FFFC3B60 0B0000EF		call  clearVars
                        	
                        	RUNNXL:					; RUN <next line>
FFFC3B64 71802E03		lw		$t2,CURRNT	; executing a program?
FFFC3B68 000E1463		bne		$t2,x0,RUN3	; if not, we've finished a direct stat.
                        	RUN2:
FFFC3B6C C55FF06F		jmp		WSTART
                        	RUN3:
FFFC3B70 7A402903		lw		a0,IRQROUT		; are we handling IRQ's ?
FFFC3B74 02090E63		beq		a0,x0,RUN1
FFFC3B78 7B402D83		lw		$t1,IRQFlag		; was there an IRQ ?
FFFC3B7C 020D8A63		beq		$t1,x0,RUN1
FFFC3B80 7A002A23		sw		x0,IRQFlag
FFFC3B84 2D0010EF		call	PUSHA_		; the same code as a GOSUB
FFFC3B88 FF470713		sub		$sp,$sp,#12
FFFC3B8C 71402903		lw		a0,STKGOS
FFFC3B90 01272023		sw		a0,[$sp]
FFFC3B94 71802903		lw		a0,CURRNT
FFFC3B98 01272223		sw		a0,4[$sp]
FFFC3B9C 01C72423		sw		$t2,8[$sp]
FFFC3BA0 70002823		sw		x0,LOPVAR		; load new values
FFFC3BA4 70E02A23		sw		$sp,STKGOS
FFFC3BA8 7A402E83		lw		$t3,IRQROUT
FFFC3BAC 00000C63		bra		RUNTSL
                        	RUN1:
FFFC3BB0 000E6EB3		mov		$t3,$t2
FFFC3BB4 00006933		mov		a0,x0
FFFC3BB8 1C0010EF		call	FNDLNP		; else find the next line number
FFFC3BBC 70402D83		lw		$t1,TXTUNF	; if we've fallen off the end, stop
FFFC3BC0 FBBEF6E3		bgeu	$t3,$t1,RUN2
                        	
                        	RUNTSL:					; RUN <this line>
FFFC3BC4 71D02C23		sw		$t3,CURRNT	; set CURRNT to point to the line no.
FFFC3BC8 004E8E13		add		$t2,$t3,#4	; set the text pointer to
                        	
                        	RUNSML:                 ; RUN <same line>
FFFC3BCC 668010EF		call	CHKIO		; see if a control-C was pressed
FFFC3BD0 FFFC4EB7		ldi		$t3,#TAB2		; find command in TAB2
FFFC3BD4 976E8E93
FFFC3BD8 FFFC4F37		ldi		$t4,#TAB2_1
FFFC3BDC A2CF0F13
FFFC3BE0 ED1FF06F		jmp		EXEC		; and execute it
                        	
                        	
                        	;******************************************************************
                        	; 'GOTO expr<CR>' evaluates the expression, finds the target
                        	; line, and jumps to 'RUNTSL' to do it.
                        	;******************************************************************
                        	;
                        	GOTO:
FFFC3BE4 7E4000EF		call	OREXPR		;evaluate the following expression
FFFC3BE8 000862B3		mov   r5,v0
FFFC3BEC 7E5000EF		call 	ENDCHK		;must find end of line
FFFC3BF0 0002E933		mov   a0,r5
FFFC3BF4 164010EF		call 	FNDLN		; find the target line
FFFC3BF8 FC0816E3		bne		v0,x0,RUNTSL; go do it
FFFC3BFC FFFC5937		ldi		a0,#msgBadGotoGosub
FFFC3C00 60590913
FFFC3C04 01C0106F		jmp		ERROR		; no such line no.
                        	
                        	_clr:
FFFC3C08 008000EF	    call    clearVars
FFFC3C0C 1540006F	    jmp     FINISH
                        	
                        	; Clear the variable area of memory
                        	clearVars:
FFFC3C10 FF870713		sub		$sp,$sp,#8
FFFC3C14 00672023		sw		r6,[$sp]
FFFC3C18 00172223		sw		$ra,4[$sp]
FFFC3C1C 06406313	  ldi   r6,#100    	; number of word pairs to clear
FFFC3C20 70802803	  lw    v0,VARBGN
                        	.cv1:
FFFC3C24 00082023	  sw		x0,[$v0]		; variable name
FFFC3C28 00082223	  sw		x0,4[$v0]		; and value
FFFC3C2C 00880813	  add		v0,v0,#8
FFFC3C30 FFF30313	  sub		r6,r6,#1
FFFC3C34 FE6048E3		bgt		r6,x0,.cv1
FFFC3C38 00072303	  lw		r6,[$sp]
FFFC3C3C 00472083	  lw		$ra,4[$sp]
FFFC3C40 00870713	  add		$sp,$sp,#8
FFFC3C44 00008067	  ret
                        	
                        	;******************************************************************
                        	; ONIRQ <line number>
                        	; ONIRQ sets up an interrupt handler which acts like a specialized
                        	; subroutine call. ONIRQ is coded like a GOTO that never executes.
                        	;******************************************************************
                        	;
                        	ONIRQ:
FFFC3C48 780000EF		call	OREXPR		;evaluate the following expression
FFFC3C4C 000862B3		mov   r5,v0
FFFC3C50 781000EF		call 	ENDCHK		;must find end of line
FFFC3C54 0002E933		mov   a0,r5
FFFC3C58 100010EF		call 	FNDLN		; find the target line
FFFC3C5C 00081663		bne		v0,r0,ONIRQ1
FFFC3C60 7A002223		sw		x0,IRQROUT
FFFC3C64 0FC0006F		jmp		FINISH
                        	ONIRQ1:
FFFC3C68 7BD02223		sw		$t3,IRQROUT
FFFC3C6C 0F40006F		jmp		FINISH
                        	
                        	WAITIRQ:
FFFC3C70 5C4010EF		call	CHKIO		; see if a control-C was pressed
FFFC3C74 7B402D83		lw		$t1,IRQFlag
FFFC3C78 FE0D8CE3		beq		$t1,x0,WAITIRQ
FFFC3C7C 0E40006F		jmp		FINISH
                        	
                        	
                        	;******************************************************************
                        	; LIST
                        	;
                        	; LISTX has two forms:
                        	; 'LIST<CR>' lists all saved lines
                        	; 'LIST #<CR>' starts listing at the line #
                        	; Control-S pauses the listing, control-C stops it.
                        	;******************************************************************
                        	;
                        	LISTX:
FFFC3C80 490010EF		call		TSTNUM		; see if there's a line no.
FFFC3C84 000862B3		mov      r5,v0
FFFC3C88 749000EF		call		ENDCHK		; if not, we get a zero
FFFC3C8C 0002E933		mov      a0,r5
FFFC3C90 0C8010EF		call		FNDLN		; find this or next line
                        	LS1:
FFFC3C94 00081663		bne		v0,r0,LS4
                        	LS5:
FFFC3C98 70402D83		lw		$t1,TXTUNF
FFFC3C9C B3BEF2E3		bgeu	$t3,$t1,WSTART	; warm start if we passed the end
                        	LS4:
FFFC3CA0 000EE933		mov		a0,$t3
FFFC3CA4 3C4010EF		call	PRTLN		; print the line
FFFC3CA8 00086EB3		mov		$t3,$v0		; set pointer for next
FFFC3CAC 588010EF		call	CHKIO		; check for listing halt request
FFFC3CB0 00080A63		beq		v0,x0,LS3
FFFC3CB4 01306D93		ldi		$t1,#CTRLS
FFFC3CB8 01B81663		bne		v0,$t1,LS3; pause the listing?
                        	LS2:
FFFC3CBC 578010EF		call 	CHKIO		; if so, wait for another keypress
FFFC3CC0 FE080EE3		beq		v0,r0,LS2
                        	LS3:
                        	;	mov		$v0,$x0
FFFC3CC4 FC000AE3		bra		LS5
                        	;	mov		a0,r0
                        	;	call	FNDSKP	;FNDLNP		; find the next line
                        	;	bra		LS1
                        	
                        	
                        	;******************************************************************
                        	; PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                        	; where '....' is a list of expressions, formats, back-arrows,
                        	; and strings.	These items a separated by commas.
                        	;
                        	; A format is a pound sign followed by a number.  It controls
                        	; the number of spaces the value of an expression is going to
                        	; be printed in.  It stays effective for the rest of the print
                        	; command unless changed by another format.  If no format is
                        	; specified, 11 positions will be used.
                        	;
                        	; A string is quoted in a pair of single- or double-quotes.
                        	;
                        	; An underline (back-arrow) means generate a <CR> without a <LF>
                        	;
                        	; A <CR LF> is generated after the entire list has been printed
                        	; or if the list is empty.  If the list ends with a semicolon,
                        	; however, no <CR LF> is generated.
                        	;******************************************************************
                        	;
                        	PRINT:
FFFC3CC8 00B06293		ldi		r5,#11		; D4 = number of print spaces
FFFC3CCC 3F8010EF		call	TSTC		; if null list and ":"
FFFC3CD0 0000003A		dw		':'
FFFC3CD4 00000663		bra		PR2
FFFC3CD8 584010EF		call	CRLF		; give CR-LF and continue
FFFC3CDC EF1FF06F		jmp		RUNSML		;		execution on the same line
                        	PR2:
FFFC3CE0 3E4010EF		call	TSTC		;if null list and <CR>
FFFC3CE4 0000000D		dw		CR
FFFC3CE8 00000663		bra		PR0
FFFC3CEC 570010EF		call	CRLF		;also give CR-LF and
FFFC3CF0 E75FF06F		jmp		RUNNXL		;execute the next line
                        	PR0:
FFFC3CF4 3D0010EF		call	TSTC		;else is it a format?
FFFC3CF8 00000023		dw		'#'
FFFC3CFC 00000863		bra		PR1
FFFC3D00 6C8000EF		call	OREXPR		; yes, evaluate expression
FFFC3D04 000862B3		mov		r5,v0	; and save it as print width
FFFC3D08 02000263		bra		PR3		; look for more to print
                        	PR1:
FFFC3D0C 3B8010EF		call	TSTC	;	is character expression? (MRL)
FFFC3D10 00000024		dw		'$'
FFFC3D14 00000863		bra		PR4
FFFC3D18 6B0000EF		call	OREXPR	;	yep. Evaluate expression (MRL)
FFFC3D1C 9EDFF0EF		call	GOOUT	;	print low byte (MRL)
FFFC3D20 00000663		bra		PR3		;look for more. (MRL)
                        	PR4:
FFFC3D24 1DC010EF		call	QTSTG	;	is it a string?
                        		; the following branch must occupy only 1 word!
FFFC3D28 02000063		bra		PR8		;	if not, must be an expression
                        	PR3:
FFFC3D2C 398010EF		call		TSTC	;	if ",", go find next
FFFC3D30 0000002C		dw		','
FFFC3D34 00000663		bra		PR6
FFFC3D38 65D000EF		call		FIN		;in the list.
FFFC3D3C FA000CE3		bra		PR0
                        	PR6:
FFFC3D40 51C010EF		call		CRLF		;list ends here
FFFC3D44 01C0006F		jmp		FINISH
                        	PR8:
FFFC3D48 680000EF		call	OREXPR		; evaluate the expression
FFFC3D4C 00086933		mov		a0,v0
FFFC3D50 00506993		ldi		a1,#5		; set the width
FFFC3D54 00A06A13		ldi		a2,#10
FFFC3D58 23C010EF		call	PRTNUM		; print its value
FFFC3D5C FC0008E3		bra		PR3			; more to print?
                        	
                        	
                        	FINISH:
FFFC3D60 635000EF		call	FIN		; Check end of command
FFFC3D64 6B50006F		jmp		QWHAT	; print "What?" if wrong
                        	
                        	
                        	;*******************************************************************
                        	;
                        	; *** GOSUB *** & RETURN ***
                        	;
                        	; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                        	; except that the current text pointer, stack pointer, etc. are
                        	; saved so that execution can be continued after the subroutine
                        	; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                        	; recursive), the save area must be stacked.  The stack pointer
                        	; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                        	; If we are in the main routine, 'STKGOS' is zero (this was done
                        	; in the initialization section of the interpreter), but we still
                        	; save it as a flag for no further 'RETURN's.
                        	;******************************************************************
                        	;
                        	GOSUB:
FFFC3D68 0EC010EF		call	PUSHA_		; save the current 'FOR' parameters
FFFC3D6C 65C000EF		call	OREXPR		; get line number
FFFC3D70 00086933		mov		$a0,$v0
FFFC3D74 7E5000EF		call	FNDLN		; find the target line
FFFC3D78 00081863		bne		v0,r0,gosub1
FFFC3D7C FFFC5937		ldi		a0,#msgBadGotoGosub
FFFC3D80 60590913
FFFC3D84 69D0006F		jmp		ERROR		; if not there, say "How?"
                        	gosub1:
FFFC3D88 FF470713		sub		$sp,$sp,#12
FFFC3D8C 71402903		lw		a0,STKGOS	; 'STKGOS'
FFFC3D90 01272023		sw		a0,[$sp]
FFFC3D94 71802903		lw		a0,CURRNT	; found it, save old 'CURRNT'...
FFFC3D98 01272223		sw		a0,4[$sp]
FFFC3D9C 01C72423		sw		$t2,8[$sp]
FFFC3DA0 70002823		sw		$x0,LOPVAR		; load new values
FFFC3DA4 70E02A23		sw		$sp,STKGOS
FFFC3DA8 E1DFF06F		jmp		RUNTSL
                        	
                        	
                        	;******************************************************************
                        	; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                        	; returns the execution to the command after the most recent
                        	; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                        	; a 'GOSUB' and is thus an error.
                        	;******************************************************************
                        	;
                        	RETURN:
FFFC3DAC 625000EF		call	ENDCHK		; there should be just a <CR>
FFFC3DB0 71402983		lw		a1,STKGOS		; get old stack pointer
FFFC3DB4 00099863		bne		a1,x0,return1
FFFC3DB8 FFFC5937		ldi		a0,#msgRetWoGosub
FFFC3DBC 62190913
FFFC3DC0 6610006F		jmp		ERROR		; if zero, it doesn't exist
                        	return1:
FFFC3DC4 0009E733		mov		$sp,a1		; else restore it
FFFC3DC8 00072903		lw		a0,[$sp]
FFFC3DCC 00470713		add		$sp,$sp,#4
FFFC3DD0 71202A23		sw		a0,STKGOS	; and the old 'STKGOS'
FFFC3DD4 00072903		lw		a0,[$sp]
FFFC3DD8 00470713		add		$sp,$sp,#4
FFFC3DDC 71202C23		sw		a0,CURRNT	; and the old 'CURRNT'
FFFC3DE0 00072E03		lw		$t2,[$sp]	; and the old text pointer
FFFC3DE4 00470713		add		$sp,$sp,#4
FFFC3DE8 034010EF		call	POPA_		;and the old 'FOR' parameters
FFFC3DEC F75FF06F		jmp		FINISH		;and we are back home
                        	
                        	;******************************************************************
                        	; *** FOR *** & NEXT ***
                        	;
                        	; 'FOR' has two forms:
                        	; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                        	; The second form means the same thing as the first form with a
                        	; STEP of positive 1.  The interpreter will find the variable 'var'
                        	; and set its value to the current value of 'exp1'.  It also
                        	; evaluates 'exp2' and 'exp1' and saves all these together with
                        	; the text pointer, etc. in the 'FOR' save area, which consists of
                        	; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                        	; already something in the save area (indicated by a non-zero
                        	; 'LOPVAR'), then the old save area is saved on the stack before
                        	; the new values are stored.  The interpreter will then dig in the
                        	; stack and find out if this same variable was used in another
                        	; currently active 'FOR' loop.  If that is the case, then the old
                        	; 'FOR' loop is deactivated. (i.e. purged from the stack)
                        	;******************************************************************
                        	;
                        	FOR:
FFFC3DF0 064010EF		call	PUSHA_		; save the old 'FOR' save area
FFFC3DF4 539000EF		call	SETVAL		; set the control variable
FFFC3DF8 71002823		sw		v0,LOPVAR		; save its address
FFFC3DFC FFFC4EB7		ldi		$t3,#TAB5
FFFC3E00 A08E8E93
FFFC3E04 FFFC4F37		ldi		$t4,#TAB5_1	; use 'EXEC' to test for 'TO'
FFFC3E08 A74F0F13
FFFC3E0C CA5FF06F		jmp		EXEC
                        	FR1:
FFFC3E10 5B8000EF		call	OREXPR		; evaluate the limit
FFFC3E14 77002E23		sw		v0,LOPLMT	; save that
FFFC3E18 FFFC4EB7		ldi		$t3,#TAB6
FFFC3E1C A0BE8E93
FFFC3E20 FFFC4F37		ldi		$t4,#TAB6_1	; use 'EXEC' to test for the word 'STEP
FFFC3E24 A78F0F13
FFFC3E28 C89FF06F		jmp		EXEC
                        	FR2:
FFFC3E2C 59C000EF		call	OREXPR		; found it, get the step value
FFFC3E30 00000463		bra		FR4
                        	FR3:
FFFC3E34 00106813		ldi		v0,#1		; not found, step defaults to 1
                        	FR4:
FFFC3E38 77002C23		sw		v0,LOPINC	; save that too
                        	FR5:
FFFC3E3C 71802983		lw		a1,CURRNT
FFFC3E40 77302A23		sw		a1,LOPLN	; save address of current line number
FFFC3E44 77C02823		sw		$t2,LOPPT	; and text pointer
FFFC3E48 000761B3		mov		r3,$sp		; dig into the stack to find 'LOPVAR'
FFFC3E4C 71002303		lw		r6,LOPVAR
FFFC3E50 00000463		bra		FR7
                        	FR6:
FFFC3E54 01418193		add		r3,r3,#20	; look at next stack frame
                        	FR7:
FFFC3E58 0001A983		lw		a1,[r3]		; is it zero?
FFFC3E5C 00098E63		beq		a1,x0,FR8	; if so, we're done
FFFC3E60 FE699AE3		bne		a1,r6,FR6	; same as current LOPVAR? nope, look some more
                        	
FFFC3E64 0001E933	  mov		a0,r3	   ; Else remove 5 words from...
FFFC3E68 000769B3		mov		a1,$sp
FFFC3E6C 01418A13		add		a2,r3,#20  ; inside the stack.
FFFC3E70 7A5000EF		call	MVDOWN
FFFC3E74 01470713		add		$sp,$sp,#20	; set the SP 5 long words up
                        	;	lw		a0,[$sp]		; ???
                        	;	add		$sp,$sp,#4
                        	FR8:
FFFC3E78 EE9FF06F	  jmp	    FINISH		; and continue execution
                        	
                        	
                        	;******************************************************************
                        	; 'NEXT var' serves as the logical (not necessarily physical) end
                        	; of the 'FOR' loop.  The control variable 'var' is checked with
                        	; the 'LOPVAR'.  If they are not the same, the interpreter digs in
                        	; the stack to find the right one and purges all those that didn't
                        	; match.  Either way, it then adds the 'STEP' to that variable and
                        	; checks the result with against the limit value.  If it is within
                        	; the limit, control loops back to the command following the
                        	; 'FOR'.  If it's outside the limit, the save area is purged and
                        	; execution continues.
                        	;******************************************************************
                        	;
                        	NEXT:
FFFC3E7C 00006933		mov		a0,x0		; don't allocate it
FFFC3E80 189000EF		call	TSTV		; get address of variable
FFFC3E84 00081863		bne		v0,x0,NX4
FFFC3E88 FFFC5937		ldi		a0,#msgNextVar
FFFC3E8C 5E290913
FFFC3E90 580008E3		bra		ERROR		; if no variable, say "What?"
                        	NX4:
FFFC3E94 00086EB3		mov		$t3,v0	; save variable's address
                        	NX0:
FFFC3E98 71002903		lw		a0,LOPVAR	; If 'LOPVAR' is zero, we never...
FFFC3E9C 00091863		bne		a0,x0,NX5	; had a FOR loop
FFFC3EA0 FFFC5937		ldi		a0,#msgNextFor
FFFC3EA4 5D090913
FFFC3EA8 56000CE3		bra		ERROR
                        	NX5:
FFFC3EAC 01D90663		beq		a0,$t3,NX2	; else we check them OK, they agree
FFFC3EB0 76D000EF		call	POPA_		; nope, let's see the next frame
FFFC3EB4 FE0002E3		bra		NX0
                        	NX2:
FFFC3EB8 000EA903		lw		a0,[$t3]		; get control variable's value
FFFC3EBC 77802983		lw		a1,LOPINC
FFFC3EC0 01390933		add		a0,a0,a1	; add in loop increment
                        	;	BVS.L	QHOW		say "How?" for 32-bit overflow
FFFC3EC4 012EA023		sw		a0,[$t3]		; save control variable's new value
FFFC3EC8 77C02183		lw		r3,LOPLMT	; get loop's limit value
FFFC3ECC 0009D663		bge		a1,x0,NX1	; check loop increment, branch if loop increment is positive
FFFC3ED0 00394E63		blt		a0,r3,NXPurge	; test against limit
FFFC3ED4 00000463		bra     NX3
                        	NX1:
FFFC3ED8 0121CA63		bgt		a0,r3,NXPurge
                        	NX3:
FFFC3EDC 77402E03		lw		$t2,LOPLN	; Within limit, go back to the...
FFFC3EE0 71C02C23		sw		$t2,CURRNT
FFFC3EE4 77002E03		lw		$t2,LOPPT	; saved 'CURRNT' and text pointer.
FFFC3EE8 E79FF06F		jmp		FINISH
                        	NXPurge:
FFFC3EEC 731000EF	  call    POPA_        ; purge this loop
FFFC3EF0 E71FF06F	  jmp     FINISH
                        	
                        	
                        	;******************************************************************
                        	; *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                        	;
                        	; 'REM' can be followed by anything and is ignored by the
                        	; interpreter.
                        	;
                        	;REM
                        	;    br	    IF2		    ; skip the rest of the line
                        	; 'IF' is followed by an expression, as a condition and one or
                        	; more commands (including other 'IF's) separated by colons.
                        	; Note that the word 'THEN' is not used.  The interpreter evaluates
                        	; the expression.  If it is non-zero, execution continues.  If it
                        	; is zero, the commands that follow are ignored and execution
                        	; continues on the next line.
                        	;******************************************************************
                        	;
                        	IF0:
FFFC3EF4 4D4000EF	  call	OREXPR		; evaluate the expression
                        	IF1:
FFFC3EF8 00080463	  beq	  v0,x0,IF2	; is it zero? if not, continue
FFFC3EFC CD1FF06F	  jmp		RUNSML
                        	IF2:
FFFC3F00 000E6EB3	  mov		$t3,$t2	; set lookup pointer
FFFC3F04 00006933		mov		a0,x0		; find line #0 (impossible)
FFFC3F08 6D1000EF		call	FNDSKP		; if so, skip the rest of the line
FFFC3F0C 00081463		bne		v0,x0,IF3; if no next line, do a warm start
FFFC3F10 8B1FF06F		jmp		WSTART
                        	IF3:
FFFC3F14 CB1FF06F		jmp		RUNTSL		; run the next line
                        	
                        	
                        	;******************************************************************
                        	; INPUT is called first and establishes a stack frame
                        	INPERR:
FFFC3F18 79802703		lw		$sp,STKINP		; restore the old stack pointer
FFFC3F1C 00072903		lw		a0,[$sp]
FFFC3F20 00470713		add		$sp,$sp,#4
FFFC3F24 71202C23		sw		a0,CURRNT		; and old 'CURRNT'
FFFC3F28 00072E03		lw		$t2,[$sp]		; and old text pointer
FFFC3F2C 00470713		add		$sp,$sp,#4
FFFC3F30 01470713		add		$sp,$sp,#20	; fall through will subtract 20
                        	
                        	; 'INPUT' is like the 'PRINT' command, and is followed by a list
                        	; of items.  If the item is a string in single or double quotes,
                        	; or is an underline (back arrow), it has the same effect as in
                        	; 'PRINT'.  If an item is a variable, this variable name is
                        	; printed out followed by a colon, then the interpreter waits for
                        	; an expression to be typed in.  The variable is then set to the
                        	; value of this expression.  If the variable is preceeded by a
                        	; string (again in single or double quotes), the string will be
                        	; displayed followed by a colon.  The interpreter the waits for an
                        	; expression to be entered and sets the variable equal to the
                        	; expression's value.  If the input expression is invalid, the
                        	; interpreter will print "What?", "How?", or "Sorry" and reprint
                        	; the prompt and redo the input.  The execution will not terminate
                        	; unless you press control-C.  This is handled in 'INPERR'.
                        	;
                        	INPUT:
FFFC3F34 FEC70713		sub		$sp,$sp,#20	; allocate five words on stack
FFFC3F38 00572823		sw		r5,16[$sp]	; save off r5 into stack var
                        	IP6:
FFFC3F3C 01C72023		sw		$t2,[$sp]	; save in case of error
FFFC3F40 7C1000EF		call	QTSTG		; is next item a string?
FFFC3F44 00000C63		bra		IP2			; nope - this branch must take only 1 word
FFFC3F48 00106913		ldi		a0,#1		; allocate var
FFFC3F4C 0BD000EF		call	TSTV		; yes, but is it followed by a variable?
FFFC3F50 08090463		beq    a0,r0,IP4   ; if not, brnch
FFFC3F54 00096F33		mov		$t4,a0		; put away the variable's address
FFFC3F58 04000063		bra		IP3			; if so, input to variable
                        	IP2:
FFFC3F5C 01C72223		sw		$t2,4[$sp]	; save off in stack var for 'PRTSTG'
FFFC3F60 00106913		ldi		a0,#1
FFFC3F64 0A5000EF		call	TSTV		; must be a variable now
FFFC3F68 00091A63		bne		a0,r0,IP7
FFFC3F6C FFFC5937		ldi		a0,#msgInputVar
FFFC3F70 5B490913
FFFC3F74 01470713		add		$sp,$sp,#20	; cleanup stack
FFFC3F78 4A0004E3		bra		ERROR		; "What?" it isn't?
                        	IP7:
FFFC3F7C 00096F33		mov		$t4,a0		; put away the variable's address
FFFC3F80 000E4283		lbu		r5,[$t2]		; get ready for 'PRTSTG' by null terminating
FFFC3F84 000E0023		sb		x0,[$t2]
FFFC3F88 000069B3		mov		a1,x0
FFFC3F8C 00472903		lw		a0,4[$sp]	; get back text pointer
FFFC3F90 709000EF		call	PRTSTG		; print string as prompt
FFFC3F94 005E0023		sb		r5,[$t2]		; un-null terminate
                        	IP3
FFFC3F98 01C72223		sw		$t2,4[$sp]	; save in case of error
FFFC3F9C 71802903		lw		a0,CURRNT
FFFC3FA0 01272423		sw		a0,8[$sp]	; also save 'CURRNT'
FFFC3FA4 FFF06913		ldi		a0,#-1
FFFC3FA8 71202C23		sw		a0,CURRNT	; flag that we are in INPUT
FFFC3FAC 78E02C23		sw		$sp,STKINP	; save the stack pointer too
FFFC3FB0 01E72623		sw		$t4,12[$sp]	; save the variable address
FFFC3FB4 03A06913		ldi		a0,#':'		; print a colon first
FFFC3FB8 4AD000EF		call	GETLN		; then get an input line
FFFC3FBC 71C06E13		ldi		$t2,#BUFFER	; point to the buffer
FFFC3FC0 408000EF		call	OREXPR		; evaluate the input
FFFC3FC4 00C72F03		lw		$t4,12[$sp]	; restore the variable address
FFFC3FC8 012F2023		sw		a0,[$t4]	; save value in variable
FFFC3FCC 00872903		lw		a0,8[$sp]	; restore old 'CURRNT'
FFFC3FD0 71202C23		sw		a0,CURRNT
FFFC3FD4 00472E03		lw		$t2,4[$sp]	; and the old text pointer
                        	IP4:
FFFC3FD8 0EC010EF		call	TSTC
FFFC3FDC 0000002C		dw		','
FFFC3FE0 00000463		bra		IP5
FFFC3FE4 F4000CE3		bra		IP6			; yes, more items
                        	IP5:
FFFC3FE8 01072283		lw		r5,16[$sp]
FFFC3FEC 01470713		add		$sp,$sp,#20	; cleanup stack
FFFC3FF0 D71FF06F	 	jmp		FINISH
                        	
                        	
                        	DEFLT:
FFFC3FF4 000E4903	  lbu    	a0,[$t2]
FFFC3FF8 00D06D93	  ldi			$t1,#CR
FFFC3FFC D7B902E3		beq	    a0,$t1,FINISH	    ; empty line is OK else it is 'LET'
                        	
                        	
                        	;******************************************************************
                        	; 'LET' is followed by a list of items separated by commas.
                        	; Each item consists of a variable, an equals sign, and an
                        	; expression.  The interpreter evaluates the expression and sets
                        	; the variable to that value.  The interpreter will also handle
                        	; 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                        	;******************************************************************
                        	;
                        	LET:
FFFC4000 32D000EF	  call	SETVAL		; do the assignment
FFFC4004 0C0010EF		call	TSTC		; check for more 'LET' items
FFFC4008 0000002C		dw		','
FFFC400C D55FF06F		jmp		FINISH
FFFC4010 FE0008E3		bra	    LET
                        	LT1:
FFFC4014 D4DFF06F	  jmp	    FINISH		; until we are finished.
                        	
                        	
                        	;******************************************************************
                        	; *** LOAD *** & SAVE ***
                        	;
                        	; These two commands transfer a program to/from an auxiliary
                        	; device such as a cassette, another computer, etc.  The program
                        	; is converted to an easily-stored format: each line starts with
                        	; a colon, the line no. as 4 hex digits, and the rest of the line.
                        	; At the end, a line starting with an '@' sign is sent.  This
                        	; format can be read back with a minimum of processing time by
                        	; the RTF65002
                        	;******************************************************************
                        	;
                        	LOAD
FFFC4018 00002E37		ldi		$t2,#TXTBGN	; set pointer to start of prog. area
FFFC401C 800E0E13
FFFC4020 00D06913		ldi		a0,#CR		; For a CP/M host, tell it we're ready...
FFFC4024 EECFF0EF		call	GOAUXO		; by sending a CR to finish PIP command.
                        	LOD1:
FFFC4028 EF0FF0EF		call	GOAUXI		; look for start of line
FFFC402C FF205EE3		ble		a0,r0,LOD1
FFFC4030 04006D93		ldi		$t1,#'@'
FFFC4034 03B90E63		beq		a0,$t1,LODEND	; end of program?
FFFC4038 01A06D93		ldi		$t1,#$1A
FFFC403C 03B90A63		beq		a0,$t1,LODEND	; or EOF marker
FFFC4040 03A06D93		ldi		$t1,#':'
FFFC4044 FFB912E3		bne		a0,$t1,LOD1	; if not, is it start of line? if not, wait for it
FFFC4048 030000EF		call	GCHAR		; get line number
FFFC404C 012E2023		sw		a0,[$t2]		; store it
FFFC4050 004E0E13		add		$t2,$t2,#4
                        	LOD2:
FFFC4054 EC4FF0EF		call	GOAUXI		; get another text char.
FFFC4058 FF205EE3		ble		a0,r0,LOD2
FFFC405C 012E0023		sb		a0,[$t2]		; store it
FFFC4060 001E0E13		add		$t2,$t2,#1
FFFC4064 00D06D93		ldi		$t1,#CR
FFFC4068 FFB916E3		bne		a0,$t1,LOD2		; is it the end of the line? if not, go back for more
FFFC406C FA000EE3		bra		LOD1		; if so, start a new line
                        	LODEND:
FFFC4070 71C02223		sw		$t2,TXTUNF	; set end-of program pointer
FFFC4074 F4CFF06F		jmp		WSTART		; back to direct mode
                        	
                        	
                        	; get character from input (32 bit value)
                        	GCHAR:
FFFC4078 FF470713		sub		$sp,$sp,#12
FFFC407C 00572023		sw		r5,[$sp]
FFFC4080 00672223		sw		r6,4[$sp]
FFFC4084 00172423		sw		$ra,8[$sp]
FFFC4088 00806313		ldi		r6,#8       ; repeat ten times
FFFC408C 00006293		ldi		r5,#0
                        	GCHAR1:
FFFC4090 E88FF0EF		call	GOAUXI		; get a char
FFFC4094 FF205EE3		ble		a0,r0,GCHAR1
FFFC4098 02C000EF		call	asciiToHex
FFFC409C 00429293		sll		r5,r5,#4
FFFC40A0 0122E2B3		or		r5,r5,a0
FFFC40A4 FFF30313		sub		r6,r6,#1
FFFC40A8 FE6064E3		bgtu	r6,r0,GCHAR1
FFFC40AC 0002E933		mov		a0,r5
FFFC40B0 00072283		lw		r5,[$sp]
FFFC40B4 00472303		lw		r6,4[$sp]
FFFC40B8 00872083		lw		$ra,8[$sp]
FFFC40BC 00C70713		add		$sp,$sp,#12
FFFC40C0 00008067		ret
                        	
                        	; convert an ascii char to hex code
                        	; input
                        	;	a0 = char to convert
                        	
                        	asciiToHex:
FFFC40C4 03906D93		ldi		$t1,#'9'
FFFC40C8 012DF463		bleu	a0,$t1,a2h1; less than '9'
FFFC40CC FF990913		sub		a0,a0,#7	; shift 'A' to '9'+1
                        	a2h1:
FFFC40D0 FD090913		sub		a0,a0,#'0'
FFFC40D4 00F97913		and		a0,a0,#15	; make sure a nybble
FFFC40D8 00008067		ret
                        	
                        	GetFilename:
FFFC40DC FFC70713		sub		$sp,$sp,#4
FFFC40E0 00172023		sw		$ra,[$sp]
FFFC40E4 7E1000EF		call	TSTC
FFFC40E8 00000022		dw		'"'
FFFC40EC 04000C63		bra		gfn1
FFFC40F0 000061B3		mov		r3,r0
                        	gfn2:
FFFC40F4 000E4903		lbu		a0,[$t2]		; get text character
FFFC40F8 001E0E13		add		$t2,$t2,#1
FFFC40FC 02206D93		ldi		$t1,#'"'
FFFC4100 03B90263		beq		a0,$t1,gfn3
FFFC4104 02090063		beq		a0,r0,gfn3
FFFC4108 6D218023		sb		a0,FILENAME[r3]
FFFC410C 00118193		add		r3,r3,#1
FFFC4110 04006D93		ldi		$t1,#64
FFFC4114 FFB1E0E3		bltu	r3,$t1,gfn2
FFFC4118 00072083		lw		$ra,[$sp]
FFFC411C 00470713		add		$sp,$sp,#4
FFFC4120 00008067		ret
                        	gfn3:
FFFC4124 02006913		ldi		a0,#' '
FFFC4128 6D218023		sb		a0,FILENAME[r3]
FFFC412C 00118193		add		r3,r3,#1
FFFC4130 04006D93		ldi		$t1,#64
FFFC4134 FFB1E8E3		bltu	r3,$t1,gfn3
FFFC4138 00072083		lw		$ra,[$sp]
FFFC413C 00470713		add		$sp,$sp,#4
FFFC4140 00008067		ret
                        	gfn1:
FFFC4144 E7CFF06F		jmp		WSTART
                        	
                        	LOAD3:
FFFC4148 F95FF0EF		call	GetFilename
FFFC414C 00000637		call	AUXIN_INIT
FFFC4150 346600E7
FFFC4154 EC5FF06F		jmp		LOAD
                        	
                        	;	call		OREXPR		;evaluate the following expression
                        	;	ld		a0,#5000
FFFC4158 000019B7		ldi		a1,#$E00
FFFC415C E0098993
FFFC4160 00000637		call	SDReadSector
FFFC4164 347600E7
FFFC4168 00190913		add		a0,a0,#1
FFFC416C 000029B7		ldi		a1,#TXTBGN
FFFC4170 80098993
                        	LOAD4:
FFFC4174 FFC70713		sub		$sp,$sp,#4
FFFC4178 01272023		sw		a0,[$sp]
FFFC417C 00000637		call	SDReadSector
FFFC4180 347600E7
FFFC4184 20098993		add		a1,a1,#512
FFFC4188 00072903		lw		a0,[$sp]
FFFC418C 00470713		add		$sp,$sp,#4
FFFC4190 00190913		add		a0,a0,#1
FFFC4194 00002237		ldi		r4,#TXTBGN
FFFC4198 80020213
FFFC419C 00010637		add		r4,r4,#65536
FFFC41A0 00060613
FFFC41A4 00460233
FFFC41A8 FC49C6E3		blt		a1,r4,LOAD4
                        	LOAD5:
FFFC41AC E0000A63		bra		WSTART
                        	
                        	
                        	SAVE3:
FFFC41B0 F2DFF0EF		call	GetFilename
FFFC41B4 00000637		call	AUXOUT_INIT
FFFC41B8 34A600E7
FFFC41BC 0600006F		jmp		SAVE
                        	
FFFC41C0 208000EF		call	OREXPR		;evaluate the following expression
                        	;	lda		#5000		; starting sector
FFFC41C4 000019B7		ldi		a1,#$E00	; starting address to write
FFFC41C8 E0098993
FFFC41CC 00000637		call	SDWriteSector
FFFC41D0 34C600E7
FFFC41D4 00190913		add		a0,a0,#1
FFFC41D8 000029B7		ldi		a1,#TXTBGN
FFFC41DC 80098993
                        	SAVE4:
FFFC41E0 FFC70713		sub		$sp,$sp,#4
FFFC41E4 01272023		sw		a0,[$sp]
FFFC41E8 00000637		call	SDWriteSector
FFFC41EC 34C600E7
FFFC41F0 20098993		add		a1,a1,#512
FFFC41F4 00072903		lw		a0,[$sp]
FFFC41F8 00470713		add		$sp,$sp,#4
FFFC41FC 00190913		add		a0,a0,#1
FFFC4200 00002237		ldi		r4,#TXTBGN
FFFC4204 80020213
FFFC4208 00010637		add		r4,r4,#65536
FFFC420C 00060613
FFFC4210 00460233
FFFC4214 FC49C6E3		blt		a1,r4,SAVE4
FFFC4218 DA000463		bra		WSTART
                        	
                        	SAVE:
FFFC421C 00002E37		ldi		$t2,#TXTBGN	;set pointer to start of prog. area
FFFC4220 800E0E13
FFFC4224 70402E83		lw		$t3,TXTUNF	;set pointer to end of prog. area
                        	SAVE1:
FFFC4228 054000EF		call	AUXOCRLF    ; send out a CR & LF (CP/M likes this)
FFFC422C 03CEC863		bgt		$t2,$t3,SAVEND; are we finished?
FFFC4230 03A06913		ldi		a0,#':'		; if not, start a line
FFFC4234 CDCFF0EF		call	GOAUXO
FFFC4238 000E2903		lw		a0,[$t2]		; get line number
FFFC423C 004E0E13		add		$t2,$t2,#4
FFFC4240 060000EF		call	PWORD       ; output line number as 5-digit hex
                        	SAVE2:
FFFC4244 000E4903		lbu		a0,[$t2]		; get a text char.
FFFC4248 001E0E13		add		$t2,$t2,#1
FFFC424C 00D06D93		ldi		$t1,#CR
FFFC4250 FDB90CE3		beq		a0,$t1,SAVE1	; is it the end of the line? if so, send CR & LF and start new line
FFFC4254 CBCFF0EF		call	GOAUXO		; send it out
FFFC4258 FE0006E3		bra		SAVE2		; go back for more text
                        	SAVEND:
FFFC425C 04006913		ldi		a0,#'@'		; send end-of-program indicator
FFFC4260 CB0FF0EF		call	GOAUXO
FFFC4264 018000EF		call	AUXOCRLF    ; followed by a CR & LF
FFFC4268 01A06913		ldi		a0,#$1A		; and a control-Z to end the CP/M file
FFFC426C CA4FF0EF		call	GOAUXO
FFFC4270 00000637		call	AUXOUT_FLUSH
FFFC4274 353600E7
FFFC4278 D4000463		bra		WSTART		; then go do a warm start
                        	
                        	; output a CR LF sequence to auxillary output
                        	; Registers Affected
                        	;   r3 = LF
                        	AUXOCRLF:
FFFC427C FFC70713		sub		$sp,$sp,#4
FFFC4280 00172023		sw		$ra,[$sp]
FFFC4284 00D06913	  ldi		a0,#CR
FFFC4288 C88FF0EF	  call	GOAUXO
FFFC428C 00A06913	  ldi		a0,#LINEFD
FFFC4290 C80FF0EF	  call	GOAUXO
FFFC4294 00072083	  lw		$ra,[$sp]
FFFC4298 00470713	  add		$sp,$sp,#4
FFFC429C 00008067	  ret
                        	
                        	
                        	; output a word in hex format
                        	; tricky because of the need to reverse the order of the chars
                        	PWORD:
FFFC42A0 FF870713		sub		$sp,$sp,#8
FFFC42A4 00572023		sw		r5,[$sp]
FFFC42A8 00172223		sw		$ra,4[$sp]
FFFC42AC 7A206293		ldi		r5,#NUMWKA+14
FFFC42B0 00096233		mov		r4,a0		; r4 = value
                        	pword1:
FFFC42B4 00026933	  mov   a0,r4	    ; a0 = value
FFFC42B8 00425213	  srl		r4,r4,#4	; shift over to next nybble
FFFC42BC 038000EF	  call	toAsciiHex  ; convert LS nybble to ascii hex
FFFC42C0 01228023	  sb    a0,[r5]		; save in work area
FFFC42C4 FFF28293	  sub		r5,r5,#1
FFFC42C8 79406D93	  ldi		$t1,#NUMWKA
FFFC42CC FFB2D4E3		bge		r5,$t1,pword1
                        	pword2:
FFFC42D0 00128293	  add		r5,r5,#1
FFFC42D4 0002C903	  lbu   a0,[r5]     ; get char to output
FFFC42D8 C38FF0EF		call	GOAUXO		; send it
FFFC42DC 7A206D93		ldi		$t1,#NUMWKA+14
FFFC42E0 FFB2C8E3		blt		r5,$t1,pword2
FFFC42E4 00072283		lw		r5,[$sp]
FFFC42E8 00472083		lw		$ra,4[$sp]
FFFC42EC 00870713		add		$sp,$sp,#8
FFFC42F0 00008067		ret
                        	
                        	; convert nybble in a1 to ascii hex chaa1
                        	; a1 = character to convert
                        	
                        	toAsciiHex:
FFFC42F4 00F97913		and		a0,a0,#15	; make sure it's a nybble
FFFC42F8 00A06D93		ldi		$t1,#10
FFFC42FC 01B94463		blt		a0,$t1,tah1	; > 10 ?
FFFC4300 00790913		add		a0,a0,#7	; bump it up to the letter 'A'
                        	tah1:
FFFC4304 03090913		add		a0,a0,#'0'	; bump up to ascii '0'
FFFC4308 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	; *** POKE ***
                        	;
                        	; 'POKE expr1,expa1' stores the byte from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEW expr1,expa1' stores the word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEH expr1,expa1' stores the half-word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	;******************************************************************
                        	;
                        	POKE:
FFFC430C 0BC000EF		call	OREXPR		; get the memory address
FFFC4310 5B5000EF		call	TSTC		; it must be followed by a comma
FFFC4314 0000002C		dw		','
FFFC4318 06000C63		bra		PKER
FFFC431C FFC70713		sub		$sp,$sp,#4
FFFC4320 01272023		sw		a0,[$sp]	; save the address
FFFC4324 0A4000EF		call	OREXPR		; get the byte to be POKE'd
FFFC4328 00072983		lw		a1,[$sp]	; get the address back
FFFC432C 00470713		add		$sp,$sp,#4
FFFC4330 01298023		sb		a0,[a1]		; store the byte in memory
FFFC4334 A2DFF06F		jmp		FINISH
                        	
                        	POKEW:
FFFC4338 090000EF		call	OREXPR		; get the memory address
FFFC433C 589000EF		call	TSTC		; it must be followed by a comma
FFFC4340 0000002C		dw		','
FFFC4344 04000663		bra		PKER
FFFC4348 FFC70713		sub		$sp,$sp,#4
FFFC434C 01272023		sw		a0,[$sp]	; save the address
FFFC4350 078000EF		call	OREXPR		; get the byte to be POKE'd
FFFC4354 00072983		lw		a1,[$sp]	; get the address back
FFFC4358 00470713		add		$sp,$sp,#4
FFFC435C 0129A023		sw		a0,[a1]		; store the byte in memory
FFFC4360 A01FF06F		jmp		FINISH
                        	
                        	POKEH:
FFFC4364 064000EF		call	OREXPR		; get the memory address
FFFC4368 55D000EF		call	TSTC		; it must be followed by a comma
FFFC436C 0000002C		dw		','
FFFC4370 02000063		bra		PKER
FFFC4374 FFC70713		sub		$sp,$sp,#4
FFFC4378 01272023		sw		a0,[$sp]	; save the address
FFFC437C 04C000EF		call	OREXPR		; get the byte to be POKE'd
FFFC4380 00072983		lw		a1,[$sp]	; get the address back
FFFC4384 00470713		add		$sp,$sp,#4
FFFC4388 01299023		sh		a0,[a1]		; store the byte in memory
FFFC438C 9D5FF06F		jmp		FINISH
                        	
                        	PKER:
FFFC4390 FFFC5937		ldi		a0,#msgComma
FFFC4394 55290913
FFFC4398 0890006F		jmp		ERROR		; if no comma, say "What?"
                        	
                        	;******************************************************************
                        	; 'SYSX expr' jumps to the machine language subroutine whose
                        	; starting address is specified by 'expr'.  The subroutine can use
                        	; all registers but must leave the stack the way it found it.
                        	; The subroutine returns to the interpreter by executing an RTS.
                        	;******************************************************************
                        	
                        	SYSX:
FFFC439C 02C000EF		call	OREXPR		; get the subroutine's address
FFFC43A0 00081863		bne		v0,r0,sysx1; make sure we got a valid address
FFFC43A4 FFFC5937		ldi		a0,#msgSYSBad
FFFC43A8 5A390913
FFFC43AC 0750006F		jmp		ERROR
                        	sysx1:
FFFC43B0 FFC70713		sub		$sp,$sp,#4
FFFC43B4 01C72023		stt		$t2,[$sp]	; save the text pointer
FFFC43B8 000800E7		call	[v0]			; jump to the subroutine
FFFC43BC 00072E03		ldt		$t2,[$sp]	; restore the text pointer
FFFC43C0 00470713		add		$sp,$sp,#4
FFFC43C4 99DFF06F		jmp		FINISH
                        	
                        	;******************************************************************
                        	; *** EXPR ***
                        	;
                        	; 'EXPR' evaluates arithmetical or logical expressions.
                        	; <OREXPR>::= <ANDEXPR> OR <ANDEXPR> ...
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	; <EXPR>::=<ADDEXPR>
                        	;	   <ADDEXPR><rel.op.><ADDEXPR>
                        	; where <rel.op.> is one of the operators in TAB8 and the result
                        	; of these operations is 1 if true and 0 if false.
                        	; <ADDEXPR>::=(+ or -)<MULEXPR>(+ or -)<MULEXPR>(...
                        	; where () are optional and (... are optional repeats.
                        	; <MULEXPR>::=<FUNCEXPR>( <* or /><FUNCEXPR> )(...
                        	; <FUNCEXPR>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                        	; as an index, functions can have an <EXPR> as arguments, and
                        	; <FUNCEXPR> can be an <EXPR> in parenthesis.
                        	;
                        	
                        	; <OREXPR>::=<ANDEXPR> OR <ANDEXPR> ...
                        	;
                        	OREXPR:
FFFC43C8 FF470713		sub		$sp,$sp,#12
FFFC43CC 00172023		sw		$ra,[$sp]
FFFC43D0 00372223		sw		r3,4[$sp]
FFFC43D4 00472423		sw		r4,8[$sp]
FFFC43D8 058000EF		call	ANDEXPR		; get first <ANDEXPR>
                        	XP_OR1:
FFFC43DC FF870713		sub		$sp,$sp,#8
FFFC43E0 01072023		sw		$v0,[$sp]		; save <ANDEXPR> value
FFFC43E4 01172223		sw		$v1,4[$sp]	; save type
FFFC43E8 FFFC4EB7		ldi		$t3,#TAB10	; look up a logical operator
FFFC43EC A1EE8E93
FFFC43F0 FFFC4F37		ldi		$t4,#TAB10_1
FFFC43F4 A8EF0F13
FFFC43F8 EB8FF06F		jmp		EXEC		; go do it
                        	XP_OR:
FFFC43FC 034000EF	  call	ANDEXPR
FFFC4400 00072903	  lw		$a0,[$sp]
FFFC4404 00870713	  add		$sp,$sp,#8
FFFC4408 01286833	  or    v0,v0,a0
FFFC440C FC0008E3	  bra   XP_OR1
                        	XP_ORX:
FFFC4410 00072803	  lw		$v0,[$sp]
FFFC4414 00472883	  lw		$v1,4[$sp]
FFFC4418 00870713	  add		$sp,$sp,#8
FFFC441C 00072083		lw		$ra,[$sp]
FFFC4420 00472183		lw		r3,4[$sp]
FFFC4424 00872203		lw		r4,8[$sp]
FFFC4428 00C70713		add		$sp,$sp,#12
FFFC442C 00008067	  ret
                        	
                        	
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	;
                        	ANDEXPR:
FFFC4430 FFC70713		sub		$sp,$sp,#4
FFFC4434 00172023		sw		$ra,[$sp]
FFFC4438 0E8000EF		call	EXPR		; get first <EXPR>
                        	XP_AND1:
FFFC443C FF870713		sub		$sp,$sp,#8
FFFC4440 01072023		sw		$v0,[$sp]		; save <EXPR> value
FFFC4444 01172223		sw		$v1,4[$sp]	; save type
FFFC4448 FFFC4EB7		ldi		$t3,#TAB9		; look up a logical operator
FFFC444C A1AE8E93
FFFC4450 FFFC4F37		ldi		$t4,#TAB9_1
FFFC4454 A8AF0F13
FFFC4458 E58FF06F		jmp		EXEC		; go do it
                        	XP_AND:
FFFC445C 0C4000EF	  call	EXPR
FFFC4460 00072903	  lw		$a0,[$sp]
FFFC4464 00870713	  add		$sp,$sp,#8
FFFC4468 01287833	  and   v0,v0,a0
FFFC446C FC0008E3	  bra   XP_AND1
                        	XP_ANDX:
FFFC4470 00072803	  lw		$v0,[$sp]
FFFC4474 00472883	  lw		$v1,4[$sp]
FFFC4478 00870713	  add		$sp,$sp,#8
FFFC447C 00072083		lw		$ra,[$sp]
FFFC4480 00470713		add		$sp,$sp,#4
FFFC4484 00008067	  ret
                        	
                        	
                        	; Determine if the character is a digit
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if digit, otherwise 0
                        	;
                        	isDigit:
FFFC4488 03006D93		ldi		$t1,#'0'
FFFC448C 01B94A63		blt		a0,$t1,isDigitFalse
FFFC4490 03906D93		ldi		$t1,#'9'
FFFC4494 012DC663		bgt		a0,$t1,isDigitFalse
FFFC4498 00106813		ldi		v0,#1
FFFC449C 00008067	  ret
                        	isDigitFalse:
FFFC44A0 00006833	  mov		v0,r0
FFFC44A4 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphabetic
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlpha:
FFFC44A8 04106D93		ldi		$t1,#'A'
FFFC44AC 03B94263		blt		a0,$t1,isAlphaFalse
FFFC44B0 05A06D93		ldi		$t1,#'Z'
FFFC44B4 012DDA63		ble		a0,$t1,isAlphaTrue
FFFC44B8 06106D93		ldi		$t1,#'a'
FFFC44BC 01B94A63		blt		a0,$t1,isAlphaFalse
FFFC44C0 07A06D93		ldi		$t1,#'z'
FFFC44C4 012DC663		bgt		a0,$t1,isAlphaFalse
                        	isAlphaTrue:
FFFC44C8 00106813	  ldi		v0,#1
FFFC44CC 00008067	  ret
                        	isAlphaFalse:
FFFC44D0 00006833	  mov		v0,r0
FFFC44D4 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphanumeric
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlnum:
FFFC44D8 FFC70713		sub		$sp,$sp,#4
FFFC44DC 00172023		sw		$ra,[$sp]
FFFC44E0 FA9FF0EF	  call	isDigit
FFFC44E4 00081463		bne		v0,r0,isDigitx	; if it is a digit
FFFC44E8 FC1FF0EF	  call  isAlpha
                        	isDigitx:
FFFC44EC 00072083		lw		$ra,[$sp]
FFFC44F0 00470713		add		$sp,$sp,#4
FFFC44F4 00008067	  ret
                        	
                        	FORCEFIT:
FFFC44F8 03198263		beq		a1,v1,.0001				; types match
FFFC44FC 00006D13		ldi		$t0,#0
FFFC4500 01A98663		beq		a1,$t0,.intAnd
                        	;	itof	$f1,$v0
FFFC4504 00106913		ldi		a0,#1
FFFC4508 00008067		ret
                        	.intAnd:
FFFC450C 00106D13		ldi		$t0,#1
FFFC4510 01A89663		bne		$v1,$t0,.0001
                        	;	itof	$f2,$a1
FFFC4514 00106993		ldi		$a1,#1
FFFC4518 00008067		ret
                        	.0001:
FFFC451C 00008067		ret
                        	
                        	EXPR:
FFFC4520 FFC70713		sub		$sp,$sp,#4
FFFC4524 00172023		sw		$ra,[$sp]
FFFC4528 11C000EF		call	ADDEXPR
FFFC452C FF870713		sub		$sp,$sp,#8				; save <ADDEXPR> value
FFFC4530 01072023		sw		v0,[$sp]
FFFC4534 01172223		sw		v1,4[$sp]					; save type
FFFC4538 FFFC4EB7		ldi		$t3,#TAB8		; look up a relational operator
FFFC453C A10E8E93
FFFC4540 FFFC4F37		ldi		$t4,#TAB8_1
FFFC4544 A7CF0F13
FFFC4548 D68FF06F		jmp		EXEC		; go do it
                        	XP11:
FFFC454C 00072903		lw		a0,[$sp]
FFFC4550 00472983		lw		a1,4[$sp]
FFFC4554 00870713		add		$sp,$sp,#8
FFFC4558 0C4000EF		call	XP18	; is it ">="?
FFFC455C 09095A63		bge		a0,v0,XPRT1	; no, return v0=1
FFFC4560 06000E63		bra		XPRT0	; else return v0=0
                        	XP12:
FFFC4564 00072903		lw		a0,[$sp]
FFFC4568 00472983		lw		a1,4[$sp]
FFFC456C 00870713		add		$sp,$sp,#8
FFFC4570 0AC000EF		call	XP18	; is it "<>"?
FFFC4574 07091E63		bne		a0,v0,XPRT1	; no, return a1=1
FFFC4578 06000263		bra		XPRT0	; else return a1=0
                        	XP13:
FFFC457C 00072903		lw		a0,[$sp]
FFFC4580 00472983		lw		a1,4[$sp]
FFFC4584 00870713		add		$sp,$sp,#8
FFFC4588 094000EF		call	XP18	; is it ">"?
FFFC458C 07284263		bgt		a0,v0,XPRT1	; no, return a1=1
FFFC4590 04000663		bra		XPRT0	; else return a1=0
                        	XP14:
FFFC4594 00072903		lw		a0,[$sp]
FFFC4598 00472983		lw		a1,4[$sp]
FFFC459C 00870713		add		$sp,$sp,#8
FFFC45A0 07C000EF		call	XP18	; is it "<="?
FFFC45A4 05285663		ble		a0,v0,XPRT1	; no, return a1=1
FFFC45A8 02000A63		bra		XPRT0	; else return a1=0
                        	XP15:
FFFC45AC 00072903		lw		a0,[$sp]
FFFC45B0 00472983		lw		a1,4[$sp]
FFFC45B4 00870713		add		$sp,$sp,#8
FFFC45B8 064000EF		call	XP18	; is it "="?
FFFC45BC 03090A63		beq		a0,v0,XPRT1	; if not, return a1=1
FFFC45C0 00000E63		bra		XPRT0	; else return a1=0
                        	XP16:
FFFC45C4 00072903		lw		a0,[$sp]
FFFC45C8 00472983		lw		a1,4[$sp]
FFFC45CC 00870713		add		$sp,$sp,#8
FFFC45D0 04C000EF		call	XP18	; is it "<"?
FFFC45D4 01094E63		blt		a0,v0,XPRT1	; if not, return a1=1
FFFC45D8 00000263		bra		XPRT0	; else return a1=0
                        	XPRT0:
FFFC45DC 00006833		mov		v0,x0   ; return a0=0 (false)
FFFC45E0 000068B3		mov		v1,x0		; type = int
FFFC45E4 00072083		lw		$ra,[$sp]
FFFC45E8 00470713		add		$sp,$sp,#4
FFFC45EC 00008067		ret
                        	XPRT1:
FFFC45F0 00106813		ldi		v0,#1	; return a0=1 (true)
FFFC45F4 00006893		ldi		v1,#0	; type = int
FFFC45F8 00072083		lw		$ra,[$sp]
FFFC45FC 00470713		add		$sp,$sp,#4
FFFC4600 00008067		ret
                        	
                        	XP17:				; it's not a rel. operator
FFFC4604 00072803		lw		v0,[$sp]; return a1=<ADDEXPR>
FFFC4608 00472883		lw		v1,4[$sp]
FFFC460C 00870713		add		$sp,$sp,#8
FFFC4610 00072083		lw		$ra,[$sp]
FFFC4614 00470713		add		$sp,$sp,#4
FFFC4618 00008067		ret
                        	
                        	XP18:
FFFC461C FF470713		sub		$sp,$sp,#12
FFFC4620 00172023		sw		$ra,[$sp]
FFFC4624 01072223		sw		v0,4[$sp]
FFFC4628 01172423		sw		v1,8[$sp]
FFFC462C 018000EF		call	ADDEXPR		; do a second <ADDEXPR>
FFFC4630 00472903		lw		a0,4[$sp]
FFFC4634 00872983		lw		a1,8[$sp]
FFFC4638 00072083		lw		$ra,[$sp]
FFFC463C 00C70713		add		$sp,$sp,#12
FFFC4640 00008067		ret
                        	
                        	; <ADDEXPR>::=(+ or -)<MULEXPR>(+ or -)<MULEXPR>(...
                        	//message "ADDEXPR"
                        	ADDEXPR:
FFFC4644 FFC70713		sub		$sp,$sp,#4
FFFC4648 00172023		sw		$ra,[$sp]
FFFC464C 279000EF		call	TSTC		; negative sign?
FFFC4650 0000002D		dw		'-'
FFFC4654 00000C63		bra		XP21
FFFC4658 00006833		mov		v0,r0		; yes, fake '0-'
FFFC465C FF870713		sub		$sp,$sp,#8
FFFC4660 01072023		sw		v0,[$sp]
FFFC4664 01172223		sw		v1,4[$sp]
FFFC4668 04000863		bra		XP26
                        	XP21:
FFFC466C 259000EF		call	TSTC		; positive sign? ignore it
FFFC4670 0000002B		dw		'+'
FFFC4674 00000263		bra		XP22
                        	XP22:
FFFC4678 064000EF		call	MULEXPR		; first <MULEXPR>
                        	XP23:
FFFC467C FF870713		sub		$sp,$sp,#8; yes, save the value
FFFC4680 01072023		sw		v0,[$sp]
FFFC4684 01172223		sw		v1,4[$sp]	; and type
FFFC4688 23D000EF		call	TSTC		; add?
FFFC468C 0000002B		dw		'+'
FFFC4690 00000E63		bra		XP25
FFFC4694 048000EF		call	MULEXPR		; get the second <MULEXPR>
                        	XP24:
FFFC4698 00072903		lw		a0,[$sp]
FFFC469C 00472983		lw		a1,4[$sp]
FFFC46A0 00870713		add		$sp,$sp,#8
FFFC46A4 01280833		add		v0,v0,a0	; add it to the first <MULEXPR>
                        	;	BVS.L	QHOW		brnch if there's an overflow
FFFC46A8 FC000AE3		bra		XP23		; else go back for more operations
                        	XP25:
FFFC46AC 219000EF		call	TSTC		; subtract?
FFFC46B0 0000002D		dw		'-'
FFFC46B4 00000863		bra		XP45
                        	XP26:
FFFC46B8 024000EF		call	MULEXPR		; get second <MULEXPR>
FFFC46BC 41000833		sub		v0,r0,v0	; change its sign
FFFC46C0 FC000CE3		bra		XP24		; and do an addition
                        	XP45:
FFFC46C4 00072803		lw		v0,[$sp]
FFFC46C8 00472883		lw		v1,4[$sp]
FFFC46CC 00870713		add		$sp,$sp,#8
FFFC46D0 00072083		lw		$ra,[$sp]
FFFC46D4 00470713		add		$sp,$sp,#4
FFFC46D8 00008067		ret
                        	
                        	
                        	; <MULEXPR>::=<FUNCEXPR>( <* or /><FUNCEXPR> )(...
                        	
                        	MULEXPR:
FFFC46DC FFC70713		sub		$sp,$sp,#4
FFFC46E0 00172023		sw		$ra,[$sp]
FFFC46E4 094000EF		call	FUNCEXPR		; get first <FUNCEXPR>
                        	XP31:
FFFC46E8 FF870713		sub		$sp,$sp,#8
FFFC46EC 01072023		sw		v0,[$sp]; yes, save that first result
FFFC46F0 01172223		sw		v1,4[$sp]
FFFC46F4 1D1000EF		call	TSTC		; multiply?
FFFC46F8 0000002A		dw		'*'
FFFC46FC 00000E63		bra		XP34
FFFC4700 078000EF		call	FUNCEXPR		; get second <FUNCEXPR>
FFFC4704 00072903		lw		a0,[$sp]
FFFC4708 00472983		lw		a1,4[$sp]
FFFC470C 00870713		add		$sp,$sp,#8
FFFC4710 03280833		mul		v0,v0,a0	; multiply the two
FFFC4714 FC000AE3		bra		XP31        ; then look for more terms
                        	XP34:
FFFC4718 1AD000EF		call	TSTC		; divide?
FFFC471C 0000002F		dw		'/'
FFFC4720 00000E63		bra		XP35
FFFC4724 054000EF		call	FUNCEXPR		; get second <FUNCEXPR>
FFFC4728 00072903		lw		a0,[$sp]
FFFC472C 00472983		lw		a1,4[$sp]
FFFC4730 00870713		add		$sp,$sp,#8
FFFC4734 03284833		div		v0,v0,a0	; do the division
FFFC4738 FA0008E3		bra		XP31		; go back for any more terms
                        	XP35:
FFFC473C 189000EF		call	TSTC
FFFC4740 00000025		dw		'%'
FFFC4744 00000E63		bra		XP47
FFFC4748 030000EF		call	FUNCEXPR
FFFC474C 00072903		lw		a0,[$sp]
FFFC4750 00472983		lw		a1,4[$sp]
FFFC4754 00870713		add		$sp,$sp,#8
FFFC4758 03286833		rem		v0,v0,a0
FFFC475C F80006E3		bra		XP31
                        	XP47:
FFFC4760 00072803		lw		v0,[$sp]
FFFC4764 00472883		lw		v1,4[$sp]
FFFC4768 00870713		add		$sp,$sp,#8
FFFC476C 00072083		lw		$ra,[$sp]
FFFC4770 00470713		add		$sp,$sp,#4
FFFC4774 00008067		ret
                        	
                        	
                        	; Functions are called through FUNCEXPR
                        	; <FUNCEXPR>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	
                        	FUNCEXPR:
FFFC4778 FFC70713		sub		$sp,$sp,#4
FFFC477C 00172023		sw		$ra,[$sp]
FFFC4780 FFFC4EB7	  ldi		$t3,#TAB4		; find possible function
FFFC4784 9CFE8E93
FFFC4788 FFFC4F37	  ldi		$t4,#TAB4_1
FFFC478C A5AF0F13
FFFC4790 B20FF06F		jmp		EXEC        ; branch to function which does subsequent ret for FUNCEXPR
                        	XP40:                   ; we get here if it wasn't a function
FFFC4794 00006933		mov		a0,x0
FFFC4798 070000EF		call	TSTV
FFFC479C 00080A63		beq   v0,x0,XP41	; not a variable
FFFC47A0 00082803		lw		$v0,[$v0]		; if a variable, return its value in v0
FFFC47A4 00072083		lw		$ra,[$sp]
FFFC47A8 00470713		add		$sp,$sp,#4
FFFC47AC 00008067		ret
                        	XP41:
FFFC47B0 161000EF		call	TSTNUM		; or is it a number?
FFFC47B4 00089463		bne		v1,x0,XP46	; (if not, # of digits will be zero) if so, return it in v0
FFFC47B8 010000EF		call	PARN        ; check for (EXPR)
                        	XP46:
FFFC47BC 00072083		lw		$ra,[$sp]
FFFC47C0 00470713		add		$sp,$sp,#4
FFFC47C4 00008067		ret
                        	
                        	
                        	; Check for a parenthesized expression
                        	PARN:
FFFC47C8 FFC70713		sub		$sp,$sp,#4
FFFC47CC 00172023		sw		$ra,[$sp]	
FFFC47D0 0F5000EF		call	TSTC		; else look for ( OREXPR )
FFFC47D4 00000028		dw		'('
FFFC47D8 02000063		bra		XP43
FFFC47DC BEDFF0EF		call	OREXPR
FFFC47E0 0E5000EF		call	TSTC
FFFC47E4 00000029		dw		')'
FFFC47E8 00000863		bra		XP43
                        	XP42:
FFFC47EC 00072083		lw		$ra,[$sp]
FFFC47F0 00470713		add		$sp,$sp,#4
FFFC47F4 00008067		ret
                        	XP43:
FFFC47F8 00470713		add		$sp,$sp,#4		; get rid of return address
FFFC47FC FFFC5937		ldi		a0,#msgWhat
FFFC4800 4D890913
FFFC4804 41C0006F		jmp		ERROR
                        	
                        	
                        	; ===== Test for a valid variable name.  Returns Z=1 if not
                        	;	found, else returns Z=0 and the address of the
                        	;	variable in a0.
                        	; Parameters
                        	;		a0 = 1 = allocate if not found
                        	; Returns
                        	;		v0 = address of variable, zero if not found
                        	
                        	TSTV:
FFFC4808 FF870713		sub		$sp,$sp,#8
FFFC480C 00572023		sw		r5,[$sp]
FFFC4810 00172223		sw		$ra,4[$sp]
FFFC4814 000962B3		mov		r5,a0		; r5=allocate flag
FFFC4818 16D000EF		call	IGNBLK
FFFC481C 000E4903		lbu		a0,[$t2]		; look at the program text
FFFC4820 04006D93		ldi		$t1,#'@'
FFFC4824 07B94263		blt		a0,$t1,tstv_notfound	; C=1: not a variable
FFFC4828 03B91E63		bne		a0,$t1,TV1				; brnch if not "@" array
FFFC482C 001E0E13		add		$t2,$t2,#1	; If it is, it should be
FFFC4830 F99FF0EF		call	PARN		; followed by (EXPR) as its index.
                        	;	BCS.L	QHOW		say "How?" if index is too big
FFFC4834 00000263		bra		TV3
                        	TV3:
FFFC4838 FFC70713		sub		$sp,$sp,#4	; save the index
FFFC483C 01072023		sw		v0,[$sp]
FFFC4840 2D0000EF		call	SIZEX		; get amount of free memory
FFFC4844 00072983		lw		a1,[$sp]
FFFC4848 00470713		add		$sp,$sp,#4	; get back the index
FFFC484C 0109C663		blt		a1,v0,TV2		; see if there's enough memory
FFFC4850 00870713		add		$sp,$sp,#8
FFFC4854 3B80006F		jmp   QSORRY		; if not, say "Sorry"
                        	TV2:
FFFC4858 70802903		lw		a0,VARBGN	; put address of array element...
FFFC485C 41390833		sub   v0,a0,a1    ; into a0 (neg. offset is used)
FFFC4860 00000C63		bra   TSTVRT
                        	TV1:	
FFFC4864 038000EF	  call	getVarName      ; get variable name
FFFC4868 00080863	  beq   v0,x0,TSTVRT    ; if not, return v0=0
FFFC486C 00086933	  mov		a0,v0
FFFC4870 0002E9B3	  mov		a1,r5
FFFC4874 0D4000EF	  call	findVar     ; find or allocate
                        	TSTVRT:
FFFC4878 00072283		lw		r5,[$sp]
FFFC487C 00472083		lw		$ra,4[$sp]
FFFC4880 00870713		add		$sp,$sp,#8
FFFC4884 00008067		ret								; v0<>0 (if found)
                        	tstv_notfound:
FFFC4888 00072283		lw		r5,[$sp]
FFFC488C 00472083		lw		$ra,4[$sp]
FFFC4890 00870713		add		$sp,$sp,#8
FFFC4894 00006833		mov		v0,x0				; v0=0 if not found
FFFC4898 00008067	  ret
                        	
                        	; Get a variable name. Called after blanks have been ignored.
                        	;
                        	; Returns
                        	;   v0 = 3 character variable name + type
                        	;
                        	getVarName:
FFFC489C FF470713		sub		$sp,$sp,#12
FFFC48A0 00572023		sw		r5,[$sp]
FFFC48A4 00172223		sw		$ra,4[$sp]
FFFC48A8 000E4903	  lbu   a0,[$t2]		; get first character
FFFC48AC 01272423	  sw		a0,8[$sp]		; save off current name
FFFC48B0 BF9FF0EF	  call	isAlpha
FFFC48B4 08080063	  beq   v0,r0,gvn1
FFFC48B8 00206293	  ldi	  r5,#2       ; loop two more times
                        	
                        		; check for second/third character
                        	gvn4:
FFFC48BC 001E0E13		add		$t2,$t2,#1
FFFC48C0 000E4903		lbu   a0,[$t2]		; do we have another char ?
FFFC48C4 C15FF0EF		call	isAlnum
FFFC48C8 02080863		beq   v0,x0,gvn2	; nope
FFFC48CC 00872903		lw		a0,8[$sp]		; get varname
FFFC48D0 00891913		sll		a0,a0,#8
FFFC48D4 000E4983		lbu   a1,[$t2]
FFFC48D8 01396933		or    a0,a0,a1   	; add in new char
FFFC48DC 01272423	  sw		a0,8[$sp]		; save off current name again
FFFC48E0 FFF28293	  sub		r5,r5,#1
FFFC48E4 FC504CE3	  bgt		r5,x0,gvn4
                        	
                        	 	; now ignore extra variable name characters
                        	gvn6:
FFFC48E8 001E0E13		add		$t2,$t2,#1
FFFC48EC 000E4903		lbu   a0,[$t2]		; do we have another char ?
FFFC48F0 BE9FF0EF	  call  isAlnum
FFFC48F4 FE081AE3	  bne   v0,x0,gvn6	; keep looping as long as we have identifier chars
                        	
                        	  ; check for a variable type
                        	gvn2:
FFFC48F8 000E4983		lbu   a1,[$t2]
FFFC48FC 02506D93		ldi		$t1,#'%'
FFFC4900 01B98A63		beq		a1,$t1,gvn3
FFFC4904 02406D93		ldi		$t1,#'$'
FFFC4908 01B98663		beq		a1,$t1,gvn3
FFFC490C FFFE0E13	  sub		$t2,$t2,#1
FFFC4910 02E06993	  ldi		$a1,#'.'		; if no variable type assume float
                        	
                        	  ; insert variable type indicator and return
                        	gvn3:
FFFC4914 001E0E13		add		$t2,$t2,#1
FFFC4918 00872903		lw		a0,8[$sp]		; get varname
FFFC491C 00891913		sll		a0,a0,#8
FFFC4920 01396833	  or    v0,a0,a1    ; add in variable type
FFFC4924 00072283	  lw		r5,[$sp]
FFFC4928 00472083	  lw		$ra,4[$sp]
FFFC492C 00C70713	  add		$sp,$sp,#12
FFFC4930 00008067	  ret								; return a0 = varname
                        	
                        	  ; not a variable name
                        	gvn1:
FFFC4934 00072283		lw		r5,[$sp]
FFFC4938 00472083	  lw		$ra,4[$sp]
FFFC493C 00C70713		add		$sp,$sp,#12
FFFC4940 00006833	  mov		v0,x0       ; return v0 = 0 if not a varname
FFFC4944 00008067	  ret
                        	
                        	
                        	; Find variable
                        	;   a0 = varname
                        	;		a1 = allocate flag
                        	; Returns
                        	;   v0 = variable address, Z =0 if found / allocated, Z=1 if not found
                        	
                        	findVar:
FFFC4948 FF870713		sub		$sp,$sp,#8
FFFC494C 00772023		sw		x7,[$sp]
FFFC4950 00372223		sw		x3,4[$sp]
FFFC4954 70802183	  lw    x3,VARBGN
                        	fv4:
FFFC4958 0001A383	  lw    x7,[x3]     ; get varname / type
FFFC495C 02038663	  beq   x7,x0,fv3		; no more vars ?
FFFC4960 02790863	  beq   a0,x7,fv1		; match ?
FFFC4964 00818193		add		x3,x3,#8		; move to next var
FFFC4968 70C02383	  lw    x7,VAREND		; 
FFFC496C FE71C6E3	  blt   x3,x7,fv4		; loop back to look at next var
                        	
                        	  ; variable not found
                        	  ; no more memory
FFFC4970 00072383	  lw		x7,[$sp]
FFFC4974 00472183	  lw		x3,4[$sp]
FFFC4978 00870713	  add		$sp,$sp,#8
FFFC497C FFFC5937	  ldi		a0,#msgVarSpace
FFFC4980 52690913
FFFC4984 29C0006F	  jmp   ERROR
                        	
                        	  ; variable not found
                        	  ; allocate new ?
                        	fv3:
FFFC4988 00098E63		beq		a1,x0,fv2
FFFC498C 0121A023	  sw    a0,[x3]     ; save varname / type
                        	  ; found variable
                        	  ; return address
                        	fv1:
FFFC4990 00418813	  add		v0,x3,#4
FFFC4994 00072383	  lw		x7,[$sp]
FFFC4998 00472183	  lw		x3,4[$sp]
FFFC499C 00870713	  add		$sp,$sp,#8
FFFC49A0 00008067	  ret			    			; v0 = address
                        	
                        	  ; didn't find var and not allocating
                        	fv2:
FFFC49A4 00072383	  lw		x7,[$sp]
FFFC49A8 00472183	  lw		x3,4[$sp]
FFFC49AC 00870713	  add		$sp,$sp,#8
FFFC49B0 00006833		mov		v0,x0				; v0 = nullptr
FFFC49B4 00008067	  ret
                        	
                        	; The following functions are entered via a jump instruction with
                        	; the return address already saved.
                        	
                        	; ===== The PEEK function returns the byte stored at the address
                        	;	contained in the following expression.
                        	;
                        	PEEK:
FFFC49B8 E11FF0EF		call	PARN		; get the memory address
FFFC49BC 00080803		lb		v0,[v0]		; get the addressed byte
FFFC49C0 000068B3		mov		v1,x0			; type = int
FFFC49C4 00072083		lw		$ra,[$sp]
FFFC49C8 00470713		add		$sp,$sp,#4
FFFC49CC 00008067		ret
                        	PEEKW:
FFFC49D0 DF9FF0EF		call	PARN		; get the memory address
FFFC49D4 00082803		lw		v0,[v0]		; get the addressed word
FFFC49D8 000068B3		mov		v1,x0			; type = int
FFFC49DC 00072083		lw		$ra,[$sp]
FFFC49E0 00470713		add		$sp,$sp,#4
FFFC49E4 00008067		ret
                        	PEEKH:
FFFC49E8 DE1FF0EF		call	PARN		; get the memory address
FFFC49EC 00081803		lh		v0,[v0]		; get the addressed byte
FFFC49F0 000068B3		mov		v1,x0			; type = int
FFFC49F4 00072083		lw		$ra,[$sp]
FFFC49F8 00470713		add		$sp,$sp,#4
FFFC49FC 00008067		ret
                        	
                        	
                        	; user function call
                        	; call the user function with argument in a0, type in a1
                        	USRX:
FFFC4A00 FFC70713		sub		$sp,$sp,#4
FFFC4A04 01A72023		sw		$t0,[$sp]
FFFC4A08 DC1FF0EF		call	PARN		; get expression value
FFFC4A0C 00086933		mov		a0,v0
FFFC4A10 0008E9B3		mov		a1,v1
FFFC4A14 FFC70713		sub		$sp,$sp,#4	; save the text pointer
FFFC4A18 01C72023		sw		$t2,[$sp]
FFFC4A1C 7A002D03		lw		$t0,usrJmp
FFFC4A20 000D00E7		call	[$t0]			; get usr vector, jump to the subroutine
FFFC4A24 00072E03		lw		$t2,[$sp]	; restore the text pointer
FFFC4A28 00470713		add		$sp,$sp,#4
FFFC4A2C 00072D03		lw		$t0,[$sp]
FFFC4A30 00470713		add		$sp,$sp,#4
FFFC4A34 00072083		lw		$ra,[$sp]
FFFC4A38 00470713		add		$sp,$sp,#4
FFFC4A3C 00008067		ret
                        	
                        	
                        	; ===== The RND function returns a random number from 1 to
                        	;	the value of the following expression in D0.
                        	;
                        	RND:
FFFC4A40 D89FF0EF		call	PARN		; get the upper limit
FFFC4A44 04080063		beq		v0,r0,rnd2	; it must be positive and non-zero
FFFC4A48 02084663		blt		v0,r0,rnd1
FFFC4A4C 000869B3		mov		a1,v0
FFFC4A50 000868B3		mov		v1,v0
FFFC4A54 00000637		call	gen_rand	; generate a random number
FFFC4A58 395600E7
FFFC4A5C 03186833		rem		v0,v0,v1
FFFC4A60 00180813		add		v0,v0,#1
FFFC4A64 000068B3		mov		v1,x0
FFFC4A68 00072083		lw		$ra,[$sp]
FFFC4A6C 00470713		add		$sp,$sp,#4
FFFC4A70 00008067		ret
                        	rnd1:
FFFC4A74 FFFC5937		ldi		a0,#msgRNDBad
FFFC4A78 59090913
FFFC4A7C 00470713		add		$sp,$sp,#4
FFFC4A80 1A00006F		jmp		ERROR
                        	rnd2:
FFFC4A84 00000637		call	gen_rand	; generate a random number
FFFC4A88 395600E7
FFFC4A8C 000068B3		mov		v1,x0
FFFC4A90 00072083		lw		$ra,[$sp]
FFFC4A94 00470713		add		$sp,$sp,#4
FFFC4A98 00008067		ret
                        	
                        	; ===== The ABS function returns an absolute value in a1.
                        	;
                        	ABS:
FFFC4A9C D2DFF0EF		call	PARN		; get the following expr.'s value
FFFC4AA0 00084863		blt		v0,r0,ABS1
FFFC4AA4 00072083		lw		$ra,[$sp]
FFFC4AA8 00470713		add		$sp,$sp,#4
FFFC4AAC 00008067		ret
                        	ABS1:
FFFC4AB0 41000833		sub		v0,x0,v0
FFFC4AB4 00072083		lw		$ra,[$sp]
FFFC4AB8 00470713		add		$sp,$sp,#4
FFFC4ABC 00008067		ret
                        	
                        	
                        	;==== The TICK function returns the cpu tick value in a0.
                        	;
                        	TICKX:
FFFC4AC0 C0001873		csrrw	v0,#$C00,x0
FFFC4AC4 000068B3		mov		v1,x0
FFFC4AC8 00072083		lw		$ra,[$sp]
FFFC4ACC 00470713		add		$sp,$sp,#4
FFFC4AD0 00008067		ret
                        	
                        	; ===== The SGN function returns the sign in a0. +1,0, or -1
                        	;
                        	SGN:
FFFC4AD4 CF5FF0EF		call	PARN		; get the following expr.'s value
FFFC4AD8 000068B3		mov		v1,x0
FFFC4ADC 02080463		beq		v0,r0,SGN1
FFFC4AE0 00084A63		blt		v0,r0,SGN2
FFFC4AE4 00106813		ldi		v0,#1
FFFC4AE8 00072083		lw		$ra,[$sp]
FFFC4AEC 00470713		add		$sp,$sp,#4
FFFC4AF0 00008067		ret
                        	SGN2:
FFFC4AF4 FFF06813		ldi		v0,#-1
FFFC4AF8 00072083		lw		$ra,[$sp]
FFFC4AFC 00470713		add		$sp,$sp,#4
FFFC4B00 00008067		ret
                        	SGN1:
FFFC4B04 00072083		lw		$ra,[$sp]
FFFC4B08 00470713		add		$sp,$sp,#4
FFFC4B0C 00008067		ret	
                        	
                        	; ===== The SIZE function returns the size of free memory in v0.
                        	; does not consider memory used by @()
                        	;
                        	SIZEX:
FFFC4B10 70802803		lw		v0,VARBGN	; get the number of free bytes...
FFFC4B14 70402883		lw		v1,TXTUNF	; between 'TXTUNF' and 'VARBGN'
FFFC4B18 41180833		sub		v0,v0,v1
FFFC4B1C 000068B3		mov		v1,x0			; type = int
FFFC4B20 00072083		lw		$ra,[$sp]
FFFC4B24 00470713		add		$sp,$sp,#4
FFFC4B28 00008067		ret					; return the number in v0
                        	
                        	
                        	;******************************************************************
                        	;
                        	; *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                        	;
                        	; 'SETVAL' expects a variable, followed by an equal sign and then
                        	; an expression.  It evaluates the expression and sets the variable
                        	; to that value.
                        	;
                        	; returns
                        	; a1 = variable's address
                        	;
                        	SETVAL:
FFFC4B2C FFC70713		sub		$sp,$sp,#4
FFFC4B30 00172023		sw		$ra,[$sp]
FFFC4B34 00106913	  ldi		a0,#1		; allocate var
FFFC4B38 CD1FF0EF	  call	TSTV		; variable name?
FFFC4B3C 00081A63	  bne		v0,x0,.sv2
FFFC4B40 FFFC5937	 	ldi		a0,#msgVar
FFFC4B44 57A90913
FFFC4B48 00470713		add		$sp,$sp,#4
FFFC4B4C 0D40006F	 	jmp		ERROR 
                        	.sv2:
FFFC4B50 FFC70713		sub		$sp,$sp,#4
FFFC4B54 01072023		sw		v0,[$sp]	; save the variable's address
FFFC4B58 56C000EF		call	TSTC			; get past the "=" sign
FFFC4B5C 0000003D		dw		'='
FFFC4B60 02000663		bra		SV1
FFFC4B64 865FF0EF		call	OREXPR		; evaluate the expression
FFFC4B68 00072983		lw		a1,[$sp]	; get back the variable's address
FFFC4B6C 00470713		add		$sp,$sp,#4
FFFC4B70 0109A023		sw    v0,[a1]   ; and save value in the variable
FFFC4B74 0009E833		mov		v0,a1			; return v0 = variable address
FFFC4B78 FFC9A883		lw		v1,-4[a1]
FFFC4B7C 0FF8F893		and		v1,v1,#$FF
FFFC4B80 00072083		lw		$ra,[$sp]
FFFC4B84 00470713		add		$sp,$sp,#4
FFFC4B88 00008067		ret
                        	SV1:
FFFC4B8C 00470713		add		$sp,$sp,#4
FFFC4B90 0880006F	  jmp	  QWHAT		; if no "=" sign
                        	
                        	
                        	; 'FIN' checks the end of a command.  If it ended with ":",
                        	; execution continues.	If it ended with a CR, it finds the
                        	; the next line and continues from there.
                        	;
                        	FIN:
FFFC4B94 FFC70713		sub		$sp,$sp,#4
FFFC4B98 00172023		sw		$ra,[$sp]
FFFC4B9C 528000EF		call	TSTC		; *** FIN ***
FFFC4BA0 0000003A		dw		':'
FFFC4BA4 00000663		bra		FI1
FFFC4BA8 00470713		add		$sp,$sp,#4	; if ":", discard return address
FFFC4BAC 820FF06F		jmp		RUNSML		; continue on the same line
                        	FI1:
FFFC4BB0 514000EF		call	TSTC		; not ":", is it a CR?
FFFC4BB4 0000000D		dw		CR
FFFC4BB8 00000663		bra		FI2
                        							; else return to the caller
FFFC4BBC 00470713		add		$sp,$sp,#4	; yes, purge return address
FFFC4BC0 FA5FE06F		jmp		RUNNXL		; execute the next line
                        	FI2:
FFFC4BC4 00072083		lw		$ra,[$sp]
FFFC4BC8 00470713		add		$sp,$sp,#4
FFFC4BCC 00008067		ret					; else return to the caller
                        	
                        	
                        	; 'ENDCHK' checks if a command is ended with a CR. This is
                        	; required in certain commands, such as GOTO, RETURN, STOP, etc.
                        	;
                        	; Check that there is nothing else on the line
                        	; Registers Affected
                        	;   a0
                        	;
                        	ENDCHK:
FFFC4BD0 FFC70713		sub		$sp,$sp,#4
FFFC4BD4 00172023		sw		$ra,[$sp]
FFFC4BD8 5AC000EF		call	IGNBLK
FFFC4BDC 000E4903		lbu		a0,[$t2]
FFFC4BE0 00D06D93		ldi		$t1,#CR
FFFC4BE4 01B90863		beq		a0,$t1,ec1	; does it end with a CR?
FFFC4BE8 FFFC5937		ldi		a0,#msgExtraChars
FFFC4BEC 64B90913
FFFC4BF0 0300006F		jmp		ERROR
                        	ec1:
FFFC4BF4 00072083		lw		$ra,[$sp]
FFFC4BF8 00470713		add		$sp,$sp,#4
FFFC4BFC 00008067		ret
                        	
                        	; 'ERROR' prints the string pointed to by a0. It then prints the
                        	; line pointed to by CURRNT with a "?" inserted at where the
                        	; old text pointer (should be on top of the stack) points to.
                        	; Execution of Tiny BASIC is stopped and a warm start is done.
                        	; If CURRNT is zero (indicating a direct command), the direct
                        	; command is not printed. If CURRNT is -1 (indicating
                        	; 'INPUT' command in progress), the input line is not printed
                        	; and execution is not terminated but continues at 'INPERR'.
                        	;
                        	; Related to 'ERROR' are the following:
                        	; 'QWHAT' saves text pointer on stack and gets "What?" message.
                        	; 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                        	; 'QSORRY' and 'ASORRY' do the same kind of thing.
                        	; 'QHOW' and 'AHOW' also do this for "How?".
                        	;
                        	TOOBIG:
FFFC4C00 FFFC5937		ldi		a0,#msgTooBig
FFFC4C04 63790913
FFFC4C08 00000C63		bra		ERROR
                        	QSORRY:
FFFC4C0C FFFC5937	  ldi		a0,#SRYMSG
FFFC4C10 4DF90913
FFFC4C14 00000663		bra	    ERROR
                        	QWHAT:
FFFC4C18 FFFC5937		ldi		a0,#msgWhat
FFFC4C1C 4D890913
                        	ERROR:
FFFC4C20 644000EF		call	PRMESG		; display the error message
FFFC4C24 71802903		lw		a0,CURRNT	; get the current line pointer
FFFC4C28 02090C63		beq		a0,r0,ERROR1	; if zero, do a warm start
FFFC4C2C FFF06D93		ldi		$t1,#-1
FFFC4C30 AFB90463		beq		a0,$t1,INPERR	; is the line no. pointer = -1? if so, redo input
FFFC4C34 000E4283		lbu		r5,[$t2]		; save the char. pointed to
FFFC4C38 000E0023		sb		x0,[$t2]		; put a zero where the error is
FFFC4C3C 71802903		lw		a0,CURRNT	; point to start of current line
FFFC4C40 428000EF		call	PRTLN		; display the line in error up to the 0
FFFC4C44 00096333		mov     r6,a0	    ; save off end pointer
FFFC4C48 005E0023		sb		r5,[$t2]		; restore the character
FFFC4C4C 03F06913		ldi		a0,#'?'		; display a "?"
FFFC4C50 AB9FE0EF		call	GOOUT
FFFC4C54 000069B3		mov		a1,r0		; stop char = 0
FFFC4C58 FFF30913		sub		a0,r6,#1	; point back to the error char.
FFFC4C5C 23C000EF		call	PRTSTG		; display the rest of the line
                        	ERROR1:
FFFC4C60 B61FE06F		jmp	    WSTART		; and do a warm start
                        	
                        	;******************************************************************
                        	;
                        	; *** GETLN *** FNDLN (& friends) ***
                        	;
                        	; 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                        	; the character in r3 (given by the caller), then it fills the
                        	; buffer and echos. It ignores LF's but still echos
                        	; them back. Control-H is used to delete the last character
                        	; entered (if there is one), and control-X is used to delete the
                        	; whole line and start over again. CR signals the end of a line,
                        	; and causes 'GETLN' to return.
                        	;
                        	;
                        	GETLN:
FFFC4C64 FF870713		sub		$sp,$sp,#8
FFFC4C68 00572023		sw		r5,[$sp]
FFFC4C6C 00172223		sw		$ra,4[$sp]
FFFC4C70 A99FE0EF		call	GOOUT		; display the prompt
FFFC4C74 00106913		ldi		a0,#1
                        	;	sw		a0,CursorFlash	; turn on cursor flash
FFFC4C78 02006913		ldi		a0,#' '		; and a space
FFFC4C7C A8DFE0EF		call	GOOUT
FFFC4C80 71C06E13		ldi		$t2,#BUFFER	; $t2 is the buffer pointer
                        	.GL1:
FFFC4C84 5B0000EF		call	CHKIO		; check keyboard
FFFC4C88 FE080EE3		beq		v0,x0,.GL1	; wait for a char. to come in
FFFC4C8C 00806D93		ldi		$t1,#CTRLH
FFFC4C90 05B80663		beq		v0,$t1,.GL3	; delete last character? if so
FFFC4C94 01806D93		ldi		$t1,#CTRLX
FFFC4C98 07B80663		beq		v0,$t1,.GL4	; delete the whole line?
FFFC4C9C 00D06D93		ldi		$t1,#CR
FFFC4CA0 01B80663		beq		v0,$t1,.GL2		; accept a CR
FFFC4CA4 02006D93		ldi		$t1,#' '
FFFC4CA8 FDB84EE3		blt		v0,$t1,.GL1	; if other control char., discard it
                        	.GL2:
FFFC4CAC 010E0023		sb		v0,[$t2]		; save the char.
FFFC4CB0 001E0E13		add		$t2,$t2,#1
FFFC4CB4 FFC70713		sub		$sp,$sp,#4
FFFC4CB8 01072023		sw		v0,[$sp]
FFFC4CBC 00086933		mov		$a0,$v0
FFFC4CC0 A49FE0EF		call	GOOUT		; echo the char back out
FFFC4CC4 00072803		lw		v0,[$sp]; get char back (GOOUT destroys a0)
FFFC4CC8 00470713		add		$sp,$sp,#4
FFFC4CCC 00D06D93		ldi		$t1,#CR
FFFC4CD0 07B80663		beq		v0,$t1,.GL7			; if it's a CR, end the line
FFFC4CD4 76F06D93		ldi		$t1,#BUFFER+BUFLEN-1
FFFC4CD8 FBBE46E3		blt		$t2,$t1,.GL1		; any more room? ; yes: get some more, else delete last char.
                        	.GL3:
FFFC4CDC 00806913		ldi		a0,#CTRLH	; delete a char. if possible
FFFC4CE0 A29FE0EF		call	GOOUT
FFFC4CE4 02006913		ldi		a0,#' '
FFFC4CE8 A21FE0EF		call	GOOUT
FFFC4CEC 71C06D93		ldi		$t1,#BUFFER
FFFC4CF0 F9CDDAE3		ble		$t2,$t1,.GL1	; any char.'s left?	; if not
FFFC4CF4 00806913		ldi		a0,#CTRLH		; if so, finish the BS-space-BS sequence
FFFC4CF8 A11FE0EF		call	GOOUT
FFFC4CFC FFFE0E13		sub		$t2,$t2,#1	; decrement the text pointer
FFFC4D00 F80002E3		bra		.GL1		; back for more
                        	.GL4:
FFFC4D04 000E6933		mov		a0,$t2		; delete the whole line
FFFC4D08 8E490293		sub		r5,a0,#BUFFER   ; figure out how many backspaces we need
FFFC4D0C 02028463		beq		r5,r0,.GL6		; if none needed, brnch
FFFC4D10 FFF28293		sub		r5,r5,#1		; loop count is one less
                        	.GL5:
FFFC4D14 00806913		ldi		a0,#CTRLH		; and display BS-space-BS sequences
FFFC4D18 9F1FE0EF		call	GOOUT
FFFC4D1C 02006913		ldi		a0,#' '
FFFC4D20 9E9FE0EF		call	GOOUT
FFFC4D24 00806913		ldi		a0,#CTRLH
FFFC4D28 9E1FE0EF		call	GOOUT
FFFC4D2C FFF28293		sub		r5,r5,#1
FFFC4D30 FE0292E3		bne		r5,r0,.GL5
                        	.GL6:
FFFC4D34 71C06E13		ldi		$t2,#BUFFER	; reinitialize the text pointer
FFFC4D38 F40006E3		bra		.GL1		; and go back for more
                        	.GL7:
FFFC4D3C 000E0023		sb		x0,[$t2]		; null terminate line
                        	;	sw		x0,CursorFlash	; turn off cursor flash
FFFC4D40 00A06913		ldi		a0,#LINEFD	; echo a LF for the CR
FFFC4D44 9C5FE0EF		call	GOOUT
FFFC4D48 00072283		lw		r5,[$sp]
FFFC4D4C 00472083		lw		$ra,4[$sp]
FFFC4D50 00870713		add		$sp,$sp,#8
FFFC4D54 00008067		ret
                        	
                        	
                        	; 'FNDLN' finds a line with a given line no. (in a0) in the
                        	; text save area.  $t3 is used as the text pointer. If the line
                        	; is found, $t3 will point to the beginning of that line
                        	; (i.e. the high byte of the line no.), and $v0 = 1.
                        	; If that line is not there and a line with a higher line no.
                        	; is found, $t3 points there and $v0 = 0. If we reached
                        	; the end of the text save area and cannot find the line, flags
                        	; $t3 = 0, $v0 = 0.
                        	; $v0=1 if line found
                        	; r0 = 1	<= line is found
                        	;	$t3 = pointer to line
                        	; r0 = 0    <= line is not found
                        	;	r9 = zero, if end of text area
                        	;	r9 = otherwise higher line number
                        	;
                        	; 'FNDLN' will initialize $t3 to the beginning of the text save
                        	; area to start the search. Some other entries of this routine
                        	; will not initialize $t3 and do the search.
                        	; 'FNDLNP' will start with $t3 and search for the line no.
                        	; 'FNDNXT' will bump $t3 by 4, find a CR and then start search.
                        	; 'FNDSKP' uses $t3 to find a CR, and then starts the search.
                        	; return Z=1 if line is found, r9 = pointer to line
                        	;
                        	; Parameters
                        	;	a0 = line number to find
                        	;
                        	FNDLN:
FFFC4D58 00100DB7		ldi		$t1,#$FFFFF
FFFC4D5C FFFD8D93
FFFC4D60 01B94863		blt		a0,$t1,fl1	; line no. must be < 65535
FFFC4D64 FFFC5937		ldi		a0,#msgLineRange
FFFC4D68 56590913
FFFC4D6C EB5FF06F		jmp		ERROR
                        	fl1:
FFFC4D70 00002EB7		ldi		$t3,#TXTBGN	; init. the text save pointer
FFFC4D74 800E8E93
                        	
                        	FNDLNP:
FFFC4D78 70402F03		lw		$t4,TXTUNF	; check if we passed the end
FFFC4D7C 05EEF463		bgeu	$t3,$t4,FNDRET1; if so, return with r9=0,a0=0
FFFC4D80 FF870713		sub		$sp,$sp,#8	; push a0
FFFC4D84 01272023		sw		a0,[$sp]
FFFC4D88 00172223		sw		ra,4[$sp]
FFFC4D8C 000EE933		mov		a0,t3
FFFC4D90 2AC000EF		call	LoadWord		; get line number
FFFC4D94 00072903		lw		a0,[$sp]		; pop a0
FFFC4D98 00472083		lw		ra,4[$sp]
FFFC4D9C 00870713		add		$sp,$sp,#8
FFFC4DA0 03280663		beq		v0,a0,FNDRET2
FFFC4DA4 03286863		bltu	v0,a0,FNDNXT	; is this the line we want? no, not there yet
                        	FNDRET:
FFFC4DA8 004E8E93		add		$t3,$t3,#4	; find the next line, skip over line number
                        	.0001:
FFFC4DAC 000EC883		lbu		v1,[$t3]
FFFC4DB0 001E8E93		add		$t3,$t3,#1
FFFC4DB4 00D06D93		ldi		$t1,#CR
FFFC4DB8 FFB89AE3		bne		v1,$t1,.0001	; try to find a CR, keep looking
FFFC4DBC 00006833		mov		v0,x0	; line not found, but $t3=next line pointer
FFFC4DC0 00008067		ret
                        	FNDRET1:
                        	;	eor		r9,r9,r9	; no higher line
FFFC4DC4 00006833		mov		v0,x0	; line not found
FFFC4DC8 00008067		ret
                        	FNDRET2:
FFFC4DCC 00106813		ldi		v0,#1	; line found
FFFC4DD0 00008067		ret
                        	
                        	FNDNXT:
FFFC4DD4 004E8E93		add		$t3,$t3,#4	; find the next line
                        	
                        	FNDSKP:
FFFC4DD8 000EC883		lbu		v1,[$t3]
FFFC4DDC 001E8E93		add		$t3,$t3,#1
FFFC4DE0 00D06D93		ldi		$t1,#CR
FFFC4DE4 FFB89AE3		bne		v1,$t1,FNDSKP	; try to find a CR, keep looking
FFFC4DE8 F80008E3		bra		FNDLNP		; check if end of text
                        	
                        	
                        	;******************************************************************
                        	; 'MVUP' moves a block up from where a0 points to where a1 points
                        	; until a0=a2
                        	;
                        	MVUP1:
FFFC4DEC 00090203		lb		r4,[a0]
FFFC4DF0 00498023		sb		r4,[a1]
FFFC4DF4 00190913		add		a0,a0,#1
FFFC4DF8 00198993		add		a1,a1,#1
                        	MVUP:
FFFC4DFC FF4918E3		bne		a0,a2,MVUP1
FFFC4E00 00008067		ret
                        	
                        	
                        	; 'MVDOWN' moves a block down from where a0 points to where a1
                        	; points until a0=a2
                        	;
                        	MVDOWN1:
FFFC4E04 FFF90913		sub		a0,a0,#1
FFFC4E08 FFF98993		sub		a1,a1,#1
FFFC4E0C 00090203		lb		r4,[a0]
FFFC4E10 00498023		sb		r4,[a1]
                        	MVDOWN:
FFFC4E14 FF4918E3		bne		a0,a2,MVDOWN1
FFFC4E18 00008067		ret
                        	
                        	
                        	; 'POPA_' restores the 'FOR' loop variable save area from the stack
                        	;
                        	; 'PUSHA_' stacks for 'FOR' loop variable save area onto the stack
                        	;
                        	; Note: a single zero word is stored on the stack in the
                        	; case that no FOR loops need to be saved. This needs to be
                        	; done because PUSHA_ / POPA_ is called all the time.
                        	//message "POPA_"
                        	POPA_:
FFFC4E1C 00072903		lw		a0,[$sp]
FFFC4E20 00470713		add		$sp,$sp,#4
FFFC4E24 71202823		sw		a0,LOPVAR	; restore LOPVAR, but zero means no more
FFFC4E28 02090463		beq		a0,x0,PP1
FFFC4E2C 00072903		lw		a0,[$sp]
FFFC4E30 77202823		sw		a0,LOPPT
FFFC4E34 00472903		lw		a0,4[$sp]
FFFC4E38 77202A23		sw		a0,LOPLN
FFFC4E3C 00872903		lw		a0,8[$sp]
FFFC4E40 77202E23		sw		a0,LOPLMT
FFFC4E44 00C72903		lw		a0,12[$sp]
FFFC4E48 77202C23		sw		a0,LOPINC
FFFC4E4C 01070713		add		$sp,$sp,#16
                        	PP1:
FFFC4E50 00008067		ret
                        	
                        	
                        	PUSHA_:
FFFC4E54 79C02903		lw		a0,STKBOT	; Are we running out of stack room?
FFFC4E58 01490913		add		a0,a0,#20	; we might need this many bytes
FFFC4E5C DB2748E3		blt		$sp,a0,QSORRY	; out of stack space
FFFC4E60 71002983		lw		a1,LOPVAR		; save loop variables
FFFC4E64 02098463		beq		a1,x0,PU1		; if LOPVAR is zero, that's all
FFFC4E68 FF070713		sub		$sp,$sp,#16
FFFC4E6C 77002903		lw		a0,LOPPT
FFFC4E70 01272023		sw		a0,[$sp]
FFFC4E74 77402903		lw		a0,LOPLN
FFFC4E78 01272223		sw		a0,4[$sp]
FFFC4E7C 77C02903		lw		a0,LOPLMT
FFFC4E80 01272423		sw		a0,8[$sp]
FFFC4E84 77802903		lw		a0,LOPINC
FFFC4E88 01272623		sw		a0,12[$sp]
                        	PU1:
FFFC4E8C FFC70713		sub		$sp,$sp,#4
FFFC4E90 01372023		sw		a1,[$sp]
FFFC4E94 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	;
                        	; 'PRTSTG' prints a string pointed to by a0. It stops printing
                        	; and returns to the caller when either a CR is printed or when
                        	; the next byte is the same as what was passed in a1 by the
                        	; caller.
                        	;
                        	; 'PRTLN' prints the saved text line pointed to by r3
                        	; with line no. and all.
                        	;
                        	
                        	; a0 = pointer to string
                        	; a1 = stop character
                        	; return v0 = pointer to end of line + 1
                        	
                        	PRTSTG:
FFFC4E98 FEC70713		sub		$sp,$sp,#20
FFFC4E9C 00572023		sw		r5,[$sp]
FFFC4EA0 00672223		sw		r6,4[$sp]
FFFC4EA4 00772423		sw		r7,8[$sp]
FFFC4EA8 00172623		sw		$ra,12[$sp]
FFFC4EAC 01272823		sw		$a0,16[$sp]
FFFC4EB0 000962B3		mov   r5,a0	    ; r5 = pointer
FFFC4EB4 0009E333		mov   r6,a1	    ; r6 = stop char
                        	.PS1:
FFFC4EB8 0002C383	  lbu   r7,[r5]     ; get a text character
FFFC4EBC 00128293		add		r5,r5,#1
FFFC4EC0 00638E63		beq	  r7,r6,.PRTRET	; same as stop character? if so, return
FFFC4EC4 0003E933		mov   a0,r7
FFFC4EC8 841FE0EF		call	GOOUT		; display the char.
FFFC4ECC 00D06D93		ldi		$t1,#CR
FFFC4ED0 FFB394E3		bne   r7,$t1,.PS1	; is it a C.R.? no, go back for more
FFFC4ED4 00A06913		ldi		a0,#LINEFD  ; yes, add a L.F.
FFFC4ED8 831FE0EF		call	GOOUT
                        	.PRTRET:
FFFC4EDC 0003E8B3	  mov   v1,r7	    ; return a1 = stop char
FFFC4EE0 0002E833		mov		v0,r5		; return a0 = line pointer
FFFC4EE4 00072283		lw		$r5,[$sp]
FFFC4EE8 00472303		lw		$r6,4[$sp]
FFFC4EEC 00872383		lw		$r7,8[$sp]
FFFC4EF0 00C72083		lw		$ra,12[$sp]
FFFC4EF4 01072903		lw		$a0,16[$sp]
FFFC4EF8 01470713		add		$sp,$sp,#20
FFFC4EFC 00008067	  ret					; then return
                        	
                        	
                        	; 'QTSTG' looks for an underline (back-arrow on some systems),
                        	; single-quote, or double-quote.  If none of these are found, returns
                        	; to the caller.  If underline, outputs a CR without a LF.  If single
                        	; or double quote, prints the quoted string and demands a matching
                        	; end quote.  After the printing, the next i-word of the caller is
                        	; skipped over (usually a branch instruction).
                        	;
                        	QTSTG:
FFFC4F00 FFC70713		sub		$sp,$sp,#4
FFFC4F04 00172023		sw		$ra,[$sp]
FFFC4F08 1BC000EF		call	TSTC		; *** QTSTG ***
FFFC4F0C 00000022		dw		'"'
FFFC4F10 02000063		bra		QT3
FFFC4F14 02206993		ldi		a1,#'"'		; it is a "
                        	QT1:
FFFC4F18 000E6933		mov		a0,$t2
FFFC4F1C F7DFF0EF		call	PRTSTG		; print until another
FFFC4F20 00086E33		mov		$t2,v0
FFFC4F24 00D06D93		ldi		$t1,#CR
FFFC4F28 03B89863		bne		v1,$t1,QT2	; was last one a CR?
FFFC4F2C C39FE06F		jmp		RUNNXL		; if so run next line
                        	QT3:
FFFC4F30 194000EF		call	TSTC		; is it a single quote?
FFFC4F34 0000005C		dw		'\''
FFFC4F38 00000663		bra		QT4
FFFC4F3C 02706993		ldi		a1,#'\''	; if so, do same as above
FFFC4F40 FC000CE3		bra		QT1
                        	QT4:
FFFC4F44 180000EF		call	TSTC		; is it an underline?
FFFC4F48 0000005F		dw		'_'
FFFC4F4C 00000C63		bra		QT5
FFFC4F50 00D06913		ldi		a0,#CR		; if so, output a CR without LF
FFFC4F54 FB4FE0EF		call	GOOUT
                        	QT2:
FFFC4F58 00072083		lw		$ra,[$sp]		; get return address
FFFC4F5C 00470713		add		$sp,$sp,#4
FFFC4F60 00408067		jmp		4[$ra]		; skip following branch
                        	QT5:					; not " ' or _
FFFC4F64 00072083		lw		$ra,[$sp]		; get return address
FFFC4F68 00470713		add		$sp,$sp,#4
FFFC4F6C 00008067		ret
                        	
                        	; Output a CR LF sequence
                        	;
                        	prCRLF:
FFFC4F70 FFC70713		sub		$sp,$sp,#4
FFFC4F74 00172023		sw		$ra,[$sp]
FFFC4F78 00D06913		ldi		a0,#CR
FFFC4F7C F8CFE0EF		call	GOOUT
FFFC4F80 00A06913		ldi		a0,#LINEFD
FFFC4F84 F84FE0EF		call	GOOUT
FFFC4F88 00072083		lw		$ra,[$sp]
FFFC4F8C 00470713		add		$sp,$sp,#4
FFFC4F90 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; 'PRTNUM' prints the 32 bit number in a0, leading blanks are added if
                        	; needed to pad the number of spaces to the number in a1.
                        	; However, if the number of digits is larger than the no. in
                        	; a1, all digits are printed anyway. Negative sign is also
                        	; printed and counted in, positive sign is not.
                        	;
                        	; Parameters
                        	; 	a0 = number to print
                        	; 	a1 = number of digits
                        	;		a2 = base (eg 10, 16)
                        	; Register Usage
                        	;		s2 = number of padding spaces
                        	; Modifies:
                        	;		a0,a1,t1
                        	; Returns:
                        	;		none
                        	;-------------------------------------------------------------------------------
                        	
FFFC4F94 FEC70713	public PRTNUM:
	sub		$sp,$sp,#20
FFFC4F98 00472023		sw		$s1,[$sp]
FFFC4F9C 00572223		sw		$s2,4[$sp]
FFFC4FA0 00672423		sw		$s3,8[$sp]
FFFC4FA4 00772623		sw		$s4,12[$sp]
FFFC4FA8 00172823		sw		$ra,16[$sp]
FFFC4FAC 79406393		ldi		s4,#NUMWKA	; r7 = pointer to numeric work area
FFFC4FB0 00096333		mov		s3,a0		; save number for later
FFFC4FB4 0009E2B3		mov		s2,a1		; s2 = min number of chars
FFFC4FB8 00095663		bge		a0,x0,.PN2	; is it negative? if not
FFFC4FBC 41200933		sub		a0,x0,a0	; else make it positive
FFFC4FC0 FFF28293		sub		s2,s2,#1	; one less for width count
                        	.PN2:
FFFC4FC4 00A06D93		ldi		$t1,#10
                        	.PN1:
FFFC4FC8 034969B3		rem		a1,a0,a2	; a1 = a0 mod 10
FFFC4FCC 03494933		div		a0,a0,a2	; a0 /= 10 divide by 10
FFFC4FD0 013A7463		bleu	a1,a2,.PN7
FFFC4FD4 00798993		add		a1,a1,#'A'-10-'0'
                        	.PN7:
FFFC4FD8 03098993		add		a1,a1,#'0'	; convert remainder to ascii
FFFC4FDC 01338023		sb		a1,[$s4]		; and store in buffer
FFFC4FE0 00138393		add		s4,s4,#1
FFFC4FE4 FFF28293		sub		s2,s2,#1	; decrement width
FFFC4FE8 FE0910E3		bne		a0,x0,.PN1
FFFC4FEC 00505A63		ble		$s2,$x0,.PN4	; test pad count, skip padding if not needed
                        	.PN3:
FFFC4FF0 02006913		ldi		$a0,#' '		; display the required leading spaces
FFFC4FF4 F14FE0EF		call	GOOUT
FFFC4FF8 FFF28293		sub		$s2,$s2,#1
FFFC4FFC FE504AE3		bgt		$s2,$x0,.PN3
                        	.PN4:
FFFC5000 00035663		bge		$s3,$x0,.PN5	; is number negative?
FFFC5004 02D06913		ldi		$a0,#'-'		; if so, display the sign
FFFC5008 F00FE0EF		call	GOOUT
                        	.PN5:
FFFC500C 79406D93		ldi		$t1,#NUMWKA
                        	.PN6:
FFFC5010 FFF38393		sub		$s4,$s4,#1
FFFC5014 0003C903		lbu		$a0,[$s4]		; now unstack the digits and display
FFFC5018 EF0FE0EF		call	GOOUT
FFFC501C FE7DEAE3		bgtu	$s4,$t1,.PN6
                        	
FFFC5020 00072203		lw		$s1,[$sp]
FFFC5024 00472283		lw		$s2,4[$sp]
FFFC5028 00872303		lw		$s3,8[$sp]
FFFC502C 00C72383		lw		$s4,12[$sp]
FFFC5030 01072083		lw		$ra,16[$sp]
FFFC5034 01470713		add		$sp,$sp,#20
FFFC5038 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; Load a word from memory using unaligned access.
                        	; Moves forwards through memory
                        	;
                        	; Parameters:
                        	;		a0 = pointer to word
                        	; Returns:
                        	;		v0 = word loaded
                        	;-------------------------------------------------------------------------------
                        	LoadWord:
FFFC503C 00094803	  lbu		$v0,[$a0]	
FFFC5040 00194883	  lbu		$v1,1[$a0]
FFFC5044 00889893	  sll		$v1,$v1,#8
FFFC5048 01186833	  or		$v0,$v0,$v1
FFFC504C 00294883	  lbu		$v1,2[$a0]
FFFC5050 01089893	  sll		$v1,$v1,#16
FFFC5054 01186833	  or		$v0,$v0,$v1
FFFC5058 00394883	  lbu		$v1,3[$a0]
FFFC505C 01889893	  sll		$v1,$v1,#24
FFFC5060 01186833	  or		$v0,$v0,$v1
FFFC5064 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = pointer to line
                        	; Returns:
                        	;		v0 = pointer to end of line + 1
                        	;-------------------------------------------------------------------------------
                        	
                        	PRTLN:
FFFC5068 FF070713		sub		$sp,$sp,#16
FFFC506C 00572023		sw		$r5,[$sp]
FFFC5070 00172223		sw		$ra,4[$sp]
FFFC5074 01272423		sw		$a0,8[$sp]
FFFC5078 01372623		sw		$a1,12[$sp]
FFFC507C 000962B3	  mov		$r5,$a0		; r5 = pointer
                        	  ; get the line number stored as binary
                        	  ; assume unaligned loads not allowed
FFFC5080 FBDFF0EF	  call	LoadWord
FFFC5084 00086933	  mov		a0,v0
                        	
FFFC5088 00428293		add		r5,r5,#4
FFFC508C 00506993	  ldi		a1,#5       ; display a 0 or more digit line no.
FFFC5090 00A06A13	  ldi		a2,#10
FFFC5094 F01FF0EF		call	PRTNUM
FFFC5098 02006913		ldi		a0,#' '     ; followed by a blank
FFFC509C E6CFE0EF		call	GOOUT
FFFC50A0 000069B3		mov		a1,r0       ; stop char. is a zero
FFFC50A4 0002E933		mov		a0,r5
FFFC50A8 DF1FF0EF		call  PRTSTG		; display the rest of the line
FFFC50AC 00072283		lw		$r5,[$sp]
FFFC50B0 00472083		lw		$ra,4[$sp]
FFFC50B4 00872903		lw		$a0,8[$sp]
FFFC50B8 00C72983		lw		$a1,12[$sp]
FFFC50BC 01070713		add		$sp,$sp,#16
FFFC50C0 00008067		ret
                        	
                        	
                        	; ===== Test text byte following the call to this subroutine. If it
                        	;	equals the byte pointed to by t2, return to the code following
                        	;	the call. 
                        	;
                        	; Parameters:
                        	;		<static> word byte to look for
                        	;		<static> branch if not found
                        	; Registers Affected
                        	;   none
                        	; Returns
                        	;		t2 = updated text pointer
                        	;
                        	TSTC:
FFFC50C4 FF470713		sub		$sp,$sp,#12
FFFC50C8 01272023		sw		$a0,[$sp]
FFFC50CC 00172223		sw		$ra,4[$sp]
FFFC50D0 01372423		sw		$a1,8[$sp]
FFFC50D4 0B0000EF		call	IGNBLK		; ignore leading blanks
FFFC50D8 00472083		lw		$ra,4[$sp]	; get return address, it's needed for a reference
FFFC50DC 000E4903		lbu		$a0,[$t2]
FFFC50E0 0000C983		lbu		$a1,[$ra]
FFFC50E4 01298A63		beq		$a1,$a0,TC1	; is it = to what t2 points to? if so
FFFC50E8 00072903		lw		$a0,[$sp]		; restore a0
FFFC50EC 00872983		lw		$a1,8[$sp]
FFFC50F0 00C70713		add		$sp,$sp,#12	;
FFFC50F4 00408067		jmp		4[$ra]			; jump to the routine skip param
                        	TC1:
FFFC50F8 001E0E13		add		$t2,$t2,#1	; if equal, bump text pointer
FFFC50FC 00072903		lw		$a0,[$sp]
FFFC5100 00472083		lw		$ra,4[$sp]
FFFC5104 00872983		lw		$a1,8[$sp]
FFFC5108 00C70713		add		$sp,$sp,#12
FFFC510C 00808067		jmp		8[$ra]			; jump back, skip parm and branch
                        	
                        	
                        	; ===== See if the text pointed to by $t2 is a number. If so,
                        	;	return the number in $v0 and the number of digits in $v1,
                        	;	else return zero in $v0 and $v1.
                        	; Registers Affected
                        	;   a0,a1,r3,r4
                        	; Returns
                        	; 	v0 = number
                        	;		v1 = number of digits in number
                        	;	t2 = updated text pointer
                        	;
                        	TSTNUM:
FFFC5110 FF870713		sub		$sp,$sp,#8
FFFC5114 00172223		sw		$ra,4[$sp]
FFFC5118 00372023		sw		r3,[$sp]
FFFC511C 068000EF		call	IGNBLK		; skip over blanks
FFFC5120 00006833		mov		$v0,$x0		; initialize return parameters
FFFC5124 000068B3		mov		$v1,$x0
                        	TN1:
FFFC5128 000E4183		lbu		r3,[$t2]
FFFC512C 03006D93		ldi		$t1,#'0'
FFFC5130 05B1C263		blt		r3,$t1,TSNMRET; is it less than zero?
FFFC5134 03906D93		ldi		$t1,#'9'
FFFC5138 023DCE63		bgt		r3,$t1,TSNMRET; is it greater than nine?
FFFC513C 00000DB7		ldi		$t1,#$7FFFFFFFFFFFFFF
FFFC5140 FFFD8D93
FFFC5144 010DF863		bleu	$v0,$t1,TN2; see if there's room for new digit
FFFC5148 FFFC5937		ldi		$a0,#msgNumTooBig
FFFC514C 50190913
FFFC5150 AD1FF06F		jmp		ERROR		; if not, we've overflowd
                        	TN2:
FFFC5154 001E0E13		add		$t2,$t2,#1	; adjust text pointer
FFFC5158 00181E93		sll		$t3,$v0,#1	; quickly multiply result by 10
FFFC515C 00381813		sll		$v0,$v0,#3	; *8
FFFC5160 01D80833		add		$v0,$v0,$t3	; *8 + *2
FFFC5164 00F1F193		and		r3,r3,#$0F	; add in the new digit
FFFC5168 00380833		add		$v0,$v0,r3
FFFC516C 00188893		add		$v1,$v1,#1	; increment the no. of digits
FFFC5170 FA000CE3		bra		TN1
                        	TSNMRET:
FFFC5174 00072183		lw		r3,[$sp]
FFFC5178 00472083		lw		$ra,4[$sp]
FFFC517C 00870713		add		$sp,$sp,#8
FFFC5180 00008067		ret
                        	
                        	
                        	;===== Skip over blanks in the text pointed to by $t2.
                        	;
                        	; Registers Affected:
                        	;	$t2
                        	; Returns
                        	;	$t2 = pointer updateded past any spaces or tabs
                        	;
                        	IGNBLK:
FFFC5184 FFC70713		sub		$sp,$sp,#4
FFFC5188 01272023		sw		$a0,[$sp]
                        	IGB2:
FFFC518C 000E4903		lbu		a0,[$t2]			; get char
FFFC5190 02006D93		ldi		$t1,#' '
FFFC5194 01B90663		beq		$a0,$t1,IGB1	; see if it's a space
FFFC5198 00906D93		ldi		$t1,#'\t'
FFFC519C 01B91663		bne		a0,$t1,IGBRET	; or a tab
                        	IGB1:
FFFC51A0 001E0E13		add		$t2,$t2,#1		; increment the text pointer
FFFC51A4 FE0004E3		bra		IGB2
                        	IGBRET:
FFFC51A8 00072903		lw		$a0,[$sp]
FFFC51AC 00470713		add		$sp,$sp,#4
FFFC51B0 00008067		ret
                        	
                        	; ===== Convert the line of text in the input buffer to upper
                        	;	case (except for stuff between quotes).
                        	;
                        	; Registers Affected
                        	;   a0,r3
                        	; Returns
                        	;	r8 = pointing to end of text in buffer
                        	;
                        	TOUPBUF:
FFFC51B4 FFC70713		sub		$sp,$sp,#4
FFFC51B8 00172023		sw		$ra,[$sp]
FFFC51BC 71C06E13		ldi		$t2,#BUFFER	; set up text pointer
FFFC51C0 000061B3		mov		r3,x0		; clear quote flag
                        	TOUPB1:
FFFC51C4 000E4903		lbu		a0,[$t2]		; get the next text char.
FFFC51C8 001E0E13		add		$t2,$t2,#1
FFFC51CC 00D06D93		ldi		$t1,#CR
FFFC51D0 03B90E63		beq		a0,$t1,TOUPBRT		; is it end of line?
FFFC51D4 02206D93		ldi		$t1,#'"'
FFFC51D8 01B90E63		beq		a0,$t1,DOQUO	; a double quote?
FFFC51DC 02706D93		ldi		$t1,#'\''
FFFC51E0 01B90A63		beq		a0,$t1,DOQUO	; or a single quote?
FFFC51E4 FE0190E3		bne		r3,x0,TOUPB1	; inside quotes?
FFFC51E8 030000EF		call	toUpper 	; convert to upper case
FFFC51EC FF0E0FA3		sb		v0,-1[$t2]	; store it
FFFC51F0 FC000AE3		bra		TOUPB1		; and go back for more
                        	DOQUO:
FFFC51F4 00019663		bne		r3,x0,DOQUO1; are we inside quotes?
FFFC51F8 000961B3		mov		r3,a0		; if not, toggle inside-quotes flag
FFFC51FC FC0004E3		bra		TOUPB1
                        	DOQUO1:
FFFC5200 FD2192E3		bne		r3,a0,TOUPB1; make sure we're ending proper quote
FFFC5204 000061B3		mov		r3,r0		; else clear quote flag
FFFC5208 FA000EE3		bra		TOUPB1
                        	TOUPBRT:
FFFC520C 00072083		lw		$ra,[$sp]
FFFC5210 00470713		add		$sp,$sp,#4
FFFC5214 00008067		ret
                        	
                        	
                        	; ===== Convert the character in a0 to upper case
                        	;
                        	toUpper:
FFFC5218 00096833		mov		$v0,$a0
FFFC521C 06182D93		slt		$t1,$v0,#'a'
FFFC5220 000D9863		bne   $t1,$x0,TOUPRET	; is it < 'a'?
FFFC5224 07A06D93		ldi		$t1,#'z'
FFFC5228 010DC463		bgt		$v0,$t1,TOUPRET	; or > 'z'?
FFFC522C FE080813		sub		$v0,$v0,#32	  ; if not, make it upper case
                        	TOUPRET:
FFFC5230 00008067		ret
                        	
                        	; 'CHKIO' checks the input. If there's no input, it will return
                        	; to the caller with the a0=0. If there is input, the input byte is in a0.
                        	; However, if a control-C is read, 'CHKIO' will warm-start BASIC and will
                        	; not return to the caller.
                        	;
                        	//message "CHKIO"
                        	CHKIO:
FFFC5234 FFC70713		sub		$sp,$sp,#4
FFFC5238 00172023		sw		$ra,[$sp]
FFFC523C 228000EF		call	INCH		; get input if possible
FFFC5240 00080863		beq		$v0,$x0,CHKRET	; if Zero, no input
FFFC5244 00384893		xor		$v1,$v0,#CTRLC
FFFC5248 00089463		bne		$v1,$x0,CHKRET; is it control-C?
FFFC524C D74FE06F		jmp		WSTART		; if so, do a warm start
                        	CHKRET:
FFFC5250 00072083		lw		$ra,[$sp]
FFFC5254 00470713		add		$sp,$sp,#4
FFFC5258 00008067		ret
                        	
                        	; ===== Display a CR-LF sequence
                        	;
                        	CRLF:
FFFC525C FFFC5937		ldi		a0,#CLMSG
FFFC5260 4E590913
                        	
                        	; ===== Display a zero-ended string pointed to by register a0
                        	; Registers Affected
                        	;   a0,a1,r4
                        	;
                        	PRMESG:
FFFC5264 FFC70713		sub		$sp,$sp,#4
FFFC5268 00172023		sw		$ra,[$sp]
FFFC526C D10FB0EF		call	PutString
FFFC5270 00072083		lw		$ra,[$sp]
FFFC5274 00470713		add		$sp,$sp,#4
FFFC5278 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;	erc = ALLOCMBX (<handle var>)
                        	;------------------------------------------------------------------------------
                        	
                        	ALLOCMBX:
FFFC527C E49FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC5280 00000028		dw		'('
FFFC5284 04000E63		bra		.paren
FFFC5288 00106913		ldi		a0,#1
FFFC528C D7CFF0EF		call	TSTV
FFFC5290 00081863		bne		v0,x0,.0001
FFFC5294 FFFC5937		ldi		a0,#msgVar
FFFC5298 57A90913
FFFC529C 985FF06F		jmp		ERROR
                        	.0001:
FFFC52A0 E25FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC52A4 00000029		dw		')'
FFFC52A8 02000C63		bra		.paren
FFFC52AC 00086233		mov		s1,v0
FFFC52B0 00E06913		ldi		a0,#14			; get current tid
FFFC52B4 00000073		ecall
FFFC52B8 0008E9B3		mov		a1,v1
FFFC52BC 00026A33		mov		a2,s1
FFFC52C0 00606913		ldi		a0,#6
FFFC52C4 00000073		ecall
FFFC52C8 00081463		bne		v0,x0,.0002
FFFC52CC 01122023		sw		v1,[s1]				; save handle in variable
                        	.0002:
FFFC52D0 000068B3		mov		v1,x0
FFFC52D4 00072083		lw		$ra,[$sp]
FFFC52D8 00470713		add		$sp,$sp,#4
FFFC52DC 00008067		ret
                        	.paren:
FFFC52E0 FFFC5937		ldi		a0,#msgParen
FFFC52E4 68790913
FFFC52E8 939FF06F		jmp		ERROR
                        	
                        	;------------------------------------------------------------------------------
                        	; erc = SENDMSG (<handle var>, <msg data 1>, <msg data 2>, <msg data 3>)
                        	;------------------------------------------------------------------------------
                        	
                        	SENDMSG:
FFFC52EC DD9FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC52F0 00000028		dw		'('
FFFC52F4 08000463		bra		.paren
FFFC52F8 8D0FF0EF		call	OREXPR	; get the mailbox handle
FFFC52FC 00086233		mov		s1,v0
FFFC5300 DC5FF0EF		call	TSTC		; it must be followed by a comma
FFFC5304 0000002C		dw		','
FFFC5308 06000463		bra		.err
FFFC530C 8BCFF0EF		call	OREXPR	; get the memory address
FFFC5310 000862B3		mov		s2,v0
FFFC5314 DB1FF0EF		call	TSTC		; it must be followed by a comma
FFFC5318 0000002C		dw		','
FFFC531C 04000A63		bra		.err
FFFC5320 8A8FF0EF		call	OREXPR	; get the memory address
FFFC5324 00086333		mov		s3,v0
FFFC5328 D9DFF0EF		call	TSTC		; it must be followed by a comma
FFFC532C 0000002C		dw		','
FFFC5330 04000063		bra		.err
FFFC5334 894FF0EF		call	OREXPR	; get the memory address
FFFC5338 000863B3		mov		s4,v0
FFFC533C D89FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC5340 00000029		dw		')'
FFFC5344 02000C63		bra		.paren
FFFC5348 00906913		ldi		a0,#9		; SendMsg
FFFC534C 000269B3		mov		a1,s1
FFFC5350 0002EA33		mov		a2,s2
FFFC5354 00036AB3		mov		a3,s3
FFFC5358 0003EB33		mov		a4,s4
FFFC535C 00000073		ecall
FFFC5360 000068B3		mov		v1,x0
FFFC5364 00072083		lw		$ra,[$sp]
FFFC5368 00470713		add		$sp,$sp,#4
FFFC536C 00008067		ret
                        	.err:
FFFC5370 FFFC5937		ldi		a0,#msgComma
FFFC5374 55290913
FFFC5378 8A9FF06F		jmp		ERROR
                        	.paren:
FFFC537C FFFC5937		ldi		a0,#msgParen
FFFC5380 68790913
FFFC5384 89DFF06F		jmp		ERROR
                        	
                        	;------------------------------------------------------------------------------
                        	; WAITMSG <handle var>, <var for data 1>, <var for data 2>, <var for data 3>,
                        	;		<expr>
                        	;------------------------------------------------------------------------------
                        	
                        	WAITMSG:
FFFC5388 D3DFF0EF		call	TSTC		; else look for ( OREXPR )
FFFC538C 00000028		dw		'('
FFFC5390 0C000263		bra		.paren
FFFC5394 834FF0EF		call	OREXPR	; get the mailbox handle
FFFC5398 00086233		mov		s1,v0
FFFC539C D29FF0EF		call	TSTC		; it must be followed by a comma
FFFC53A0 0000002C		dw		','
FFFC53A4 0A000263		bra		.err
FFFC53A8 00106913		ldi		a0,#1
FFFC53AC C5CFF0EF		call	TSTV
FFFC53B0 00081863		bne		v0,x0,.0001
                        	.0002:
FFFC53B4 FFFC5937		ldi		a0,#msgVar
FFFC53B8 57A90913
FFFC53BC 865FF06F		jmp		ERROR
                        	.0001:
FFFC53C0 D05FF0EF		call	TSTC		; it must be followed by a comma
FFFC53C4 0000002C		dw		','
FFFC53C8 08000063		bra		.err
FFFC53CC 000862B3		mov		s2,v0
FFFC53D0 00106913		ldi		a0,#1
FFFC53D4 C34FF0EF		call	TSTV
FFFC53D8 FC080EE3		beq		v0,x0,.0002
FFFC53DC CE9FF0EF		call	TSTC		; it must be followed by a comma
FFFC53E0 0000002C		dw		','
FFFC53E4 06000263		bra		.err
FFFC53E8 00086333		mov		s3,v0
FFFC53EC 00106913		ldi		a0,#1
FFFC53F0 C18FF0EF		call	TSTV
FFFC53F4 FC0800E3		beq		v0,x0,.0002
FFFC53F8 000863B3		mov		s4,v0
FFFC53FC CC9FF0EF		call	TSTC		; it must be followed by a comma
FFFC5400 0000002C		dw		','
FFFC5404 04000263		bra		.err
FFFC5408 FC1FE0EF		call	OREXPR	; get queue remove flag
FFFC540C 00086BB3		mov		a5,v0
FFFC5410 000863B3		mov		s4,v0
FFFC5414 CB1FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC5418 00000029		dw		')'
FFFC541C 02000C63		bra		.paren
FFFC5420 00A06913		ldi		a0,#10		; WaitMsg
FFFC5424 000269B3		mov		a1,s1
FFFC5428 0002EA33		mov		a2,s2
FFFC542C 00036AB3		mov		a3,s3
FFFC5430 0003EB33		mov		a4,s4
FFFC5434 00000073		ecall
FFFC5438 000068B3		mov		v1,x0
FFFC543C 00072083		lw		$ra,[$sp]
FFFC5440 00470713		add		$sp,$sp,#4
FFFC5444 00008067		ret
                        	.err:
FFFC5448 FFFC5937		ldi		a0,#msgComma
FFFC544C 55290913
FFFC5450 FD0FF06F		jmp		ERROR
                        	.paren:
FFFC5454 FFFC5937		ldi		a0,#msgParen
FFFC5458 68790913
FFFC545C FC4FF06F		jmp		ERROR
                        	
                        	;*****************************************************
                        	; The following routines are the only ones that need *
                        	; to be changed for a different I/O environment.     *
                        	;*****************************************************
                        	
                        	; ===== Output character to the console (Port 1) from register a0
                        	;	(Preserves all registers.)
                        	;
                        	OUTC:
FFFC5460 DD5FA06F		jmp		Putch
                        	
                        	; ===== Input a character from the console into register v0 (or
                        	;	return Zero status if there's no character available).
                        	;
                        	INCH:
FFFC5464 FFC70713		sub 	$sp,$sp,#4
FFFC5468 00172023		sw		$ra,[$sp]
FFFC546C DA1FA0EF		call	Getch
FFFC5470 00180813		add		$v0,$v0,#1				; prepare test -1
FFFC5474 00080A63		beq		$v0,$x0,INCH1			; was = -1
FFFC5478 FFF80813		sub		$v0,$v0,#1				; get char back
FFFC547C 00072083		lw		$ra,[$sp]
FFFC5480 00470713		add		$sp,$sp,#4
FFFC5484 00008067		ret
                        	INCH1:
FFFC5488 00072083		lw		$ra,[$sp]		; return a zero for no-char
FFFC548C 00470713		add		$sp,$sp,#4
FFFC5490 00008067		ret
                        	
                        	; ===== Return to the resident monitor, operating system, etc.
                        	;
                        	//message "BYEBYE"
                        	BYEBYE:
                        	//	call	ReleaseIOFocus
FFFC5494 70002703		lw		$sp,OSSP
FFFC5498 E29FA06F		jmp		Monitor
                        	 
                        	
FFFC549C 53430A0D	msgInit	db	CR,LINEFD,"CS01 Tiny BASIC v1.0",CR,LINEFD,"(C) 2017-2020  Robert Finch",CR,CR,0
FFFC54A0 54203130
FFFC54A4 20796E69
FFFC54A8 49534142
FFFC54AC 31762043
FFFC54B0 0A0D302E
FFFC54B4 20294328
FFFC54B8 37313032
FFFC54BC 3230322D
FFFC54C0 52202030
FFFC54C4 7265626F
FFFC54C8 69462074
FFFC54CC 0D68636E
FFFC54D0 0A0D000D
FFFC54D2 4B4F0A0D	OKMSG	db	CR,LINEFD,"OK",CR,0
FFFC54D6 6857000D
FFFC54D8 74616857	msgWhat	db	"What?",CR,0
FFFC54DC 53000D3F
FFFC54DF 72726F53	SRYMSG	db	"Sorry."
FFFC54E3 000D2E79
FFFC54E5 6F43000D	CLMSG	db	CR,0
FFFC54E7 706D6F43	msgReadError	db	"Compact FLASH read error",CR,0
FFFC54EB 20746361
FFFC54EF 53414C46
FFFC54F3 65722048
FFFC54F7 65206461
FFFC54FB 726F7272
FFFC54FF 754E000D
FFFC5501 626D754E	msgNumTooBig	db	"Number is too big",CR,0
FFFC5505 69207265
FFFC5509 6F742073
FFFC550D 6962206F
FFFC5511 44000D67
FFFC5514 69766944	msgDivZero		db	"Division by zero",CR,0
FFFC5518 6E6F6973
FFFC551C 20796220
FFFC5520 6F72657A
FFFC5524 754F000D
FFFC5526 2074754F	msgVarSpace     db  "Out of variable space",CR,0
FFFC552A 7620666F
FFFC552E 61697261
FFFC5532 20656C62
FFFC5536 63617073
FFFC553A 20000D65
FFFC553D 74796220	msgBytesFree	db	" bytes free",CR,0
FFFC5541 66207365
FFFC5545 0D656572
FFFC5549 65520D00
FFFC554A 6165520D	msgReady		db	CR,"Ready",CR,0
FFFC554E 000D7964
FFFC5552 65707845	msgComma		db	"Expecting a comma",CR,0
FFFC5556 6E697463
FFFC555A 20612067
FFFC555E 6D6D6F63
FFFC5562 4C000D61
FFFC5565 656E694C	msgLineRange	db	"Line number too big",CR,0
FFFC5569 6D756E20
FFFC556D 20726562
FFFC5571 206F6F74
FFFC5575 0D676962
FFFC5579 70784500
FFFC557A 65707845	msgVar			db "Expecting a variable",CR,0
FFFC557E 6E697463
FFFC5582 20612067
FFFC5586 69726176
FFFC558A 656C6261
FFFC558E 4E52000D
FFFC5590 20444E52	msgRNDBad		db	"RND bad parameter",CR,0
FFFC5594 20646162
FFFC5598 61726170
FFFC559C 6574656D
FFFC55A0 53000D72
FFFC55A3 20535953	msgSYSBad		db	"SYS bad address",CR,0
FFFC55A7 20646162
FFFC55AB 72646461
FFFC55AF 0D737365
FFFC55B3 504E4900
FFFC55B4 55504E49	msgInputVar		db	"INPUT expecting a variable",CR,0
FFFC55B8 78652054
FFFC55BC 74636570
FFFC55C0 20676E69
FFFC55C4 61762061
FFFC55C8 62616972
FFFC55CC 000D656C
FFFC55D0 5458454E	msgNextFor		db	"NEXT without FOR",CR,0
FFFC55D4 74697720
FFFC55D8 74756F68
FFFC55DC 524F4620
FFFC55E0 454E000D
FFFC55E2 5458454E	msgNextVar		db	"NEXT expecting a defined variable",CR,0
FFFC55E6 70786520
FFFC55EA 69746365
FFFC55EE 6120676E
FFFC55F2 66656420
FFFC55F6 64656E69
FFFC55FA 72617620
FFFC55FE 6C626169
FFFC5602 47000D65
FFFC5605 4F544F47	msgBadGotoGosub	db	"GOTO/GOSUB bad line number",CR,0
FFFC5609 534F472F
FFFC560D 62204255
FFFC5611 6C206461
FFFC5615 20656E69
FFFC5619 626D756E
FFFC561D 000D7265
FFFC5621 55544552	msgRetWoGosub   db	"RETURN without GOSUB",CR,0
FFFC5625 77204E52
FFFC5629 6F687469
FFFC562D 47207475
FFFC5631 4255534F
FFFC5635 7250000D
FFFC5637 676F7250	msgTooBig		db	"Program is too big",CR,0
FFFC563B 206D6172
FFFC563F 74207369
FFFC5643 62206F6F
FFFC5647 000D6769
FFFC564B 72747845	msgExtraChars	db	"Extra characters on line ignored",CR,0
FFFC564F 68632061
FFFC5653 63617261
FFFC5657 73726574
FFFC565B 206E6F20
FFFC565F 656E696C
FFFC5663 6E676920
FFFC5667 6465726F
FFFC566B 4520000D
FFFC566D 766E4520	msgEnvFail		db	" Environment call failed",CR,0
FFFC5671 6E6F7269
FFFC5675 746E656D
FFFC5679 6C616320
FFFC567D 6166206C
FFFC5681 64656C69
FFFC5685 7845000D
FFFC5687 65707845	msgParen		db	"Expecting parenthesis",CR,0
FFFC568B 6E697463
FFFC568F 61702067
FFFC5693 746E6572
FFFC5697 69736568
FFFC569B 00000D73
                        	
                        	LSTROM	equ	*		; end of possible ROM area
;	END
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	
                        		rodata
                        		align 8                        	
                        	begin_init_data:
                        	_begin_init_data:
                        	
                        		rodata
                        		align 8                        	
                        	end_init_data:
                        	_end_init_data:
1002 symbols
  Symbol Name                              seg     address bits
  ABS                                        code  fffc4a9c 18
  ABS1                                       code  fffc4ab0 18
  ADDEXPR                                    code  fffc4644 18
  ALLOCMBX                                   code  fffc527c 18
  ALLOCMBX.0001                              code  fffc52a0 18
  ALLOCMBX.0002                              code  fffc52d0 18
  ALLOCMBX.paren                             code  fffc52e0 18
  ANDEXPR                                    code  fffc4430 18
  AUXIN                                      code  8000000000000288 32
  AUXIN_INIT                                 code  8000000000000346 32
  AUXOCRLF                                   code  fffc427c 18
  AUXOUT                                     code  8000000000000286 32
  AUXOUT_FLUSH                               code  8000000000000353 32
  AUXOUT_INIT                                code  800000000000034a 32
  Alloc                                      code  fffc0df8 18
  Alloc.0001                                 code  fffc0e74 18
  Alloc.enough                               code  fffc0e38 18
  Alloc.noRun                                code  fffc0e98 18
  Alloc.noRun2                               code  fffc0e30 18
  Alloc.xit                                  code  fffc0e9c 18
  AllocStack                                 code  fffc0eb4 18
  AllocStack.0001                            code  fffc0ed8 18
  AllocStack.xit                             code  fffc0eec 18
  AllocTCB                                   code  fffc2984 18
  AllocTCB.0001                              code  fffc2998 18
  AllocTCB.0002                              code  fffc29d0 18
  AllocTCB.0003                              code  fffc29e0 18
  AllocTCB.allocTid                          code  fffc29c4 18
  BASPRMPT                                   code  fffc37e0 18
  BS                                        const  000008 5
  BUFFER                                    const  00071c 12
  BUFLEN                                    const  000054 8
  BYEBYE                                     code  fffc5494 18
  CHKIO                                      code  fffc5234 18
  CHKRET                                     code  fffc5250 18
  CLMSG                                      code  fffc54e5 18
  CR                                        const  00000d 5
  CRLF                                       code  fffc525c 18
  CSTART                                     code  fffc3730 32
  CTRLC                                     const  000003 3
  CTRLH                                     const  000008 5
  CTRLI                                     const  000009 5
  CTRLJ                                     const  00000a 5
  CTRLK                                     const  00000b 5
  CTRLM                                     const  00000d 5
  CTRLS                                     const  000013 6
  CTRLX                                     const  000018 6
  CURRNT                                    const  000718 12
  CopyDevFuncTbl                             code  fffc2eb4 18
  CopyDevFuncTbl.again                       code  fffc2ec8 18
  CursorFlash                               const  0007b0 12
  CursorX                                   const  024800 19
  CursorY                                   const  024801 19
  DCB_LastErc                               const  000018 6
  DCB_Mbx                                   const  000048 8
  DCB_Name                                  const  000000 1
  DCB_ReentCount                            const  000038 7
  DCB_Resv1                                 const  000058 8
  DCB_Resv2                                 const  000060 8
  DCB_Size                                  const  000068 8
  DCB_StartBlock                            const  000020 7
  DCB_Type                                  const  00000c 5
  DCB_fSingleUser                           const  000039 7
  DCB_hJob                                  const  000040 8
  DCB_nBPB                                  const  000010 6
  DCB_nBlocks                               const  000028 7
  DCB_pCmdProc                              const  000030 7
  DCB_pSema                                 const  000050 8
  DEFLT                                      code  fffc3ff4 18
  DEL                                       const  00007f 8
  DIRECT                                     code  fffc3aa0 18
  DOQUO                                      code  fffc51f4 18
  DOQUO1                                     code  fffc5200 18
  DRSP_DONE                                 const  000001 2
  DVC_BuildBPB                              const  000005 4
  DVC_Close                                 const  000007 4
  DVC_FlushInput                            const  000014 6
  DVC_FlushOutput                           const  000015 6
  DVC_GetChar                               const  000008 5
  DVC_GetCharDirect                         const  00000a 5
  DVC_IOCTRL_READ                           const  000018 6
  DVC_IOCTRL_WRITE                          const  000019 6
  DVC_IRQ                                   const  000016 6
  DVC_Initialize                            const  000002 3
  DVC_InputStatus                           const  00000c 5
  DVC_IsRemoveable                          const  000017 6
  DVC_MediaCheck                            const  000004 4
  DVC_Nop                                   const  000000 1
  DVC_Open                                  const  000006 4
  DVC_OutputStatus                          const  000013 6
  DVC_OutputUntilBusy                       const  00001a 6
  DVC_PeekChar                              const  000009 5
  DVC_PeekCharDirect                        const  00000b 5
  DVC_PutChar                               const  00000d 5
  DVC_ReadBlock                             const  000010 6
  DVC_SetPosition                           const  00000f 5
  DVC_Setup                                 const  000001 2
  DVC_Status                                const  000003 3
  DVC_VerifyBlock                           const  000012 6
  DVC_WriteBlock                            const  000011 6
  DVF_Base                                  const  022000 19
  DVF_Limit                                 const  024000 19
  DeleteLine                                 code  fffc3894 18
  DeleteLine.0001                            code  fffc38b4 18
  DeleteLine.0002                            code  fffc38a0 18
  DeleteLine.0003                            code  fffc38b8 18
  DispAttr                                  const  024808 19
  DumpReadyList                              code  fffc2a30 18
  DumpReadyList.0001                         code  fffc2aac 18
  DumpReadyList.0002                         code  fffc2a68 18
  DumpReadyList.brk                          code  fffc2af4 18
  DumpReadyList.nxt                          code  fffc2ae8 18
  DumpReadyQueue                             code  8000000000000199 32
  DumpTimeoutList                            code  fffc2b20 18
  DumpTimeoutList.0002                       code  fffc2b5c 18
  DumpTimeoutList.brk                        code  fffc2b94 18
  ENDCHK                                     code  fffc4bd0 18
  ENDMEM                                    const  008000 17
  ERETx                                      code  80000000000001fe 32
  ERROR                                      code  fffc4c20 18
  ERROR1                                     code  fffc4c60 18
  EX1                                        code  fffc3aec 18
  EXEC                                       code  fffc3ab0 18
  EXGO                                       code  fffc3b14 18
  EXLP                                       code  fffc3abc 18
  EXMAT                                      code  fffc3b00 18
  EXNGO                                      code  fffc3ad4 18
  EXPR                                       code  fffc4520 18
  E_Arg                                     const  000001 2
  E_BadAlarm                                const  000011 6
  E_BadBlockNum                             const  000025 7
  E_BadCallno                               const  00001a 6
  E_BadDevNum                               const  000020 7
  E_BadDevOp                                const  000022 7
  E_BadMbx                                  const  000004 4
  E_DCBInUse                                const  000019 6
  E_NoDev                                   const  000021 7
  E_NoMem                                   const  00000c 5
  E_NoMoreAlarmBlks                         const  000044 8
  E_NoMoreMbx                               const  000040 8
  E_NoMoreMsgBlks                           const  000041 8
  E_NoMoreTCBs                              const  000045 8
  E_NoMsg                                   const  00000b 5
  E_NoThread                                const  000006 4
  E_NotAlloc                                const  000009 5
  E_NotOwner                                const  000012 6
  E_Ok                                      const  000000 1
  E_QueFull                                 const  000005 4
  E_QueStrategy                             const  000013 6
  E_ReadError                               const  000023 7
  E_Timeout                                 const  000010 6
  E_TooManyBlocks                           const  000026 7
  E_WriteError                              const  000024 7
  EditMem                                    code  fffc05ac 18
  FI1                                        code  fffc4bb0 18
  FI2                                        code  fffc4bc4 18
  FILEBUF                                   const  07f600 20
  FILENAME                                  const  0006c0 12
  FIN                                        code  fffc4b94 18
  FINISH                                     code  fffc3d60 18
  FMTKInit                                   code  fffc1a20 18
  FMTKInit.0001                              code  fffc1aec 18
  FMTKInit.0002                              code  fffc1b20 18
  FMTKInit.0003                              code  fffc1ad0 18
  FMTK_AllocMbx                              code  fffc2348 18
  FMTK_AllocMbx.badArg                       code  fffc23a8 18
  FMTK_AllocMbx.noOwner                      code  fffc2380 18
  FMTK_AllocMbx.nxt                          code  fffc2360 18
  FMTK_AllocMbx.xit                          code  fffc23ac 18
  FMTK_ExitTask                              code  fffc224c 18
  FMTK_ExitTask.xit                          code  fffc226c 18
  FMTK_ForceReleaseIOFocus                   code  fffc2db4 18
  FMTK_ForceReleaseIOFocus.0001              code  fffc2e58 18
  FMTK_ForceReleaseIOFocus.done              code  fffc2e64 18
  FMTK_ForceReleaseIOFocus.noFocus           code  fffc2e64 18
  FMTK_ForceReleaseIOFocus.notSame           code  fffc2e24 18
  FMTK_ForceReleaseIOFocus.pjSame            code  fffc2e44 18
  FMTK_FreeMbx                               code  fffc23b8 18
  FMTK_FreeMbx.0001                          code  fffc2424 18
  FMTK_FreeMbx.0002                          code  fffc23e8 18
  FMTK_FreeMbx.0003                          code  fffc2414 18
  FMTK_FreeMbx.badMbx                        code  fffc2438 18
  FMTK_FreeMbx.xit                           code  fffc243c 18
  FMTK_GetCurrentTid                         code  fffc1b58 18
  FMTK_HasIOFocus                            code  fffc2c20 18
  FMTK_HasIOFocus.hasFocus                   code  fffc2c74 18
  FMTK_HasIOFocus.noSwitch                   code  fffc2c4c 18
  FMTK_HasIOFocus.xit                        code  fffc2c78 18
  FMTK_IO                                    code  fffc2e6c 18
  FMTK_IO.badDev                             code  fffc2eac 18
  FMTK_IO.badFunc                            code  fffc2ea4 18
  FMTK_IO.xit                                code  fffc2ea0 18
  FMTK_Initialize                            code  800000000000018b 32
  FMTK_KillTask                              code  fffc2278 18
  FMTK_KillTask.immortal                     code  fffc22d8 18
  FMTK_KillTask.xit                          code  fffc22dc 18
  FMTK_PeekMsg                               code  fffc2558 18
  FMTK_PeekMsg.badMbx                        code  fffc2610 18
  FMTK_PeekMsg.noMsg                         code  fffc2608 18
  FMTK_PeekMsg.nod1                          code  fffc25d8 18
  FMTK_PeekMsg.nod2                          code  fffc25ec 18
  FMTK_PeekMsg.nod3                          code  fffc2600 18
  FMTK_PeekMsg.nodq                          code  fffc25c0 18
  FMTK_PeekMsg.ret                           code  fffc2614 18
  FMTK_PostMsg                               code  8000000000000193 32
  FMTK_ReleaseIOFocus                        code  fffc2da8 18
  FMTK_RequestIOFocus                        code  fffc2d1c 18
  FMTK_RequestIOFocus.notEmpty               code  fffc2d88 18
  FMTK_RequestIOFocus.ret                    code  fffc2da0 18
  FMTK_SchedulerIRQ                          code  fffc2038 18
  FMTK_SchedulerIRQ.0001                     code  fffc2094 18
  FMTK_SchedulerIRQ.0002                     code  fffc210c 18
  FMTK_SchedulerIRQ.0003                     code  fffc2120 18
  FMTK_SchedulerIRQ.0004                     code  fffc2134 18
  FMTK_SchedulerIRQ.noException              code  fffc20ec 18
  FMTK_SchedulerIRQ.noLock                   code  fffc2158 18
  FMTK_SchedulerIRQ.noMsg                    code  fffc213c 18
  FMTK_SchedulerIRQ.noTimeout                code  fffc20c8 18
  FMTK_SchedulerIRQ.notZero                  code  fffc20c8 18
  FMTK_SendMsg                               code  fffc2448 18
  FMTK_SendMsg.0001                          code  fffc2478 18
  FMTK_SendMsg.badMbx                        code  fffc2548 18
  FMTK_SendMsg.mbxEmpty                      code  fffc2530 18
  FMTK_SendMsg.noMsg                         code  fffc2540 18
  FMTK_SendMsg.noWaiters                     code  fffc24d8 18
  FMTK_SendMsg.nxtTid                        code  fffc24bc 18
  FMTK_SendMsg.xit                           code  fffc254c 18
  FMTK_SetTaskPriority                       code  800000000000018f 32
  FMTK_Sleep                                 code  fffc1f38 18
  FMTK_Sleep.0001                            code  fffc1f74 18
  FMTK_Sleep.0002                            code  fffc1fdc 18
  FMTK_Sleep.0003                            code  fffc1ff0 18
  FMTK_Sleep.0004                            code  fffc2004 18
  FMTK_Sleep.noException                     code  fffc1fc0 18
  FMTK_Sleep.noMsg                           code  fffc200c 18
  FMTK_Sleep.wait                            code  fffc2014 18
  FMTK_Sleep.xit                             code  fffc202c 18
  FMTK_StartApp                              code  8000000000000197 32
  FMTK_StartTask                             code  fffc2170 18
  FMTK_StartTask.err                         code  fffc2240 18
  FMTK_StartTask.xit                         code  fffc2240 18
  FMTK_SwitchIOFocus                         code  fffc2c80 18
  FMTK_SwitchIOFocus.0001                    code  fffc2cbc 18
  FMTK_SwitchIOFocus.0002                    code  fffc2cd4 18
  FMTK_SwitchIOFocus.0003                    code  fffc2cec 18
  FMTK_SwitchIOFocus.0004                    code  fffc2d04 18
  FMTK_SwitchIOFocus.noFocus                 code  fffc2d14 18
  FMTK_SwitchIOFocus.sameFocus               code  fffc2d14 18
  FMTK_WaitMsg                               code  fffc2620 18
  FMTK_WaitMsg.qt                            code  fffc2644 18
  FMTK_WaitMsg.xit                           code  fffc2698 18
  FNDLN                                      code  fffc4d58 18
  FNDLNP                                     code  fffc4d78 18
  FNDNXT                                     code  fffc4dd4 18
  FNDRET                                     code  fffc4da8 18
  FNDRET.0001                                code  fffc4dac 18
  FNDRET1                                    code  fffc4dc4 18
  FNDRET2                                    code  fffc4dcc 18
  FNDSKP                                     code  fffc4dd8 18
  FOR                                        code  fffc3df0 18
  FORCEFIT                                   code  fffc44f8 18
  FORCEFIT.0001                              code  fffc451c 18
  FORCEFIT.intAnd                            code  fffc450c 18
  FR1                                        code  fffc3e10 18
  FR2                                        code  fffc3e2c 18
  FR3                                        code  fffc3e34 18
  FR4                                        code  fffc3e38 18
  FR5                                        code  fffc3e3c 18
  FR6                                        code  fffc3e54 18
  FR7                                        code  fffc3e58 18
  FR8                                        code  fffc3e78 18
  FUNCEXPR                                   code  fffc4778 18
  FillMem                                    code  fffc05c4 18
  FillMem.0001                               code  fffc05e0 18
  FindRun                                    code  fffc0d94 18
  FindRun.0001                               code  fffc0db4 18
  FindRun.0002                               code  fffc0dc4 18
  FindRun.empty0                             code  fffc0dcc 18
  FindRun.empty1                             code  fffc0dd0 18
  FindRun.foundEnough                        code  fffc0df0 18
  FreeAll                                    code  fffc0ef0 18
  FreeAll.0001                               code  fffc0f50 18
  FreeAll.nxt                                code  fffc0ef8 18
  FreeMsg                                   const  024350 19
  FreeTCB                                    code  fffc29fc 18
  GCHAR                                      code  fffc4078 18
  GCHAR1                                     code  fffc4090 18
  GETLN                                      code  fffc4c64 18
  GETLN.GL1                                  code  fffc4c84 18
  GETLN.GL2                                  code  fffc4cac 18
  GETLN.GL3                                  code  fffc4cdc 18
  GETLN.GL4                                  code  fffc4d04 18
  GETLN.GL5                                  code  fffc4d14 18
  GETLN.GL6                                  code  fffc4d34 18
  GETLN.GL7                                  code  fffc4d3c 18
  GOAUXI                                     code  fffc3718 18
  GOAUXO                                     code  fffc3710 18
  GOBYE                                      code  fffc3720 18
  GOIN                                       code  fffc370c 18
  GOOUT                                      code  fffc3708 18
  GOSTART                                    code  fffc3700 18
  GOSUB                                      code  fffc3d68 18
  GOTO                                       code  fffc3be4 18
  GOWARM                                     code  fffc3704 18
  GetBuflen                                  code  fffc38fc 18
  GetBuflen.0001                             code  fffc3924 18
  GetBuflen.0002                             code  fffc3908 18
  GetBuflen.0004                             code  fffc3920 18
  GetCurrentTid                              code  fffc1b4c 18
  GetFilename                                code  fffc40dc 18
  GetHexNum                                  code  fffc061c 18
  GetHexNum.0001                             code  fffc066c 18
  GetHexNum.isDigit                          code  fffc06a8 18
  GetHexNum.isHexLower                       code  fffc0690 18
  GetHexNum.isHexUpper                       code  fffc0678 18
  GetHexNum.next                             code  fffc062c 18
  Getch                                      code  fffc020c 18
  IF0                                        code  fffc3ef4 18
  IF1                                        code  fffc3ef8 18
  IF2                                        code  fffc3f00 18
  IF3                                        code  fffc3f14 18
  IGB1                                       code  fffc51a0 18
  IGB2                                       code  fffc518c 18
  IGBRET                                     code  fffc51a8 18
  IGNBLK                                     code  fffc5184 18
  INBUF                                     const  014100 18
  INCH                                       code  fffc5464 18
  INCH1                                      code  fffc5488 18
  INPERR                                     code  fffc3f18 18
  INPPTR                                    const  0007ac 12
  INPUT                                      code  fffc3f34 18
  INSLINE                                    code  fffc3854 18
  INSLINE.0001                               code  fffc3880 18
  IOF_NEXT                                  const  0002e8 11
  IOF_PREV                                  const  0002f0 11
  IOFocusNdx                                const  024810 19
  IOFocusTbl                                const  024818 19
  IP2                                        code  fffc3f5c 18
  IP3                                        code  fffc3f98 18
  IP4                                        code  fffc3fd8 18
  IP5                                        code  fffc3fe8 18
  IP6                                        code  fffc3f3c 18
  IP7                                        code  fffc3f7c 18
  IRQFlag                                   const  0007b4 12
  IRQROUT                                   const  0007a4 12
  IRQRout                                    code  fffc07dc 18
  IRQRout.isIRQ                              code  fffc07fc 18
  IRQRout.noIRQ                              code  fffc081c 18
  IdleTask                                   code  fffc0208 18
  InsertIntoReadyList                        code  fffc26a4 18
  InsertIntoReadyList.0001                   code  fffc2738 18
  InsertIntoReadyList.badTid                 code  fffc2740 18
  InsertIntoReadyList.insert                 code  fffc2704 18
  InsertIntoReadyList.level2                 code  fffc2724 18
  InsertIntoTimeoutList                      code  fffc2800 18
  InsertIntoTimeoutList.0001                 code  fffc2858 18
  InsertIntoTimeoutList.0002                 code  fffc28c0 18
  InsertIntoTimeoutList.0003                 code  fffc28d0 18
  InsertIntoTimeoutList.beginWhile           code  fffc2864 18
  InsertIntoTimeoutList.endOfList            code  fffc2884 18
  InsertIntoTimeoutList.endWhile             code  fffc2894 18
  InsertLine                                 code  fffc38dc 18
  InsertLine.0001                            code  fffc38e0 18
  InsertLine.done                            code  fffc38f8 18
  KEYBD                                      code  800000000000023c 32
  KeybdFuncTbl                               code  fffc31f0 18
  KeybdIRQ                                   code  fffc358c 18
  KeybdIRQ.0001                              code  fffc3618 18
  KeybdIRQ.noRoom                            code  fffc35c8 18
  KeybdIRQ.notAlt                            code  8000000000000257 32
  KeybdIRQ.notAltTab                         code  fffc3638 18
  KeybdIRQ.notCtrl                           code  fffc3618 18
  KeybdIRQ.notCtrlC                          code  fffc35f4 18
  KeybdIRQ.notCtrlZ                          code  fffc3618 18
  KeybdIRQ.notKbd                            code  fffc3674 18
  KillTask                                   code  80000000000001cf 32
  LEDS                                      const  ffdc0600 33
  LET                                        code  fffc4000 18
  LINEFD                                    const  00000a 5
  LISTX                                      code  fffc3c80 18
  LOAD                                       code  fffc4018 18
  LOAD3                                      code  fffc4148 18
  LOAD4                                      code  fffc4174 18
  LOAD5                                      code  fffc41ac 18
  LOD1                                       code  fffc4028 18
  LOD2                                       code  fffc4054 18
  LODEND                                     code  fffc4070 18
  LOG_MBXSZ                                 const  000005 4
  LOG_MSGSZ                                 const  000005 4
  LOG_PGSZ                                  const  000010 6
  LOG_TCBSZ                                 const  00000a 5
  LOPINC                                    const  000778 12
  LOPLMT                                    const  00077c 12
  LOPLN                                     const  000774 12
  LOPPT                                     const  000770 12
  LOPVAR                                    const  000710 12
  LS1                                        code  fffc3c94 18
  LS2                                        code  fffc3cbc 18
  LS3                                        code  fffc3cc4 18
  LS4                                        code  fffc3ca0 18
  LS5                                        code  fffc3c98 18
  LSTROM                                    const  000000 1
  LT1                                        code  fffc4014 18
  LoadWord                                   code  fffc503c 18
  MAX_DEV_OP                                const  00001f 6
  MAX_TID                                   const  00003f 7
  MBX_MQHEAD                                const  000010 6
  MBX_MQTAIL                                const  000018 6
  MBX_OWNER                                 const  000000 1
  MBX_SIZE                                  const  000020 7
  MBX_WTIDS                                 const  000008 5
  MMUInit                                    code  fffc0ce4 18
  MMUInit.0001                               code  fffc0d1c 18
  MMUInit.0002                               code  fffc0d78 18
  MMUInit.0003                               code  fffc0d38 18
  MMUInit.0004                               code  fffc0d0c 18
  MMUInit.0006                               code  fffc0d50 18
  MSG_D1                                    const  000008 5
  MSG_D2                                    const  000010 6
  MSG_D3                                    const  000018 6
  MSG_LINK                                  const  000000 1
  MSG_SIZE                                  const  000020 7
  MULEXPR                                    code  fffc46dc 18
  MVDOWN                                     code  fffc4e14 18
  MVDOWN1                                    code  fffc4e04 18
  MVUP                                       code  fffc4dfc 18
  MVUP1                                      code  fffc4dec 18
  MachineStart                               code  fffc0100 18
  MapOSPages                                 code  fffc1b70 18
  MapOSPages.nxt                             code  fffc1b7c 18
  MbxRemoveTask                              code  fffc22e8 18
  MbxRemoveTask.xit                          code  fffc2330 18
  MonEntry                                   code  fffc02b8 18
  Monitor                                    code  fffc02c0 18
  Monitor.0001                               code  fffc02ec 18
  Monitor.0002                               code  fffc033c 18
  Monitor.0003                               code  fffc03a0 18
  Monitor.0004                               code  fffc0428 18
  Monitor.0005                               code  fffc0520 18
  Monitor.0006                               code  fffc048c 18
  Monitor.0007                               code  fffc04bc 18
  Monitor.0008                               code  fffc04c8 18
  Monitor.0009                               code  fffc04d4 18
  Monitor.0010                               code  fffc04ec 18
  Monitor.0011                               code  fffc0508 18
  Monitor.0012                               code  fffc0520 18
  Monitor.doBackspace                        code  fffc038c 18
  Monitor.doDelete                           code  fffc0334 18
  Monitor.noT                                code  fffc04b4 18
  Monitor.procLine                           code  fffc03f0 18
  Monitor.skip                               code  fffc0404 18
  Monitor.skip2                              code  fffc0420 18
  NEW                                        code  fffc3b28 18
  NEXT                                       code  fffc3e7c 18
  NPAGES                                    const  024828 19
  NR_DCB                                    const  000020 7
  NR_MBX                                    const  000100 10
  NR_MSG                                    const  000800 13
  NR_TCB                                    const  000040 8
  NUMWKA                                    const  000794 12
  NX0                                        code  fffc3e98 18
  NX1                                        code  fffc3ed8 18
  NX2                                        code  fffc3eb8 18
  NX3                                        code  fffc3edc 18
  NX4                                        code  fffc3e94 18
  NX5                                        code  fffc3eac 18
  NXPurge                                    code  fffc3eec 18
  OKMSG                                      code  fffc54d2 18
  ONIRQ                                      code  fffc3c48 18
  ONIRQ1                                     code  fffc3c68 18
  OREXPR                                     code  fffc43c8 18
  OSCALL                                     code  fffc1ed0 18
  OSCALL.xit                                 code  fffc1f20 18
  OSCALL.zero                                code  fffc1f30 18
  OSCallTbl                                  code  fffc19c8 18
  OSPAGES                                   const  000003 3
  OSSP                                      const  000700 12
  OUTC                                       code  fffc5460 18
  OUTPTR                                    const  0007a8 12
  OpenSpace                                  code  fffc3928 18
  OpenSpace.0003                             code  fffc3940 18
  OpenSpace.noSpace                          code  fffc395c 18
  PAGESZ                                    const  010000 18
  PAGES_PER_TASK                            const  001000 14
  PARN                                       code  fffc47c8 18
  PEEK                                       code  fffc49b8 18
  PEEKH                                      code  fffc49e8 18
  PEEKW                                      code  fffc49d0 18
  PIC                                       const  ffdc0f00 33
  PIC_CH16                                  const  0000c0 9
  PIC_CH28                                  const  0000f0 9
  PIC_CH31                                  const  0000fc 9
  PIDMAP                                    const  024310 19
  PKER                                       code  fffc4390 18
  POKE                                       code  fffc430c 18
  POKEH                                      code  fffc4364 18
  POKEW                                      code  fffc4338 18
  POPA_                                      code  fffc4e1c 18
  PP1                                        code  fffc4e50 18
  PR0                                        code  fffc3cf4 18
  PR1                                        code  fffc3d0c 18
  PR2                                        code  fffc3ce0 18
  PR3                                        code  fffc3d2c 18
  PR4                                        code  fffc3d24 18
  PR6                                        code  fffc3d40 18
  PR8                                        code  fffc3d48 18
  PRINT                                      code  fffc3cc8 18
  PRMESG                                     code  fffc5264 18
  PRTLN                                      code  fffc5068 18
  PRTNUM                                     code  fffc4f94 32
  PRTNUM.PN1                                 code  fffc4fc8 18
  PRTNUM.PN2                                 code  fffc4fc4 18
  PRTNUM.PN3                                 code  fffc4ff0 18
  PRTNUM.PN4                                 code  fffc5000 18
  PRTNUM.PN5                                 code  fffc500c 18
  PRTNUM.PN6                                 code  fffc5010 18
  PRTNUM.PN7                                 code  fffc4fd8 18
  PRTSTG                                     code  fffc4e98 18
  PRTSTG.PRTRET                              code  fffc4edc 18
  PRTSTG.PS1                                 code  fffc4eb8 18
  PU1                                        code  fffc4e8c 18
  PUSHA_                                     code  fffc4e54 18
  PWORD                                      code  fffc42a0 18
  PicInit                                    code  fffc0f90 18
  PutHexByte                                 code  fffc071c 18
  PutHexDword                                code  fffc06bc 18
  PutHexHalf                                 code  fffc06fc 18
  PutHexNybble                               code  fffc073c 18
  PutHexNybble.0001                          code  fffc076c 18
  PutHexNybble.lt10                          code  fffc0764 18
  PutHexWord                                 code  fffc06dc 18
  PutString                                  code  fffc077c 18
  PutString.0001                             code  fffc078c 18
  PutString.done                             code  fffc07a0 18
  Putch                                      code  fffc0234 18
  QNDX                                      const  024304 19
  QSORRY                                     code  fffc4c0c 18
  QT1                                        code  fffc4f18 18
  QT2                                        code  fffc4f58 18
  QT3                                        code  fffc4f30 18
  QT4                                        code  fffc4f44 18
  QT5                                        code  fffc4f64 18
  QTSTG                                      code  fffc4f00 18
  QWHAT                                      code  fffc4c18 18
  RDYQ0                                     const  024400 19
  RDYQ1                                     const  024500 19
  RDYQ2                                     const  024600 19
  RDYQ3                                     const  024700 19
  READYQ                                    const  024308 19
  RETURN                                     code  fffc3dac 18
  RND                                        code  fffc4a40 18
  RUN                                        code  fffc3b50 18
  RUN1                                       code  fffc3bb0 18
  RUN2                                       code  fffc3b6c 18
  RUN3                                       code  fffc3b70 18
  RUNNXL                                     code  fffc3b64 18
  RUNSML                                     code  fffc3bcc 18
  RUNTSL                                     code  fffc3bc4 18
  RemoveFromReadyList                        code  fffc2748 18
  RemoveFromReadyList.tidOk                  code  fffc275c 18
  RemoveFromReadyList2                       code  fffc2774 18
  RemoveFromReadyList2.0001                  code  fffc27c8 18
  RemoveFromReadyList2.0002                  code  fffc27e4 18
  RemoveFromReadyList2.0003                  code  fffc27b8 18
  RemoveFromReadyList2.badTid                code  fffc27f8 18
  RemoveFromTimeoutList                      code  fffc28e4 18
  RemoveFromTimeoutList.0001                 code  fffc2934 18
  RemoveFromTimeoutList.noNext               code  fffc2954 18
  RemoveFromTimeoutList.noPrev               code  fffc2968 18
  RemoveFromTimeoutList.noWait               code  fffc28f8 18
  RestoreContext                             code  fffc1ca8 18
  RestoreContext.rsseg                       code  fffc1cb8 18
  SAVE                                       code  fffc421c 18
  SAVE1                                      code  fffc4228 18
  SAVE2                                      code  fffc4244 18
  SAVE3                                      code  fffc41b0 18
  SAVE4                                      code  fffc41e0 18
  SAVEND                                     code  fffc425c 18
  SC_C                                      const  000021 7
  SC_TAB                                    const  00000d 5
  SC_Z                                      const  00001a 6
  SDReadSector                               code  8000000000000347 32
  SDWriteSector                              code  800000000000034c 32
  SENDMSG                                    code  fffc52ec 18
  SENDMSG.err                                code  fffc5370 18
  SENDMSG.paren                              code  fffc537c 18
  SETVAL                                     code  fffc4b2c 18
  SETVAL.sv2                                 code  fffc4b50 18
  SGN                                        code  fffc4ad4 18
  SGN1                                       code  fffc4b04 18
  SGN2                                       code  fffc4af4 18
  SIZEX                                      code  fffc4b10 18
  SRYMSG                                     code  fffc54df 18
  ST2                                        code  fffc3830 18
  STACKOFFS                                 const  07fffc 20
  STKBOT                                    const  00079c 12
  STKGOS                                    const  000714 12
  STKINP                                    const  000798 12
  STOP                                       code  fffc3b3c 18
  STRTMP                                    const  000200 11
  SV1                                        code  fffc4b8c 18
  SYSX                                       code  fffc439c 18
  SaveContext                                code  fffc1bf8 18
  SaveContext.svseg                          code  fffc1c88 18
  SelectTaskToRun                            code  fffc1b90 18
  SelectTaskToRun.0001                       code  fffc1bd4 18
  SelectTaskToRun.dq                         code  fffc1bf0 18
  SelectTaskToRun.goodTid                    code  fffc1bf0 18
  SelectTaskToRun.nxtQ                       code  fffc1bcc 18
  SerHeadRcv                                const  025800 19
  SerHeadXmit                               const  025808 19
  SerRcvBuf                                 const  025000 19
  SerRcvXoff                                const  025811 19
  SerRcvXon                                 const  025810 19
  SerTailRcv                                const  025804 19
  SerTailXmit                               const  02580c 19
  SerXmitBuf                                const  025400 19
  SerialFinishCmd                            code  fffc11b4 18
  SerialFinishCmd.0001                       code  fffc11d8 18
  SerialFuncTbl                              code  fffc0fc0 18
  SerialGetChar                              code  fffc11dc 18
  SerialGetChar.0001                         code  fffc1290 18
  SerialGetChar.0002                         code  fffc1244 18
  SerialGetChar.noChars                      code  fffc1290 18
  SerialGetChar.xit                          code  fffc1294 18
  SerialIRQ                                  code  fffc1424 18
  SerialIRQ.0001                             code  fffc14d4 18
  SerialIRQ.notRxInt                         code  fffc14e8 18
  SerialIRQ.nxtByte                          code  fffc1424 18
  SerialIRQ.rxFull                           code  fffc14e8 18
  SerialInit                                 code  fffc1080 18
  SerialPeekChar                             code  fffc12ac 18
  SerialPeekChar.0001                        code  fffc12f8 18
  SerialPeekChar.noChars                     code  fffc12f8 18
  SerialPeekChar.xit                         code  fffc12fc 18
  SerialPeekCharDirect                       code  fffc1314 18
  SerialPeekCharDirect.0001                  code  fffc1354 18
  SerialPeekCharDirect.xit                   code  fffc1358 18
  SerialPutChar                              code  fffc1370 18
  SerialPutChar.0001                         code  fffc1384 18
  SerialPutChar.0002                         code  fffc1380 18
  SerialPutChar.goSleep                      code  fffc13c0 18
  SerialRcvCount                             code  fffc13e8 18
  SerialRcvCount.xit                         code  fffc141c 18
  SerialService                              code  fffc115c 18
  SerialServiceInit                          code  fffc1144 18
  SerialServiceLoop                          code  fffc1178 18
  SkipSpaces                                 code  fffc05f0 18
  SkipSpaces.skip1                           code  fffc0614 18
  SkipSpaces.skip2                           code  fffc05f0 18
  SwapContext                                code  fffc1d64 18
  SwapContext.noCtxSwitch                    code  fffc1ecc 18
  SwapContext.rsseg                          code  fffc1e24 18
  SwapContext.svseg                          code  fffc1e04 18
  SwitchIOFocus                             const  024820 19
  SysSema                                   const  024340 19
  TAB                                       const  000009 5
  TAB1                                       code  fffc3964 18
  TAB10                                      code  fffc3a1e 18
  TAB10_1                                    code  fffc3a8e 18
  TAB1_1                                     code  fffc3a22 18
  TAB2                                       code  fffc3976 18
  TAB2_1                                     code  fffc3a2c 18
  TAB4                                       code  fffc39cf 18
  TAB4_1                                     code  fffc3a5a 18
  TAB5                                       code  fffc3a08 18
  TAB5_1                                     code  fffc3a74 18
  TAB6                                       code  fffc3a0b 18
  TAB6_1                                     code  fffc3a78 18
  TAB8                                       code  fffc3a10 18
  TAB8_1                                     code  fffc3a7c 18
  TAB9                                       code  fffc3a1a 18
  TAB9_1                                     code  fffc3a8a 18
  TC1                                        code  fffc50f8 18
  TC64CursorAddr                            const  ffd1df1c 33
  TCBElapsedTime                            const  0002c0 11
  TCBEndTime                                const  0002b8 11
  TCBException                              const  0002c8 11
  TCBKbdBuf                                 const  000308 11
  TCBKbdHead                                const  000300 11
  TCBKbdState2                               code  8000000000000252 32
  TCBKbdTail                                const  000301 11
  TCBMsgD1                                  const  000298 11
  TCBMsgD2                                  const  0002a0 11
  TCBMsgD3                                  const  0002a8 11
  TCBName                                   const  0002f8 11
  TCBNext                                   const  0002d0 11
  TCBPrev                                   const  0002d8 11
  TCBPriority                               const  000289 11
  TCBResource                               const  000328 11
  TCBStackBot                               const  000290 11
  TCBStartTime                              const  0002b0 11
  TCBStatus                                 const  000288 11
  TCBTimeout                                const  0002e0 11
  TCBVideoMem                               const  000330 11
  TCBWaitMbx                                const  00028a 11
  TCBepc                                    const  000280 11
  TCBpVideo                                 const  000338 11
  TCBsegs                                   const  000200 11
  TICKX                                      code  fffc4ac0 18
  TN1                                        code  fffc5128 18
  TN2                                        code  fffc5154 18
  TOOBIG                                     code  fffc4c00 18
  TOUPB1                                     code  fffc51c4 18
  TOUPBRT                                    code  fffc520c 18
  TOUPBUF                                    code  fffc51b4 18
  TOUPRET                                    code  fffc5230 18
  TSNMRET                                    code  fffc5174 18
  TSTC                                       code  fffc50c4 18
  TSTNUM                                     code  fffc5110 18
  TSTV                                       code  fffc4808 18
  TSTVRT                                     code  fffc4878 18
  TS_DEAD                                   const  000002 3
  TS_MSGRDY                                 const  000004 4
  TS_NONE                                   const  000000 1
  TS_PREEMPT                                const  000020 7
  TS_READY                                  const  000001 2
  TS_RUNNING                                const  000080 9
  TS_TIMEOUT                                const  000010 6
  TS_WAITMSG                                const  000008 5
  TV1                                        code  fffc4864 18
  TV2                                        code  fffc4858 18
  TV3                                        code  fffc4838 18
  TXTBGN                                    const  001800 14
  TXTUNF                                    const  000704 12
  Tick                                      const  024330 19
  TimeoutList                               const  024328 19
  TinyBasic                                  code  fffc3700 18
  UART                                      const  ffdc0a00 33
  UART_CMD                                  const  000008 5
  UART_STAT                                 const  000004 4
  UART_TRB                                  const  000000 1
  USRX                                       code  fffc4a00 18
  UpdateCursorPos                            code  fffc17f4 18
  UserStart                                  code  fffc0168 18
  UserStart2                                 code  fffc0198 18
  UserStart2.0002                            code  fffc01e0 18
  UserStart2.0003                            code  fffc01f4 18
  VARBGN                                    const  000708 12
  VAREND                                    const  00070c 12
  VIA                                       const  ffdc0600 33
  VIA_ACR                                   const  00002c 7
  VIA_DDRA                                  const  00000c 5
  VIA_IER                                   const  000038 7
  VIA_IFR                                   const  000034 7
  VIA_PA                                    const  000004 4
  VIA_PARAW                                 const  00003c 7
  VIA_PCR                                   const  000030 7
  VIA_T1CH                                  const  000014 6
  VIA_T1CL                                  const  000010 6
  ViaFuncTbl                                 code  fffc14f8 18
  ViaIRQ                                     code  fffc1614 18
  ViaIRQ.0003                                code  fffc1668 18
  ViaInit                                    code  fffc15b8 18
  VideoClearScreen                           code  fffc17a8 18
  VideoClearScreen.0001                      code  fffc17c0 18
  VideoFuncTbl                               code  fffc1670 18
  VideoHomeCursor                            code  fffc17d4 18
  VideoIRQ                                   code  fffc19c4 18
  VideoIRQ.0003                              code  fffc19c4 18
  VideoInit                                  code  fffc1730 18
  VideoPutChar                               code  fffc1834 18
  VideoPutChar.0001                          code  fffc18f8 18
  VideoPutChar.cr1                           code  fffc19ac 18
  VideoPutChar.cursorRight                   code  fffc197c 18
  VideoPutChar.doCR                          code  fffc1948 18
  VideoPutChar.doCls                         code  fffc19b8 18
  VideoPutChar.doLF                          code  fffc1968 18
  VideoPutChar.doLF1                         code  fffc18d0 18
  VideoPutChar.saveX                         code  fffc1928 18
  VideoPutChar.saveY                         code  fffc1918 18
  VirtToPhys                                 code  fffc0f54 18
  VirtToPhys.notMapped                       code  fffc0f88 18
  WAITIRQ                                    code  fffc3c70 18
  WAITMSG                                    code  fffc5388 18
  WAITMSG.0001                               code  fffc53c0 18
  WAITMSG.0002                               code  fffc53b4 18
  WAITMSG.err                                code  fffc5448 18
  WAITMSG.paren                              code  fffc5454 18
  WSTART                                     code  fffc37c0 18
  XOFF                                      const  000013 6
  XON                                       const  000011 6
  XP11                                       code  fffc454c 18
  XP12                                       code  fffc4564 18
  XP13                                       code  fffc457c 18
  XP14                                       code  fffc4594 18
  XP15                                       code  fffc45ac 18
  XP16                                       code  fffc45c4 18
  XP17                                       code  fffc4604 18
  XP18                                       code  fffc461c 18
  XP21                                       code  fffc466c 18
  XP22                                       code  fffc4678 18
  XP23                                       code  fffc467c 18
  XP24                                       code  fffc4698 18
  XP25                                       code  fffc46ac 18
  XP26                                       code  fffc46b8 18
  XP31                                       code  fffc46e8 18
  XP34                                       code  fffc4718 18
  XP35                                       code  fffc473c 18
  XP40                                       code  fffc4794 18
  XP41                                       code  fffc47b0 18
  XP42                                       code  fffc47ec 18
  XP43                                       code  fffc47f8 18
  XP45                                       code  fffc46c4 18
  XP46                                       code  fffc47bc 18
  XP47                                       code  fffc4760 18
  XPRT0                                      code  fffc45dc 18
  XPRT1                                      code  fffc45f0 18
  XP_AND                                     code  fffc445c 18
  XP_AND1                                    code  fffc443c 18
  XP_ANDX                                    code  fffc4470 18
  XP_OR                                      code  fffc43fc 18
  XP_OR1                                     code  fffc43dc 18
  XP_ORX                                     code  fffc4410 18
  YIELD0                                     code  fffc3b44 18
  _KeybdGetID                                code  fffc341c 18
  _KeybdGetID.0001                           code  fffc3460 18
  _KeybdGetID.notKbd                         code  fffc347c 18
  _KeybdGetScancode                          code  fffc3568 18
  _KeybdGetStatus                            code  fffc3540 18
  _KeybdID                                   code  800000000000024a 32
  _KeybdInit                                 code  fffc32b0 18
  _KeybdInit.0002                            code  fffc32e0 18
  _KeybdInit.0004                            code  fffc3388 18
  _KeybdInit.config                          code  fffc332c 18
  _KeybdInit.keybdErr                        code  fffc3370 18
  _KeybdInit.ledxit                          code  fffc33b4 18
  _KeybdInit.tryAgain                        code  fffc3364 18
  _KeybdInit.xit                             code  fffc33d0 18
  _KeybdPeekScancode                         code  fffc3554 18
  _KeybdRecvByte                             code  fffc3484 18
  _KeybdRecvByte.0003                        code  fffc3490 18
  _KeybdRecvByte.0004                        code  fffc34c8 18
  _KeybdSendByte                             code  fffc34d8 18
  _KeybdSetLED                               code  fffc33dc 18
  _KeybdWaitTx                               code  fffc34ec 18
  _KeybdWaitTx.0001                          code  fffc34f8 18
  _KeybdWaitTx.0002                          code  fffc3530 18
  _MicroDelay                                code  fffc07b0 18
  _MicroDelay.0001                           code  fffc07b4 18
  _clr                                       code  fffc3c08 18
  _cls                                       code  80000000000002cb 32
  _end_init_data                           rodata  fffc6000 32
  _keybdControlCodes                         code  fffc30f0 18
  _keybdExtendedCodes                        code  fffc3170 18
  _rdcf                                      code  80000000000002cd 32
  _shiftedScanCodes                          code  fffc2ff0 18
  _unshiftedScanCodes                        code  fffc2ef0 18
  a2h1                                       code  fffc40d0 18
  asciiToHex                                 code  fffc40c4 18
  begin_init_data                          rodata  fffc6000 32
  clearVars                                  code  fffc3c10 18
  clearVars.cv1                              code  fffc3c24 18
  doMem                                      code  fffc0524 18
  doMem.loop                                 code  fffc0588 18
  doMem.loop2                                code  fffc0560 18
  ec1                                        code  fffc4bf4 18
  end_init_data                            rodata  fffc6000 32
  findVar                                    code  fffc4948 18
  fl1                                        code  fffc4d70 18
  flt10                                      code  fffc0909 18
  flt20                                      code  fffc08f9 18
  flt50                                      code  fffc08e9 18
  fltMillion                                 code  fffc0ce0 18
  fltOne                                     code  fffc0cd8 18
  fltTen                                     code  fffc0cdc 18
  fltToString                                code  fffc0919 18
  fltToString.0001                           code  fffc097a 18
  fltToString.0002                           code  fffc09fa 18
  fltToString.0003                           code  fffc09e6 18
  fltToString.0004                           code  fffc0a46 18
  fltToString.0005                           code  fffc0a3e 18
  fltToString.0006                           code  fffc0a26 18
  fltToString.0007                           code  fffc0a62 18
  fltToString.0008                           code  fffc0a76 18
  fltToString.0009                           code  fffc0a72 18
  fltToString.0010                           code  fffc0a96 18
  fltToString.0011                           code  fffc0b22 18
  fltToString.0012                           code  fffc0ada 18
  fltToString.0013                           code  fffc0ac6 18
  fltToString.0014                           code  fffc0af6 18
  fltToString.0015                           code  fffc0b12 18
  fltToString.0016                           code  fffc0aae 18
  fltToString.0017                           code  fffc0b1a 18
  fltToString.0018                           code  fffc0b22 18
  fltToString.0019                           code  fffc0b56 18
  fltToString.0020                           code  fffc0b62 18
  fltToString.0021                           code  fffc0b86 18
  fltToString.0022                           code  fffc0b92 18
  fltToString.0023                           code  fffc0ba2 18
  fltToString.0024                           code  fffc0bae 18
  fltToString.0025                           code  fffc0b9a 18
  fltToString.0026                           code  fffc0bc2 18
  fltToString.0027                           code  fffc0bca 18
  fltToString.0028                           code  fffc0bd2 18
  fltToString.0029                           code  fffc0bde 18
  fltToString.0030                           code  fffc0bea 18
  fltToString.0031                           code  fffc0bf6 18
  fltToString.0032                           code  fffc0bfe 18
  fltToString.0034                           code  fffc0c06 18
  fltToString.0035                           code  fffc0c12 18
  fltToString.0036                           code  fffc0c22 18
  fltToString.0037                           code  fffc0c2e 18
  fltToString.0038                           code  fffc0c36 18
  fltToString.0039                           code  fffc0c4a 18
  fltToString.0040                           code  fffc0c3e 18
  fltToString.0041                           code  fffc0ca6 18
  fltToString.0042                           code  fffc0c6a 18
  fltToString.0043                           code  fffc0c7a 18
  fltToString.0044                           code  fffc0c8e 18
  fltToString.0045                           code  fffc0c72 18
  fltToString.0046                           code  fffc0c9a 18
  fltToString.0047                           code  fffc0ca6 18
  fltToString.0048                           code  fffc0c92 18
  fltToString.0050                           code  fffc0cc6 18
  fltToString.0051                           code  fffc0cc2 18
  fltToString.0052                           code  fffc0cb2 18
  fltToString.inf                            code  fffc0962 18
  fltToString.notZero                        code  fffc09b6 18
  fltToString.pos                            code  fffc09a2 18
  fltToString.prt                            code  fffc0c5a 18
  fputc                                      code  fffc0270 18
  fv1                                        code  fffc4990 18
  fv2                                        code  fffc49a4 18
  fv3                                        code  fffc4988 18
  fv4                                        code  fffc4958 18
  gen_rand                                   code  8000000000000395 32
  getVarName                                 code  fffc489c 18
  gfn1                                       code  fffc4144 18
  gfn2                                       code  fffc40f4 18
  gfn3                                       code  fffc4124 18
  gosub1                                     code  fffc3d88 18
  gvn1                                       code  fffc4934 18
  gvn2                                       code  fffc48f8 18
  gvn3                                       code  fffc4914 18
  gvn4                                       code  fffc48bc 18
  gvn6                                       code  fffc48e8 18
  hKeybdMbx                                 const  024822 19
  isAlnum                                    code  fffc44d8 18
  isAlpha                                    code  fffc44a8 18
  isAlphaFalse                               code  fffc44d0 18
  isAlphaTrue                                code  fffc44c8 18
  isDigit                                    code  fffc4488 18
  isDigitFalse                               code  fffc44a0 18
  isDigitx                                   code  fffc44ec 18
  mbxs                                      const  020000 19
  mbxs_end                                  const  022000 19
  milliseconds                              const  014208 18
  missed_ticks                              const  024320 19
  msgBadGotoGosub                            code  fffc5605 18
  msgBadKeybd                                code  8000000000000244 32
  msgBytesFree                               code  fffc553d 18
  msgCRLF                                    code  fffc08e6 18
  msgComma                                   code  fffc5552 18
  msgDivZero                                 code  fffc5514 18
  msgEnvFail                                 code  fffc566d 18
  msgExtraChars                              code  fffc564b 18
  msgInf                                     code  fffc0cd0 18
  msgInit                                    code  fffc549c 18
  msgInputVar                                code  fffc55b4 18
  msgLineRange                               code  fffc5565 18
  msgMonHelp                                 code  fffc0839 18
  msgNan                                     code  fffc0cd4 18
  msgNextFor                                 code  fffc55d0 18
  msgNextVar                                 code  fffc55e2 18
  msgNumTooBig                               code  fffc5501 18
  msgParen                                   code  fffc5687 18
  msgRNDBad                                  code  fffc5590 18
  msgReadError                               code  fffc54e7 18
  msgReady                                   code  fffc554a 18
  msgReadyList                               code  fffc2bc0 18
  msgRetWoGosub                              code  fffc5621 18
  msgSYSBad                                  code  fffc55a3 18
  msgStart                                   code  fffc0820 18
  msgTaskStart                               code  fffc08d8 18
  msgTimeoutList                             code  fffc2bf1 18
  msgTooBig                                  code  fffc5637 18
  msgVar                                     code  fffc557a 18
  msgVarSpace                                code  fffc5526 18
  msgWhat                                    code  fffc54d8 18
  msgs                                      const  010000 18
  nmeSerial                                  code  fffc14ec 18
  prCRLF                                     code  fffc4f70 18
  pword1                                     code  fffc42b4 18
  pword2                                     code  fffc42d0 18
  qToChk                                     code  fffc19fe 18
  return1                                    code  fffc3dc4 18
  rnd1                                       code  fffc4a74 18
  rnd2                                       code  fffc4a84 18
  switchflag                                const  014200 18
  sysx1                                      code  fffc43b0 18
  tah1                                       code  fffc4304 18
  toAsciiHex                                 code  fffc42f4 18
  toUpper                                    code  fffc5218 18
  tstv_notfound                              code  fffc4888 18
  usrJmp                                    const  0007a0 12

Undefined Symbols
  AUXIN                                      code  8000000000000288 32
  AUXIN_INIT                                 code  8000000000000346 32
  AUXOUT                                     code  8000000000000286 32
  AUXOUT_FLUSH                               code  8000000000000353 32
  AUXOUT_INIT                                code  800000000000034a 32
  DumpReadyQueue                             code  8000000000000199 32
  ERETx                                      code  80000000000001fe 32
  FMTK_Initialize                            code  800000000000018b 32
  FMTK_PostMsg                               code  8000000000000193 32
  FMTK_SetTaskPriority                       code  800000000000018f 32
  FMTK_StartApp                              code  8000000000000197 32
  KEYBD                                      code  800000000000023c 32
  KeybdIRQ.notAlt                            code  8000000000000257 32
  KillTask                                   code  80000000000001cf 32
  SDReadSector                               code  8000000000000347 32
  SDWriteSector                              code  800000000000034c 32
  TCBKbdState2                               code  8000000000000252 32
  _KeybdID                                   code  800000000000024a 32
  _cls                                       code  80000000000002cb 32
  _rdcf                                      code  80000000000002cd 32
  gen_rand                                   code  8000000000000395 32
  msgBadKeybd                                code  8000000000000244 32

  Macro Name
 mGetCurrentTid                            -842150451

	csrrw	v0,#$181,x0
	and		v0,v0,#15

 mHasFocus                                 -842150451

	ldi		a0,#20
	ecall

 mPopTimeoutList                           -842150451

	sll		$t0,$v0,#LOG_TCBSZ		; tid to pointer
	lbu		$v1,TCBStatus[$t0]		; no longer a waiting status
	and		$t1,$v1,#TS_WAITMSG		; check if waiting for a message
	beqz	$t1,.noWait@
	mMbxRemoveTask							; remove task from mailbox list
.noWait@:
	and		$v1,$v1,#~(TS_WAITMSG|TS_TIMEOUT)
	stb		$v1,TCBStatus[$t0]
	ldw		$v1,TCBNext[$t0]			; get next task on timeout list
	stw		$v1,TimeoutList				; update list head
	ldi		$t1,#NR_TCB						; check valid handle
	bgeu	$v1,$t1,.done@
	ldi		$t1,#-1								;
	sll		$v1,$v1,#LOG_TCBSZ		; v1 = tid to pointer
	stw		$t1,TCBPrev[$v1]			; TimeoutList->prev = -1
.done@:
	ldi		$t1,#-1								; reset next and prev indexes
	stw		$t1,TCBNext[$t0]			; on popped task
	stw		$t1,TCBPrev[$t0]

 mSleep                                    1

	ldi		a0,#5
	ldi		a1,#0
	ecall

 mUnlockSemaphore                          1

	ldi		v0,#-1
	sw		v0,0

 mWaitForFocus                             -842150451

.WFF1@:
	
	ldi		a0,#20
	ecall
bne		v1,x0,.HasFocus@
	call	SerialPeekChar	;Direct
	ldi		a0,#$14							; CTRL-T
	bne		$v0,$a0,.WFF2@
	call	SerialGetChar
	ldi		$a0,#21							; switch IO Focus
	ecall
	bra		.WFF1@
.WFF2@:
	
	ldi		a0,#5
	ldi		a1,#1
	ecall

	bra		.WFF1@
.HasFocus@:

0 compressable instructions
The top 1024 are:
Comp  Opcode  Count
