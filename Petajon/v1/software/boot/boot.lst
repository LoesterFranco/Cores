                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/const.r5a",1
                        	.file "../fmtk/const.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	; First 256 bytes are for integer register set
                        	; Second 256 bytes are for float register set
                        	; Leave some room for 64-bit regs
                        	TCBsegs			EQU		$200		; segment register storage
                        	TCBepc			EQU		$280
                        	TCBStatus		EQU		$288
                        	TCBPriority	EQU		$289
                        	TCBContextSaved	EQU		$28A
                        	TCBWaitMbx	EQU		$28C
                        	TCBStackBot	EQU		$290
                        	TCBMsgD1		EQU		$298
                        	TCBMsgD2		EQU		$2A0
                        	TCBMsgD3		EQU		$2A8
                        	TCBStartTime	EQU		$2B0
                        	TCBEndTime		EQU		$2B8
                        	TCBElapsedTime		EQU		$2C0
                        	TCBException	EQU	$2C8
                        	TCBNext			EQU		$2D0
                        	TCBPrev			EQU		$2D8
                        	TCBTimeout	EQU		$2E0
                        	IOF_NEXT		EQU		$2E8
                        	IOF_PREV		EQU		$2F0
                        	TCBName			EQU		$2F8
                        	TCBKbdHead	EQU		$300
                        	TCBKbdTail	EQU		$301
                        	TCBKbdBuf		EQU		$308
                        	; 328 end of keyboard buffer
                        	TCBResource	EQU		$328
                        	TCBVideoMem	EQU		$330
                        	TCBpVideo		EQU		$338
                        	
                        	TS_NONE			EQU		0
                        	TS_READY		EQU		1
                        	TS_DEAD			EQU		2
                        	TS_MSGRDY		EQU		4
                        	TS_WAITMSG	EQU		8
                        	TS_TIMEOUT	EQU		16
                        	TS_PREEMPT	EQU		32
                        	TS_RUNNING	EQU		128
                        	
                        	; error codes
                        	E_Ok		=		0x00
                        	E_Arg		=		0x01
                        	E_BadMbx	=		0x04
                        	E_QueFull	=		0x05
                        	E_NoThread	=		0x06
                        	E_NotAlloc	=		0x09
                        	E_NoMsg		=		0x0b
                        	E_Timeout	=		0x10
                        	E_BadAlarm	=		0x11
                        	E_NotOwner	=		0x12
                        	E_QueStrategy =		0x13
                        	E_BadDevNum	=		0x18
                        	E_DCBInUse	=		0x19
                        	E_BadCallno	=  0x1A
                        	; Device driver errors
                        	E_BadDevNum	=		0x20
                        	E_NoDev		=		0x21
                        	E_BadDevOp	=		0x22
                        	E_ReadError	=		0x23
                        	E_WriteError =		0x24
                        	E_BadBlockNum	=	0x25
                        	E_TooManyBlocks	=	0x26
                        	
                        	; resource errors
                        	E_NoMoreMbx	=		0x40
                        	E_NoMoreMsgBlks	=	0x41
                        	E_NoMoreAlarmBlks	=0x44
                        	E_NoMoreTCBs	=	0x45
                        	E_NoMem		= 12
                        	
                        	CSR_REGSET	equ		$790
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/config.r5a",1
                        	.file "../fmtk/config.r5a",1
                        	MAX_TID		EQU		63
                        	NR_TCB		EQU		64
                        	NR_MBX		EQU		256
                        	NR_MSG		EQU		2048
                        	LOG_TCBSZ	EQU		10
                        	LOG_PGSZ	EQU		16
                        	PAGESZ		EQU		65536
                        	PAGES_PER_TASK	EQU		4096	; maximum number of pages per task
                        	OSPAGES		EQU		3			; pages of memory dedicated to OS
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/device.r5a",1
                        	.file "../fmtk/device.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2014-2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; DeviceDriver.inc
                        	; - Device driver structures and constants                                                                         
                        	; ============================================================================
                        	
                        	;	.global			; global constants
                        	
                        	; Device Control Block
                        	;
                        	DCB_Name			EQU		0		; string: first byte is length, 11 chars max
                        	DCB_Type			EQU		0x0C
                        	DCB_nBPB			EQU		0x10
                        	DCB_LastErc			EQU		0x18		; last error code
                        	DCB_StartBlock		EQU		0x20		; starting block number (partitioned devices)
                        	DCB_nBlocks			EQU		0x28		; number of blocks on device
                        	DCB_pCmdProc		EQU		0x30		; pointer to command processor routine
                        	DCB_ReentCount		EQU		0x38		; re-entrancy count (1 to 255)
                        	DCB_fSingleUser		EQU		0x39
                        	DCB_hJob			EQU		0x40		; handle to associated job
                        	DCB_Mbx				EQU		0x48
                        	DCB_pSema			EQU		0x50		; pointer to device semaphore
                        	DCB_Resv1			EQU		0x58		; reserved
                        	DCB_Resv2			EQU		0x60		; reserved
                        	DCB_Size			EQU		0x68
                        	
                        	; Device command opcodes
                        	;
                        	DVC_Nop				EQU		0
                        	DVC_Setup			EQU		1
                        	DVC_Initialize		EQU		2
                        	DVC_Status			EQU		3
                        	DVC_MediaCheck		EQU		4
                        	DVC_BuildBPB		EQU		5
                        	DVC_Open			EQU		6
                        	DVC_Close			EQU		7
                        	DVC_GetChar			EQU		8
                        	DVC_PeekChar		EQU		9
                        	DVC_GetCharDirect	EQU		10
                        	DVC_PeekCharDirect	EQU		11
                        	DVC_InputStatus		EQU		12
                        	DVC_PutChar			EQU		13
                        	DVC_SetPosition		EQU		15
                        	DVC_ReadBlock		EQU		16
                        	DVC_WriteBlock		EQU		17
                        	DVC_VerifyBlock		EQU		18
                        	DVC_OutputStatus	EQU		19
                        	DVC_FlushInput		EQU		20
                        	DVC_FlushOutput		EQU		21
                        	DVC_IRQ				EQU		22
                        	DVC_IsRemoveable	EQU		23
                        	DVC_IOCTRL_READ		EQU		24
                        	DVC_IOCTRL_WRITE	EQU		25
                        	DVC_OutputUntilBusy	EQU		26
                        	
                        	MAX_DEV_OP			EQU		31
                        	
                        	
                        	DRSP_DONE			EQU		1
                        	
                        	;Standard Devices are:
                        	
                        	;#		Device					Standard name
                        	
                        	;0		NULL device 			NUL		(OS built-in)
                        	;1		Keyboard (sequential)	KBD		(OS built-in)
                        	;2		Video (sequential)		VID		(OS built-in)
                        	;3		Printer (parallel 1)	LPT
                        	;4		Printer (parallel 2)	LPT2
                        	;5		RS-232 1				COM1	(OS built-in)
                        	;6		RS-232 2				COM2
                        	;7		RS-232 3				COM3
                        	;8		RS-232 4				COM4
                        	;9		Parallel xfer	  PTI
                        	;10		Floppy					FD0
                        	;11		Floppy					FD1
                        	;12		Hard disk				HD0
                        	;13		Hard disk				HD1
                        	;14
                        	;15
                        	;16		SDCard					CARD1 	(OS built-in)
                        	;17
                        	;18
                        	;19
                        	;20
                        	;21
                        	;22
                        	;23
                        	;24
                        	;25
                        	;26
                        	;27
                        	;28		Audio						PSG1	(OS built-in)
                        	;29
                        	;30   Random Number		PRNG
                        	;31		Debug						DBG
                        	
                        	NR_DCB			EQU		32
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/macro.r5a",1
                        	.file "../fmtk/macro.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	; macros have to be defined before they are encountered.
                        	
                        	; unlock the a semaphore	
                        	macro mUnlockSemaphore (adr)
	ldi		v0,#-1
	sw		v0,adr
endm
                        	
                        	; Look at the asid register for task id
                        	macro mGetCurrentTid
	csrrw	v0,#$181,x0
	and		v0,v0,#MAX_TID
endm
                        	
                        	macro	mHasFocus
	ldi		$a0,#20
	ecall
endm
                        	
                        	macro mSleep(tm)
	ldi		$a0,#5
	ldi		$a1,#tm
	ecall
endm
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	macro mWaitForFocus
.WFF1@:
	
	ldi		$a0,#20
	ecall
bne		v1,x0,.HasFocus@
	call	SerialPeekChar	;Direct
	ldi		a0,#$14							; CTRL-T
	bne		$v0,$a0,.WFF2@
	call	SerialGetChar
	ldi		$a0,#21							; switch IO Focus
	ecall
	bra		.WFF1@
.WFF2@:
	
	ldi		$a0,#5
	ldi		$a1,#1
	ecall

	bra		.WFF1@
.HasFocus@:
endm
                        	
                        	;------------------------------------------------------------------------------
                        	; Pop an entry off the timeout list. It is assumed the entry is popped when
                        	; its timeout reached zero. Hence there is no adjustment of the following
                        	; timeout made. Routine used only in the schedulerIRQ, so written as a macro.
                        	;
                        	; Parameters:
                        	;		v0 = top timeout list
                        	; Modifies:
                        	;		v1,t0,t1,t2,t3
                        	;	Returns:
                        	;		v0 = timeout list entry tid
                        	;------------------------------------------------------------------------------
                        	
                        	macro mPopTimeoutList
	sll		$t0,$v0,#LOG_TCBSZ		; tid to pointer
	lbu		$v1,TCBStatus[$t0]		; no longer a waiting status
	and		$t1,$v1,#TS_WAITMSG		; check if waiting for a message
	beqz	$t1,.noWait@
	mMbxRemoveTask							; remove task from mailbox list
.noWait@:
	and		$v1,$v1,#~(TS_WAITMSG|TS_TIMEOUT)
	stb		$v1,TCBStatus[$t0]
	ldw		$v1,TCBNext[$t0]			; get next task on timeout list
	stw		$v1,TimeoutList				; update list head
	ldi		$t1,#NR_TCB						; check valid handle
	bgeu	$v1,$t1,.done@
	ldi		$t1,#-1								;
	sll		$v1,$v1,#LOG_TCBSZ		; v1 = tid to pointer
	stw		$t1,TCBPrev[$v1]			; TimeoutList->prev = -1
.done@:
	ldi		$t1,#-1								; reset next and prev indexes
	stw		$t1,TCBNext[$t0]			; on popped task
	stw		$t1,TCBPrev[$t0]
endm
                        	
                        	
                        	macro mVideoGetPtr:
	
	csrrw	v0,#$181,x0
	and		v0,v0,#MAX_TID
sll		$v0,$v0,#LOG_TCBSZ
	ldo		$v0,TCBpVideo[$v0]
	ldi		$v0,#$FFD00000
endm
                        	
                        	macro mDispIRQLive
     ldo      $v0,$FFD00000+440
     add     	$v0,$v0,#1
     sto      $v0,$FFD00000+440
endm
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/global.r5a",1
                        	.file "../fmtk/global.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	;
                        	; 00000000	+-----------------------------------
                        	;						| Task Control Blocks (64 x 1kB)
                        	; 00010000	+-----------------------------------
                        	;						| Message Array (2048 x 32b)
                        	; 00020000	+-----------------------------------
                        	;						| Mailbox Array (256 x 32b)
                        	; 00022000	+-----------------------------------
                        	;						| Device Control Blocks (32 x 256b)
                        	; 00024000	+-----------------------------------
                        	
                        	msgs		EQU		$10000
                        	mbxs		EQU		$20000
                        	mbxs_end	EQU	$22000
                        	; The following must be at least 256 byte aligned
                        	DVF_Base		EQU		$22000
                        	DVF_Limit		EQU		$24000
                        	QNDX		EQU		$24304
                        	READYQ	EQU		$24308
                        	PIDMAP	EQU		$24310
                        	missed_ticks	equ		$24320
                        	TimeoutList		equ		$24328
                        	Tick		EQU		$24330
                        	SysSema	EQU		$24340
                        	FreeMsg	EQU		$24350
                        	RDYQ0		EQU		$24400
                        	RDYQ1		EQU		$24500
                        	RDYQ2		EQU		$24600
                        	RDYQ3		EQU		$24700
                        	CursorX		equ		$24800
                        	CursorY		equ		$24801
                        	DispAttr	equ		$24808
                        	IOFocusNdx		EQU		$24810
                        	IOFocusTbl		EQU		$24818
                        	SwitchIOFocus	EQU		$24820
                        	hKeybdMbx	equ		$24822
                        	NPAGES	equ		$24828
                        	
                        	SerRcvBuf		EQU		$25000
                        	SerXmitBuf	EQU		$25400
                        	SerHeadRcv	EQU		$25800
                        	SerTailRcv	EQU		$25804
                        	SerHeadXmit	EQU		$25808
                        	SerTailXmit	EQU		$2580C
                        	SerRcvXon		EQU		$25810
                        	SerRcvXoff	EQU		$25811
                        	
                        	
                        	
                        	
                        	
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	
                        	CTRLC				equ		$03
                        	BS					equ		$08
                        	LF					equ		$0A
                        	CR					equ		$0D
                        	XON					equ		$11
                        	XOFF				equ		$13
                        	DEL					equ		$7F
                        	LEDS				equ		$FFDC0600
                        	VIA					equ		$FFDC0600
                        	VIA_PA			equ		$04
                        	VIA_DDRA		equ		$0C
                        	VIA_T1CL		equ		$10
                        	VIA_T1CH		equ		$14
                        	VIA_ACR			equ		$2C
                        	VIA_PCR			equ		$30
                        	VIA_IFR			equ		$34
                        	VIA_IER			equ		$38
                        	VIA_PARAW		equ		$3C
                        	UART				equ		$FFDC0A00
                        	UART_TRB		equ		$00
                        	UART_STAT		equ		$04
                        	UART_CMD		equ		$08
                        			; First 16kB is for TCB's
                        	INBUF				equ		$14100
                        	switchflag	equ		$14200
                        	milliseconds	equ		$14208
                        	
                        	
                        	.file "boot.r5a",31
                        		code	18 bits
                        	;------------------------------------------------------------------------------
                        	; Exception vector table.
                        	;------------------------------------------------------------------------------
                        		org		$FFFC0000				; user mode exception
FFFC0000 0590006F		jmp		IRQRout
FFFC0004 00000000		org		$FFFC0040				; supervisor mode exception (not possible)
FFFC0008 00000000
FFFC000C 00000000
FFFC0010 00000000
FFFC0014 00000000
FFFC0018 00000000
FFFC001C 00000000
FFFC0020 00000000
FFFC0024 00000000
FFFC0028 00000000
FFFC002C 00000000
FFFC0030 00000000
FFFC0034 00000000
FFFC0038 00000000
FFFC003C 00000000
FFFC0040 0190006F		jmp		IRQRout
FFFC0044 00000000		org		$FFFC0080				; hypervisor mode exception (not possible)
FFFC0048 00000000
FFFC004C 00000000
FFFC0050 00000000
FFFC0054 00000000
FFFC0058 00000000
FFFC005C 00000000
FFFC0060 00000000
FFFC0064 00000000
FFFC0068 00000000
FFFC006C 00000000
FFFC0070 00000000
FFFC0074 00000000
FFFC0078 00000000
FFFC007C 00000000
FFFC0080 7D80006F		jmp		IRQRout
FFFC0084 00000000		org 	$FFFC00C0				; machine mode exception
FFFC0088 00000000
FFFC008C 00000000
FFFC0090 00000000
FFFC0094 00000000
FFFC0098 00000000
FFFC009C 00000000
FFFC00A0 00000000
FFFC00A4 00000000
FFFC00A8 00000000
FFFC00AC 00000000
FFFC00B0 00000000
FFFC00B4 00000000
FFFC00B8 00000000
FFFC00BC 00000000
FFFC00C0 7980006F		jmp		IRQRout
FFFC00C4 00000000		org		$FFFC00FC				; non-maskable interrupt
FFFC00C8 00000000
FFFC00CC 00000000
FFFC00D0 00000000
FFFC00D4 00000000
FFFC00D8 00000000
FFFC00DC 00000000
FFFC00E0 00000000
FFFC00E4 00000000
FFFC00E8 00000000
FFFC00EC 00000000
FFFC00F0 00000000
FFFC00F4 00000000
FFFC00F8 00000000
FFFC00FC 0040006F		jmp		MachineStart
                        	
                        	;------------------------------------------------------------------------------
                        	; User mode code starts here
                        	;------------------------------------------------------------------------------
                        		org		$FFFC0100
                        	MachineStart:
FFFC0100 1FFFC737		ldi		$sp,#$1FFFBFF8		; setup machine mode stack pointer
FFFC0104 FF870713
                        		; The dram needs a bit of time before it's ready for access. along with
                        		; the video screen which also needs some time. So the first thing done is
                        		; to delay for about 3 seconds.
FFFC0108 FFDC0DB7		ldi		$t1,#VIA
FFFC010C 600D8D93
FFFC0110 0FF06D13		ldi		$t0,#$000000FF		; set via so we can see output on LEDs
FFFC0114 01ADA623		stt		$t0,VIA_DDRA[$t1]
FFFC0118 03938937		ldi		$a0,#60000000			; 3s in 50ns intervals
FFFC011C 70090913
FFFC0120 70C000EF		call	_MicroDelay
FFFC0124 4E1000EF		call	MMUInit					; initialize MMU for address space zero.
FFFC0128 435010EF		call	FMTKInit
FFFC012C 7E4010EF		call	VideoInit
FFFC0130 628010EF		call	ViaInit
FFFC0134 0AC010EF		call	SerialInit
FFFC0138 670030EF		call	_KeybdInit
FFFC013C 775000EF		call	PicInit
FFFC0140 00006D13		ldi		$t0,#0
FFFC0144 181D1073		csrrw	$x0,#$181,$t0		; set ASID
FFFC0148 FFFC0D37		ldi		$t0,#$FFFC0000
FFFC014C 000D0D13
FFFC0150 301D1073		csrrw $x0,#$301,$t0		; set tvec
FFFC0154 FFFC0D37		ldi		$t0,#UserStart
FFFC0158 168D0D13
FFFC015C 341D1073		csrrw	$x0,#$341,$t0		; set mepc
FFFC0160 30046073		csrrs	$x0,#$300,#8		; enable interrupts (on eret)
FFFC0164 10000073		eret									; switch to user mode
                        	UserStart:
FFFC0168 00106913		ldi		$a0,#1					; start TinyBasic
FFFC016C 000089B7		ldi		$a1,#32000
FFFC0170 D0098993
FFFC0174 FFFC4A37		ldi		$a2,#CSTART
FFFC0178 C30A0A13
FFFC017C 00000073		ecall
FFFC0180 00106913		ldi		$a0,#1
FFFC0184 000069B7		ldi		$a1,#24000
FFFC0188 DC098993
FFFC018C FFFC0A37		ldi		$a2,#UserStart2
FFFC0190 198A0A13
FFFC0194 00000073		ecall
                        	;	wfi
                        	UserStart2:
FFFC0198 03938937		ldi		$a0,#60000000				; 3s in 50ns intervals
FFFC019C 70090913
FFFC01A0 68C000EF		call	_MicroDelay
FFFC01A4 40006913		ldi		$a0,#$400						; clear screen
FFFC01A8 00000073		ecall
FFFC01AC 40106913		ldi		$a0,#$401						; home cursor
FFFC01B0 00000073		ecall
FFFC01B4 00E06913		ldi		$a0,#14							; Get current tid
FFFC01B8 00000073		ecall
FFFC01BC 0008E9B3		mov		$a1,$v1
FFFC01C0 01806913		ldi		$a0,#24							; RequestIOFocus
FFFC01C4 00000073		ecall
                        	;	ldi		$sp,#$1FFF7FF8			; setup user mode stack pointer
                        	;	ldi		$sp,#$AFFFFFFC
FFFC01C8 00406D13		ldi		$t0,#$04						; turn on the LED
FFFC01CC FFDC0637		stt		$t0,VIA+VIA_PARAW
FFFC01D0 63C60613
FFFC01D4 00060633
FFFC01D8 01A62023
FFFC01DC 01006E13		ldi		$t2,#16							; send an XON just in case
                        	;	ldi		$a3,#XON
                        	;.0004:
                        	;	call	SerialPutChar
                        	;	sub		$t2,$t2,#1
                        	;	bnez	$t2,.0004
                        	.0002:
FFFC01E0 FFFC1937		ldi		$a0,#msgStart				; spit out a startup message
FFFC01E4 92890913
FFFC01E8 FFD00D37		ldi		$t0,#$FFD00000
FFFC01EC 000D0D13
FFFC01F0 FFFC0637		ldo		$t1,datAttr
FFFC01F4 24860613
FFFC01F8 00060633
FFFC01FC 00063D83
                        	.0005:
FFFC0200 00094983		ldbu	$a1,[$a0]
FFFC0204 00190913		add		$a0,$a0,#1
FFFC0208 00098A63		beqz	$a1,.0004
FFFC020C 01B9E9B3		or		$a1,$a1,$t1
FFFC0210 013D3023		sto		$a1,[$t0]
FFFC0214 008D0D13		add		$t0,$t0,#8
FFFC0218 FE0004E3		bra		.0005
                        	.0004:
FFFC021C FFFC1937		ldi		$a0,#msgStart
FFFC0220 92890913
FFFC0224 5D4000EF		call	PutString
                        	;		ldi		a0,#1
                        	;		ldi		a1,#24000
                        	;		ldi		a2,#Monitor
                        	;		ecall
FFFC0228 4A5020EF		call	DumpReadyList
FFFC022C 10000463		bra		MonEntry
                        	
                        			; Now a loop to recieve and echo back characters
                        	.0003:
FFFC0230 1DC010EF		call	SerialPeekChar
FFFC0234 FE084EE3		blt		$v0,$x0,.0003
FFFC0238 00086933		mov		$a0,$v0
FFFC023C 294010EF		call	SerialPutChar
FFFC0240 FE0008E3		bra		.0003
                        	
FFFC0244 00000000		align	
                        	
                        	datAttr:
FFFC0248 001F0000		dco		$FFFF001F0000
FFFC024C 0000FFFF
                        	
                        		align	8                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	IdleTask:
FFFC0250 00000063		bra		IdleTask
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a character from input device. Checks for a CTRL-T which indicates to
                        	; switch the I/O focus.
                        	;
                        	; Parameters:
                        	;		none
                        	; Returns:
                        	;		v0 = character, -1 if none available
                        	;------------------------------------------------------------------------------
                        	
                        	Getch:
FFFC0254 FE870713		sub		$sp,$sp,#24
FFFC0258 00173023		sto		$ra,[$sp]
FFFC025C 01273423		sto		$a0,8[$sp]
FFFC0260 01373823		sto		$a1,16[$sp]
                        	;	mWaitForFocus
FFFC0264 0D8010EF		call	SerialGetChar
FFFC0268 00073083		ldo		$ra,[$sp]
FFFC026C 00873903		ldo		$a0,8[$sp]
FFFC0270 01073983		ldo		$a1,16[$sp]
FFFC0274 01870713		add		$sp,$sp,#24
FFFC0278 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	Putch:
FFFC027C FA870713		sub		$sp,$sp,#88
FFFC0280 00173023		sto		$ra,[$sp]
FFFC0284 01073423		sto		$v0,8[$sp]
FFFC0288 01573823		sto		$a3,16[$sp]
FFFC028C 01173C23		sto		$v1,24[$sp]
FFFC0290 03373023		sto		$a1,32[$sp]
FFFC0294 03A73423		sto		$t0,40[$sp]
FFFC0298 03B73823		sto		$t1,48[$sp]
FFFC029C 03C73C23		sto		$t2,56[$sp]
FFFC02A0 05D73023		sto		$t3,64[$sp]
FFFC02A4 05E73423		sto		$t4,72[$sp]
FFFC02A8 05F73823		sto		$t5,80[$sp]
FFFC02AC 00096AB3		mov		$a3,$a0
                        	;	call	SerialPutChar
                        	;	call	VideoPutChar
FFFC02B0 40206913		ldi		$a0,#$402
FFFC02B4 00000073		ecall
                        	;	ldi		$a1,#5							; serial port = 5
                        	;	call	fputc
                        	;	ldi		$a1,#2							; video = 2
                        	;	call	fputc
FFFC02B8 00073083		ldo		$ra,[$sp]
FFFC02BC 00873803		ldo		$v0,8[$sp]
FFFC02C0 01073A83		ldo		$a3,16[$sp]
FFFC02C4 01873883		ldo		$v1,24[$sp]
FFFC02C8 02073983		ldo		$a1,32[$sp]
FFFC02CC 02873D03		ldo		$t0,40[$sp]
FFFC02D0 03073D83		ldo		$t1,48[$sp]
FFFC02D4 03873E03		ldo		$t2,56[$sp]
FFFC02D8 04073E83		ldo		$t3,64[$sp]
FFFC02DC 04873F03		ldo		$t4,72[$sp]
FFFC02E0 05073F83		ldo		$t5,80[$sp]
FFFC02E4 05870713		add		$sp,$sp,#88
FFFC02E8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; fputc - put a character to an I/O device. If the task doesn't have the I/O
                        	; focus then it is rescheduled, allowing another task to run.
                        	;
                        	; Stack Space:
                        	;		6 words
                        	; Register Usage:
                        	;		a0 = FMTK_IO specify
                        	;		a2 = device putchar function
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a3 = character to put
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	fputc:
FFFC02EC FD070713		sub		$sp,$sp,#48
FFFC02F0 00173023		sto		$ra,[$sp]
FFFC02F4 01073423		sto		$v0,8[$sp]
FFFC02F8 01273823		sto		$a0,16[$sp]
FFFC02FC 01173C23		sto		$v1,24[$sp]
FFFC0300 03373023		sto		$a1,32[$sp]
FFFC0304 03473423		sto		$a2,40[$sp]
                        	;	mWaitForFocus
FFFC0308 01A06913		ldi		$a0,#26							; FMTK_IO
FFFC030C 00D06A13		ldi		$a2,#13							; putchar function
FFFC0310 00000073		ecall
FFFC0314 00073083		ldo		$ra,[$sp]
FFFC0318 00873803		ldo		$v0,8[$sp]
FFFC031C 01073903		ldo		$a0,16[$sp]
FFFC0320 01873883		ldo		$v1,24[$sp]
FFFC0324 02073983		ldo		$a1,32[$sp]
FFFC0328 02873A03		ldo		$a2,40[$sp]
FFFC032C 03070713		add		$sp,$sp,#48
FFFC0330 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	MonEntry:
                        	;		flw			$f2,fltTen
                        	;		fsw			$f2,f2Save
                        	;		flw			$f1,fltTen
                        	;		fsw			$f1,f1Save
                        	;		fadd		$f18,$f2,$f1
                        	;		fsw			$f18,f18Save
FFFC0334 00A06913			ldi		$a0,#10
FFFC0338 00606A13			ldi		$a2,#6
                        	;		call	fltToString
                        	;		ldi		$a0,#STRTMP
                        	;		call	PutString
                        	
                        	Monitor:
FFFC033C B0000737		ldi		$sp,#$AFFFFFFC
FFFC0340 FFC70713
FFFC0344 3000F073		csrrc	$x0,#$300,#1
                        	;		call	DumpReadyList
                        	;		call	DumpTimeoutList
FFFC0348 3000E073		csrrs	$x0,#$300,#1
FFFC034C 00006213		ldi		$s1,#0					; s1 = input pointer
FFFC0350 00D06913		ldi		$a0,#CR
FFFC0354 F29FF0EF		call	Putch
FFFC0358 00006913		ldi		$a0,#LF
	call	Putch
FFFC035C F21FF0EF
FFFC0360 03E06913		ldi		$a0,#'>'
FFFC0364 F19FF0EF		call	Putch
                        	.0001:
FFFC0368 EEDFF0EF			call	Getch						; wait until character pressed
FFFC036C FE084EE3			blt		$v0,$x0,.0001
FFFC0370 00084D13			xor		$t0,$v0,#LF			; ignore line feed
		beq		$t0,$x0,.procLine
FFFC0374 0E0D0C63
FFFC0378 00D84D13			xor		$t0,$v0,#CR
FFFC037C 0E0D0863			beq		$t0,$x0,.procLine
FFFC0380 00884D13			xor		$t0,$v0,#BS
FFFC0384 080D0263			beq		$t0,$x0,.doBackspace
FFFC0388 07F84D13			xor		$t0,$v0,#DEL
FFFC038C 020D0263			beq		$t0,$x0,.doDelete
FFFC0390 00014637			sb		$v0,INBUF[$s1]
FFFC0394 10060613
FFFC0398 00460633
FFFC039C 01060023
FFFC03A0 00120213			add		$s1,$s1,#1
FFFC03A4 00086933			mov		$a0,$v0
FFFC03A8 ED5FF0EF			call	Putch
FFFC03AC FA000EE3			bra		.0001
                        	.doDelete:
FFFC03B0 000262B3			mov		$s2,$s1
FFFC03B4 00128293			add		$s2,$s2,#1
                        	.0002:
FFFC03B8 00014637			lb		$t0,INBUF[$s2]
FFFC03BC 10060613
FFFC03C0 00560633
FFFC03C4 00060D03
FFFC03C8 00014637			sb		$t0,INBUF-1[$s2]
FFFC03CC 0FF60613
FFFC03D0 00560633
FFFC03D4 01A60023
FFFC03D8 00128293			add		$s2,$s2,#1
FFFC03DC 00014637			add		$t0,$s2,#INBUF
FFFC03E0 10060613
FFFC03E4 00560D33
FFFC03E8 00014637			slt		$t0,$t0,#INBUF+$7F
FFFC03EC 17F60613
FFFC03F0 FC0D14E3			bne		$t0,$x0,.0002
FFFC03F4 00014637			sb		$x0,INBUF[$s2]
FFFC03F8 10060613
FFFC03FC 00560633
FFFC0400 00060023
FFFC0404 F60002E3			bra		.0001
                        	.doBackspace:
FFFC0408 F60200E3			beq		$s1,$x0,.0001		; can't backspace anymore
FFFC040C 00086933			mov		$a0,$v0					; show the backspace
FFFC0410 E6DFF0EF			call	Putch
FFFC0414 FFF20213			sub		$s1,$s1,#1
FFFC0418 000262B3			mov		$s2,$s1
                        	.0003:
FFFC041C 00014637			lb		$t0,INBUF+1[$s2]
FFFC0420 10160613
FFFC0424 00560633
FFFC0428 00060D03
FFFC042C 00014637			sb		$t0,INBUF[$s2]
FFFC0430 10060613
FFFC0434 00560633
FFFC0438 01A60023
FFFC043C 00128293			add		$s2,$s2,#1
FFFC0440 00014637			add		$t0,$s2,#INBUF
FFFC0444 10060613
FFFC0448 00560D33
FFFC044C 00014637			slt		$t0,$t0,#INBUF+$7F
FFFC0450 17F60613
FFFC0454 FC0D14E3			bne		$t0,$x0,.0003
FFFC0458 00014637			sb		$x0,INBUF[$s2]
FFFC045C 10060613
FFFC0460 00560633
FFFC0464 00060023
FFFC0468 F00000E3			bra		.0001
                        	.procLine:
FFFC046C 00014637			sb		$x0,INBUF[$s1]
FFFC0470 10060613
FFFC0474 00460633
FFFC0478 00060023
FFFC047C 00006213			ldi		$s1,#0
                        	.skip:
FFFC0480 00014637			lb		$t0,INBUF[$s1]
FFFC0484 10060613
FFFC0488 00460633
FFFC048C 00060D03
FFFC0490 100D0663			beq		$t0,$x0,.0005
FFFC0494 03ED4D93			xor		$t1,$t0,#'>'
FFFC0498 000D9663			bne		$t1,$x0,.0004
                        	.skip2:
FFFC049C 00120213			add		$s1,$s1,#1
FFFC04A0 FE0000E3			bra		.skip
                        	.0004:
FFFC04A4 020D4D93			xor		$t1,$t0,#' '
FFFC04A8 FE0D8AE3			beq		$t1,$x0,.skip2
FFFC04AC 009D4D93			xor		$t1,$t0,#'\t'
FFFC04B0 FE0D86E3			beq		$t1,$x0,.skip2
FFFC04B4 04DD4D93			xor		$t1,$t0,#'M'
FFFC04B8 0E0D8463			beq		$t1,$x0,doMem
FFFC04BC 04206D93			ldi		$t1,#'B'
FFFC04C0 05BD1463			bne		$t0,$t1,.0006
FFFC04C4 00106913			ldi		$a0,#1					; Start task
FFFC04C8 000089B7			ldi		$a1,#32000			; 32 kB
FFFC04CC D0098993
FFFC04D0 FFFC4A37			ldi		$a2,#CSTART			; start address
FFFC04D4 C30A0A13
FFFC04D8 00000073			ecall
FFFC04DC 0008E233			mov		$s1,$v1					; save v1
FFFC04E0 FFFC1937			ldi		$a0,#msgCRLF
FFFC04E4 9EE90913
FFFC04E8 310000EF			call	PutString
FFFC04EC 00026933			mov		$a0,$s1					; get back v1
FFFC04F0 2A8000EF			call	PutHexByte
FFFC04F4 FFFC1937			ldi		$a0,#msgTaskStart
FFFC04F8 9E090913
FFFC04FC 2FC000EF			call	PutString
FFFC0500 1CD020EF			call  DumpReadyList
                        			;ldi		$a0,#5					; Reschedule task
                        			;ldi		$a1,#1					; sleep(0)
                        			;ecall
FFFC0504 E39FF06F			jmp		Monitor
                        	.0006:
FFFC0508 04406D93			ldi		$t1,#'D'
FFFC050C 03BD1663			bne		$t0,$t1,.0007
FFFC0510 00014637			lb		$t0,INBUF+1[$s1]
FFFC0514 10160613
FFFC0518 00460633
FFFC051C 00060D03
FFFC0520 05406D93			ldi		$t1,#'T'
FFFC0524 01BD1663			bne		$t0,$t1,.noT
FFFC0528 295020EF			call	DumpTimeoutList
FFFC052C E11FF06F			jmp		Monitor
                        	.noT:
FFFC0530 19D020EF			call 	DumpReadyList
                        			;ldi		$a0,#15
                        			;ecall
FFFC0534 E09FF06F			jmp		Monitor
                        	.0007:
FFFC0538 04506D93			ldi		$t1,#'E'
FFFC053C 01BD1463			bne		$t0,$t1,.0008
FFFC0540 0E80006F			jmp		EditMem
                        	.0008:
FFFC0544 04606D93			ldi		$t1,#'F'
FFFC0548 01BD1463			bne		$t0,$t1,.0009
FFFC054C 0F40006F			jmp		FillMem
                        	.0009:
FFFC0550 05306D93			ldi		$t1,#'S'
FFFC0554 01BD1A63			bne		$t0,$t1,.0010
FFFC0558 00506913			ldi		$a0,#5					; sleep(0)
FFFC055C 00106993			ldi		$a1,#1
FFFC0560 00000073			ecall
FFFC0564 DD9FF06F			jmp		Monitor
                        	.0010:
FFFC0568 04B06D93			ldi		$t1,#'K'
FFFC056C 01BD1C63			bne		$t0,$t1,.0011
FFFC0570 128000EF			call	GetHexNum
FFFC0574 00306913			ldi		$a0,#3					; kill task
FFFC0578 000869B3			mov		$a1,$v0					; a0 = pid
FFFC057C 00000073			ecall
FFFC0580 DBDFF06F			jmp		Monitor
                        	.0011:
FFFC0584 03F06D93			ldi		$t1,#'?'
FFFC0588 01BD1A63			bne		$t0,$t1,.0012
FFFC058C FFFC1937			ldi		$a0,#msgMonHelp
FFFC0590 94190913
FFFC0594 264000EF			call	PutString
FFFC0598 DA5FF06F			jmp		Monitor
                        	.0012:
                        	.0005:
FFFC059C DA0000E3			bra		Monitor
                        	
                        	doMem:
FFFC05A0 FF870713			sub		$sp,$sp,#8
FFFC05A4 00120213			add		$s1,$s1,#1
FFFC05A8 00473023			sto		$s1,[$sp]
FFFC05AC 00D06913			ldi		$a0,#CR
FFFC05B0 CCDFF0EF			call	Putch
FFFC05B4 00014937			ldi		$a0,INBUF
FFFC05B8 10090913
FFFC05BC 23C000EF			call	PutString
FFFC05C0 00073203			ldo		$s1,[$sp]
FFFC05C4 00870713			add		$sp,$sp,#8
FFFC05C8 0D0000EF			call	GetHexNum
FFFC05CC 00086333			mov		$s3,$v0
FFFC05D0 00120213			add		$s1,$s1,#1
FFFC05D4 0C4000EF			call	GetHexNum
FFFC05D8 006803B3			add		$s4,$v0,$s3
                        	.loop2:
FFFC05DC C79FF0EF			call	Getch						; check for ctrl-c
FFFC05E0 00384813			xor		$v0,$v0,#3
FFFC05E4 D4080CE3			beq		$v0,$x0,Monitor
FFFC05E8 00D06913			ldi		$a0,#CR
FFFC05EC C91FF0EF			call	Putch
FFFC05F0 00036933			mov		$a0,$s3
FFFC05F4 164000EF			call	PutHexWord
FFFC05F8 03A06913			ldi		$a0,#':'
FFFC05FC C81FF0EF			call	Putch
FFFC0600 00706293			ldi		$s2,#7
                        	.loop:
FFFC0604 02006913			ldi		$a0,#' '
FFFC0608 C75FF0EF			call	Putch
FFFC060C 00030903			ldb		$a0,[$s3]
FFFC0610 188000EF			call	PutHexByte
FFFC0614 00130313			add		$s3,$s3,#1
FFFC0618 FFF28293			sub		$s2,$s2,#1
FFFC061C FE02D4E3			bge		$s2,$x0,.loop
FFFC0620 FA736EE3			bltu	$s3,$s4,.loop2
FFFC0624 D0000CE3			bra		Monitor		
                        	
                        	EditMem:
FFFC0628 070000EF			call	GetHexNum			; get address to edit
FFFC062C 00086333			mov		$s3,$v0
FFFC0630 00120213			add		$s1,$s1,#1
FFFC0634 064000EF			call	GetHexNum			; get value to set
FFFC0638 00680023			stb		$s3,[$v0]			; update mem
FFFC063C D01FF06F			jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	;	>F 1000 800 EE
                        	; Fills memory beginning at address $1000 for $800 bytes with the value $EE
                        	;------------------------------------------------------------------------------
                        	
                        	FillMem:
FFFC0640 058000EF			call	GetHexNum			; get address
FFFC0644 00086333			mov		$s3,$v0
FFFC0648 00120213			add		$s1,$s1,#1
FFFC064C 04C000EF			call	GetHexNum			; get length
FFFC0650 000863B3			mov		$s4,$v0
FFFC0654 00120213			add		$s1,$s1,#1
FFFC0658 040000EF			call	GetHexNum			; get byte to use
                        	.0001:
FFFC065C 01030023			stb		$v0,[$s3]
FFFC0660 FFF38393			sub		$s4,$s4,#1
FFFC0664 FE704CE3			bgt		$s4,$x0,.0001
FFFC0668 CD5FF06F			jmp		Monitor
                        	
                        	;------------------------------------------------------------------------------
                        	; Skip over spaces and tabs in the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	SkipSpaces:
                        	.skip2:
FFFC066C 00014637			ldb		$t0,INBUF[$s1]
FFFC0670 10060613
FFFC0674 00460633
FFFC0678 00060D03
FFFC067C 020D4D93			xor		$t1,$t0,#' '
FFFC0680 000D8863			beq		$t1,$x0,.skip1
FFFC0684 009D4D93			xor		$t1,$t0,#'\t'
FFFC0688 000D8463			beq		$t1,$x0,.skip1
FFFC068C 00008067			ret
                        	.skip1:
FFFC0690 00120213			add		$s1,$s1,#1
FFFC0694 FC000CE3			bra		.skip2
                        	
                        	;------------------------------------------------------------------------------
                        	; Get a hex number from the input buffer.
                        	;------------------------------------------------------------------------------
                        	
                        	GetHexNum:
FFFC0698 00006813			ldi		$v0,#0							; v0 = num
FFFC069C FF870713			sub		$sp,$sp,#8
FFFC06A0 00173023			sto		$ra,[$sp]
FFFC06A4 FC9FF0EF			call	SkipSpaces
                        	.next:
FFFC06A8 00014637			lb		$t0,INBUF[$s1]
FFFC06AC 10060613
FFFC06B0 00460633
FFFC06B4 00060D03
FFFC06B8 03006E13			ldi		$t2,#'0'
FFFC06BC 03CD4663			blt		$t0,$t2,.0001
FFFC06C0 03A06E13			ldi		$t2,#'9'+1
FFFC06C4 07CD4063			blt		$t0,$t2,.isDigit
FFFC06C8 04106E13			ldi		$t2,#'A'
FFFC06CC 01CD4E63			blt		$t0,$t2,.0001
FFFC06D0 04706E13			ldi		$t2,#'F'+1
FFFC06D4 03CD4063			blt		$t0,$t2,.isHexUpper
FFFC06D8 06106E13			ldi		$t2,#'a'
FFFC06DC 01CD4663			blt		$t0,$t2,.0001
FFFC06E0 06706E13			ldi		$t2,#'f'+1
FFFC06E4 03CD4463			blt		$t0,$t2,.isHexLower
                        	.0001:
FFFC06E8 00073083			ldo		$ra,[$sp]
FFFC06EC 00870713			add		$sp,$sp,#8
FFFC06F0 00008067			ret
                        	.isHexUpper:
FFFC06F4 00481813			sll		$v0,$v0,#4
FFFC06F8 FBFD0D13			sub		$t0,$t0,#'A'
FFFC06FC 00AD0D13			add		$t0,$t0,#10
FFFC0700 01A86833			or		$v0,$v0,$t0
FFFC0704 00120213			add		$s1,$s1,#1
FFFC0708 FA0000E3			bra		.next
                        	.isHexLower:
FFFC070C 00481813			sll		$v0,$v0,#4
FFFC0710 F9FD0D13			sub		$t0,$t0,#'a'
FFFC0714 00AD0D13			add		$t0,$t0,#10
FFFC0718 01A86833			or		$v0,$v0,$t0
FFFC071C 00120213			add		$s1,$s1,#1
FFFC0720 F80004E3			bra		.next
                        	.isDigit:
FFFC0724 00481813			sll		$v0,$v0,#4
FFFC0728 FD0D0D13			sub		$t0,$t0,#'0'
FFFC072C 01A86833			or		$v0,$v0,$t0
FFFC0730 00120213			add		$s1,$s1,#1
FFFC0734 F6000AE3			bra		.next
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a word as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexDword:
FFFC0738 FF070713			sub		$sp,$sp,#16
FFFC073C 00173023			sto		$ra,[$sp]
FFFC0740 01273423			sto		$a0,8[$sp]
FFFC0744 00095913			srl		$a0,$a0,#32
FFFC0748 010000EF			call	PutHexWord
FFFC074C 00073083			ldo		$ra,[$sp]
FFFC0750 00873903			ldo		$a0,8[$sp]
FFFC0754 01070713			add		$sp,$sp,#16	; fall through to PutHexWord
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a word as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexWord:
FFFC0758 FF070713			sub		$sp,$sp,#16
FFFC075C 00173023			sto		$ra,[$sp]
FFFC0760 01273423			sto		$a0,8[$sp]
FFFC0764 01095913			srl		$a0,$a0,#16
FFFC0768 010000EF			call	PutHexHalf
FFFC076C 00073083			ldo		$ra,[$sp]
FFFC0770 00873903			ldo		$a0,8[$sp]
FFFC0774 01070713			add		$sp,$sp,#16	; fall through to PutHexHalf
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a half-word (16 bits) as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexHalf:
FFFC0778 FF070713			sub		$sp,$sp,#16
FFFC077C 00173023			sto		$ra,[$sp]
FFFC0780 01273423			sto		$a0,8[$sp]
FFFC0784 00895913			srl		$a0,$a0,#8
FFFC0788 010000EF			call	PutHexByte
FFFC078C 00073083			ldo		$ra,[$sp]
FFFC0790 00873903			ldo		$a0,8[$sp]		
FFFC0794 01070713			add		$sp,$sp,#16	; fall through to PutHexByte
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a byte as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexByte:
FFFC0798 FF070713			sub		$sp,$sp,#16
FFFC079C 00173023			sto		$ra,[$sp]
FFFC07A0 01273423			sto		$a0,8[$sp]
FFFC07A4 00495913			srl		$a0,$a0,#4		; put the high order nybble first
FFFC07A8 010000EF			call	PutHexNybble
FFFC07AC 00073083			ldo		$ra,[$sp]
FFFC07B0 00873903			ldo		$a0,8[$sp]
FFFC07B4 01070713			add		$sp,$sp,#16		; fall through to PutHexNybble
                        	
                        	;------------------------------------------------------------------------------
                        	; Output a nybble as a hex string.
                        	;------------------------------------------------------------------------------
                        	
                        	PutHexNybble:
FFFC07B8 FF070713			sub		$sp,$sp,#16
FFFC07BC 00173023			sto		$ra,[$sp]
FFFC07C0 01273423			sto		$a0,8[$sp]
FFFC07C4 00F97913			and		$a0,$a0,#15		; strip off high order bits
FFFC07C8 00A06D13			ldi		$t0,#10
FFFC07CC 01A94A63			blt		$a0,$t0,.lt10
FFFC07D0 FF690913			sub		$a0,$a0,#10
FFFC07D4 04190913			add		$a0,$a0,#'A'
FFFC07D8 AA5FF0EF			call	Putch
FFFC07DC 00000663			bra		.0001
                        	.lt10:
FFFC07E0 03090913			add		$a0,$a0,#'0'
FFFC07E4 A99FF0EF			call	Putch
                        	.0001:
FFFC07E8 00073083			ldo		$ra,[$sp]
FFFC07EC 00873903			ldo		$a0,8[$sp]
FFFC07F0 01070713			add		$sp,$sp,#16
FFFC07F4 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; PutString
                        	;    Put a string of characters to output device. Calls the 
                        	; Putch routine, so this routine also blocks if the transmitter is not
                        	; empty.
                        	;
                        	; Parameters:
                        	;		$a0 = pointer to null terminated string to put
                        	; Modifies:
                        	;		$t0 and $t1
                        	; Stack Space:
                        	;		2 words
                        	;------------------------------------------------------------------------------
                        	
                        	PutString:
FFFC07F8 FF070713		sub		$sp,$sp,#16				; save link register
FFFC07FC 00173023		sto		$ra,[$sp]
FFFC0800 01273423		sto		$a0,8[$sp]				; and argument
FFFC0804 00096DB3		mov		$t1,$a0						; t1 = pointer to string
                        	.0001:
FFFC0808 000DC903		ldbu	$a0,[$t1]
FFFC080C 001D8D93		add		$t1,$t1,#1				; advance pointer to next byte
FFFC0810 00090663		beqz	$a0,.done			; branch if done
FFFC0814 A69FF0EF		call	Putch							; output character
FFFC0818 FE0008E3		bra		.0001
                        	.done:
FFFC081C 00073083		ldo		$ra,[$sp]					; restore return address
FFFC0820 00873903		ldo		$a0,8[$sp]				; and argument
FFFC0824 01070713		add		$sp,$sp,#16
FFFC0828 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; MicroDelay - delay for a few clock ticks
                        	;
                        	; Parameters:
                        	;		a0 = wait in ticks (50 ns intervals)
                        	;------------------------------------------------------------------------------
                        	
                        	_MicroDelay:
FFFC082C C0001EF3		csrrw	$t3,#$C00,$x0
                        	.0001:
FFFC0830 C0001F73		csrrw	$t4,#$C00,$x0
FFFC0834 41DF0F33		sub		$t4,$t4,$t3
FFFC0838 011F5F93		srl		$t5,$t4,#17
FFFC083C FFDC0637		stt		$t5,VIA+VIA_PARAW
FFFC0840 63C60613
FFFC0844 00060633
FFFC0848 01F62023
FFFC084C 012F2F33		slt		$t4,$t4,$a0
FFFC0850 FE0F10E3		bnez	$t4,.0001
FFFC0854 00008067		ret
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	; Exception processing code starts here.
                        	; As per the RISCV privilege spec, the MSB indicates an external interrupt.
                        	; The system uses cause codes 32 to 63 for external devices. This cause code
                        	; range is reserved in the RISCV spec.
                        	;------------------------------------------------------------------------------
                        	.file "boot.r5a",666
                        		code
                        		align	4                        	
                        	IRQRout:
FFFC0858 7907ED73		csrrs	$t0,#CSR_REGSET,#15	; get regset,  ensure current regset is selected for all
FFFC085C 004D5D13		srl		$t0,$t0,#4
FFFC0860 003D7D13		and		$t0,$t0,#3
FFFC0864 00AD1D13		sll		$t0,$t0,#10				; 1k stack area
FFFC0868 20000737		ldi		$sp,#$20000000-8	; setup machine mode stack pointer (top of ram)
FFFC086C FF870713
FFFC0870 41A70733		sub		$sp,$sp,$t0				; set stack pointer for register set
FFFC0874 34201D73		csrrw	$t0,#$342,$x0			; get cause code
FFFC0878 000D4C63		blt		$t0,$x0,.isIRQ		; irq or ecall?
FFFC087C 00806D93		ldi		$t1,#8
FFFC0880 09BD6E63		bltu	$t0,$t1,.cause0to7
FFFC0884 00B06D93		ldi		$t1,#11
FFFC0888 09ADEA63		bgtu	$t0,$t1,.cause12plus
FFFC088C 1C50106F		jmp		OSCALL						; goto operating system call dispatcher
                        	.isIRQ:
FFFC0890 FFD00637		ldo		$v0,$FFD00000+440	; Display IRQ live indicator
FFFC0894 1B860613
FFFC0898 00060633
FFFC089C 00063803
FFFC08A0 00180813		add		$v0,$v0,#1
FFFC08A4 FFD00637		sto		$v0,$FFD00000+440
FFFC08A8 1B860613
FFFC08AC 00060633
FFFC08B0 01063023
FFFC08B4 792168F3		csrrs	$v1,#$792,#2			; check and set interrupt semaphore
FFFC08B8 0028F893		and		$v1,$v1,#2
FFFC08BC 00088463		beqz	$v1,.doIRQ
FFFC08C0 10000073		eret
                        	.doIRQ:
FFFC08C4 01FD7D93		and		$t1,$t0,#31				; interrupting device # is low order 5 bits of cause code
FFFC08C8 008D9D93		sll		$t1,$t1,#8				; 256 bytes per device func table
FFFC08CC 00022637		add		$t1,$t1,#DVF_Base+22*8	; load IRQ routine vector from device func table
FFFC08D0 0B060613
FFFC08D4 01B60DB3
FFFC08D8 000DBD83		ldo		$t1,[$t1]
FFFC08DC 000D8463		beq		$t1,$x0,.noIRQ		; make sure there's an address to go to
FFFC08E0 000D8067		jmp		[$t1]							; call to the IRQ routine
                        	.noIRQ:
                        		; For now, clear all interrupt sources
                        		; Otherwise the system will hang on an unknown interrupt.
FFFC08E4 FFDC0637		stt		$t0,VIA+VIA_PARAW
FFFC08E8 63C60613
FFFC08EC 00060633
FFFC08F0 01A62023
FFFC08F4 FFDC1637		ldt		$a1,UART+UART_TRB		; get data from Rx buffer to clear interrupt
FFFC08F8 A0060613
FFFC08FC 00060633
FFFC0900 00062983
FFFC0904 FFDC0637		ldt		$t0,VIA+VIA_T1CL		; clear interrupt
FFFC0908 61060613
FFFC090C 00060633
FFFC0910 00062D03
FFFC0914 79217073		csrrc	$x0,#$792,#2			; clear interrupt semaphore
FFFC0918 10000073		eret
                        	.cause0to7:
                        	.cause12plus:
FFFC091C 3000F073		csrrc	$x0,#$300,#1			; disable ints
FFFC0920 10100073		wfi
FFFC0924 FE000CE3		bra		.cause0to7				; and loop
                        	
                        	;------------------------------------------------------------------------------
                        	; Message strings
                        	;------------------------------------------------------------------------------
                        	
                        	msgStart:
FFFC0928 61746550			db		"Petajon System Starting.",13
FFFC092C 206E6F6A
FFFC0930 74737953
FFFC0934 53206D65
FFFC0938 74726174
FFFC093C 2E676E69
FFFC0940 6E6F4D0D
                        	msgMonHelp:
FFFC0941 696E6F4D			db		"Monitor Commands",13
FFFC0945 20726F74
FFFC0949 6D6D6F43
FFFC094D 73646E61
FFFC0951 2D20420D
FFFC0952 202D2042			db		"B - start tiny basic",13
FFFC0956 72617473
FFFC095A 69742074
FFFC095E 6220796E
FFFC0962 63697361
FFFC0966 2D20440D
FFFC0967 202D2044			db		"D - dump ready que",13
FFFC096B 706D7564
FFFC096F 61657220
FFFC0973 71207964
FFFC0977 450D6575
FFFC097A 202D2045			db		"E - edit memory",13
FFFC097E 74696465
FFFC0982 6D656D20
FFFC0986 0D79726F
FFFC098A 202D2046			db		"F - fill memory",13
FFFC098E 6C6C6966
FFFC0992 6D656D20
FFFC0996 0D79726F
FFFC099A 743C204B			db		"K <tid> - kill task", 13
FFFC099E 203E6469
FFFC09A2 696B202D
FFFC09A6 74206C6C
FFFC09AA 0D6B7361
FFFC09AE 733C204D			db		"M <start> <length>	- dump memory",13
FFFC09B2 74726174
FFFC09B6 6C3C203E
FFFC09BA 74676E65
FFFC09BE 2D093E68
FFFC09C2 6D756420
FFFC09C6 656D2070
FFFC09CA 79726F6D
FFFC09CE 2D20530D
FFFC09CF 202D2053			db		"S - switch task",13
FFFC09D3 74697773
FFFC09D7 74206863
FFFC09DB 0D6B7361
FFFC09DF 61742000			db		0
                        			align 4                        	
                        	msgTaskStart:
FFFC09E0 73617420			db		" task started."
FFFC09E4 7473206B
FFFC09E8 65747261
FFFC09EC 0A0D2E64
                        	msgCRLF:
FFFC09EE 00000A0D			db		13,10,0
FFFC09F1 00000000			align		
FFFC09F5 00000000
                        	
                        	flt50:
FFFC09F8 00000000		dw	0x00000000,0x00000000,0x00000000,0x40049000
FFFC09FC 00000000
FFFC0A00 00000000
FFFC0A04 40049000
                        	flt20:
FFFC0A08 00000000		dw	0x00000000,0x00000000,0x00000000,0x40034000
FFFC0A0C 00000000
FFFC0A10 00000000
FFFC0A14 40034000
                        	flt10:
FFFC0A18 00000000		dw	0x00000000,0x00000000,0x00000000,0x40024000
FFFC0A1C 00000000
FFFC0A20 00000000
FFFC0A24 40024000
                        	
                        			align		8                        	
                        	
                        	.file "fltToString.r5a",1
                        	.file "fltToString.r5a",1
                        	STRTMP		equ		$0200
                        	
                        	; -----------------------------------------------------------------------------
                        	;		$fa0 = number to convert (f18)
                        	;		$a1	= width
                        	;		$a2 = precision
                        	;		$a3 = E
                        	;		$t2 = ndx
                        	;		$s9 = exp
                        	; -----------------------------------------------------------------------------
                        	
                        	fltToString:
FFFC0A28 00006E13			ldi		$t2,#0				; $t2 = 0
FFFC0A2C E0090953			fmv		$a0,$f18
FFFC0A30 7F800637			and		$t0,$a0,#$7F800000
FFFC0A34 00060613
FFFC0A38 01267D33
FFFC0A3C 7F800DB7			ldi		$t1,#$7F800000
FFFC0A40 000D8D93
FFFC0A44 05BD1263			bne		$t0,$t1,.0001
FFFC0A48 00800637			and		$t0,$a0,#$007FFFFF
FFFC0A4C FFF60613
FFFC0A50 01267D33
FFFC0A54 000D0E63			beq		$t0,$x0,.inf
FFFC0A58 FFFC1637			ldt		$t0,msgNan
FFFC0A5C DE060613
FFFC0A60 00060633
FFFC0A64 00062D03
FFFC0A68 21A02023			stt		$t0,STRTMP
FFFC0A6C 2E000E63			bra		.prt
                        	.inf:
FFFC0A70 FFFC1637			ldt		$t0,msgInf
FFFC0A74 DDC60613
FFFC0A78 00060633
FFFC0A7C 00062D03
FFFC0A80 21A02023			stt		$t0,STRTMP
FFFC0A84 2E000263			bra		.prt
                        	.0001:
FFFC0A88 80000637			and		$t0,$a0,#$80000000
FFFC0A8C 00060613
FFFC0A90 01267D33
FFFC0A94 000D0E63			beq		$t0,$x0,.pos
FFFC0A98 02D06D13			ldi		$t0,#'-'
FFFC0A9C 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0AA0 001E0E13			add		$t2,$t2,#1
FFFC0AA4 80000637			and		$a0,$a0,#$7FFFFFFF
FFFC0AA8 FFF60613
FFFC0AAC 01267933
                        	.pos:
FFFC0AB0 00091A63			bne		$a0,$x0,.notZero
FFFC0AB4 03006D13			ldi		$t0,#'0'
FFFC0AB8 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0ABC 200E00A3			stb		$x0,STRTMP+1[$t2]
FFFC0AC0 2A000463			bra		.prt		
                        	.notZero:
FFFC0AC4 00006633			mov		$s9,$x0			; exp = 0.0
                        	;	// Make a small number > 0 so we can get at the digits.
                        	;	if (dbl < 1.0) {
                        	;		while (dbl < 1.0) {
                        	;			dbl *= 1000000.0;
                        	;			exp -= 6;  
                        	;		}
                        	;	}
FFFC0AC8 FFFC1637			flw		$f3,fltOne
FFFC0ACC DE460613
FFFC0AD0 00060633
FFFC0AD4 00062187
FFFC0AD8 F0090053			fmv		$f0,$a0
FFFC0ADC A0391D53			flt		$t0,$f18,$f3
FFFC0AE0 020D0463			beq		$t0,$x0,.0002
FFFC0AE4 FFFC1637			flw		$f4,fltMillion
FFFC0AE8 DEC60613
FFFC0AEC 00060633
FFFC0AF0 00062207
                        	.0003:
FFFC0AF4 A0391D53			flt		$t0,$f18,$f3
FFFC0AF8 000D0863			beq		$t0,$x0,.0002
FFFC0AFC 10490953			fmul	$f18,$f18,$f4
FFFC0B00 FFA60613			sub		$s9,$s9,#6
FFFC0B04 FE0008E3			bra		.0003
                        	.0002:
                        	;	// The following is similar to using log10() and pow() functions.
                        	;	// Now dbl is >= 1.0
                        	;	// Create a number dbl2 on the same order of magnitude as dbl, but
                        	;	// less than dbl.
                        	;	dbl2 = 1.0;
                        	;	dbla = dbl2;
                        	;	if (dbl > dbl2) {	// dbl > 1.0 ?
                        	;		while (dbl2 <= dbl) {
                        	;			dbla = dbl2;
                        	;			dbl2 *= 10.0;	// increase power of 10
                        	;			exp++;
                        	;		}
                        	;		// The above loop goes one too far, we want the last value less
                        	;		// than dbl.
                        	;		dbl2 = dbla;
                        	;		exp--;
                        	;	}
FFFC0B08 FFFC1637			flw		$f1,fltOne				; $f1 = dbl2 = 1.0
FFFC0B0C DE460613
FFFC0B10 00060633
FFFC0B14 00062087
FFFC0B18 38008153			fmov	$f2,$f1						; $f2 = dbla = dbl2
FFFC0B1C A1209D53			flt		$t0,$f1,$f18				; if (dbl2 < dbl)
FFFC0B20 020D0A63			beq		$t0,$x0,.0004
FFFC0B24 FFFC1637			flw		$f5,fltTen				; $f5 = 10.0
FFFC0B28 DE860613
FFFC0B2C 00060633
FFFC0B30 00062287
                        	.0006:
FFFC0B34 A1208D53			fle		$t0,$f1,$f18				; while ($f1 <= $f18)
FFFC0B38 000D0A63			beq		$t0,$x0,.0005
FFFC0B3C 38008153			fmov	$f2,$f1						; dbla = dbl2
FFFC0B40 105080D3			fmul	$f1,$f1,$f5				; dbl2 *= 10.0
FFFC0B44 00160613			add		$s9,$s9,#1				; exp++;
FFFC0B48 FE0006E3			bra		.0006
                        	.0005:
FFFC0B4C 380100D3			fmov	$f1,$f2						; dbl2 = dbla
FFFC0B50 FFF60613			sub		$s9,$s9,#1				; exp--;
                        	.0004:
                        	;	// For small constants < 1000000 try and spit out a whole number
                        	;    if (exp >= 0 && exp < 6) {
                        	;        digits_before_decpt = exp+1;
                        	;		exp = 0;
                        	;	}
                        	;	else if (exp >= -6)
                        	;		digits_before_decpt = 1;
                        	;	else
                        	;		digits_before_decpt = -1;
FFFC0B54 00064E63			blt		$s9,$x0,.0007
FFFC0B58 00606413			ldi		$s5,#6
FFFC0B5C 00865A63			bge		$s9,$s5,.0007
FFFC0B60 FFFFE233			mov		$s1,#s0						; s1 = digits before decpt
FFFC0B64 00120213			add		$s1,$s1,#1
FFFC0B68 00006613			ldi		$s9,#0						; exp = 0
FFFC0B6C 00000C63			bra		.0008
                        	.0007:
FFFC0B70 FF906413			ldi		$s5,#-7
FFFC0B74 00864663			blt		$s9,$s5,.0009
FFFC0B78 00106213			ldi		$s1,#1
FFFC0B7C 00000463			bra		.0008
                        	.0009:
FFFC0B80 FFF06213			ldi		$s1,#-1
                        	.0008:
                        	;	// Spit out a leading zero before the decimal point for a small number.
                        	;    if (exp < -6) {
                        	;		buf[ndx] = '0';
                        	;		ndx++;
                        	;        buf[ndx] = '.';
                        	;        ndx++;
                        	;    }
FFFC0B84 FFA06413			ldi		$s5,#-6
FFFC0B88 00865E63			bge		$s9,$s5,.0010
FFFC0B8C 03006D13			ldi		$t0,#'0'
FFFC0B90 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0B94 001E0E13			add		$t2,$t2,#1
FFFC0B98 02E06D13			ldi		$t0,#'.'
FFFC0B9C 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0BA0 001E0E13			add		$t2,$t2,#1
                        	.0010:
                        	;	// Now loop processing one digit at a time.
                        	;    for (nn = 0; nn < 30 && precision > 0; nn++) {
                        	;        digit = 0;
                        	;		dbla = dbl;
                        	;		// dbl is on the same order of magnitude as dbl2 so
                        	;		// a repeated subtract can be used to find the digit.
                        	;        while (dbl >= dbl2) {
                        	;            dbl -= dbl2;
                        	;            digit++;
                        	;        }
                        	;        buf[ndx] = digit + '0';
                        	;		// Now go back and perform just a single subtract and
                        	;		// a multiply to find out how much to reduce dbl by.
                        	;		// This should improve the accuracy
                        	;		if (digit > 2)
                        	;			dbl = dbla - dbl2 * digit;
                        	;        ndx++;
                        	;        digits_before_decpt--;
                        	;        if (digits_before_decpt==0) {
                        	;           buf[ndx] = '.';
                        	;           ndx++;
                        	;        }
                        	;        else if (digits_before_decpt < 0)
                        	;            precision--;
                        	;		// Shift the next digit to be tested into position.
                        	;        dbl *= 10.0;
                        	;    }
FFFC0BA4 00006313			ldi		$s3,#0						; s3 = nn = 0
FFFC0BA8 01E06413			ldi		$s5,#30
FFFC0BAC FFFC1637			flw		$f7,fltTen				; f7 = 10.0
FFFC0BB0 DE860613
FFFC0BB4 00060633
FFFC0BB8 00062387
                        	.0016:
FFFC0BBC 00832D33			slt		$t0,$s3,$s5
FFFC0BC0 060D0863			beq		$t0,$x0,.0011
FFFC0BC4 00006413			ldi		$s5,#0
FFFC0BC8 07445463			bge		$s5,$a2,.0011			; (0 < precision)
FFFC0BCC 00006393			ldi		$s4,#0						; s4 = digit = 0
FFFC0BD0 38090153			fmov	$f2,$f18						; dbla = dbl
                        	.0013:
FFFC0BD4 A1208D53			fle		$t0,$f1,$f18						; while (dbl2 <= dbl)
FFFC0BD8 000D0863			beq		$t0,$x0,.0012
FFFC0BDC 08190953			fsub	$f18,$f18,$f1						; dbl -= dbl2
FFFC0BE0 00138393			add		$s4,$s4,#1						; digit++
FFFC0BE4 FE0008E3			bra		.0013
                        	.0012:
FFFC0BE8 03038413			add		$s5,$s4,#'0'			; buf[ndx] = digit + '0'
FFFC0BEC 208E0023			stb		$s5,STRTMP[$t2]
FFFC0BF0 00206413			ldi		$s5,#2						; if (2 < digit)
FFFC0BF4 00745863			bge		$s5,$s4,.0014
FFFC0BF8 D00382D3			fcvt.s.w	$f5,$s4				; f5 = digit as float
FFFC0BFC 10508353			fmul	$f6,$f1,$f5				; f6 = dbl2 * digit
FFFC0C00 08610953			fsub	$f18,$f2,$f6				; dbl = dbla - dbl2 * digit
                        	.0014:
FFFC0C04 001E0E13			add		$t2,$t2,#1				; ndx++
FFFC0C08 FFF20213			sub		$s1,$s1,#1				; digits_before_decpt--;
FFFC0C0C 00021A63			bne		$s1,$x0,.0015			; if (digits_before_decpt==0)
FFFC0C10 02E06D13			ldi		$t0,#'.'
FFFC0C14 21AE0023			stb		$t0,STRTMP[$t2]		; buf[ndx] = '.'
FFFC0C18 001E0E13			add		$t2,$t2,#1				; ndx++
FFFC0C1C 00000663			bra		.0017
                        	.0015:
FFFC0C20 00025463			bge		$s1,$x0,.0017			; else if (digits_before_decpt < 0)
FFFC0C24 FFFA0A13			sub		$a2,$a2,#1				; 	precision--
                        	.0017:
FFFC0C28 10790953			fmul	$f18,$f18,$f7				; dbl *= 10.0
FFFC0C2C F80008E3			bra		.0016
                        	.0011:
                        	;	// Trim trailing zeros from the number
                        	;    do {
                        	;        ndx--;
                        	;    } while(buf[ndx]=='0');
                        	;    ndx++;
                        	.0018:
FFFC0C30 FFFE0E13			sub		$t2,$t2,#1				; ndx--
FFFC0C34 200E0D03			ldb		$t0,STRTMP[$t2]
FFFC0C38 030D4D13			xor		$t0,$t0,#'0'
FFFC0C3C FE0D0AE3			beq		$t0,$x0,.0018
FFFC0C40 001E0E13			add		$t2,$t2,#1				; ndx++
                        	;	// Make sure we have at least one digit after the decimal point.
                        	;	if (buf[ndx]=='.') {
                        	;		ndx++;
                        	;		buf[ndx]='0';
                        	;		ndx++;
                        	;        buf[ndx]='\0';
                        	;	}
FFFC0C44 200E0D03			ldb		$t0,STRTMP[$t2]
FFFC0C48 02ED4D13			xor		$t0,$t0,#'.'
FFFC0C4C 000D1C63			bne		$t0,$x0,.0019
FFFC0C50 001E0E13			add		$t2,$t2,#1
FFFC0C54 03006D13			ldi		$t0,#'0'
FFFC0C58 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0C5C 001E0E13			add		$t2,$t2,#1
FFFC0C60 200E0023			stb		$x0,STRTMP[$t2]
                        	.0019:
                        	;	// If the number is times 10^0 don't output the exponent
                        	;   if (exp==0) {
                        	;        buf[ndx]='\0';
                        	;        goto prt;
                        	;    }
FFFC0C64 00061663			bne		$s9,$x0,.0020
FFFC0C68 200E0023			stb		$x0,STRTMP[$t2]
FFFC0C6C 0E000E63			bra		.prt
                        	.0020:
                        	;	// Spit out +/-E
                        	;    buf[ndx] = E;
                        	;    ndx++;
                        	;    if (exp < 0) {
                        	;        buf[ndx]='-';
                        	;        ndx++;
                        	;        exp = -exp;
                        	;    }
                        	;    else {
                        	;         buf[ndx]='+';
                        	;         ndx++;
                        	;    }
FFFC0C70 04506D13			ldi		$t0,#'E'
FFFC0C74 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0C78 001E0E13			add		$t2,$t2,#1
FFFC0C7C 00065C63			bge		$s9,$x0,.0021
FFFC0C80 02D06D13			ldi		$t0,#'-'
FFFC0C84 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0C88 001E0E13			add		$t2,$t2,#1
FFFC0C8C 40C00633			sub		$s9,$x0,$s9			; exp = -exp
FFFC0C90 00000863			bra		.0022
                        	.0021:
FFFC0C94 02B06D13			ldi		$t0,#'+'
FFFC0C98 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0C9C 001E0E13			add		$t2,$t2,#1
                        	.0022:
                        	;	// now process the exponent
                        	;    digit = 0;
                        	;    while (exp >= 1000) {
                        	;        exp -= 1000;
                        	;        digit++;
                        	;    }
FFFC0CA0 00006393			ldi		$s4,#0
FFFC0CA4 3E806D13			ldi		$t0,#1000
                        	.0025:
FFFC0CA8 01A65463			bge		$s9,$t0,.0023
FFFC0CAC 00000863			bra		.0024
                        	.0023:
FFFC0CB0 41A60633			sub		$s9,$s9,$t0
FFFC0CB4 00138393			add		$s4,$s4,#1
FFFC0CB8 FE0008E3			bra		.0025
                        	.0024:
                        	;	d1 = digit;
                        	;	if (digit) {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0CBC 0003E4B3			mov		$s6,$s4					; s6 = d1 = s4 = digit
FFFC0CC0 00039863			bne		$s4,$x0,.0026
FFFC0CC4 03038D13			add		$t0,$s4,#'0'
FFFC0CC8 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0CCC 001E0E13			add		$t2,$t2,#1
                        	.0026:
                        	;	digit = 0;
                        	;    while (exp >= 100) {
                        	;        exp -= 100;
                        	;        digit++;
                        	;    }
FFFC0CD0 00006393			ldi		$s4,#0
FFFC0CD4 06406D13			ldi		$t0,#100
                        	.0027:
FFFC0CD8 01A65463			bge		$s9,$t0,.0028
FFFC0CDC 00000863			bra		.0029
                        	.0028:
FFFC0CE0 41A60633			sub		$s9,$s9,$t0
FFFC0CE4 00138393			add		$s4,$s4,#1
FFFC0CE8 FE0008E3			bra		.0027
                        	.0029:	
                        	;	d2 = digit;
                        	;	if (digit==0 && d1==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0CEC 0003E533			mov		$s7,$s4				; $s7 = d2
FFFC0CF0 00049463			bne		$s6,$x0,.0030
FFFC0CF4 00038863			beq		$s4,$x0,.0031
                        	.0030:
FFFC0CF8 03038D13			add		$t0,$s4,#'0'
FFFC0CFC 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0D00 001E0E13			add		$t2,$t2,#1
                        	.0031:
                        	;	digit = 0;
                        	;    while (exp >= 10) {
                        	;        exp -= 10;
                        	;        digit++;
                        	;    }
FFFC0D04 00006393			ldi		$s4,#0
FFFC0D08 00A06D13			ldi		$t0,#10
                        	.0032:
FFFC0D0C 01A65463			bge		$s9,$t0,.0034
FFFC0D10 00000863			bra		.0035
                        	.0034:
FFFC0D14 41A60633			sub		$s9,$s9,$t0
FFFC0D18 00138393			add		$s4,$s4,#1
FFFC0D1C FE0008E3			bra		.0032
                        	.0035:	
                        	;	d3 = digit;
                        	;	if (digit==0 && d1==0 && d2==0)
                        	;		;
                        	;	else {
                        	;		buf[ndx] = digit + '0';
                        	;		ndx++;
                        	;	}
FFFC0D20 0003E5B3			mov		$s8,$s4
FFFC0D24 00039663			bne		$s4,$x0,.0036
FFFC0D28 00049463			bne		$s6,$x0,.0036
FFFC0D2C 00050863			beq		$s7,$x0,.0037
                        	.0036:
FFFC0D30 03038D13			add		$t0,$s4,#'0'
FFFC0D34 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0D38 001E0E13			add		$t2,$t2,#1
                        	.0037:
                        	;	digit = 0;
                        	;    while (exp >= 1) {
                        	;        exp -= 1;
                        	;        digit++;
                        	;    }
FFFC0D3C 00006393			ldi		$s4,#0
FFFC0D40 00106D13			ldi		$t0,#1
                        	.0038:
FFFC0D44 01A65463			bge		$s9,$t0,.0040
FFFC0D48 00000863			bra		.0039
                        	.0040:
FFFC0D4C 41A60633			sub		$s9,$s9,$t0
FFFC0D50 00138393			add		$s4,$s4,#1
FFFC0D54 FE0008E3			bra		.0038
                        	.0039:	
                        	;    buf[ndx] = digit + '0';
                        	;    ndx++;
                        	;    buf[ndx] = '\0';
FFFC0D58 03038D13			add		$t0,$s4,#'0'
FFFC0D5C 21AE0023			sb		$t0,STRTMP[$t2]
FFFC0D60 001E0E13			add		$t2,$t2,#1
FFFC0D64 200E0023			sb		$x0,STRTMP[$t2]
                        	;	// Now pad the number on the left or right as requested.
                        	.prt:
                        	;    // pad left
                        	;    if (width > 0) {
                        	;        if (ndx < width) {
                        	;            for (nn = 39; nn >= width-ndx; nn--)
                        	;                buf[nn] = buf[nn-(width-ndx)];
                        	;            for (; nn >= 0; nn--)
                        	;                buf[nn] = ' ';
                        	;        }
                        	;    }
FFFC0D68 0409C663			blt		$a1,$x0,.0041
FFFC0D6C 04098463			beq		$a1,$x0,.0041
FFFC0D70 013E4463			blt		$t2,$a1,.0042
FFFC0D74 04000063			bra		.0041
                        	.0042:
FFFC0D78 02706313			ldi		$s3,#39					; s3 = nn
FFFC0D7C 41C98D33			sub		$t0,$a1,$t2			; width-ndx
                        	.0045:
FFFC0D80 01A35463			bge		$s3,$t0,.0043
FFFC0D84 00000C63			bra		.0044
                        	.0043:
FFFC0D88 41A304B3			sub		$s6,$s3,$t0			; nn-(width-ndx)
FFFC0D8C 20030D83			ldb		$t1,STRTMP[$s3]
FFFC0D90 21B48023			stb		$t1,STRTMP[$s6]
FFFC0D94 FFF30313			sub		$s3,$s3,#1
FFFC0D98 FE0004E3			bra		.0045
                        	.0044:
FFFC0D9C 02006D13			ldi		$t0,#' '
                        	.0048:
FFFC0DA0 00035463			bge		$s3,$x0,.0046
FFFC0DA4 00000863			bra		.0047
                        	.0046:
FFFC0DA8 21A30023			stb		$t0,STRTMP[$s3]
FFFC0DAC FFF30313			sub		$s3,$s3,#1
FFFC0DB0 FE0008E3			bra		.0048
                        	.0047:
                        	.0041:
                        	;    // pad right
                        	;    if (width < 0) {
                        	;        width = -width;
                        	;        while (ndx < width) {
                        	;            buf[ndx]=' ';
                        	;            ndx++;
                        	;        }
                        	;        buf[ndx]='\0';
                        	;    }
                        	;    return (ndx);
FFFC0DB4 0209D063			bge		$a1,$x0,.0050
FFFC0DB8 413009B3			sub		$a1,$x0,$a1
FFFC0DBC 02006D13			ldi		$t0,#' '
                        	.0052:
FFFC0DC0 013E5863			bge		$t2,$a1,.0051
FFFC0DC4 21AE0023			stb		$t0,STRTMP[$t2]
FFFC0DC8 001E0E13			add		$t2,$t2,#1
FFFC0DCC FE000AE3			bra		.0052
                        	.0051:
FFFC0DD0 200E0023			stb		$x0,STRTMP[$t2]
                        	.0050:
FFFC0DD4 000E6833			mov		$v0,$t2
FFFC0DD8 00008067			ret
                        	
                        			align	4                        	
                        	msgInf:
FFFC0DDC 00666E49			db	"Inf",0
                        	msgNan:
FFFC0DE0 006E614E			db	"Nan",0
                        	fltOne:
FFFC0DE4 3F800000			dw		$3F800000					; 1.0
                        	fltTen:
FFFC0DE8 41200000			dw		$41200000					; 10.0
                        	fltMillion:
FFFC0DEC 49742400			dw		$49742400					; 1,000,000
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../bios/bios.r5a",1
                        	.file "../bios/bios.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../bios/bios.r5a",25
                        		code
                        		align	2                        	
                        	BIOSCallTbl:
FFFC0DF0 0DFC0DF8		dh		BIOS_ClearScreen
FFFC0DF2 0E000DFC		dh		BIOS_HomeCursor
FFFC0DF4 00000E00		dh		BIOS_VideoPutChar
                        	
FFFC0DF6 006F0000		align	
                        	
                        	BIOS_ClearScreen:
FFFC0DF8 3910006F		jmp		VideoClearScreen
                        	BIOS_HomeCursor:
FFFC0DFC 3D10006F		jmp		VideoHomeCursor
                        	BIOS_VideoPutChar:
FFFC0E00 42D0006F		jmp		VideoPutChar
                        	
                        	
                        	
                        	
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../bios/mem.r5a",1
                        	.file "../bios/mem.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../bios/mem.r5a",25
                        			code	18 bits
                        			align	4                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	MMUInit:
FFFC0E04 FF870713			sub		$sp,$sp,#8
FFFC0E08 00173023			sto		$ra,[$sp]
FFFC0E0C 00002D37			ldi		$t0,#8189				; set number of available pages (3 pages already allocated)
FFFC0E10 FFDD0D13
FFFC0E14 00025637			stt		$t0,NPAGES
FFFC0E18 82860613
FFFC0E1C 00060633
FFFC0E20 01A62023
                        			; Free all memory for all tasks			
FFFC0E24 00006D13			ldi		$t0,#$00
FFFC0E28 03F06F13			ldi		$t4,#MAX_TID		; task id
                        	.0004:
FFFC0E2C 00006D93			ldi		$t1,#$000				; regno
FFFC0E30 00001E37			ldi		$t2,#PAGES_PER_TASK	; number of registers to update
FFFC0E34 000E0E13
FFFC0E38 00206E93			ldi		$t3,#2					; number of pages pre-allocated
                        	.0001:
FFFC0E3C 010F1213			sll		$s1,$t4,#16			; put tid in place
FFFC0E40 01B26233			or		$s1,$s1,$t1			; or in page number
FFFC0E44 024D000D			mvmap	$x0,$t0,$s1
FFFC0E48 001D0D13			add		$t0,$t0,#$01
FFFC0E4C 001D8D93			add		$t1,$t1,#$01		; increment page number
FFFC0E50 01DDE463			bltu	$t1,$t3,.0003
FFFC0E54 00006D33			mov		$t0,$x0					; mark pages unallocated
                        	.0003:
FFFC0E58 FFFE0E13			sub		$t2,$t2,#1
FFFC0E5C FE0E10E3			bne		$t2,$x0,.0001
FFFC0E60 FFFF0F13			sub		$t4,$t4,#1
FFFC0E64 FC0F54E3			bge		$t4,$x0,.0004
                        			; Now ensure all pages in PAM are marked free
FFFC0E68 00002D37			ldi		$t0,#8191
FFFC0E6C FFFD0D13
                        	.0006:
FFFC0E70 0A0D000D			pfree	$t0
FFFC0E74 FFFD0D13			sub		$t0,$t0,#1
FFFC0E78 FE0D5CE3			bge		$t0,$x0,.0006
                        			; allocate last page for system stack
FFFC0E7C 00002DB7			ldi		$t1,#$1FFF				
FFFC0E80 FFFD8D93
FFFC0E84 00002D37			ldi		$t0,#$1FFF
FFFC0E88 FFFD0D13
FFFC0E8C 03BD000D			mvmap	$x0,$t0,$t1
                        	
                        			; Now setup segment registers
FFFC0E90 00006D13			ldi		$t0,#$0
FFFC0E94 00706D93			ldi		$t1,#$07				; t1 = value to load RWX=111, base = 0
                        	.0002:
FFFC0E98 01AD800D			mvseg	$x0,$t1,$t0			; move to the segment register identifed by t0
FFFC0E9C 001D0D13			add		$t0,$t0,#1			; pick next segment register
FFFC0EA0 010D2E13			slt		$t2,$t0,#16			; 16 segment regs
FFFC0EA4 FE0E1AE3			bne		$t2,$x0,.0002
FFFC0EA8 00073083			ldo		$ra,[$sp]
FFFC0EAC 00870713			add		$sp,$sp,#8
FFFC0EB0 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Find a run of buckets available for mapping virtual to physical addresses.
                        	;
                        	; Parameters:
                        	;		a0 = tid
                        	;		a1 = number of pages required.
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		v0 = starting bucket number (includes ASID), -1 if no run found
                        	;------------------------------------------------------------------------------
                        	
                        	FindRun:
FFFC0EB4 03F97E93		and			$t3,$a0,#$3F			; t3 = tid
FFFC0EB8 010E9E93		sll			$t3,$t3,#16				; shift into usable position
FFFC0EBC 00006D93		ldi			$t1,#0						; t1 = count of consecutive empty buckets
FFFC0EC0 000EEE33		mov			$t2,$t3						; t2 = map entry number
FFFC0EC4 003E6E13		or			$t2,$t2,#OSPAGES	; start looking at page 32 (others are for OS)
FFFC0EC8 00002FB7		ldi			$t5,#8191					; max number of pages - 1
FFFC0ECC FFFF8F93
FFFC0ED0 01DFEFB3		or			$t5,$t5,$t3				; t5 = max in ASID
                        	.0001:
FFFC0ED4 03C0080D		mvmap		$v0,$x0,$t2				; get map entry into v0
FFFC0ED8 00080A63		beq			$v0,$x0,.empty0		; is it empty?
FFFC0EDC 001E0E13		add			$t2,$t2,#1
FFFC0EE0 FFFE6AE3		bltu		$t2,$t5,.0001
                        	.0002:
FFFC0EE4 FFF06813		ldi			$v0,#-1						; got here so no run was found
FFFC0EE8 00008067		ret
                        	.empty0:
FFFC0EEC 000E6EB3		mov			$t3,$t2						; save first empty bucket
                        	.empty1:
FFFC0EF0 FFFE7AE3		bgeu		$t2,$t5,.0002
FFFC0EF4 001D8D93		add			$t1,$t1,#1
FFFC0EF8 013DFC63		bgeu		$t1,$a1,.foundEnough
FFFC0EFC 001E0E13		add			$t2,$t2,#1				; next bucket
FFFC0F00 03C0080D		mvmap		$v0,$x0,$t2				; get map entry
FFFC0F04 FE0806E3		beq			$v0,$x0,.empty1
FFFC0F08 00006DB3		mov			$t1,$x0						; reset counter
FFFC0F0C FC0004E3		bra			.0001							; go back and find another run
                        	.foundEnough:
FFFC0F10 000EE833		mov			$v0,$t3						; v0 = start of run
FFFC0F14 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = pid
                        	;		a1 = amount of memory to allocate
                        	; Modifies:
                        	;		a1,t0
                        	; Returns:
                        	;		v1 = pointer to allocated memory in virtual address space.
                        	;		v0 = E_Ok for success, E_NotAlloc otherwise
                        	;------------------------------------------------------------------------------
                        	;
                        	Alloc:
FFFC0F18 FE070713		sub			$sp,$sp,#32
FFFC0F1C 00173023		sto			$ra,[$sp]
FFFC0F20 00473423		sto			$s1,8[$sp]				; these regs must be saved
FFFC0F24 00573823		sto			$s2,16[$sp]
FFFC0F28 00673C23		sto			$s3,24[$sp]
                        		; First check if there are enough pages available in the system.
FFFC0F2C 00010637		add			$v0,$a1,#PAGESZ-1	; v0 = round memory request
FFFC0F30 FFF60613
FFFC0F34 01360833
FFFC0F38 01085813		srl			$v0,$v0,#LOG_PGSZ	; v0 = convert to pages required
FFFC0F3C 00025637		ldo			$t0,NPAGES				; check number of pages available
FFFC0F40 82860613
FFFC0F44 00060633
FFFC0F48 00063D03
FFFC0F4C 010D7663		bleu		$v0,$t0,.enough
                        	.noRun2:
FFFC0F50 00006893		ldi			$v1,#0						; not enough, return null
FFFC0F54 06000263		bra			.noRun
                        	.enough:
                        		; There are enough pages, but is there a run long enough in map space?
FFFC0F58 000862B3		mov			$s2,$v0						; save required # pages
FFFC0F5C 000869B3		mov			$a1,$v0
FFFC0F60 F55FF0EF		call		FindRun						; find a run of available slots
FFFC0F64 FE0846E3		blt			$v0,$x0,.noRun2
                        		; Now there are enough pages, and a run available, so allocate
FFFC0F68 00086233		mov			$s1,$v0						; s1 = start of run
FFFC0F6C 00025637		ldo			$s3,NPAGES				; decrease number of pages available in system
FFFC0F70 82860613
FFFC0F74 00060633
FFFC0F78 00063303
FFFC0F7C 40530333		sub			$s3,$s3,$s2
FFFC0F80 00025637		sto			$s3,NPAGES
FFFC0F84 82860613
FFFC0F88 00060633
FFFC0F8C 00663023
FFFC0F90 00086333		mov			$s3,$v0						; s3 = start of run
                        	.0001:
FFFC0F94 0800080D		palloc	$v0								; allocate a page (cheat and use hardware)
FFFC0F98 02080063		beqz		$v0,.noRun
FFFC0F9C 0268000D		mvmap		$x0,$v0,$s3				; map the page
FFFC0FA0 00130313		add			$s3,$s3,#1				; next bucket
FFFC0FA4 FFF28293		sub			$s2,$s2,#1
FFFC0FA8 FE5046E3		bgt			$s2,$x0,.0001
FFFC0FAC 01021893		sll			$v1,$s1,#LOG_PGSZ	; v1 = virtual address of allocated mem.
FFFC0FB0 00006813		ldi			$v0,#E_Ok
FFFC0FB4 00000463		bra			.xit
                        	.noRun:
FFFC0FB8 00906813		ldi			$v0,#E_NotAlloc
                        	.xit
FFFC0FBC 00073083		ldo			$ra,[$sp]					; restore saved regs
FFFC0FC0 00873203		ldo			$s1,8[$sp]
FFFC0FC4 01073283		ldo			$s2,16[$sp]
FFFC0FC8 01873303		ldo			$s3,24[$sp]
FFFC0FCC 02070713		add			$sp,$sp,#32
FFFC0FD0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Allocate the stack page for a task. The stack is located at the highest
                        	; virtual address ($7FC00).
                        	;
                        	; Parameters:
                        	;		a0 = pid to allocate for
                        	;	Returns:
                        	;		v0 = physical address, 0 if unsuccessful
                        	;		v1 = virtual address, not valid unless successful
                        	;------------------------------------------------------------------------------
                        	
                        	AllocStack:
FFFC0FD4 01091893		sll			$v1,$a0,#16			; 
FFFC0FD8 00001637		or			$v1,$v1,#PAGES_PER_TASK-1	; last page of memory is for stack
FFFC0FDC FFF60613
FFFC0FE0 011668B3
FFFC0FE4 0310080D		mvmap		$v0,$x0,$v1			; check if stack already allocated
FFFC0FE8 00081863		bnez		$v0,.0001
FFFC0FEC 0800080D		palloc	$v0							; allocate a page
FFFC0FF0 00080E63		beq			$v0,$x0,.xit		; success?
FFFC0FF4 0318000D		mvmap		$x0,$v0,$v1
                        	.0001:
FFFC0FF8 00001637		and			$v1,$v1,#4095
FFFC0FFC FFF60613
FFFC1000 011678B3
FFFC1004 01081813		sll			$v0,$v0,#LOG_PGSZ			; convert pages to addresses
FFFC1008 01089893		sll			$v1,$v1,#LOG_PGSZ
                        	.xit:
FFFC100C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; This routine will de-allocate all the pages associated with a task including
                        	; the stack.
                        	;
                        	; Parameters:
                        	;		a0 = pid to free memory for
                        	;	Modifies:
                        	;		a0,t0,t1,t3,t4
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	FreeAll:
FFFC1010 00006E93		ldi			$t3,#0
FFFC1014 01091F13		sll			$t4,$a0,#16
                        	.nxt:
FFFC1018 00001637		slt			$t1,$t3,#PAGES_PER_TASK		; number of buckets to check
FFFC101C 00060613
FFFC1020 040D8863		beqz		$t1,.0001
FFFC1024 003F0637		and			$t4,$t4,#$3F0000
FFFC1028 00060613
FFFC102C 01E67F33
FFFC1030 01DF6F33		or			$t4,$t4,$t3			; combine pid and bucket number
FFFC1034 00006D13		ldi			$t0,#0					; new page number to set (indicates free)
FFFC1038 03ED0D0D		mvmap		$t0,$t0,$t4			; get page mapping and set to zero
FFFC103C 001E8E93		add			$t3,$t3,#1			; advance to next bucket
FFFC1040 FC0D0CE3		beqz		$t0,.nxt				; 0 = no map in this bucket
FFFC1044 0A0D000D		pfree		$t0							; free the page
FFFC1048 00025637		ldo			$t0,NPAGES			; update the number of available pages
FFFC104C 82860613
FFFC1050 00060633
FFFC1054 00063D03
FFFC1058 001D0D13		add			$t0,$t0,#1
FFFC105C 00025637		sto			$t0,NPAGES
FFFC1060 82860613
FFFC1064 00060633
FFFC1068 01A63023
FFFC106C FA0006E3		bra			.nxt
                        	.0001:
FFFC1070 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Convert a virtual address to a physical one
                        	;
                        	; Parameters:
                        	;		a0 = task id
                        	;		a1 = virtual address to convert
                        	; Modifies:
                        	;		t0
                        	; Returns:
                        	;		v0 = physical address
                        	;------------------------------------------------------------------------------
                        	
                        	VirtToPhys:
FFFC1074 FF000837		ldi		$v0,#$FF000000
FFFC1078 00080813
FFFC107C 0309F663		bgeu	$a1,$v0,.notMapped
FFFC1080 0109DD13		srl		$t0,$a1,#LOG_PGSZ		; convert virt to page
FFFC1084 01091813		sll		$v0,$a0,#16
FFFC1088 01A86833		or		$v0,$v0,$t0					; and in tid
FFFC108C 0300080D		mvmap	$v0,$x0,$v0					; get the translation
FFFC1090 01081813		sll		$v0,$v0,#LOG_PGSZ		; convert page to address
FFFC1094 00010637		and		$t0,$a1,#$FFFF			; insert LSB's
FFFC1098 FFF60613
FFFC109C 01367D33
FFFC10A0 01A86833		or		$v0,$v0,$t0
FFFC10A4 00008067		ret
                        	.notMapped:
FFFC10A8 0009E833		mov		$v0,$a1
FFFC10AC 00008067		ret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/pic.r5a",1
                        	.file "../fmtk/pic.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	;
                        	;  0x80    - irq control for irq #0
                        	;  0x84    - irq control for irq #1
                        	;            bits 0 to 7  = cause code to issue
                        	;            bits 13 to 15 = irq level to issue
                        	;            bit 16 = irq enable
                        	;            bit 17 = edge sensitivity
                        	
                        	PIC				equ		$FFDC0F00
                        	PIC_CH16	equ		$C0
                        	PIC_CH28	equ		$F0
                        	PIC_CH31	equ		$FC
                        	
                        	PicInit:
FFFC10B0 FFDC1DB7		ldi		$t1,#PIC					; t1 = address of pic
FFFC10B4 F00D8D93
FFFC10B8 0001ED37		ldi		$t0,#$0001E025		; level sensitive cause 37, interrupt enabled
FFFC10BC 025D0D13
FFFC10C0 0DADA023		stt		$t0,PIC_CH16[$t1]
FFFC10C4 0001ED37		ldi		$t0,#$0001E021		; level sensitive cause 33, interrupt enabled
FFFC10C8 021D0D13
FFFC10CC 0FADA823		stt		$t0,PIC_CH28[$t1]
FFFC10D0 0001ED37		ldi		$t0,#$0001E02F		; level sensitive cause 47, interrupt enabled
FFFC10D4 02FD0D13
FFFC10D8 0FADAE23		stt		$t0,PIC_CH31[$t1]
FFFC10DC 00008067		ret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/serial.r5a",1
                        	.file "../fmtk/serial.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
                        	.file "../fmtk/serial.r5a",29
                        		code
                        		align	8                        	
                        	SerialFuncTbl:
FFFC10E0 00000000		dco		0							; no operation
FFFC10E4 00000000
FFFC10E8 00000000		dco		0							; setup
FFFC10EC 00000000
FFFC10F0 00000000		dco		0							; initialize
FFFC10F4 00000000
FFFC10F8 00000000		dco		0							; status
FFFC10FC 00000000
FFFC1100 00000000		dco		0							; media check
FFFC1104 00000000
FFFC1108 00000000		dco		0							; build BPB
FFFC110C 00000000
FFFC1110 00000000		dco		0							; open
FFFC1114 00000000
FFFC1118 00000000		dco		0							; close
FFFC111C 00000000
FFFC1120 FFFC133C		dco		SerialGetChar	; get char
FFFC1124 00000000
FFFC1128 FFFC140C		dco		SerialPeekChar
FFFC112C 00000000
FFFC1130 00000000		dco		0							; get char direct
FFFC1134 00000000
FFFC1138 FFFC1474		dco		SerialPeekCharDirect	; peek char direct
FFFC113C 00000000
FFFC1140 00000000		dco		0							; input status
FFFC1144 00000000
FFFC1148 FFFC14D0		dco		SerialPutChar
FFFC114C 00000000
FFFC1150 00000000		dco		0							; reserved
FFFC1154 00000000
FFFC1158 00000000		dco		0							; set position
FFFC115C 00000000
FFFC1160 00000000		dco		0							; read block
FFFC1164 00000000
FFFC1168 00000000		dco		0							; write block
FFFC116C 00000000
FFFC1170 00000000		dco		0							; verify block
FFFC1174 00000000
FFFC1178 00000000		dco		0							; output status
FFFC117C 00000000
FFFC1180 00000000		dco		0							; flush input
FFFC1184 00000000
FFFC1188 00000000		dco		0							; flush output
FFFC118C 00000000
FFFC1190 FFFC1584		dco		SerialIRQ			; IRQ routine
FFFC1194 00000000
FFFC1198 00000000		dco		0							; Is removable
FFFC119C 00000000
FFFC11A0 00000000		dco		0							; ioctrl read
FFFC11A4 00000000
FFFC11A8 00000000		dco		0							; ioctrl write
FFFC11AC 00000000
FFFC11B0 00000000		dco		0							; output until busy
FFFC11B4 00000000
FFFC11B8 00000000		dco		0							; 27
FFFC11BC 00000000
FFFC11C0 00000000		dco		0
FFFC11C4 00000000
FFFC11C8 00000000		dco		0
FFFC11CC 00000000
FFFC11D0 00000000		dco		0
FFFC11D4 00000000
FFFC11D8 00000000		dco		0							; 31
FFFC11DC 00000000
                        	
                        	MAX_DEV_OP			EQU		31
                        	
                        	;------------------------------------------------------------------------------
                        	; Initialize serial port.
                        	;
                        	; Modifies:
                        	;		$t0
                        	;------------------------------------------------------------------------------
                        	
                        	SerialInit:
FFFC11E0 FF870713		sub		$sp,$sp,#8
FFFC11E4 00173023		sto		$ra,[$sp]
FFFC11E8 00506913		ldi		$a0,#5							; serial device
FFFC11EC FFFC19B7		ldi		$a1,#SerialFuncTbl
FFFC11F0 0E098993
FFFC11F4 184020EF		call	CopyDevFuncTbl
FFFC11F8 00026637		stt		$x0,SerHeadRcv
FFFC11FC 80060613
FFFC1200 00060633
FFFC1204 00062023
FFFC1208 00026637		stt		$x0,SerTailRcv
FFFC120C 80460613
FFFC1210 00060633
FFFC1214 00062023
FFFC1218 00026637		stt		$x0,SerHeadXmit
FFFC121C 80860613
FFFC1220 00060633
FFFC1224 00062023
FFFC1228 00026637		stt		$x0,SerTailXmit
FFFC122C 80C60613
FFFC1230 00060633
FFFC1234 00062023
FFFC1238 00026637		stb		$x0,SerRcvXon
FFFC123C 81060613
FFFC1240 00060633
FFFC1244 00060023
FFFC1248 00026637		stb		$x0,SerRcvXoff
FFFC124C 81160613
FFFC1250 00060633
FFFC1254 00060023
FFFC1258 00906D13		ldi		$t0,#$09						; dtr,rts active, rxint enabled, no parity
FFFC125C FFDC1637		stt		$t0,UART+8
FFFC1260 A0860613
FFFC1264 00060633
FFFC1268 01A62023
FFFC126C 00060D37		ldi		$t0,#$0006001E			; reset the fifo's
FFFC1270 01ED0D13
FFFC1274 FFDC1637		stt		$t0,UART+12
FFFC1278 A0C60613
FFFC127C 00060633
FFFC1280 01A62023
FFFC1284 01E06D13		ldi		$t0,#$0000001E			; baud 9600, 1 stop bit, 8 bit, internal baud gen
FFFC1288 FFDC1637		stt		$t0,UART+12
FFFC128C A0C60613
FFFC1290 00060633
FFFC1294 01A62023
FFFC1298 00073083		ldo		$ra,[$sp]
FFFC129C 00870713		add		$sp,$sp,#8
FFFC12A0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	SerialServiceInit:
FFFC12A4 00106913		ldi		$a0,#1			; start task
FFFC12A8 40006993		ldi		$a1,#1024		; memory required
FFFC12AC FFFC1A37		ldi		$a2,#SerialService
FFFC12B0 2BCA0A13
FFFC12B4 00000073		ecall
FFFC12B8 00008067		ret
                        	SerialService:
FFFC12BC DE870713		sub		$sp,$sp,#512+24
FFFC12C0 00E06913		ldi		$a0,#14			; get current tid
FFFC12C4 00000073		ecall
FFFC12C8 20470A13		add		$a2,$sp,#516
FFFC12CC 000869B3		mov		$a1,$v0
FFFC12D0 00606913		ldi		$a0,#6			; alloc mailbox
FFFC12D4 00000073		ecall
                        	
                        	SerialServiceLoop:
FFFC12D8 00A06913		ldi		$a0,#10			; waitmsg
FFFC12DC 20470993		add		$a1,$sp,#516
FFFC12E0 20870A13		add		$a2,$sp,#520
FFFC12E4 20C70A93		add		$a3,$sp,#524
FFFC12E8 21070B13		add		$a4,$sp,#528
FFFC12EC FFF06B93		ldi		$a5,#-1
FFFC12F0 00000073		ecall
                        	
FFFC12F4 00072D03		lw		$t0,[$sp]
FFFC12F8 01FD7D13		and		$t0,$t0,#31
FFFC12FC 001D1D13		sll		$t0,$t0,#1
FFFC1300 FFFC1637		lw		$t0,SerialFuncTbl[$t0]
FFFC1304 0E060613
FFFC1308 01A60633
FFFC130C 00062D03
FFFC1310 000D0067		jmp		[$t0]
                        	
                        	SerialFinishCmd:
FFFC1314 00C72983		lw		$a1,12[$sp]		; reply mbx
FFFC1318 00198993		add		$a1,$a1,#1		; -1 = no reply requested
FFFC131C 01298E63		beq		$a1,$a0,.0001
FFFC1320 FFF98993		sub		$a1,$a1,#1
FFFC1324 00906913		ldi		$a0,#9				; sendmsg
FFFC1328 FFF06A13		ldi		$a2,#-1
FFFC132C FFF06A93		ldi		$a3,#-1
FFFC1330 FFF06B13		ldi		$a4,#-1
FFFC1334 00000073		ecall
                        	.0001:
FFFC1338 FA1FF06F		jmp		SerialServiceLoop
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialGetChar
                        	;
                        	; Check the serial port buffer to see if there's a char available. If there's
                        	; a char available then return it. If the buffer is almost empty then send an
                        	; XON.
                        	;
                        	; Stack Space:
                        	;		3 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$v0 = character or -1
                        	;------------------------------------------------------------------------------
                        	
                        	SerialGetChar:
FFFC133C FE870713			sub		$sp,$sp,#24
FFFC1340 00173023			sto		$ra,[$sp]
FFFC1344 01173423			sto		$v1,8[$sp]
FFFC1348 00473823			sto		$s1,16[$sp]
FFFC134C 00026637			lb		$s1,SerRcvXon				; skip sending XON if already sent
FFFC1350 81060613
FFFC1354 00060633
FFFC1358 00060203
FFFC135C 3000F273			csrrc	$s1,#$300,#1				; disable interrupts
FFFC1360 04021263			bne		$s1,$x0,.0002
FFFC1364 1E4000EF			call	SerialRcvCount			; check number of chars in receive buffer
FFFC1368 00882813			slt		$v0,$v0,#8					; less than 8?
FFFC136C 02080C63			beq		$v0,$x0,.0002
FFFC1370 01106813			ldi		$v0,#XON						; if <8 send an XON
FFFC1374 00026637			sb		$x0,SerRcvXoff			; clear XOFF status
FFFC1378 81160613
FFFC137C 00060633
FFFC1380 00060023
FFFC1384 00026637			sb		$v0,SerRcvXon				; flag so we don't send it multiple times
FFFC1388 81060613
FFFC138C 00060633
FFFC1390 01060023
FFFC1394 FFDC1637			sb		$v0,UART+UART_TRB
FFFC1398 A0060613
FFFC139C 00060633
FFFC13A0 01060023
                        	.0002:
FFFC13A4 00026637			lbu		$v1,SerHeadRcv			; check if anything is in buffer
FFFC13A8 80060613
FFFC13AC 00060633
FFFC13B0 00064883
FFFC13B4 00026637			lbu		$v0,SerTailRcv
FFFC13B8 80460613
FFFC13BC 00060633
FFFC13C0 00064803
FFFC13C4 03180663			beq		$v0,$v1,.noChars		; no?
FFFC13C8 00025637			lb		$v0,SerRcvBuf[$v1]	; get byte from buffer
FFFC13CC 00060613
FFFC13D0 01160633
FFFC13D4 00060803
FFFC13D8 00188893			add		$v1,$v1,#1					; update head index
FFFC13DC 00026637			sb		$v1,SerHeadRcv				
FFFC13E0 80060613
FFFC13E4 00060633
FFFC13E8 01160023
FFFC13EC 00000463			bra		.xit
                        	.noChars:
                        	.0001:
FFFC13F0 FFF06813			ldi		$v0,#-1
                        	.xit
FFFC13F4 30021073			csrrw	$x0,#$300,$s1				; restore interrupts
FFFC13F8 00073083			ldo		$ra,[$sp]
FFFC13FC 00873883			ldo		$v1,8[$sp]
FFFC1400 01073203			ldo		$s1,16[$sp]
FFFC1404 01870713			add		$sp,$sp,#24
FFFC1408 00008067			ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPeekChar
                        	;
                        	; Check the serial port buffer to see if there's a char available. If there's
                        	; a char available then return it. But don't update the buffer indexes. No need
                        	; to send an XON here.
                        	;
                        	; Stack Space:
                        	;		3 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$v0 = character or -1
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPeekChar:
FFFC140C FE870713		sub		$sp,$sp,#24
FFFC1410 00173023		sto		$ra,[$sp]
FFFC1414 01173423		sto		$v1,8[$sp]
FFFC1418 00473823		sto		$s1,16[$sp]
FFFC141C 3000F273		csrrc	$s1,#$300,#1				; disable interrupts
FFFC1420 00026637		ldbu	$v1,SerHeadRcv			; check if anything is in buffer
FFFC1424 80060613
FFFC1428 00060633
FFFC142C 00064883
FFFC1430 00026637		ldbu	$v0,SerTailRcv
FFFC1434 80460613
FFFC1438 00060633
FFFC143C 00064803
FFFC1440 01180C63		beq		$v0,$v1,.noChars		; no?
FFFC1444 00025637		ldb		$v0,SerRcvBuf[$v1]	; get byte from buffer
FFFC1448 00060613
FFFC144C 01160633
FFFC1450 00060803
FFFC1454 00000463		bra		.xit
                        	.noChars:
                        	.0001:
FFFC1458 FFF06813		ldi		$v0,#-1
                        	.xit
FFFC145C 30021073		csrrw	$x0,#$300,$s1				; restore interrupts
FFFC1460 00073083		ldo		$ra,[$sp]
FFFC1464 00873883		ldo		$v1,8[$sp]
FFFC1468 01073203		ldo		$s1,16[$sp]
FFFC146C 01870713		add		$sp,$sp,#24
FFFC1470 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPeekChar
                        	;		Get a character directly from the I/O port. This bypasses the input
                        	; buffer.
                        	;
                        	; Stack Space:
                        	;		3 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		$v0 = character or -1
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPeekCharDirect:
FFFC1474 FE870713		sub		$sp,$sp,#24
FFFC1478 00173023		sto		$ra,[$sp]
FFFC147C 01173423		sto		$v1,8[$sp]
FFFC1480 00473823		sto		$s1,16[$sp]
FFFC1484 3000F273		csrrc	$s1,#$300,#1				; disable interrupts
FFFC1488 FFDC1637		ldb		$v0,UART+UART_STAT
FFFC148C A0460613
FFFC1490 00060633
FFFC1494 00060803
FFFC1498 00887813		and		$v0,$v0,#8					; look for Rx not empty
FFFC149C 00080C63		beq		$v0,$x0,.0001
FFFC14A0 FFDC1637		ldb		$v0,UART+UART_TRB
FFFC14A4 A0060613
FFFC14A8 00060633
FFFC14AC 00060803
FFFC14B0 00000463		bra		.xit
                        	.0001:
FFFC14B4 FFF06813		ldi		$v0,#-1
                        	.xit
FFFC14B8 30021073		csrrw	$x0,#$300,$s1				; restore interrupts
FFFC14BC 00073083		ldo		$ra,[$sp]
FFFC14C0 00873883		ldo		$v1,8[$sp]
FFFC14C4 01073203		ldo		$s1,16[$sp]
FFFC14C8 01870713		add		$sp,$sp,#24
FFFC14CC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SerialPutChar
                        	;    Put a character to the serial transmitter. This routine blocks until the
                        	; transmitter is empty. The routine will attempt to transmit the char up to 
                        	; 10 times. If it still can't transmit the char then sleep is called and the
                        	; task is put to sleep for a tick. When it wakes up the routine continues to
                        	; try and send a character.
                        	;
                        	; Stack Space
                        	;		5 words
                        	; Parameters:
                        	;		$a3 = character to put
                        	; Modifies:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	SerialPutChar:
FFFC14D0 FE870713		sub		$sp,$sp,#24
FFFC14D4 01073023		sto		$v0,[$sp]
FFFC14D8 00173423		sto		$ra,8[$sp]
FFFC14DC 01173823		sto		$v1,16[$sp]
                        	.0002:
FFFC14E0 00A06893		ldi		$v1,#10
                        	.0001:
                        	;	sub		$v1,$v1,#1
                        	;	beq		$v1,$x0,.goSleep
FFFC14E4 FFDC1637		ldb		$v0,UART+UART_STAT	; wait until the uart indicates tx empty
FFFC14E8 A0460613
FFFC14EC 00060633
FFFC14F0 00060803
FFFC14F4 01087813		and		$v0,$v0,#16					; bit #4 of the status reg
FFFC14F8 FE0806E3		beqz	$v0,.0001						; branch if transmitter is not empty
FFFC14FC FFDC1637		stb		$a3,UART+UART_TRB		; send the byte
FFFC1500 A0060613
FFFC1504 00060633
FFFC1508 01560023
FFFC150C 00073803		ldo		$v0,[$sp]
FFFC1510 00873083		ldo		$ra,8[$sp]
FFFC1514 01073883		ldo		$v1,16[$sp]
FFFC1518 01870713		add		$sp,$sp,#24
FFFC151C 00008067		ret
                        	.goSleep:
FFFC1520 FF070713		sub		$sp,$sp,#16
FFFC1524 01273023		sto		$a0,[$sp]
FFFC1528 01373423		sto		$a1,8[$sp]
FFFC152C 00506913		ldi		$a0,#5							; sleep function
FFFC1530 00106993		ldi		$a1,#1							; 1 tick
FFFC1534 00000073		ecall
FFFC1538 00073903		ldo		$a0,[$sp]
FFFC153C 00873983		ldo		$a1,8[$sp]
FFFC1540 01070713		add		$sp,$sp,#16
FFFC1544 F8000EE3		bra		.0002
                        	
                        	;------------------------------------------------------------------------------
                        	; Calculate number of character in input buffer
                        	;------------------------------------------------------------------------------
                        	
                        	SerialRcvCount:
FFFC1548 00026637		ldbu	$v0,SerTailRcv	; v0 = tail index
FFFC154C 80460613
FFFC1550 00060633
FFFC1554 00064803
FFFC1558 00026637		ldbu	$v1,SerHeadRcv	; v1 = head index
FFFC155C 80060613
FFFC1560 00060633
FFFC1564 00064883
FFFC1568 41180D33		sub		$t0,$v0,$v1
FFFC156C 000D5863		bge		$t0,$x0,.xit
FFFC1570 10006D13		ldi		$t0,#256
FFFC1574 411D0D33		sub		$t0,$t0,$v1
FFFC1578 010D0D33		add		$t0,$t0,$v0
                        	.xit:
FFFC157C 000D6833		mov		$v0,$t0
FFFC1580 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	SerialIRQ:
                        	.nxtByte:
FFFC1584 00897D13		and		$t0,$a0,#$08				; bit 3 = rx full
FFFC1588 0C0D0063		beq		$t0,$x0,.notRxInt
FFFC158C FFDC1637		ldt		$a1,UART+UART_TRB		; get data from Rx buffer to clear interrupt
FFFC1590 A0060613
FFFC1594 00060633
FFFC1598 00062983
FFFC159C 00026637		ldbu	$t2,SerHeadRcv			; get buffer indexes
FFFC15A0 80060613
FFFC15A4 00060633
FFFC15A8 00064E03
FFFC15AC 00026637		ldbu	$t3,SerTailRcv
FFFC15B0 80460613
FFFC15B4 00060633
FFFC15B8 00064E83
FFFC15BC 001E8E93		add		$t3,$t3,#1					; see if buffer full
FFFC15C0 0FFEFE93		and		$t3,$t3,#255
FFFC15C4 09DE0263		beq		$t2,$t3,.rxFull
FFFC15C8 00026637		stb		$t3,SerTailRcv			; update tail pointer
FFFC15CC 80460613
FFFC15D0 00060633
FFFC15D4 01D60023
FFFC15D8 FFFE8E93		sub		$t3,$t3,#1
FFFC15DC 0FFEFE13		and		$t2,$t3,#255
FFFC15E0 00025637		stb		$a1,SerRcvBuf[$t2]	; store recieved byte in buffer
FFFC15E4 00060613
FFFC15E8 01C60633
FFFC15EC 01360023
FFFC15F0 00026637		ldb		$v0,SerRcvXoff			; check if xoff already sent
FFFC15F4 81160613
FFFC15F8 00060633
FFFC15FC 00060803
FFFC1600 02081A63		bne		$v0,$x0,.0001
FFFC1604 F45FF0EF		call	SerialRcvCount			; if more than 240 chars in buffer
FFFC1608 0F082813		slt		$v0,$v0,#240				; send an XOFF
FFFC160C 02081463		bne		$v0,$x0,.0001
FFFC1610 01306913		ldi		$a0,#XOFF
FFFC1614 00026637		stb		$x0,SerRcvXon				; clear XON status
FFFC1618 81060613
FFFC161C 00060633
FFFC1620 00060023
FFFC1624 00026637		stb		$a0,SerRcvXoff			; set XOFF status
FFFC1628 81160613
FFFC162C 00060633
FFFC1630 01260023
                        		stb		UART+UART_TRB
                        	.0001:
FFFC1634 FFDC1637		ldt		$a0,UART+UART_STAT	; check the status for another byte
FFFC1638 A0460613
FFFC163C 00060633
FFFC1640 00062903
FFFC1644 F40000E3		bra		.nxtByte
                        	;	ldi		$a0,#$0B						; dtr,rts active, rxint disabled, no parity
                        	;	sw		$a0,UART+UART_CMD
                        	.rxFull:
                        	.notRxInt:
FFFC1648 79217073		csrrc	$x0,#$792,#2			; clear IRQ semaphore
FFFC164C 10000073		eret
                        	
                        	nmeSerial:
FFFC1650 69726553		db		"Serial",0
FFFC1654 00006C61
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/via.r5a",1
                        	.file "../fmtk/via.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
FFFC1657 00000000		align	
                        	
                        	ViaFuncTbl:
FFFC1658 00000000		dco		0							; no operation
FFFC165C 00000000
FFFC1660 00000000		dco		0							; setup
FFFC1664 00000000
FFFC1668 00000000		dco		0							; initialize
FFFC166C 00000000
FFFC1670 00000000		dco		0							; status
FFFC1674 00000000
FFFC1678 00000000		dco		0							; media check
FFFC167C 00000000
FFFC1680 00000000		dco		0							; build BPB
FFFC1684 00000000
FFFC1688 00000000		dco		0							; open
FFFC168C 00000000
FFFC1690 00000000		dco		0							; close
FFFC1694 00000000
FFFC1698 00000000		dco		0							; get char
FFFC169C 00000000
FFFC16A0 00000000		dco		0							; Peek char
FFFC16A4 00000000
FFFC16A8 00000000		dco		0							; get char direct
FFFC16AC 00000000
FFFC16B0 00000000		dco		0							; peek char direct
FFFC16B4 00000000
FFFC16B8 00000000		dco		0							; input status
FFFC16BC 00000000
FFFC16C0 00000000		dco		0							; Put char
FFFC16C4 00000000
FFFC16C8 00000000		dco		0							; reserved
FFFC16CC 00000000
FFFC16D0 00000000		dco		0							; set position
FFFC16D4 00000000
FFFC16D8 00000000		dco		0							; read block
FFFC16DC 00000000
FFFC16E0 00000000		dco		0							; write block
FFFC16E4 00000000
FFFC16E8 00000000		dco		0							; verify block
FFFC16EC 00000000
FFFC16F0 00000000		dco		0							; output status
FFFC16F4 00000000
FFFC16F8 00000000		dco		0							; flush input
FFFC16FC 00000000
FFFC1700 00000000		dco		0							; flush output
FFFC1704 00000000
FFFC1708 FFFC17B4		dco		ViaIRQ				; IRQ routine
FFFC170C 00000000
FFFC1710 00000000		dco		0							; Is removable
FFFC1714 00000000
FFFC1718 00000000		dco		0							; ioctrl read
FFFC171C 00000000
FFFC1720 00000000		dco		0							; ioctrl write
FFFC1724 00000000
FFFC1728 00000000		dco		0							; output until busy
FFFC172C 00000000
FFFC1730 00000000		dco		0							; 27
FFFC1734 00000000
FFFC1738 00000000		dco		0
FFFC173C 00000000
FFFC1740 00000000		dco		0
FFFC1744 00000000
FFFC1748 00000000		dco		0
FFFC174C 00000000
FFFC1750 00000000		dco		0							; 31
FFFC1754 00000000
                        	
                        	;------------------------------------------------------------------------------
                        	; ViaInit
                        	;
                        	; Initialize the versatile interface adapter.
                        	;------------------------------------------------------------------------------
                        	
                        	ViaInit:
FFFC1758 FF870713		sub		$sp,$sp,#8
FFFC175C 00173023		sto		$ra,[$sp]
FFFC1760 00F06913		ldi		$a0,#15							; VIA device
FFFC1764 FFFC19B7		ldi		$a1,#ViaFuncTbl
FFFC1768 65898993
FFFC176C 40D010EF		call	CopyDevFuncTbl
                        		; Initialize port A low order eight bits as output, the remaining bits as
                        		; input.
FFFC1770 FFDC0DB7		ldi		$t1,#VIA
FFFC1774 600D8D93
FFFC1778 0FF06D13		ldi		$t0,#$000000FF
FFFC177C 01ADA623		stt		$t0,VIA_DDRA[$t1]
FFFC1780 00106D13		ldi		$t0,#1							; select timer 3 access
FFFC1784 03AD88A3		stb		$t0,VIA_PCR+1[$t1]
FFFC1788 01F06D13		ldi		$t0,#$1F
FFFC178C 03AD86A3		stb		$t0,VIA_ACR+1[$t1]		; set timer 3 mode, timer 1/2 = 64 bit
FFFC1790 0016ED37		ldi		$t0,#$0016E360			;	divider value for 33.333Hz (30 ms)
FFFC1794 360D0D13
FFFC1798 01ADA823		stt		$t0,VIA_T1CL[$t1]
FFFC179C 000DAA23		stt		$x0,VIA_T1CH[$t1]		; trigger transfer to count registers
FFFC17A0 18006D13		ldi		$t0,#$180						; enable timer3 interrupts
FFFC17A4 03ADAC23		stt		$t0,VIA_IER[$t1]
FFFC17A8 00073083		ldo		$ra,[$sp]
FFFC17AC 00870713		add		$sp,$sp,#8
FFFC17B0 00008067		ret
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	ViaIRQ:
                        		; Was it the VIA that caused the interrupt?
FFFC17B4 FFDC0DB7		ldi		$t1,#VIA
FFFC17B8 600D8D93
FFFC17BC 034D8D03		ldb		$t0,VIA_IFR[$t1]
FFFC17C0 040D5463		bge		$t0,$x0,.0003				; no
FFFC17C4 00106D13		ldi		$t0,#1							; select timer 3 access
FFFC17C8 03AD88A3		stb		$t0,VIA_PCR+1[$t1]
FFFC17CC 010DAD03		ldt		$t0,VIA_T1CL[$t1]		; yes, clear interrupt
FFFC17D0 00014637		ldo		$t0,milliseconds
FFFC17D4 20860613
FFFC17D8 00060633
FFFC17DC 00063D03
FFFC17E0 01ED0D13		add		$t0,$t0,#30
FFFC17E4 00014637		sto		$t0,milliseconds
FFFC17E8 20860613
FFFC17EC 00060633
FFFC17F0 01A63023
FFFC17F4 00014637		stt		$t0,switchflag
FFFC17F8 20060613
FFFC17FC 00060633
FFFC1800 01A62023
FFFC1804 3F9000EF		call	FMTK_SchedulerIRQ
                        	.0003:
FFFC1808 79217073		csrrc	$x0,#$792,#2			; clear IRQ semaphore
FFFC180C 10000073		eret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/video.r5a",1
                        	.file "../fmtk/video.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	TC64CursorAddr	equ		$FFD1DF1C
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
                        		align	8                        	
                        	VideoFuncTbl:
FFFC1810 00000000		dco		0							; no operation
FFFC1814 00000000
FFFC1818 00000000		dco		0							; setup
FFFC181C 00000000
FFFC1820 00000000		dco		0							; initialize
FFFC1824 00000000
FFFC1828 00000000		dco		0							; status
FFFC182C 00000000
FFFC1830 00000000		dco		0							; media check
FFFC1834 00000000
FFFC1838 00000000		dco		0							; build BPB
FFFC183C 00000000
FFFC1840 00000000		dco		0							; open
FFFC1844 00000000
FFFC1848 00000000		dco		0							; close
FFFC184C 00000000
FFFC1850 00000000		dco		0							; get char
FFFC1854 00000000
FFFC1858 00000000		dco		0							; Peek char
FFFC185C 00000000
FFFC1860 00000000		dco		0							; get char direct
FFFC1864 00000000
FFFC1868 00000000		dco		0							; peek char direct
FFFC186C 00000000
FFFC1870 00000000		dco		0							; input status
FFFC1874 00000000
FFFC1878 FFFC1A2C		dco		VideoPutChar	; Put char
FFFC187C 00000000
FFFC1880 00000000		dco		0							; reserved
FFFC1884 00000000
FFFC1888 00000000		dco		0							; set position
FFFC188C 00000000
FFFC1890 00000000		dco		0							; read block
FFFC1894 00000000
FFFC1898 00000000		dco		0							; write block
FFFC189C 00000000
FFFC18A0 00000000		dco		0							; verify block
FFFC18A4 00000000
FFFC18A8 00000000		dco		0							; output status
FFFC18AC 00000000
FFFC18B0 00000000		dco		0							; flush input
FFFC18B4 00000000
FFFC18B8 00000000		dco		0							; flush output
FFFC18BC 00000000
FFFC18C0 FFFC1D00		dco		VideoIRQ			; IRQ routine
FFFC18C4 00000000
FFFC18C8 00000000		dco		0							; Is removable
FFFC18CC 00000000
FFFC18D0 00000000		dco		0							; ioctrl read
FFFC18D4 00000000
FFFC18D8 00000000		dco		0							; ioctrl write
FFFC18DC 00000000
FFFC18E0 00000000		dco		0							; output until busy
FFFC18E4 00000000
FFFC18E8 00000000		dco		0							; 27
FFFC18EC 00000000
FFFC18F0 00000000		dco		0
FFFC18F4 00000000
FFFC18F8 00000000		dco		0
FFFC18FC 00000000
FFFC1900 00000000		dco		0
FFFC1904 00000000
FFFC1908 00000000		dco		0							; 31
FFFC190C 00000000
                        	
                        	;------------------------------------------------------------------------------
                        	; VideoInit
                        	;
                        	; Initialize the versatile interface adapter.
                        	;------------------------------------------------------------------------------
                        	
                        	VideoInit:
FFFC1910 FF870713		sub		$sp,$sp,#8
FFFC1914 00173023		sto		$ra,[$sp]
FFFC1918 00206913		ldi		$a0,#2							; Video device
FFFC191C FFFC29B7		ldi		$a1,#VideoFuncTbl
FFFC1920 81098993
FFFC1924 255010EF		call	CopyDevFuncTbl
FFFC1928 00025637		stb		$x0,CursorX
FFFC192C 80060613
FFFC1930 00060633
FFFC1934 00060023
FFFC1938 00025637		stb		$x0,CursorY
FFFC193C 80160613
FFFC1940 00060633
FFFC1944 00060023
FFFC1948 000F0D37		ldi		$t0,#$000F0000
FFFC194C 000D0D13
FFFC1950 00025637		stt		$t0,DispAttr
FFFC1954 80860613
FFFC1958 00060633
FFFC195C 01A62023
FFFC1960 00210D37		ldi		$t0,#$0020FFFF
FFFC1964 FFFD0D13
FFFC1968 00025637		stt		$t0,DispAttr+4
FFFC196C 80C60613
FFFC1970 00060633
FFFC1974 01A62023
FFFC1978 010000EF		call	VideoClearScreen
FFFC197C 00073083		ldo		$ra,[$sp]
FFFC1980 00870713		add		$sp,$sp,#8
FFFC1984 00008067		ret
                        	
                        	VideoClearScreen:
                        	;	csrrs	$x0,#$300,#1				; interrupts on
FFFC1988 65806D13		ldi		$t0,#56*29
FFFC198C 00025637		ldo		$t1,DispAttr
FFFC1990 80860613
FFFC1994 00060633
FFFC1998 00063D83
FFFC199C 020DED93		or		$t1,$t1,#' '
                        		
                        		
FFFC19A0 18101873		csrrw	v0,#$181,x0
FFFC19A4 03F87813		and		v0,v0,#MAX_TID
FFFC19A8 00A81813	sll		$v0,$v0,#LOG_TCBSZ
FFFC19AC 33883803		ldo		$v0,TCBpVideo[$v0]
FFFC19B0 FFD00837		ldi		$v0,#$FFD00000
FFFC19B4 00080813
                        	.0001:
FFFC19B8 01B83023		sto		$t1,[$v0]	
FFFC19BC 00880813		add		$v0,$v0,#8
FFFC19C0 FFFD0D13		sub		$t0,$t0,#1
FFFC19C4 FFA04AE3		bgt		$t0,$x0,.0001
FFFC19C8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	VideoHomeCursor:
FFFC19CC 00025637		stb		$x0,CursorX
FFFC19D0 80060613
FFFC19D4 00060633
FFFC19D8 00060023
FFFC19DC 00025637		stb		$x0,CursorY
FFFC19E0 80160613
FFFC19E4 00060633
FFFC19E8 00060023
                        		; fall through into update cursor pos.
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	UpdateCursorPos:
FFFC19EC 00025637		ldbu	$t0,CursorY
FFFC19F0 80160613
FFFC19F4 00060633
FFFC19F8 00064D03
FFFC19FC 03806D93		ldi		$t1,#56
FFFC1A00 03BD0D33		mul		$t0,$t0,$t1
FFFC1A04 00025637		ldbu	$t1,CursorX
FFFC1A08 80060613
FFFC1A0C 00060633
FFFC1A10 00064D83
FFFC1A14 01BD0D33		add		$t0,$t0,$t1
FFFC1A18 FFD1E637		stw		$t0,TC64CursorAddr
FFFC1A1C F1C60613
FFFC1A20 00060633
FFFC1A24 01A61023
FFFC1A28 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a3 = character to display
                        	;------------------------------------------------------------------------------
                        	
                        	VideoPutChar:
FFFC1A2C FF070713		sub		$sp,$sp,#16
FFFC1A30 00173023		sto		$ra,[$sp]
FFFC1A34 00473423		sto		$s1,8[$sp]
FFFC1A38 00D06D13		ldi		$t0,#CR
FFFC1A3C 75AA8963		beq		$a3,$t0,.doCR
FFFC1A40 00A06D13		ldi		$t0,#$0A				; line feed
FFFC1A44 75AA8563		beq		$a3,$t0,.doLF
FFFC1A48 00C06D13		ldi		$t0,#$0C				; CTRL-L
FFFC1A4C 75AA8263		beq		$a3,$t0,.doCls
FFFC1A50 09106D13		ldi		$t0,#$91
FFFC1A54 73AA8E63		beq		$a3,$t0,.cursorRight
FFFC1A58 09306D13		ldi		$t0,#$93
FFFC1A5C 73AA8B63		beq		$a3,$t0,.cursorLeft
FFFC1A60 09006D13		ldi		$t0,#$90
FFFC1A64 73AA8763		beq		$a3,$t0,.cursorUp
FFFC1A68 09206D13		ldi		$t0,#$92
FFFC1A6C 73AA8463		beq		$a3,$t0,.cursorDown
FFFC1A70 00806D13		ldi		$t0,#BS
FFFC1A74 73AA8063		beq		$a3,$t0,.backspace
FFFC1A78 09906D13		ldi		$t0,#$99
FFFC1A7C 71AA8D63		beq		$a3,$t0,.delete
                        		mGetVideoPtr
FFFC1A80 00086D33		mov		$t0,$v0
FFFC1A84 00025637		ldbu	$t1,CursorX
FFFC1A88 80060613
FFFC1A8C 00060633
FFFC1A90 00064D83
FFFC1A94 003D9D93		sll		$t1,$t1,#3						; *8 bytes per display cell
FFFC1A98 01BD6D33		or		$t0,$t0,$t1						; add in base address
FFFC1A9C 00025637		ldbu	$t1,CursorY
FFFC1AA0 80160613
FFFC1AA4 00060633
FFFC1AA8 00064D83
FFFC1AAC 1C006E13		ldi		$t2,#56*8
FFFC1AB0 03CD8DB3		mul		$t1,$t1,$t2
FFFC1AB4 01BD0D33		add		$t0,$t0,$t1
FFFC1AB8 00025637		ldo		$t1,DispAttr
FFFC1ABC 80860613
FFFC1AC0 00060633
FFFC1AC4 00063D83
FFFC1AC8 015DEDB3		or		$t1,$t1,$a3
FFFC1ACC 01BD3023		sto		$t1,[$t0]							; store to screen memory
FFFC1AD0 00025637		ldbu	$t0,CursorX						; increment cursor position
FFFC1AD4 80060613
FFFC1AD8 00060633
FFFC1ADC 00064D03
FFFC1AE0 001D0D13		add		$t0,$t0,#1
FFFC1AE4 03806D93		ldi		$t1,#56
FFFC1AE8 07BD4263		blt		$t0,$t1,.saveX
FFFC1AEC 00006D13		ldi		$t0,#0
                        	.doLF1:
FFFC1AF0 00025637		ldbu	$t2,CursorY
FFFC1AF4 80160613
FFFC1AF8 00060633
FFFC1AFC 00064E03
FFFC1B00 001E0E13		add		$t2,$t2,#1
FFFC1B04 01D06D93		ldi		$t1,#29
FFFC1B08 03BE4A63		blt		$t2,$t1,.saveY
                        		; scroll up
FFFC1B0C 65806E93		ldi		$t3,#56*29
FFFC1B10 FFD00F37		ldi		$t4,#$FFD00000
FFFC1B14 000F0F13
                        	.0001:
FFFC1B18 1C0F3F83		ldo		$t5,56*8[$t4]
FFFC1B1C 01FF3023		sto		$t5,[$t4]
FFFC1B20 008F0F13		add		$t4,$t4,#8
FFFC1B24 FFFE8E93		sub		$t3,$t3,#1
FFFC1B28 FFD048E3		bgt		$t3,$x0,.0001
                        	.xit:
FFFC1B2C 00073083		ldo		$ra,[$sp]
FFFC1B30 00873203		ldo		$s1,8[$sp]
FFFC1B34 01070713		add		$sp,$sp,#16
FFFC1B38 00008067		ret
                        	.saveY:
FFFC1B3C 00025637		stb		$t2,CursorY
FFFC1B40 80160613
FFFC1B44 00060633
FFFC1B48 01C60023
                        	.saveX:
FFFC1B4C 00025637		stb		$t0,CursorX
FFFC1B50 80060613
FFFC1B54 00060633
FFFC1B58 01A60023
FFFC1B5C E91FF0EF		call	UpdateCursorPos
FFFC1B60 FC0006E3		bra		.xit
                        	.doCR:
FFFC1B64 00025637		stb		$x0,CursorX
FFFC1B68 80060613
FFFC1B6C 00060633
FFFC1B70 00060023
FFFC1B74 E79FF0EF		call	UpdateCursorPos
FFFC1B78 FA000AE3		bra		.xit
                        	.doLF:
FFFC1B7C 00025637		ldbu	$t0,CursorX
FFFC1B80 80060613
FFFC1B84 00060633
FFFC1B88 00064D03
FFFC1B8C F60002E3		bra		.doLF1
                        	.cursorRight:
FFFC1B90 00025637		ldbu	$t0,CursorX
FFFC1B94 80060613
FFFC1B98 00060633
FFFC1B9C 00064D03
FFFC1BA0 001D0D13		add		$t0,$t0,#1
FFFC1BA4 03706D93		ldi		$t1,#55
FFFC1BA8 01BD5C63		bge		$t0,$t1,.cr1
FFFC1BAC 00025637		stb		$t0,CursorX
FFFC1BB0 80060613
FFFC1BB4 00060633
FFFC1BB8 01A60023
                        	.cr2:
FFFC1BBC E31FF0EF		call	UpdateCursorPos
                        	.cr1:
FFFC1BC0 F60006E3		bra		.xit
                        	.cursorLeft:
FFFC1BC4 00025637		ldbu	$t0,CursorX
FFFC1BC8 80060613
FFFC1BCC 00060633
FFFC1BD0 00064D03
FFFC1BD4 FFFD0D13		sub		$t0,$t0,#1
FFFC1BD8 FE0D44E3		blt		$t0,$x0,.cr1
FFFC1BDC 00025637		stb		$t0,CursorX
FFFC1BE0 80060613
FFFC1BE4 00060633
FFFC1BE8 01A60023
FFFC1BEC FC0008E3		bra		.cr2
                        	.cursorUp:
FFFC1BF0 00025637		ldbu	$t0,CursorY
FFFC1BF4 80160613
FFFC1BF8 00060633
FFFC1BFC 00064D03
FFFC1C00 FFFD0D13		sub		$t0,$t0,#1
FFFC1C04 FA0D4EE3		blt		$t0,$x0,.cr1
FFFC1C08 00025637		stb		$t0,CursorY
FFFC1C0C 80160613
FFFC1C10 00060633
FFFC1C14 01A60023
FFFC1C18 FA0002E3		bra		.cr2
                        	.cursorDown:
FFFC1C1C 00025637		ldbu	$t0,CursorY
FFFC1C20 80160613
FFFC1C24 00060633
FFFC1C28 00064D03
FFFC1C2C 001D0D13		add		$t0,$t0,#1
FFFC1C30 01D06D93		ldi		$t1,#29
FFFC1C34 F9BD56E3		bge		$t0,$t1,.cr1
FFFC1C38 00025637		stb		$t0,CursorY
FFFC1C3C 80160613
FFFC1C40 00060633
FFFC1C44 01A60023
FFFC1C48 F6000AE3		bra		.cr2
                        	.doCls:
FFFC1C4C D3DFF0EF		call	VideoClearScreen
FFFC1C50 D7DFF0EF		call	VideoHomeCursor
FFFC1C54 F60006E3		bra		.cr1
                        	.backspace:
FFFC1C58 00025637		ldbu	$t0,CursorX
FFFC1C5C 80060613
FFFC1C60 00060633
FFFC1C64 00064D03
FFFC1C68 F40D0CE3		beqz	$t0,.cr1
FFFC1C6C FFFD0D13		sub		$t0,$t0,#1
FFFC1C70 00025637		stb		$t0,CursorX
FFFC1C74 80060613
FFFC1C78 00060633
FFFC1C7C 01A60023
                        	.del0001:
FFFC1C80 03706213		ldi		$s1,#55
FFFC1C84 41A20233		sub		$s1,$s1,$t0
FFFC1C88 D65FF0EF		call	UpdateCursorPos
FFFC1C8C 00025637		ldbu	$t1,CursorY
FFFC1C90 80160613
FFFC1C94 00060633
FFFC1C98 00064D83
FFFC1C9C 1C006E93		ldi		$t3,#56*8
FFFC1CA0 03DD8DB3		mul		$t1,$t1,$t3
FFFC1CA4 003D1D13		sll		$t0,$t0,#3
FFFC1CA8 01AD8EB3		add		$t3,$t1,$t0
FFFC1CAC FFD00637		add		$t3,$t3,#$FFD00000
FFFC1CB0 00060613
FFFC1CB4 01D60EB3
FFFC1CB8 00020C63		beqz	$s1,.bs0001
                        	.bs0002:
FFFC1CBC 008EBF03		ldo		$t4,8[$t3]
FFFC1CC0 01EEB023		sto		$t4,[$t3]
FFFC1CC4 008E8E93		add		$t3,$t3,#8
FFFC1CC8 FFF20213		sub		$s1,$s1,#1
FFFC1CCC FFFFC8E3		bgt		$s1,.bs0002
                        	.bs0001:
FFFC1CD0 00025637		ldo		$t4,DispAttr
FFFC1CD4 80860613
FFFC1CD8 00060633
FFFC1CDC 00063F03
FFFC1CE0 020F6F13		or		$t4,$t4,#' '
FFFC1CE4 01EEB423		sto		$t4,8[$t3]
FFFC1CE8 E40002E3		bra		.xit
                        	.delete:
FFFC1CEC 00025637		ldbu	$t0,CursorX
FFFC1CF0 80060613
FFFC1CF4 00060633
FFFC1CF8 00064D03
FFFC1CFC F80002E3		bra		.del0001	
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	VideoIRQ:
                        		; Was it the Video that caused the interrupt?
                        	.0003:
FFFC1D00 10000073		eret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/task.r5a",1
                        	.file "../fmtk/task.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../fmtk/task.r5a",25
                        		code
                        		align	2                        	
                        	OSCallTbl:
FFFC1D04 25B801AD		dh		FMTK_Initialize					; 0
FFFC1D06 26A825B8		dh		FMTK_StartTask					; 1
FFFC1D08 26D426A8		dh		FMTK_ExitTask
FFFC1D0A 01B126D4		dh		FMTK_KillTask
FFFC1D0C 22F401B1		dh		FMTK_SetTaskPriority
FFFC1D0E 27D822F4		dh		FMTK_Sleep							; 5
FFFC1D10 284C27D8		dh		FMTK_AllocMbx
FFFC1D12 01B5284C		dh		FMTK_FreeMbx
FFFC1D14 28DC01B5		dh		FMTK_PostMsg
FFFC1D16 2ABC28DC		dh		FMTK_SendMsg
FFFC1D18 29EC2ABC		dh		FMTK_WaitMsg						; 10
FFFC1D1A 01B929EC		dh		FMTK_PeekMsg
FFFC1D1C 1F4801B9		dh		FMTK_StartApp
FFFC1D1E 1E941F48		dh		FMTK_SaveContext				; 13
FFFC1D20 2ECC1E94		dh		FMTK_GetCurrentTid
FFFC1D22 00002ECC		dh		DumpReadyList
FFFC1D24 00000000		dh		0
FFFC1D26 00000000		dh		0
FFFC1D28 00000000		dh		0
FFFC1D2A 30BC0000		dh		0
FFFC1D2C 311C30BC		dh		FMTK_HasIOFocus					; 20
FFFC1D2E 326C311C		dh		FMTK_SwitchIOFocus			; 21
FFFC1D30 3278326C		dh		FMTK_ReleaseIOFocus			; 22
FFFC1D32 31E03278		dh		FMTK_ForceReleaseIOFocus	; 23
FFFC1D34 000031E0		dh		FMTK_RequestIOFocus			; 24
FFFC1D36 33300000		dh		0
FFFC1D38 00003330		dh		FMTK_IO									; 26
                        	
                        	qToChk:
FFFC1D3A 02000000		db	0,0,0,2,0,0,4,2
FFFC1D3E 02040000
FFFC1D42 02060000		db	0,0,6,2,0,0,4,2
FFFC1D46 02040000
FFFC1D4A 02000000		db	0,0,0,2,0,0,4,2
FFFC1D4E 02040000
FFFC1D52 02060000		db	0,0,6,2,0,0,4,2
FFFC1D56 02040000
                        	
FFFC1D5A 46370000		align	
                        	
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FMTKInit:
FFFC1D5C 00024637		stt		$x0,QNDX
FFFC1D60 30460613
FFFC1D64 00060633
FFFC1D68 00062023
FFFC1D6C 00024637		sto		$x0,PIDMAP
FFFC1D70 31060613
FFFC1D74 00060633
FFFC1D78 00063023
FFFC1D7C 00024637		stt		$x0,missed_ticks
FFFC1D80 32060613
FFFC1D84 00060633
FFFC1D88 00062023
FFFC1D8C FFF06D13		ldi		$t0,#-1
FFFC1D90 00024637		stt		$t0,TimeoutList
FFFC1D94 32860613
FFFC1D98 00060633
FFFC1D9C 01A62023
FFFC1DA0 00024637		stt		$t0,READYQ
FFFC1DA4 30860613
FFFC1DA8 00060633
FFFC1DAC 01A62023
FFFC1DB0 00024637		stt		$t0,READYQ+4
FFFC1DB4 30C60613
FFFC1DB8 00060633
FFFC1DBC 01A62023
FFFC1DC0 00025637		stw		$t0,hKeybdMbx
FFFC1DC4 82260613
FFFC1DC8 00060633
FFFC1DCC 01A61023
                        	
FFFC1DD0 00025637		stb		$x0,SwitchIOFocus	
FFFC1DD4 82060613
FFFC1DD8 00060633
FFFC1DDC 00060023
FFFC1DE0 00025637		stt		$x0,IOFocusTbl
FFFC1DE4 81860613
FFFC1DE8 00060633
FFFC1DEC 00062023
FFFC1DF0 00025637		stt		$t0,IOFocusNdx
FFFC1DF4 81060613
FFFC1DF8 00060633
FFFC1DFC 01A62023
                        	
                        		; zero out device function table
FFFC1E00 00022D37		ldi		$t0,#DVF_Base
FFFC1E04 000D0D13
FFFC1E08 40006D93		ldi		$t1,#32*32
                        	.0003:
FFFC1E0C 000D3023		sto		$x0,[$t0]
FFFC1E10 008D0D13		add		$t0,$t0,#8
FFFC1E14 FFFD8D93		sub		$t1,$t1,#1
FFFC1E18 FFB04AE3		bgt		$t1,$x0,.0003
                        	
                        		; Initialize mailboxes
FFFC1E1C 00020D37		ldi		$t0,#mbxs
FFFC1E20 000D0D13
FFFC1E24 08006D93		ldi		$t1,#4*32
                        	.0001:
FFFC1E28 000D3023		sto		$x0,[$t0]
FFFC1E2C 008D0D13		add		$t0,$t0,#8
FFFC1E30 FFFD8D93		sub		$t1,$t1,#1
FFFC1E34 FFB04AE3		bgt		$t1,$x0,.0001
                        	
                        		; Initialize free message list
FFFC1E38 00010D37		ldi		$t0,#msgs
FFFC1E3C 000D0D13
FFFC1E40 00024637		sto		$t0,FreeMsg
FFFC1E44 35060613
FFFC1E48 00060633
FFFC1E4C 01A63023
FFFC1E50 00006D93		ldi		$t1,#0
FFFC1E54 00001E37		ldi		$t2,#NR_MSG
FFFC1E58 800E0E13
                        	.0002:
FFFC1E5C 001D8D93		add		$t1,$t1,#1
FFFC1E60 01BD3023		sto		$t1,MSG_LINK[$t0]
FFFC1E64 020D0D13		add		$t0,$t0,#32
FFFC1E68 FFFE0E13		sub		$t2,$t2,#1
FFFC1E6C FFC048E3		bgt		$t2,$x0,.0002
                        	
                        		; unlock the system semaphore	
                        		
FFFC1E70 FFF06813		ldi		v0,#-1
FFFC1E74 00024637		sw		v0,SysSema
FFFC1E78 34060613
FFFC1E7C 00060633
FFFC1E80 01062023
                        	
FFFC1E84 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Get the task id for the currently running task.
                        	;
                        	; Returns:
                        	;		v0 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	GetCurrentTid:
FFFC1E88 18101873		csrrw	$v0,#$181,$x0				; get current pid
FFFC1E8C 03F87813		and		$v0,$v0,#MAX_TID		; mask off extra bits
FFFC1E90 00008067		ret
                        	
                        	FMTK_GetCurrentTid:
FFFC1E94 3000E073		csrrs	$x0,#$300,#1				; enable ints
                        		
FFFC1E98 18101873		csrrw	v0,#$181,x0
FFFC1E9C 03F87813		and		v0,v0,#MAX_TID
FFFC1EA0 000868B3	mov		$v1,$v0
FFFC1EA4 00006813		ldi		$v0,#E_Ok
FFFC1EA8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	MapOSPages:
FFFC1EAC 00306813		ldi			$v0,#OSPAGES	; number of pages pre-mapped
FFFC1EB0 00006893		ldi			$v1,#0
FFFC1EB4 01091893		sll			$v1,$a0,#16		; put ASID in proper spot
                        	.nxt:
FFFC1EB8 0318800D		mvmap		$x0,$v1,$v1
FFFC1EBC 00188893		add			$v1,$v1,#1
FFFC1EC0 FFF80813		sub			$v0,$v0,#1
FFFC1EC4 FF004AE3		bgt			$v0,$x0,.nxt
FFFC1EC8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Select the next task to run. The ready lists are searched in a circular
                        	; fashion beginning with the list identified indirectly by QNDX. There are
                        	; four ready lists to hold tasks of four different priorities. 
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		v1, t0, t1, t2, t3, t4
                        	;	Returns:
                        	;		v0 = task id of task to run
                        	;------------------------------------------------------------------------------
                        	
                        	SelectTaskToRun:
                        		; Pick the first queue to check, occasionally the queue
                        		; chosen isn't the highest priority one in order to 
                        		; prevent starvation of lower priority tasks.
                        	.searchQ:
FFFC1ECC 3000F073		csrrc	$x0,#$300,#1				; interrupts off
FFFC1ED0 00024637		ldbu	$v1,QNDX						; get index into que check table
FFFC1ED4 30460613
FFFC1ED8 00060633
FFFC1EDC 00064883
FFFC1EE0 00188893		add		$v1,$v1,#1					; increment it, and limit
FFFC1EE4 01F8F893		and		$v1,$v1,#31
FFFC1EE8 00024637		stb		$v1,QNDX						; store back
FFFC1EEC 30460613
FFFC1EF0 00060633
FFFC1EF4 01160023
FFFC1EF8 FFFC2637		ldbu	$v1,qToChk[$v1]			; assume this will be valid
FFFC1EFC D3A60613
FFFC1F00 01160633
FFFC1F04 00064883
FFFC1F08 00406E13		ldi		$t2,#4							; 4 queues to check
                        	.nxtQ:
FFFC1F0C 1C08880D		getrdy	$v0,$v1
;	ldw		$v0,READYQ[$v1]			; check queue to see if contains any
FFFC1F10 02085663		bge		$v0,$x0,.dq					; yes, go dequeue
                        	.0001:
FFFC1F14 00188893		add		$v1,$v1,#1					; no, advance to next queue
FFFC1F18 0038F893		and		$v1,$v1,#3					; 4 max
FFFC1F1C FFFE0E13		sub		$t2,$t2,#1					;
FFFC1F20 FFC046E3		bgt		$t2,$x0,.nxtQ				; go back to check next queue
                        		; Here, nothing else is actually ready to run
FFFC1F24 3000E073		csrrs	$x0,#$300,#1				; interrupts on
FFFC1F28 10100073		wfi
FFFC1F2C FA0000E3		bra		.searchQ
                        		; just go back to what we were doing.
                        		
FFFC1F30 18101873		csrrw	v0,#$181,x0
FFFC1F34 03F87813		and		v0,v0,#MAX_TID
FFFC1F38 00008067	ret
                        	.dq:
                        	;	ldi		$t3,#MAX_TID				; ensure we have a valid tid
                        	;	bleu	$v0,$t3,.goodTid
                        		; If the tid isn't valid the readyq was screwed up
                        	;	ldi		$t3,#-1							; indicate queue empty
                        	;	stw		$t3,READYQ[$v1]
                        	;	bra		.0001								; and try next queue
                        	.goodTid:
FFFC1F3C 3000E073		csrrs	$x0,#$300,#1				; interrupts on
FFFC1F40 18181073		csrrw	$x0,#$181,$v0
                        		;sll		$t1,$v0,#LOG_TCBSZ
                        		;ldw		$t0,TCBNext[$t1]		; update head of ready queue
                        		;stw		$t0,READYQ[$v1]
FFFC1F44 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_SaveContext:
                        		
FFFC1F48 18101873		csrrw	v0,#$181,x0
FFFC1F4C 03F87813		and		v0,v0,#MAX_TID
FFFC1F50 00A81213	sll		$s1,$v0,#LOG_TCBSZ
                        	SaveContext:
FFFC1F54 28A20D03		ldb		$t0,TCBContextSaved[$s1]
FFFC1F58 0A0D1C63		bnez	$t0,.xit
                        		; Save outgoing register set in TCB
FFFC1F5C 79027073		csrrc	$x0,#CSR_REGSET,#4	; select previous (user) register set for Rs2
FFFC1F60 00123423		sto		$x1,8[$s1]
FFFC1F64 00223823		sto		$x2,16[$s1]
FFFC1F68 00323C23		sto		$x3,24[$s1]
FFFC1F6C 02423023		sto		$x4,32[$s1]
FFFC1F70 02523423		sto		$x5,40[$s1]
FFFC1F74 02623823		sto		$x6,48[$s1]
FFFC1F78 02723C23		sto		$x7,56[$s1]
FFFC1F7C 04823023		sto		$x8,64[$s1]
FFFC1F80 04923423		sto		$x9,72[$s1]
FFFC1F84 04A23823		sto		$x10,80[$s1]
FFFC1F88 04B23C23		sto		$x11,88[$s1]
FFFC1F8C 06C23023		sto		$x12,96[$s1]
FFFC1F90 06D23423		sto		$x13,104[$s1]
FFFC1F94 06E23823		sto		$x14,112[$s1]
FFFC1F98 06F23C23		sto		$x15,120[$s1]
FFFC1F9C 09023023		sto		$x16,128[$s1]
FFFC1FA0 09123423		sto		$x17,136[$s1]
FFFC1FA4 09223823		sto		$x18,144[$s1]
FFFC1FA8 09323C23		sto		$x19,152[$s1]
FFFC1FAC 0B423023		sto		$x20,160[$s1]
FFFC1FB0 0B523423		sto		$x21,168[$s1]
FFFC1FB4 0B623823		sto		$x22,176[$s1]
FFFC1FB8 0B723C23		sto		$x23,184[$s1]
FFFC1FBC 0D823023		sto		$x24,192[$s1]
FFFC1FC0 0D923423		sto		$x25,200[$s1]
FFFC1FC4 0DA23823		sto		$x26,208[$s1]
FFFC1FC8 0DB23C23		sto		$x27,216[$s1]
FFFC1FCC 0FC23023		sto		$x28,224[$s1]
FFFC1FD0 0FD23423		sto		$x29,232[$s1]
FFFC1FD4 0FE23823		sto		$x30,240[$s1]
FFFC1FD8 0FF23C23		sto		$x31,248[$s1]
FFFC1FDC 79026073		csrrs	$x0,#CSR_REGSET,#4				; select current register set for Rs2
FFFC1FE0 34101173		csrrw	$x2,#$341,$x0				; save off mepc
FFFC1FE4 28223023		sto		$x2,TCBepc[$s1]
                        		; Now save off segment registers
FFFC1FE8 00006D93		ldi		$t1,#0
                        	.svseg:
FFFC1FEC 01B00D0D		mvseg	$t0,$x0,$t1
FFFC1FF0 003D9113		sll		$x2,$t1,#3
FFFC1FF4 00410133		add		$x2,$x2,$s1
FFFC1FF8 21A13023		sto		$t0,TCBsegs[$x2]
FFFC1FFC 001D8D93		add		$t1,$t1,#1
FFFC2000 00FDFD93		and		$t1,$t1,#15
FFFC2004 FE0D94E3		bne		$t1,$x0,.svseg
FFFC2008 00106D13		ldi		$t0,#1
FFFC200C 29A20523		stb		$t0,TCBContextSaved[$s1]
                        	.xit:
FFFC2010 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	RestoreContext:
                        		; Switch memory maps
FFFC2014 00A2D813		srl		$v0,$s2,#10					; convert pointer to tid
FFFC2018 03F87813		and		$v0,$v0,#$3F				; mask to 64 task
FFFC201C 181818F3		csrrw	$v1,#$181,$v0				; set ASID
                        	
                        		; Restore segment register set
FFFC2020 00006D93		ldi		$t1,#0
                        	.rsseg:
FFFC2024 003D9113		sll		$x2,$t1,#3
FFFC2028 00510133		add		$x2,$x2,$s2
FFFC202C 20013D03		ldo		$t0,TCBsegs[$x2]
FFFC2030 01BD000D		mvseg	$x0,$t0,$t1
FFFC2034 001D8D93		add		$t1,$t1,#1
FFFC2038 00FDFD93		and		$t1,$t1,#15
FFFC203C FE0D94E3		bne		$t1,$x0,.rsseg
                        	
FFFC2040 2802B103		ldo		$x2,TCBepc[$s2]			; restore epc
FFFC2044 34111073		csrrw	$x0,#$341,$x2
                        		; Restore incoming registers
FFFC2048 7900F073		csrrc	$x0,#CSR_REGSET,#1				; select previous regset for Rd
FFFC204C 0082B083		ldo		$x1,8[$s2]
FFFC2050 0102B103		ldo		$x2,16[$s2]
FFFC2054 0182B183		ldo		$x3,24[$s2]
FFFC2058 0202B203		ldo		$x4,32[$s2]
FFFC205C 0282B283		ldo		$x5,40[$s2]
FFFC2060 0302B303		ldo		$x6,48[$s2]
FFFC2064 0382B383		ldo		$x7,56[$s2]
FFFC2068 0402B403		ldo		$x8,64[$s2]
FFFC206C 0482B483		ldo		$x9,72[$s2]
FFFC2070 0502B503		ldo		$x10,80[$s2]
FFFC2074 0582B583		ldo		$x11,88[$s2]
FFFC2078 0602B603		ldo		$x12,96[$s2]
FFFC207C 0682B683		ldo		$x13,104[$s2]
FFFC2080 0702B703		ldo		$x14,112[$s2]
FFFC2084 0782B783		ldo		$x15,120[$s2]
FFFC2088 0802B803		ldo		$x16,128[$s2]
FFFC208C 0882B883		ldo		$x17,136[$s2]
FFFC2090 0902B903		ldo		$x18,144[$s2]
FFFC2094 0982B983		ldo		$x19,152[$s2]
FFFC2098 0A02BA03		ldo		$x20,160[$s2]
FFFC209C 0A82BA83		ldo		$x21,168[$s2]
FFFC20A0 0B02BB03		ldo		$x22,176[$s2]
FFFC20A4 0B82BB83		ldo		$x23,184[$s2]
FFFC20A8 0C02BC03		ldo		$x24,192[$s2]
FFFC20AC 0C82BC83		ldo		$x25,200[$s2]
FFFC20B0 0D02BD03		ldo		$x26,208[$s2]
FFFC20B4 0D82BD83		ldo		$x27,216[$s2]
FFFC20B8 0E02BE03		ldo		$x28,224[$s2]
FFFC20BC 0E82BE83		ldo		$x29,232[$s2]
FFFC20C0 0F02BF03		ldo		$x30,240[$s2]
FFFC20C4 0F82BF83		ldo		$x31,248[$s2]
FFFC20C8 7900E073		csrrs	$x0,#CSR_REGSET,#1				; select current regset for Rd
FFFC20CC 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Swap from outgoing context to incoming context.
                        	;
                        	; Parameters:
                        	;		s1 = pointer to TCB of outgoing context
                        	;		s2 = pointer to TCB of incoming context
                        	;------------------------------------------------------------------------------
                        	
                        	SwapContext:
FFFC20D0 16520E63		beq		$s1,$s2,.noCtxSwitch@
FFFC20D4 3000FE73		csrrc	$t2,#$300,#1							; interrupts off
FFFC20D8 79001873		csrrw	$v0,#CSR_REGSET,$x0				; get register set
FFFC20DC F3F87893		and		$v1,$v0,#$FFFFFF3F				; set previous to user regset
FFFC20E0 79089073		csrrw	$x0,#CSR_REGSET,$v1	
FFFC20E4 28A20883		ldb		$v1,TCBContextSaved[$s1]
FFFC20E8 0A089863		bnez	$v1,.savedAlready
                        		; Save outgoing register set in TCB
FFFC20EC 79027073		csrrc	$x0,#CSR_REGSET,#4				; select previous (user) register set for Rs2
FFFC20F0 00123423		sto		$x1,8[$s1]
FFFC20F4 00223823		sto		$x2,16[$s1]
FFFC20F8 00323C23		sto		$x3,24[$s1]
FFFC20FC 02423023		sto		$x4,32[$s1]
FFFC2100 02523423		sto		$x5,40[$s1]
FFFC2104 02623823		sto		$x6,48[$s1]
FFFC2108 02723C23		sto		$x7,56[$s1]
FFFC210C 04823023		sto		$x8,64[$s1]
FFFC2110 04923423		sto		$x9,72[$s1]
FFFC2114 04A23823		sto		$x10,80[$s1]
FFFC2118 04B23C23		sto		$x11,88[$s1]
FFFC211C 06C23023		sto		$x12,96[$s1]
FFFC2120 06D23423		sto		$x13,104[$s1]
FFFC2124 06E23823		sto		$x14,112[$s1]
FFFC2128 06F23C23		sto		$x15,120[$s1]
FFFC212C 09023023		sto		$x16,128[$s1]
FFFC2130 09123423		sto		$x17,136[$s1]
FFFC2134 09223823		sto		$x18,144[$s1]
FFFC2138 09323C23		sto		$x19,152[$s1]
FFFC213C 0B423023		sto		$x20,160[$s1]
FFFC2140 0B523423		sto		$x21,168[$s1]
FFFC2144 0B623823		sto		$x22,176[$s1]
FFFC2148 0B723C23		sto		$x23,184[$s1]
FFFC214C 0D823023		sto		$x24,192[$s1]
FFFC2150 0D923423		sto		$x25,200[$s1]
FFFC2154 0DA23823		sto		$x26,208[$s1]
FFFC2158 0DB23C23		sto		$x27,216[$s1]
FFFC215C 0FC23023		sto		$x28,224[$s1]
FFFC2160 0FD23423		sto		$x29,232[$s1]
FFFC2164 0FE23823		sto		$x30,240[$s1]
FFFC2168 0FF23C23		sto		$x31,248[$s1]
FFFC216C 79026073		csrrs	$x0,#CSR_REGSET,#4				; select current register set for Rs2
FFFC2170 34101173		csrrw	$x2,#$341,$x0				; save off mepc
FFFC2174 28223023		sto		$x2,TCBepc[$s1]
                        		; Now save off segment registers
FFFC2178 00006D93		ldi		$t1,#0
                        	.svseg:
FFFC217C 01B00D0D		mvseg	$t0,$x0,$t1
FFFC2180 003D9113		sll		$x2,$t1,#3
FFFC2184 00410133		add		$x2,$x2,$s1
FFFC2188 21A13023		sto		$t0,TCBsegs[$x2]
FFFC218C 001D8D93		add		$t1,$t1,#1
FFFC2190 00FDFD93		and		$t1,$t1,#15
FFFC2194 FE0D94E3		bne		$t1,$x0,.svseg
                        	
                        	.savedAlready:
                        		; Restore segment register set
FFFC2198 00006D93		ldi		$t1,#0
                        	.rsseg:
FFFC219C 003D9113		sll		$x2,$t1,#3
FFFC21A0 00510133		add		$x2,$x2,$s2
FFFC21A4 20013D03		ldo		$t0,TCBsegs[$x2]
FFFC21A8 01BD000D		mvseg	$x0,$t0,$t1
FFFC21AC 001D8D93		add		$t1,$t1,#1
FFFC21B0 00FDFD93		and		$t1,$t1,#15
FFFC21B4 FE0D94E3		bne		$t1,$x0,.rsseg
                        	
FFFC21B8 2802B103		ldo		$x2,TCBepc[$s2]			; restore epc
FFFC21BC 34111073		csrrw	$x0,#$341,$x2
                        		; Restore incoming registers
FFFC21C0 7900F073		csrrc	$x0,#CSR_REGSET,#1				; select previous regset for Rd
FFFC21C4 0082B083		ldo		$x1,8[$s2]
FFFC21C8 0102B103		ldo		$x2,16[$s2]
FFFC21CC 0182B183		ldo		$x3,24[$s2]
FFFC21D0 0202B203		ldo		$x4,32[$s2]
FFFC21D4 0282B283		ldo		$x5,40[$s2]
FFFC21D8 0302B303		ldo		$x6,48[$s2]
FFFC21DC 0382B383		ldo		$x7,56[$s2]
FFFC21E0 0402B403		ldo		$x8,64[$s2]
FFFC21E4 0482B483		ldo		$x9,72[$s2]
FFFC21E8 0502B503		ldo		$x10,80[$s2]
FFFC21EC 0582B583		ldo		$x11,88[$s2]
FFFC21F0 0602B603		ldo		$x12,96[$s2]
FFFC21F4 0682B683		ldo		$x13,104[$s2]
FFFC21F8 0702B703		ldo		$x14,112[$s2]
FFFC21FC 0782B783		ldo		$x15,120[$s2]
FFFC2200 0802B803		ldo		$x16,128[$s2]
FFFC2204 0882B883		ldo		$x17,136[$s2]
FFFC2208 0902B903		ldo		$x18,144[$s2]
FFFC220C 0982B983		ldo		$x19,152[$s2]
FFFC2210 0A02BA03		ldo		$x20,160[$s2]
FFFC2214 0A82BA83		ldo		$x21,168[$s2]
FFFC2218 0B02BB03		ldo		$x22,176[$s2]
FFFC221C 0B82BB83		ldo		$x23,184[$s2]
FFFC2220 0C02BC03		ldo		$x24,192[$s2]
FFFC2224 0C82BC83		ldo		$x25,200[$s2]
FFFC2228 0D02BD03		ldo		$x26,208[$s2]
FFFC222C 0D82BD83		ldo		$x27,216[$s2]
FFFC2230 0E02BE03		ldo		$x28,224[$s2]
FFFC2234 0E82BE83		ldo		$x29,232[$s2]
FFFC2238 0F02BF03		ldo		$x30,240[$s2]
FFFC223C 0F82BF83		ldo		$x31,248[$s2]
FFFC2240 28028523		stb		$x0,TCBContextSaved[$s2]
FFFC2244 79081073		csrrw	$x0,#CSR_REGSET,$v0				; restore register set selections
FFFC2248 300E1073		csrrw	$x0,#$300,$t2							; restore interrupts
                        	.noCtxSwitch:
FFFC224C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Operating system call dispatcher.
                        	;------------------------------------------------------------------------------
                        	
                        	OSCALL:
FFFC2250 79017073		csrrc	$x0,#CSR_REGSET,#2		; select previous regs for Rs1		
FFFC2254 00096933		mov		$a0,$a0								; move previous to current
FFFC2258 0009E9B3		mov		$a1,$a1
FFFC225C 000A6A33		mov		$a2,$a2
FFFC2260 000AEAB3		mov		$a3,$a3
FFFC2264 000B6B33		mov		$a4,$a4
FFFC2268 000BEBB3		mov		$a5,$a5
FFFC226C 79016073		csrrs	$x0,#CSR_REGSET,#2		; get back current registers for all
FFFC2270 40006D13		ldi		$t0,#1024
FFFC2274 03A96A63		bltu	$a0,$t0,.oscall
FFFC2278 01F97913		and		$a0,$a0,#31
FFFC227C 00191913		sll		$a0,$a0,#1
FFFC2280 FFFC1637		lhu		$t0,BIOSCallTbl[$a0]
FFFC2284 DF060613
FFFC2288 01260633
FFFC228C 00065D03
FFFC2290 040D0E63		beqz	$t0,.zero
FFFC2294 FFFC0637		or		$t0,$t0,#$FFFC0000
FFFC2298 00060613
FFFC229C 01A66D33
FFFC22A0 000D00E7		call	[$t0]									; call the BIOS Function
FFFC22A4 02000A63		bra		.xit
                        	.oscall:
FFFC22A8 01F97913		and		$a0,$a0,#31
FFFC22AC 04090063		beqz	$a0,.zero
FFFC22B0 00191913		sll		$a0,$a0,#1
FFFC22B4 FFFC2637		lhu		$t0,OSCallTbl[$a0]
FFFC22B8 D0460613
FFFC22BC 01260633
FFFC22C0 00065D03
FFFC22C4 020D0463		beqz	$t0,.zero
FFFC22C8 FFFC0637		or		$t0,$t0,#$FFFC0000
FFFC22CC 00060613
FFFC22D0 01A66D33
FFFC22D4 000D00E7		call	[$t0]									; call the OS Function
                        	.xit:
FFFC22D8 7900F073		csrrc	$x0,#CSR_REGSET,#1		; select previous regs for Rd
FFFC22DC 00086833		mov		$v0,$v0
FFFC22E0 0008E8B3		mov		$v1,$v1
FFFC22E4 7900E073		csrrs	$x0,#CSR_REGSET,#1		; select current regs for Rd
FFFC22E8 10000073		eret
                        	.zero:
FFFC22EC 01A06813		ldi		$v0,#E_BadCallno
FFFC22F0 FE0004E3		bra		.xit
                        	
                        	;------------------------------------------------------------------------------
                        	; Sleep for a number of ticks. Tick interval determined by the VIA timer #3.
                        	; Passing a time of zero or less causes the function to return right away.
                        	;
                        	; Parameters:
                        	;		a1 = length of time to sleep (must be >= 0)
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_Sleep:
FFFC22F4 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC22F8 FF870713		sub		$sp,$sp,#8
FFFC22FC 00173023		sto		$ra,[$sp]
FFFC2300 0E09C863		bltz	$a1,.xit
                        		
FFFC2304 18101873		csrrw	v0,#$181,x0
FFFC2308 03F87813		and		v0,v0,#MAX_TID
FFFC230C 00A81213	sll		$s1,$v0,#LOG_TCBSZ
                        		; First thing: set end time. We don't want to include time spent in the OS in
                        		; the time accounting, so we set the end time as soon as possible.
FFFC2310 70101E73		csrrw	$t2,#$701,$x0					; get time
FFFC2314 2BC23C23		sto		$t2,TCBEndTime[$s1]
FFFC2318 00098C63		beqz	$a1,.0001
FFFC231C 00086933		mov		$a0,$v0								; a0 = current tid
FFFC2320 3000F073		csrrc	$x0,#$300,#1					; disable ints
FFFC2324 0C1000EF		call	RemoveFromReadyList
FFFC2328 175000EF		call	InsertIntoTimeoutList	; a1 = timeout
FFFC232C 3000E073		csrrs	$x0,#$300,#1					; enable ints
                        	.0001:
FFFC2330 28824803		ldbu	$v0,TCBStatus[$s1]		; flag task as no longer running
FFFC2334 F7F87813		and		$v0,$v0,#~TS_RUNNING
FFFC2338 29020423		stb		$v0,TCBStatus[$s1]
                        	
                        		;	AccountTime
FFFC233C 2B823E03		ldo		$t2,TCBEndTime[$s1]		; get back end time
FFFC2340 2B023E83		ldo		$t3,TCBStartTime[$s1]
FFFC2344 41DE0F33		sub		$t4,$t2,$t3						; end - start
FFFC2348 2C023F83		ldo		$t5,TCBElapsedTime[$s1]
FFFC234C 01EF8FB3		add		$t5,$t5,$t4						; ticks + (end - start)
FFFC2350 2DF23023		sto		$t5,TCBElapsedTime[$s1]
                        		; Will switch to target memory map.
FFFC2354 B79FF0EF		call	SelectTaskToRun
                        	
FFFC2358 00A81293		sll		$s2,$v0,#LOG_TCBSZ		; s2 = pointer to incoming TCB
FFFC235C 2882C103		ldbu	$x2,TCBStatus[$s2]		; x2 = incoming status
FFFC2360 08116E13		or		$t2,$x2,#TS_RUNNING|TS_READY	; set status = running
FFFC2364 2C82A103		ldt		$x2,TCBException[$s2]	;
FFFC2368 00010A63		beqz	$x2,.noException
                        		; set link register to catch handler address
                        		;{
                        		;	t->regs[29] = t->regs[28];   // set link register to catch handler
                        		;	t->epc = t->regs[28];        // and the PC register
                        		;	t->regs[1] = t->exception;    // r1 = exception value
                        		;	t->exception = 0;
                        		;	t->regs[2] = 45;              // r2 = exception type
                        		;}
FFFC236C 0022B423		sto		$x2,8[$s2]						; r1 = exception
FFFC2370 2C02A423		stt		$x0,TCBException[$s2]	; tcb->exception = 0
FFFC2374 02D06113		ldi		$x2,#45
FFFC2378 0022B823		sto		$x2,16[$s2]						; r2 = 45
                        	.noException:
                        	
                        		; If a message is ready, update status to ready and put
                        		; message in target memory. The task will be returning
                        		; from a WaitMsg so a return status of E_Ok is also set.
FFFC237C 004E7113		and		$x2,$t2,#TS_MSGRDY
FFFC2380 04010E63		beqz	$x2,.noMsg
FFFC2384 00010D37		ldi		$t0,#$10000						; mprv bit
FFFC2388 000D0D13
FFFC238C 0A02B903		ldo		$a0,160[$s2]					; user a2 (x20)
FFFC2390 00090A63		beqz	$a0,.0002
FFFC2394 2982B103		ldo		$x2,TCBMsgD1[$s2]
FFFC2398 300D2073		csrrs	$x0,#$300,$t0					; set mprv
FFFC239C 00293023		sto		$x2,[$a0]							; store to user space
FFFC23A0 300D3073		csrrc	$x0,#$300,$t0					; clear mprv
                        	.0002:
FFFC23A4 0A82B903		ldo		$a0,168[$s2]
FFFC23A8 00090A63		beqz	$a0,.0003
FFFC23AC 2A02B103		ldo		$x2,TCBMsgD2[$s2]
FFFC23B0 300D2073		csrrs	$x0,#$300,$t0					; set mprv
FFFC23B4 00293023		sto		$x2,[$a0]
FFFC23B8 300D3073		csrrc	$x0,#$300,$t0					; set mprv
                        	.0003:
FFFC23BC 0B02B903		ldo		$a0,176[$s2]
FFFC23C0 00090A63		beqz	$a0,.0004
FFFC23C4 2A82B103		ldo		$x2,TCBMsgD3[$s2]
FFFC23C8 300D2073		csrrs	$x0,#$300,$t0					; set mprv
FFFC23CC 00293023		sto		$x2,[$a0]
FFFC23D0 300D3073		csrrc	$x0,#$300,$t0					; set mprv
                        	.0004:
FFFC23D4 00006113		ldi		$x2,#E_Ok						; setup to return E_Ok
FFFC23D8 0822B023		sto		$x2,128[$s2]					; in v0
                        	
                        	.noMsg:
FFFC23DC FFBE7E13		and		$t2,$t2,#~TS_MSGRDY		; mask out message ready status
FFFC23E0 29C28423		stb		$t2,TCBStatus[$s2]
                        	
                        		; A context switch will be performed by the scheduler IRQ when a tick occurs.
                        		; Go to a low power mode while waiting for the interrupt.
                        		; The context switch will return after the wfi. However, another interrupt
                        		; might have occurred that didn't switch the context. So, the task status
                        		; is checked to see if it's ready yet. If not the wait continues.
                        		; What's really wanted is a wait for scheduler task interrupt.
FFFC23E4 CEDFF0EF		call	SwapContext
                        	;.wait:
                        	;	wfi
                        	;	ldbu	$t2,TCBStatus[$s1]
                        	;	and		$t2,$t2,#TS_READY
                        	;	beqz	$t2,.wait
                        	
                        		; As above, we want to minimize the impact of the OS on the tasks scheduled
                        		; time. So we set the start time as late as possible.
FFFC23E8 70101E73		csrrw	$t2,#$701,$x0					; get time
FFFC23EC 2BC23823		sto		$t2,TCBStartTime[$s1]
                        	.xit:
FFFC23F0 00073083		ldo		$ra,[$sp]
FFFC23F4 00870713		add		$sp,$sp,#8
FFFC23F8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; SchedulerIRQ meant to be called from the timer ISR.
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_SchedulerIRQ:
FFFC23FC 7920E873		csrrs	$v0,#$792,#1					; check and set semaphore
FFFC2400 00187813		and		$v0,$v0,#1
FFFC2404 00080463		beqz	$v0,.doSchedule				; do scheduling only if semaphore clear
FFFC2408 00008067		ret
                        	.doSchedule:
FFFC240C 3000E073		csrrs	$x0,#$300,#1					; enable ints
                        		
FFFC2410 18101873		csrrw	v0,#$181,x0
FFFC2414 03F87813		and		v0,v0,#MAX_TID
FFFC2418 00A81213	sll		$s1,$v0,#LOG_TCBSZ		; compute pointer to TCB
FFFC241C 70101E73		csrrw	$t2,#$701,$x0					; get time
FFFC2420 2BC23C23		sto		$t2,TCBEndTime[$s1]
FFFC2424 1600000D		decto												; decrement timeouts (takes 64 clock cycles async)
FFFC2428 FF870713		sub		$sp,$sp,#8
FFFC242C 00173023		sto		$ra,[$sp]
FFFC2430 00024937		ldi		$a0,#SysSema
FFFC2434 34090913
FFFC2438 01406993		ldi		$a1,#20
                        	;	call	LockSemaphore
                        	;	beq		$v0,$x0,.noLock
                        	; Might need the following if the external timer isn't used.
                        	;	csrrw	$v0,#$701,$x0					; get the time
                        	;	add		$v0,$v0,#300000				; wait 300,000 cycles @40MHz (30ms)
                        	;	csrrw	$x0,#$321,$v0					; set next interrupt time
                        		;	AccountTime
FFFC243C 2B023E83		ldo		$t3,TCBStartTime[$s1]
FFFC2440 41DE0F33		sub		$t4,$t2,$t3						; end - start
FFFC2444 2C023F83		ldo		$t5,TCBElapsedTime[$s1]
FFFC2448 01EF8FB3		add		$t5,$t5,$t4						; ticks + (end - start)
FFFC244C 2DF23023		sto		$t5,TCBElapsedTime[$s1]
                        	
FFFC2450 28824F83		ldbu	$t5,TCBStatus[$s1]
FFFC2454 020FEF93		or		$t5,$t5,#TS_PREEMPT
FFFC2458 F7FFFF93		and		$t5,$t5,#~TS_RUNNING	; no longer running, but may still be ready
FFFC245C 29F20423		stb		$t5,TCBStatus[$s1]
                        		; Keep popping the timeout list as long as there are tasks on it with
                        		; expired timeouts.
FFFC2460 00006913		ldi		$a0,#0
FFFC2464 1400038D		getzl	$s4		; Get list of tasks whose timeout is zero
.0001:
FFFC2468 00A91F13		sll		$t4,$a0,#10
FFFC246C 288F4E03		lbu		$t2,TCBStatus[$t4]
FFFC2470 010E7E13		and		$t2,$t2,#TS_TIMEOUT
FFFC2474 020E0463		beqz	$t2,.noTimeout
FFFC2478 0013FE13		and		$t2,$s4,#1					; is zero bit set?
FFFC247C 020E0063		beqz	$t2,.notZero
FFFC2480 288F4E03		lbu		$t2,TCBStatus[$t4]
FFFC2484 FE7E7E13		and		$t2,$t2,#~(TS_TIMEOUT|TS_WAITMSG)
	sb		$t2,TCBStatus[$t4]
FFFC2488 29CF0423
FFFC248C 3000F073		csrrc	$x0,#$300,#1				; disable ints
FFFC2490 2E8000EF		call	MbxRemoveTask
FFFC2494 6AC000EF		call	InsertIntoReadyList
FFFC2498 3000E073		csrrs	$x0,#$300,#1				; enable ints
                        	.notZero:
                        	.noTimeout:
FFFC249C 00190913		add		$a0,$a0,#1
FFFC24A0 0013D393		srl		$s4,$s4,#1	
FFFC24A4 FC0392E3		bnez	$s4,.0001
                        	
                        		; The ready list was just updated, there could be new tasks
                        		; ready to run. Will switch to target memory map.
                        	.searchQ:
FFFC24A8 00024637		ldbu	$v1,QNDX						; get index into que check table
FFFC24AC 30460613
FFFC24B0 00060633
FFFC24B4 00064883
FFFC24B8 00188893		add		$v1,$v1,#1					; increment it, and limit
FFFC24BC 01F8F893		and		$v1,$v1,#31
FFFC24C0 00024637		stb		$v1,QNDX						; store back
FFFC24C4 30460613
FFFC24C8 00060633
FFFC24CC 01160023
FFFC24D0 FFFC2637		ldbu	$v1,qToChk[$v1]			; assume this will be valid
FFFC24D4 D3A60613
FFFC24D8 01160633
FFFC24DC 00064883
FFFC24E0 00406E13		ldi		$t2,#4							; 4 queues to check
                        	.nxtQ:
FFFC24E4 1C08880D		getrdy	$v0,$v1
;	ldw		$v0,READYQ[$v1]			; check queue to see if contains any
FFFC24E8 00085E63		bge		$v0,$x0,.dq					; yes, go dequeue
FFFC24EC 00188893		add		$v1,$v1,#1					; no, advance to next queue
FFFC24F0 0038F893		and		$v1,$v1,#3					; 4 max
FFFC24F4 FFFE0E13		sub		$t2,$t2,#1					;
FFFC24F8 FFC046E3		bgt		$t2,$x0,.nxtQ				; go back to check next queue
                        		; Here, nothing else is actually ready to run
                        		; just go back to what we were doing.
                        		
FFFC24FC 18101873		csrrw	v0,#$181,x0
FFFC2500 03F87813		and		v0,v0,#MAX_TID
                        	.dq:
                        	.goodTid:
FFFC2504 18181073		csrrw	$x0,#$181,$v0
                        	
FFFC2508 00A81293		sll		$s2,$v0,#LOG_TCBSZ	; s2 = pointer to incoming TCB
FFFC250C 2882C103		lbu		$x2,TCBStatus[$s2]	; x2 = incoming status
FFFC2510 08116E13		or		$t2,$x2,#TS_RUNNING|TS_READY	; status = running
FFFC2514 2C82B103		ldo		$x2,TCBException[$s2]	;
FFFC2518 00010263		beqz	$x2,.noException
                        		; set link register to catch handler address
                        		;{
                        		;	t->regs[29] = t->regs[28];   // set link register to catch handler
                        		;	t->epc = t->regs[28];        // and the PC register
                        		;	t->regs[1] = t->exception;    // r1 = exception value
                        		;	t->exception = 0;
                        		;	t->regs[2] = 45;              // r2 = exception type
                        		;}
                        	.noException:
                        	
                        		; If a message is ready, update status to ready and put
                        		; message in target memory. The task will be returning
                        		; from a WaitMsg so a return status of E_Ok is also set.
FFFC251C 06000263		bra		.noMsg
FFFC2520 004E7113		and		$x2,$t2,#TS_MSGRDY
FFFC2524 04010E63		beq		$x2,$x0,.noMsg
FFFC2528 00010D37		ldi		$t0,#$10000						; mprv bit
FFFC252C 000D0D13
FFFC2530 0A02B903		ldo		$a0,160[$s2]					; user a2 (x20)
FFFC2534 00090A63		beq		$a0,$x0,.0002
FFFC2538 2982B103		ldo		$x2,TCBMsgD1[$s2]
FFFC253C 300D2073		csrrs	$x0,#$300,$t0					; set mprv
FFFC2540 00293023		sto		$x2,[$a0]
FFFC2544 300D3073		csrrc	$x0,#$300,$t0					; set mprv
                        	.0002:
FFFC2548 0A82B903		ldo		$a0,168[$s2]
FFFC254C 00090A63		beq		$a0,$x0,.0003
FFFC2550 2A02B103		ldo		$x2,TCBMsgD2[$s2]
FFFC2554 300D2073		csrrs	$x0,#$300,$t0					; set mprv
FFFC2558 00293023		sto		$x2,[$a0]
FFFC255C 300D3073		csrrc	$x0,#$300,$t0					; set mprv
                        	.0003:
FFFC2560 0B02B903		ldo		$a0,176[$s2]
FFFC2564 00090A63		beq		$a0,$x0,.0004
FFFC2568 2A82B103		ldo		$x2,TCBMsgD3[$s2]
FFFC256C 300D2073		csrrs	$x0,#$300,$t0					; set mprv
FFFC2570 00293023		sto		$x2,[$a0]
FFFC2574 300D3073		csrrc	$x0,#$300,$t0					; set mprv
                        	.0004:
FFFC2578 00006113		ldi		$x2,#E_Ok						; setup to return E_Ok
FFFC257C 0822B023		sto		$x2,128[$s2]				; in v0
                        	
                        	.noMsg:
FFFC2580 FFBE7E13		and		$t2,$t2,#~TS_MSGRDY		; mask out message ready status
FFFC2584 29C28423		stb		$t2,TCBStatus[$s2]
                        	
                        		
FFFC2588 FFF06813		ldi		v0,#-1
FFFC258C 00024637		sw		v0,SysSema
FFFC2590 34060613
FFFC2594 00060633
FFFC2598 01062023
                        	
                        	.noLock:
FFFC259C B35FF0EF		call	SwapContext
FFFC25A0 00073083		ldo		$ra,[$sp]
FFFC25A4 00870713		add		$sp,$sp,#8
FFFC25A8 70101E73		csrrw	$t2,#$701,$x0					; get low time
FFFC25AC 2BC2B823		sto		$t2,TCBStartTime[$s2]
FFFC25B0 7920F073		csrrc	$x0,#$792,#1				; clear scheduling semaphore
FFFC25B4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Start a task.
                        	;	Task status is set to ready, priority normal, and the task is inserted into
                        	; the ready list. Segment registers are setup for a flat memory model.
                        	; 
                        	;	Parameters:
                        	;		a1 = memory required
                        	;		a2 = start pc (usually $100)
                        	;	Modifies:
                        	;		a0 = tid
                        	;	Returns:
                        	;		v0 = E_Ok if successful
                        	;		v1 = tid of started task if successful
                        	;------------------------------------------------------------------------------
                        	;
                        	FMTK_StartTask:
FFFC25B8 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC25BC FF870713		sub		$sp,$sp,#8
FFFC25C0 00173023		sto		$ra,[$sp]
FFFC25C4 05D000EF		call	AllocTCB
FFFC25C8 00004637		stb		$v1,$4321
FFFC25CC 32160613
FFFC25D0 00060633
FFFC25D4 01160023
FFFC25D8 0C081263		bnez	$v0,.err
FFFC25DC 0008E933		mov		$a0,$v1
FFFC25E0 A31FE0EF		call	FreeAll
FFFC25E4 8C9FF0EF		call	MapOSPages			; Map OS pages into address space
FFFC25E8 00A91213		sll		$s1,$a0,#LOG_TCBSZ	; compute TCB address
FFFC25EC 9E9FE0EF		call	AllocStack
FFFC25F0 A0010637		add		$t0,$v1,#$A000FFFC	; set stack pointer
FFFC25F4 FFC60613
FFFC25F8 01160D33
FFFC25FC 07A23823		sto		$t0,112[$s1]
FFFC2600 29423023		sto		$a2,TCBepc[$s1]	; address task will begin at
FFFC2604 915FE0EF		call	Alloc
FFFC2608 00004637		stb		$v0,$4320
FFFC260C 32060613
FFFC2610 00060633
FFFC2614 01060023
FFFC2618 08081263		bnez	$v0,.err
FFFC261C 0008E933		mov		$a0,$v1
FFFC2620 938FE0EF		call	PutHexWord
FFFC2624 00106D13		ldi		$t0,#TS_READY
FFFC2628 29A20423		stb		$t0,TCBStatus[$s1]
FFFC262C 00206D13		ldi		$t0,#2					; normal execution priority
FFFC2630 29A204A3		stb		$t0,TCBPriority[$s1]
                        		; leave segment base at $0, flat memory model
FFFC2634 00606D13		ldi		$t0,#6							; read,write
FFFC2638 21A23023		sto		$t0,TCBsegs[$s1]			; segs 0 to 11
FFFC263C 21A23423		sto		$t0,TCBsegs+8[$s1]
FFFC2640 21A23823		sto		$t0,TCBsegs+16[$s1]
FFFC2644 21A23C23		sto		$t0,TCBsegs+24[$s1]
FFFC2648 23A23023		sto		$t0,TCBsegs+32[$s1]
FFFC264C 23A23423		sto		$t0,TCBsegs+40[$s1]
FFFC2650 23A23823		sto		$t0,TCBsegs+48[$s1]
FFFC2654 23A23C23		sto		$t0,TCBsegs+56[$s1]
FFFC2658 25A23023		sto		$t0,TCBsegs+64[$s1]
FFFC265C 25A23423		sto		$t0,TCBsegs+72[$s1]
FFFC2660 25A23823		sto		$t0,TCBsegs+80[$s1]
FFFC2664 25A23C23		sto		$t0,TCBsegs+88[$s1]
FFFC2668 00506D13		ldi		$t0,#5							; read,execute
FFFC266C 27A23023		sto		$t0,TCBsegs+96[$s1]	; segs 12 to 15
FFFC2670 27A23423		sto		$t0,TCBsegs+104[$s1]
FFFC2674 27A23823		sto		$t0,TCBsegs+112[$s1]
FFFC2678 27A23C23		sto		$t0,TCBsegs+120[$s1]
FFFC267C 32023823		sto		$x0,TCBVideoMem[$s1]
FFFC2680 FFD00D37		ldi		$t0,#$FFD00000
FFFC2684 000D0D13
FFFC2688 33A23C23		sto		$t0,TCBpVideo[$s1]
FFFC268C 00A25913		srl		$a0,$s1,#LOG_TCBSZ	; need the tid again
FFFC2690 3000F073		csrrc	$x0,#$300,#1				; disable ints
FFFC2694 4AC000EF		call	InsertIntoReadyList
FFFC2698 000968B3		mov		$v1,$a0
                        	.err:
                        	.xit:
FFFC269C 00073083		ldo		$ra,[$sp]
FFFC26A0 00870713		add		$sp,$sp,#8
FFFC26A4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Exit the current task.
                        	;
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		a1 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_ExitTask:
FFFC26A8 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC26AC FF870713		sub		$sp,$sp,#8
FFFC26B0 00173023		sto		$ra,[$sp]
                        		
FFFC26B4 18101873		csrrw	v0,#$181,x0
FFFC26B8 03F87813		and		v0,v0,#MAX_TID
FFFC26BC 000869B3	mov		a1,v0
FFFC26C0 00000637		call	KillTask
FFFC26C4 1F9600E7
                        	.xit:
FFFC26C8 00073083		ldo		$ra,[$sp]
FFFC26CC 00870713		add		$sp,$sp,#8
FFFC26D0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = tid of task to kill
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_KillTask:
FFFC26D4 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC26D8 FF870713		sub		$sp,$sp,#8
FFFC26DC 00173023		sto		$ra,[$sp]
FFFC26E0 04098A63		beqz	$a1,.immortal		; tid #0 is immortal (the system)
FFFC26E4 00206D13		ldi		$t0,#TS_DEAD				; flag task as dead (prevents it from being re-queued)
FFFC26E8 03F9FD93		and		$t1,$a1,#MAX_TID		; limit tid
FFFC26EC 00AD9D93		sll		$t1,$t1,#LOG_TCBSZ	; convert to TCB address
FFFC26F0 29AD8423		stb		$t0,TCBStatus[$t1]
FFFC26F4 0009E933		mov		$a0,$a1								; a0 = pid
FFFC26F8 3000F073		csrrc	$x0,#$300,#1				; disable ints
FFFC26FC 4E8000EF		call	RemoveFromReadyList
FFFC2700 911FE0EF		call	FreeAll							; free all the memory associated with the task
                        		; Now make process ID available for reuse
FFFC2704 00024637		ldo		$t1,PIDMAP
FFFC2708 31060613
FFFC270C 00060633
FFFC2710 00063D83
FFFC2714 00106D13		ldi		$t0,#1							; generate bit "off" mask
FFFC2718 013D1D33		sll		$t0,$t0,$a1
FFFC271C FFFD4D13		xor		$t0,$t0,#-1					; complment for inverted mask
FFFC2720 01ADFDB3		and		$t1,$t1,$t0
FFFC2724 00024637		sto		$t1,PIDMAP
FFFC2728 31060613
FFFC272C 00060633
FFFC2730 01B63023
                        	.immortal:
FFFC2734 00006813		ldi		$v0,#E_Ok
                        	.xit:
FFFC2738 00073083		ldo		$ra,[$sp]
FFFC273C 00870713		add		$sp,$sp,#8
FFFC2740 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_AllocVideoBuf:
                        		
FFFC2744 18101873		csrrw	v0,#$181,x0
FFFC2748 03F87813		and		v0,v0,#MAX_TID
FFFC274C 00086933	mov		$a0,$v0
FFFC2750 00106993		ldi		$a1,#1			; request 1 byte to get 1 page (64kB)
FFFC2754 FC4FE0EF		call	Alloc
FFFC2758 00081E63		bnez	$v0,.err
FFFC275C 00A91213		sll		$s1,$a0,#LOG_TCBSZ
FFFC2760 00000637		sto		$v1,TCBVidMem[$s1]
FFFC2764 1FF60613
FFFC2768 00460633
FFFC276C 01163023
FFFC2770 33123C23		sto		$v1,TCBpVideo[$s1]
                        	.err:
FFFC2774 00008067		ret
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/msg.r5a",1
                        	.file "../fmtk/msg.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	MBX_OWNER			equ		0		; tid of owning task
                        	MBX_WTIDS			equ		8		; tasks waiting at mailbox
                        	MBX_MQHEAD		equ		16		
                        	MBX_MQTAIL		equ		24
                        	MBX_SIZE			equ		32
                        	LOG_MBXSZ			equ		5
                        	
                        	MSG_LINK	equ		0
                        	MSG_D1		equ		8
                        	MSG_D2		equ		16
                        	MSG_D3		equ		24
                        	MSG_SIZE	equ		32
                        	LOG_MSGSZ	equ		5
                        	
                        	;	bss
                        	;	align 4
                        	;FreeMsg	dw	0
                        	;msgs:
                        	;	fill.b	MSG_SIZE*1024,0
                        	;mbxs:
                        	;	fill.b	MBX_SIZE*32,0
                        	;mbxs_end:
                        	
                        	.file "../fmtk/msg.r5a",48
                        		code
                        		align	4                        	
                        	
                        	;------------------------------------------------------------------------------
                        	; Remove the task from the list of tasks waiting at the mailbox.
                        	; This routine is only called from a couple of places and it is convenient
                        	; not to stack the return address. So, it is implemented as a macro.
                        	;
                        	; Parameters:
                        	;		a0 = task id
                        	;------------------------------------------------------------------------------
                        	
                        	MbxRemoveTask:
FFFC2778 FE070713		sub		$sp,$sp,#32
FFFC277C 00473023		sto		$s1,[$sp]
FFFC2780 01A73423		sto		$t0,8[$sp]
FFFC2784 01B73823		sto		$t1,16[$sp]
FFFC2788 01C73C23		sto		$t2,24[$sp]
FFFC278C 00A91213		sll		$s1,$a0,#LOG_TCBSZ		; tid to pointer
FFFC2790 28C21D03		lh		$t0,TCBWaitMbx[$s1]		; get mailbox handle
FFFC2794 020D4663		blt		$t0,$x0,.xit					; handle good?
FFFC2798 005D1D13		sll		$t0,$t0,#LOG_MBXSZ		; convert to pointer
FFFC279C 00020637		add		$t0,$t0,#mbxs					; by adding base address
FFFC27A0 00060613
FFFC27A4 01A60D33
FFFC27A8 008D3D83		ldo		$t1,MBX_WTIDS[$t0]		; get waiting task list
FFFC27AC 00106E13		ldi		$t2,#1								; create a mask for given task id
FFFC27B0 012E1E33		sll		$t2,$t2,$a0
FFFC27B4 FFFE4E13		xor		$t2,$t2,#-1
FFFC27B8 01CDFDB3		and		$t1,$t1,$t2						; clear bit
FFFC27BC 01BD3423		sto		$t1,MBX_WTIDS[$t0]		; update waiting task list
                        	.xit:
FFFC27C0 00073203		ldo		$s1,[$sp]
FFFC27C4 00873D03		ldo		$t0,8[$sp]
FFFC27C8 01073D83		ldo		$t1,16[$sp]
FFFC27CC 01873E03		ldo		$t2,24[$sp]
FFFC27D0 02070713		add		$sp,$sp,#32
FFFC27D4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Allocate a mailbox.
                        	;
                        	; Parameters:
                        	;		a1 = task id of owner
                        	;		a2 = pointer where to store handle
                        	; Returns:
                        	;		v0 = E_Ok
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_AllocMbx:
                        		; Enable interrupts
FFFC27D8 3000E073		csrrs	$x0,#$300,#1				
FFFC27DC FF870713		sub		$sp,$sp,#8
FFFC27E0 00173023		sto		$ra,[$sp]
FFFC27E4 040A0C63		beq		$a2,$x0,.badArg
FFFC27E8 00020D37		ldi		$t0,#mbxs
FFFC27EC 000D0D13
                        	.nxt:
FFFC27F0 000D4D83		ldbu	$t1,MBX_OWNER[$t0]
FFFC27F4 000D8E63		beq		$t1,$x0,.noOwner
FFFC27F8 020D0D13		add		$t0,$t0,#MBX_SIZE
FFFC27FC 00022637		slt		$t1,$t0,#mbxs_end
FFFC2800 00060613
FFFC2804 FE0D96E3		bne		$t1,$x0,.nxt
FFFC2808 04006813		ldi		$v0,#E_NoMoreMbx
FFFC280C 02000A63		bra		.xit
                        	.noOwner:
FFFC2810 013D0023		stb		$a1,MBX_OWNER[$t0]
FFFC2814 FFFE0637		sub		$t5,$t0,#mbxs				; convert pointer to handle
FFFC2818 00060613
FFFC281C 41A60FB3
FFFC2820 005FDF93		srl		$t5,$t5,#LOG_MBXSZ
FFFC2824 0009E933		mov		$a0,$a1
FFFC2828 000A69B3		mov		$a1,$a2
FFFC282C 849FE0EF		call	VirtToPhys
FFFC2830 01F83023		sto		$t5,[$v0]
FFFC2834 00006813		ldi		$v0,#E_Ok
FFFC2838 00000463		bra		.xit
                        	.badArg:
FFFC283C 00106813		ldi		$v0,#E_Arg
                        	.xit:
FFFC2840 00073083		ldo		$ra,[$sp]
FFFC2844 00870713		add		$sp,$sp,#8
FFFC2848 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Free a mailbox
                        	;
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_FreeMbx:
                        		; Enable interrupts
FFFC284C 3000E073		csrrs	$x0,#$300,#1				
FFFC2850 FF870713		sub		$sp,$sp,#8
FFFC2854 00173023		sto		$ra,[$sp]
FFFC2858 1009A213		slt		$s1,$a1,#NR_MBX
FFFC285C 06020863		beq		$s1,$x0,.badMbx
FFFC2860 00599213		sll		$s1,$a1,#LOG_MBXSZ		; convert handle to pointer
FFFC2864 00020637		add		$s1,$s1,#mbxs
FFFC2868 00060613
FFFC286C 00460233
FFFC2870 00006293		ldi		$s2,#0
FFFC2874 04006393		ldi		$s4,#NR_TCB						; possibly 64 tasks
FFFC2878 00823483		ldo		$s6,MBX_WTIDS[$s1]
                        	.0002:
FFFC287C 0014F313		and		$s3,$s6,#1
FFFC2880 02030C63		beq		$s3,$x0,.0001
FFFC2884 00A29413		sll		$s5,$s2,#LOG_TCBSZ		; tid to pointer
FFFC2888 28844803		lbu		$v0,TCBStatus[$s5]
FFFC288C FF787813		and		$v0,$v0,#~TS_WAITMSG	; no longer waiting
FFFC2890 29040423		stb		$v0,TCBStatus[$s5]
FFFC2894 01087813		and		$v0,$v0,#TS_TIMEOUT
FFFC2898 0002E933		mov		$a0,$s2
                        		; Disable interrupts
FFFC289C 3000F073		csrrc	$x0,#$300,#1
FFFC28A0 00080463		beqz	$v0,.0003
FFFC28A4 4DC000EF		call	RemoveFromTimeoutList
                        	.0003:
FFFC28A8 298000EF		call	InsertIntoReadyList
FFFC28AC 3000E073		csrrs	$x0,#$300,#1					; enable ints
FFFC28B0 00B06813		ldi		$v0,#E_NoMsg					; but no message
FFFC28B4 09043023		sto		$v0,128[$s5]					; v0 = E_NoMsg
                        	.0001:
FFFC28B8 0014D493		srl		$s6,$s6,#1
FFFC28BC 00128293		add		$s2,$s2,#1
FFFC28C0 FA72EEE3		bltu	$s2,$s4,.0002
FFFC28C4 00006813		ldi		$v0,#E_Ok
FFFC28C8 00000463		bra		.xit
                        	.badMbx:
FFFC28CC 00406813		ldi		$v0,#E_BadMbx				; return null pointer if bad mailbox
                        	.xit:
FFFC28D0 00073083		ldo		$ra,[$sp]
FFFC28D4 00870713		add		$sp,$sp,#8
FFFC28D8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Send a message to a mailbox.
                        	; The message will be broadcast to any waiting tasks. Waiting tasks will then
                        	; be moved to the ready list. If there are no waiting tasks then the message
                        	; is queued at the mailbox.
                        	;
                        	; Register Usage:
                        	;		t0 = mailbox pointer
                        	;		t1 = message pointer
                        	;		s1 = task id of waiting task
                        	; Modifies:
                        	;		a0
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = message d1
                        	;		a3 = message d2
                        	;		a4 = message d3
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_SendMsg:
FFFC28DC 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC28E0 FF870713		sub		$sp,$sp,#8
FFFC28E4 00173023		sto		$ra,[$sp]
FFFC28E8 1009BD13		sltu	$t0,$a1,#NR_MBX
FFFC28EC 0E0D0863		beq		$t0,$x0,.badMbx
FFFC28F0 00599D13		sll		$t0,$a1,#LOG_MBXSZ	; convert handle to pointer
FFFC28F4 00020637		add		$t0,$t0,#mbxs
FFFC28F8 00060613
FFFC28FC 01A60D33
FFFC2900 008D3F83		ldo		$t5,MBX_WTIDS[$t0]
FFFC2904 060F8463		beq		$t5,$x0,.noWaiters	; no waiters = go queue message
FFFC2908 00006213		ldi		$s1,#0
                        	.0001:
FFFC290C 001FF313		and		$s3,$t5,#1					; is tid waiting?
FFFC2910 04030063		beq		$s3,$x0,.nxtTid
FFFC2914 00A21313		sll		$s3,$s1,#LOG_TCBSZ	; convert tid to TCB pointer
FFFC2918 29433C23		sto		$a2,TCBMsgD1[$s3]		; copy message to TCB
FFFC291C 2B533023		sto		$a3,TCBMsgD2[$s3]
FFFC2920 2B633423		sto		$a4,TCBMsgD3[$s3]
FFFC2924 28834E03		ldbu	$t2,TCBStatus[$s3]
FFFC2928 004E6E13		or		$t2,$t2,#TS_MSGRDY
FFFC292C 29C30423		stb		$t2,TCBStatus[$s3]
FFFC2930 00026933		mov		$a0,$s1
FFFC2934 FF070713		sub		$sp,$sp,#16
FFFC2938 00173023		sto		$ra,[$sp]
FFFC293C 01A73423		sto		$t0,8[$sp]						; push t0
FFFC2940 200000EF		call	InsertIntoReadyList
FFFC2944 00073083		ldo		$ra,[$sp]
FFFC2948 00873D03		ldo		$t0,8[$sp]						; pop t0
FFFC294C 01070713		add		$sp,$sp,#16
                        	.nxtTid:
FFFC2950 001FDF93		srl		$t5,$t5,#1					; check next task
FFFC2954 00120213		add		$s1,$s1,#1
FFFC2958 03F27213		and		$s1,$s1,#63
FFFC295C FA0218E3		bne		$s1,$x0,.0001
FFFC2960 000D3423		sto		$x0,MBX_WTIDS[$t0]	; clear waiters
FFFC2964 00006813		ldi		$v0,#E_Ok
FFFC2968 06000C63		bra		.xit
                        	.noWaiters:
FFFC296C 00024637		ldo		$t1,FreeMsg
FFFC2970 35060613
FFFC2974 00060633
FFFC2978 00063D83
FFFC297C 040D8C63		beq		$t1,$x0,.noMsg			; message available?
FFFC2980 3000F073		csrrc	$x0,#$300,#1				; disable ints
FFFC2984 000DBE03		ldo		$t2,MSG_LINK[$t1]
FFFC2988 00024637		sto		$t2,FreeMsg
FFFC298C 35060613
FFFC2990 00060633
FFFC2994 01C63023
FFFC2998 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC299C 014DB423		sto		$a2,MSG_D1[$t1]
FFFC29A0 015DB823		sto		$a3,MSG_D2[$t1]
FFFC29A4 016DBC23		sto		$a4,MSG_D3[$t1]
FFFC29A8 3000F073		csrrc	$x0,#$300,#1				; diable ints
FFFC29AC 018D3E83		ldo		$t3,MBX_MQTAIL[$t0]
FFFC29B0 000E8A63		beq		$t3,$x0,.mbxEmpty
FFFC29B4 01BEB023		sto		$t1,MSG_LINK[$t3]
FFFC29B8 01BD3C23		sto		$t1,MBX_MQTAIL[$t0]
FFFC29BC 00006813		ldi		$v0,#E_Ok
FFFC29C0 02000063		bra		.xit
                        	.mbxEmpty:
FFFC29C4 01BD3823		sto		$t1,MBX_MQHEAD[$t0]
FFFC29C8 01BD3C23		sto		$t1,MBX_MQTAIL[$t0]
FFFC29CC 00006813		ldi		$v0,#E_Ok
FFFC29D0 00000863		bra		.xit
                        	.noMsg:
FFFC29D4 00B06813		ldi		$v0,#E_NoMsg
FFFC29D8 00000463		bra		.xit
                        	.badMbx:
FFFC29DC 00406813		ldi		$v0,#E_BadMbx				; return null pointer if bad mailbox
                        	.xit:
FFFC29E0 00073083		ldo		$ra,[$sp]
FFFC29E4 00870713		add		$sp,$sp,#8
FFFC29E8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; PeekMsg will check for a message at a mailbox optionally dequeuing it.
                        	; If no message is available PeekMsg returns to the caller with a E_NoMsg
                        	; status.
                        	;
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = pointer where to put message D1
                        	;		a3 = pointer where to put message D2
                        	;		a4 = pointer where to put message D3
                        	;		a5 = 1 = remove from queue
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_PeekMsg:
FFFC29EC 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC29F0 FF870713		sub		$sp,$sp,#8
FFFC29F4 00173023		sto		$ra,[$sp]
FFFC29F8 FF870713		sub		$sp,$sp,#8
FFFC29FC 00173023		sto		$ra,[$sp]
FFFC2A00 0209AD13		slt		$t0,$a1,#32
FFFC2A04 0A0D0463		beq		$t0,$x0,.badMbx
FFFC2A08 00599E13		sll		$t2,$a1,#LOG_MBXSZ	; convert handle to pointer
FFFC2A0C 00020637		add		$t2,$t2,#mbxs
FFFC2A10 00060613
FFFC2A14 01C60E33
FFFC2A18 3000F073		csrrc	$x0,#$300,#1				; disable ints
FFFC2A1C 010E3D83		ldo		$t1,MBX_MQHEAD[$t2]
FFFC2A20 080D8263		beq		$t1,$x0,.noMsg
FFFC2A24 020B8863		beq		$a5,$x0,.nodq
FFFC2A28 000DBE83		ldo		$t3,MSG_LINK[$t1]
FFFC2A2C 01DE3823		sto		$t3,MBX_MQHEAD[$t2]
                        		; This is done here only because interrupts are disabled
FFFC2A30 00024637		ldo		$t3,FreeMsg
FFFC2A34 35060613
FFFC2A38 00060633
FFFC2A3C 00063E83
FFFC2A40 01DDB023		sto		$t3,MSG_LINK[$t1]
FFFC2A44 00024637		sto		$t1,FreeMsg
FFFC2A48 35060613
FFFC2A4C 00060633
FFFC2A50 01B63023
                        	.nodq:
FFFC2A54 00010D37		ldi		$t0,#$10000
FFFC2A58 000D0D13
FFFC2A5C 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC2A60 000A0A63		beqz	$a2,.nod1
FFFC2A64 008DBE83		ldo		$t3,MSG_D1[$t1]
FFFC2A68 300D2073		csrrs	$x0,#$300,$t0				; set mprv
FFFC2A6C 01DA3023		sto		$t3,[$a2]
FFFC2A70 300D3073		csrrc	$x0,#$300,$t0				; clear mprv
                        	.nod1:
FFFC2A74 000A8A63		beqz	$a3,.nod2
FFFC2A78 010DBE83		ldo		$t3,MSG_D2[$t1]
FFFC2A7C 300D2073		csrrs	$x0,#$300,$t0				; set mprv
FFFC2A80 01DAB023		sto		$t3,[$a3]
FFFC2A84 300D3073		csrrc	$x0,#$300,$t0				; clear mprv
                        	.nod2:
FFFC2A88 000B0A63		beqz	$a4,.nod3
FFFC2A8C 018DBE83		ldo		$t3,MSG_D3[$t1]
FFFC2A90 300D2073		csrrs	$x0,#$300,$t0				; set mprv
FFFC2A94 01DB3023		sto		$t3,[$a4]
FFFC2A98 300D3073		csrrc	$x0,#$300,$t0				; clear mprv
                        	.nod3:
FFFC2A9C 00006813		ldi		$v0,#E_Ok
FFFC2AA0 00000863		bra		.ret
                        	.noMsg:
FFFC2AA4 00B06813		ldi		$v0,#E_NoMsg
FFFC2AA8 00000463		bra		.ret
                        	.badMbx:
FFFC2AAC 00406813		ldi		$v0,#E_BadMbx				; return null pointer if bad mailbox
                        	.ret:
FFFC2AB0 00073083		ldo		$ra,[$sp]
FFFC2AB4 00870713		add		$sp,$sp,#8
FFFC2AB8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Calling WaitMsg will cause the task to be queued at the mailbox and a task
                        	; switch to occur if there are no messages at the mailbox.
                        	;
                        	; Parameters:
                        	;		a1 = mailbox handle
                        	;		a2 = pointer where to put message D1
                        	;		a3 = pointer where to put message D2
                        	;		a4 = pointer where to put message D3
                        	;		a5 = time limit
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_WaitMsg:
FFFC2ABC 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC2AC0 FF870713		sub		$sp,$sp,#8
FFFC2AC4 00173023		sto		$ra,[$sp]
FFFC2AC8 000BE433		mov		$s5,$a5
FFFC2ACC 00106B93		ldi		$a5,#1
FFFC2AD0 F1DFF0EF		call	FMTK_PeekMsg				; check for a message, return if available
FFFC2AD4 00B06D93		ldi		$t1,#E_NoMsg
FFFC2AD8 01B80463		beq		$v0,$t1,.qt					; no message? Then go queue task
FFFC2ADC 04000C63		bra		.xit
                        	.qt:
                        		
FFFC2AE0 18101873		csrrw	v0,#$181,x0
FFFC2AE4 03F87813		and		v0,v0,#MAX_TID
FFFC2AE8 00106E13	ldi		$t2,#1
FFFC2AEC 010E1E33		sll		$t2,$t2,$v0
FFFC2AF0 00599E93		sll		$t3,$a1,#LOG_MBXSZ	; convert handle to pointer
FFFC2AF4 00020637		add		$t3,$t3,#mbxs
FFFC2AF8 00060613
FFFC2AFC 01D60EB3
FFFC2B00 3000F073		csrrc	$x0,#$300,#1				; disable ints
FFFC2B04 008EBF03		ldo		$t4,MBX_WTIDS[$t3]	; get waiting task list
FFFC2B08 01CF6F33		or		$t4,$t4,$t2					; set bit for tid
FFFC2B0C 01EEB423		sto		$t4,MBX_WTIDS[$t3]	; save task list
FFFC2B10 3000E073		csrrs	$x0,#$300,#1				; enable ints
FFFC2B14 00A81F13		sll		$t4,$v0,#LOG_TCBSZ	; convert tid to TCB pointer
FFFC2B18 288F4E83		ldbu	$t3,TCBStatus[$t4]
FFFC2B1C 008EEE93		or		$t3,$t3,#TS_WAITMSG	; set waiting for message status
FFFC2B20 FFEEFE93		and		$t3,$t3,#~TS_READY	; not ready
FFFC2B24 29DF0423		stb		$t3,TCBStatus[$t4]
FFFC2B28 293F0623		stb		$a1,TCBWaitMbx[$t4]	; set mailbox task is waiting for
FFFC2B2C 000BE9B3		mov		$a1,$a5
                        		; Continue by switching tasks
FFFC2B30 FC4FF0EF		call		FMTK_Sleep
                        	.xit:
FFFC2B34 00073083		ldo		$ra,[$sp]
FFFC2B38 00870713		add		$sp,$sp,#8
FFFC2B3C 00008067		ret
                        	
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/tcb.r5a",1
                        	.file "../fmtk/tcb.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	.file "../fmtk/tcb.r5a",25
                        		code
                        		align	4                        	
                        	;------------------------------------------------------------------------------
                        	; Insert task into ready list. The list is a doubly linked circular list.
                        	;
                        	; Parameters:
                        	;		a0 = tid to insert
                        	; Modifies:
                        	;		v1,t0,t1,t2
                        	; Returns:
                        	;		v0 = 1 for success, 0 if failed
                        	;------------------------------------------------------------------------------
                        	
                        	InsertIntoReadyList:
FFFC2B40 00006813		ldi		$v0,#E_Ok						; setup for ok
FFFC2B44 03F06893		ldi		$v1,#MAX_TID				; check argument
FFFC2B48 0928EA63		bgtu	$a0,$v1,.badTid
FFFC2B4C 00A91E93		sll		$t3,$a0,#LOG_TCBSZ	; tid to pointer
FFFC2B50 288ECD03		ldbu	$t0,TCBStatus[$t3]	; set status to ready
FFFC2B54 001D6D13		or		$t0,$t0,#TS_READY
FFFC2B58 29AE8423		sb		$t0,TCBStatus[$t3]
FFFC2B5C 289E8D03		ldb		$t0,TCBPriority[$t3]
FFFC2B60 19A9000D		insrdy	$a0,$t0
	ret
FFFC2B64 00008067
FFFC2B68 003D7D13		and		$t0,$t0,#3					; limit to four
FFFC2B6C 001D1D13		sll		$t0,$t0,#1					; *2 for indexing
FFFC2B70 00024637		ldw		$t1,READYQ[$t0]			; get head of queue for that priority
FFFC2B74 30860613
FFFC2B78 01A60633
FFFC2B7C 00061D83
FFFC2B80 020DD063		bge		$t1,$x0,.insert			; Is there a head?
                        		; level 0 insert - nothing in list, create a ring to self
FFFC2B84 00024637		stw		$a0,READYQ[$t0]			; no head, simple to insert
FFFC2B88 30860613
FFFC2B8C 01A60633
FFFC2B90 01261023
FFFC2B94 2D2E9823		stw		$a0,TCBNext[$t3]		; remember it's a ring
FFFC2B98 2D2E9C23		stw		$a0,TCBPrev[$t3]
FFFC2B9C 00008067		ret
                        		; Insert at tail of list, which is just before the head.
                        	.insert:
FFFC2BA0 00AD9F13		sll		$t4,$t1,#LOG_TCBSZ	; tid to pointer
FFFC2BA4 2D8F1E03		ldw		$t2,TCBPrev[$t4]		; t2 = head->prev
FFFC2BA8 01BE1C63		bne		$t2,$t1,.level2
                        		;level 1 insert - only 1 item currently in list, items point to each other
                        		; This bit probably redundant code as normal insertion should work as well.
FFFC2BAC 2D2F1C23		stw		$a0,TCBPrev[$t4]		; simple to insert
FFFC2BB0 2D2F1823		stw		$a0,TCBNext[$t4]		; head->prev = head->next = arg
FFFC2BB4 2DBE9C23		stw		$t1,TCBPrev[$t3]		; arg->prev = arg->next = head
FFFC2BB8 2DBE9823		stw		$t1,TCBNext[$t3]
FFFC2BBC 00008067		ret
                        		; Here there will be three or more entries in the list. Arg is inserted
                        		; between head and head->prev to make it the last on the list.
                        	.level2:
FFFC2BC0 2DCE9C23		stw		$t2,TCBPrev[$t3]		; arg->prev = head->prev
FFFC2BC4 2DBE9823		stw		$t1,TCBNext[$t3]		; arg->next = head, arg links are now set
                        		; If there's a head there should be a head->prev and head->next at least pointing to the head
FFFC2BC8 000E4663		bltz	$t2,.0001						; head->prev valid?
FFFC2BCC 00AE1E93		sll		$t3,$t2,#LOG_TCBSZ	; t3 = head->prev (as a pointer)
FFFC2BD0 2D2E9823		stw		$a0,TCBNext[$t3]		; head->prev->next = arg
                        	.0001:
FFFC2BD4 2D2F1C23		stw		$a0,TCBPrev[$t4]		; head->prev = arg
FFFC2BD8 00008067		ret
                        	.badTid:
FFFC2BDC 00106813		ldi		$v0,#E_Arg
FFFC2BE0 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; The ready list is a doubly linked list to make it easier and faster to
                        	; remove items from the list. There's no need to search the list for the item
                        	; to remove.
                        	;
                        	; Parameters:
                        	;		a0 = tid to remove
                        	; Modifies:
                        	;		t0,t1,t2,t3,t4,t5
                        	; Returns:
                        	;		v0 = E_Ok for success
                        	;------------------------------------------------------------------------------
                        	
                        	RemoveFromReadyList:
FFFC2BE4 03F06893		ldi		$v1,#MAX_TID					; check arg
FFFC2BE8 0128F863		bleu	$a0,$v1,.tidOk
FFFC2BEC 00106813		ldi		$v0,#E_Arg
FFFC2BF0 00000637		jmp		ERETx
FFFC2BF4 22B60067
                        	.tidOk:
FFFC2BF8 1A09000D		rmvrdy	$a0									; cheat and use hardware
FFFC2BFC 00A91F13		sll		$t4,$a0,#LOG_TCBSZ		; s1 = pointer to tcb
FFFC2C00 288F0D03		ldb		$t0,TCBStatus[$t4]		; set status no longer ready or running
FFFC2C04 F7ED7D13		and		$t0,$t0,#~(TS_READY|TS_RUNNING)
	stb		$t0,TCBStatus[$t4]
FFFC2C08 29AF0423
FFFC2C0C 00008067		ret
                        	
                        	RemoveFromReadyList2:
FFFC2C10 03F06893		ldi		$v1,#MAX_TID					; check arg
FFFC2C14 0928E063		bgtu	$a0,$v1,.badTid
FFFC2C18 00A91F13		sll		$t4,$a0,#LOG_TCBSZ		; s1 = pointer to tcb
FFFC2C1C 288F0D03		ldb		$t0,TCBStatus[$t4]		; set status no longer ready or running
FFFC2C20 F7ED7D13		and		$t0,$t0,#~(TS_READY|TS_RUNNING)
	stb		$t0,TCBStatus[$t4]
FFFC2C24 29AF0423
FFFC2C28 289F0D03		ldb		$t0,TCBPriority[$t4]	; t0 = priority
FFFC2C2C 003D7D13		and		$t0,$t0,#3						; limit to 0-3
FFFC2C30 001D1D13		sll		$t0,$t0,#1						; *2 for indexing
FFFC2C34 00024637		ldw		$t1,READYQ[$t0]				; get head tid
FFFC2C38 30860613
FFFC2C3C 01A60633
FFFC2C40 00061D83
FFFC2C44 2D0F1E03		ldw		$t2,TCBNext[$t4]			; get arg->next
FFFC2C48 012D9E63		bne		$t1,$a0,.0001					; removing head of list?
FFFC2C4C 012E1463		bne		$t2,$a0,.0003					; list emptying? (if arg->next points back to arg)
FFFC2C50 FFF06E13		ldi		$t2,#-1
                        	.0003:
FFFC2C54 00024637		stw		$t2,READYQ[$t0]				; yes, set new head to arg->next
FFFC2C58 30860613
FFFC2C5C 01A60633
FFFC2C60 01C61023
                        	.0001:
FFFC2C64 000E4E63		bltz	$t2,.0002							; validate t2 (arg->next)
FFFC2C68 011E7C63		bgeu	$t2,$v1,.0002					; there should always be an arg->next, arg->prev
FFFC2C6C 2D8F1E83		ldw		$t3,TCBPrev[$t4]			; because the list is circular t3=arg->prev
FFFC2C70 00AE9F93		sll		$t5,$t3,#LOG_TCBSZ		; t5 = arg->prev as a pointer
FFFC2C74 2DCF9823		stw		$t2,TCBNext[$t5]			; arg->prev->next = arg->next
FFFC2C78 00AE1F93		sll		$t5,$t2,#LOG_TCBSZ		; t5 = arg->next as a pointer
FFFC2C7C 2DDF9C23		stw		$t3,TCBPrev[$t5]			; arg->next->prev = arg->prev
                        		; Now indicate links in TCB are not in use.
                        	.0002:
FFFC2C80 FFF06813		ldi		$v0,#-1
FFFC2C84 2D0F1823		stw		$v0,TCBNext[$t4]
FFFC2C88 2D0F1C23		stw		$v0,TCBPrev[$t4]
FFFC2C8C 00006813		ldi		$v0,#E_Ok							; we're ok
FFFC2C90 00008067		ret
                        	.badTid:
FFFC2C94 00106813		ldi		$v0,#E_Arg
FFFC2C98 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = task id to insert
                        	;		a1 = timeout value
                        	; Modifies:
                        	;		t0,t1,t2,t3,t4,t5
                        	;------------------------------------------------------------------------------
                        	
                        	InsertIntoTimeoutList:
FFFC2C9C 1139000D		setto	$a0,$a1
	sll		$t5,$a0,#LOG_TCBSZ		; tid to pointer
FFFC2CA0 00A91F93
FFFC2CA4 288FCE03		ldbu	$t2,TCBStatus[$t5]		; set status to timing out
FFFC2CA8 010E6E13		or		$t2,$t2,#TS_TIMEOUT
FFFC2CAC 29CF8423		stb		$t2,TCBStatus[$t5]
FFFC2CB0 00006813		ldi		$v0,#E_Ok
FFFC2CB4 00008067		ret
FFFC2CB8 FFF06D13		ldi		$t0,#-1						
FFFC2CBC 2DAF9823		stw		$t0,TCBNext[$t5]			; initialize indexes to -1
FFFC2CC0 2DAF9C23		stw		$t0,TCBPrev[$t5]
FFFC2CC4 00024637		ldw		$t0,TimeoutList
FFFC2CC8 32860613
FFFC2CCC 00060633
FFFC2CD0 00061D03
FFFC2CD4 020D5063		bge		$t0,$x0,.0001
                        		; Here the timeout list was empty, easy to insert.
FFFC2CD8 2F3FA023		stt		$a1,TCBTimeout[$t5]		; set timeout for task
FFFC2CDC 00024637		stw		$a0,TimeoutList				; set head of list
FFFC2CE0 32860613
FFFC2CE4 00060633
FFFC2CE8 01261023
FFFC2CEC 00006813		ldi		$v0,#E_Ok							; and return
FFFC2CF0 00008067		ret
                        	.0001:
FFFC2CF4 FFF06D93		ldi		$t1,#-1								; t1 used as previous index
FFFC2CF8 000D6E33		mov		$t2,$t0								; t2 = head of timeout list index
FFFC2CFC 00AE1E93		sll		$t3,$t2,#LOG_TCBSZ		; t3 = head of timeout list as a pointer
                        		; Search the timeout list for the proper insertion point. The timeouts are
                        		; relative, so the requested amount is decremented by the amounts in the
                        		; list as it is searched.
                        	.beginWhile:
FFFC2D00 2E0EAF03		ldt		$t4,TCBTimeout[$t3]		; get the timeout
FFFC2D04 033F5663		ble		$a1,$t4,.endWhile			; is it greater than the requested timeout ?
FFFC2D08 41E989B3		sub		$a1,$a1,$t4						; decrement by list amount
FFFC2D0C 000EEDB3		mov		$t1,$t3								; t1 = pointer to previous entry
FFFC2D10 2D0E9E83		ldw		$t3,TCBNext[$t3]			; get the next entry in list
FFFC2D14 000EC663		bltz	$t3,.endOfList					; end of list?
FFFC2D18 00AE9E93		sll		$t3,$t3,#LOG_TCBSZ		; no, set pointer to current entry
FFFC2D1C FFBE92E3		bne		$t3,$t1,.beginWhile		; list screwed up? (This test should always be true)
                        	.endOfList:
                        		; Here the end of the list was reached, insert as last entry
FFFC2D20 2D2D9823		stw		$a0,TCBNext[$t1]			; entry->next = arg
FFFC2D24 2DBF9C23		stw		$t1,TCBPrev[$t5]			; arg->prev = entry
FFFC2D28 2F3FA023		stt		$a1,TCBTimeout[$t5]
FFFC2D2C 04000063		bra		.0003
                        	.endWhile:
                        		; Here we found a timeout greater than the requested amount. Insert before.
FFFC2D30 20AEDE13		sra		$t2,$t3,#LOG_TCBSZ		; pointer to tid
FFFC2D34 2DCF9823		stw		$t2,TCBNext[$t5]			; arg->next = entry
FFFC2D38 20ADDE13		sra		$t2,$t1,#LOG_TCBSZ
FFFC2D3C 2DCF9C23		stw		$t2,TCBPrev[$t5]			; arg->prev = prev entry
FFFC2D40 2E0EAE03		ldt		$t2,TCBTimeout[$t3]		; update timeout of entry by subtracting off
FFFC2D44 413E0E33		sub		$t2,$t2,$a1						; the arg's timeout
FFFC2D48 2FCEA023		stt		$t2,TCBTimeout[$t3]
FFFC2D4C 2D2E9C23		stw		$a0,TCBPrev[$t3]			; entry->prev = arg
FFFC2D50 000DC663		bltz	$t1,.0002							; previous entry? no - go update list head
FFFC2D54 2D2D9823		stw		$a0,TCBNext[$t1]			; prev entry->next = arg
FFFC2D58 00000A63		bra		.0003
                        	.0002:
FFFC2D5C 00024637		stw		$a0,TimeoutList				; list head = arg
FFFC2D60 32860613
FFFC2D64 00060633
FFFC2D68 01261023
                        	.0003:
FFFC2D6C 288FCE03		ldbu	$t2,TCBStatus[$t5]		; set status to timing out
FFFC2D70 010E6E13		or		$t2,$t2,#TS_TIMEOUT
FFFC2D74 29CF8423		stb		$t2,TCBStatus[$t5]
FFFC2D78 00006813		ldi		$v0,#E_Ok
FFFC2D7C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Remove a task from the timeout list. The timeouts of following tasks are
                        	; adjusted. Called when a mailbox is freed and a task is waiting at the
                        	; mailbox. From within scheduling code mPopTimeoutList is used instead.
                        	;
                        	; Parameters:
                        	;		a0 = task id to remove
                        	; Modifies:
                        	;		t0,t3,t4
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	RemoveFromTimeoutList:
FFFC2D80 00A91E93		sll		$t3,$a0,#LOG_TCBSZ		; tid to pointer
FFFC2D84 288ECD03		ldbu	$t0,TCBStatus[$t3]		; check if waiting at a mailbox
FFFC2D88 008D7D13		and		$t0,$t0,#TS_WAITMSG
FFFC2D8C 000D0463		beqz	$t0,.noWait				
FFFC2D90 9E9FF0EF		call	MbxRemoveTask					; remove task from mailbox
                        	.noWait:
FFFC2D94 FE7D7D13		and		$t0,$t0,#~(TS_TIMEOUT|TS_WAITMSG)
	stb		$t0,TCBStatus[$t3]
FFFC2D98 29AE8423
FFFC2D9C 1009000D		setto	$a0,$x0
	ldi		$v0,#E_Ok
FFFC2DA0 00006813
FFFC2DA4 00008067		ret
                        	
FFFC2DA8 00024637		ldw		$t1,TimeoutList
FFFC2DAC 32860613
FFFC2DB0 00060633
FFFC2DB4 00061D83
FFFC2DB8 2D0E9D03		ldw		$t0,TCBNext[$t3]			; t0 = arg->next
FFFC2DBC 01B91A63		bne		$a0,$t1,.0001					; check removing head of list
FFFC2DC0 00024637		stw		$t0,TimeoutList				; set new head = arg->next
FFFC2DC4 32860613
FFFC2DC8 00060633
FFFC2DCC 01A61023
                        	.0001:
FFFC2DD0 020D4063		bltz	$t0,.noNext
FFFC2DD4 00AD1F13		sll		$t4,$t0,#LOG_TCBSZ
FFFC2DD8 2D8E9D83		ldw		$t1,TCBPrev[$t3]			; next->prev = arg->prev
FFFC2DDC 2DBF1C23		stw		$t1,TCBPrev[$t4]			
FFFC2DE0 2E0F2D83		ldt		$t1,TCBTimeout[$t4]		; next->timeout += arg->timeout
FFFC2DE4 2E0EAE03		ldt		$t2,TCBTimeout[$t3]
FFFC2DE8 01CD8DB3		add		$t1,$t1,$t2
FFFC2DEC 2FBF2023		stt		$t1,TCBTimeout[$t4]
                        	.noNext:
FFFC2DF0 2D8E9D03		ldw		$t0,TCBPrev[$t3]			; check for previous
FFFC2DF4 000D4863		bltz	$t0,.noPrev
FFFC2DF8 00AD1F13		sll		$t4,$t0,#LOG_TCBSZ
FFFC2DFC 2D0E9D03		ldw		$t0,TCBNext[$t3]			; prev->next = arg->next
FFFC2E00 2DAF1823		stw		$t0,TCBNext[$t4]
                        	.noPrev:
FFFC2E04 288E8D03		ldb		$t0,TCBStatus[$t3]		; no longer timing out
FFFC2E08 FE7D7D13		and		$t0,$t0,#~(TS_TIMEOUT|TS_WAITMSG)
	stb		$t0,TCBStatus[$t3]
FFFC2E0C 29AE8423
FFFC2E10 FFF06D13		ldi		$t0,#-1								; reset links
FFFC2E14 2DAE9823		stw		$t0,TCBNext[$t3]
FFFC2E18 2DAE9C23		stw		$t0,TCBPrev[$t3]
FFFC2E1C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Returns:
                        	;		v1 = process id
                        	;------------------------------------------------------------------------------
                        	
                        	AllocTCB:
FFFC2E20 00006D93		ldi		$t1,#0
FFFC2E24 00024637		ldwu	$v1,PIDMAP
FFFC2E28 31060613
FFFC2E2C 00060633
FFFC2E30 00065883
                        	.0001:
FFFC2E34 0018FD13		and		$t0,$v1,#1
FFFC2E38 020D0463		beqz	$t0,.allocTid
FFFC2E3C 0018D893		srl		$v1,$v1,#1
FFFC2E40 00008637		or		$v1,$v1,#$8000
FFFC2E44 00060613
FFFC2E48 011668B3
FFFC2E4C 001D8D93		add		$t1,$t1,#1
FFFC2E50 00FDFD93		and		$t1,$t1,#15
FFFC2E54 FE0D90E3		bne		$t1,$x0,.0001
                        	; here no tcbs available
FFFC2E58 04506813		ldi		$v0,#E_NoMoreTCBs
FFFC2E5C 00008067		ret
                        	.allocTid:
FFFC2E60 000DE833		mov		$v0,$t1
FFFC2E64 0018E893		or		$v1,$v1,#1
FFFC2E68 000D8A63		beqz	$t1,.0003
                        	.0002:
FFFC2E6C 00189893		sll		$v1,$v1,#1
FFFC2E70 0018E893		or		$v1,$v1,#1
FFFC2E74 FFFD8D93		sub		$t1,$t1,#1
FFFC2E78 FE0D9AE3		bnez	$t1,.0002
                        	.0003:
FFFC2E7C 00024637		stw		$v1,PIDMAP
FFFC2E80 31060613
FFFC2E84 00060633
FFFC2E88 01161023
FFFC2E8C 000868B3		mov		$v1,$v0
FFFC2E90 00006813		ldi		$v0,#E_Ok
FFFC2E94 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	
                        	FreeTCB:
FFFC2E98 00106D13		ldi		$t0,#1
FFFC2E9C 012D1D33		sll		$t0,$t0,$a0
FFFC2EA0 FFFD4D13		xor		$t0,$t0,#-1
FFFC2EA4 00024637		lhu		$t1,PIDMAP
FFFC2EA8 31060613
FFFC2EAC 00060633
FFFC2EB0 00065D83
FFFC2EB4 01ADFDB3		and		$t1,$t1,$t0
FFFC2EB8 00024637		stw		$t1,PIDMAP
FFFC2EBC 31060613
FFFC2EC0 00060633
FFFC2EC4 01B61023
FFFC2EC8 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Diagnostics
                        	;------------------------------------------------------------------------------
                        	
                        	DumpReadyList:
FFFC2ECC FC070713		sub		$sp,$sp,#64
FFFC2ED0 00173023		sto		$ra,[$sp]
FFFC2ED4 01273423		sto		$a0,8[$sp]
FFFC2ED8 01473823		sto		$a2,16[$sp]
FFFC2EDC 01573C23		sto		$a3,24[$sp]
FFFC2EE0 03B73023		sto		$t1,32[$sp]
FFFC2EE4 03C73423		sto		$t2,40[$sp]
FFFC2EE8 03D73823		sto		$t3,48[$sp]
FFFC2EEC 02473C23		sto		$s1,56[$sp]
FFFC2EF0 FFFC3937		ldi		$a0,#msgReadyList
FFFC2EF4 05C90913
FFFC2EF8 901FD0EF		call	PutString
FFFC2EFC 00006D93		ldi		$t1,#0
FFFC2F00 3000F273		csrrc	$s1,#$300,#1
                        	.0002:
FFFC2F04 D70FE0EF		call	SerialPeekCharDirect
FFFC2F08 00384813		xor		$v0,$v0,#CTRLC
FFFC2F0C 08080263		beqz	$v0,.brk
FFFC2F10 00D06913		ldi		$a0,#CR
FFFC2F14 B68FD0EF		call	Putch
FFFC2F18 05106913		ldi		$a0,#'Q'
FFFC2F1C B60FD0EF		call	Putch
FFFC2F20 001DD913		srl		$a0,$t1,#1
FFFC2F24 895FD0EF		call	PutHexNybble
FFFC2F28 03A06913		ldi		$a0,#':'
FFFC2F2C B50FD0EF		call	Putch
FFFC2F30 00024637		ldw		$a2,READYQ[$t1]
FFFC2F34 30860613
FFFC2F38 01B60633
FFFC2F3C 00061A03
FFFC2F40 040A4263		blt		$a2,$x0,.nxt
FFFC2F44 000A6AB3		mov		$a3,$a2
                        	.0001:
FFFC2F48 000AE933		mov		$a0,$a3
FFFC2F4C 82DFD0EF		call	PutHexHalf
FFFC2F50 02006913		ldi		$a0,#' '
FFFC2F54 B28FD0EF		call	Putch
FFFC2F58 00AA9A93		sll		$a3,$a3,#LOG_TCBSZ
FFFC2F5C 2D0A9903		ldw		$a0,TCBNext[$a3]
FFFC2F60 819FD0EF		call	PutHexHalf
FFFC2F64 02006913		ldi		$a0,#' '
FFFC2F68 B14FD0EF		call	Putch
FFFC2F6C 2D8A9903		ldw		$a0,TCBPrev[$a3]
FFFC2F70 809FD0EF		call	PutHexHalf
FFFC2F74 00D06913		ldi		$a0,#CR
FFFC2F78 B04FD0EF		call	Putch
FFFC2F7C 2D0A9A83		ldw		$a3,TCBNext[$a3]
FFFC2F80 FD5A14E3		bne		$a2,$a3,.0001
                        	.nxt:
FFFC2F84 002D8D93		add		$t1,$t1,#2
FFFC2F88 008DAE13		slt		$t2,$t1,#8
FFFC2F8C F60E1CE3		bnez	$t2,.0002
                        	.brk:
FFFC2F90 30021073		csrrw	$x0,#$300,$s1
FFFC2F94 00073083		ldo		$ra,[$sp]
FFFC2F98 00873903		ldo		$a0,8[$sp]
FFFC2F9C 01073A03		ldo		$a2,16[$sp]
FFFC2FA0 01873A83		ldo		$a3,24[$sp]
FFFC2FA4 02073D83		ldo		$t1,32[$sp]
FFFC2FA8 02873E03		ldo		$t2,40[$sp]
FFFC2FAC 03073E83		ldo		$t3,48[$sp]
FFFC2FB0 03873203		ldo		$s1,56[$sp]
FFFC2FB4 04070713		add		$sp,$sp,#64
FFFC2FB8 00008067		ret
                        	
                        	DumpTimeoutList:
FFFC2FBC FE070713		sub		$sp,$sp,#32
FFFC2FC0 00172023		stt		$ra,[$sp]
FFFC2FC4 01272223		stt		$a0,4[$sp]
FFFC2FC8 01472423		stt		$a2,8[$sp]
FFFC2FCC 01572623		stt		$a3,12[$sp]
FFFC2FD0 01B72823		stt		$t1,16[$sp]
FFFC2FD4 01C72A23		stt		$t2,20[$sp]
FFFC2FD8 01D72C23		stt		$t3,24[$sp]
FFFC2FDC 00472E23		stt		$s1,28[$sp]
FFFC2FE0 FFFC3937		ldi		$a0,#msgTimeoutList
FFFC2FE4 08D90913
FFFC2FE8 811FD0EF		call	PutString
FFFC2FEC 00006D93		ldi		$t1,#0
FFFC2FF0 3000F273		csrrc	$s1,#$300,#1
FFFC2FF4 00006A93		ldi		$a3,#0
                        	.0002:
FFFC2FF8 C7CFE0EF		call	SerialPeekCharDirect
FFFC2FFC 00384813		xor		$v0,$v0,#CTRLC
FFFC3000 02080863		beqz	$v0,.brk
FFFC3004 00D06913		ldi		$a0,#CR
FFFC3008 A74FD0EF		call	Putch
                        	;	ldw		$a2,TimeoutList
                        	;	bltz	$a2,.brk
                        	;	mov		$a3,$a2
                        	;.0001:
FFFC300C 000AE933		mov		$a0,$a3
FFFC3010 F68FD0EF		call	PutHexHalf
FFFC3014 02D06913		ldi		$a0,#'-'
FFFC3018 A64FD0EF		call	Putch
FFFC301C 120D890D		getto	$a0,$t1
;	sll		$a3,$a3,#LOG_TCBSZ
                        	;	ldt		$a0,TCBTimeout[$a3]
FFFC3020 F38FD0EF		call	PutHexWord
                        	;	ldi		$a0,#CR
                        	;	call	Putch
FFFC3024 001A8A93		add		$a3,$a3,#1
FFFC3028 00FAFA93		and		$a3,$a3,#15
FFFC302C FD5046E3		bgt		$a3,$x0,.0002
                        	;	ldw		$a3,TCBNext[$a3]
                        	;	bge		$a3,$x0,.0001
                        	.brk:
FFFC3030 30021073		csrrw	$x0,#$300,$s1
FFFC3034 00072083		ldt		$ra,[$sp]
FFFC3038 00472903		ldt		$a0,4[$sp]
FFFC303C 00872A03		ldt		$a2,8[$sp]
FFFC3040 00C72A83		ldt		$a3,12[$sp]
FFFC3044 01072D83		ldt		$t1,16[$sp]
FFFC3048 01472E03		ldt		$t2,20[$sp]
FFFC304C 01872E83		ldt		$t3,24[$sp]
FFFC3050 01C72203		ldt		$s1,28[$sp]
FFFC3054 02070713		add		$sp,$sp,#32
FFFC3058 00008067		ret
                        	
                        	msgReadyList:
FFFC305C 6165520D		db	CR,"Ready List",CR
FFFC3060 4C207964
FFFC3064 0D747369
FFFC3068 20657551		db	"Que Tid  Prv  Nxt",CR
FFFC306C 20646954
FFFC3070 76725020
FFFC3074 784E2020
FFFC3078 2D2D0D74
FFFC307A 2D2D2D2D		db	"-----------------",CR,0
FFFC307E 2D2D2D2D
FFFC3082 2D2D2D2D
FFFC3086 2D2D2D2D
FFFC308A 0D000D2D
                        	
                        	msgTimeoutList:
FFFC308D 6D69540D		db	CR,"Timeout List",CR
FFFC3091 74756F65
FFFC3095 73694C20
FFFC3099 54200D74
FFFC309B 64695420		db	" Tid - Timeout",CR
FFFC309F 54202D20
FFFC30A3 6F656D69
FFFC30A7 2D0D7475
FFFC30AA 2D2D2D2D		db	"--------------",CR,0
FFFC30AE 2D2D2D2D
FFFC30B2 2D2D2D2D
FFFC30B6 000D2D2D
                        	
FFFC30BA E0730000		align 
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/iofocus.r5a",1
                        	.file "../fmtk/iofocus.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;-----------------------------------------------------------------------------
                        	; IO Focus routines complicated by the fact that the base address of TCB
                        	; zero is zero (looks like a null pointer but isn't). So the value -1 is 
                        	; used to indicate no focus index.
                        	;-----------------------------------------------------------------------------
                        	
                        	.file "../fmtk/iofocus.r5a",31
                        		code
                        		align	4                        	
                        	
                        	;-----------------------------------------------------------------------------
                        	; Determine if the currently running task has the I/O focus.
                        	;
                        	; Stack Space:
                        	;		2 words
                        	; Parameters:
                        	;		none
                        	; Modifies:
                        	;		none
                        	; Returns:
                        	;		v0 = E_Ok
                        	;		v1 = 1 if task has IO focus, 0 otherwise
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_HasIOFocus:
                        		; Enable interrupts
FFFC30BC 3000E073		csrrs	$x0,#$300,#1				
FFFC30C0 00025637		ldb		$v0,SwitchIOFocus
FFFC30C4 82060613
FFFC30C8 00060633
FFFC30CC 00060803
FFFC30D0 00080C63		beqz	$v0,.noSwitch
FFFC30D4 00025637		stb		$x0,SwitchIOFocus
FFFC30D8 82060613
FFFC30DC 00060633
FFFC30E0 00060023
FFFC30E4 038000EF		call	FMTK_SwitchIOFocus
                        	.noSwitch:
                        		
FFFC30E8 18101873		csrrw	v0,#$181,x0
FFFC30EC 03F87813		and		v0,v0,#MAX_TID
FFFC30F0 00A81813	sll		$v0,$v0,#LOG_TCBSZ
FFFC30F4 00025637		ldo		$v1,IOFocusNdx
FFFC30F8 81060613
FFFC30FC 00060633
FFFC3100 00063883
FFFC3104 01180663		beq		$v0,$v1,.hasFocus
FFFC3108 00006893		ldi		$v1,#0
FFFC310C 00000463		bra		.xit
                        	.hasFocus:
FFFC3110 00106893		ldi		$v1,#1
                        	.xit:
FFFC3114 00006813		ldi		$v0,#E_Ok
FFFC3118 00008067		ret
                        	
                        	;-----------------------------------------------------------------------------
                        	; First check if it's even possible to switch the focus to another
                        	; task. The I/O focus list could be empty or there may be only a
                        	; single task in the list. In either case it's not possible to
                        	; switch.
                        	;
                        	;	Parameters:
                        	;		none
                        	;	Modifies:
                        	;		a0,a1,t0,t1,t2,t3
                        	;	Returns:
                        	;		v0 = E_Ok
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_SwitchIOFocus:
FFFC311C FF870713		sub		$sp,$sp,#8
FFFC3120 00173023		sto		$ra,[$sp]
FFFC3124 00025637		ldo		$t0,IOFocusNdx			; get focus pointer
FFFC3128 81060613
FFFC312C 00060633
FFFC3130 00063D03
FFFC3134 080D4E63		bltz	$t0,.noFocus				; is it -1?
FFFC3138 2E8D3D83		ldo		$t1,IOF_NEXT[$t0]
FFFC313C 09AD8A63		beq		$t1,$t0,.sameFocus
FFFC3140 080DC863		bltz	$t1,.noFocus
FFFC3144 3000E073		csrrs	$x0,#$300,#1				; enable interrupts
                        		; swap virtual text screens
FFFC3148 65806213		ldi		$s1,#56*29
FFFC314C 330D3E03		ldo		$t2,TCBVideoMem[$t0]
FFFC3150 020E0A63		beqz	$t2,.0002
FFFC3154 33CD3C23		sto		$t2,TCBpVideo[$t0]
FFFC3158 FFD00EB7		ldi		$t3,#$FFD00000
FFFC315C 000E8E93
FFFC3160 00AD5913		srl		$a0,$t0,#LOG_TCBSZ
FFFC3164 000E69B3		mov		$a1,$t2
FFFC3168 F0DFD0EF		call	VirtToPhys
                        	.0001:
FFFC316C 000EBF03		ldo		$t4,[$t3]
FFFC3170 01E83023		sto		$t4,[$v0]
FFFC3174 008E8E93		add		$t3,$t3,#8
FFFC3178 00880813		add		$v0,$v0,#8
FFFC317C FFF20213		sub		$s1,$s1,#1
FFFC3180 FE4046E3		bgt		$s1,$x0,.0001
                        	.0002:
FFFC3184 65806213		ldi		$s1,#56*29
FFFC3188 330DBE03		ldo		$t2,TCBVideoMem[$t1]
FFFC318C 020E0A63		beqz	$t2,.0004
FFFC3190 FFD00EB7		ldi		$t3,#$FFD00000
FFFC3194 000E8E93
FFFC3198 33DDBC23		sto		$t3,TCBpVideo[$t1]
FFFC319C 00ADD913		srl		$a0,$t1,#LOG_TCBSZ
FFFC31A0 000E69B3		mov		$a1,$t2
FFFC31A4 ED1FD0EF		call	VirtToPhys
                        	.0003:
FFFC31A8 00083F03		ldo		$t4,[$v0]
FFFC31AC 01EEB023		sto		$t4,[$t3]
FFFC31B0 008E8E93		add		$t3,$t3,#8
FFFC31B4 00880813		add		$v0,$v0,#8
FFFC31B8 FFF20213		sub		$s1,$s1,#1
FFFC31BC FE4046E3		bgt		$s1,$x0,.0003
                        	.0004:
FFFC31C0 00025637		sto		$t1,IOFocusNdx
FFFC31C4 81060613
FFFC31C8 00060633
FFFC31CC 01B63023
                        	.sameFocus:
                        	.noFocus:
FFFC31D0 00006813		ldi		$v0,E_Ok
FFFC31D4 00073083		ldo		$ra,[$sp]
FFFC31D8 00870713		add		$sp,$sp,#8
FFFC31DC 00008067		ret
                        	
                        	;-----------------------------------------------------------------------------
                        	; The I/O focus list is an array indicating which jobs are requesting the
                        	; I/O focus. The I/O focus is user controlled by pressing CNTRL-T on the
                        	; keyboard.
                        	;
                        	; Parameters:
                        	;		a1 = task id requesting focus for
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_RequestIOFocus:
FFFC31E0 00106D13		ldi		$t0,#1
FFFC31E4 013D1D33		sll		$t0,$t0,$a1
FFFC31E8 00025637		ldo		$t1,IOFocusTbl			; Is the task already included in the IO focus?
FFFC31EC 81860613
FFFC31F0 00060633
FFFC31F4 00063D83
FFFC31F8 01ADFE33		and		$t2,$t1,$t0					; test bit
FFFC31FC 060E1463		bnez	$t2,.ret						; If so, don't add again
FFFC3200 01ADEDB3		or		$t1,$t1,$t0					; set bit indicator
FFFC3204 00025637		sto		$t1,IOFocusTbl
FFFC3208 81860613
FFFC320C 00060633
FFFC3210 01B63023
                        		; Disable interrupts while manipulating IO focus list
FFFC3214 3000F073		csrrc	$x0,#$300,#1				
FFFC3218 00025637		ldo		$t0,IOFocusNdx			; get current index
FFFC321C 81060613
FFFC3220 00060633
FFFC3224 00063D03
FFFC3228 00A99D93		sll		$t1,$a1,#LOG_TCBSZ	; t1 = pointer to TCB
FFFC322C 020D5063		bge		$t0,$x0,.notEmpty		; is there one? (!= -1)
FFFC3230 00025637		sto		$t1,IOFocusNdx			; no current index, so set equal to requester
FFFC3234 81060613
FFFC3238 00060633
FFFC323C 01B63023
FFFC3240 2FBDB423		sto		$t1,IOF_NEXT[$t1]		; and loop back to self
FFFC3244 2FBDB823		sto		$t1,IOF_PREV[$t1]
FFFC3248 00000E63		bra		.ret
                        	.notEmpty:
FFFC324C 2F0D3E03		ldo		$t2,IOF_PREV[$t0]		; insert t1 into focus ring
FFFC3250 2FCDB823		sto		$t2,IOF_PREV[$t1]
FFFC3254 2FADB423		sto		$t0,IOF_NEXT[$t1]
FFFC3258 2F0D3E03		ldo		$t2,IOF_PREV[$t0]
FFFC325C 2FBE3423		sto		$t1,IOF_NEXT[$t2]
FFFC3260 2FBD3823		sto		$t1,IOF_PREV[$t0]
                        	.ret:
FFFC3264 00006813		ldi		$v0,#E_Ok
FFFC3268 00008067		ret
                        	
                        	;-----------------------------------------------------------------------------
                        	; ReleaseIOFocus called when the task no longer desires to be on the I/O
                        	; focus list.
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_ReleaseIOFocus:
                        		
FFFC326C 18101873		csrrw	v0,#$181,x0
FFFC3270 03F87813		and		v0,v0,#MAX_TID
FFFC3274 000869B3	mov		$a1,$v0
                        		; fall into ForceReleaseIOFocus
                        	
                        	;-----------------------------------------------------------------------------
                        	; Releasing the I/O focus causes the focus to switch if the running job
                        	; had the I/O focus.
                        	; ForceReleaseIOFocus forces the release of the IO focus for a job
                        	; different than the one currently running.
                        	; 
                        	; Stack Space:
                        	;		2 words
                        	; Parameters:
                        	;		a1 = task id to release
                        	; Returns:
                        	;		v0 = E_Ok
                        	;-----------------------------------------------------------------------------
                        	
                        	FMTK_ForceReleaseIOFocus:
FFFC3278 3000E073		csrrs	$x0,#$300,#1				; enable interrupts
FFFC327C 00106D13		ldi		$t0,#1
FFFC3280 013D1D33		sll		$t0,$t0,$a1
FFFC3284 00025637		ldo		$t1,IOFocusTbl
FFFC3288 81860613
FFFC328C 00060633
FFFC3290 00063D83
FFFC3294 01ADFE33		and		$t2,$t1,$t0				; test bit for task
FFFC3298 080E0863		beq		$t2,$x0,.noFocus	; does it even have the focus?
FFFC329C FFFD4D13		xor		$t0,$t0,#-1				; get inverted mask
FFFC32A0 01ADFDB3		and		$t1,$t1,$t0				; clear bit for task
FFFC32A4 00025637		sto		$t1,IOFocusTbl
FFFC32A8 81860613
FFFC32AC 00060633
FFFC32B0 01B63023
FFFC32B4 00025637		ldo		$t1,IOFocusNdx		; check if the focus being released is the current
FFFC32B8 81060613
FFFC32BC 00060633
FFFC32C0 00063D83
FFFC32C4 00A99D13		sll		$t0,$a1,#LOG_TCBSZ	; io focus. If so, switch focus
FFFC32C8 03BD1063		bne		$t0,$t1,.notSame
FFFC32CC FF070713		sub		$sp,$sp,#16
FFFC32D0 01A73023		sto		$t0,[$sp]
FFFC32D4 01B73423		sto		$t1,8[$sp]
FFFC32D8 E45FF0EF		call	FMTK_SwitchIOFocus
FFFC32DC 00073D03		ldo		$t0,[$sp]
FFFC32E0 00873D83		ldo		$t1,8[$sp]
FFFC32E4 01070713		add		$sp,$sp,#16
                        	.notSame:
                        		; Disable interrupts while manipulating IO focus list
FFFC32E8 3000F073		csrrc	$x0,#$300,#1				
FFFC32EC 2E8D3E03		ldo		$t2,IOF_NEXT[$t0]
FFFC32F0 020E4C63		blt		$t2,$x0,.done
FFFC32F4 01AE0A63		beq		$t2,$t0,.pjSame
FFFC32F8 2F0D3D83		ldo		$t1,IOF_PREV[$t0]
FFFC32FC 2FBE3823		sto		$t1,IOF_PREV[$t2]
FFFC3300 2FCDB423		sto		$t2,IOF_NEXT[$t1]
FFFC3304 00000C63		bra		.0001
                        	.pjSame:
FFFC3308 FFF06D93		ldi		$t1,#-1
FFFC330C 00025637		sto		$t1,IOFocusNdx
FFFC3310 81060613
FFFC3314 00060633
FFFC3318 01B63023
                        	.0001:
FFFC331C FFF06D93		ldi		$t1,#-1
FFFC3320 2FBD3423		sto		$t1,IOF_NEXT[$t0]	
FFFC3324 2FBD3823		sto		$t1,IOF_PREV[$t0]	
                        	.done:
                        	.noFocus:
FFFC3328 00006813		ldi		$v0,#E_Ok
FFFC332C 00008067		ret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/io.r5a",1
                        	.file "../fmtk/io.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;Standard Devices are:
                        	
                        	;#		Device					Standard name
                        	
                        	;0		NULL device 			NUL		(OS built-in)
                        	;1		Keyboard (sequential)	KBD		(OS built-in)
                        	;2		Video (sequential)		VID		(OS built-in)
                        	;3		Printer (parallel 1)	LPT
                        	;4		Printer (parallel 2)	LPT2
                        	;5		RS-232 1				COM1	(OS built-in)
                        	;6		RS-232 2				COM2
                        	;7		RS-232 3				COM3
                        	;8		RS-232 4				COM4
                        	;9		Parallel xfer	  PTI
                        	;10		Floppy					FD0
                        	;11		Floppy					FD1
                        	;12		Hard disk				HD0
                        	;13		Hard disk				HD1
                        	;14
                        	;15   VIA							VIA1
                        	;16		SDCard					CARD1 	(OS built-in)
                        	;17
                        	;18
                        	;19
                        	;20
                        	;21
                        	;22
                        	;23
                        	;24
                        	;25
                        	;26
                        	;27
                        	;28		Audio						PSG1	(OS built-in)
                        	;29
                        	;30   Random Number		PRNG
                        	;31		Debug						DBG
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a1 = I/O channel
                        	;		a2 = function
                        	;		a3 = data
                        	;------------------------------------------------------------------------------
                        	
                        	FMTK_IO:
FFFC3330 02006813		ldi		$v0,#32
FFFC3334 0309FE63		bgeu	$a1,$v0,.badDev
FFFC3338 02006893		ldi		$v1,#32
FFFC333C 031A7663		bgeu	$a2,$v1,.badFunc
FFFC3340 00899813		sll		$v0,$a1,#8					; each device allowed 32 functions (*256)
FFFC3344 003A1893		sll		$v1,$a2,#3					; function number *8
FFFC3348 00022637		add		$v0,$v0,#DVF_Base		; base address of function table
FFFC334C 00060613
FFFC3350 01060833
FFFC3354 01186833		or		$v0,$v0,$v1
FFFC3358 00083803		ldo		$v0,[$v0]
FFFC335C 00080663		beq		$v0,$x0,.badFunc
FFFC3360 000800E7		call	[$v0]
                        	.xit:
FFFC3364 00008067		ret
                        	.badFunc:
FFFC3368 02206813		ldi		$v0,#E_BadDevOp
FFFC336C FE000CE3		bra		.xit
                        	.badDev:
FFFC3370 02006813		ldi		$v0,#E_BadDevNum
FFFC3374 FE0008E3		bra		.xit
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = I/O channel
                        	;		a1 = points to function table
                        	;------------------------------------------------------------------------------
                        	
                        	CopyDevFuncTbl:
FFFC3378 00891813		sll		$v0,$a0,#8					; each device allowed 32 functions (*256)
FFFC337C 00022637		add		$v0,$v0,#DVF_Base		; base address of function table
FFFC3380 00060613
FFFC3384 01060833
FFFC3388 02006D13		ldi		$t0,#32							; 32 functions to copy
                        	.again:
FFFC338C 0009BE03		ldo		$t2,[$a1]
FFFC3390 01C83023		sto		$t2,[$v0]
FFFC3394 00898993		add		$a1,$a1,#8
FFFC3398 00880813		add		$v0,$v0,#8
FFFC339C FFFD0D13		sub		$t0,$t0,#1
FFFC33A0 FFA046E3		bgt		$t0,$x0,.again
FFFC33A4 00008067		ret
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/scancodes.r5a",1
                        	.file "../fmtk/scancodes.r5a",1
                        		;--------------------------------------------------------------------------
                        		; PS2 scan codes to ascii conversion tables.
                        		;--------------------------------------------------------------------------
                        		;
                        		align	8                        	
                        	_unshiftedScanCodes:
FFFC33A8 A52EA92E		.byte	$2e,$a9,$2e,$a5,$a3,$a1,$a2,$ac
FFFC33AC ACA2A1A3
FFFC33B0 A6A8AA2E		.byte	$2e,$aa,$a8,$a6,$a4,$09,$60,$2e
FFFC33B4 2E6009A4
FFFC33B8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$71,$31,$2e
FFFC33BC 2E31712E
FFFC33C0 737A2E2E		.byte	$2e,$2e,$7a,$73,$61,$77,$32,$2e
FFFC33C4 2E327761
FFFC33C8 6478632E		.byte	$2e,$63,$78,$64,$65,$34,$33,$2e
FFFC33CC 2E333465
FFFC33D0 6676202E		.byte	$2e,$20,$76,$66,$74,$72,$35,$2e
FFFC33D4 2E357274
FFFC33D8 68626E2E		.byte	$2e,$6e,$62,$68,$67,$79,$36,$2e
FFFC33DC 2E367967
FFFC33E0 6A6D2E2E		.byte	$2e,$2e,$6d,$6a,$75,$37,$38,$2e
FFFC33E4 2E383775
FFFC33E8 696B2C2E		.byte	$2e,$2c,$6b,$69,$6f,$30,$39,$2e
FFFC33EC 2E39306F
FFFC33F0 6C2F2E2E		.byte	$2e,$2e,$2f,$6c,$3b,$70,$2d,$2e
FFFC33F4 2E2D703B
FFFC33F8 2E272E2E		.byte	$2e,$2e,$27,$2e,$5b,$3d,$2e,$2e
FFFC33FC 2E2E3D5B
FFFC3400 5D0D2EAD		.byte	$ad,$2e,$0d,$5d,$2e,$5c,$2e,$2e
FFFC3404 2E2E5C2E
FFFC3408 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
FFFC340C 2E082E2E
FFFC3410 932E952E		.byte	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
FFFC3414 2E2E2E94
FFFC3418 2E927F98		.byte	$98,$7f,$92,$2e,$91,$90,$1b,$af
FFFC341C AF1B9091
FFFC3420 2E972EAB		.byte	$ab,$2e,$97,$2e,$2e,$96,$ae,$2e
FFFC3424 2EAE962E
                        	
FFFC3428 A72E2E2E		.byte	$2e,$2e,$2e,$a7,$2e,$2e,$2e,$2e
FFFC342C 2E2E2E2E
FFFC3430 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3434 2E2E2E2E
FFFC3438 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC343C 2E2E2E2E
FFFC3440 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3444 2E2E2E2E
FFFC3448 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC344C 2E2E2E2E
FFFC3450 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3454 2E2E2E2E
FFFC3458 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC345C 2E2E2E2E
FFFC3460 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3464 2E2E2E2E
FFFC3468 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC346C 2E2E2E2E
FFFC3470 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3474 2E2E2E2E
FFFC3478 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC347C 2E2E2E2E
FFFC3480 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3484 2E2E2E2E
FFFC3488 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC348C 2E2E2E2E
FFFC3490 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3494 2E2E2E2E
FFFC3498 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC349C 2E2E2E2E
FFFC34A0 2EFA2E2E		.byte	$2e,$2e,$fa,$2e,$2e,$2e,$2e,$2e
FFFC34A4 2E2E2E2E
                        	
                        	_shiftedScanCodes:
FFFC34A8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC34AC 2E2E2E2E
FFFC34B0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
FFFC34B4 2E7E092E
FFFC34B8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$51,$21,$2e
FFFC34BC 2E21512E
FFFC34C0 535A2E2E		.byte	$2e,$2e,$5a,$53,$41,$57,$40,$2e
FFFC34C4 2E405741
FFFC34C8 4458432E		.byte	$2e,$43,$58,$44,$45,$24,$23,$2e
FFFC34CC 2E232445
FFFC34D0 4656202E		.byte	$2e,$20,$56,$46,$54,$52,$25,$2e
FFFC34D4 2E255254
FFFC34D8 48424E2E		.byte	$2e,$4e,$42,$48,$47,$59,$5e,$2e
FFFC34DC 2E5E5947
FFFC34E0 4A4D2E2E		.byte	$2e,$2e,$4d,$4a,$55,$26,$2a,$2e
FFFC34E4 2E2A2655
FFFC34E8 494B3C2E		.byte	$2e,$3c,$4b,$49,$4f,$29,$28,$2e
FFFC34EC 2E28294F
FFFC34F0 4C3F3E2E		.byte	$2e,$3e,$3f,$4c,$3a,$50,$5f,$2e
FFFC34F4 2E5F503A
FFFC34F8 2E222E2E		.byte	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
FFFC34FC 2E2E2B7B
FFFC3500 7D0D2E2E		.byte	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
FFFC3504 2E2E7C2E
FFFC3508 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
FFFC350C 2E082E2E
FFFC3510 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3514 2E2E2E2E
FFFC3518 2E2E7F2E		.byte	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
FFFC351C 2E1B2E2E
FFFC3520 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3524 2E2E2E2E
                        	
FFFC3528 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC352C 2E2E2E2E
FFFC3530 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3534 2E2E2E2E
FFFC3538 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC353C 2E2E2E2E
FFFC3540 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3544 2E2E2E2E
FFFC3548 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC354C 2E2E2E2E
FFFC3550 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3554 2E2E2E2E
FFFC3558 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC355C 2E2E2E2E
FFFC3560 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3564 2E2E2E2E
FFFC3568 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC356C 2E2E2E2E
FFFC3570 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3574 2E2E2E2E
FFFC3578 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC357C 2E2E2E2E
FFFC3580 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3584 2E2E2E2E
FFFC3588 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC358C 2E2E2E2E
FFFC3590 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3594 2E2E2E2E
FFFC3598 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC359C 2E2E2E2E
FFFC35A0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC35A4 2E2E2E2E
                        	
                        	; control
                        	_keybdControlCodes:
FFFC35A8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC35AC 2E2E2E2E
FFFC35B0 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
FFFC35B4 2E7E092E
FFFC35B8 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$11,$21,$2e
FFFC35BC 2E21112E
FFFC35C0 131A2E2E		.byte	$2e,$2e,$1a,$13,$01,$17,$40,$2e
FFFC35C4 2E401701
FFFC35C8 0418032E		.byte	$2e,$03,$18,$04,$05,$24,$23,$2e
FFFC35CC 2E232405
FFFC35D0 0616202E		.byte	$2e,$20,$16,$06,$14,$12,$25,$2e
FFFC35D4 2E251214
FFFC35D8 08020E2E		.byte	$2e,$0e,$02,$08,$07,$19,$5e,$2e
FFFC35DC 2E5E1907
FFFC35E0 0A0D2E2E		.byte	$2e,$2e,$0d,$0a,$15,$26,$2a,$2e
FFFC35E4 2E2A2615
FFFC35E8 090B3C2E		.byte	$2e,$3c,$0b,$09,$0f,$29,$28,$2e
FFFC35EC 2E28290F
FFFC35F0 0C3F3E2E		.byte	$2e,$3e,$3f,$0c,$3a,$10,$5f,$2e
FFFC35F4 2E5F103A
FFFC35F8 2E222E2E		.byte	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
FFFC35FC 2E2E2B7B
FFFC3600 7D0D2E2E		.byte	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
FFFC3604 2E2E7C2E
FFFC3608 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
FFFC360C 2E082E2E
FFFC3610 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3614 2E2E2E2E
FFFC3618 2E2E7F2E		.byte	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
FFFC361C 2E1B2E2E
FFFC3620 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3624 2E2E2E2E
                        	
                        	_keybdExtendedCodes:
FFFC3628 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$a3,$a1,$a2,$2e
FFFC362C 2EA2A1A3
FFFC3630 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3634 2E2E2E2E
FFFC3638 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC363C 2E2E2E2E
FFFC3640 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3644 2E2E2E2E
FFFC3648 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC364C 2E2E2E2E
FFFC3650 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3654 2E2E2E2E
FFFC3658 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC365C 2E2E2E2E
FFFC3660 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3664 2E2E2E2E
FFFC3668 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC366C 2E2E2E2E
FFFC3670 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3674 2E2E2E2E
FFFC3678 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC367C 2E2E2E2E
FFFC3680 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC3684 2E2E2E2E
FFFC3688 2E2E2E2E		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
FFFC368C 2E2E2E2E
FFFC3690 932E952E		.byte	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
FFFC3694 2E2E2E94
FFFC3698 2E929998		.byte	$98,$99,$92,$2e,$91,$90,$2e,$2e
FFFC369C 2E2E9091
FFFC36A0 2E972E2E		.byte	$2e,$2e,$97,$2e,$2e,$96,$2e,$2e
FFFC36A4 2E2E962E
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "../fmtk/keybd_driver_asm.r5a",1
                        	.file "../fmtk/keybd_driver_asm.r5a",1
                        	; ============================================================================
                        	;        __
                        	;   \\__/ o\    (C) 2020  Robert Finch, Stratford
                        	;    \  __ /    All rights reserved.
                        	;     \/_//     robfinch<remove>@finitron.ca
                        	;       ||
                        	;  
                        	;
                        	; This source file is free software: you can redistribute it and/or modify 
                        	; it under the terms of the GNU Lesser General Public License as published 
                        	; by the Free Software Foundation, either version 3 of the License, or     
                        	; (at your option) any later version.                                      
                        	;                                                                          
                        	; This source file is distributed in the hope that it will be useful,      
                        	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                        	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                        	; GNU General Public License for more details.                             
                        	;                                                                          
                        	; You should have received a copy of the GNU General Public License        
                        	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                        	;
                        	; ============================================================================
                        	
                        	;------------------------------------------------------------------------------
                        	;------------------------------------------------------------------------------
                        	; Device command 
                        	;
                        		align	8                        	
                        	KeybdFuncTbl:
FFFC36A8 00000000		dco		0							; no operation
FFFC36AC 00000000
FFFC36B0 00000000		dco		0							; setup
FFFC36B4 00000000
FFFC36B8 00000000		dco		0							; initialize
FFFC36BC 00000000
FFFC36C0 00000000		dco		0							; status
FFFC36C4 00000000
FFFC36C8 00000000		dco		0							; media check
FFFC36CC 00000000
FFFC36D0 00000000		dco		0							; build BPB
FFFC36D4 00000000
FFFC36D8 00000000		dco		0							; open
FFFC36DC 00000000
FFFC36E0 00000000		dco		0							; close
FFFC36E4 00000000
FFFC36E8 00000000		dco		0							; get char
FFFC36EC 00000000
FFFC36F0 00000000		dco		0							; Peek char
FFFC36F4 00000000
FFFC36F8 FFFC3A60		dco		_KeybdGetScancode		; get char direct
FFFC36FC 00000000
FFFC3700 FFFC3A4C		dco		_KeybdPeekScancode	; Peek char direct
FFFC3704 00000000
FFFC3708 00000000		dco		0							; input status
FFFC370C 00000000
FFFC3710 00000000		dco		0							; Put char
FFFC3714 00000000
FFFC3718 FFFC39D0		dco		_KeybdSendByte	; reserved
FFFC371C 00000000
FFFC3720 00000000		dco		0							; set position
FFFC3724 00000000
FFFC3728 00000000		dco		0							; read block
FFFC372C 00000000
FFFC3730 00000000		dco		0							; write block
FFFC3734 00000000
FFFC3738 00000000		dco		0							; verify block
FFFC373C 00000000
FFFC3740 00000000		dco		0							; output status
FFFC3744 00000000
FFFC3748 00000000		dco		0							; flush input
FFFC374C 00000000
FFFC3750 00000000		dco		0							; flush output
FFFC3754 00000000
FFFC3758 FFFC3A84		dco		KeybdIRQ			; IRQ routine
FFFC375C 00000000
FFFC3760 00000000		dco		0							; Is removable
FFFC3764 00000000
FFFC3768 00000000		dco		0							; ioctrl read
FFFC376C 00000000
FFFC3770 00000000		dco		0							; ioctrl write
FFFC3774 00000000
FFFC3778 00000000		dco		0							; output until busy
FFFC377C 00000000
FFFC3780 00000000		dco		0							; 27
FFFC3784 00000000
FFFC3788 00000000		dco		0
FFFC378C 00000000
FFFC3790 00000000		dco		0
FFFC3794 00000000
FFFC3798 00000000		dco		0
FFFC379C 00000000
FFFC37A0 00000000		dco		0							; 31
FFFC37A4 00000000
                        	
                        	;===============================================================================
                        	; Keyboard routines
                        	;===============================================================================
                        	
                        	SC_C		equ		$21
                        	SC_Z		equ		$1A
                        	SC_TAB	equ		$0D
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Initialize the keyboard.
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        		align	4                        			; we don't know what was before
                        	_KeybdInit:
FFFC37A8 FF070713		sub		$sp,$sp,#16
FFFC37AC 00173023		sto		$ra,[$sp]
FFFC37B0 00106913		ldi		$a0,#1					; Keyboard device
FFFC37B4 FFFC39B7		ldi		$a1,#KeybdFuncTbl
FFFC37B8 6A898993
FFFC37BC BBDFF0EF		call	CopyDevFuncTbl
FFFC37C0 00006993		ldi		$a1,#0
FFFC37C4 00025A37		ldi		$a2,#hKeybdMbx
FFFC37C8 822A0A13
FFFC37CC 80CFF0EF		call	FMTK_AllocMbx
FFFC37D0 0E000C63		bra		.xit
FFFC37D4 00506E93		ldi		$t3,#5
                        	.0002:
FFFC37D8 00031937		ldi		$a0,#200000			; 10ms wait
FFFC37DC D4090913
FFFC37E0 01D73423		sto		$t3,8[$sp]
FFFC37E4 848FD0EF		call	_MicroDelay
FFFC37E8 FFF06913		ldi		$a0,#-1					; send reset code to keyboard
FFFC37EC 00000637		stb		$a0,KEYBD+1			; write $FF to status reg to clear TX state
FFFC37F0 26B60613
FFFC37F4 00060633
FFFC37F8 01260023
FFFC37FC 1D4000EF		call	_KeybdSendByte	; now write to transmit register
FFFC3800 1E4000EF		call	_KeybdWaitTx		; wait until no longer busy
FFFC3804 178000EF		call	_KeybdRecvByte	; look for an ACK ($FA)
FFFC3808 0FA84E13		xor		$t2,$v0,#$FA
FFFC380C 040E1863		bnez	$t2,.tryAgain
FFFC3810 16C000EF		call	_KeybdRecvByte	; look for BAT completion code ($AA)
FFFC3814 0FC84E13		xor		$t2,$v0,#$FC		; reset error ?
FFFC3818 040E0263		beqz	$t2,.tryAgain
FFFC381C 0AA84813		xor		$v0,$v0,#$AA	; reset complete okay ?
FFFC3820 02081E63		bnez	$v0,.tryAgain
                        	
                        		; After a reset, scan code set #2 should be active
                        	.config:
FFFC3824 0F006913		ldi		$a0,#$F0			; send scan code select
FFFC3828 FFDC0637		stb		$a0,LEDS
FFFC382C 60060613
FFFC3830 00060633
FFFC3834 01260023
FFFC3838 198000EF		call	_KeybdSendByte
FFFC383C 1A8000EF		call	_KeybdWaitTx
FFFC3840 08087813		and		$v0,$v0,#$80
FFFC3844 00081C63		bnez	$v0,.tryAgain
FFFC3848 134000EF		call	_KeybdRecvByte	; wait for response from keyboard
FFFC384C 08087893		and		$v1,$v0,#$80
FFFC3850 00089663		bnez	$v1,.tryAgain
FFFC3854 0FA84E13		xor		$t2,$v0,#$FA
FFFC3858 020E0463		beqz	$t2,.0004
                        	.tryAgain:
FFFC385C 00873E83		ldo		$t3,8[$sp]
FFFC3860 FFFE8E93	  sub   $t3,$t3,#1
FFFC3864 F60E9AE3		bnez	$t3,.0002
                        	.keybdErr:
FFFC3868 00000937		ldi		$a0,#msgBadKeybd
FFFC386C 27190913
FFFC3870 FF870713		sub		$sp,$sp,#8
FFFC3874 01273023		sto		$a0,[$sp]
FFFC3878 F81FC0EF		call	PutString		; _DBGDisplayAsciiStringCRLF
FFFC387C 02000863		bra		.ledxit
                        	.0004:
FFFC3880 00206913		ldi		$a0,#2			; select scan code set #2
FFFC3884 14C000EF		call	_KeybdSendByte
FFFC3888 15C000EF		call	_KeybdWaitTx
FFFC388C 08087813		and		$v0,$v0,#$80
FFFC3890 FC0816E3		bnez	$v0,.tryAgain
FFFC3894 0E8000EF		call	_KeybdRecvByte	; wait for response from keyboard
FFFC3898 08087893		and		$v1,$v0,#$80
FFFC389C FC0890E3		bnez	$v1,.tryAgain
FFFC38A0 0FA84E13		xor		$t2,$v0,#$FA
FFFC38A4 FA0E1CE3		bnez	$t2,.tryAgain
FFFC38A8 06C000EF		call	_KeybdGetID
                        	.ledxit:
FFFC38AC 00706913		ldi		$a0,#$07
FFFC38B0 024000EF		call	_KeybdSetLED
FFFC38B4 005B9937		ldi		$a0,#6000000	; 300 ms
FFFC38B8 D8090913
FFFC38BC F71FC0EF		call	_MicroDelay
FFFC38C0 00006913		ldi		$a0,#$00
FFFC38C4 010000EF		call	_KeybdSetLED
                        	.xit:
FFFC38C8 00073083		ldo		$ra,[$sp]
FFFC38CC 01070713		add		$sp,$sp,#16
FFFC38D0 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Set the LEDs on the keyboard.
                        	;
                        	; Parameters: $a0 LED status to set
                        	; Returns: none
                        	; Modifies: none
                        	; Stack Space: 2 words
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdSetLED:
FFFC38D4 FF070713		sub		$sp,$sp,#16
FFFC38D8 00173023		sto		$ra,[$sp]
FFFC38DC 00096E33		mov		$t2,$a0
FFFC38E0 0ED06913		ldi		$a0,#$ED
FFFC38E4 01C73423		sto		$t2,8[$sp]
FFFC38E8 0E8000EF		call	_KeybdSendByte
FFFC38EC 0F8000EF		call	_KeybdWaitTx
FFFC38F0 08C000EF		call	_KeybdRecvByte	; should be an ack
FFFC38F4 00873E03		ldo		$t2,8[$sp]
FFFC38F8 000E6933		mov		$a0,$t2
FFFC38FC 0D4000EF		call	_KeybdSendByte
FFFC3900 0E4000EF		call	_KeybdWaitTx
FFFC3904 078000EF		call	_KeybdRecvByte	; should be an ack
FFFC3908 00073083		ldo		$ra,[$sp]
FFFC390C 01070713		add		$sp,$sp,#16
FFFC3910 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Get ID - get the keyboards identifier code.
                        	;
                        	; Parameters: none
                        	; Returns: r1 = $AB83, $00 on fail
                        	; Modifies: r1, KeybdID updated
                        	; Stack Space: 2 words
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdGetID:
FFFC3914 FF870713		sub		$sp,$sp,#8
FFFC3918 00173023		sto		$ra,[$sp]
FFFC391C 0F206913		ldi		$a0,#$F2
FFFC3920 0B0000EF		call	_KeybdSendByte
FFFC3924 0C0000EF		call	_KeybdWaitTx
FFFC3928 054000EF		call	_KeybdRecvByte
FFFC392C 08087893		and		$v1,$v0,#$80
FFFC3930 04089263		bnez	$v1,.notKbd
FFFC3934 0AB84E13		xor		$t2,$v0,#$AB
FFFC3938 020E1E63		bnez	$t2,.notKbd
FFFC393C 040000EF		call	_KeybdRecvByte
FFFC3940 08087893		and		$v1,$v0,#$80
FFFC3944 02089863		bnez	$v1,.notKbd
FFFC3948 08384E13		xor		$t2,$v0,#$83
FFFC394C 020E1463		bnez	$t2,.notKbd
FFFC3950 0000B837		ldi		$v0,#$AB83
FFFC3954 B8380813
                        	.0001:
FFFC3958 00000637		stt		$v0,_KeybdID
FFFC395C 27760613
FFFC3960 00060633
FFFC3964 01062023
FFFC3968 00073083		ldo		$ra,[$sp]
FFFC396C 00870713		add		$sp,$sp,#8
FFFC3970 00008067		ret
                        	.notKbd:
FFFC3974 00006813		ldi		$v0,#$00
FFFC3978 FE0000E3		bra		.0001
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Recieve a byte from the keyboard, used after a command is sent to the
                        	; keyboard in order to wait for a response.
                        	;
                        	; Parameters: none
                        	; Returns: r1 = recieved byte ($00 to $FF), -1 on timeout
                        	; Modifies: r1
                        	; Stack Space: 2 words
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdRecvByte:
FFFC397C FF070713		sub		$sp,$sp,#16
FFFC3980 00173023		sto		$ra,[$sp]
FFFC3984 06406E93		ldi		$t3,#100				; wait up to 1s
                        	.0003:
FFFC3988 0B0000EF		call	_KeybdGetStatus	; wait for response from keyboard
FFFC398C 08087813		and		$v0,$v0,#$80		; is input buffer full ? yes, branch
FFFC3990 02081863		bnez	$v0,.0004
FFFC3994 00031937		ldi		$a0,#200000
FFFC3998 D4090913
FFFC399C 01D73423		sto		$t3,8[$sp]
FFFC39A0 E8DFC0EF		call	_MicroDelay
FFFC39A4 00873E83		ldo		$t3,8[$sp]
FFFC39A8 FFFE8E93		sub   $t3,$t3,#1
FFFC39AC FC0E9EE3		bnez	$t3,.0003				; go back and try again
FFFC39B0 FFF06813		ldi		$v0,#-1				; return -1
FFFC39B4 00073083		ldo		$ra,[$sp]
FFFC39B8 01070713		add		$sp,$sp,#16
FFFC39BC 00008067		ret
                        	.0004:
FFFC39C0 0A0000EF		call	_KeybdGetScancode
FFFC39C4 00073083		ldo		$ra,[$sp]
FFFC39C8 01070713		add		$sp,$sp,#16
FFFC39CC 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Send a byte to the keyboard.
                        	;
                        	; Parameters: $a0 byte to send
                        	; Returns: none
                        	; Modifies: none
                        	; Stack Space: 0 words
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdSendByte:
FFFC39D0 00000637		stb		$a0,KEYBD
FFFC39D4 26A60613
FFFC39D8 00060633
FFFC39DC 01260023
FFFC39E0 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Wait until the keyboard transmit is complete
                        	;
                        	; Parameters: none
                        	; Returns: r1 = 0 if successful, r1 = -1 timeout
                        	; Modifies: v0,t3
                        	; Stack Space: 1 words
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdWaitTx:
FFFC39E4 FF070713		sub		$sp,$sp,#16
FFFC39E8 00173023		sto		$ra,[$sp]
FFFC39EC 06406E93		ldi		$t3,#100			; wait a max of 1s
                        	.0001:
FFFC39F0 048000EF		call	_KeybdGetStatus
FFFC39F4 04087813		and		$v0,$v0,#$40	; check for transmit complete bit; branch if bit set
FFFC39F8 02081863		bnez	$v0,.0002
FFFC39FC 01D73423		sto		$t3,8[$sp]
FFFC3A00 00031937		ldi		$a0,#200000		; 10 ms @20MHz
FFFC3A04 D4090913
FFFC3A08 E25FC0EF		call	_MicroDelay		; delay a little bit
FFFC3A0C 00873E83		ldo		$t3,8[$sp]
FFFC3A10 FFFE8E93		sub		$t3,$t3,#1
FFFC3A14 FC0E9EE3		bnez	$t3,.0001
FFFC3A18 00073083		ldo		$ra,[$sp]			; timed out
FFFC3A1C 00870713		add		$sp,$sp,#8
FFFC3A20 FFF06813		ldi		$v0,#-1
FFFC3A24 00008067		ret		
                        	.0002:
FFFC3A28 00073083		ldo		$ra,[$sp]			; timed out
FFFC3A2C 01070713		add		$sp,$sp,#16
FFFC3A30 00006813		ldi		$v0,#0
FFFC3A34 00008067		ret		
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Get the keyboard status
                        	;
                        	; Parameters: none
                        	; Returns: r1 = status
                        	; Modifies: r1
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdGetStatus:
FFFC3A38 00000637		ldb		$v0,KEYBD+1
FFFC3A3C 26B60613
FFFC3A40 00060633
FFFC3A44 00060803
FFFC3A48 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; Get the scancode from the keyboard port. Getting the scancode clears the
                        	; interrupt status.
                        	;
                        	; Parameters: none
                        	; Returns: r1 = scancode
                        	; Modifies: r1
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	_KeybdPeekScancode:
FFFC3A4C 00000637		ldbu		$v0,KEYBD			; get the scan code
FFFC3A50 26A60613
FFFC3A54 00060633
FFFC3A58 00064803
FFFC3A5C 00008067		ret
                        	
                        	_KeybdGetScancode:
FFFC3A60 00000637		ldbu		$v0,KEYBD			; get the scan code
FFFC3A64 26A60613
FFFC3A68 00060633
FFFC3A6C 00064803
FFFC3A70 00000637		stb			$x0,KEYBD+1		; clear receive register
FFFC3A74 26B60613
FFFC3A78 00060633
FFFC3A7C 00060023
FFFC3A80 00008067		ret
                        	
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        	
                        	KeybdIRQ:
FFFC3A84 FB5FF0EF		call	_KeybdGetStatus
FFFC3A88 0E085263		bge		$v0,$x0,.notKbd
FFFC3A8C FD5FF0EF		call	_KeybdGetScancode
FFFC3A90 00025637		ldo		$s1,IOFocusNdx
FFFC3A94 81060613
FFFC3A98 00060633
FFFC3A9C 00063203
FFFC3AA0 0C020663		beqz	$s1,.notKbd
FFFC3AA4 30024D03		ldbu	$t0,TCBKbdHead[$s1]
FFFC3AA8 30124D83		ldbu	$t1,TCBKbdTail[$s1]
FFFC3AAC 001D0D13		add		$t0,$t0,#1
FFFC3AB0 01FD7D13		and		$t0,$t0,#31
FFFC3AB4 01BD0663		beq		$t0,$t1,.noRoom
FFFC3AB8 31A20023		stb		$t0,TCBKbdHead[$s1]
FFFC3ABC 31020423		stb		$v0,TCBKbdBuf[$s1]
                        	.noRoom:
                        		; check trigger debugger
                        		; check CTRL-C
FFFC3AC0 00000637		lbu		$t0,TCBKbdState2
FFFC3AC4 27F60613
FFFC3AC8 00060633
FFFC3ACC 00064D03
FFFC3AD0 004D7D93		and		$t1,$t0,#4
FFFC3AD4 020D8E63		beqz	$t1,.notCtrl
FFFC3AD8 02106D13		ldi		$t0,#SC_C
FFFC3ADC 01A81863		bne		$v0,$t0,.notCtrlC
FFFC3AE0 00306D13		ldi		$t0,#3
FFFC3AE4 2DA23423		sto		$t0,TCBException[$s1]
FFFC3AE8 02000463		bra		.0001
                        	.notCtrlC:
FFFC3AEC 01A06D13		ldi		$t0,#SC_Z
FFFC3AF0 03A81063		bne		$v0,$t0,.notCtrlZ
FFFC3AF4 01A06D13		ldi		$t0,#26
                        		
FFFC3AF8 18101873		csrrw	v0,#$181,x0
FFFC3AFC 03F87813		and		v0,v0,#MAX_TID
FFFC3B00 00081813	sll		$v0,$v0,#32
FFFC3B04 01A86833		or		$v0,$v0,$t0
FFFC3B08 2D023423		sto		$v0,TCBException[$s1]
FFFC3B0C 00000263		bra		.0001
                        	.notCtrlZ:
                        	.0001:
                        	.notCtrl:
FFFC3B10 002D7D93		and		$t1,$t0,#2
FFFC3B14 760D8863		beqz	$t1,.notAlt
FFFC3B18 00D06D13		ldi		$t0,#SC_TAB
FFFC3B1C 01A81A63		bne		$v0,$t0,.notAltTab
FFFC3B20 00025637		stb		$t0,SwitchIOFocus
FFFC3B24 82060613
FFFC3B28 00060633
FFFC3B2C 01A60023
                        	.notAltTab:
                        		; Send a message indicating a key is available
                        		; Keyboard mailbox setup yet?
FFFC3B30 00025637		ldw		$a1,hKeybdMbx
FFFC3B34 82260613
FFFC3B38 00060633
FFFC3B3C 00061983
FFFC3B40 0209C663		blt		$a1,$x0,.notKbd
                        		; If there's already a keyboard message, don't send another one.
FFFC3B44 00599213		sll		$s1,$a1,#LOG_MBXSZ
FFFC3B48 00020637		add		$s1,$s1,#mbxs
FFFC3B4C 00060613
FFFC3B50 00460233
FFFC3B54 01823D03		ldo		$t0,MBX_MQTAIL[$s1]
FFFC3B58 000D1A63		bnez	$t0,.notKbd
FFFC3B5C FFF06A13		ldi		$a2,#-1
FFFC3B60 FFF06A93		ldi		$a3,#-1
FFFC3B64 FFF06B13		ldi		$a4,#-1
FFFC3B68 D75FE0EF		call	FMTK_SendMsg
                        	.notKbd:
FFFC3B6C 79217073		csrrc	$x0,#$792,#2			; clear IRQ semaphore
FFFC3B70 10000073		eret
                        	
                        	; Return -1 if there is a scancode available in the buffer.
                        	
                        	_KeybdGetBufferStatus:
                        		
FFFC3B74 18101873		csrrw	v0,#$181,x0
FFFC3B78 03F87813		and		v0,v0,#MAX_TID
FFFC3B7C 00A81213	sll		$s1,$v0,#LOG_TCBSZ
FFFC3B80 3000F2F3		csrrc	$s2,#$300,#1						; disable interrupts
FFFC3B84 30024D03		ldbu	$t0,TCBKbdHead[$s1]
FFFC3B88 30124D83		ldbu	$t1,TCBKbdTail[$s1]
FFFC3B8C 30029073		csrrw	$x0,#$300,$s2						; restore interrupts
FFFC3B90 01BD0663		beq		$t0,$t1,.empty
FFFC3B94 FFF06813		ldi		$v0,#-1
FFFC3B98 00008067		ret
                        	.empty:
FFFC3B9C 00006813		ldi		$v0,#0
FFFC3BA0 00008067		ret
                        	
                        	_KeybdGetBufferedScancode:	
                        		
FFFC3BA4 18101873		csrrw	v0,#$181,x0
FFFC3BA8 03F87813		and		v0,v0,#MAX_TID
FFFC3BAC 00A81213	sll		$s1,$v0,#LOG_TCBSZ
FFFC3BB0 00006813		ldi		$v0,#0									; $v0 = scancode
FFFC3BB4 3000F2F3		csrrc	$s2,#$300,#1						; disable interrupts
FFFC3BB8 30024D03		ldbu	$t0,TCBKbdHead[$s1]
FFFC3BBC 30124D83		ldbu	$t1,TCBKbdTail[$s1]
FFFC3BC0 01BD0C63		beq		$t0,$t1,.empty					; return 0 if empty
FFFC3BC4 004D8D33		add		$t0,$t1,$s1							; calc pointer to buffer entry
FFFC3BC8 308D4803		ldbu	$v0,TCBKbdBuf[$t0]			; get buffer entry
FFFC3BCC 001D8D93		add		$t1,$t1,#1							; increment tail pointer
FFFC3BD0 01FDFD93		and		$t1,$t1,#31
FFFC3BD4 31B200A3		stb		$t1,TCBKbdTail[$s1]			; store tail pointer
                        	.empty:
FFFC3BD8 30029073		csrrw	$x0,#$300,$s2						; restore interrupts
FFFC3BDC 00008067		ret
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "TinyBasic.r5a",1
                        	.file "TinyBasic.r5a",1
                        	;****************************************************************;
                        	;                                                                ;
                        	;		Tiny BASIC for the CS01                                      ;
                        	;                                                                ;
                        	; Derived from a 68000 derivative of Palo Alto Tiny BASIC as     ;
                        	; published in the May 1976 issue of Dr. Dobb's Journal.         ;
                        	; Adapted to the 68000 by:                                       ;
                        	;	Gordon brndly						                         ;
                        	;	12147 - 51 Street					                         ;
                        	;	Edmonton AB  T5W 3G8					                     ;
                        	;	Canada							                             ;
                        	;	(updated mailing address for 1996)			                 ;
                        	;                                                                ;
                        	; Adapted to the CS01 by:                                        ;
                        	;    Robert Finch                                                ;
                        	;    Ontario, Canada                                             ;
                        	;	 robfinch<remove>@finitron.ca    	                             ;  
                        	;****************************************************************;
                        	;  Copyright (C) 2016-2020 by Robert Finch. This program may be	 ;
                        	;    freely distributed for personal use only. All commercial	 ;
                        	;		       rights are reserved.			                     ;
                        	;****************************************************************;
                        	;
                        	; Register Usage
                        	; $t2 = text pointer (global usage)
                        	; r3,r4 = inputs parameters to subroutines
                        	; a1 = return value
                        	;
                        	;* Vers. 1.0  1984/7/17	- Original version by Gordon brndly
                        	;*	1.1  1984/12/9	- Addition of '0x' print term by Marvin Lipford
                        	;*	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                        	
                        	CR		EQU	0x0D		;ASCII equates
                        	LINEFD	EQU	0x0A		; Don't use LF (same as load float instruction)
                        	TAB		EQU	0x09
                        	CTRLC	EQU	0x03
                        	CTRLH	EQU	0x08
                        	CTRLI	EQU	0x09
                        	CTRLJ	EQU	0x0A
                        	CTRLK	EQU	0x0B
                        	CTRLM   EQU 0x0D
                        	CTRLS	EQU	0x13
                        	CTRLX	EQU	0x18
                        	XON		EQU	0x11
                        	XOFF	EQU	0x13
                        	
                        	FILENAME	EQU		0x3F6C0
                        	FILEBUF		EQU		0x03F600
                        	OSSP		EQU		0x30000
                        	TXTUNF		EQU		OSSP+4
                        	VARBGN		EQU		TXTUNF+4
                        	VAREND		EQU		VARBGN+4
                        	LOPVAR		EQU		VAREND+4
                        	STKGOS		EQU		LOPVAR+4
                        	CURRNT		EQU		STKGOS+4
                        	BUFFER		EQU		CURRNT+4
                        	BUFLEN		EQU		84
                        	LOPPT		EQU		BUFFER+84
                        	LOPLN		EQU		LOPPT+4
                        	LOPINC		EQU		LOPLN+4
                        	LOPLMT		EQU		LOPINC+4
                        	NUMWKA		EQU		LOPLMT+24
                        	STKINP		EQU		NUMWKA+4
                        	STKBOT		EQU		STKINP+4
                        	usrJmp		EQU		STKBOT+4
                        	IRQROUT		EQU		usrJmp+4
                        	
                        	OUTPTR		EQU		IRQROUT+4
                        	INPPTR		EQU		OUTPTR+4
                        	CursorFlash	EQU		INPPTR+4
                        	IRQFlag		EQU		CursorFlash+4
                        	
                        	;
                        	; Modifiable system constants:
                        	;
                        	;THRD_AREA	dw	0x04000000	; threading switch area 0x04000000-0x40FFFFF
                        	;bitmap dw	0x00100000	; bitmap graphics memory 0x04100000-0x417FFFF
                        	TXTBGN		EQU		0x031800	;TXT ;beginning of program memory
                        	ENDMEM		EQU		0x03FFFC	; end of available memory
                        	STACKOFFS	EQU		0xAFFFC000	; stack offset
                        	
                        	
                        	.file "TinyBasic.r5a",84
                        			code
FFFC3BE0 00000000			align	25
FFFC3BE4 00000000
FFFC3BE8 00000000
FFFC3BEC 00000000
FFFC3BF0 00000000
FFFC3BF4 00000000
FFFC3BF8 00000000
FFFC3BFC 00000000
                        	
                        	;
                        	; Standard jump table. You can change these addresses if you are
                        	; customizing this interpreter for a different environment.
                        	;
                        	TinyBasic:
                        	GOSTART:	
FFFC3C00 0300006F			jmp	CSTART	;	Cold Start entry point
                        	GOWARM:	
FFFC3C04 11C0006F			jmp	WSTART	;	Warm Start entry point
                        	GOOUT:	
FFFC3C08 17C0206F			jmp	OUTC	;	Jump to character-out routine
                        	GOIN:	
FFFC3C0C 17C0206F			jmp	INCH	;Jump to character-in routine
                        	GOAUXO:	
FFFC3C10 00000637			jmp	AUXOUT	;	Jump to auxiliary-out routine
FFFC3C14 2B760067
                        	GOAUXI:	
FFFC3C18 00000637			jmp	AUXIN	;	Jump to auxiliary-in routine
FFFC3C1C 2B960067
                        	GOBYE:	
FFFC3C20 1980206F			jmp	BYEBYE	;	Jump to monitor, DOS, etc.
                        	
FFFC3C24 00000000		align	1
FFFC3C28 00000000
FFFC3C2C 00000000
                        	
                        	//message "CSTART"
                        	public CSTART:
	; First save off the link register and OS sp value
FFFC3C30 00030637		sw		$sp,OSSP
FFFC3C34 00060613
FFFC3C38 00060633
FFFC3C3C 00E62023
FFFC3C40 AFFFC737		ldi		$sp,#STACKOFFS	; initialize stack pointer
FFFC3C44 00070713
FFFC3C48 00E06913		ldi		$a0,#14							; Get current tid
FFFC3C4C 00000073		ecall
FFFC3C50 0008E9B3		mov		$a1,$v1
FFFC3C54 01806913		ldi		$a0,#24							; RequestIOFocus
FFFC3C58 00000073		ecall
                        	;	call	_DBGHomeCursor[pc]
FFFC3C5C 00006933		mov		a0,r0			; turn off keyboard echoing
                        	//	call	SetKeyboardEcho
                        	//	stz		CursorFlash
                        	//	ldx		#0x10000020	; black chars, yellow background
                        	;	stx		charToPrint
                        	;	call	_DBGClearScreen[pc]
FFFC3C60 FFFC6937		ldi		a0,#msgInit	;	tell who we are
FFFC3C64 DCC90913
FFFC3C68 721010EF		call	PRMESG
FFFC3C6C 00032937		ldi		a0,#TXTBGN	;	init. end-of-program pointer
FFFC3C70 80090913
FFFC3C74 00030637		sw		a0,TXTUNF
FFFC3C78 00460613
FFFC3C7C 00060633
FFFC3C80 01262023
FFFC3C84 00040937		ldi		a0,#ENDMEM	;	get address of end of memory
FFFC3C88 FFC90913
FFFC3C8C 00080937		ldi		a0,#$7F800
FFFC3C90 80090913
FFFC3C94 00030637		sw		a0,STKBOT
FFFC3C98 09C60613
FFFC3C9C 00060633
FFFC3CA0 01262023
FFFC3CA4 00040937		ldi		a0,#ENDMEM
FFFC3CA8 FFC90913
FFFC3CAC 00030637		sw		a0,VAREND
FFFC3CB0 00C60613
FFFC3CB4 00060633
FFFC3CB8 01262023
FFFC3CBC CE090913		sub		a0,a0,#800 	;   100 vars
FFFC3CC0 00030637		sw    a0,VARBGN
FFFC3CC4 00860613
FFFC3CC8 00060633
FFFC3CCC 01262023
FFFC3CD0 59C000EF		call  clearVars   ; clear the variable area
FFFC3CD4 00030637		sw		r0,IRQROUT
FFFC3CD8 0A460613
FFFC3CDC 00060633
FFFC3CE0 00062023
FFFC3CE4 00030637		lw    a0,VARBGN   ; calculate number of bytes free
FFFC3CE8 00860613
FFFC3CEC 00060633
FFFC3CF0 00062903
FFFC3CF4 00030637		lw		a1,TXTUNF
FFFC3CF8 00460613
FFFC3CFC 00060633
FFFC3D00 00062983
FFFC3D04 41390933		sub   a0,a0,a1
FFFC3D08 00606993		ldi		a1,#6		; max 6 digits
FFFC3D0C 00A06A13		ldi		a2,#10	; base 10
FFFC3D10 39D010EF		call  PRTNUM
FFFC3D14 FFFC6937		ldi		a0,#msgBytesFree
FFFC3D18 E6D90913
FFFC3D1C 66D010EF		call	PRMESG
                        	WSTART:
FFFC3D20 00030637		sw		x0,LOPVAR   ; initialize internal variables
FFFC3D24 01060613
FFFC3D28 00060633
FFFC3D2C 00062023
FFFC3D30 00030637		sw		x0,STKGOS
FFFC3D34 01460613
FFFC3D38 00060633
FFFC3D3C 00062023
FFFC3D40 00030637		sw		x0,CURRNT	;	current line number pointer = 0
FFFC3D44 01860613
FFFC3D48 00060633
FFFC3D4C 00062023
FFFC3D50 AFFFC737		ldi		$sp,#STACKOFFS	;	init S.P. again, just in case
FFFC3D54 00070713
FFFC3D58 FFFC6937		ldi		a0,#msgReady	;	display "Ready"
FFFC3D5C E7A90913
FFFC3D60 629010EF		call	PRMESG
                        	BASPRMPT:
FFFC3D64 00E06913		ldi		a0,#14		; get current tid
FFFC3D68 00000073		ecall
FFFC3D6C 0008E933		mov		a0,v1
FFFC3D70 A29FC0EF		call	PutHexByte
FFFC3D74 03E06913		ldi		a0,#'>'		; Prompt with a '>' and
FFFC3D78 75C010EF		call	GETLN		; read a line.
FFFC3D7C 559010EF		call	TOUPBUF 	; convert to upper case
FFFC3D80 000E64B3		mov		$s6,$t2		; save pointer to end of line
FFFC3D84 00030E37		ldi		$t2,#BUFFER	; point to the beginning of line
FFFC3D88 01CE0E13
FFFC3D8C 4A5010EF		call	TSTNUM		; is there a number there?
FFFC3D90 515010EF		call	IGNBLK		; skip trailing blanks
FFFC3D94 000E4483		lbu		$s6,[$t2]
FFFC3D98 00D4C493		xor		$s6,$s6,#CR	; s6 = flag empty line
                        	; does line no. exist? (or nonzero?)
FFFC3D9C 2C088263		beq		v1,x0,DIRECT		; if not, it's a direct statement
FFFC3DA0 00100DB7		ldi		$t1,#$FFFFF
FFFC3DA4 FFFD8D93
FFFC3DA8 010DD863		ble		v0,$t1,ST2	; see if line no. is <= 16 bits
FFFC3DAC FFFC6937		ldi		a0,#msgLineRange	; if not, we've overflowed
FFFC3DB0 E9590913
FFFC3DB4 6C40106F		jmp		ERROR
                        	ST2:
FFFC3DB8 00086933	  mov		$a0,$v0		; a0 = line number
FFFC3DBC 000E6433	  mov		$s5,$t2			; save line buffer pointer
FFFC3DC0 FFCE0E13		sub		$t2,$t2,#4
FFFC3DC4 012E2023	  sw		$a0,[$t2]		;	This will end up in buffer
FFFC3DC8 019010EF		call	FNDLN		; find this line in save area
FFFC3DCC 000EE533		mov		$s7,$t3		; save possible line pointer
FFFC3DD0 00080663		beq		$v0,$x0,INSLINE	; if not found, insert
FFFC3DD4 000EE933		mov		$a0,$t3
FFFC3DD8 044000EF		call	DeleteLine
                        	INSLINE:
FFFC3DDC F80484E3		beq		$s6,$x0,BASPRMPT	; line was empty
FFFC3DE0 00046933		mov		$a0,$s5			; a0 = buffer pointer	
                        		; GetBuflen just get the length of the text.
                        		; A line number is stuffed just before the text
                        		; so length needs to be adjusted by 4.
FFFC3DE4 0B8000EF		call	GetBuflen
FFFC3DE8 00480393		add		$s4,$v0,#4
FFFC3DEC 00056933		mov		$a0,$s7
FFFC3DF0 0003E9B3		mov		$a1,$s4
FFFC3DF4 0D4000EF		call	OpenSpace
FFFC3DF8 00081863		bne		$v0,$x0,.0001	; space available?
FFFC3DFC FFFC6937		ldi		a0,#msgTooBig	; no space available
FFFC3E00 F6790913
FFFC3E04 6740106F		jmp		ERROR
                        	.0001:
FFFC3E08 00056933		mov		$a0,$s7			; target
FFFC3E0C FFC40993		sub		$a1,$s5,#4	; source (incl lineno)
FFFC3E10 0003EA33		mov		$a2,$s4			; length
FFFC3E14 068000EF		call	InsertLine
FFFC3E18 F40006E3		bra		BASPRMPT
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	;		a0 = pointer to line to delete
                        	; Modifies:
                        	;		t0,t1,t2,t3
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	DeleteLine:
                        		; Find the end of the line to delete
FFFC3E1C 00490D13		add		$t0,$a0,#4		; t0 = pointer to line past line number
FFFC3E20 00D06E13		ldi		$t2,#CR
FFFC3E24 00030637		lw		$t3,TXTUNF		; last text address
FFFC3E28 00460613
FFFC3E2C 00060633
FFFC3E30 00062E83
                        	.0002:
FFFC3E34 000D4D83		lbu		$t1,[$t0]
FFFC3E38 000D8A63		beq		$t1,$x0,.0003	; might be null
FFFC3E3C 01CD8663		beq		$t1,$t2,.0001	; lines end with CR
FFFC3E40 001D0D13		add		$t0,$t0,#1
FFFC3E44 FFDD68E3		bltu	$t0,$t3,.0002	; end of program?
                        	.0001:
FFFC3E48 001D0D13		add		$t0,$t0,#1
                        	.0003:
                        		; pull text after eol overtop
FFFC3E4C 000D4F03		lbu		$t4,[$t0]			; copy from next line
FFFC3E50 01E90023		sb		$t4,[$a0]			; overtop deleted line
FFFC3E54 001D0D13		add		$t0,$t0,#1		; increment pointers
FFFC3E58 00190913		add		$a0,$a0,#1
FFFC3E5C FFAEF8E3		bleu	$t0,$t3,.0003	; to end of program
                        		; update end of text
FFFC3E60 412D0933		sub		$a0,$t0,$a0		; difference of pointers = length
FFFC3E64 412E8EB3		sub		$t3,$t3,$a0		
FFFC3E68 00030637		sw		$t3,TXTUNF
FFFC3E6C 00460613
FFFC3E70 00060633
FFFC3E74 01D62023
FFFC3E78 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = insertion point
                        	; 	a1 = source buffer
                        	; 	a2 = length
                        	; Modifies:
                        	;		a0,a1,a2,t1
                        	; Returns:
                        	;		none
                        	;------------------------------------------------------------------------------
                        	
                        	InsertLine:
FFFC3E7C 000A0E63		beq		$a2,$x0,.done		; zero length? Probably a SW error
                        	.0001:
FFFC3E80 0009CD83		lbu		$t1,[$a1]				; get from source text
FFFC3E84 01B90023		sb		$t1,[$a0]				; store to insertion point
FFFC3E88 00198993		add		$a1,$a1,#1			; increment pointers
FFFC3E8C 00190913		add		$a0,$a0,#1
FFFC3E90 FFFA0A13		sub		$a2,$a2,#1			; decrement length
FFFC3E94 FF4066E3		bgtu	$a2,$x0,.0001
                        	.done:
FFFC3E98 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; GetBuflen - get the length of text in a buffer. The length is taken up to
                        	; the first null character or carriage return character encountered.
                        	;
                        	; Parameters:
                        	;		a0 = pointer to buffer
                        	; Modifies:
                        	;		t2,t3,t5
                        	; Returns:
                        	;		v0 = length of data in buffer
                        	;------------------------------------------------------------------------------
                        	
                        	GetBuflen:
FFFC3E9C 00006813		ldi		$v0,#0
FFFC3EA0 00D06E93		ldi		$t3,#CR
FFFC3EA4 00096FB3		mov		$t5,$a0
                        	.0002:
FFFC3EA8 000FCE03		lbu		$t2,[$t5]
FFFC3EAC 001F8F93		add		$t5,$t5,#1
FFFC3EB0 000E0A63		beq		$t2,$x0,.0001
FFFC3EB4 01DE0663		beq		$t2,$t3,.0004
FFFC3EB8 00180813		add		$v0,$v0,#1
FFFC3EBC FE0006E3		bra		.0002
                        	.0004:
FFFC3EC0 00180813		add		$v0,$v0,#1
                        	.0001:
FFFC3EC4 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = place to insert line
                        	; 	a1 = buffer length
                        	; Modifies:
                        	;		t1,t2,t3,t5
                        	; Returns:
                        	;		v0 = 1 if successful, 0 if not enough room available
                        	;------------------------------------------------------------------------------
                        	
                        	OpenSpace:
FFFC3EC8 00030637		lw		$t2,TXTUNF
FFFC3ECC 00460613
FFFC3ED0 00060633
FFFC3ED4 00062E03
FFFC3ED8 000E6EB3		mov		$t3,$t2				; t3 = old end of text
FFFC3EDC 013E0E33		add		$t2,$t2,$a1		; increment end of text by buffer length
FFFC3EE0 00030637		lw		$t1,VARBGN		; compare to start of variables
FFFC3EE4 00860613
FFFC3EE8 00060633
FFFC3EEC 00062D83
FFFC3EF0 03BE7863		bgeu	$t2,$t1,.noSpace	; enough room?
FFFC3EF4 00030637		sw		$t2,TXTUNF		; yes, set new end of text
FFFC3EF8 00460613
FFFC3EFC 00060633
FFFC3F00 01C62023
                        	.0003:
FFFC3F04 000ECF83		lbu		$t5,[$t3]			; copy old text
FFFC3F08 01FE0023		sb		$t5,[$t2]			; to new text loc
FFFC3F0C FFFE8E93		sub		$t3,$t3,#1		; decrement pointers
FFFC3F10 FFFE0E13		sub		$t2,$t2,#1
FFFC3F14 FF2EF8E3		bgeu	$t3,$a0,.0003	; until insert point reached
FFFC3F18 00106813		ldi		$v0,#1				; return success
FFFC3F1C 00008067		ret
                        	.noSpace:
FFFC3F20 00006813		ldi		$v0,#0
FFFC3F24 00008067		ret	
                        	
                        	;******************************************************************
                        	;
                        	; *** Tables *** DIRECT *** EXEC ***
                        	;
                        	; This section of the code tests a string against a table. When
                        	; a match is found, control is transferred to the section of
                        	; code according to the table.
                        	;
                        	; At 'EXEC', r8 should point to the string, r9 should point to
                        	; the character table, and r10 should point to the execution
                        	; table. At 'DIRECT', r8 should point to the string, r9 and
                        	; r10 will be set up to point to TAB1 and TAB1_1, which are
                        	; the tables of all direct and statement commands.
                        	;
                        	; A '.' in the string will terminate the test and the partial
                        	; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                        	; 'PRIN.', or 'PRINT' will all match 'PRINT'.
                        	;
                        	; There are two tables: the character table and the execution
                        	; table. The character table consists of any number of text items.
                        	; Each item is a string of characters with the last character's
                        	; high bit set to one. The execution table holds a 32-bit
                        	; execution addresses that correspond to each entry in the
                        	; character table.
                        	;
                        	; The end of the character table is a 0 byte which corresponds
                        	; to the default routine in the execution table, which is
                        	; executed if none of the other table items are matched.
                        	;
                        	; Character-matching tables:
                        	TAB1:
FFFC3F28 D453494C		db	"LIS",'T'+0x80        ; Direct commands
FFFC3F2C C4414F4C		db	"LOA",'D'+0x80
FFFC3F30 52D7454E		db	"NE",'W'+0x80
FFFC3F33 53CE5552		db	"RU",'N'+0x80
FFFC3F36 C5564153		db	"SAV",'E'+0x80
                        	TAB2:
FFFC3F3A D458454E		db	"NEX",'T'+0x80         ; Direct / statement
FFFC3F3E 49D4454C		db	"LE",'T'+0x80
FFFC3F41 4F47C649		db	"I",'F'+0x80
FFFC3F43 CF544F47		db	"GOT",'O'+0x80
FFFC3F47 55534F47		db	"GOSU",'B'+0x80
FFFC3F4B 544552C2
FFFC3F4C 55544552		db	"RETUR",'N'+0x80
FFFC3F50 4552CE52
FFFC3F52 46CD4552		db	"RE",'M'+0x80
FFFC3F55 49D24F46		db	"FO",'R'+0x80
FFFC3F58 55504E49		db	"INPU",'T'+0x80
FFFC3F5C 495250D4
FFFC3F5D 4E495250		db	"PRIN",'T'+0x80
FFFC3F61 4B4F50D4
FFFC3F62 C54B4F50		db	"POK",'E'+0x80
FFFC3F66 454B4F50		db	"POKE",'W'+0x80
FFFC3F6A 4B4F50D7
FFFC3F6B 454B4F50		db	"POKE",'H'+0x80
FFFC3F6F 454959C8
FFFC3F70 4C454959		db	"YIEL",'D'+0x80
FFFC3F74 4F5453C4
FFFC3F75 D04F5453		db	"STO",'P'+0x80
FFFC3F79 53C55942		db	"BY",'E'+0x80
FFFC3F7C 43D35953		db	"SY",'S'+0x80
FFFC3F7F 43D34C43		db	"CL",'S'+0x80
FFFC3F82 52D24C43	    db  "CL",'R'+0x80
FFFC3F85 C6434452	    db	"RDC",'F'+0x80
FFFC3F89 52494E4F	    db	"ONIR",'Q'+0x80
FFFC3F8D 494157D1
FFFC3F8E D4494157	    db	"WAI",'T'+0x80
FFFC3F92 45455000		db	0
                        	TAB4:
FFFC3F93 CB454550		db	"PEE",'K'+0x80         ;Functions
FFFC3F97 4B454550		db	"PEEK",'W'+0x80
FFFC3F9B 454550D7
FFFC3F9C 4B454550		db	"PEEK",'H'+0x80
FFFC3FA0 C44E52C8
FFFC3FA1 41C44E52		db	"RN",'D'+0x80
FFFC3FA4 53D34241		db	"AB",'S'+0x80
FFFC3FA7 54CE4753		db  "SG",'N'+0x80
FFFC3FAA CB434954		db	"TIC",'K'+0x80
FFFC3FAE C55A4953		db	"SIZ",'E'+0x80
FFFC3FB2 41D25355		db  "US",'R'+0x80
FFFC3FB5 4F4C4C41	  db	"ALLOCMB",'X'+0x80
FFFC3FB9 D8424D43
FFFC3FBD 444E4553	  db	"SENDMS",'G'+0x80
FFFC3FC1 57C7534D
FFFC3FC4 54494157	  db	"WAITMS",'G'+0x80
FFFC3FC8 00C7534D
FFFC3FCB 00CF5400		db	0
                        	TAB5:
FFFC3FCC 5300CF54		db	"T",'O'+0x80           ;"TO" in "FOR"
FFFC3FCE 45545300		db	0
                        	TAB6:
FFFC3FCF D0455453		db	"STE",'P'+0x80         ;"STEP" in "FOR"
FFFC3FD3 3CBD3E00		db	0
                        	TAB8:
FFFC3FD4 BE3CBD3E		db	'>','='+0x80           ;Relational operators
FFFC3FD6 BDBEBE3C		db	'<','>'+0x80
FFFC3FD8 BD3CBDBE		db	'>'+0x80
FFFC3FD9 BCBD3CBD		db	'='+0x80
FFFC3FDA 00BCBD3C		db	'<','='+0x80
FFFC3FDC 4E4100BC		db	'<'+0x80
FFFC3FDD C44E4100		db	0
                        	TAB9:
FFFC3FDE 00C44E41	    db  "AN",'D'+0x80
FFFC3FE1 00D24F00	    db  0
                        	TAB10:
FFFC3FE2 0000D24F	    db  "O",'R'+0x80
FFFC3FE4 430C0000	    db  0
                        	
                        	;* Execution address tables:
                        	; We save some bytes by specifiying only the low order 16 bits of the address
                        	;
FFFC3FE5 40430C00		align	
                        	
                        	TAB1_1:
FFFC3FE6 4940430C		dh	LISTX			;Direct commands
FFFC3FE8 40E84940		dh	LOAD3
FFFC3FEA 411C40E8		dh	NEW
FFFC3FEC 49A8411C		dh	RUN
FFFC3FEE 45BC49A8		dh	SAVE3
                        	TAB2_1:
FFFC3FF0 47D445BC		dh	NEXT		;	Direct / statement
FFFC3FF2 467C47D4		dh	LET
FFFC3FF4 4240467C		dh	IF0
FFFC3FF6 44004240		dh	GOTO
FFFC3FF8 44744400		dh	GOSUB
FFFC3FFA 46884474		dh	RETURN
FFFC3FFC 44DC4688		dh	IF2			; REM
FFFC3FFE 46D444DC		dh	FOR
FFFC4000 436046D4		dh	INPUT
FFFC4002 4B1C4360		dh	PRINT
FFFC4004 4B484B1C		dh	POKE
FFFC4006 4B744B48		dh	POKEW
FFFC4008 41104B74		dh	POKEH
FFFC400A 41084110		dh	YIELD0
FFFC400C 3C204108		dh	STOP
FFFC400E 4BAC3C20		dh	GOBYE
FFFC4010 02FC4BAC		dh	SYSX
FFFC4012 426402FC		dh	_cls
FFFC4014 02FE4264		dh  _clr
FFFC4016 42B002FE		dh	_rdcf
FFFC4018 42F042B0		dh  ONIRQ
FFFC401A 47C842F0		dh	WAITIRQ
FFFC401C 51EC47C8		dh	DEFLT
                        	TAB4_1:
FFFC401E 520451EC		dh	PEEK			;Functions
FFFC4020 521C5204		dh	PEEKW
FFFC4022 5280521C		dh	PEEKH
FFFC4024 00005280		dh	RND
FFFC4026 53140000		dh	ABS
FFFC4028 53005314		dh  SGN
FFFC402A 53505300		dh	TICKX
FFFC402C 52345350		dh	SIZEX
FFFC402E 5BA05234		dh  USRX
FFFC4030 5C105BA0		dh	ALLOCMBX
FFFC4032 5CAC5C10		dh	SENDMSG
FFFC4034 4FA45CAC		dh	WAITMSG
FFFC4036 45084FA4		dh	XP40
                        	TAB5_1
FFFC4038 54704508		dh	FR1			;"TO" in "FOR"
FFFC403A 45305470		dh	QWHAT
                        	TAB6_1
FFFC403C 45384530		dh	FR2			;"STEP" in "FOR"
FFFC403E 4D5C4538		dh	FR3
                        	TAB8_1
FFFC4040 4D744D5C		dh	XP11	;>=		Relational operators
FFFC4042 4D8C4D74		dh	XP12	;<>
FFFC4044 4DBC4D8C		dh	XP13	;>
FFFC4046 4DA44DBC		dh	XP15	;=
FFFC4048 4DD44DA4		dh	XP14	;<=
FFFC404A 4E144DD4		dh	XP16	;<
FFFC404C 4C6C4E14		dh	XP17
                        	TAB9_1
FFFC404E 4C804C6C	    dh  XP_AND
FFFC4050 4C0C4C80	    dh  XP_ANDX
                        	TAB10_1
FFFC4052 4C204C0C	    dh  XP_OR
FFFC4054 00004C20	    dh  XP_ORX
                        	
                        	;*
                        	; r3 = match flag (trashed)
                        	; r9 = text table
                        	; r10 = exec table
                        	; r11 = trashed
FFFC4056 00000000		align	1
FFFC405A 00000000
FFFC405E 4EB70000
                        	
                        	//message "DIRECT"
                        	DIRECT:
FFFC4060 FFFC4EB7		ldi		$t3,#TAB1
FFFC4064 F28E8E93
FFFC4068 FFFC4F37		ldi		$t4,#TAB1_1
FFFC406C FE6F0F13
                        	EXEC:
FFFC4070 235010EF		call	IGNBLK		; ignore leading blanks
FFFC4074 000E6FB3		mov		$t5,$t2		; save the pointer
FFFC4078 000061B3		mov		r3,r0		; clear match flag
                        	EXLP:
FFFC407C 000E4903		lbu		a0,[$t2]		; get the program character
FFFC4080 001E0E13		add		$t2,$t2,#1
FFFC4084 000EC983		lbu		a1,[$t3]		; get the table character
FFFC4088 00099663		bne		a1,x0,EXNGO		; If end of table,
FFFC408C 000FEE33		mov		$t2,$t5		;	restore the text pointer and...
FFFC4090 04000263		bra		EXGO		;   execute the default.
                        	EXNGO:
FFFC4094 04390063		beq		a0,r3,EXGO	; Else check for period... if so, execute
FFFC4098 07F9F993		and		a1,a1,#0x7f	; ignore the table's high bit
FFFC409C 03298263		beq		a1,a0,EXMAT	;		is there a match?
FFFC40A0 002F0F13		add		$t4,$t4,#2	;if not, try the next entry
FFFC40A4 000FEE33		mov		$t2,$t5		; reset the program pointer
FFFC40A8 000061B3		mov		r3,x0		; sorry, no match
                        	EX1:
FFFC40AC 000EC903		lbu		a0,[$t3]		; get to the end of the entry
FFFC40B0 001E8E93		add		$t3,$t3,#1
FFFC40B4 08097D93		and		$t1,$a0,#$80
FFFC40B8 FE0D8AE3		beq		$t1,$r0,EX1	; test for bit 7 set
FFFC40BC FC0000E3		bra		EXLP		; back for more matching
                        	EXMAT:
FFFC40C0 02E06193		ldi		r3,#'.'		; we've got a match so far
FFFC40C4 000EC903		lbu		a0,[$t3]		; end of table entry?
FFFC40C8 001E8E93		add		$t3,$t3,#1
FFFC40CC 08097D93		and		$t1,$a0,#$80
FFFC40D0 FA0D86E3		beq		$t1,$r0,EXLP		; test for bit 7 set, if not, go back for more
                        	EXGO:
                        		; execute the appropriate routine
FFFC40D4 000F5903		lhu		a0,[$t4]	; get the low mid order byte
FFFC40D8 FFFC0637		or		a0,a0,#$FFFC0000	; add in ROM base
FFFC40DC 00060613
FFFC40E0 01266933
FFFC40E4 00090067		jmp		[a0]
                        	
                        	    
                        	;******************************************************************
                        	;
                        	; What follows is the code to execute direct and statement
                        	; commands. Control is transferred to these points via the command
                        	; table lookup code of 'DIRECT' and 'EXEC' in the last section.
                        	; After the command is executed, control is transferred to other
                        	; sections as follows:
                        	;
                        	; For 'LISTX', 'NEW', and 'STOP': go back to the warm start point.
                        	; For 'RUN': go execute the first stored line if any; else go
                        	; back to the warm start point.
                        	; For 'GOTO' and 'GOSUB': go execute the target line.
                        	; For 'RETURN' and 'NEXT'; go back to saved return line.
                        	; For all others: if 'CURRNT' is 0, go to warm start; else go
                        	; execute next command. (This is done in 'FINISH'.)
                        	;
                        	;******************************************************************
                        	;
                        	; *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                        	;
                        	; 'NEW<CR>' sets TXTUNF to point to TXTBGN
                        	;
                        	
                        	NEW:
FFFC40E8 340010EF		call	ENDCHK
FFFC40EC 00032837		ldi		v0,#TXTBGN
FFFC40F0 80080813
FFFC40F4 00030637		sw		v0,TXTUNF	;	set the end pointer
FFFC40F8 00460613
FFFC40FC 00060633
FFFC4100 01062023
FFFC4104 168000EF		call  clearVars
                        	
                        	; 'STOP<CR>' goes back to WSTART
                        	;
                        	STOP:
FFFC4108 320010EF		call	ENDCHK
FFFC410C C15FF06F		jmp		WSTART		; WSTART will reset the stack
                        	
                        	;------------------------------------------------------------------------------
                        	; YIELD suspends execution of TinyBasic by switching to the next ready task.
                        	;------------------------------------------------------------------------------
                        	
                        	YIELD0:
FFFC4110 00D06913		ldi		a0,#13
FFFC4114 00000073		ecall
FFFC4118 2E00006F		jmp		FINISH
                        	
                        	;------------------------------------------------------------------------------
                        	; 'RUN<CR>' finds the first stored line, stores its address
                        	; in CURRNT, and starts executing it. Note that only those
                        	; commands in TAB2 are legal for a stored program.
                        	;
                        	; There are 3 more entries in 'RUN':
                        	; 'RUNNXL' finds next line, stores it's address and executes it.
                        	; 'RUNTSL' stores the address of this line and executes it.
                        	; 'RUNSML' continues the execution on same line.
                        	;
                        	RUN:
FFFC411C 30C010EF		call	ENDCHK
FFFC4120 00032E37		ldi		$t2,#TXTBGN	;	set pointer to beginning
FFFC4124 800E0E13
FFFC4128 00030637		sw		$t2,CURRNT
FFFC412C 01860613
FFFC4130 00060633
FFFC4134 01C62023
FFFC4138 134000EF		call  clearVars
                        	
                        	RUNNXL:					; RUN <next line>
FFFC413C 00030637		lw		$t2,CURRNT	; executing a program?
FFFC4140 01860613
FFFC4144 00060633
FFFC4148 00062E03
FFFC414C 000E1463		bne		$t2,x0,RUN3	; if not, we've finished a direct stat.
                        	RUN2:
FFFC4150 BD1FF06F		jmp		WSTART
                        	RUN3:
FFFC4154 00030637		lw		a0,IRQROUT		; are we handling IRQ's ?
FFFC4158 0A460613
FFFC415C 00060633
FFFC4160 00062903
FFFC4164 08090863		beq		a0,x0,RUN1
FFFC4168 00030637		lw		$t1,IRQFlag		; was there an IRQ ?
FFFC416C 0B460613
FFFC4170 00060633
FFFC4174 00062D83
FFFC4178 060D8E63		beq		$t1,x0,RUN1
FFFC417C 00030637		sw		x0,IRQFlag
FFFC4180 0B460613
FFFC4184 00060633
FFFC4188 00062023
FFFC418C 598010EF		call	PUSHA_		; the same code as a GOSUB
FFFC4190 FF470713		sub		$sp,$sp,#12
FFFC4194 00030637		lw		a0,STKGOS
FFFC4198 01460613
FFFC419C 00060633
FFFC41A0 00062903
FFFC41A4 01272023		sw		a0,[$sp]
FFFC41A8 00030637		lw		a0,CURRNT
FFFC41AC 01860613
FFFC41B0 00060633
FFFC41B4 00062903
FFFC41B8 01272223		sw		a0,4[$sp]
FFFC41BC 01C72423		sw		$t2,8[$sp]
FFFC41C0 00030637		sw		x0,LOPVAR		; load new values
FFFC41C4 01060613
FFFC41C8 00060633
FFFC41CC 00062023
FFFC41D0 00030637		sw		$sp,STKGOS
FFFC41D4 01460613
FFFC41D8 00060633
FFFC41DC 00E62023
FFFC41E0 00030637		lw		$t3,IRQROUT
FFFC41E4 0A460613
FFFC41E8 00060633
FFFC41EC 00062E83
FFFC41F0 02000263		bra		RUNTSL
                        	RUN1:
FFFC41F4 000E6EB3		mov		$t3,$t2
FFFC41F8 00006933		mov		a0,x0
FFFC41FC 404010EF		call	FNDLNP		; else find the next line number
FFFC4200 00030637		lw		$t1,TXTUNF	; if we've fallen off the end, stop
FFFC4204 00460613
FFFC4208 00060633
FFFC420C 00062D83
FFFC4210 F5BEF0E3		bgeu	$t3,$t1,RUN2
                        	
                        	RUNTSL:					; RUN <this line>
FFFC4214 00030637		sw		$t3,CURRNT	; set CURRNT to point to the line no.
FFFC4218 01860613
FFFC421C 00060633
FFFC4220 01D62023
FFFC4224 004E8E13		add		$t2,$t3,#4	; set the text pointer to
                        	
                        	RUNSML:                 ; RUN <same line>
FFFC4228 131010EF		call	CHKIO		; see if a control-C was pressed
FFFC422C FFFC4EB7		ldi		$t3,#TAB2		; find command in TAB2
FFFC4230 F3AE8E93
FFFC4234 FFFC4F37		ldi		$t4,#TAB2_1
FFFC4238 FF0F0F13
FFFC423C E35FF06F		jmp		EXEC		; and execute it
                        	
                        	
                        	;******************************************************************
                        	; 'GOTO expr<CR>' evaluates the expression, finds the target
                        	; line, and jumps to 'RUNTSL' to do it.
                        	;******************************************************************
                        	;
                        	GOTO:
FFFC4240 199000EF		call	OREXPR		;evaluate the following expression
FFFC4244 000862B3		mov   r5,v0
FFFC4248 1E0010EF		call 	ENDCHK		;must find end of line
FFFC424C 0002E933		mov   a0,r5
FFFC4250 390010EF		call 	FNDLN		; find the target line
FFFC4254 FC0810E3		bne		v0,x0,RUNTSL; go do it
FFFC4258 FFFC6937		ldi		a0,#msgBadGotoGosub
FFFC425C F3590913
FFFC4260 2180106F		jmp		ERROR		; no such line no.
                        	
                        	_clr:
FFFC4264 008000EF	    call    clearVars
FFFC4268 1900006F	    jmp     FINISH
                        	
                        	; Clear the variable area of memory
                        	clearVars:
FFFC426C FF870713		sub		$sp,$sp,#8
FFFC4270 00672023		sw		r6,[$sp]
FFFC4274 00172223		sw		$ra,4[$sp]
FFFC4278 06406313	  ldi   r6,#100    	; number of word pairs to clear
FFFC427C 00030637	  lw    v0,VARBGN
FFFC4280 00860613
FFFC4284 00060633
FFFC4288 00062803
                        	.cv1:
FFFC428C 00082023	  sw		x0,[$v0]		; variable name
FFFC4290 00082223	  sw		x0,4[$v0]		; and value
FFFC4294 00880813	  add		v0,v0,#8
FFFC4298 FFF30313	  sub		r6,r6,#1
FFFC429C FE6048E3		bgt		r6,x0,.cv1
FFFC42A0 00072303	  lw		r6,[$sp]
FFFC42A4 00472083	  lw		$ra,4[$sp]
FFFC42A8 00870713	  add		$sp,$sp,#8
FFFC42AC 00008067	  ret
                        	
                        	;******************************************************************
                        	; ONIRQ <line number>
                        	; ONIRQ sets up an interrupt handler which acts like a specialized
                        	; subroutine call. ONIRQ is coded like a GOTO that never executes.
                        	;******************************************************************
                        	;
                        	ONIRQ:
FFFC42B0 129000EF		call	OREXPR		;evaluate the following expression
FFFC42B4 000862B3		mov   r5,v0
FFFC42B8 170010EF		call 	ENDCHK		;must find end of line
FFFC42BC 0002E933		mov   a0,r5
FFFC42C0 320010EF		call 	FNDLN		; find the target line
FFFC42C4 00081C63		bne		v0,r0,ONIRQ1
FFFC42C8 00030637		sw		x0,IRQROUT
FFFC42CC 0A460613
FFFC42D0 00060633
FFFC42D4 00062023
FFFC42D8 1200006F		jmp		FINISH
                        	ONIRQ1:
FFFC42DC 00030637		sw		$t3,IRQROUT
FFFC42E0 0A460613
FFFC42E4 00060633
FFFC42E8 01D62023
FFFC42EC 10C0006F		jmp		FINISH
                        	
                        	WAITIRQ:
FFFC42F0 069010EF		call	CHKIO		; see if a control-C was pressed
FFFC42F4 00030637		lw		$t1,IRQFlag
FFFC42F8 0B460613
FFFC42FC 00060633
FFFC4300 00062D83
FFFC4304 FE0D86E3		beq		$t1,x0,WAITIRQ
FFFC4308 0F00006F		jmp		FINISH
                        	
                        	
                        	;******************************************************************
                        	; LIST
                        	;
                        	; LISTX has two forms:
                        	; 'LIST<CR>' lists all saved lines
                        	; 'LIST #<CR>' starts listing at the line #
                        	; Control-S pauses the listing, control-C stops it.
                        	;******************************************************************
                        	;
                        	LISTX:
FFFC430C 724010EF		call		TSTNUM		; see if there's a line no.
FFFC4310 000862B3		mov      r5,v0
FFFC4314 114010EF		call		ENDCHK		; if not, we get a zero
FFFC4318 0002E933		mov      a0,r5
FFFC431C 2C4010EF		call		FNDLN		; find this or next line
                        	LS1:
FFFC4320 00081C63		bne		v0,r0,LS4
                        	LS5:
FFFC4324 00030637		lw		$t1,TXTUNF
FFFC4328 00460613
FFFC432C 00060633
FFFC4330 00062D83
FFFC4334 9FBEF6E3		bgeu	$t3,$t1,WSTART	; warm start if we passed the end
                        	LS4:
FFFC4338 000EE933		mov		a0,$t3
FFFC433C 64C010EF		call	PRTLN		; print the line
FFFC4340 00086EB3		mov		$t3,$v0		; set pointer for next
FFFC4344 015010EF		call	CHKIO		; check for listing halt request
FFFC4348 00080A63		beq		v0,x0,LS3
FFFC434C 01306D93		ldi		$t1,#CTRLS
FFFC4350 01B81663		bne		v0,$t1,LS3; pause the listing?
                        	LS2:
FFFC4354 005010EF		call 	CHKIO		; if so, wait for another keypress
FFFC4358 FE080EE3		beq		v0,r0,LS2
                        	LS3:
                        	;	mov		$v0,$x0
FFFC435C FC0004E3		bra		LS5
                        	;	mov		a0,r0
                        	;	call	FNDSKP	;FNDLNP		; find the next line
                        	;	bra		LS1
                        	
                        	
                        	;******************************************************************
                        	; PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                        	; where '....' is a list of expressions, formats, back-arrows,
                        	; and strings.	These items a separated by commas.
                        	;
                        	; A format is a pound sign followed by a number.  It controls
                        	; the number of spaces the value of an expression is going to
                        	; be printed in.  It stays effective for the rest of the print
                        	; command unless changed by another format.  If no format is
                        	; specified, 11 positions will be used.
                        	;
                        	; A string is quoted in a pair of single- or double-quotes.
                        	;
                        	; An underline (back-arrow) means generate a <CR> without a <LF>
                        	;
                        	; A <CR LF> is generated after the entire list has been printed
                        	; or if the list is empty.  If the list ends with a semicolon,
                        	; however, no <CR LF> is generated.
                        	;******************************************************************
                        	;
                        	PRINT:
FFFC4360 00B06293		ldi		r5,#11		; D4 = number of print spaces
FFFC4364 680010EF		call	TSTC		; if null list and ":"
FFFC4368 0000003A		dw		':'
FFFC436C 00000663		bra		PR2
FFFC4370 011010EF		call	CRLF		; give CR-LF and continue
FFFC4374 EB5FF06F		jmp		RUNSML		;		execution on the same line
                        	PR2:
FFFC4378 66C010EF		call	TSTC		;if null list and <CR>
FFFC437C 0000000D		dw		CR
FFFC4380 00000663		bra		PR0
FFFC4384 7FC010EF		call	CRLF		;also give CR-LF and
FFFC4388 DB5FF06F		jmp		RUNNXL		;execute the next line
                        	PR0:
FFFC438C 658010EF		call	TSTC		;else is it a format?
FFFC4390 00000023		dw		'#'
FFFC4394 00000863		bra		PR1
FFFC4398 041000EF		call	OREXPR		; yes, evaluate expression
FFFC439C 000862B3		mov		r5,v0	; and save it as print width
FFFC43A0 02000263		bra		PR3		; look for more to print
                        	PR1:
FFFC43A4 640010EF		call	TSTC	;	is character expression? (MRL)
FFFC43A8 00000024		dw		'$'
FFFC43AC 00000863		bra		PR4
FFFC43B0 029000EF		call	OREXPR	;	yep. Evaluate expression (MRL)
FFFC43B4 855FF0EF		call	GOOUT	;	print low byte (MRL)
FFFC43B8 00000663		bra		PR3		;look for more. (MRL)
                        	PR4:
FFFC43BC 45C010EF		call	QTSTG	;	is it a string?
                        		; the following branch must occupy only 1 word!
FFFC43C0 02000063		bra		PR8		;	if not, must be an expression
                        	PR3:
FFFC43C4 620010EF		call		TSTC	;	if ",", go find next
FFFC43C8 0000002C		dw		','
FFFC43CC 00000663		bra		PR6
FFFC43D0 01C010EF		call		FIN		;in the list.
FFFC43D4 FA000CE3		bra		PR0
                        	PR6:
FFFC43D8 7A8010EF		call		CRLF		;list ends here
FFFC43DC 01C0006F		jmp		FINISH
                        	PR8:
FFFC43E0 7F8000EF		call	OREXPR		; evaluate the expression
FFFC43E4 00086933		mov		a0,v0
FFFC43E8 00506993		ldi		a1,#5		; set the width
FFFC43EC 00A06A13		ldi		a2,#10
FFFC43F0 4BC010EF		call	PRTNUM		; print its value
FFFC43F4 FC0008E3		bra		PR3			; more to print?
                        	
                        	
                        	FINISH:
FFFC43F8 7F5000EF		call	FIN		; Check end of command
FFFC43FC 0740106F		jmp		QWHAT	; print "What?" if wrong
                        	
                        	
                        	;*******************************************************************
                        	;
                        	; *** GOSUB *** & RETURN ***
                        	;
                        	; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                        	; except that the current text pointer, stack pointer, etc. are
                        	; saved so that execution can be continued after the subroutine
                        	; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                        	; recursive), the save area must be stacked.  The stack pointer
                        	; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                        	; If we are in the main routine, 'STKGOS' is zero (this was done
                        	; in the initialization section of the interpreter), but we still
                        	; save it as a flag for no further 'RETURN's.
                        	;******************************************************************
                        	;
                        	GOSUB:
FFFC4400 324010EF		call	PUSHA_		; save the current 'FOR' parameters
FFFC4404 7D4000EF		call	OREXPR		; get line number
FFFC4408 00086933		mov		$a0,$v0
FFFC440C 1D4010EF		call	FNDLN		; find the target line
FFFC4410 00081863		bne		v0,r0,gosub1
FFFC4414 FFFC6937		ldi		a0,#msgBadGotoGosub
FFFC4418 F3590913
FFFC441C 05C0106F		jmp		ERROR		; if not there, say "How?"
                        	gosub1:
FFFC4420 FF470713		sub		$sp,$sp,#12
FFFC4424 00030637		lw		a0,STKGOS	; 'STKGOS'
FFFC4428 01460613
FFFC442C 00060633
FFFC4430 00062903
FFFC4434 01272023		sw		a0,[$sp]
FFFC4438 00030637		lw		a0,CURRNT	; found it, save old 'CURRNT'...
FFFC443C 01860613
FFFC4440 00060633
FFFC4444 00062903
FFFC4448 01272223		sw		a0,4[$sp]
FFFC444C 01C72423		sw		$t2,8[$sp]
FFFC4450 00030637		sw		$x0,LOPVAR		; load new values
FFFC4454 01060613
FFFC4458 00060633
FFFC445C 00062023
FFFC4460 00030637		sw		$sp,STKGOS
FFFC4464 01460613
FFFC4468 00060633
FFFC446C 00E62023
FFFC4470 DA5FF06F		jmp		RUNTSL
                        	
                        	
                        	;******************************************************************
                        	; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                        	; returns the execution to the command after the most recent
                        	; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                        	; a 'GOSUB' and is thus an error.
                        	;******************************************************************
                        	;
                        	RETURN:
FFFC4474 7B5000EF		call	ENDCHK		; there should be just a <CR>
FFFC4478 00030637		lw		a1,STKGOS		; get old stack pointer
FFFC447C 01460613
FFFC4480 00060633
FFFC4484 00062983
FFFC4488 00099863		bne		a1,x0,return1
FFFC448C FFFC6937		ldi		a0,#msgRetWoGosub
FFFC4490 F5190913
FFFC4494 7E50006F		jmp		ERROR		; if zero, it doesn't exist
                        	return1:
FFFC4498 0009E733		mov		$sp,a1		; else restore it
FFFC449C 00072903		lw		a0,[$sp]
FFFC44A0 00470713		add		$sp,$sp,#4
FFFC44A4 00030637		sw		a0,STKGOS	; and the old 'STKGOS'
FFFC44A8 01460613
FFFC44AC 00060633
FFFC44B0 01262023
FFFC44B4 00072903		lw		a0,[$sp]
FFFC44B8 00470713		add		$sp,$sp,#4
FFFC44BC 00030637		sw		a0,CURRNT	; and the old 'CURRNT'
FFFC44C0 01860613
FFFC44C4 00060633
FFFC44C8 01262023
FFFC44CC 00072E03		lw		$t2,[$sp]	; and the old text pointer
FFFC44D0 00470713		add		$sp,$sp,#4
FFFC44D4 1DC010EF		call	POPA_		;and the old 'FOR' parameters
FFFC44D8 F21FF06F		jmp		FINISH		;and we are back home
                        	
                        	;******************************************************************
                        	; *** FOR *** & NEXT ***
                        	;
                        	; 'FOR' has two forms:
                        	; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                        	; The second form means the same thing as the first form with a
                        	; STEP of positive 1.  The interpreter will find the variable 'var'
                        	; and set its value to the current value of 'exp1'.  It also
                        	; evaluates 'exp2' and 'exp1' and saves all these together with
                        	; the text pointer, etc. in the 'FOR' save area, which consists of
                        	; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                        	; already something in the save area (indicated by a non-zero
                        	; 'LOPVAR'), then the old save area is saved on the stack before
                        	; the new values are stored.  The interpreter will then dig in the
                        	; stack and find out if this same variable was used in another
                        	; currently active 'FOR' loop.  If that is the case, then the old
                        	; 'FOR' loop is deactivated. (i.e. purged from the stack)
                        	;******************************************************************
                        	;
                        	FOR:
FFFC44DC 248010EF		call	PUSHA_		; save the old 'FOR' save area
FFFC44E0 6A5000EF		call	SETVAL		; set the control variable
FFFC44E4 00030637		sw		v0,LOPVAR		; save its address
FFFC44E8 01060613
FFFC44EC 00060633
FFFC44F0 01062023
FFFC44F4 FFFC4EB7		ldi		$t3,#TAB5
FFFC44F8 FCCE8E93
FFFC44FC FFFC4F37		ldi		$t4,#TAB5_1	; use 'EXEC' to test for 'TO'
FFFC4500 038F0F13
FFFC4504 B6DFF06F		jmp		EXEC
                        	FR1:
FFFC4508 6D0000EF		call	OREXPR		; evaluate the limit
FFFC450C 00030637		sw		v0,LOPLMT	; save that
FFFC4510 07C60613
FFFC4514 00060633
FFFC4518 01062023
FFFC451C FFFC4EB7		ldi		$t3,#TAB6
FFFC4520 FCFE8E93
FFFC4524 FFFC4F37		ldi		$t4,#TAB6_1	; use 'EXEC' to test for the word 'STEP
FFFC4528 03CF0F13
FFFC452C B45FF06F		jmp		EXEC
                        	FR2:
FFFC4530 6A8000EF		call	OREXPR		; found it, get the step value
FFFC4534 00000463		bra		FR4
                        	FR3:
FFFC4538 00106813		ldi		v0,#1		; not found, step defaults to 1
                        	FR4:
FFFC453C 00030637		sw		v0,LOPINC	; save that too
FFFC4540 07860613
FFFC4544 00060633
FFFC4548 01062023
                        	FR5:
FFFC454C 00030637		lw		a1,CURRNT
FFFC4550 01860613
FFFC4554 00060633
FFFC4558 00062983
FFFC455C 00030637		sw		a1,LOPLN	; save address of current line number
FFFC4560 07460613
FFFC4564 00060633
FFFC4568 01362023
FFFC456C 00030637		sw		$t2,LOPPT	; and text pointer
FFFC4570 07060613
FFFC4574 00060633
FFFC4578 01C62023
FFFC457C 000761B3		mov		r3,$sp		; dig into the stack to find 'LOPVAR'
FFFC4580 00030637		lw		r6,LOPVAR
FFFC4584 01060613
FFFC4588 00060633
FFFC458C 00062303
FFFC4590 00000463		bra		FR7
                        	FR6:
FFFC4594 01418193		add		r3,r3,#20	; look at next stack frame
                        	FR7:
FFFC4598 0001A983		lw		a1,[r3]		; is it zero?
FFFC459C 00098E63		beq		a1,x0,FR8	; if so, we're done
FFFC45A0 FE699AE3		bne		a1,r6,FR6	; same as current LOPVAR? nope, look some more
                        	
FFFC45A4 0001E933	  mov		a0,r3	   ; Else remove 5 words from...
FFFC45A8 000769B3		mov		a1,$sp
FFFC45AC 01418A13		add		a2,r3,#20  ; inside the stack.
FFFC45B0 0F8010EF		call	MVDOWN
FFFC45B4 01470713		add		$sp,$sp,#20	; set the SP 5 long words up
                        	;	lw		a0,[$sp]		; ???
                        	;	add		$sp,$sp,#4
                        	FR8:
FFFC45B8 E41FF06F	  jmp	    FINISH		; and continue execution
                        	
                        	
                        	;******************************************************************
                        	; 'NEXT var' serves as the logical (not necessarily physical) end
                        	; of the 'FOR' loop.  The control variable 'var' is checked with
                        	; the 'LOPVAR'.  If they are not the same, the interpreter digs in
                        	; the stack to find the right one and purges all those that didn't
                        	; match.  Either way, it then adds the 'STEP' to that variable and
                        	; checks the result with against the limit value.  If it is within
                        	; the limit, control loops back to the command following the
                        	; 'FOR'.  If it's outside the limit, the save area is purged and
                        	; execution continues.
                        	;******************************************************************
                        	;
                        	NEXT:
FFFC45BC 00006933		mov		a0,x0		; don't allocate it
FFFC45C0 259000EF		call	TSTV		; get address of variable
FFFC45C4 00081863		bne		v0,x0,NX4
FFFC45C8 FFFC6937		ldi		a0,#msgNextVar
FFFC45CC F1290913
FFFC45D0 6A0004E3		bra		ERROR		; if no variable, say "What?"
                        	NX4:
FFFC45D4 00086EB3		mov		$t3,v0	; save variable's address
                        	NX0:
FFFC45D8 00030637		lw		a0,LOPVAR	; If 'LOPVAR' is zero, we never...
FFFC45DC 01060613
FFFC45E0 00060633
FFFC45E4 00062903
FFFC45E8 00091863		bne		a0,x0,NX5	; had a FOR loop
FFFC45EC FFFC6937		ldi		a0,#msgNextFor
FFFC45F0 F0090913
FFFC45F4 680002E3		bra		ERROR
                        	NX5:
FFFC45F8 01D90663		beq		a0,$t3,NX2	; else we check them OK, they agree
FFFC45FC 0B4010EF		call	POPA_		; nope, let's see the next frame
FFFC4600 FC000CE3		bra		NX0
                        	NX2:
FFFC4604 000EA903		lw		a0,[$t3]		; get control variable's value
FFFC4608 00030637		lw		a1,LOPINC
FFFC460C 07860613
FFFC4610 00060633
FFFC4614 00062983
FFFC4618 01390933		add		a0,a0,a1	; add in loop increment
                        	;	BVS.L	QHOW		say "How?" for 32-bit overflow
FFFC461C 012EA023		sw		a0,[$t3]		; save control variable's new value
FFFC4620 00030637		lw		r3,LOPLMT	; get loop's limit value
FFFC4624 07C60613
FFFC4628 00060633
FFFC462C 00062183
FFFC4630 0009D663		bge		a1,x0,NX1	; check loop increment, branch if loop increment is positive
FFFC4634 04394063		blt		a0,r3,NXPurge	; test against limit
FFFC4638 00000463		bra     NX3
                        	NX1:
FFFC463C 0321CC63		bgt		a0,r3,NXPurge
                        	NX3:
FFFC4640 00030637		lw		$t2,LOPLN	; Within limit, go back to the...
FFFC4644 07460613
FFFC4648 00060633
FFFC464C 00062E03
FFFC4650 00030637		sw		$t2,CURRNT
FFFC4654 01860613
FFFC4658 00060633
FFFC465C 01C62023
FFFC4660 00030637		lw		$t2,LOPPT	; saved 'CURRNT' and text pointer.
FFFC4664 07060613
FFFC4668 00060633
FFFC466C 00062E03
FFFC4670 D89FF06F		jmp		FINISH
                        	NXPurge:
FFFC4674 03C010EF	  call    POPA_        ; purge this loop
FFFC4678 D81FF06F	  jmp     FINISH
                        	
                        	
                        	;******************************************************************
                        	; *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                        	;
                        	; 'REM' can be followed by anything and is ignored by the
                        	; interpreter.
                        	;
                        	;REM
                        	;    br	    IF2		    ; skip the rest of the line
                        	; 'IF' is followed by an expression, as a condition and one or
                        	; more commands (including other 'IF's) separated by colons.
                        	; Note that the word 'THEN' is not used.  The interpreter evaluates
                        	; the expression.  If it is non-zero, execution continues.  If it
                        	; is zero, the commands that follow are ignored and execution
                        	; continues on the next line.
                        	;******************************************************************
                        	;
                        	IF0:
FFFC467C 55C000EF	  call	OREXPR		; evaluate the expression
                        	IF1:
FFFC4680 00080463	  beq	  v0,x0,IF2	; is it zero? if not, continue
FFFC4684 BA5FF06F	  jmp		RUNSML
                        	IF2:
FFFC4688 000E6EB3	  mov		$t3,$t2	; set lookup pointer
FFFC468C 00006933		mov		a0,x0		; find line #0 (impossible)
FFFC4690 7DD000EF		call	FNDSKP		; if so, skip the rest of the line
FFFC4694 00081463		bne		v0,x0,IF3; if no next line, do a warm start
FFFC4698 E88FF06F		jmp		WSTART
                        	IF3:
FFFC469C B79FF06F		jmp		RUNTSL		; run the next line
                        	
                        	
                        	;******************************************************************
                        	; INPUT is called first and establishes a stack frame
                        	INPERR:
FFFC46A0 00030637		lw		$sp,STKINP		; restore the old stack pointer
FFFC46A4 09860613
FFFC46A8 00060633
FFFC46AC 00062703
FFFC46B0 00072903		lw		a0,[$sp]
FFFC46B4 00470713		add		$sp,$sp,#4
FFFC46B8 00030637		sw		a0,CURRNT		; and old 'CURRNT'
FFFC46BC 01860613
FFFC46C0 00060633
FFFC46C4 01262023
FFFC46C8 00072E03		lw		$t2,[$sp]		; and old text pointer
FFFC46CC 00470713		add		$sp,$sp,#4
FFFC46D0 01470713		add		$sp,$sp,#20	; fall through will subtract 20
                        	
                        	; 'INPUT' is like the 'PRINT' command, and is followed by a list
                        	; of items.  If the item is a string in single or double quotes,
                        	; or is an underline (back arrow), it has the same effect as in
                        	; 'PRINT'.  If an item is a variable, this variable name is
                        	; printed out followed by a colon, then the interpreter waits for
                        	; an expression to be typed in.  The variable is then set to the
                        	; value of this expression.  If the variable is preceeded by a
                        	; string (again in single or double quotes), the string will be
                        	; displayed followed by a colon.  The interpreter the waits for an
                        	; expression to be entered and sets the variable equal to the
                        	; expression's value.  If the input expression is invalid, the
                        	; interpreter will print "What?", "How?", or "Sorry" and reprint
                        	; the prompt and redo the input.  The execution will not terminate
                        	; unless you press control-C.  This is handled in 'INPERR'.
                        	;
                        	INPUT:
FFFC46D4 FEC70713		sub		$sp,$sp,#20	; allocate five words on stack
FFFC46D8 00572823		sw		r5,16[$sp]	; save off r5 into stack var
                        	IP6:
FFFC46DC 01C72023		sw		$t2,[$sp]	; save in case of error
FFFC46E0 138010EF		call	QTSTG		; is next item a string?
FFFC46E4 00000C63		bra		IP2			; nope - this branch must take only 1 word
FFFC46E8 00106913		ldi		a0,#1		; allocate var
FFFC46EC 12D000EF		call	TSTV		; yes, but is it followed by a variable?
FFFC46F0 0A090E63		beq    a0,r0,IP4   ; if not, brnch
FFFC46F4 00096F33		mov		$t4,a0		; put away the variable's address
FFFC46F8 04000063		bra		IP3			; if so, input to variable
                        	IP2:
FFFC46FC 01C72223		sw		$t2,4[$sp]	; save off in stack var for 'PRTSTG'
FFFC4700 00106913		ldi		a0,#1
FFFC4704 115000EF		call	TSTV		; must be a variable now
FFFC4708 00091A63		bne		a0,r0,IP7
FFFC470C FFFC6937		ldi		a0,#msgInputVar
FFFC4710 EE490913
FFFC4714 01470713		add		$sp,$sp,#20	; cleanup stack
FFFC4718 560000E3		bra		ERROR		; "What?" it isn't?
                        	IP7:
FFFC471C 00096F33		mov		$t4,a0		; put away the variable's address
FFFC4720 000E4283		lbu		r5,[$t2]		; get ready for 'PRTSTG' by null terminating
FFFC4724 000E0023		sb		x0,[$t2]
FFFC4728 000069B3		mov		a1,x0
FFFC472C 00472903		lw		a0,4[$sp]	; get back text pointer
FFFC4730 080010EF		call	PRTSTG		; print string as prompt
FFFC4734 005E0023		sb		r5,[$t2]		; un-null terminate
                        	IP3
FFFC4738 01C72223		sw		$t2,4[$sp]	; save in case of error
FFFC473C 00030637		lw		a0,CURRNT
FFFC4740 01860613
FFFC4744 00060633
FFFC4748 00062903
FFFC474C 01272423		sw		a0,8[$sp]	; also save 'CURRNT'
FFFC4750 FFF06913		ldi		a0,#-1
FFFC4754 00030637		sw		a0,CURRNT	; flag that we are in INPUT
FFFC4758 01860613
FFFC475C 00060633
FFFC4760 01262023
FFFC4764 00030637		sw		$sp,STKINP	; save the stack pointer too
FFFC4768 09860613
FFFC476C 00060633
FFFC4770 00E62023
FFFC4774 01E72623		sw		$t4,12[$sp]	; save the variable address
FFFC4778 03A06913		ldi		a0,#':'		; print a colon first
FFFC477C 559000EF		call	GETLN		; then get an input line
FFFC4780 00030E37		ldi		$t2,#BUFFER	; point to the buffer
FFFC4784 01CE0E13
FFFC4788 450000EF		call	OREXPR		; evaluate the input
FFFC478C 00C72F03		lw		$t4,12[$sp]	; restore the variable address
FFFC4790 012F2023		sw		a0,[$t4]	; save value in variable
FFFC4794 00872903		lw		a0,8[$sp]	; restore old 'CURRNT'
FFFC4798 00030637		sw		a0,CURRNT
FFFC479C 01860613
FFFC47A0 00060633
FFFC47A4 01262023
FFFC47A8 00472E03		lw		$t2,4[$sp]	; and the old text pointer
                        	IP4:
FFFC47AC 238010EF		call	TSTC
FFFC47B0 0000002C		dw		','
FFFC47B4 00000463		bra		IP5
FFFC47B8 F20002E3		bra		IP6			; yes, more items
                        	IP5:
FFFC47BC 01072283		lw		r5,16[$sp]
FFFC47C0 01470713		add		$sp,$sp,#20	; cleanup stack
FFFC47C4 C35FF06F	 	jmp		FINISH
                        	
                        	
                        	DEFLT:
FFFC47C8 000E4903	  lbu    	a0,[$t2]
FFFC47CC 00D06D93	  ldi			$t1,#CR
FFFC47D0 C3B904E3		beq	    a0,$t1,FINISH	    ; empty line is OK else it is 'LET'
                        	
                        	
                        	;******************************************************************
                        	; 'LET' is followed by a list of items separated by commas.
                        	; Each item consists of a variable, an equals sign, and an
                        	; expression.  The interpreter evaluates the expression and sets
                        	; the variable to that value.  The interpreter will also handle
                        	; 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                        	;******************************************************************
                        	;
                        	LET:
FFFC47D4 3B1000EF	  call	SETVAL		; do the assignment
FFFC47D8 20C010EF		call	TSTC		; check for more 'LET' items
FFFC47DC 0000002C		dw		','
FFFC47E0 C19FF06F		jmp		FINISH
FFFC47E4 FE0008E3		bra	    LET
                        	LT1:
FFFC47E8 C11FF06F	  jmp	    FINISH		; until we are finished.
                        	
                        	
                        	;******************************************************************
                        	; *** LOAD *** & SAVE ***
                        	;
                        	; These two commands transfer a program to/from an auxiliary
                        	; device such as a cassette, another computer, etc.  The program
                        	; is converted to an easily-stored format: each line starts with
                        	; a colon, the line no. as 4 hex digits, and the rest of the line.
                        	; At the end, a line starting with an '@' sign is sent.  This
                        	; format can be read back with a minimum of processing time by
                        	; the RTF65002
                        	;******************************************************************
                        	;
                        	LOAD
FFFC47EC 00032E37		ldi		$t2,#TXTBGN	; set pointer to start of prog. area
FFFC47F0 800E0E13
FFFC47F4 00D06913		ldi		a0,#CR		; For a CP/M host, tell it we're ready...
FFFC47F8 C18FF0EF		call	GOAUXO		; by sending a CR to finish PIP command.
                        	LOD1:
FFFC47FC C1CFF0EF		call	GOAUXI		; look for start of line
FFFC4800 FF205EE3		ble		a0,r0,LOD1
FFFC4804 04006D93		ldi		$t1,#'@'
FFFC4808 03B90E63		beq		a0,$t1,LODEND	; end of program?
FFFC480C 01A06D93		ldi		$t1,#$1A
FFFC4810 03B90A63		beq		a0,$t1,LODEND	; or EOF marker
FFFC4814 03A06D93		ldi		$t1,#':'
FFFC4818 FFB912E3		bne		a0,$t1,LOD1	; if not, is it start of line? if not, wait for it
FFFC481C 03C000EF		call	GCHAR		; get line number
FFFC4820 012E2023		sw		a0,[$t2]		; store it
FFFC4824 004E0E13		add		$t2,$t2,#4
                        	LOD2:
FFFC4828 BF0FF0EF		call	GOAUXI		; get another text char.
FFFC482C FF205EE3		ble		a0,r0,LOD2
FFFC4830 012E0023		sb		a0,[$t2]		; store it
FFFC4834 001E0E13		add		$t2,$t2,#1
FFFC4838 00D06D93		ldi		$t1,#CR
FFFC483C FFB916E3		bne		a0,$t1,LOD2		; is it the end of the line? if not, go back for more
FFFC4840 FA000EE3		bra		LOD1		; if so, start a new line
                        	LODEND:
FFFC4844 00030637		sw		$t2,TXTUNF	; set end-of program pointer
FFFC4848 00460613
FFFC484C 00060633
FFFC4850 01C62023
FFFC4854 CCCFF06F		jmp		WSTART		; back to direct mode
                        	
                        	
                        	; get character from input (32 bit value)
                        	GCHAR:
FFFC4858 FF470713		sub		$sp,$sp,#12
FFFC485C 00572023		sw		r5,[$sp]
FFFC4860 00672223		sw		r6,4[$sp]
FFFC4864 00172423		sw		$ra,8[$sp]
FFFC4868 00806313		ldi		r6,#8       ; repeat ten times
FFFC486C 00006293		ldi		r5,#0
                        	GCHAR1:
FFFC4870 BA8FF0EF		call	GOAUXI		; get a char
FFFC4874 FF205EE3		ble		a0,r0,GCHAR1
FFFC4878 02C000EF		call	asciiToHex
FFFC487C 00429293		sll		r5,r5,#4
FFFC4880 0122E2B3		or		r5,r5,a0
FFFC4884 FFF30313		sub		r6,r6,#1
FFFC4888 FE6064E3		bgtu	r6,r0,GCHAR1
FFFC488C 0002E933		mov		a0,r5
FFFC4890 00072283		lw		r5,[$sp]
FFFC4894 00472303		lw		r6,4[$sp]
FFFC4898 00872083		lw		$ra,8[$sp]
FFFC489C 00C70713		add		$sp,$sp,#12
FFFC48A0 00008067		ret
                        	
                        	; convert an ascii char to hex code
                        	; input
                        	;	a0 = char to convert
                        	
                        	asciiToHex:
FFFC48A4 03906D93		ldi		$t1,#'9'
FFFC48A8 012DF463		bleu	a0,$t1,a2h1; less than '9'
FFFC48AC FF990913		sub		a0,a0,#7	; shift 'A' to '9'+1
                        	a2h1:
FFFC48B0 FD090913		sub		a0,a0,#'0'
FFFC48B4 00F97913		and		a0,a0,#15	; make sure a nybble
FFFC48B8 00008067		ret
                        	
                        	GetFilename:
FFFC48BC FFC70713		sub		$sp,$sp,#4
FFFC48C0 00172023		sw		$ra,[$sp]
FFFC48C4 120010EF		call	TSTC
FFFC48C8 00000022		dw		'"'
FFFC48CC 06000863		bra		gfn1
FFFC48D0 000061B3		mov		r3,r0
                        	gfn2:
FFFC48D4 000E4903		lbu		a0,[$t2]		; get text character
FFFC48D8 001E0E13		add		$t2,$t2,#1
FFFC48DC 02206D93		ldi		$t1,#'"'
FFFC48E0 03B90863		beq		a0,$t1,gfn3
FFFC48E4 02090663		beq		a0,r0,gfn3
FFFC48E8 0003F637		sb		a0,FILENAME[r3]
FFFC48EC 6C060613
FFFC48F0 00360633
FFFC48F4 01260023
FFFC48F8 00118193		add		r3,r3,#1
FFFC48FC 04006D93		ldi		$t1,#64
FFFC4900 FDB1EAE3		bltu	r3,$t1,gfn2
FFFC4904 00072083		lw		$ra,[$sp]
FFFC4908 00470713		add		$sp,$sp,#4
FFFC490C 00008067		ret
                        	gfn3:
FFFC4910 02006913		ldi		a0,#' '
FFFC4914 0003F637		sb		a0,FILENAME[r3]
FFFC4918 6C060613
FFFC491C 00360633
FFFC4920 01260023
FFFC4924 00118193		add		r3,r3,#1
FFFC4928 04006D93		ldi		$t1,#64
FFFC492C FFB1E2E3		bltu	r3,$t1,gfn3
FFFC4930 00072083		lw		$ra,[$sp]
FFFC4934 00470713		add		$sp,$sp,#4
FFFC4938 00008067		ret
                        	gfn1:
FFFC493C BE4FF06F		jmp		WSTART
                        	
                        	LOAD3:
FFFC4940 F7DFF0EF		call	GetFilename
FFFC4944 00000637		call	AUXIN_INIT
FFFC4948 377600E7
FFFC494C EA1FF06F		jmp		LOAD
                        	
                        	;	call		OREXPR		;evaluate the following expression
                        	;	ld		a0,#5000
FFFC4950 000019B7		ldi		a1,#$E00
FFFC4954 E0098993
FFFC4958 00000637		call	SDReadSector
FFFC495C 378600E7
FFFC4960 00190913		add		a0,a0,#1
FFFC4964 000329B7		ldi		a1,#TXTBGN
FFFC4968 80098993
                        	LOAD4:
FFFC496C FFC70713		sub		$sp,$sp,#4
FFFC4970 01272023		sw		a0,[$sp]
FFFC4974 00000637		call	SDReadSector
FFFC4978 378600E7
FFFC497C 20098993		add		a1,a1,#512
FFFC4980 00072903		lw		a0,[$sp]
FFFC4984 00470713		add		$sp,$sp,#4
FFFC4988 00190913		add		a0,a0,#1
FFFC498C 00032237		ldi		r4,#TXTBGN
FFFC4990 80020213
FFFC4994 00010637		add		r4,r4,#65536
FFFC4998 00060613
FFFC499C 00460233
FFFC49A0 FC49C6E3		blt		a1,r4,LOAD4
                        	LOAD5:
FFFC49A4 B6000E63		bra		WSTART
                        	
                        	
                        	SAVE3:
FFFC49A8 F15FF0EF		call	GetFilename
FFFC49AC 00000637		call	AUXOUT_INIT
FFFC49B0 37B600E7
FFFC49B4 0600006F		jmp		SAVE
                        	
FFFC49B8 220000EF		call	OREXPR		;evaluate the following expression
                        	;	lda		#5000		; starting sector
FFFC49BC 000019B7		ldi		a1,#$E00	; starting address to write
FFFC49C0 E0098993
FFFC49C4 00000637		call	SDWriteSector
FFFC49C8 37D600E7
FFFC49CC 00190913		add		a0,a0,#1
FFFC49D0 000329B7		ldi		a1,#TXTBGN
FFFC49D4 80098993
                        	SAVE4:
FFFC49D8 FFC70713		sub		$sp,$sp,#4
FFFC49DC 01272023		sw		a0,[$sp]
FFFC49E0 00000637		call	SDWriteSector
FFFC49E4 37D600E7
FFFC49E8 20098993		add		a1,a1,#512
FFFC49EC 00072903		lw		a0,[$sp]
FFFC49F0 00470713		add		$sp,$sp,#4
FFFC49F4 00190913		add		a0,a0,#1
FFFC49F8 00032237		ldi		r4,#TXTBGN
FFFC49FC 80020213
FFFC4A00 00010637		add		r4,r4,#65536
FFFC4A04 00060613
FFFC4A08 00460233
FFFC4A0C FC49C6E3		blt		a1,r4,SAVE4
FFFC4A10 B0000863		bra		WSTART
                        	
                        	SAVE:
FFFC4A14 00032E37		ldi		$t2,#TXTBGN	;set pointer to start of prog. area
FFFC4A18 800E0E13
FFFC4A1C 00030637		lw		$t3,TXTUNF	;set pointer to end of prog. area
FFFC4A20 00460613
FFFC4A24 00060633
FFFC4A28 00062E83
                        	SAVE1:
FFFC4A2C 054000EF		call	AUXOCRLF    ; send out a CR & LF (CP/M likes this)
FFFC4A30 03CEC863		bgt		$t2,$t3,SAVEND; are we finished?
FFFC4A34 03A06913		ldi		a0,#':'		; if not, start a line
FFFC4A38 9D8FF0EF		call	GOAUXO
FFFC4A3C 000E2903		lw		a0,[$t2]		; get line number
FFFC4A40 004E0E13		add		$t2,$t2,#4
FFFC4A44 060000EF		call	PWORD       ; output line number as 5-digit hex
                        	SAVE2:
FFFC4A48 000E4903		lbu		a0,[$t2]		; get a text char.
FFFC4A4C 001E0E13		add		$t2,$t2,#1
FFFC4A50 00D06D93		ldi		$t1,#CR
FFFC4A54 FDB90CE3		beq		a0,$t1,SAVE1	; is it the end of the line? if so, send CR & LF and start new line
FFFC4A58 9B8FF0EF		call	GOAUXO		; send it out
FFFC4A5C FE0006E3		bra		SAVE2		; go back for more text
                        	SAVEND:
FFFC4A60 04006913		ldi		a0,#'@'		; send end-of-program indicator
FFFC4A64 9ACFF0EF		call	GOAUXO
FFFC4A68 018000EF		call	AUXOCRLF    ; followed by a CR & LF
FFFC4A6C 01A06913		ldi		a0,#$1A		; and a control-Z to end the CP/M file
FFFC4A70 9A0FF0EF		call	GOAUXO
FFFC4A74 00000637		call	AUXOUT_FLUSH
FFFC4A78 384600E7
FFFC4A7C AA000263		bra		WSTART		; then go do a warm start
                        	
                        	; output a CR LF sequence to auxillary output
                        	; Registers Affected
                        	;   r3 = LF
                        	AUXOCRLF:
FFFC4A80 FFC70713		sub		$sp,$sp,#4
FFFC4A84 00172023		sw		$ra,[$sp]
FFFC4A88 00D06913	  ldi		a0,#CR
FFFC4A8C 984FF0EF	  call	GOAUXO
FFFC4A90 00A06913	  ldi		a0,#LINEFD
FFFC4A94 97CFF0EF	  call	GOAUXO
FFFC4A98 00072083	  lw		$ra,[$sp]
FFFC4A9C 00470713	  add		$sp,$sp,#4
FFFC4AA0 00008067	  ret
                        	
                        	
                        	; output a word in hex format
                        	; tricky because of the need to reverse the order of the chars
                        	PWORD:
FFFC4AA4 FF870713		sub		$sp,$sp,#8
FFFC4AA8 00572023		sw		r5,[$sp]
FFFC4AAC 00172223		sw		$ra,4[$sp]
FFFC4AB0 000302B7		ldi		r5,#NUMWKA+14
FFFC4AB4 0A228293
FFFC4AB8 00096233		mov		r4,a0		; r4 = value
                        	pword1:
FFFC4ABC 00026933	  mov   a0,r4	    ; a0 = value
FFFC4AC0 00425213	  srl		r4,r4,#4	; shift over to next nybble
FFFC4AC4 040000EF	  call	toAsciiHex  ; convert LS nybble to ascii hex
FFFC4AC8 01228023	  sb    a0,[r5]		; save in work area
FFFC4ACC FFF28293	  sub		r5,r5,#1
FFFC4AD0 00030DB7	  ldi		$t1,#NUMWKA
FFFC4AD4 094D8D93
FFFC4AD8 FFB2D2E3		bge		r5,$t1,pword1
                        	pword2:
FFFC4ADC 00128293	  add		r5,r5,#1
FFFC4AE0 0002C903	  lbu   a0,[r5]     ; get char to output
FFFC4AE4 92CFF0EF		call	GOAUXO		; send it
FFFC4AE8 00030DB7		ldi		$t1,#NUMWKA+14
FFFC4AEC 0A2D8D93
FFFC4AF0 FFB2C6E3		blt		r5,$t1,pword2
FFFC4AF4 00072283		lw		r5,[$sp]
FFFC4AF8 00472083		lw		$ra,4[$sp]
FFFC4AFC 00870713		add		$sp,$sp,#8
FFFC4B00 00008067		ret
                        	
                        	; convert nybble in a1 to ascii hex chaa1
                        	; a1 = character to convert
                        	
                        	toAsciiHex:
FFFC4B04 00F97913		and		a0,a0,#15	; make sure it's a nybble
FFFC4B08 00A06D93		ldi		$t1,#10
FFFC4B0C 01B94463		blt		a0,$t1,tah1	; > 10 ?
FFFC4B10 00790913		add		a0,a0,#7	; bump it up to the letter 'A'
                        	tah1:
FFFC4B14 03090913		add		a0,a0,#'0'	; bump up to ascii '0'
FFFC4B18 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	; *** POKE ***
                        	;
                        	; 'POKE expr1,expa1' stores the byte from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEW expr1,expa1' stores the word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	; 'POKEH expr1,expa1' stores the half-word from 'expa1' into the memory
                        	; address specified by 'expr1'.
                        	;******************************************************************
                        	;
                        	POKE:
FFFC4B1C 0BC000EF		call	OREXPR		; get the memory address
FFFC4B20 6C5000EF		call	TSTC		; it must be followed by a comma
FFFC4B24 0000002C		dw		','
FFFC4B28 06000C63		bra		PKER
FFFC4B2C FFC70713		sub		$sp,$sp,#4
FFFC4B30 01272023		sw		a0,[$sp]	; save the address
FFFC4B34 0A4000EF		call	OREXPR		; get the byte to be POKE'd
FFFC4B38 00072983		lw		a1,[$sp]	; get the address back
FFFC4B3C 00470713		add		$sp,$sp,#4
FFFC4B40 01298023		sb		a0,[a1]		; store the byte in memory
FFFC4B44 8B5FF06F		jmp		FINISH
                        	
                        	POKEW:
FFFC4B48 090000EF		call	OREXPR		; get the memory address
FFFC4B4C 699000EF		call	TSTC		; it must be followed by a comma
FFFC4B50 0000002C		dw		','
FFFC4B54 04000663		bra		PKER
FFFC4B58 FFC70713		sub		$sp,$sp,#4
FFFC4B5C 01272023		sw		a0,[$sp]	; save the address
FFFC4B60 078000EF		call	OREXPR		; get the byte to be POKE'd
FFFC4B64 00072983		lw		a1,[$sp]	; get the address back
FFFC4B68 00470713		add		$sp,$sp,#4
FFFC4B6C 0129A023		sw		a0,[a1]		; store the byte in memory
FFFC4B70 889FF06F		jmp		FINISH
                        	
                        	POKEH:
FFFC4B74 064000EF		call	OREXPR		; get the memory address
FFFC4B78 66D000EF		call	TSTC		; it must be followed by a comma
FFFC4B7C 0000002C		dw		','
FFFC4B80 02000063		bra		PKER
FFFC4B84 FFC70713		sub		$sp,$sp,#4
FFFC4B88 01272023		sw		a0,[$sp]	; save the address
FFFC4B8C 04C000EF		call	OREXPR		; get the byte to be POKE'd
FFFC4B90 00072983		lw		a1,[$sp]	; get the address back
FFFC4B94 00470713		add		$sp,$sp,#4
FFFC4B98 01299023		sh		a0,[a1]		; store the byte in memory
FFFC4B9C 85DFF06F		jmp		FINISH
                        	
                        	PKER:
FFFC4BA0 FFFC6937		ldi		a0,#msgComma
FFFC4BA4 E8290913
FFFC4BA8 0D10006F		jmp		ERROR		; if no comma, say "What?"
                        	
                        	;******************************************************************
                        	; 'SYSX expr' jumps to the machine language subroutine whose
                        	; starting address is specified by 'expr'.  The subroutine can use
                        	; all registers but must leave the stack the way it found it.
                        	; The subroutine returns to the interpreter by executing an RTS.
                        	;******************************************************************
                        	
                        	SYSX:
FFFC4BAC 02C000EF		call	OREXPR		; get the subroutine's address
FFFC4BB0 00081863		bne		v0,r0,sysx1; make sure we got a valid address
FFFC4BB4 FFFC6937		ldi		a0,#msgSYSBad
FFFC4BB8 ED390913
FFFC4BBC 0BD0006F		jmp		ERROR
                        	sysx1:
FFFC4BC0 FFC70713		sub		$sp,$sp,#4
FFFC4BC4 01C72023		stt		$t2,[$sp]	; save the text pointer
FFFC4BC8 000800E7		call	[v0]			; jump to the subroutine
FFFC4BCC 00072E03		ldt		$t2,[$sp]	; restore the text pointer
FFFC4BD0 00470713		add		$sp,$sp,#4
FFFC4BD4 825FF06F		jmp		FINISH
                        	
                        	;******************************************************************
                        	; *** EXPR ***
                        	;
                        	; 'EXPR' evaluates arithmetical or logical expressions.
                        	; <OREXPR>::= <ANDEXPR> OR <ANDEXPR> ...
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	; <EXPR>::=<ADDEXPR>
                        	;	   <ADDEXPR><rel.op.><ADDEXPR>
                        	; where <rel.op.> is one of the operators in TAB8 and the result
                        	; of these operations is 1 if true and 0 if false.
                        	; <ADDEXPR>::=(+ or -)<MULEXPR>(+ or -)<MULEXPR>(...
                        	; where () are optional and (... are optional repeats.
                        	; <MULEXPR>::=<FUNCEXPR>( <* or /><FUNCEXPR> )(...
                        	; <FUNCEXPR>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                        	; as an index, functions can have an <EXPR> as arguments, and
                        	; <FUNCEXPR> can be an <EXPR> in parenthesis.
                        	;
                        	
                        	; <OREXPR>::=<ANDEXPR> OR <ANDEXPR> ...
                        	;
                        	OREXPR:
FFFC4BD8 FF470713		sub		$sp,$sp,#12
FFFC4BDC 00172023		sw		$ra,[$sp]
FFFC4BE0 00372223		sw		r3,4[$sp]
FFFC4BE4 00472423		sw		r4,8[$sp]
FFFC4BE8 058000EF		call	ANDEXPR		; get first <ANDEXPR>
                        	XP_OR1:
FFFC4BEC FF870713		sub		$sp,$sp,#8
FFFC4BF0 01072023		sw		$v0,[$sp]		; save <ANDEXPR> value
FFFC4BF4 01172223		sw		$v1,4[$sp]	; save type
FFFC4BF8 FFFC4EB7		ldi		$t3,#TAB10	; look up a logical operator
FFFC4BFC FE2E8E93
FFFC4C00 FFFC4F37		ldi		$t4,#TAB10_1
FFFC4C04 052F0F13
FFFC4C08 C68FF06F		jmp		EXEC		; go do it
                        	XP_OR:
FFFC4C0C 034000EF	  call	ANDEXPR
FFFC4C10 00072903	  lw		$a0,[$sp]
FFFC4C14 00870713	  add		$sp,$sp,#8
FFFC4C18 01286833	  or    v0,v0,a0
FFFC4C1C FC0008E3	  bra   XP_OR1
                        	XP_ORX:
FFFC4C20 00072803	  lw		$v0,[$sp]
FFFC4C24 00472883	  lw		$v1,4[$sp]
FFFC4C28 00870713	  add		$sp,$sp,#8
FFFC4C2C 00072083		lw		$ra,[$sp]
FFFC4C30 00472183		lw		r3,4[$sp]
FFFC4C34 00872203		lw		r4,8[$sp]
FFFC4C38 00C70713		add		$sp,$sp,#12
FFFC4C3C 00008067	  ret
                        	
                        	
                        	; <ANDEXPR>::=<EXPR> AND <EXPR> ...
                        	;
                        	ANDEXPR:
FFFC4C40 FFC70713		sub		$sp,$sp,#4
FFFC4C44 00172023		sw		$ra,[$sp]
FFFC4C48 0E8000EF		call	EXPR		; get first <EXPR>
                        	XP_AND1:
FFFC4C4C FF870713		sub		$sp,$sp,#8
FFFC4C50 01072023		sw		$v0,[$sp]		; save <EXPR> value
FFFC4C54 01172223		sw		$v1,4[$sp]	; save type
FFFC4C58 FFFC4EB7		ldi		$t3,#TAB9		; look up a logical operator
FFFC4C5C FDEE8E93
FFFC4C60 FFFC4F37		ldi		$t4,#TAB9_1
FFFC4C64 04EF0F13
FFFC4C68 C08FF06F		jmp		EXEC		; go do it
                        	XP_AND:
FFFC4C6C 0C4000EF	  call	EXPR
FFFC4C70 00072903	  lw		$a0,[$sp]
FFFC4C74 00870713	  add		$sp,$sp,#8
FFFC4C78 01287833	  and   v0,v0,a0
FFFC4C7C FC0008E3	  bra   XP_AND1
                        	XP_ANDX:
FFFC4C80 00072803	  lw		$v0,[$sp]
FFFC4C84 00472883	  lw		$v1,4[$sp]
FFFC4C88 00870713	  add		$sp,$sp,#8
FFFC4C8C 00072083		lw		$ra,[$sp]
FFFC4C90 00470713		add		$sp,$sp,#4
FFFC4C94 00008067	  ret
                        	
                        	
                        	; Determine if the character is a digit
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if digit, otherwise 0
                        	;
                        	isDigit:
FFFC4C98 03006D93		ldi		$t1,#'0'
FFFC4C9C 01B94A63		blt		a0,$t1,isDigitFalse
FFFC4CA0 03906D93		ldi		$t1,#'9'
FFFC4CA4 012DC663		bgt		a0,$t1,isDigitFalse
FFFC4CA8 00106813		ldi		v0,#1
FFFC4CAC 00008067	  ret
                        	isDigitFalse:
FFFC4CB0 00006833	  mov		v0,r0
FFFC4CB4 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphabetic
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlpha:
FFFC4CB8 04106D93		ldi		$t1,#'A'
FFFC4CBC 03B94263		blt		a0,$t1,isAlphaFalse
FFFC4CC0 05A06D93		ldi		$t1,#'Z'
FFFC4CC4 012DDA63		ble		a0,$t1,isAlphaTrue
FFFC4CC8 06106D93		ldi		$t1,#'a'
FFFC4CCC 01B94A63		blt		a0,$t1,isAlphaFalse
FFFC4CD0 07A06D93		ldi		$t1,#'z'
FFFC4CD4 012DC663		bgt		a0,$t1,isAlphaFalse
                        	isAlphaTrue:
FFFC4CD8 00106813	  ldi		v0,#1
FFFC4CDC 00008067	  ret
                        	isAlphaFalse:
FFFC4CE0 00006833	  mov		v0,r0
FFFC4CE4 00008067	  ret
                        	
                        	
                        	; Determine if the character is a alphanumeric
                        	;   Parameters
                        	;       a0 = char to test
                        	;   Returns
                        	;       a0 = 1 if alpha, otherwise 0
                        	;
                        	isAlnum:
FFFC4CE8 FFC70713		sub		$sp,$sp,#4
FFFC4CEC 00172023		sw		$ra,[$sp]
FFFC4CF0 FA9FF0EF	  call	isDigit
FFFC4CF4 00081463		bne		v0,r0,isDigitx	; if it is a digit
FFFC4CF8 FC1FF0EF	  call  isAlpha
                        	isDigitx:
FFFC4CFC 00072083		lw		$ra,[$sp]
FFFC4D00 00470713		add		$sp,$sp,#4
FFFC4D04 00008067	  ret
                        	
                        	FORCEFIT:
FFFC4D08 03198263		beq		a1,v1,.0001				; types match
FFFC4D0C 00006D13		ldi		$t0,#0
FFFC4D10 01A98663		beq		a1,$t0,.intAnd
                        	;	itof	$f1,$v0
FFFC4D14 00106913		ldi		a0,#1
FFFC4D18 00008067		ret
                        	.intAnd:
FFFC4D1C 00106D13		ldi		$t0,#1
FFFC4D20 01A89663		bne		$v1,$t0,.0001
                        	;	itof	$f2,$a1
FFFC4D24 00106993		ldi		$a1,#1
FFFC4D28 00008067		ret
                        	.0001:
FFFC4D2C 00008067		ret
                        	
                        	EXPR:
FFFC4D30 FFC70713		sub		$sp,$sp,#4
FFFC4D34 00172023		sw		$ra,[$sp]
FFFC4D38 11C000EF		call	ADDEXPR
FFFC4D3C FF870713		sub		$sp,$sp,#8				; save <ADDEXPR> value
FFFC4D40 01072023		sw		v0,[$sp]
FFFC4D44 01172223		sw		v1,4[$sp]					; save type
FFFC4D48 FFFC4EB7		ldi		$t3,#TAB8		; look up a relational operator
FFFC4D4C FD4E8E93
FFFC4D50 FFFC4F37		ldi		$t4,#TAB8_1
FFFC4D54 040F0F13
FFFC4D58 B18FF06F		jmp		EXEC		; go do it
                        	XP11:
FFFC4D5C 00072903		lw		a0,[$sp]
FFFC4D60 00472983		lw		a1,4[$sp]
FFFC4D64 00870713		add		$sp,$sp,#8
FFFC4D68 0C4000EF		call	XP18	; is it ">="?
FFFC4D6C 09095A63		bge		a0,v0,XPRT1	; no, return v0=1
FFFC4D70 06000E63		bra		XPRT0	; else return v0=0
                        	XP12:
FFFC4D74 00072903		lw		a0,[$sp]
FFFC4D78 00472983		lw		a1,4[$sp]
FFFC4D7C 00870713		add		$sp,$sp,#8
FFFC4D80 0AC000EF		call	XP18	; is it "<>"?
FFFC4D84 07091E63		bne		a0,v0,XPRT1	; no, return a1=1
FFFC4D88 06000263		bra		XPRT0	; else return a1=0
                        	XP13:
FFFC4D8C 00072903		lw		a0,[$sp]
FFFC4D90 00472983		lw		a1,4[$sp]
FFFC4D94 00870713		add		$sp,$sp,#8
FFFC4D98 094000EF		call	XP18	; is it ">"?
FFFC4D9C 07284263		bgt		a0,v0,XPRT1	; no, return a1=1
FFFC4DA0 04000663		bra		XPRT0	; else return a1=0
                        	XP14:
FFFC4DA4 00072903		lw		a0,[$sp]
FFFC4DA8 00472983		lw		a1,4[$sp]
FFFC4DAC 00870713		add		$sp,$sp,#8
FFFC4DB0 07C000EF		call	XP18	; is it "<="?
FFFC4DB4 05285663		ble		a0,v0,XPRT1	; no, return a1=1
FFFC4DB8 02000A63		bra		XPRT0	; else return a1=0
                        	XP15:
FFFC4DBC 00072903		lw		a0,[$sp]
FFFC4DC0 00472983		lw		a1,4[$sp]
FFFC4DC4 00870713		add		$sp,$sp,#8
FFFC4DC8 064000EF		call	XP18	; is it "="?
FFFC4DCC 03090A63		beq		a0,v0,XPRT1	; if not, return a1=1
FFFC4DD0 00000E63		bra		XPRT0	; else return a1=0
                        	XP16:
FFFC4DD4 00072903		lw		a0,[$sp]
FFFC4DD8 00472983		lw		a1,4[$sp]
FFFC4DDC 00870713		add		$sp,$sp,#8
FFFC4DE0 04C000EF		call	XP18	; is it "<"?
FFFC4DE4 01094E63		blt		a0,v0,XPRT1	; if not, return a1=1
FFFC4DE8 00000263		bra		XPRT0	; else return a1=0
                        	XPRT0:
FFFC4DEC 00006833		mov		v0,x0   ; return a0=0 (false)
FFFC4DF0 000068B3		mov		v1,x0		; type = int
FFFC4DF4 00072083		lw		$ra,[$sp]
FFFC4DF8 00470713		add		$sp,$sp,#4
FFFC4DFC 00008067		ret
                        	XPRT1:
FFFC4E00 00106813		ldi		v0,#1	; return a0=1 (true)
FFFC4E04 00006893		ldi		v1,#0	; type = int
FFFC4E08 00072083		lw		$ra,[$sp]
FFFC4E0C 00470713		add		$sp,$sp,#4
FFFC4E10 00008067		ret
                        	
                        	XP17:				; it's not a rel. operator
FFFC4E14 00072803		lw		v0,[$sp]; return a1=<ADDEXPR>
FFFC4E18 00472883		lw		v1,4[$sp]
FFFC4E1C 00870713		add		$sp,$sp,#8
FFFC4E20 00072083		lw		$ra,[$sp]
FFFC4E24 00470713		add		$sp,$sp,#4
FFFC4E28 00008067		ret
                        	
                        	XP18:
FFFC4E2C FF470713		sub		$sp,$sp,#12
FFFC4E30 00172023		sw		$ra,[$sp]
FFFC4E34 01072223		sw		v0,4[$sp]
FFFC4E38 01172423		sw		v1,8[$sp]
FFFC4E3C 018000EF		call	ADDEXPR		; do a second <ADDEXPR>
FFFC4E40 00472903		lw		a0,4[$sp]
FFFC4E44 00872983		lw		a1,8[$sp]
FFFC4E48 00072083		lw		$ra,[$sp]
FFFC4E4C 00C70713		add		$sp,$sp,#12
FFFC4E50 00008067		ret
                        	
                        	; <ADDEXPR>::=(+ or -)<MULEXPR>(+ or -)<MULEXPR>(...
                        	//message "ADDEXPR"
                        	ADDEXPR:
FFFC4E54 FFC70713		sub		$sp,$sp,#4
FFFC4E58 00172023		sw		$ra,[$sp]
FFFC4E5C 389000EF		call	TSTC		; negative sign?
FFFC4E60 0000002D		dw		'-'
FFFC4E64 00000C63		bra		XP21
FFFC4E68 00006833		mov		v0,r0		; yes, fake '0-'
FFFC4E6C FF870713		sub		$sp,$sp,#8
FFFC4E70 01072023		sw		v0,[$sp]
FFFC4E74 01172223		sw		v1,4[$sp]
FFFC4E78 04000863		bra		XP26
                        	XP21:
FFFC4E7C 369000EF		call	TSTC		; positive sign? ignore it
FFFC4E80 0000002B		dw		'+'
FFFC4E84 00000263		bra		XP22
                        	XP22:
FFFC4E88 064000EF		call	MULEXPR		; first <MULEXPR>
                        	XP23:
FFFC4E8C FF870713		sub		$sp,$sp,#8; yes, save the value
FFFC4E90 01072023		sw		v0,[$sp]
FFFC4E94 01172223		sw		v1,4[$sp]	; and type
FFFC4E98 34D000EF		call	TSTC		; add?
FFFC4E9C 0000002B		dw		'+'
FFFC4EA0 00000E63		bra		XP25
FFFC4EA4 048000EF		call	MULEXPR		; get the second <MULEXPR>
                        	XP24:
FFFC4EA8 00072903		lw		a0,[$sp]
FFFC4EAC 00472983		lw		a1,4[$sp]
FFFC4EB0 00870713		add		$sp,$sp,#8
FFFC4EB4 01280833		add		v0,v0,a0	; add it to the first <MULEXPR>
                        	;	BVS.L	QHOW		brnch if there's an overflow
FFFC4EB8 FC000AE3		bra		XP23		; else go back for more operations
                        	XP25:
FFFC4EBC 329000EF		call	TSTC		; subtract?
FFFC4EC0 0000002D		dw		'-'
FFFC4EC4 00000863		bra		XP45
                        	XP26:
FFFC4EC8 024000EF		call	MULEXPR		; get second <MULEXPR>
FFFC4ECC 41000833		sub		v0,r0,v0	; change its sign
FFFC4ED0 FC000CE3		bra		XP24		; and do an addition
                        	XP45:
FFFC4ED4 00072803		lw		v0,[$sp]
FFFC4ED8 00472883		lw		v1,4[$sp]
FFFC4EDC 00870713		add		$sp,$sp,#8
FFFC4EE0 00072083		lw		$ra,[$sp]
FFFC4EE4 00470713		add		$sp,$sp,#4
FFFC4EE8 00008067		ret
                        	
                        	
                        	; <MULEXPR>::=<FUNCEXPR>( <* or /><FUNCEXPR> )(...
                        	
                        	MULEXPR:
FFFC4EEC FFC70713		sub		$sp,$sp,#4
FFFC4EF0 00172023		sw		$ra,[$sp]
FFFC4EF4 094000EF		call	FUNCEXPR		; get first <FUNCEXPR>
                        	XP31:
FFFC4EF8 FF870713		sub		$sp,$sp,#8
FFFC4EFC 01072023		sw		v0,[$sp]; yes, save that first result
FFFC4F00 01172223		sw		v1,4[$sp]
FFFC4F04 2E1000EF		call	TSTC		; multiply?
FFFC4F08 0000002A		dw		'*'
FFFC4F0C 00000E63		bra		XP34
FFFC4F10 078000EF		call	FUNCEXPR		; get second <FUNCEXPR>
FFFC4F14 00072903		lw		a0,[$sp]
FFFC4F18 00472983		lw		a1,4[$sp]
FFFC4F1C 00870713		add		$sp,$sp,#8
FFFC4F20 03280833		mul		v0,v0,a0	; multiply the two
FFFC4F24 FC000AE3		bra		XP31        ; then look for more terms
                        	XP34:
FFFC4F28 2BD000EF		call	TSTC		; divide?
FFFC4F2C 0000002F		dw		'/'
FFFC4F30 00000E63		bra		XP35
FFFC4F34 054000EF		call	FUNCEXPR		; get second <FUNCEXPR>
FFFC4F38 00072903		lw		a0,[$sp]
FFFC4F3C 00472983		lw		a1,4[$sp]
FFFC4F40 00870713		add		$sp,$sp,#8
FFFC4F44 03284833		div		v0,v0,a0	; do the division
FFFC4F48 FA0008E3		bra		XP31		; go back for any more terms
                        	XP35:
FFFC4F4C 299000EF		call	TSTC
FFFC4F50 00000025		dw		'%'
FFFC4F54 00000E63		bra		XP47
FFFC4F58 030000EF		call	FUNCEXPR
FFFC4F5C 00072903		lw		a0,[$sp]
FFFC4F60 00472983		lw		a1,4[$sp]
FFFC4F64 00870713		add		$sp,$sp,#8
FFFC4F68 03286833		rem		v0,v0,a0
FFFC4F6C F80006E3		bra		XP31
                        	XP47:
FFFC4F70 00072803		lw		v0,[$sp]
FFFC4F74 00472883		lw		v1,4[$sp]
FFFC4F78 00870713		add		$sp,$sp,#8
FFFC4F7C 00072083		lw		$ra,[$sp]
FFFC4F80 00470713		add		$sp,$sp,#4
FFFC4F84 00008067		ret
                        	
                        	
                        	; Functions are called through FUNCEXPR
                        	; <FUNCEXPR>::=<variable>
                        	;	    <function>
                        	;	    (<EXPR>)
                        	
                        	FUNCEXPR:
FFFC4F88 FFC70713		sub		$sp,$sp,#4
FFFC4F8C 00172023		sw		$ra,[$sp]
FFFC4F90 FFFC4EB7	  ldi		$t3,#TAB4		; find possible function
FFFC4F94 F93E8E93
FFFC4F98 FFFC4F37	  ldi		$t4,#TAB4_1
FFFC4F9C 01EF0F13
FFFC4FA0 8D0FF06F		jmp		EXEC        ; branch to function which does subsequent ret for FUNCEXPR
                        	XP40:                   ; we get here if it wasn't a function
FFFC4FA4 00006933		mov		a0,x0
FFFC4FA8 070000EF		call	TSTV
FFFC4FAC 00080A63		beq   v0,x0,XP41	; not a variable
FFFC4FB0 00082803		lw		$v0,[$v0]		; if a variable, return its value in v0
FFFC4FB4 00072083		lw		$ra,[$sp]
FFFC4FB8 00470713		add		$sp,$sp,#4
FFFC4FBC 00008067		ret
                        	XP41:
FFFC4FC0 271000EF		call	TSTNUM		; or is it a number?
FFFC4FC4 00089463		bne		v1,x0,XP46	; (if not, # of digits will be zero) if so, return it in v0
FFFC4FC8 010000EF		call	PARN        ; check for (EXPR)
                        	XP46:
FFFC4FCC 00072083		lw		$ra,[$sp]
FFFC4FD0 00470713		add		$sp,$sp,#4
FFFC4FD4 00008067		ret
                        	
                        	
                        	; Check for a parenthesized expression
                        	PARN:
FFFC4FD8 FFC70713		sub		$sp,$sp,#4
FFFC4FDC 00172023		sw		$ra,[$sp]	
FFFC4FE0 205000EF		call	TSTC		; else look for ( OREXPR )
FFFC4FE4 00000028		dw		'('
FFFC4FE8 02000063		bra		XP43
FFFC4FEC BEDFF0EF		call	OREXPR
FFFC4FF0 1F5000EF		call	TSTC
FFFC4FF4 00000029		dw		')'
FFFC4FF8 00000863		bra		XP43
                        	XP42:
FFFC4FFC 00072083		lw		$ra,[$sp]
FFFC5000 00470713		add		$sp,$sp,#4
FFFC5004 00008067		ret
                        	XP43:
FFFC5008 00470713		add		$sp,$sp,#4		; get rid of return address
FFFC500C FFFC6937		ldi		a0,#msgWhat
FFFC5010 E0890913
FFFC5014 4640006F		jmp		ERROR
                        	
                        	
                        	; ===== Test for a valid variable name.  Returns Z=1 if not
                        	;	found, else returns Z=0 and the address of the
                        	;	variable in a0.
                        	; Parameters
                        	;		a0 = 1 = allocate if not found
                        	; Returns
                        	;		v0 = address of variable, zero if not found
                        	
                        	TSTV:
FFFC5018 FF870713		sub		$sp,$sp,#8
FFFC501C 00572023		sw		r5,[$sp]
FFFC5020 00172223		sw		$ra,4[$sp]
FFFC5024 000962B3		mov		r5,a0		; r5=allocate flag
FFFC5028 27D000EF		call	IGNBLK
FFFC502C 000E4903		lbu		a0,[$t2]		; look at the program text
FFFC5030 04006D93		ldi		$t1,#'@'
FFFC5034 07B94863		blt		a0,$t1,tstv_notfound	; C=1: not a variable
FFFC5038 05B91463		bne		a0,$t1,TV1				; brnch if not "@" array
FFFC503C 001E0E13		add		$t2,$t2,#1	; If it is, it should be
FFFC5040 F99FF0EF		call	PARN		; followed by (EXPR) as its index.
                        	;	BCS.L	QHOW		say "How?" if index is too big
FFFC5044 00000263		bra		TV3
                        	TV3:
FFFC5048 FFC70713		sub		$sp,$sp,#4	; save the index
FFFC504C 01072023		sw		v0,[$sp]
FFFC5050 300000EF		call	SIZEX		; get amount of free memory
FFFC5054 00072983		lw		a1,[$sp]
FFFC5058 00470713		add		$sp,$sp,#4	; get back the index
FFFC505C 0109C663		blt		a1,v0,TV2		; see if there's enough memory
FFFC5060 00870713		add		$sp,$sp,#8
FFFC5064 4000006F		jmp   QSORRY		; if not, say "Sorry"
                        	TV2:
FFFC5068 00030637		lw		a0,VARBGN	; put address of array element...
FFFC506C 00860613
FFFC5070 00060633
FFFC5074 00062903
FFFC5078 41390833		sub   v0,a0,a1    ; into a0 (neg. offset is used)
FFFC507C 00000C63		bra   TSTVRT
                        	TV1:	
FFFC5080 038000EF	  call	getVarName      ; get variable name
FFFC5084 00080863	  beq   v0,x0,TSTVRT    ; if not, return v0=0
FFFC5088 00086933	  mov		a0,v0
FFFC508C 0002E9B3	  mov		a1,r5
FFFC5090 0D4000EF	  call	findVar     ; find or allocate
                        	TSTVRT:
FFFC5094 00072283		lw		r5,[$sp]
FFFC5098 00472083		lw		$ra,4[$sp]
FFFC509C 00870713		add		$sp,$sp,#8
FFFC50A0 00008067		ret								; v0<>0 (if found)
                        	tstv_notfound:
FFFC50A4 00072283		lw		r5,[$sp]
FFFC50A8 00472083		lw		$ra,4[$sp]
FFFC50AC 00870713		add		$sp,$sp,#8
FFFC50B0 00006833		mov		v0,x0				; v0=0 if not found
FFFC50B4 00008067	  ret
                        	
                        	; Get a variable name. Called after blanks have been ignored.
                        	;
                        	; Returns
                        	;   v0 = 3 character variable name + type
                        	;
                        	getVarName:
FFFC50B8 FF470713		sub		$sp,$sp,#12
FFFC50BC 00572023		sw		r5,[$sp]
FFFC50C0 00172223		sw		$ra,4[$sp]
FFFC50C4 000E4903	  lbu   a0,[$t2]		; get first character
FFFC50C8 01272423	  sw		a0,8[$sp]		; save off current name
FFFC50CC BEDFF0EF	  call	isAlpha
FFFC50D0 08080063	  beq   v0,r0,gvn1
FFFC50D4 00206293	  ldi	  r5,#2       ; loop two more times
                        	
                        		; check for second/third character
                        	gvn4:
FFFC50D8 001E0E13		add		$t2,$t2,#1
FFFC50DC 000E4903		lbu   a0,[$t2]		; do we have another char ?
FFFC50E0 C09FF0EF		call	isAlnum
FFFC50E4 02080863		beq   v0,x0,gvn2	; nope
FFFC50E8 00872903		lw		a0,8[$sp]		; get varname
FFFC50EC 00891913		sll		a0,a0,#8
FFFC50F0 000E4983		lbu   a1,[$t2]
FFFC50F4 01396933		or    a0,a0,a1   	; add in new char
FFFC50F8 01272423	  sw		a0,8[$sp]		; save off current name again
FFFC50FC FFF28293	  sub		r5,r5,#1
FFFC5100 FC504CE3	  bgt		r5,x0,gvn4
                        	
                        	 	; now ignore extra variable name characters
                        	gvn6:
FFFC5104 001E0E13		add		$t2,$t2,#1
FFFC5108 000E4903		lbu   a0,[$t2]		; do we have another char ?
FFFC510C BDDFF0EF	  call  isAlnum
FFFC5110 FE081AE3	  bne   v0,x0,gvn6	; keep looping as long as we have identifier chars
                        	
                        	  ; check for a variable type
                        	gvn2:
FFFC5114 000E4983		lbu   a1,[$t2]
FFFC5118 02506D93		ldi		$t1,#'%'
FFFC511C 01B98A63		beq		a1,$t1,gvn3
FFFC5120 02406D93		ldi		$t1,#'$'
FFFC5124 01B98663		beq		a1,$t1,gvn3
FFFC5128 FFFE0E13	  sub		$t2,$t2,#1
FFFC512C 02E06993	  ldi		$a1,#'.'		; if no variable type assume float
                        	
                        	  ; insert variable type indicator and return
                        	gvn3:
FFFC5130 001E0E13		add		$t2,$t2,#1
FFFC5134 00872903		lw		a0,8[$sp]		; get varname
FFFC5138 00891913		sll		a0,a0,#8
FFFC513C 01396833	  or    v0,a0,a1    ; add in variable type
FFFC5140 00072283	  lw		r5,[$sp]
FFFC5144 00472083	  lw		$ra,4[$sp]
FFFC5148 00C70713	  add		$sp,$sp,#12
FFFC514C 00008067	  ret								; return a0 = varname
                        	
                        	  ; not a variable name
                        	gvn1:
FFFC5150 00072283		lw		r5,[$sp]
FFFC5154 00472083	  lw		$ra,4[$sp]
FFFC5158 00C70713		add		$sp,$sp,#12
FFFC515C 00006833	  mov		v0,x0       ; return v0 = 0 if not a varname
FFFC5160 00008067	  ret
                        	
                        	
                        	; Find variable
                        	;   a0 = varname
                        	;		a1 = allocate flag
                        	; Returns
                        	;   v0 = variable address, Z =0 if found / allocated, Z=1 if not found
                        	
                        	findVar:
FFFC5164 FF870713		sub		$sp,$sp,#8
FFFC5168 00772023		sw		x7,[$sp]
FFFC516C 00372223		sw		x3,4[$sp]
FFFC5170 00030637	  lw    x3,VARBGN
FFFC5174 00860613
FFFC5178 00060633
FFFC517C 00062183
                        	fv4:
FFFC5180 0001A383	  lw    x7,[x3]     ; get varname / type
FFFC5184 02038C63	  beq   x7,x0,fv3		; no more vars ?
FFFC5188 02790E63	  beq   a0,x7,fv1		; match ?
FFFC518C 00818193		add		x3,x3,#8		; move to next var
FFFC5190 00030637	  lw    x7,VAREND		; 
FFFC5194 00C60613
FFFC5198 00060633
FFFC519C 00062383
FFFC51A0 FE71C0E3	  blt   x3,x7,fv4		; loop back to look at next var
                        	
                        	  ; variable not found
                        	  ; no more memory
FFFC51A4 00072383	  lw		x7,[$sp]
FFFC51A8 00472183	  lw		x3,4[$sp]
FFFC51AC 00870713	  add		$sp,$sp,#8
FFFC51B0 FFFC6937	  ldi		a0,#msgVarSpace
FFFC51B4 E5690913
FFFC51B8 2C00006F	  jmp   ERROR
                        	
                        	  ; variable not found
                        	  ; allocate new ?
                        	fv3:
FFFC51BC 00098E63		beq		a1,x0,fv2
FFFC51C0 0121A023	  sw    a0,[x3]     ; save varname / type
                        	  ; found variable
                        	  ; return address
                        	fv1:
FFFC51C4 00418813	  add		v0,x3,#4
FFFC51C8 00072383	  lw		x7,[$sp]
FFFC51CC 00472183	  lw		x3,4[$sp]
FFFC51D0 00870713	  add		$sp,$sp,#8
FFFC51D4 00008067	  ret			    			; v0 = address
                        	
                        	  ; didn't find var and not allocating
                        	fv2:
FFFC51D8 00072383	  lw		x7,[$sp]
FFFC51DC 00472183	  lw		x3,4[$sp]
FFFC51E0 00870713	  add		$sp,$sp,#8
FFFC51E4 00006833		mov		v0,x0				; v0 = nullptr
FFFC51E8 00008067	  ret
                        	
                        	; The following functions are entered via a jump instruction with
                        	; the return address already saved.
                        	
                        	; ===== The PEEK function returns the byte stored at the address
                        	;	contained in the following expression.
                        	;
                        	PEEK:
FFFC51EC DEDFF0EF		call	PARN		; get the memory address
FFFC51F0 00080803		lb		v0,[v0]		; get the addressed byte
FFFC51F4 000068B3		mov		v1,x0			; type = int
FFFC51F8 00072083		lw		$ra,[$sp]
FFFC51FC 00470713		add		$sp,$sp,#4
FFFC5200 00008067		ret
                        	PEEKW:
FFFC5204 DD5FF0EF		call	PARN		; get the memory address
FFFC5208 00082803		lw		v0,[v0]		; get the addressed word
FFFC520C 000068B3		mov		v1,x0			; type = int
FFFC5210 00072083		lw		$ra,[$sp]
FFFC5214 00470713		add		$sp,$sp,#4
FFFC5218 00008067		ret
                        	PEEKH:
FFFC521C DBDFF0EF		call	PARN		; get the memory address
FFFC5220 00081803		lh		v0,[v0]		; get the addressed byte
FFFC5224 000068B3		mov		v1,x0			; type = int
FFFC5228 00072083		lw		$ra,[$sp]
FFFC522C 00470713		add		$sp,$sp,#4
FFFC5230 00008067		ret
                        	
                        	
                        	; user function call
                        	; call the user function with argument in a0, type in a1
                        	USRX:
FFFC5234 FFC70713		sub		$sp,$sp,#4
FFFC5238 01A72023		sw		$t0,[$sp]
FFFC523C D9DFF0EF		call	PARN		; get expression value
FFFC5240 00086933		mov		a0,v0
FFFC5244 0008E9B3		mov		a1,v1
FFFC5248 FFC70713		sub		$sp,$sp,#4	; save the text pointer
FFFC524C 01C72023		sw		$t2,[$sp]
FFFC5250 00030637		lw		$t0,usrJmp
FFFC5254 0A060613
FFFC5258 00060633
FFFC525C 00062D03
FFFC5260 000D00E7		call	[$t0]			; get usr vector, jump to the subroutine
FFFC5264 00072E03		lw		$t2,[$sp]	; restore the text pointer
FFFC5268 00470713		add		$sp,$sp,#4
FFFC526C 00072D03		lw		$t0,[$sp]
FFFC5270 00470713		add		$sp,$sp,#4
FFFC5274 00072083		lw		$ra,[$sp]
FFFC5278 00470713		add		$sp,$sp,#4
FFFC527C 00008067		ret
                        	
                        	
                        	; ===== The RND function returns a random number from 1 to
                        	;	the value of the following expression in D0.
                        	;
                        	RND:
FFFC5280 D59FF0EF		call	PARN		; get the upper limit
FFFC5284 04080063		beq		v0,r0,rnd2	; it must be positive and non-zero
FFFC5288 02084663		blt		v0,r0,rnd1
FFFC528C 000869B3		mov		a1,v0
FFFC5290 000868B3		mov		v1,v0
FFFC5294 00000637		call	gen_rand	; generate a random number
FFFC5298 3C6600E7
FFFC529C 03186833		rem		v0,v0,v1
FFFC52A0 00180813		add		v0,v0,#1
FFFC52A4 000068B3		mov		v1,x0
FFFC52A8 00072083		lw		$ra,[$sp]
FFFC52AC 00470713		add		$sp,$sp,#4
FFFC52B0 00008067		ret
                        	rnd1:
FFFC52B4 FFFC6937		ldi		a0,#msgRNDBad
FFFC52B8 EC090913
FFFC52BC 00470713		add		$sp,$sp,#4
FFFC52C0 1B80006F		jmp		ERROR
                        	rnd2:
FFFC52C4 00000637		call	gen_rand	; generate a random number
FFFC52C8 3C6600E7
FFFC52CC 000068B3		mov		v1,x0
FFFC52D0 00072083		lw		$ra,[$sp]
FFFC52D4 00470713		add		$sp,$sp,#4
FFFC52D8 00008067		ret
                        	
                        	; ===== The ABS function returns an absolute value in a1.
                        	;
                        	ABS:
FFFC52DC CFDFF0EF		call	PARN		; get the following expr.'s value
FFFC52E0 00084863		blt		v0,r0,ABS1
FFFC52E4 00072083		lw		$ra,[$sp]
FFFC52E8 00470713		add		$sp,$sp,#4
FFFC52EC 00008067		ret
                        	ABS1:
FFFC52F0 41000833		sub		v0,x0,v0
FFFC52F4 00072083		lw		$ra,[$sp]
FFFC52F8 00470713		add		$sp,$sp,#4
FFFC52FC 00008067		ret
                        	
                        	
                        	;==== The TICK function returns the cpu tick value in a0.
                        	;
                        	TICKX:
FFFC5300 C0001873		csrrw	v0,#$C00,x0
FFFC5304 000068B3		mov		v1,x0
FFFC5308 00072083		lw		$ra,[$sp]
FFFC530C 00470713		add		$sp,$sp,#4
FFFC5310 00008067		ret
                        	
                        	; ===== The SGN function returns the sign in a0. +1,0, or -1
                        	;
                        	SGN:
FFFC5314 CC5FF0EF		call	PARN		; get the following expr.'s value
FFFC5318 000068B3		mov		v1,x0
FFFC531C 02080463		beq		v0,r0,SGN1
FFFC5320 00084A63		blt		v0,r0,SGN2
FFFC5324 00106813		ldi		v0,#1
FFFC5328 00072083		lw		$ra,[$sp]
FFFC532C 00470713		add		$sp,$sp,#4
FFFC5330 00008067		ret
                        	SGN2:
FFFC5334 FFF06813		ldi		v0,#-1
FFFC5338 00072083		lw		$ra,[$sp]
FFFC533C 00470713		add		$sp,$sp,#4
FFFC5340 00008067		ret
                        	SGN1:
FFFC5344 00072083		lw		$ra,[$sp]
FFFC5348 00470713		add		$sp,$sp,#4
FFFC534C 00008067		ret	
                        	
                        	; ===== The SIZE function returns the size of free memory in v0.
                        	; does not consider memory used by @()
                        	;
                        	SIZEX:
FFFC5350 00030637		lw		v0,VARBGN	; get the number of free bytes...
FFFC5354 00860613
FFFC5358 00060633
FFFC535C 00062803
FFFC5360 00030637		lw		v1,TXTUNF	; between 'TXTUNF' and 'VARBGN'
FFFC5364 00460613
FFFC5368 00060633
FFFC536C 00062883
FFFC5370 41180833		sub		v0,v0,v1
FFFC5374 000068B3		mov		v1,x0			; type = int
FFFC5378 00072083		lw		$ra,[$sp]
FFFC537C 00470713		add		$sp,$sp,#4
FFFC5380 00008067		ret					; return the number in v0
                        	
                        	
                        	;******************************************************************
                        	;
                        	; *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                        	;
                        	; 'SETVAL' expects a variable, followed by an equal sign and then
                        	; an expression.  It evaluates the expression and sets the variable
                        	; to that value.
                        	;
                        	; returns
                        	; a1 = variable's address
                        	;
                        	SETVAL:
FFFC5384 FFC70713		sub		$sp,$sp,#4
FFFC5388 00172023		sw		$ra,[$sp]
FFFC538C 00106913	  ldi		a0,#1		; allocate var
FFFC5390 C89FF0EF	  call	TSTV		; variable name?
FFFC5394 00081A63	  bne		v0,x0,.sv2
FFFC5398 FFFC6937	 	ldi		a0,#msgVar
FFFC539C EAA90913
FFFC53A0 00470713		add		$sp,$sp,#4
FFFC53A4 0D40006F	 	jmp		ERROR 
                        	.sv2:
FFFC53A8 FFC70713		sub		$sp,$sp,#4
FFFC53AC 01072023		sw		v0,[$sp]	; save the variable's address
FFFC53B0 634000EF		call	TSTC			; get past the "=" sign
FFFC53B4 0000003D		dw		'='
FFFC53B8 02000663		bra		SV1
FFFC53BC 81DFF0EF		call	OREXPR		; evaluate the expression
FFFC53C0 00072983		lw		a1,[$sp]	; get back the variable's address
FFFC53C4 00470713		add		$sp,$sp,#4
FFFC53C8 0109A023		sw    v0,[a1]   ; and save value in the variable
FFFC53CC 0009E833		mov		v0,a1			; return v0 = variable address
FFFC53D0 FFC9A883		lw		v1,-4[a1]
FFFC53D4 0FF8F893		and		v1,v1,#$FF
FFFC53D8 00072083		lw		$ra,[$sp]
FFFC53DC 00470713		add		$sp,$sp,#4
FFFC53E0 00008067		ret
                        	SV1:
FFFC53E4 00470713		add		$sp,$sp,#4
FFFC53E8 0880006F	  jmp	  QWHAT		; if no "=" sign
                        	
                        	
                        	; 'FIN' checks the end of a command.  If it ended with ":",
                        	; execution continues.	If it ended with a CR, it finds the
                        	; the next line and continues from there.
                        	;
                        	FIN:
FFFC53EC FFC70713		sub		$sp,$sp,#4
FFFC53F0 00172023		sw		$ra,[$sp]
FFFC53F4 5F0000EF		call	TSTC		; *** FIN ***
FFFC53F8 0000003A		dw		':'
FFFC53FC 00000663		bra		FI1
FFFC5400 00470713		add		$sp,$sp,#4	; if ":", discard return address
FFFC5404 E25FE06F		jmp		RUNSML		; continue on the same line
                        	FI1:
FFFC5408 5DC000EF		call	TSTC		; not ":", is it a CR?
FFFC540C 0000000D		dw		CR
FFFC5410 00000663		bra		FI2
                        							; else return to the caller
FFFC5414 00470713		add		$sp,$sp,#4	; yes, purge return address
FFFC5418 D25FE06F		jmp		RUNNXL		; execute the next line
                        	FI2:
FFFC541C 00072083		lw		$ra,[$sp]
FFFC5420 00470713		add		$sp,$sp,#4
FFFC5424 00008067		ret					; else return to the caller
                        	
                        	
                        	; 'ENDCHK' checks if a command is ended with a CR. This is
                        	; required in certain commands, such as GOTO, RETURN, STOP, etc.
                        	;
                        	; Check that there is nothing else on the line
                        	; Registers Affected
                        	;   a0
                        	;
                        	ENDCHK:
FFFC5428 FFC70713		sub		$sp,$sp,#4
FFFC542C 00172023		sw		$ra,[$sp]
FFFC5430 674000EF		call	IGNBLK
FFFC5434 000E4903		lbu		a0,[$t2]
FFFC5438 00D06D93		ldi		$t1,#CR
FFFC543C 01B90863		beq		a0,$t1,ec1	; does it end with a CR?
FFFC5440 FFFC6937		ldi		a0,#msgExtraChars
FFFC5444 F7B90913
FFFC5448 0300006F		jmp		ERROR
                        	ec1:
FFFC544C 00072083		lw		$ra,[$sp]
FFFC5450 00470713		add		$sp,$sp,#4
FFFC5454 00008067		ret
                        	
                        	; 'ERROR' prints the string pointed to by a0. It then prints the
                        	; line pointed to by CURRNT with a "?" inserted at where the
                        	; old text pointer (should be on top of the stack) points to.
                        	; Execution of Tiny BASIC is stopped and a warm start is done.
                        	; If CURRNT is zero (indicating a direct command), the direct
                        	; command is not printed. If CURRNT is -1 (indicating
                        	; 'INPUT' command in progress), the input line is not printed
                        	; and execution is not terminated but continues at 'INPERR'.
                        	;
                        	; Related to 'ERROR' are the following:
                        	; 'QWHAT' saves text pointer on stack and gets "What?" message.
                        	; 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                        	; 'QSORRY' and 'ASORRY' do the same kind of thing.
                        	; 'QHOW' and 'AHOW' also do this for "How?".
                        	;
                        	TOOBIG:
FFFC5458 FFFC6937		ldi		a0,#msgTooBig
FFFC545C F6790913
FFFC5460 00000C63		bra		ERROR
                        	QSORRY:
FFFC5464 FFFC6937	  ldi		a0,#SRYMSG
FFFC5468 E0F90913
FFFC546C 00000663		bra	    ERROR
                        	QWHAT:
FFFC5470 FFFC6937		ldi		a0,#msgWhat
FFFC5474 E0890913
                        	ERROR:
FFFC5478 710000EF		call	PRMESG		; display the error message
FFFC547C 00030637		lw		a0,CURRNT	; get the current line pointer
FFFC5480 01860613
FFFC5484 00060633
FFFC5488 00062903
FFFC548C 04090263		beq		a0,r0,ERROR1	; if zero, do a warm start
FFFC5490 FFF06D93		ldi		$t1,#-1
FFFC5494 A1B90663		beq		a0,$t1,INPERR	; is the line no. pointer = -1? if so, redo input
FFFC5498 000E4283		lbu		r5,[$t2]		; save the char. pointed to
FFFC549C 000E0023		sb		x0,[$t2]		; put a zero where the error is
FFFC54A0 00030637		lw		a0,CURRNT	; point to start of current line
FFFC54A4 01860613
FFFC54A8 00060633
FFFC54AC 00062903
FFFC54B0 4D8000EF		call	PRTLN		; display the line in error up to the 0
FFFC54B4 00096333		mov     r6,a0	    ; save off end pointer
FFFC54B8 005E0023		sb		r5,[$t2]		; restore the character
FFFC54BC 03F06913		ldi		a0,#'?'		; display a "?"
FFFC54C0 F48FE0EF		call	GOOUT
FFFC54C4 000069B3		mov		a1,r0		; stop char = 0
FFFC54C8 FFF30913		sub		a0,r6,#1	; point back to the error char.
FFFC54CC 2E4000EF		call	PRTSTG		; display the rest of the line
                        	ERROR1:
FFFC54D0 851FE06F		jmp	    WSTART		; and do a warm start
                        	
                        	;******************************************************************
                        	;
                        	; *** GETLN *** FNDLN (& friends) ***
                        	;
                        	; 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                        	; the character in r3 (given by the caller), then it fills the
                        	; buffer and echos. It ignores LF's but still echos
                        	; them back. Control-H is used to delete the last character
                        	; entered (if there is one), and control-X is used to delete the
                        	; whole line and start over again. CR signals the end of a line,
                        	; and causes 'GETLN' to return.
                        	;
                        	;
                        	GETLN:
FFFC54D4 FF870713		sub		$sp,$sp,#8
FFFC54D8 00572023		sw		r5,[$sp]
FFFC54DC 00172223		sw		$ra,4[$sp]
FFFC54E0 F28FE0EF		call	GOOUT		; display the prompt
FFFC54E4 00106913		ldi		a0,#1
                        	;	sw		a0,CursorFlash	; turn on cursor flash
FFFC54E8 02006913		ldi		a0,#' '		; and a space
FFFC54EC F1CFE0EF		call	GOOUT
FFFC54F0 00030E37		ldi		$t2,#BUFFER	; $t2 is the buffer pointer
FFFC54F4 01CE0E13
                        	.GL1:
FFFC54F8 660000EF		call	CHKIO		; check keyboard
FFFC54FC FE080EE3		beq		v0,x0,.GL1	; wait for a char. to come in
FFFC5500 00806D93		ldi		$t1,#CTRLH
FFFC5504 05B80863		beq		v0,$t1,.GL3	; delete last character? if so
FFFC5508 01806D93		ldi		$t1,#CTRLX
FFFC550C 07B80A63		beq		v0,$t1,.GL4	; delete the whole line?
FFFC5510 00D06D93		ldi		$t1,#CR
FFFC5514 01B80663		beq		v0,$t1,.GL2		; accept a CR
FFFC5518 02006D93		ldi		$t1,#' '
FFFC551C FDB84EE3		blt		v0,$t1,.GL1	; if other control char., discard it
                        	.GL2:
FFFC5520 010E0023		sb		v0,[$t2]		; save the char.
FFFC5524 001E0E13		add		$t2,$t2,#1
FFFC5528 FFC70713		sub		$sp,$sp,#4
FFFC552C 01072023		sw		v0,[$sp]
FFFC5530 00086933		mov		$a0,$v0
FFFC5534 ED4FE0EF		call	GOOUT		; echo the char back out
FFFC5538 00072803		lw		v0,[$sp]; get char back (GOOUT destroys a0)
FFFC553C 00470713		add		$sp,$sp,#4
FFFC5540 00D06D93		ldi		$t1,#CR
FFFC5544 09B80063		beq		v0,$t1,.GL7			; if it's a CR, end the line
FFFC5548 00030DB7		ldi		$t1,#BUFFER+BUFLEN-1
FFFC554C 06FD8D93
FFFC5550 FBBE44E3		blt		$t2,$t1,.GL1		; any more room? ; yes: get some more, else delete last char.
                        	.GL3:
FFFC5554 00806913		ldi		a0,#CTRLH	; delete a char. if possible
FFFC5558 EB0FE0EF		call	GOOUT
FFFC555C 02006913		ldi		a0,#' '
FFFC5560 EA8FE0EF		call	GOOUT
FFFC5564 00030DB7		ldi		$t1,#BUFFER
FFFC5568 01CD8D93
FFFC556C F9CDD6E3		ble		$t2,$t1,.GL1	; any char.'s left?	; if not
FFFC5570 00806913		ldi		a0,#CTRLH		; if so, finish the BS-space-BS sequence
FFFC5574 E94FE0EF		call	GOOUT
FFFC5578 FFFE0E13		sub		$t2,$t2,#1	; decrement the text pointer
FFFC557C F6000EE3		bra		.GL1		; back for more
                        	.GL4:
FFFC5580 000E6933		mov		a0,$t2		; delete the whole line
FFFC5584 FFFD0637		sub		r5,a0,#BUFFER   ; figure out how many backspaces we need
FFFC5588 FE460613
FFFC558C 412602B3
FFFC5590 02028463		beq		r5,r0,.GL6		; if none needed, brnch
FFFC5594 FFF28293		sub		r5,r5,#1		; loop count is one less
                        	.GL5:
FFFC5598 00806913		ldi		a0,#CTRLH		; and display BS-space-BS sequences
FFFC559C E6CFE0EF		call	GOOUT
FFFC55A0 02006913		ldi		a0,#' '
FFFC55A4 E64FE0EF		call	GOOUT
FFFC55A8 00806913		ldi		a0,#CTRLH
FFFC55AC E5CFE0EF		call	GOOUT
FFFC55B0 FFF28293		sub		r5,r5,#1
FFFC55B4 FE0292E3		bne		r5,r0,.GL5
                        	.GL6:
FFFC55B8 00030E37		ldi		$t2,#BUFFER	; reinitialize the text pointer
FFFC55BC 01CE0E13
FFFC55C0 F2000CE3		bra		.GL1		; and go back for more
                        	.GL7:
FFFC55C4 000E0023		sb		x0,[$t2]		; null terminate line
                        	;	sw		x0,CursorFlash	; turn off cursor flash
FFFC55C8 00A06913		ldi		a0,#LINEFD	; echo a LF for the CR
FFFC55CC E3CFE0EF		call	GOOUT
FFFC55D0 00072283		lw		r5,[$sp]
FFFC55D4 00472083		lw		$ra,4[$sp]
FFFC55D8 00870713		add		$sp,$sp,#8
FFFC55DC 00008067		ret
                        	
                        	
                        	; 'FNDLN' finds a line with a given line no. (in a0) in the
                        	; text save area.  $t3 is used as the text pointer. If the line
                        	; is found, $t3 will point to the beginning of that line
                        	; (i.e. the high byte of the line no.), and $v0 = 1.
                        	; If that line is not there and a line with a higher line no.
                        	; is found, $t3 points there and $v0 = 0. If we reached
                        	; the end of the text save area and cannot find the line, flags
                        	; $t3 = 0, $v0 = 0.
                        	; $v0=1 if line found
                        	; r0 = 1	<= line is found
                        	;	$t3 = pointer to line
                        	; r0 = 0    <= line is not found
                        	;	r9 = zero, if end of text area
                        	;	r9 = otherwise higher line number
                        	;
                        	; 'FNDLN' will initialize $t3 to the beginning of the text save
                        	; area to start the search. Some other entries of this routine
                        	; will not initialize $t3 and do the search.
                        	; 'FNDLNP' will start with $t3 and search for the line no.
                        	; 'FNDNXT' will bump $t3 by 4, find a CR and then start search.
                        	; 'FNDSKP' uses $t3 to find a CR, and then starts the search.
                        	; return Z=1 if line is found, r9 = pointer to line
                        	;
                        	; Parameters
                        	;	a0 = line number to find
                        	;
                        	FNDLN:
FFFC55E0 00100DB7		ldi		$t1,#$FFFFF
FFFC55E4 FFFD8D93
FFFC55E8 01B94863		blt		a0,$t1,fl1	; line no. must be < 65535
FFFC55EC FFFC6937		ldi		a0,#msgLineRange
FFFC55F0 E9590913
FFFC55F4 E85FF06F		jmp		ERROR
                        	fl1:
FFFC55F8 00032EB7		ldi		$t3,#TXTBGN	; init. the text save pointer
FFFC55FC 800E8E93
                        	
                        	FNDLNP:
FFFC5600 00030637		lw		$t4,TXTUNF	; check if we passed the end
FFFC5604 00460613
FFFC5608 00060633
FFFC560C 00062F03
FFFC5610 05EEF463		bgeu	$t3,$t4,FNDRET1; if so, return with r9=0,a0=0
FFFC5614 FF870713		sub		$sp,$sp,#8	; push a0
FFFC5618 01272023		sw		a0,[$sp]
FFFC561C 00172223		sw		ra,4[$sp]
FFFC5620 000EE933		mov		a0,t3
FFFC5624 338000EF		call	LoadWord		; get line number
FFFC5628 00072903		lw		a0,[$sp]		; pop a0
FFFC562C 00472083		lw		ra,4[$sp]
FFFC5630 00870713		add		$sp,$sp,#8
FFFC5634 03280663		beq		v0,a0,FNDRET2
FFFC5638 03286863		bltu	v0,a0,FNDNXT	; is this the line we want? no, not there yet
                        	FNDRET:
FFFC563C 004E8E93		add		$t3,$t3,#4	; find the next line, skip over line number
                        	.0001:
FFFC5640 000EC883		lbu		v1,[$t3]
FFFC5644 001E8E93		add		$t3,$t3,#1
FFFC5648 00D06D93		ldi		$t1,#CR
FFFC564C FFB89AE3		bne		v1,$t1,.0001	; try to find a CR, keep looking
FFFC5650 00006833		mov		v0,x0	; line not found, but $t3=next line pointer
FFFC5654 00008067		ret
                        	FNDRET1:
                        	;	eor		r9,r9,r9	; no higher line
FFFC5658 00006833		mov		v0,x0	; line not found
FFFC565C 00008067		ret
                        	FNDRET2:
FFFC5660 00106813		ldi		v0,#1	; line found
FFFC5664 00008067		ret
                        	
                        	FNDNXT:
FFFC5668 004E8E93		add		$t3,$t3,#4	; find the next line
                        	
                        	FNDSKP:
FFFC566C 000EC883		lbu		v1,[$t3]
FFFC5670 001E8E93		add		$t3,$t3,#1
FFFC5674 00D06D93		ldi		$t1,#CR
FFFC5678 FFB89AE3		bne		v1,$t1,FNDSKP	; try to find a CR, keep looking
FFFC567C F80002E3		bra		FNDLNP		; check if end of text
                        	
                        	
                        	;******************************************************************
                        	; 'MVUP' moves a block up from where a0 points to where a1 points
                        	; until a0=a2
                        	;
                        	MVUP1:
FFFC5680 00090203		lb		r4,[a0]
FFFC5684 00498023		sb		r4,[a1]
FFFC5688 00190913		add		a0,a0,#1
FFFC568C 00198993		add		a1,a1,#1
                        	MVUP:
FFFC5690 FF4918E3		bne		a0,a2,MVUP1
FFFC5694 00008067		ret
                        	
                        	
                        	; 'MVDOWN' moves a block down from where a0 points to where a1
                        	; points until a0=a2
                        	;
                        	MVDOWN1:
FFFC5698 FFF90913		sub		a0,a0,#1
FFFC569C FFF98993		sub		a1,a1,#1
FFFC56A0 00090203		lb		r4,[a0]
FFFC56A4 00498023		sb		r4,[a1]
                        	MVDOWN:
FFFC56A8 FF4918E3		bne		a0,a2,MVDOWN1
FFFC56AC 00008067		ret
                        	
                        	
                        	; 'POPA_' restores the 'FOR' loop variable save area from the stack
                        	;
                        	; 'PUSHA_' stacks for 'FOR' loop variable save area onto the stack
                        	;
                        	; Note: a single zero word is stored on the stack in the
                        	; case that no FOR loops need to be saved. This needs to be
                        	; done because PUSHA_ / POPA_ is called all the time.
                        	//message "POPA_"
                        	POPA_:
FFFC56B0 00072903		lw		a0,[$sp]
FFFC56B4 00470713		add		$sp,$sp,#4
FFFC56B8 00030637		sw		a0,LOPVAR	; restore LOPVAR, but zero means no more
FFFC56BC 01060613
FFFC56C0 00060633
FFFC56C4 01262023
FFFC56C8 04090C63		beq		a0,x0,PP1
FFFC56CC 00072903		lw		a0,[$sp]
FFFC56D0 00030637		sw		a0,LOPPT
FFFC56D4 07060613
FFFC56D8 00060633
FFFC56DC 01262023
FFFC56E0 00472903		lw		a0,4[$sp]
FFFC56E4 00030637		sw		a0,LOPLN
FFFC56E8 07460613
FFFC56EC 00060633
FFFC56F0 01262023
FFFC56F4 00872903		lw		a0,8[$sp]
FFFC56F8 00030637		sw		a0,LOPLMT
FFFC56FC 07C60613
FFFC5700 00060633
FFFC5704 01262023
FFFC5708 00C72903		lw		a0,12[$sp]
FFFC570C 00030637		sw		a0,LOPINC
FFFC5710 07860613
FFFC5714 00060633
FFFC5718 01262023
FFFC571C 01070713		add		$sp,$sp,#16
                        	PP1:
FFFC5720 00008067		ret
                        	
                        	
                        	PUSHA_:
FFFC5724 00030637		lw		a0,STKBOT	; Are we running out of stack room?
FFFC5728 09C60613
FFFC572C 00060633
FFFC5730 00062903
FFFC5734 01490913		add		a0,a0,#20	; we might need this many bytes
FFFC5738 D32746E3		blt		$sp,a0,QSORRY	; out of stack space
FFFC573C 00030637		lw		a1,LOPVAR		; save loop variables
FFFC5740 01060613
FFFC5744 00060633
FFFC5748 00062983
FFFC574C 04098C63		beq		a1,x0,PU1		; if LOPVAR is zero, that's all
FFFC5750 FF070713		sub		$sp,$sp,#16
FFFC5754 00030637		lw		a0,LOPPT
FFFC5758 07060613
FFFC575C 00060633
FFFC5760 00062903
FFFC5764 01272023		sw		a0,[$sp]
FFFC5768 00030637		lw		a0,LOPLN
FFFC576C 07460613
FFFC5770 00060633
FFFC5774 00062903
FFFC5778 01272223		sw		a0,4[$sp]
FFFC577C 00030637		lw		a0,LOPLMT
FFFC5780 07C60613
FFFC5784 00060633
FFFC5788 00062903
FFFC578C 01272423		sw		a0,8[$sp]
FFFC5790 00030637		lw		a0,LOPINC
FFFC5794 07860613
FFFC5798 00060633
FFFC579C 00062903
FFFC57A0 01272623		sw		a0,12[$sp]
                        	PU1:
FFFC57A4 FFC70713		sub		$sp,$sp,#4
FFFC57A8 01372023		sw		a1,[$sp]
FFFC57AC 00008067		ret
                        	
                        	
                        	;******************************************************************
                        	;
                        	; 'PRTSTG' prints a string pointed to by a0. It stops printing
                        	; and returns to the caller when either a CR is printed or when
                        	; the next byte is the same as what was passed in a1 by the
                        	; caller.
                        	;
                        	; 'PRTLN' prints the saved text line pointed to by r3
                        	; with line no. and all.
                        	;
                        	
                        	; a0 = pointer to string
                        	; a1 = stop character
                        	; return v0 = pointer to end of line + 1
                        	
                        	PRTSTG:
FFFC57B0 FEC70713		sub		$sp,$sp,#20
FFFC57B4 00572023		sw		r5,[$sp]
FFFC57B8 00672223		sw		r6,4[$sp]
FFFC57BC 00772423		sw		r7,8[$sp]
FFFC57C0 00172623		sw		$ra,12[$sp]
FFFC57C4 01272823		sw		$a0,16[$sp]
FFFC57C8 000962B3		mov   r5,a0	    ; r5 = pointer
FFFC57CC 0009E333		mov   r6,a1	    ; r6 = stop char
                        	.PS1:
FFFC57D0 0002C383	  lbu   r7,[r5]     ; get a text character
FFFC57D4 00128293		add		r5,r5,#1
FFFC57D8 00638E63		beq	  r7,r6,.PRTRET	; same as stop character? if so, return
FFFC57DC 0003E933		mov   a0,r7
FFFC57E0 C28FE0EF		call	GOOUT		; display the char.
FFFC57E4 00D06D93		ldi		$t1,#CR
FFFC57E8 FFB394E3		bne   r7,$t1,.PS1	; is it a C.R.? no, go back for more
FFFC57EC 00A06913		ldi		a0,#LINEFD  ; yes, add a L.F.
FFFC57F0 C18FE0EF		call	GOOUT
                        	.PRTRET:
FFFC57F4 0003E8B3	  mov   v1,r7	    ; return a1 = stop char
FFFC57F8 0002E833		mov		v0,r5		; return a0 = line pointer
FFFC57FC 00072283		lw		$r5,[$sp]
FFFC5800 00472303		lw		$r6,4[$sp]
FFFC5804 00872383		lw		$r7,8[$sp]
FFFC5808 00C72083		lw		$ra,12[$sp]
FFFC580C 01072903		lw		$a0,16[$sp]
FFFC5810 01470713		add		$sp,$sp,#20
FFFC5814 00008067	  ret					; then return
                        	
                        	
                        	; 'QTSTG' looks for an underline (back-arrow on some systems),
                        	; single-quote, or double-quote.  If none of these are found, returns
                        	; to the caller.  If underline, outputs a CR without a LF.  If single
                        	; or double quote, prints the quoted string and demands a matching
                        	; end quote.  After the printing, the next i-word of the caller is
                        	; skipped over (usually a branch instruction).
                        	;
                        	QTSTG:
FFFC5818 FFC70713		sub		$sp,$sp,#4
FFFC581C 00172023		sw		$ra,[$sp]
FFFC5820 1C4000EF		call	TSTC		; *** QTSTG ***
FFFC5824 00000022		dw		'"'
FFFC5828 02000063		bra		QT3
FFFC582C 02206993		ldi		a1,#'"'		; it is a "
                        	QT1:
FFFC5830 000E6933		mov		a0,$t2
FFFC5834 F7DFF0EF		call	PRTSTG		; print until another
FFFC5838 00086E33		mov		$t2,v0
FFFC583C 00D06D93		ldi		$t1,#CR
FFFC5840 03B89863		bne		v1,$t1,QT2	; was last one a CR?
FFFC5844 8F9FE06F		jmp		RUNNXL		; if so run next line
                        	QT3:
FFFC5848 19C000EF		call	TSTC		; is it a single quote?
FFFC584C 0000005C		dw		'\''
FFFC5850 00000663		bra		QT4
FFFC5854 02706993		ldi		a1,#'\''	; if so, do same as above
FFFC5858 FC000CE3		bra		QT1
                        	QT4:
FFFC585C 188000EF		call	TSTC		; is it an underline?
FFFC5860 0000005F		dw		'_'
FFFC5864 00000C63		bra		QT5
FFFC5868 00D06913		ldi		a0,#CR		; if so, output a CR without LF
FFFC586C B9CFE0EF		call	GOOUT
                        	QT2:
FFFC5870 00072083		lw		$ra,[$sp]		; get return address
FFFC5874 00470713		add		$sp,$sp,#4
FFFC5878 00408067		jmp		4[$ra]		; skip following branch
                        	QT5:					; not " ' or _
FFFC587C 00072083		lw		$ra,[$sp]		; get return address
FFFC5880 00470713		add		$sp,$sp,#4
FFFC5884 00008067		ret
                        	
                        	; Output a CR LF sequence
                        	;
                        	prCRLF:
FFFC5888 FFC70713		sub		$sp,$sp,#4
FFFC588C 00172023		sw		$ra,[$sp]
FFFC5890 00D06913		ldi		a0,#CR
FFFC5894 B74FE0EF		call	GOOUT
FFFC5898 00A06913		ldi		a0,#LINEFD
FFFC589C B6CFE0EF		call	GOOUT
FFFC58A0 00072083		lw		$ra,[$sp]
FFFC58A4 00470713		add		$sp,$sp,#4
FFFC58A8 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; 'PRTNUM' prints the 32 bit number in a0, leading blanks are added if
                        	; needed to pad the number of spaces to the number in a1.
                        	; However, if the number of digits is larger than the no. in
                        	; a1, all digits are printed anyway. Negative sign is also
                        	; printed and counted in, positive sign is not.
                        	;
                        	; Parameters
                        	; 	a0 = number to print
                        	; 	a1 = number of digits
                        	;		a2 = base (eg 10, 16)
                        	; Register Usage
                        	;		s2 = number of padding spaces
                        	; Modifies:
                        	;		a0,a1,t1
                        	; Returns:
                        	;		none
                        	;-------------------------------------------------------------------------------
                        	
FFFC58AC FEC70713	public PRTNUM:
	sub		$sp,$sp,#20
FFFC58B0 00472023		sw		$s1,[$sp]
FFFC58B4 00572223		sw		$s2,4[$sp]
FFFC58B8 00672423		sw		$s3,8[$sp]
FFFC58BC 00772623		sw		$s4,12[$sp]
FFFC58C0 00172823		sw		$ra,16[$sp]
FFFC58C4 000303B7		ldi		s4,#NUMWKA	; r7 = pointer to numeric work area
FFFC58C8 09438393
FFFC58CC 00096333		mov		s3,a0		; save number for later
FFFC58D0 0009E2B3		mov		s2,a1		; s2 = min number of chars
FFFC58D4 00095663		bge		a0,x0,.PN2	; is it negative? if not
FFFC58D8 41200933		sub		a0,x0,a0	; else make it positive
FFFC58DC FFF28293		sub		s2,s2,#1	; one less for width count
                        	.PN2:
FFFC58E0 00A06D93		ldi		$t1,#10
                        	.PN1:
FFFC58E4 034969B3		rem		a1,a0,a2	; a1 = a0 mod 10
FFFC58E8 03494933		div		a0,a0,a2	; a0 /= 10 divide by 10
FFFC58EC 013A7463		bleu	a1,a2,.PN7
FFFC58F0 00798993		add		a1,a1,#'A'-10-'0'
                        	.PN7:
FFFC58F4 03098993		add		a1,a1,#'0'	; convert remainder to ascii
FFFC58F8 01338023		sb		a1,[$s4]		; and store in buffer
FFFC58FC 00138393		add		s4,s4,#1
FFFC5900 FFF28293		sub		s2,s2,#1	; decrement width
FFFC5904 FE0910E3		bne		a0,x0,.PN1
FFFC5908 00505A63		ble		$s2,$x0,.PN4	; test pad count, skip padding if not needed
                        	.PN3:
FFFC590C 02006913		ldi		$a0,#' '		; display the required leading spaces
FFFC5910 AF8FE0EF		call	GOOUT
FFFC5914 FFF28293		sub		$s2,$s2,#1
FFFC5918 FE504AE3		bgt		$s2,$x0,.PN3
                        	.PN4:
FFFC591C 00035663		bge		$s3,$x0,.PN5	; is number negative?
FFFC5920 02D06913		ldi		$a0,#'-'		; if so, display the sign
FFFC5924 AE4FE0EF		call	GOOUT
                        	.PN5:
FFFC5928 00030DB7		ldi		$t1,#NUMWKA
FFFC592C 094D8D93
                        	.PN6:
FFFC5930 FFF38393		sub		$s4,$s4,#1
FFFC5934 0003C903		lbu		$a0,[$s4]		; now unstack the digits and display
FFFC5938 AD0FE0EF		call	GOOUT
FFFC593C FE7DEAE3		bgtu	$s4,$t1,.PN6
                        	
FFFC5940 00072203		lw		$s1,[$sp]
FFFC5944 00472283		lw		$s2,4[$sp]
FFFC5948 00872303		lw		$s3,8[$sp]
FFFC594C 00C72383		lw		$s4,12[$sp]
FFFC5950 01072083		lw		$ra,16[$sp]
FFFC5954 01470713		add		$sp,$sp,#20
FFFC5958 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; Load a word from memory using unaligned access.
                        	; Moves forwards through memory
                        	;
                        	; Parameters:
                        	;		a0 = pointer to word
                        	; Returns:
                        	;		v0 = word loaded
                        	;-------------------------------------------------------------------------------
                        	LoadWord:
FFFC595C 00094803	  lbu		$v0,[$a0]	
FFFC5960 00194883	  lbu		$v1,1[$a0]
FFFC5964 00889893	  sll		$v1,$v1,#8
FFFC5968 01186833	  or		$v0,$v0,$v1
FFFC596C 00294883	  lbu		$v1,2[$a0]
FFFC5970 01089893	  sll		$v1,$v1,#16
FFFC5974 01186833	  or		$v0,$v0,$v1
FFFC5978 00394883	  lbu		$v1,3[$a0]
FFFC597C 01889893	  sll		$v1,$v1,#24
FFFC5980 01186833	  or		$v0,$v0,$v1
FFFC5984 00008067		ret
                        	
                        	;-------------------------------------------------------------------------------
                        	; Parameters:
                        	; 	a0 = pointer to line
                        	; Returns:
                        	;		v0 = pointer to end of line + 1
                        	;-------------------------------------------------------------------------------
                        	
                        	PRTLN:
FFFC5988 FF070713		sub		$sp,$sp,#16
FFFC598C 00572023		sw		$r5,[$sp]
FFFC5990 00172223		sw		$ra,4[$sp]
FFFC5994 01272423		sw		$a0,8[$sp]
FFFC5998 01372623		sw		$a1,12[$sp]
FFFC599C 000962B3	  mov		$r5,$a0		; r5 = pointer
                        	  ; get the line number stored as binary
                        	  ; assume unaligned loads not allowed
FFFC59A0 FBDFF0EF	  call	LoadWord
FFFC59A4 00086933	  mov		a0,v0
                        	
FFFC59A8 00428293		add		r5,r5,#4
FFFC59AC 00506993	  ldi		a1,#5       ; display a 0 or more digit line no.
FFFC59B0 00A06A13	  ldi		a2,#10
FFFC59B4 EF9FF0EF		call	PRTNUM
FFFC59B8 02006913		ldi		a0,#' '     ; followed by a blank
FFFC59BC A4CFE0EF		call	GOOUT
FFFC59C0 000069B3		mov		a1,r0       ; stop char. is a zero
FFFC59C4 0002E933		mov		a0,r5
FFFC59C8 DE9FF0EF		call  PRTSTG		; display the rest of the line
FFFC59CC 00072283		lw		$r5,[$sp]
FFFC59D0 00472083		lw		$ra,4[$sp]
FFFC59D4 00872903		lw		$a0,8[$sp]
FFFC59D8 00C72983		lw		$a1,12[$sp]
FFFC59DC 01070713		add		$sp,$sp,#16
FFFC59E0 00008067		ret
                        	
                        	
                        	; ===== Test text byte following the call to this subroutine. If it
                        	;	equals the byte pointed to by t2, return to the code following
                        	;	the call. 
                        	;
                        	; Parameters:
                        	;		<static> word byte to look for
                        	;		<static> branch if not found
                        	; Registers Affected
                        	;   none
                        	; Returns
                        	;		t2 = updated text pointer
                        	;
                        	TSTC:
FFFC59E4 FF470713		sub		$sp,$sp,#12
FFFC59E8 01272023		sw		$a0,[$sp]
FFFC59EC 00172223		sw		$ra,4[$sp]
FFFC59F0 01372423		sw		$a1,8[$sp]
FFFC59F4 0B0000EF		call	IGNBLK		; ignore leading blanks
FFFC59F8 00472083		lw		$ra,4[$sp]	; get return address, it's needed for a reference
FFFC59FC 000E4903		lbu		$a0,[$t2]
FFFC5A00 0000C983		lbu		$a1,[$ra]
FFFC5A04 01298A63		beq		$a1,$a0,TC1	; is it = to what t2 points to? if so
FFFC5A08 00072903		lw		$a0,[$sp]		; restore a0
FFFC5A0C 00872983		lw		$a1,8[$sp]
FFFC5A10 00C70713		add		$sp,$sp,#12	;
FFFC5A14 00408067		jmp		4[$ra]			; jump to the routine skip param
                        	TC1:
FFFC5A18 001E0E13		add		$t2,$t2,#1	; if equal, bump text pointer
FFFC5A1C 00072903		lw		$a0,[$sp]
FFFC5A20 00472083		lw		$ra,4[$sp]
FFFC5A24 00872983		lw		$a1,8[$sp]
FFFC5A28 00C70713		add		$sp,$sp,#12
FFFC5A2C 00808067		jmp		8[$ra]			; jump back, skip parm and branch
                        	
                        	
                        	; ===== See if the text pointed to by $t2 is a number. If so,
                        	;	return the number in $v0 and the number of digits in $v1,
                        	;	else return zero in $v0 and $v1.
                        	; Registers Affected
                        	;   a0,a1,r3,r4
                        	; Returns
                        	; 	v0 = number
                        	;		v1 = number of digits in number
                        	;	t2 = updated text pointer
                        	;
                        	TSTNUM:
FFFC5A30 FF870713		sub		$sp,$sp,#8
FFFC5A34 00172223		sw		$ra,4[$sp]
FFFC5A38 00372023		sw		r3,[$sp]
FFFC5A3C 068000EF		call	IGNBLK		; skip over blanks
FFFC5A40 00006833		mov		$v0,$x0		; initialize return parameters
FFFC5A44 000068B3		mov		$v1,$x0
                        	TN1:
FFFC5A48 000E4183		lbu		r3,[$t2]
FFFC5A4C 03006D93		ldi		$t1,#'0'
FFFC5A50 05B1C263		blt		r3,$t1,TSNMRET; is it less than zero?
FFFC5A54 03906D93		ldi		$t1,#'9'
FFFC5A58 023DCE63		bgt		r3,$t1,TSNMRET; is it greater than nine?
FFFC5A5C 00000DB7		ldi		$t1,#$7FFFFFFFFFFFFFF
FFFC5A60 FFFD8D93
FFFC5A64 010DF863		bleu	$v0,$t1,TN2; see if there's room for new digit
FFFC5A68 FFFC6937		ldi		$a0,#msgNumTooBig
FFFC5A6C E3190913
FFFC5A70 A09FF06F		jmp		ERROR		; if not, we've overflowd
                        	TN2:
FFFC5A74 001E0E13		add		$t2,$t2,#1	; adjust text pointer
FFFC5A78 00181E93		sll		$t3,$v0,#1	; quickly multiply result by 10
FFFC5A7C 00381813		sll		$v0,$v0,#3	; *8
FFFC5A80 01D80833		add		$v0,$v0,$t3	; *8 + *2
FFFC5A84 00F1F193		and		r3,r3,#$0F	; add in the new digit
FFFC5A88 00380833		add		$v0,$v0,r3
FFFC5A8C 00188893		add		$v1,$v1,#1	; increment the no. of digits
FFFC5A90 FA000CE3		bra		TN1
                        	TSNMRET:
FFFC5A94 00072183		lw		r3,[$sp]
FFFC5A98 00472083		lw		$ra,4[$sp]
FFFC5A9C 00870713		add		$sp,$sp,#8
FFFC5AA0 00008067		ret
                        	
                        	
                        	;===== Skip over blanks in the text pointed to by $t2.
                        	;
                        	; Registers Affected:
                        	;	$t2
                        	; Returns
                        	;	$t2 = pointer updateded past any spaces or tabs
                        	;
                        	IGNBLK:
FFFC5AA4 FFC70713		sub		$sp,$sp,#4
FFFC5AA8 01272023		sw		$a0,[$sp]
                        	IGB2:
FFFC5AAC 000E4903		lbu		a0,[$t2]			; get char
FFFC5AB0 02006D93		ldi		$t1,#' '
FFFC5AB4 01B90663		beq		$a0,$t1,IGB1	; see if it's a space
FFFC5AB8 00906D93		ldi		$t1,#'\t'
FFFC5ABC 01B91663		bne		a0,$t1,IGBRET	; or a tab
                        	IGB1:
FFFC5AC0 001E0E13		add		$t2,$t2,#1		; increment the text pointer
FFFC5AC4 FE0004E3		bra		IGB2
                        	IGBRET:
FFFC5AC8 00072903		lw		$a0,[$sp]
FFFC5ACC 00470713		add		$sp,$sp,#4
FFFC5AD0 00008067		ret
                        	
                        	; ===== Convert the line of text in the input buffer to upper
                        	;	case (except for stuff between quotes).
                        	;
                        	; Registers Affected
                        	;   a0,r3
                        	; Returns
                        	;	r8 = pointing to end of text in buffer
                        	;
                        	TOUPBUF:
FFFC5AD4 FFC70713		sub		$sp,$sp,#4
FFFC5AD8 00172023		sw		$ra,[$sp]
FFFC5ADC 00030E37		ldi		$t2,#BUFFER	; set up text pointer
FFFC5AE0 01CE0E13
FFFC5AE4 000061B3		mov		r3,x0		; clear quote flag
                        	TOUPB1:
FFFC5AE8 000E4903		lbu		a0,[$t2]		; get the next text char.
FFFC5AEC 001E0E13		add		$t2,$t2,#1
FFFC5AF0 00D06D93		ldi		$t1,#CR
FFFC5AF4 03B90E63		beq		a0,$t1,TOUPBRT		; is it end of line?
FFFC5AF8 02206D93		ldi		$t1,#'"'
FFFC5AFC 01B90E63		beq		a0,$t1,DOQUO	; a double quote?
FFFC5B00 02706D93		ldi		$t1,#'\''
FFFC5B04 01B90A63		beq		a0,$t1,DOQUO	; or a single quote?
FFFC5B08 FE0190E3		bne		r3,x0,TOUPB1	; inside quotes?
FFFC5B0C 030000EF		call	toUpper 	; convert to upper case
FFFC5B10 FF0E0FA3		sb		v0,-1[$t2]	; store it
FFFC5B14 FC000AE3		bra		TOUPB1		; and go back for more
                        	DOQUO:
FFFC5B18 00019663		bne		r3,x0,DOQUO1; are we inside quotes?
FFFC5B1C 000961B3		mov		r3,a0		; if not, toggle inside-quotes flag
FFFC5B20 FC0004E3		bra		TOUPB1
                        	DOQUO1:
FFFC5B24 FD2192E3		bne		r3,a0,TOUPB1; make sure we're ending proper quote
FFFC5B28 000061B3		mov		r3,r0		; else clear quote flag
FFFC5B2C FA000EE3		bra		TOUPB1
                        	TOUPBRT:
FFFC5B30 00072083		lw		$ra,[$sp]
FFFC5B34 00470713		add		$sp,$sp,#4
FFFC5B38 00008067		ret
                        	
                        	
                        	; ===== Convert the character in a0 to upper case
                        	;
                        	toUpper:
FFFC5B3C 00096833		mov		$v0,$a0
FFFC5B40 06182D93		slt		$t1,$v0,#'a'
FFFC5B44 000D9863		bne   $t1,$x0,TOUPRET	; is it < 'a'?
FFFC5B48 07A06D93		ldi		$t1,#'z'
FFFC5B4C 010DC463		bgt		$v0,$t1,TOUPRET	; or > 'z'?
FFFC5B50 FE080813		sub		$v0,$v0,#32	  ; if not, make it upper case
                        	TOUPRET:
FFFC5B54 00008067		ret
                        	
                        	; 'CHKIO' checks the input. If there's no input, it will return
                        	; to the caller with the a0=0. If there is input, the input byte is in a0.
                        	; However, if a control-C is read, 'CHKIO' will warm-start BASIC and will
                        	; not return to the caller.
                        	;
                        	//message "CHKIO"
                        	CHKIO:
FFFC5B58 FFC70713		sub		$sp,$sp,#4
FFFC5B5C 00172023		sw		$ra,[$sp]
FFFC5B60 228000EF		call	INCH		; get input if possible
FFFC5B64 00080863		beq		$v0,$x0,CHKRET	; if Zero, no input
FFFC5B68 00384893		xor		$v1,$v0,#CTRLC
FFFC5B6C 00089463		bne		$v1,$x0,CHKRET; is it control-C?
FFFC5B70 9B0FE06F		jmp		WSTART		; if so, do a warm start
                        	CHKRET:
FFFC5B74 00072083		lw		$ra,[$sp]
FFFC5B78 00470713		add		$sp,$sp,#4
FFFC5B7C 00008067		ret
                        	
                        	; ===== Display a CR-LF sequence
                        	;
                        	CRLF:
FFFC5B80 FFFC6937		ldi		a0,#CLMSG
FFFC5B84 E1590913
                        	
                        	; ===== Display a zero-ended string pointed to by register a0
                        	; Registers Affected
                        	;   a0,a1,r4
                        	;
                        	PRMESG:
FFFC5B88 FFC70713		sub		$sp,$sp,#4
FFFC5B8C 00172023		sw		$ra,[$sp]
FFFC5B90 C69FA0EF		call	PutString
FFFC5B94 00072083		lw		$ra,[$sp]
FFFC5B98 00470713		add		$sp,$sp,#4
FFFC5B9C 00008067		ret
                        	
                        	;------------------------------------------------------------------------------
                        	;	erc = ALLOCMBX (<handle var>)
                        	;------------------------------------------------------------------------------
                        	
                        	ALLOCMBX:
FFFC5BA0 E45FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC5BA4 00000028		dw		'('
FFFC5BA8 04000E63		bra		.paren
FFFC5BAC 00106913		ldi		a0,#1
FFFC5BB0 C68FF0EF		call	TSTV
FFFC5BB4 00081863		bne		v0,x0,.0001
FFFC5BB8 FFFC6937		ldi		a0,#msgVar
FFFC5BBC EAA90913
FFFC5BC0 8B9FF06F		jmp		ERROR
                        	.0001:
FFFC5BC4 E21FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC5BC8 00000029		dw		')'
FFFC5BCC 02000C63		bra		.paren
FFFC5BD0 00086233		mov		s1,v0
FFFC5BD4 00E06913		ldi		a0,#14			; get current tid
FFFC5BD8 00000073		ecall
FFFC5BDC 0008E9B3		mov		a1,v1
FFFC5BE0 00026A33		mov		a2,s1
FFFC5BE4 00606913		ldi		a0,#6
FFFC5BE8 00000073		ecall
FFFC5BEC 00081463		bne		v0,x0,.0002
FFFC5BF0 01122023		sw		v1,[s1]				; save handle in variable
                        	.0002:
FFFC5BF4 000068B3		mov		v1,x0
FFFC5BF8 00072083		lw		$ra,[$sp]
FFFC5BFC 00470713		add		$sp,$sp,#4
FFFC5C00 00008067		ret
                        	.paren:
FFFC5C04 FFFC6937		ldi		a0,#msgParen
FFFC5C08 FB790913
FFFC5C0C 86DFF06F		jmp		ERROR
                        	
                        	;------------------------------------------------------------------------------
                        	; erc = SENDMSG (<handle var>, <msg data 1>, <msg data 2>, <msg data 3>)
                        	;------------------------------------------------------------------------------
                        	
                        	SENDMSG:
FFFC5C10 DD5FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC5C14 00000028		dw		'('
FFFC5C18 08000463		bra		.paren
FFFC5C1C FBDFE0EF		call	OREXPR	; get the mailbox handle
FFFC5C20 00086233		mov		s1,v0
FFFC5C24 DC1FF0EF		call	TSTC		; it must be followed by a comma
FFFC5C28 0000002C		dw		','
FFFC5C2C 06000463		bra		.err
FFFC5C30 FA9FE0EF		call	OREXPR	; get the memory address
FFFC5C34 000862B3		mov		s2,v0
FFFC5C38 DADFF0EF		call	TSTC		; it must be followed by a comma
FFFC5C3C 0000002C		dw		','
FFFC5C40 04000A63		bra		.err
FFFC5C44 F95FE0EF		call	OREXPR	; get the memory address
FFFC5C48 00086333		mov		s3,v0
FFFC5C4C D99FF0EF		call	TSTC		; it must be followed by a comma
FFFC5C50 0000002C		dw		','
FFFC5C54 04000063		bra		.err
FFFC5C58 F81FE0EF		call	OREXPR	; get the memory address
FFFC5C5C 000863B3		mov		s4,v0
FFFC5C60 D85FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC5C64 00000029		dw		')'
FFFC5C68 02000C63		bra		.paren
FFFC5C6C 00906913		ldi		a0,#9		; SendMsg
FFFC5C70 000269B3		mov		a1,s1
FFFC5C74 0002EA33		mov		a2,s2
FFFC5C78 00036AB3		mov		a3,s3
FFFC5C7C 0003EB33		mov		a4,s4
FFFC5C80 00000073		ecall
FFFC5C84 000068B3		mov		v1,x0
FFFC5C88 00072083		lw		$ra,[$sp]
FFFC5C8C 00470713		add		$sp,$sp,#4
FFFC5C90 00008067		ret
                        	.err:
FFFC5C94 FFFC6937		ldi		a0,#msgComma
FFFC5C98 E8290913
FFFC5C9C FDCFF06F		jmp		ERROR
                        	.paren:
FFFC5CA0 FFFC6937		ldi		a0,#msgParen
FFFC5CA4 FB790913
FFFC5CA8 FD0FF06F		jmp		ERROR
                        	
                        	;------------------------------------------------------------------------------
                        	; WAITMSG <handle var>, <var for data 1>, <var for data 2>, <var for data 3>,
                        	;		<expr>
                        	;------------------------------------------------------------------------------
                        	
                        	WAITMSG:
FFFC5CAC D39FF0EF		call	TSTC		; else look for ( OREXPR )
FFFC5CB0 00000028		dw		'('
FFFC5CB4 0C000263		bra		.paren
FFFC5CB8 F21FE0EF		call	OREXPR	; get the mailbox handle
FFFC5CBC 00086233		mov		s1,v0
FFFC5CC0 D25FF0EF		call	TSTC		; it must be followed by a comma
FFFC5CC4 0000002C		dw		','
FFFC5CC8 0A000263		bra		.err
FFFC5CCC 00106913		ldi		a0,#1
FFFC5CD0 B48FF0EF		call	TSTV
FFFC5CD4 00081863		bne		v0,x0,.0001
                        	.0002:
FFFC5CD8 FFFC6937		ldi		a0,#msgVar
FFFC5CDC EAA90913
FFFC5CE0 F98FF06F		jmp		ERROR
                        	.0001:
FFFC5CE4 D01FF0EF		call	TSTC		; it must be followed by a comma
FFFC5CE8 0000002C		dw		','
FFFC5CEC 08000063		bra		.err
FFFC5CF0 000862B3		mov		s2,v0
FFFC5CF4 00106913		ldi		a0,#1
FFFC5CF8 B20FF0EF		call	TSTV
FFFC5CFC FC080EE3		beq		v0,x0,.0002
FFFC5D00 CE5FF0EF		call	TSTC		; it must be followed by a comma
FFFC5D04 0000002C		dw		','
FFFC5D08 06000263		bra		.err
FFFC5D0C 00086333		mov		s3,v0
FFFC5D10 00106913		ldi		a0,#1
FFFC5D14 B04FF0EF		call	TSTV
FFFC5D18 FC0800E3		beq		v0,x0,.0002
FFFC5D1C 000863B3		mov		s4,v0
FFFC5D20 CC5FF0EF		call	TSTC		; it must be followed by a comma
FFFC5D24 0000002C		dw		','
FFFC5D28 04000263		bra		.err
FFFC5D2C EADFE0EF		call	OREXPR	; get queue remove flag
FFFC5D30 00086BB3		mov		a5,v0
FFFC5D34 000863B3		mov		s4,v0
FFFC5D38 CADFF0EF		call	TSTC		; else look for ( OREXPR )
FFFC5D3C 00000029		dw		')'
FFFC5D40 02000C63		bra		.paren
FFFC5D44 00A06913		ldi		a0,#10		; WaitMsg
FFFC5D48 000269B3		mov		a1,s1
FFFC5D4C 0002EA33		mov		a2,s2
FFFC5D50 00036AB3		mov		a3,s3
FFFC5D54 0003EB33		mov		a4,s4
FFFC5D58 00000073		ecall
FFFC5D5C 000068B3		mov		v1,x0
FFFC5D60 00072083		lw		$ra,[$sp]
FFFC5D64 00470713		add		$sp,$sp,#4
FFFC5D68 00008067		ret
                        	.err:
FFFC5D6C FFFC6937		ldi		a0,#msgComma
FFFC5D70 E8290913
FFFC5D74 F04FF06F		jmp		ERROR
                        	.paren:
FFFC5D78 FFFC6937		ldi		a0,#msgParen
FFFC5D7C FB790913
FFFC5D80 EF8FF06F		jmp		ERROR
                        	
                        	;*****************************************************
                        	; The following routines are the only ones that need *
                        	; to be changed for a different I/O environment.     *
                        	;*****************************************************
                        	
                        	; ===== Output character to the console (Port 1) from register a0
                        	;	(Preserves all registers.)
                        	;
                        	OUTC:
FFFC5D84 CF8FA06F		jmp		Putch
                        	
                        	; ===== Input a character from the console into register v0 (or
                        	;	return Zero status if there's no character available).
                        	;
                        	INCH:
FFFC5D88 FFC70713		sub 	$sp,$sp,#4
FFFC5D8C 00172023		sw		$ra,[$sp]
FFFC5D90 CC4FA0EF		call	Getch
FFFC5D94 00180813		add		$v0,$v0,#1				; prepare test -1
FFFC5D98 00080A63		beq		$v0,$x0,INCH1			; was = -1
FFFC5D9C FFF80813		sub		$v0,$v0,#1				; get char back
FFFC5DA0 00072083		lw		$ra,[$sp]
FFFC5DA4 00470713		add		$sp,$sp,#4
FFFC5DA8 00008067		ret
                        	INCH1:
FFFC5DAC 00072083		lw		$ra,[$sp]		; return a zero for no-char
FFFC5DB0 00470713		add		$sp,$sp,#4
FFFC5DB4 00008067		ret
                        	
                        	; ===== Return to the resident monitor, operating system, etc.
                        	;
                        	//message "BYEBYE"
                        	BYEBYE:
                        	//	call	ReleaseIOFocus
FFFC5DB8 00030637		lw		$sp,OSSP
FFFC5DBC 00060613
FFFC5DC0 00060633
FFFC5DC4 00062703
FFFC5DC8 D74FA06F		jmp		Monitor
                        	 
                        	
FFFC5DCC 53430A0D	msgInit	db	CR,LINEFD,"CS01 Tiny BASIC v1.0",CR,LINEFD,"(C) 2017-2020  Robert Finch",CR,CR,0
FFFC5DD0 54203130
FFFC5DD4 20796E69
FFFC5DD8 49534142
FFFC5DDC 31762043
FFFC5DE0 0A0D302E
FFFC5DE4 20294328
FFFC5DE8 37313032
FFFC5DEC 3230322D
FFFC5DF0 52202030
FFFC5DF4 7265626F
FFFC5DF8 69462074
FFFC5DFC 0D68636E
FFFC5E00 0A0D000D
FFFC5E02 4B4F0A0D	OKMSG	db	CR,LINEFD,"OK",CR,0
FFFC5E06 6857000D
FFFC5E08 74616857	msgWhat	db	"What?",CR,0
FFFC5E0C 53000D3F
FFFC5E0F 72726F53	SRYMSG	db	"Sorry."
FFFC5E13 000D2E79
FFFC5E15 6F43000D	CLMSG	db	CR,0
FFFC5E17 706D6F43	msgReadError	db	"Compact FLASH read error",CR,0
FFFC5E1B 20746361
FFFC5E1F 53414C46
FFFC5E23 65722048
FFFC5E27 65206461
FFFC5E2B 726F7272
FFFC5E2F 754E000D
FFFC5E31 626D754E	msgNumTooBig	db	"Number is too big",CR,0
FFFC5E35 69207265
FFFC5E39 6F742073
FFFC5E3D 6962206F
FFFC5E41 44000D67
FFFC5E44 69766944	msgDivZero		db	"Division by zero",CR,0
FFFC5E48 6E6F6973
FFFC5E4C 20796220
FFFC5E50 6F72657A
FFFC5E54 754F000D
FFFC5E56 2074754F	msgVarSpace     db  "Out of variable space",CR,0
FFFC5E5A 7620666F
FFFC5E5E 61697261
FFFC5E62 20656C62
FFFC5E66 63617073
FFFC5E6A 20000D65
FFFC5E6D 74796220	msgBytesFree	db	" bytes free",CR,0
FFFC5E71 66207365
FFFC5E75 0D656572
FFFC5E79 65520D00
FFFC5E7A 6165520D	msgReady		db	CR,"Ready",CR,0
FFFC5E7E 000D7964
FFFC5E82 65707845	msgComma		db	"Expecting a comma",CR,0
FFFC5E86 6E697463
FFFC5E8A 20612067
FFFC5E8E 6D6D6F63
FFFC5E92 4C000D61
FFFC5E95 656E694C	msgLineRange	db	"Line number too big",CR,0
FFFC5E99 6D756E20
FFFC5E9D 20726562
FFFC5EA1 206F6F74
FFFC5EA5 0D676962
FFFC5EA9 70784500
FFFC5EAA 65707845	msgVar			db "Expecting a variable",CR,0
FFFC5EAE 6E697463
FFFC5EB2 20612067
FFFC5EB6 69726176
FFFC5EBA 656C6261
FFFC5EBE 4E52000D
FFFC5EC0 20444E52	msgRNDBad		db	"RND bad parameter",CR,0
FFFC5EC4 20646162
FFFC5EC8 61726170
FFFC5ECC 6574656D
FFFC5ED0 53000D72
FFFC5ED3 20535953	msgSYSBad		db	"SYS bad address",CR,0
FFFC5ED7 20646162
FFFC5EDB 72646461
FFFC5EDF 0D737365
FFFC5EE3 504E4900
FFFC5EE4 55504E49	msgInputVar		db	"INPUT expecting a variable",CR,0
FFFC5EE8 78652054
FFFC5EEC 74636570
FFFC5EF0 20676E69
FFFC5EF4 61762061
FFFC5EF8 62616972
FFFC5EFC 000D656C
FFFC5F00 5458454E	msgNextFor		db	"NEXT without FOR",CR,0
FFFC5F04 74697720
FFFC5F08 74756F68
FFFC5F0C 524F4620
FFFC5F10 454E000D
FFFC5F12 5458454E	msgNextVar		db	"NEXT expecting a defined variable",CR,0
FFFC5F16 70786520
FFFC5F1A 69746365
FFFC5F1E 6120676E
FFFC5F22 66656420
FFFC5F26 64656E69
FFFC5F2A 72617620
FFFC5F2E 6C626169
FFFC5F32 47000D65
FFFC5F35 4F544F47	msgBadGotoGosub	db	"GOTO/GOSUB bad line number",CR,0
FFFC5F39 534F472F
FFFC5F3D 62204255
FFFC5F41 6C206461
FFFC5F45 20656E69
FFFC5F49 626D756E
FFFC5F4D 000D7265
FFFC5F51 55544552	msgRetWoGosub   db	"RETURN without GOSUB",CR,0
FFFC5F55 77204E52
FFFC5F59 6F687469
FFFC5F5D 47207475
FFFC5F61 4255534F
FFFC5F65 7250000D
FFFC5F67 676F7250	msgTooBig		db	"Program is too big",CR,0
FFFC5F6B 206D6172
FFFC5F6F 74207369
FFFC5F73 62206F6F
FFFC5F77 000D6769
FFFC5F7B 72747845	msgExtraChars	db	"Extra characters on line ignored",CR,0
FFFC5F7F 68632061
FFFC5F83 63617261
FFFC5F87 73726574
FFFC5F8B 206E6F20
FFFC5F8F 656E696C
FFFC5F93 6E676920
FFFC5F97 6465726F
FFFC5F9B 4520000D
FFFC5F9D 766E4520	msgEnvFail		db	" Environment call failed",CR,0
FFFC5FA1 6E6F7269
FFFC5FA5 746E656D
FFFC5FA9 6C616320
FFFC5FAD 6166206C
FFFC5FB1 64656C69
FFFC5FB5 7845000D
FFFC5FB7 65707845	msgParen		db	"Expecting parenthesis",CR,0
FFFC5FBB 6E697463
FFFC5FBF 61702067
FFFC5FC3 746E6572
FFFC5FC7 69736568
FFFC5FCB 00000D73
                        	
                        	LSTROM	equ	*		; end of possible ROM area
;	END
                        	
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	.file "boot.r5a",1
                        	
                        		rodata
                        		align 8                        	
                        	begin_init_data:
                        	_begin_init_data:
                        	
                        		rodata
                        		align 8                        	
                        	end_init_data:
                        	_end_init_data:
1051 symbols
  Symbol Name                              seg     address bits
  ABS                                        code  fffc52dc 18
  ABS1                                       code  fffc52f0 18
  ADDEXPR                                    code  fffc4e54 18
  ALLOCMBX                                   code  fffc5ba0 18
  ALLOCMBX.0001                              code  fffc5bc4 18
  ALLOCMBX.0002                              code  fffc5bf4 18
  ALLOCMBX.paren                             code  fffc5c04 18
  ANDEXPR                                    code  fffc4c40 18
  AUXIN                                      code  80000000000002b9 32
  AUXIN_INIT                                 code  8000000000000377 32
  AUXOCRLF                                   code  fffc4a80 18
  AUXOUT                                     code  80000000000002b7 32
  AUXOUT_FLUSH                               code  8000000000000384 32
  AUXOUT_INIT                                code  800000000000037b 32
  Alloc                                      code  fffc0f18 18
  Alloc.0001                                 code  fffc0f94 18
  Alloc.enough                               code  fffc0f58 18
  Alloc.noRun                                code  fffc0fb8 18
  Alloc.noRun2                               code  fffc0f50 18
  Alloc.xit                                  code  fffc0fbc 18
  AllocStack                                 code  fffc0fd4 18
  AllocStack.0001                            code  fffc0ff8 18
  AllocStack.xit                             code  fffc100c 18
  AllocTCB                                   code  fffc2e20 18
  AllocTCB.0001                              code  fffc2e34 18
  AllocTCB.0002                              code  fffc2e6c 18
  AllocTCB.0003                              code  fffc2e7c 18
  AllocTCB.allocTid                          code  fffc2e60 18
  BASPRMPT                                   code  fffc3d64 18
  BIOSCallTbl                                code  fffc0df0 18
  BIOS_ClearScreen                           code  fffc0df8 18
  BIOS_HomeCursor                            code  fffc0dfc 18
  BIOS_VideoPutChar                          code  fffc0e00 18
  BS                                        const  000008 5
  BUFFER                                    const  03001c 19
  BUFLEN                                    const  000054 8
  BYEBYE                                     code  fffc5db8 18
  CHKIO                                      code  fffc5b58 18
  CHKRET                                     code  fffc5b74 18
  CLMSG                                      code  fffc5e15 18
  CR                                        const  00000d 5
  CRLF                                       code  fffc5b80 18
  CSR_REGSET                                const  000790 12
  CSTART                                     code  fffc3c30 32
  CTRLC                                     const  000003 3
  CTRLH                                     const  000008 5
  CTRLI                                     const  000009 5
  CTRLJ                                     const  00000a 5
  CTRLK                                     const  00000b 5
  CTRLM                                     const  00000d 5
  CTRLS                                     const  000013 6
  CTRLX                                     const  000018 6
  CURRNT                                    const  030018 19
  CopyDevFuncTbl                             code  fffc3378 18
  CopyDevFuncTbl.again                       code  fffc338c 18
  CursorFlash                               const  0300b0 19
  CursorX                                   const  024800 19
  CursorY                                   const  024801 19
  DCB_LastErc                               const  000018 6
  DCB_Mbx                                   const  000048 8
  DCB_Name                                  const  000000 1
  DCB_ReentCount                            const  000038 7
  DCB_Resv1                                 const  000058 8
  DCB_Resv2                                 const  000060 8
  DCB_Size                                  const  000068 8
  DCB_StartBlock                            const  000020 7
  DCB_Type                                  const  00000c 5
  DCB_fSingleUser                           const  000039 7
  DCB_hJob                                  const  000040 8
  DCB_nBPB                                  const  000010 6
  DCB_nBlocks                               const  000028 7
  DCB_pCmdProc                              const  000030 7
  DCB_pSema                                 const  000050 8
  DEFLT                                      code  fffc47c8 18
  DEL                                       const  00007f 8
  DIRECT                                     code  fffc4060 18
  DOQUO                                      code  fffc5b18 18
  DOQUO1                                     code  fffc5b24 18
  DRSP_DONE                                 const  000001 2
  DVC_BuildBPB                              const  000005 4
  DVC_Close                                 const  000007 4
  DVC_FlushInput                            const  000014 6
  DVC_FlushOutput                           const  000015 6
  DVC_GetChar                               const  000008 5
  DVC_GetCharDirect                         const  00000a 5
  DVC_IOCTRL_READ                           const  000018 6
  DVC_IOCTRL_WRITE                          const  000019 6
  DVC_IRQ                                   const  000016 6
  DVC_Initialize                            const  000002 3
  DVC_InputStatus                           const  00000c 5
  DVC_IsRemoveable                          const  000017 6
  DVC_MediaCheck                            const  000004 4
  DVC_Nop                                   const  000000 1
  DVC_Open                                  const  000006 4
  DVC_OutputStatus                          const  000013 6
  DVC_OutputUntilBusy                       const  00001a 6
  DVC_PeekChar                              const  000009 5
  DVC_PeekCharDirect                        const  00000b 5
  DVC_PutChar                               const  00000d 5
  DVC_ReadBlock                             const  000010 6
  DVC_SetPosition                           const  00000f 5
  DVC_Setup                                 const  000001 2
  DVC_Status                                const  000003 3
  DVC_VerifyBlock                           const  000012 6
  DVC_WriteBlock                            const  000011 6
  DVF_Base                                  const  022000 19
  DVF_Limit                                 const  024000 19
  DeleteLine                                 code  fffc3e1c 18
  DeleteLine.0001                            code  fffc3e48 18
  DeleteLine.0002                            code  fffc3e34 18
  DeleteLine.0003                            code  fffc3e4c 18
  DispAttr                                  const  024808 19
  DumpReadyList                              code  fffc2ecc 18
  DumpReadyList.0001                         code  fffc2f48 18
  DumpReadyList.0002                         code  fffc2f04 18
  DumpReadyList.brk                          code  fffc2f90 18
  DumpReadyList.nxt                          code  fffc2f84 18
  DumpTimeoutList                            code  fffc2fbc 18
  DumpTimeoutList.0002                       code  fffc2ff8 18
  DumpTimeoutList.brk                        code  fffc3030 18
  ENDCHK                                     code  fffc5428 18
  ENDMEM                                    const  03fffc 19
  ERETx                                      code  800000000000022b 32
  ERROR                                      code  fffc5478 18
  ERROR1                                     code  fffc54d0 18
  EX1                                        code  fffc40ac 18
  EXEC                                       code  fffc4070 18
  EXGO                                       code  fffc40d4 18
  EXLP                                       code  fffc407c 18
  EXMAT                                      code  fffc40c0 18
  EXNGO                                      code  fffc4094 18
  EXPR                                       code  fffc4d30 18
  E_Arg                                     const  000001 2
  E_BadAlarm                                const  000011 6
  E_BadBlockNum                             const  000025 7
  E_BadCallno                               const  00001a 6
  E_BadDevNum                               const  000020 7
  E_BadDevOp                                const  000022 7
  E_BadMbx                                  const  000004 4
  E_DCBInUse                                const  000019 6
  E_NoDev                                   const  000021 7
  E_NoMem                                   const  00000c 5
  E_NoMoreAlarmBlks                         const  000044 8
  E_NoMoreMbx                               const  000040 8
  E_NoMoreMsgBlks                           const  000041 8
  E_NoMoreTCBs                              const  000045 8
  E_NoMsg                                   const  00000b 5
  E_NoThread                                const  000006 4
  E_NotAlloc                                const  000009 5
  E_NotOwner                                const  000012 6
  E_Ok                                      const  000000 1
  E_QueFull                                 const  000005 4
  E_QueStrategy                             const  000013 6
  E_ReadError                               const  000023 7
  E_Timeout                                 const  000010 6
  E_TooManyBlocks                           const  000026 7
  E_WriteError                              const  000024 7
  EditMem                                    code  fffc0628 18
  FI1                                        code  fffc5408 18
  FI2                                        code  fffc541c 18
  FILEBUF                                   const  03f600 19
  FILENAME                                  const  03f6c0 19
  FIN                                        code  fffc53ec 18
  FINISH                                     code  fffc43f8 18
  FMTKInit                                   code  fffc1d5c 18
  FMTKInit.0001                              code  fffc1e28 18
  FMTKInit.0002                              code  fffc1e5c 18
  FMTKInit.0003                              code  fffc1e0c 18
  FMTK_AllocMbx                              code  fffc27d8 18
  FMTK_AllocMbx.badArg                       code  fffc283c 18
  FMTK_AllocMbx.noOwner                      code  fffc2810 18
  FMTK_AllocMbx.nxt                          code  fffc27f0 18
  FMTK_AllocMbx.xit                          code  fffc2840 18
  FMTK_AllocVideoBuf                         code  fffc2744 18
  FMTK_AllocVideoBuf.err                     code  fffc2774 18
  FMTK_ExitTask                              code  fffc26a8 18
  FMTK_ExitTask.xit                          code  fffc26c8 18
  FMTK_ForceReleaseIOFocus                   code  fffc3278 18
  FMTK_ForceReleaseIOFocus.0001              code  fffc331c 18
  FMTK_ForceReleaseIOFocus.done              code  fffc3328 18
  FMTK_ForceReleaseIOFocus.noFocus           code  fffc3328 18
  FMTK_ForceReleaseIOFocus.notSame           code  fffc32e8 18
  FMTK_ForceReleaseIOFocus.pjSame            code  fffc3308 18
  FMTK_FreeMbx                               code  fffc284c 18
  FMTK_FreeMbx.0001                          code  fffc28b8 18
  FMTK_FreeMbx.0002                          code  fffc287c 18
  FMTK_FreeMbx.0003                          code  fffc28a8 18
  FMTK_FreeMbx.badMbx                        code  fffc28cc 18
  FMTK_FreeMbx.xit                           code  fffc28d0 18
  FMTK_GetCurrentTid                         code  fffc1e94 18
  FMTK_HasIOFocus                            code  fffc30bc 18
  FMTK_HasIOFocus.hasFocus                   code  fffc3110 18
  FMTK_HasIOFocus.noSwitch                   code  fffc30e8 18
  FMTK_HasIOFocus.xit                        code  fffc3114 18
  FMTK_IO                                    code  fffc3330 18
  FMTK_IO.badDev                             code  fffc3370 18
  FMTK_IO.badFunc                            code  fffc3368 18
  FMTK_IO.xit                                code  fffc3364 18
  FMTK_Initialize                            code  80000000000001ad 32
  FMTK_KillTask                              code  fffc26d4 18
  FMTK_KillTask.immortal                     code  fffc2734 18
  FMTK_KillTask.xit                          code  fffc2738 18
  FMTK_PeekMsg                               code  fffc29ec 18
  FMTK_PeekMsg.badMbx                        code  fffc2aac 18
  FMTK_PeekMsg.noMsg                         code  fffc2aa4 18
  FMTK_PeekMsg.nod1                          code  fffc2a74 18
  FMTK_PeekMsg.nod2                          code  fffc2a88 18
  FMTK_PeekMsg.nod3                          code  fffc2a9c 18
  FMTK_PeekMsg.nodq                          code  fffc2a54 18
  FMTK_PeekMsg.ret                           code  fffc2ab0 18
  FMTK_PostMsg                               code  80000000000001b5 32
  FMTK_ReleaseIOFocus                        code  fffc326c 18
  FMTK_RequestIOFocus                        code  fffc31e0 18
  FMTK_RequestIOFocus.notEmpty               code  fffc324c 18
  FMTK_RequestIOFocus.ret                    code  fffc3264 18
  FMTK_SaveContext                           code  fffc1f48 18
  FMTK_SchedulerIRQ                          code  fffc23fc 18
  FMTK_SchedulerIRQ.0001                     code  fffc2468 18
  FMTK_SchedulerIRQ.0002                     code  fffc2548 18
  FMTK_SchedulerIRQ.0003                     code  fffc2560 18
  FMTK_SchedulerIRQ.0004                     code  fffc2578 18
  FMTK_SchedulerIRQ.doSchedule               code  fffc240c 18
  FMTK_SchedulerIRQ.dq                       code  fffc2504 18
  FMTK_SchedulerIRQ.goodTid                  code  fffc2504 18
  FMTK_SchedulerIRQ.noException              code  fffc251c 18
  FMTK_SchedulerIRQ.noLock                   code  fffc259c 18
  FMTK_SchedulerIRQ.noMsg                    code  fffc2580 18
  FMTK_SchedulerIRQ.noTimeout                code  fffc249c 18
  FMTK_SchedulerIRQ.notZero                  code  fffc249c 18
  FMTK_SchedulerIRQ.nxtQ                     code  fffc24e4 18
  FMTK_SchedulerIRQ.searchQ                  code  fffc24a8 18
  FMTK_SendMsg                               code  fffc28dc 18
  FMTK_SendMsg.0001                          code  fffc290c 18
  FMTK_SendMsg.badMbx                        code  fffc29dc 18
  FMTK_SendMsg.mbxEmpty                      code  fffc29c4 18
  FMTK_SendMsg.noMsg                         code  fffc29d4 18
  FMTK_SendMsg.noWaiters                     code  fffc296c 18
  FMTK_SendMsg.nxtTid                        code  fffc2950 18
  FMTK_SendMsg.xit                           code  fffc29e0 18
  FMTK_SetTaskPriority                       code  80000000000001b1 32
  FMTK_Sleep                                 code  fffc22f4 18
  FMTK_Sleep.0001                            code  fffc2330 18
  FMTK_Sleep.0002                            code  fffc23a4 18
  FMTK_Sleep.0003                            code  fffc23bc 18
  FMTK_Sleep.0004                            code  fffc23d4 18
  FMTK_Sleep.noException                     code  fffc237c 18
  FMTK_Sleep.noMsg                           code  fffc23dc 18
  FMTK_Sleep.xit                             code  fffc23f0 18
  FMTK_StartApp                              code  80000000000001b9 32
  FMTK_StartTask                             code  fffc25b8 18
  FMTK_StartTask.err                         code  fffc269c 18
  FMTK_StartTask.xit                         code  fffc269c 18
  FMTK_SwitchIOFocus                         code  fffc311c 18
  FMTK_SwitchIOFocus.0001                    code  fffc316c 18
  FMTK_SwitchIOFocus.0002                    code  fffc3184 18
  FMTK_SwitchIOFocus.0003                    code  fffc31a8 18
  FMTK_SwitchIOFocus.0004                    code  fffc31c0 18
  FMTK_SwitchIOFocus.noFocus                 code  fffc31d0 18
  FMTK_SwitchIOFocus.sameFocus               code  fffc31d0 18
  FMTK_WaitMsg                               code  fffc2abc 18
  FMTK_WaitMsg.qt                            code  fffc2ae0 18
  FMTK_WaitMsg.xit                           code  fffc2b34 18
  FNDLN                                      code  fffc55e0 18
  FNDLNP                                     code  fffc5600 18
  FNDNXT                                     code  fffc5668 18
  FNDRET                                     code  fffc563c 18
  FNDRET.0001                                code  fffc5640 18
  FNDRET1                                    code  fffc5658 18
  FNDRET2                                    code  fffc5660 18
  FNDSKP                                     code  fffc566c 18
  FOR                                        code  fffc44dc 18
  FORCEFIT                                   code  fffc4d08 18
  FORCEFIT.0001                              code  fffc4d2c 18
  FORCEFIT.intAnd                            code  fffc4d1c 18
  FR1                                        code  fffc4508 18
  FR2                                        code  fffc4530 18
  FR3                                        code  fffc4538 18
  FR4                                        code  fffc453c 18
  FR5                                        code  fffc454c 18
  FR6                                        code  fffc4594 18
  FR7                                        code  fffc4598 18
  FR8                                        code  fffc45b8 18
  FUNCEXPR                                   code  fffc4f88 18
  FillMem                                    code  fffc0640 18
  FillMem.0001                               code  fffc065c 18
  FindRun                                    code  fffc0eb4 18
  FindRun.0001                               code  fffc0ed4 18
  FindRun.0002                               code  fffc0ee4 18
  FindRun.empty0                             code  fffc0eec 18
  FindRun.empty1                             code  fffc0ef0 18
  FindRun.foundEnough                        code  fffc0f10 18
  FreeAll                                    code  fffc1010 18
  FreeAll.0001                               code  fffc1070 18
  FreeAll.nxt                                code  fffc1018 18
  FreeMsg                                   const  024350 19
  FreeTCB                                    code  fffc2e98 18
  GCHAR                                      code  fffc4858 18
  GCHAR1                                     code  fffc4870 18
  GETLN                                      code  fffc54d4 18
  GETLN.GL1                                  code  fffc54f8 18
  GETLN.GL2                                  code  fffc5520 18
  GETLN.GL3                                  code  fffc5554 18
  GETLN.GL4                                  code  fffc5580 18
  GETLN.GL5                                  code  fffc5598 18
  GETLN.GL6                                  code  fffc55b8 18
  GETLN.GL7                                  code  fffc55c4 18
  GOAUXI                                     code  fffc3c18 18
  GOAUXO                                     code  fffc3c10 18
  GOBYE                                      code  fffc3c20 18
  GOIN                                       code  fffc3c0c 18
  GOOUT                                      code  fffc3c08 18
  GOSTART                                    code  fffc3c00 18
  GOSUB                                      code  fffc4400 18
  GOTO                                       code  fffc4240 18
  GOWARM                                     code  fffc3c04 18
  GetBuflen                                  code  fffc3e9c 18
  GetBuflen.0001                             code  fffc3ec4 18
  GetBuflen.0002                             code  fffc3ea8 18
  GetBuflen.0004                             code  fffc3ec0 18
  GetCurrentTid                              code  fffc1e88 18
  GetFilename                                code  fffc48bc 18
  GetHexNum                                  code  fffc0698 18
  GetHexNum.0001                             code  fffc06e8 18
  GetHexNum.isDigit                          code  fffc0724 18
  GetHexNum.isHexLower                       code  fffc070c 18
  GetHexNum.isHexUpper                       code  fffc06f4 18
  GetHexNum.next                             code  fffc06a8 18
  Getch                                      code  fffc0254 18
  IF0                                        code  fffc467c 18
  IF1                                        code  fffc4680 18
  IF2                                        code  fffc4688 18
  IF3                                        code  fffc469c 18
  IGB1                                       code  fffc5ac0 18
  IGB2                                       code  fffc5aac 18
  IGBRET                                     code  fffc5ac8 18
  IGNBLK                                     code  fffc5aa4 18
  INBUF                                     const  014100 18
  INCH                                       code  fffc5d88 18
  INCH1                                      code  fffc5dac 18
  INPERR                                     code  fffc46a0 18
  INPPTR                                    const  0300ac 19
  INPUT                                      code  fffc46d4 18
  INSLINE                                    code  fffc3ddc 18
  INSLINE.0001                               code  fffc3e08 18
  IOF_NEXT                                  const  0002e8 11
  IOF_PREV                                  const  0002f0 11
  IOFocusNdx                                const  024810 19
  IOFocusTbl                                const  024818 19
  IP2                                        code  fffc46fc 18
  IP3                                        code  fffc4738 18
  IP4                                        code  fffc47ac 18
  IP5                                        code  fffc47bc 18
  IP6                                        code  fffc46dc 18
  IP7                                        code  fffc471c 18
  IRQFlag                                   const  0300b4 19
  IRQROUT                                   const  0300a4 19
  IRQRout                                    code  fffc0858 18
  IRQRout.cause0to7                          code  fffc091c 18
  IRQRout.cause12plus                        code  fffc091c 18
  IRQRout.doIRQ                              code  fffc08c4 18
  IRQRout.isIRQ                              code  fffc0890 18
  IRQRout.noIRQ                              code  fffc08e4 18
  IdleTask                                   code  fffc0250 18
  InsertIntoReadyList                        code  fffc2b40 18
  InsertIntoReadyList.0001                   code  fffc2bd4 18
  InsertIntoReadyList.badTid                 code  fffc2bdc 18
  InsertIntoReadyList.insert                 code  fffc2ba0 18
  InsertIntoReadyList.level2                 code  fffc2bc0 18
  InsertIntoTimeoutList                      code  fffc2c9c 18
  InsertIntoTimeoutList.0001                 code  fffc2cf4 18
  InsertIntoTimeoutList.0002                 code  fffc2d5c 18
  InsertIntoTimeoutList.0003                 code  fffc2d6c 18
  InsertIntoTimeoutList.beginWhile           code  fffc2d00 18
  InsertIntoTimeoutList.endOfList            code  fffc2d20 18
  InsertIntoTimeoutList.endWhile             code  fffc2d30 18
  InsertLine                                 code  fffc3e7c 18
  InsertLine.0001                            code  fffc3e80 18
  InsertLine.done                            code  fffc3e98 18
  KEYBD                                      code  800000000000026a 32
  KeybdFuncTbl                               code  fffc36a8 18
  KeybdIRQ                                   code  fffc3a84 18
  KeybdIRQ.0001                              code  fffc3b10 18
  KeybdIRQ.noRoom                            code  fffc3ac0 18
  KeybdIRQ.notAlt                            code  8000000000000284 32
  KeybdIRQ.notAltTab                         code  fffc3b30 18
  KeybdIRQ.notCtrl                           code  fffc3b10 18
  KeybdIRQ.notCtrlC                          code  fffc3aec 18
  KeybdIRQ.notCtrlZ                          code  fffc3b10 18
  KeybdIRQ.notKbd                            code  fffc3b6c 18
  KillTask                                   code  80000000000001f9 32
  LEDS                                      const  ffdc0600 33
  LET                                        code  fffc47d4 18
  LINEFD                                    const  00000a 5
  LISTX                                      code  fffc430c 18
  LOAD                                       code  fffc47ec 18
  LOAD3                                      code  fffc4940 18
  LOAD4                                      code  fffc496c 18
  LOAD5                                      code  fffc49a4 18
  LOD1                                       code  fffc47fc 18
  LOD2                                       code  fffc4828 18
  LODEND                                     code  fffc4844 18
  LOG_MBXSZ                                 const  000005 4
  LOG_MSGSZ                                 const  000005 4
  LOG_PGSZ                                  const  000010 6
  LOG_TCBSZ                                 const  00000a 5
  LOPINC                                    const  030078 19
  LOPLMT                                    const  03007c 19
  LOPLN                                     const  030074 19
  LOPPT                                     const  030070 19
  LOPVAR                                    const  030010 19
  LS1                                        code  fffc4320 18
  LS2                                        code  fffc4354 18
  LS3                                        code  fffc435c 18
  LS4                                        code  fffc4338 18
  LS5                                        code  fffc4324 18
  LSTROM                                    const  000000 1
  LT1                                        code  fffc47e8 18
  LoadWord                                   code  fffc595c 18
  MAX_DEV_OP                                const  00001f 6
  MAX_TID                                   const  00003f 7
  MBX_MQHEAD                                const  000010 6
  MBX_MQTAIL                                const  000018 6
  MBX_OWNER                                 const  000000 1
  MBX_SIZE                                  const  000020 7
  MBX_WTIDS                                 const  000008 5
  MMUInit                                    code  fffc0e04 18
  MMUInit.0001                               code  fffc0e3c 18
  MMUInit.0002                               code  fffc0e98 18
  MMUInit.0003                               code  fffc0e58 18
  MMUInit.0004                               code  fffc0e2c 18
  MMUInit.0006                               code  fffc0e70 18
  MSG_D1                                    const  000008 5
  MSG_D2                                    const  000010 6
  MSG_D3                                    const  000018 6
  MSG_LINK                                  const  000000 1
  MSG_SIZE                                  const  000020 7
  MULEXPR                                    code  fffc4eec 18
  MVDOWN                                     code  fffc56a8 18
  MVDOWN1                                    code  fffc5698 18
  MVUP                                       code  fffc5690 18
  MVUP1                                      code  fffc5680 18
  MachineStart                               code  fffc0100 18
  MapOSPages                                 code  fffc1eac 18
  MapOSPages.nxt                             code  fffc1eb8 18
  MbxRemoveTask                              code  fffc2778 18
  MbxRemoveTask.xit                          code  fffc27c0 18
  MonEntry                                   code  fffc0334 18
  Monitor                                    code  fffc033c 18
  Monitor.0001                               code  fffc0368 18
  Monitor.0002                               code  fffc03b8 18
  Monitor.0003                               code  fffc041c 18
  Monitor.0004                               code  fffc04a4 18
  Monitor.0005                               code  fffc059c 18
  Monitor.0006                               code  fffc0508 18
  Monitor.0007                               code  fffc0538 18
  Monitor.0008                               code  fffc0544 18
  Monitor.0009                               code  fffc0550 18
  Monitor.0010                               code  fffc0568 18
  Monitor.0011                               code  fffc0584 18
  Monitor.0012                               code  fffc059c 18
  Monitor.doBackspace                        code  fffc0408 18
  Monitor.doDelete                           code  fffc03b0 18
  Monitor.noT                                code  fffc0530 18
  Monitor.procLine                           code  fffc046c 18
  Monitor.skip                               code  fffc0480 18
  Monitor.skip2                              code  fffc049c 18
  NEW                                        code  fffc40e8 18
  NEXT                                       code  fffc45bc 18
  NPAGES                                    const  024828 19
  NR_DCB                                    const  000020 7
  NR_MBX                                    const  000100 10
  NR_MSG                                    const  000800 13
  NR_TCB                                    const  000040 8
  NUMWKA                                    const  030094 19
  NX0                                        code  fffc45d8 18
  NX1                                        code  fffc463c 18
  NX2                                        code  fffc4604 18
  NX3                                        code  fffc4640 18
  NX4                                        code  fffc45d4 18
  NX5                                        code  fffc45f8 18
  NXPurge                                    code  fffc4674 18
  OKMSG                                      code  fffc5e02 18
  ONIRQ                                      code  fffc42b0 18
  ONIRQ1                                     code  fffc42dc 18
  OREXPR                                     code  fffc4bd8 18
  OSCALL                                     code  fffc2250 18
  OSCALL.oscall                              code  fffc22a8 18
  OSCALL.xit                                 code  fffc22d8 18
  OSCALL.zero                                code  fffc22ec 18
  OSCallTbl                                  code  fffc1d04 18
  OSPAGES                                   const  000003 3
  OSSP                                      const  030000 19
  OUTC                                       code  fffc5d84 18
  OUTPTR                                    const  0300a8 19
  OpenSpace                                  code  fffc3ec8 18
  OpenSpace.0003                             code  fffc3f04 18
  OpenSpace.noSpace                          code  fffc3f20 18
  PAGESZ                                    const  010000 18
  PAGES_PER_TASK                            const  001000 14
  PARN                                       code  fffc4fd8 18
  PEEK                                       code  fffc51ec 18
  PEEKH                                      code  fffc521c 18
  PEEKW                                      code  fffc5204 18
  PIC                                       const  ffdc0f00 33
  PIC_CH16                                  const  0000c0 9
  PIC_CH28                                  const  0000f0 9
  PIC_CH31                                  const  0000fc 9
  PIDMAP                                    const  024310 19
  PKER                                       code  fffc4ba0 18
  POKE                                       code  fffc4b1c 18
  POKEH                                      code  fffc4b74 18
  POKEW                                      code  fffc4b48 18
  POPA_                                      code  fffc56b0 18
  PP1                                        code  fffc5720 18
  PR0                                        code  fffc438c 18
  PR1                                        code  fffc43a4 18
  PR2                                        code  fffc4378 18
  PR3                                        code  fffc43c4 18
  PR4                                        code  fffc43bc 18
  PR6                                        code  fffc43d8 18
  PR8                                        code  fffc43e0 18
  PRINT                                      code  fffc4360 18
  PRMESG                                     code  fffc5b88 18
  PRTLN                                      code  fffc5988 18
  PRTNUM                                     code  fffc58ac 32
  PRTNUM.PN1                                 code  fffc58e4 18
  PRTNUM.PN2                                 code  fffc58e0 18
  PRTNUM.PN3                                 code  fffc590c 18
  PRTNUM.PN4                                 code  fffc591c 18
  PRTNUM.PN5                                 code  fffc5928 18
  PRTNUM.PN6                                 code  fffc5930 18
  PRTNUM.PN7                                 code  fffc58f4 18
  PRTSTG                                     code  fffc57b0 18
  PRTSTG.PRTRET                              code  fffc57f4 18
  PRTSTG.PS1                                 code  fffc57d0 18
  PU1                                        code  fffc57a4 18
  PUSHA_                                     code  fffc5724 18
  PWORD                                      code  fffc4aa4 18
  PicInit                                    code  fffc10b0 18
  PutHexByte                                 code  fffc0798 18
  PutHexDword                                code  fffc0738 18
  PutHexHalf                                 code  fffc0778 18
  PutHexNybble                               code  fffc07b8 18
  PutHexNybble.0001                          code  fffc07e8 18
  PutHexNybble.lt10                          code  fffc07e0 18
  PutHexWord                                 code  fffc0758 18
  PutString                                  code  fffc07f8 18
  PutString.0001                             code  fffc0808 18
  PutString.done                             code  fffc081c 18
  Putch                                      code  fffc027c 18
  QNDX                                      const  024304 19
  QSORRY                                     code  fffc5464 18
  QT1                                        code  fffc5830 18
  QT2                                        code  fffc5870 18
  QT3                                        code  fffc5848 18
  QT4                                        code  fffc585c 18
  QT5                                        code  fffc587c 18
  QTSTG                                      code  fffc5818 18
  QWHAT                                      code  fffc5470 18
  RDYQ0                                     const  024400 19
  RDYQ1                                     const  024500 19
  RDYQ2                                     const  024600 19
  RDYQ3                                     const  024700 19
  READYQ                                    const  024308 19
  RETURN                                     code  fffc4474 18
  RND                                        code  fffc5280 18
  RUN                                        code  fffc411c 18
  RUN1                                       code  fffc41f4 18
  RUN2                                       code  fffc4150 18
  RUN3                                       code  fffc4154 18
  RUNNXL                                     code  fffc413c 18
  RUNSML                                     code  fffc4228 18
  RUNTSL                                     code  fffc4214 18
  RemoveFromReadyList                        code  fffc2be4 18
  RemoveFromReadyList.tidOk                  code  fffc2bf8 18
  RemoveFromReadyList2                       code  fffc2c10 18
  RemoveFromReadyList2.0001                  code  fffc2c64 18
  RemoveFromReadyList2.0002                  code  fffc2c80 18
  RemoveFromReadyList2.0003                  code  fffc2c54 18
  RemoveFromReadyList2.badTid                code  fffc2c94 18
  RemoveFromTimeoutList                      code  fffc2d80 18
  RemoveFromTimeoutList.0001                 code  fffc2dd0 18
  RemoveFromTimeoutList.noNext               code  fffc2df0 18
  RemoveFromTimeoutList.noPrev               code  fffc2e04 18
  RemoveFromTimeoutList.noWait               code  fffc2d94 18
  RestoreContext                             code  fffc2014 18
  RestoreContext.rsseg                       code  fffc2024 18
  SAVE                                       code  fffc4a14 18
  SAVE1                                      code  fffc4a2c 18
  SAVE2                                      code  fffc4a48 18
  SAVE3                                      code  fffc49a8 18
  SAVE4                                      code  fffc49d8 18
  SAVEND                                     code  fffc4a60 18
  SC_C                                      const  000021 7
  SC_TAB                                    const  00000d 5
  SC_Z                                      const  00001a 6
  SDReadSector                               code  8000000000000378 32
  SDWriteSector                              code  800000000000037d 32
  SENDMSG                                    code  fffc5c10 18
  SENDMSG.err                                code  fffc5c94 18
  SENDMSG.paren                              code  fffc5ca0 18
  SETVAL                                     code  fffc5384 18
  SETVAL.sv2                                 code  fffc53a8 18
  SGN                                        code  fffc5314 18
  SGN1                                       code  fffc5344 18
  SGN2                                       code  fffc5334 18
  SIZEX                                      code  fffc5350 18
  SRYMSG                                     code  fffc5e0f 18
  ST2                                        code  fffc3db8 18
  STACKOFFS                                 const  afffc000 33
  STKBOT                                    const  03009c 19
  STKGOS                                    const  030014 19
  STKINP                                    const  030098 19
  STOP                                       code  fffc4108 18
  STRTMP                                    const  000200 11
  SV1                                        code  fffc53e4 18
  SYSX                                       code  fffc4bac 18
  SaveContext                                code  fffc1f54 18
  SaveContext.svseg                          code  fffc1fec 18
  SaveContext.xit                            code  fffc2010 18
  SelectTaskToRun                            code  fffc1ecc 18
  SelectTaskToRun.0001                       code  fffc1f14 18
  SelectTaskToRun.dq                         code  fffc1f3c 18
  SelectTaskToRun.goodTid                    code  fffc1f3c 18
  SelectTaskToRun.nxtQ                       code  fffc1f0c 18
  SelectTaskToRun.searchQ                    code  fffc1ecc 18
  SerHeadRcv                                const  025800 19
  SerHeadXmit                               const  025808 19
  SerRcvBuf                                 const  025000 19
  SerRcvXoff                                const  025811 19
  SerRcvXon                                 const  025810 19
  SerTailRcv                                const  025804 19
  SerTailXmit                               const  02580c 19
  SerXmitBuf                                const  025400 19
  SerialFinishCmd                            code  fffc1314 18
  SerialFinishCmd.0001                       code  fffc1338 18
  SerialFuncTbl                              code  fffc10e0 18
  SerialGetChar                              code  fffc133c 18
  SerialGetChar.0001                         code  fffc13f0 18
  SerialGetChar.0002                         code  fffc13a4 18
  SerialGetChar.noChars                      code  fffc13f0 18
  SerialGetChar.xit                          code  fffc13f4 18
  SerialIRQ                                  code  fffc1584 18
  SerialIRQ.0001                             code  fffc1634 18
  SerialIRQ.notRxInt                         code  fffc1648 18
  SerialIRQ.nxtByte                          code  fffc1584 18
  SerialIRQ.rxFull                           code  fffc1648 18
  SerialInit                                 code  fffc11e0 18
  SerialPeekChar                             code  fffc140c 18
  SerialPeekChar.0001                        code  fffc1458 18
  SerialPeekChar.noChars                     code  fffc1458 18
  SerialPeekChar.xit                         code  fffc145c 18
  SerialPeekCharDirect                       code  fffc1474 18
  SerialPeekCharDirect.0001                  code  fffc14b4 18
  SerialPeekCharDirect.xit                   code  fffc14b8 18
  SerialPutChar                              code  fffc14d0 18
  SerialPutChar.0001                         code  fffc14e4 18
  SerialPutChar.0002                         code  fffc14e0 18
  SerialPutChar.goSleep                      code  fffc1520 18
  SerialRcvCount                             code  fffc1548 18
  SerialRcvCount.xit                         code  fffc157c 18
  SerialService                              code  fffc12bc 18
  SerialServiceInit                          code  fffc12a4 18
  SerialServiceLoop                          code  fffc12d8 18
  SkipSpaces                                 code  fffc066c 18
  SkipSpaces.skip1                           code  fffc0690 18
  SkipSpaces.skip2                           code  fffc066c 18
  SwapContext                                code  fffc20d0 18
  SwapContext.noCtxSwitch                    code  fffc224c 18
  SwapContext.rsseg                          code  fffc219c 18
  SwapContext.savedAlready                   code  fffc2198 18
  SwapContext.svseg                          code  fffc217c 18
  SwitchIOFocus                             const  024820 19
  SysSema                                   const  024340 19
  TAB                                       const  000009 5
  TAB1                                       code  fffc3f28 18
  TAB10                                      code  fffc3fe2 18
  TAB10_1                                    code  fffc4052 18
  TAB1_1                                     code  fffc3fe6 18
  TAB2                                       code  fffc3f3a 18
  TAB2_1                                     code  fffc3ff0 18
  TAB4                                       code  fffc3f93 18
  TAB4_1                                     code  fffc401e 18
  TAB5                                       code  fffc3fcc 18
  TAB5_1                                     code  fffc4038 18
  TAB6                                       code  fffc3fcf 18
  TAB6_1                                     code  fffc403c 18
  TAB8                                       code  fffc3fd4 18
  TAB8_1                                     code  fffc4040 18
  TAB9                                       code  fffc3fde 18
  TAB9_1                                     code  fffc404e 18
  TC1                                        code  fffc5a18 18
  TC64CursorAddr                            const  ffd1df1c 33
  TCBContextSaved                           const  00028a 11
  TCBElapsedTime                            const  0002c0 11
  TCBEndTime                                const  0002b8 11
  TCBException                              const  0002c8 11
  TCBKbdBuf                                 const  000308 11
  TCBKbdHead                                const  000300 11
  TCBKbdState2                               code  800000000000027f 32
  TCBKbdTail                                const  000301 11
  TCBMsgD1                                  const  000298 11
  TCBMsgD2                                  const  0002a0 11
  TCBMsgD3                                  const  0002a8 11
  TCBName                                   const  0002f8 11
  TCBNext                                   const  0002d0 11
  TCBPrev                                   const  0002d8 11
  TCBPriority                               const  000289 11
  TCBResource                               const  000328 11
  TCBStackBot                               const  000290 11
  TCBStartTime                              const  0002b0 11
  TCBStatus                                 const  000288 11
  TCBTimeout                                const  0002e0 11
  TCBVidMem                                  code  80000000000001ff 32
  TCBVideoMem                               const  000330 11
  TCBWaitMbx                                const  00028c 11
  TCBepc                                    const  000280 11
  TCBpVideo                                 const  000338 11
  TCBsegs                                   const  000200 11
  TICKX                                      code  fffc5300 18
  TN1                                        code  fffc5a48 18
  TN2                                        code  fffc5a74 18
  TOOBIG                                     code  fffc5458 18
  TOUPB1                                     code  fffc5ae8 18
  TOUPBRT                                    code  fffc5b30 18
  TOUPBUF                                    code  fffc5ad4 18
  TOUPRET                                    code  fffc5b54 18
  TSNMRET                                    code  fffc5a94 18
  TSTC                                       code  fffc59e4 18
  TSTNUM                                     code  fffc5a30 18
  TSTV                                       code  fffc5018 18
  TSTVRT                                     code  fffc5094 18
  TS_DEAD                                   const  000002 3
  TS_MSGRDY                                 const  000004 4
  TS_NONE                                   const  000000 1
  TS_PREEMPT                                const  000020 7
  TS_READY                                  const  000001 2
  TS_RUNNING                                const  000080 9
  TS_TIMEOUT                                const  000010 6
  TS_WAITMSG                                const  000008 5
  TV1                                        code  fffc5080 18
  TV2                                        code  fffc5068 18
  TV3                                        code  fffc5048 18
  TXTBGN                                    const  031800 19
  TXTUNF                                    const  030004 19
  Tick                                      const  024330 19
  TimeoutList                               const  024328 19
  TinyBasic                                  code  fffc3c00 18
  UART                                      const  ffdc0a00 33
  UART_CMD                                  const  000008 5
  UART_STAT                                 const  000004 4
  UART_TRB                                  const  000000 1
  USRX                                       code  fffc5234 18
  UpdateCursorPos                            code  fffc19ec 18
  UserStart                                  code  fffc0168 18
  UserStart2                                 code  fffc0198 18
  UserStart2.0002                            code  fffc01e0 18
  UserStart2.0003                            code  fffc0230 18
  UserStart2.0004                            code  fffc021c 18
  UserStart2.0005                            code  fffc0200 18
  VARBGN                                    const  030008 19
  VAREND                                    const  03000c 19
  VIA                                       const  ffdc0600 33
  VIA_ACR                                   const  00002c 7
  VIA_DDRA                                  const  00000c 5
  VIA_IER                                   const  000038 7
  VIA_IFR                                   const  000034 7
  VIA_PA                                    const  000004 4
  VIA_PARAW                                 const  00003c 7
  VIA_PCR                                   const  000030 7
  VIA_T1CH                                  const  000014 6
  VIA_T1CL                                  const  000010 6
  ViaFuncTbl                                 code  fffc1658 18
  ViaIRQ                                     code  fffc17b4 18
  ViaIRQ.0003                                code  fffc1808 18
  ViaInit                                    code  fffc1758 18
  VideoClearScreen                           code  fffc1988 18
  VideoClearScreen.0001                      code  fffc19b8 18
  VideoFuncTbl                               code  fffc1810 18
  VideoHomeCursor                            code  fffc19cc 18
  VideoIRQ                                   code  fffc1d00 18
  VideoIRQ.0003                              code  fffc1d00 18
  VideoInit                                  code  fffc1910 18
  VideoPutChar                               code  fffc1a2c 18
  VideoPutChar.backspace                     code  8000000000000195 32
  VideoPutChar.cursorDown                    code  8000000000000194 32
  VideoPutChar.cursorLeft                    code  8000000000000192 32
  VideoPutChar.cursorRight                   code  8000000000000191 32
  VideoPutChar.cursorUp                      code  8000000000000193 32
  VideoPutChar.delete                        code  8000000000000196 32
  VideoPutChar.doCR                          code  800000000000018e 32
  VideoPutChar.doCls                         code  8000000000000190 32
  VideoPutChar.doLF                          code  800000000000018f 32
  VirtToPhys                                 code  fffc1074 18
  VirtToPhys.notMapped                       code  fffc10a8 18
  WAITIRQ                                    code  fffc42f0 18
  WAITMSG                                    code  fffc5cac 18
  WAITMSG.0001                               code  fffc5ce4 18
  WAITMSG.0002                               code  fffc5cd8 18
  WAITMSG.err                                code  fffc5d6c 18
  WAITMSG.paren                              code  fffc5d78 18
  WSTART                                     code  fffc3d20 18
  XOFF                                      const  000013 6
  XON                                       const  000011 6
  XP11                                       code  fffc4d5c 18
  XP12                                       code  fffc4d74 18
  XP13                                       code  fffc4d8c 18
  XP14                                       code  fffc4da4 18
  XP15                                       code  fffc4dbc 18
  XP16                                       code  fffc4dd4 18
  XP17                                       code  fffc4e14 18
  XP18                                       code  fffc4e2c 18
  XP21                                       code  fffc4e7c 18
  XP22                                       code  fffc4e88 18
  XP23                                       code  fffc4e8c 18
  XP24                                       code  fffc4ea8 18
  XP25                                       code  fffc4ebc 18
  XP26                                       code  fffc4ec8 18
  XP31                                       code  fffc4ef8 18
  XP34                                       code  fffc4f28 18
  XP35                                       code  fffc4f4c 18
  XP40                                       code  fffc4fa4 18
  XP41                                       code  fffc4fc0 18
  XP42                                       code  fffc4ffc 18
  XP43                                       code  fffc5008 18
  XP45                                       code  fffc4ed4 18
  XP46                                       code  fffc4fcc 18
  XP47                                       code  fffc4f70 18
  XPRT0                                      code  fffc4dec 18
  XPRT1                                      code  fffc4e00 18
  XP_AND                                     code  fffc4c6c 18
  XP_AND1                                    code  fffc4c4c 18
  XP_ANDX                                    code  fffc4c80 18
  XP_OR                                      code  fffc4c0c 18
  XP_OR1                                     code  fffc4bec 18
  XP_ORX                                     code  fffc4c20 18
  YIELD0                                     code  fffc4110 18
  _KeybdGetBufferStatus                      code  fffc3b74 18
  _KeybdGetBufferStatus.empty                code  fffc3b9c 18
  _KeybdGetBufferedScancode                  code  fffc3ba4 18
  _KeybdGetBufferedScancode.empty            code  fffc3bd8 18
  _KeybdGetID                                code  fffc3914 18
  _KeybdGetID.0001                           code  fffc3958 18
  _KeybdGetID.notKbd                         code  fffc3974 18
  _KeybdGetScancode                          code  fffc3a60 18
  _KeybdGetStatus                            code  fffc3a38 18
  _KeybdID                                   code  8000000000000277 32
  _KeybdInit                                 code  fffc37a8 18
  _KeybdInit.0002                            code  fffc37d8 18
  _KeybdInit.0004                            code  fffc3880 18
  _KeybdInit.config                          code  fffc3824 18
  _KeybdInit.keybdErr                        code  fffc3868 18
  _KeybdInit.ledxit                          code  fffc38ac 18
  _KeybdInit.tryAgain                        code  fffc385c 18
  _KeybdInit.xit                             code  fffc38c8 18
  _KeybdPeekScancode                         code  fffc3a4c 18
  _KeybdRecvByte                             code  fffc397c 18
  _KeybdRecvByte.0003                        code  fffc3988 18
  _KeybdRecvByte.0004                        code  fffc39c0 18
  _KeybdSendByte                             code  fffc39d0 18
  _KeybdSetLED                               code  fffc38d4 18
  _KeybdWaitTx                               code  fffc39e4 18
  _KeybdWaitTx.0001                          code  fffc39f0 18
  _KeybdWaitTx.0002                          code  fffc3a28 18
  _MicroDelay                                code  fffc082c 18
  _MicroDelay.0001                           code  fffc0830 18
  _clr                                       code  fffc4264 18
  _cls                                       code  80000000000002fc 32
  _end_init_data                           rodata  fffc6000 32
  _keybdControlCodes                         code  fffc35a8 18
  _keybdExtendedCodes                        code  fffc3628 18
  _rdcf                                      code  80000000000002fe 32
  _shiftedScanCodes                          code  fffc34a8 18
  _unshiftedScanCodes                        code  fffc33a8 18
  a2h1                                       code  fffc48b0 18
  asciiToHex                                 code  fffc48a4 18
  begin_init_data                          rodata  fffc6000 32
  clearVars                                  code  fffc426c 18
  clearVars.cv1                              code  fffc428c 18
  datAttr                                    code  fffc0248 18
  doMem                                      code  fffc05a0 18
  doMem.loop                                 code  fffc0604 18
  doMem.loop2                                code  fffc05dc 18
  ec1                                        code  fffc544c 18
  end_init_data                            rodata  fffc6000 32
  findVar                                    code  fffc5164 18
  fl1                                        code  fffc55f8 18
  flt10                                      code  fffc0a18 18
  flt20                                      code  fffc0a08 18
  flt50                                      code  fffc09f8 18
  fltMillion                                 code  fffc0dec 18
  fltOne                                     code  fffc0de4 18
  fltTen                                     code  fffc0de8 18
  fltToString                                code  fffc0a28 18
  fltToString.0001                           code  fffc0a88 18
  fltToString.0002                           code  fffc0b08 18
  fltToString.0003                           code  fffc0af4 18
  fltToString.0004                           code  fffc0b54 18
  fltToString.0005                           code  fffc0b4c 18
  fltToString.0006                           code  fffc0b34 18
  fltToString.0007                           code  fffc0b70 18
  fltToString.0008                           code  fffc0b84 18
  fltToString.0009                           code  fffc0b80 18
  fltToString.0010                           code  fffc0ba4 18
  fltToString.0011                           code  fffc0c30 18
  fltToString.0012                           code  fffc0be8 18
  fltToString.0013                           code  fffc0bd4 18
  fltToString.0014                           code  fffc0c04 18
  fltToString.0015                           code  fffc0c20 18
  fltToString.0016                           code  fffc0bbc 18
  fltToString.0017                           code  fffc0c28 18
  fltToString.0018                           code  fffc0c30 18
  fltToString.0019                           code  fffc0c64 18
  fltToString.0020                           code  fffc0c70 18
  fltToString.0021                           code  fffc0c94 18
  fltToString.0022                           code  fffc0ca0 18
  fltToString.0023                           code  fffc0cb0 18
  fltToString.0024                           code  fffc0cbc 18
  fltToString.0025                           code  fffc0ca8 18
  fltToString.0026                           code  fffc0cd0 18
  fltToString.0027                           code  fffc0cd8 18
  fltToString.0028                           code  fffc0ce0 18
  fltToString.0029                           code  fffc0cec 18
  fltToString.0030                           code  fffc0cf8 18
  fltToString.0031                           code  fffc0d04 18
  fltToString.0032                           code  fffc0d0c 18
  fltToString.0034                           code  fffc0d14 18
  fltToString.0035                           code  fffc0d20 18
  fltToString.0036                           code  fffc0d30 18
  fltToString.0037                           code  fffc0d3c 18
  fltToString.0038                           code  fffc0d44 18
  fltToString.0039                           code  fffc0d58 18
  fltToString.0040                           code  fffc0d4c 18
  fltToString.0041                           code  fffc0db4 18
  fltToString.0042                           code  fffc0d78 18
  fltToString.0043                           code  fffc0d88 18
  fltToString.0044                           code  fffc0d9c 18
  fltToString.0045                           code  fffc0d80 18
  fltToString.0046                           code  fffc0da8 18
  fltToString.0047                           code  fffc0db4 18
  fltToString.0048                           code  fffc0da0 18
  fltToString.0050                           code  fffc0dd4 18
  fltToString.0051                           code  fffc0dd0 18
  fltToString.0052                           code  fffc0dc0 18
  fltToString.inf                            code  fffc0a70 18
  fltToString.notZero                        code  fffc0ac4 18
  fltToString.pos                            code  fffc0ab0 18
  fltToString.prt                            code  fffc0d68 18
  fputc                                      code  fffc02ec 18
  fv1                                        code  fffc51c4 18
  fv2                                        code  fffc51d8 18
  fv3                                        code  fffc51bc 18
  fv4                                        code  fffc5180 18
  gen_rand                                   code  80000000000003c6 32
  getVarName                                 code  fffc50b8 18
  gfn1                                       code  fffc493c 18
  gfn2                                       code  fffc48d4 18
  gfn3                                       code  fffc4910 18
  gosub1                                     code  fffc4420 18
  gvn1                                       code  fffc5150 18
  gvn2                                       code  fffc5114 18
  gvn3                                       code  fffc5130 18
  gvn4                                       code  fffc50d8 18
  gvn6                                       code  fffc5104 18
  hKeybdMbx                                 const  024822 19
  isAlnum                                    code  fffc4ce8 18
  isAlpha                                    code  fffc4cb8 18
  isAlphaFalse                               code  fffc4ce0 18
  isAlphaTrue                                code  fffc4cd8 18
  isDigit                                    code  fffc4c98 18
  isDigitFalse                               code  fffc4cb0 18
  isDigitx                                   code  fffc4cfc 18
  mGetVideoPtr                               code  fffc1a80 18
  mGetVideoPtr.0001                          code  fffc1b18 18
  mGetVideoPtr.backspace                     code  fffc1c58 18
  mGetVideoPtr.bs0001                        code  fffc1cd0 18
  mGetVideoPtr.bs0002                        code  fffc1cbc 18
  mGetVideoPtr.cr1                           code  fffc1bc0 18
  mGetVideoPtr.cr2                           code  fffc1bbc 18
  mGetVideoPtr.cursorDown                    code  fffc1c1c 18
  mGetVideoPtr.cursorLeft                    code  fffc1bc4 18
  mGetVideoPtr.cursorRight                   code  fffc1b90 18
  mGetVideoPtr.cursorUp                      code  fffc1bf0 18
  mGetVideoPtr.del0001                       code  fffc1c80 18
  mGetVideoPtr.delete                        code  fffc1cec 18
  mGetVideoPtr.doCR                          code  fffc1b64 18
  mGetVideoPtr.doCls                         code  fffc1c4c 18
  mGetVideoPtr.doLF                          code  fffc1b7c 18
  mGetVideoPtr.doLF1                         code  fffc1af0 18
  mGetVideoPtr.saveX                         code  fffc1b4c 18
  mGetVideoPtr.saveY                         code  fffc1b3c 18
  mGetVideoPtr.xit                           code  fffc1b2c 18
  mbxs                                      const  020000 19
  mbxs_end                                  const  022000 19
  milliseconds                              const  014208 18
  missed_ticks                              const  024320 19
  msgBadGotoGosub                            code  fffc5f35 18
  msgBadKeybd                                code  8000000000000271 32
  msgBytesFree                               code  fffc5e6d 18
  msgCRLF                                    code  fffc09ee 18
  msgComma                                   code  fffc5e82 18
  msgDivZero                                 code  fffc5e44 18
  msgEnvFail                                 code  fffc5f9d 18
  msgExtraChars                              code  fffc5f7b 18
  msgInf                                     code  fffc0ddc 18
  msgInit                                    code  fffc5dcc 18
  msgInputVar                                code  fffc5ee4 18
  msgLineRange                               code  fffc5e95 18
  msgMonHelp                                 code  fffc0941 18
  msgNan                                     code  fffc0de0 18
  msgNextFor                                 code  fffc5f00 18
  msgNextVar                                 code  fffc5f12 18
  msgNumTooBig                               code  fffc5e31 18
  msgParen                                   code  fffc5fb7 18
  msgRNDBad                                  code  fffc5ec0 18
  msgReadError                               code  fffc5e17 18
  msgReady                                   code  fffc5e7a 18
  msgReadyList                               code  fffc305c 18
  msgRetWoGosub                              code  fffc5f51 18
  msgSYSBad                                  code  fffc5ed3 18
  msgStart                                   code  fffc0928 18
  msgTaskStart                               code  fffc09e0 18
  msgTimeoutList                             code  fffc308d 18
  msgTooBig                                  code  fffc5f67 18
  msgVar                                     code  fffc5eaa 18
  msgVarSpace                                code  fffc5e56 18
  msgWhat                                    code  fffc5e08 18
  msgs                                      const  010000 18
  nmeSerial                                  code  fffc1650 18
  prCRLF                                     code  fffc5888 18
  pword1                                     code  fffc4abc 18
  pword2                                     code  fffc4adc 18
  qToChk                                     code  fffc1d3a 18
  return1                                    code  fffc4498 18
  rnd1                                       code  fffc52b4 18
  rnd2                                       code  fffc52c4 18
  switchflag                                const  014200 18
  sysx1                                      code  fffc4bc0 18
  tah1                                       code  fffc4b14 18
  toAsciiHex                                 code  fffc4b04 18
  toUpper                                    code  fffc5b3c 18
  tstv_notfound                              code  fffc50a4 18
  usrJmp                                    const  0300a0 19

Undefined Symbols
  AUXIN                                      code  80000000000002b9 32
  AUXIN_INIT                                 code  8000000000000377 32
  AUXOUT                                     code  80000000000002b7 32
  AUXOUT_FLUSH                               code  8000000000000384 32
  AUXOUT_INIT                                code  800000000000037b 32
  ERETx                                      code  800000000000022b 32
  FMTK_Initialize                            code  80000000000001ad 32
  FMTK_PostMsg                               code  80000000000001b5 32
  FMTK_SetTaskPriority                       code  80000000000001b1 32
  FMTK_StartApp                              code  80000000000001b9 32
  KEYBD                                      code  800000000000026a 32
  KeybdIRQ.notAlt                            code  8000000000000284 32
  KillTask                                   code  80000000000001f9 32
  SDReadSector                               code  8000000000000378 32
  SDWriteSector                              code  800000000000037d 32
  TCBKbdState2                               code  800000000000027f 32
  TCBVidMem                                  code  80000000000001ff 32
  VideoPutChar.backspace                     code  8000000000000195 32
  VideoPutChar.cursorDown                    code  8000000000000194 32
  VideoPutChar.cursorLeft                    code  8000000000000192 32
  VideoPutChar.cursorRight                   code  8000000000000191 32
  VideoPutChar.cursorUp                      code  8000000000000193 32
  VideoPutChar.delete                        code  8000000000000196 32
  VideoPutChar.doCR                          code  800000000000018e 32
  VideoPutChar.doCls                         code  8000000000000190 32
  VideoPutChar.doLF                          code  800000000000018f 32
  _KeybdID                                   code  8000000000000277 32
  _cls                                       code  80000000000002fc 32
  _rdcf                                      code  80000000000002fe 32
  gen_rand                                   code  80000000000003c6 32
  msgBadKeybd                                code  8000000000000271 32

  Macro Name
 mDispIRQLive                              -842150451

     ldo      $v0,$FFD00000+440
     add     	$v0,$v0,#1
     sto      $v0,$FFD00000+440

 mGetCurrentTid                            -842150451

	csrrw	v0,#$181,x0
	and		v0,v0,#MAX_TID

 mHasFocus                                 -842150451

	ldi		$a0,#20
	ecall

 mPopTimeoutList                           -842150451

	sll		$t0,$v0,#LOG_TCBSZ		; tid to pointer
	lbu		$v1,TCBStatus[$t0]		; no longer a waiting status
	and		$t1,$v1,#TS_WAITMSG		; check if waiting for a message
	beqz	$t1,.noWait@
	mMbxRemoveTask							; remove task from mailbox list
.noWait@:
	and		$v1,$v1,#~(TS_WAITMSG|TS_TIMEOUT)
	stb		$v1,TCBStatus[$t0]
	ldw		$v1,TCBNext[$t0]			; get next task on timeout list
	stw		$v1,TimeoutList				; update list head
	ldi		$t1,#NR_TCB						; check valid handle
	bgeu	$v1,$t1,.done@
	ldi		$t1,#-1								;
	sll		$v1,$v1,#LOG_TCBSZ		; v1 = tid to pointer
	stw		$t1,TCBPrev[$v1]			; TimeoutList->prev = -1
.done@:
	ldi		$t1,#-1								; reset next and prev indexes
	stw		$t1,TCBNext[$t0]			; on popped task
	stw		$t1,TCBPrev[$t0]

 mSleep                                    1

	ldi		$a0,#5
	ldi		$a1,#0
	ecall

 mUnlockSemaphore                          1

	ldi		v0,#-1
	sw		v0,0

 mVideoGetPtr                              -842150451

	
	csrrw	v0,#$181,x0
	and		v0,v0,#MAX_TID
sll		$v0,$v0,#LOG_TCBSZ
	ldo		$v0,TCBpVideo[$v0]
	ldi		$v0,#$FFD00000

 mWaitForFocus                             -842150451

.WFF1@:
	
	ldi		$a0,#20
	ecall
bne		v1,x0,.HasFocus@
	call	SerialPeekChar	;Direct
	ldi		a0,#$14							; CTRL-T
	bne		$v0,$a0,.WFF2@
	call	SerialGetChar
	ldi		$a0,#21							; switch IO Focus
	ecall
	bra		.WFF1@
.WFF2@:
	
	ldi		$a0,#5
	ldi		$a1,#1
	ecall

	bra		.WFF1@
.HasFocus@:

0 compressable instructions
The top 1024 are:
Comp  Opcode  Count
